[{"id": "0911.1851", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Functional units for natural numbers", "comments": "17 pages; notational mistakes in tables 5 and 6 corrected; erroneous\n  definition at bottom of page 9 corrected", "journal-ref": null, "doi": null, "report-no": "PRG0913", "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Interaction with services provided by an execution environment forms part of\nthe behaviours exhibited by instruction sequences under execution. Mechanisms\nrelated to the kind of interaction in question have been proposed in the\nsetting of thread algebra. Like thread, service is an abstract behavioural\nconcept. The concept of a functional unit is similar to the concept of a\nservice, but more concrete. A state space is inherent in the concept of a\nfunctional unit, whereas it is not inherent in the concept of a service. In\nthis paper, we establish the existence of a universal computable functional\nunit for natural numbers and related results.\n", "versions": [{"version": "v1", "created": "Tue, 10 Nov 2009 08:09:33 GMT"}, {"version": "v2", "created": "Sat, 8 May 2010 12:36:02 GMT"}, {"version": "v3", "created": "Sun, 17 Oct 2010 20:26:13 GMT"}], "update_date": "2010-10-19", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0911.2327", "submitter": "EPTCS", "authors": "Ozan Kahramano\\u{g}ullari, Luca Cardelli, Emmanuelle Caron", "title": "An Intuitive Automated Modelling Interface for Systems Biology", "comments": null, "journal-ref": "EPTCS 9, 2009, pp. 73-86", "doi": "10.4204/EPTCS.9.9", "report-no": null, "categories": "cs.PL cs.CE cs.LO q-bio.QM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a natural language interface for building stochastic pi calculus\nmodels of biological systems. In this language, complex constructs describing\nbiochemical events are built from basic primitives of association, dissociation\nand transformation. This language thus allows us to model biochemical systems\nmodularly by describing their dynamics in a narrative-style language, while\nmaking amendments, refinements and extensions on the models easy. We\ndemonstrate the language on a model of Fc-gamma receptor phosphorylation during\nphagocytosis. We provide a tool implementation of the translation into a\nstochastic pi calculus language, Microsoft Research's SPiM.\n", "versions": [{"version": "v1", "created": "Thu, 12 Nov 2009 08:56:05 GMT"}], "update_date": "2009-11-13", "authors_parsed": [["Kahramano\u011fullari", "Ozan", ""], ["Cardelli", "Luca", ""], ["Caron", "Emmanuelle", ""]]}, {"id": "0911.2423", "submitter": "Matt Purkeypile", "authors": "Matt Purkeypile", "title": "Cove: A Practical Quantum Computer Programming Framework", "comments": "Doctoral dissertation, 272 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While not yet in commercial existence, quantum computers have the ability to\nsolve certain classes of problems that are not efficiently solvable on existing\nTuring Machine based (classical) computers. For quantum computers to be of use,\nmethods of programming them must exist. Proposals exist for programming quantum\ncomputers, but all of the existing ones suffer from flaws that make them\nimpractical in commercial software development environments. Cove is a\nframework for programming quantum computers that extends existing classical\nlanguages to allow for quantum computation, thus providing a quantum computing\ntoolkit for commercial software developers. Since the target users of Cove are\ncommercial developers, it is an object oriented framework that can be used by\nmultiple languages and also places emphasis on complete documentation. The\nfocus of Cove is not so much on the software product, but on the fundamental\nconcepts that make quantum computing practical for common developers.\n", "versions": [{"version": "v1", "created": "Thu, 12 Nov 2009 05:36:23 GMT"}], "update_date": "2009-11-13", "authors_parsed": [["Purkeypile", "Matt", ""]]}, {"id": "0911.2829", "submitter": "EPTCS", "authors": "S. Barry Cooper, Vincent Danos", "title": "Proceedings Fifth Workshop on Developments in Computational\n  Models--Computational Models From Nature", "comments": null, "journal-ref": "EPTCS 9, 2009", "doi": "10.4204/EPTCS.9", "report-no": null, "categories": "cs.CE cs.AI cs.CC cs.FL cs.LO cs.NE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The special theme of DCM 2009, co-located with ICALP 2009, concerned\nComputational Models From Nature, with a particular emphasis on computational\nmodels derived from physics and biology. The intention was to bring together\ndifferent approaches - in a community with a strong foundational background as\nproffered by the ICALP attendees - to create inspirational cross-boundary\nexchanges, and to lead to innovative further research. Specifically DCM 2009\nsought contributions in quantum computation and information, probabilistic\nmodels, chemical, biological and bio-inspired ones, including spatial models,\ngrowth models and models of self-assembly. Contributions putting to the test\nlogical or algorithmic aspects of computing (e.g., continuous computing with\ndynamical systems, or solid state computing models) were also very much\nwelcomed.\n", "versions": [{"version": "v1", "created": "Sun, 15 Nov 2009 03:35:32 GMT"}], "update_date": "2009-11-17", "authors_parsed": [["Cooper", "S. Barry", ""], ["Danos", "Vincent", ""]]}, {"id": "0911.2899", "submitter": "Roberto Bagnara", "authors": "Michael A. Covington (Institute for Artificial Intelligence, The\n  University of Georgia, Athens, Georgia, U.S.A.), Roberto Bagnara (Department\n  of Mathematics, University of Parma, and BUGSENG srl, Italy), Richard A.\n  O'Keefe (Department of Computer Science, University of Otago, Dunedin, New\n  Zealand), Jan Wielemaker (Department of Computer Science, VU University\n  Amsterdam, The Netherlands), Simon Price (Intelligent Systems Laboratory,\n  University of Bristol, United Kingdom)", "title": "Coding Guidelines for Prolog", "comments": "39 pages, 4 figures, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Coding standards and good practices are fundamental to a disciplined approach\nto software projects, whatever programming languages they employ. Prolog\nprogramming can benefit from such an approach, perhaps more than programming in\nother languages. Despite this, no widely accepted standards and practices seem\nto have emerged up to now. The present paper is a first step towards filling\nthis void: it provides immediate guidelines for code layout, naming\nconventions, documentation, proper use of Prolog features, program development,\ndebugging and testing. Presented with each guideline is its rationale and,\nwhere sensible options exist, illustrations of the relative pros and cons for\neach alternative. A coding standard should always be selected on a per-project\nbasis, based on a host of issues pertinent to any given programming project;\nfor this reason the paper goes beyond the mere provision of normative\nguidelines by discussing key factors and important criteria that should be\ntaken into account when deciding on a fully-fledged coding standard for the\nproject.\n", "versions": [{"version": "v1", "created": "Sun, 15 Nov 2009 18:21:41 GMT"}, {"version": "v2", "created": "Fri, 19 Nov 2010 20:25:29 GMT"}, {"version": "v3", "created": "Tue, 17 May 2011 14:30:39 GMT"}], "update_date": "2011-05-18", "authors_parsed": [["Covington", "Michael A.", "", "Institute for Artificial Intelligence, The\n  University of Georgia, Athens, Georgia, U.S.A."], ["Bagnara", "Roberto", "", "Department\n  of Mathematics, University of Parma, and BUGSENG srl, Italy"], ["O'Keefe", "Richard A.", "", "Department of Computer Science, University of Otago, Dunedin, New\n  Zealand"], ["Wielemaker", "Jan", "", "Department of Computer Science, VU University\n  Amsterdam, The Netherlands"], ["Price", "Simon", "", "Intelligent Systems Laboratory,\n  University of Bristol, United Kingdom"]]}, {"id": "0911.2993", "submitter": "Andrew Gacek", "authors": "Andrew Gacek, Dale Miller, Gopalan Nadathur", "title": "A two-level logic approach to reasoning about computations", "comments": "To appear in the Journal of Automated Reasoning", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Relational descriptions have been used in formalizing diverse computational\nnotions, including, for example, operational semantics, typing, and acceptance\nby non-deterministic machines. We therefore propose a (restricted) logical\ntheory over relations as a language for specifying such notions. Our\nspecification logic is further characterized by an ability to explicitly treat\nbinding in object languages. Once such a logic is fixed, a natural next\nquestion is how we might prove theorems about specifications written in it. We\npropose to use a second logic, called a reasoning logic, for this purpose. A\nsatisfactory reasoning logic should be able to completely encode the\nspecification logic. Associated with the specification logic are various\nnotions of binding: for quantifiers within formulas, for eigenvariables within\nsequents, and for abstractions within terms. To provide a natural treatment of\nthese aspects, the reasoning logic must encode binding structures as well as\ntheir associated notions of scope, free and bound variables, and\ncapture-avoiding substitution. Further, to support arguments about provability,\nthe reasoning logic should possess strong mechanisms for constructing proofs by\ninduction and co-induction. We provide these capabilities here by using a logic\ncalled G which represents relations over lambda-terms via definitions of atomic\njudgments, contains inference rules for induction and co-induction, and\nincludes a special generic quantifier. We show how provability in the\nspecification logic can be transparently encoded in G. We also describe an\ninteractive theorem prover called Abella that implements G and this two-level\nlogic approach and we present several examples that demonstrate the efficacy of\nAbella in reasoning about computations.\n", "versions": [{"version": "v1", "created": "Mon, 16 Nov 2009 09:56:44 GMT"}, {"version": "v2", "created": "Wed, 1 Sep 2010 08:39:26 GMT"}], "update_date": "2010-09-02", "authors_parsed": [["Gacek", "Andrew", ""], ["Miller", "Dale", ""], ["Nadathur", "Gopalan", ""]]}, {"id": "0911.3674", "submitter": "Sebastian Maneth", "authors": "Omer Gim\\'enez, Guillem Godoy, Sebastian Maneth", "title": "Deciding Regularity of the Set of Instances of a Set of Terms with\n  Regular Constraints is EXPTIME-Complete", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SC cs.CC cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Finite-state tree automata are a well studied formalism for representing term\nlanguages. This paper studies the problem of determining the regularity of the\nset of instances of a finite set of terms with variables, where each variable\nis restricted to instantiations of a regular set given by a tree automaton. The\nproblem was recently proved decidable, but with an unknown complexity. Here,\nthe exact complexity of the problem is determined by proving\nEXPTIME-completeness. The main contribution is a new, exponential time\nalgorithm that performs various exponential transformations on the involved\nterms and tree automata, and decides regularity by analyzing formulas over\ninequality and height predicates.\n", "versions": [{"version": "v1", "created": "Wed, 18 Nov 2009 23:02:12 GMT"}], "update_date": "2009-11-20", "authors_parsed": [["Gim\u00e9nez", "Omer", ""], ["Godoy", "Guillem", ""], ["Maneth", "Sebastian", ""]]}, {"id": "0911.4047", "submitter": "Elvira Albert", "authors": "G. Puebla and E. Albert and M. Hermenegildo", "title": "Efficient Local Unfolding with Ancestor Stacks", "comments": "Number of pages: 32 Number of figures: 7 Number of Tables: 3", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The most successful unfolding rules used nowadays in the partial evaluation\nof logic programs are based on well quasi orders (wqo) applied over (covering)\nancestors, i.e., a subsequence of the atoms selected during a derivation.\nAncestor (sub)sequences are used to increase the specialization power of\nunfolding while still guaranteeing termination and also to reduce the number of\natoms for which the wqo has to be checked. Unfortunately, maintaining the\nstructure of the ancestor relation during unfolding introduces significant\noverhead. We propose an efficient, practical local unfolding rule based on the\nnotion of covering ancestors which can be used in combination with a wqo and\nallows a stack-based implementation without losing any opportunities for\nspecialization. Using our technique, certain non-leftmost unfoldings are\nallowed as long as local unfolding is performed, i.e., we cover depth-first\nstrategies.\n", "versions": [{"version": "v1", "created": "Fri, 20 Nov 2009 13:44:59 GMT"}], "update_date": "2009-11-23", "authors_parsed": [["Puebla", "G.", ""], ["Albert", "E.", ""], ["Hermenegildo", "M.", ""]]}, {"id": "0911.4051", "submitter": "Pablo Arrighi", "authors": "Pablo Arrighi, Gilles Dowek", "title": "A computational definition of the notion of vectorial space", "comments": "14 pages, latex", "journal-ref": "Proc. of 5th International Workshop on Rewriting Logic and its\n  Applications 2004 (WRLA) and ENTCS 117, 249-261, (2005).", "doi": null, "report-no": null, "categories": "cs.LO cs.PL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We usually define an algebraic structure by a set, some operations defined on\nthis set and some propositions that the algebraic structure must validate. In\nsome cases, we can replace these propositions by an algorithm on terms\nconstructed upon these operations that the algebraic structure must validate.\nWe show in this note that this is the case for the notions of vectorial space\nand bilinear operation. KEYWORDS: Rewrite system, vector space, bilinear\noperation, tensorial product, semantics, quantum programming languages,\nprobabilistic programming languages.\n", "versions": [{"version": "v1", "created": "Fri, 20 Nov 2009 13:56:14 GMT"}], "update_date": "2009-11-23", "authors_parsed": [["Arrighi", "Pablo", ""], ["Dowek", "Gilles", ""]]}, {"id": "0911.4203", "submitter": "Mathieu Boespflug", "authors": "Mathieu Boespflug (LIX)", "title": "From Self-Interpreters to Normalization by Evaluation", "comments": null, "journal-ref": "2009 Workshop on Normalization by Evaluation, Los Angeles :\n  \\'Etats-Unis d'Am\\'erique (2009)", "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We characterize normalization by evaluation as the composition of a\nself-interpreter with a self-reducer using a special representation scheme, in\nthe sense of Mogensen (1992). We do so by deriving in a systematic way an\nuntyped normalization by evaluation algorithm from a standard interpreter for\nthe ?-calculus. The derived algorithm is not novel and indeed other published\nalgorithms may be obtained in the same manner through appropriate adaptations\nto the representation scheme.\n", "versions": [{"version": "v1", "created": "Sat, 21 Nov 2009 21:19:33 GMT"}], "update_date": "2009-11-24", "authors_parsed": [["Boespflug", "Mathieu", "", "LIX"]]}, {"id": "0911.4985", "submitter": "EPTCS", "authors": "Mariangiola Dezani-Ciancaglini (Dipartimento di Informatica,\n  Universit\\`a di Torino), Paola Giannini (Dipartimento di Informatica,\n  Universit\\`a del Piemonte Orientale), Angelo Troina (Dipartimento di\n  Informatica, Universit\\`a di Torino)", "title": "A Type System for a Stochastic CLS", "comments": null, "journal-ref": "EPTCS 11, 2009, pp. 91-105", "doi": "10.4204/EPTCS.11.6", "report-no": null, "categories": "cs.FL cs.PL q-bio.MN q-bio.QM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Stochastic Calculus of Looping Sequences is suitable to describe the\nevolution of microbiological systems, taking into account the speed of the\ndescribed activities. We propose a type system for this calculus that models\nhow the presence of positive and negative catalysers can modify these speeds.\nWe claim that types are the right abstraction in order to represent the\ninteraction between elements without specifying exactly the element positions.\nOur claim is supported through an example modelling the lactose operon.\n", "versions": [{"version": "v1", "created": "Thu, 26 Nov 2009 00:24:08 GMT"}], "update_date": "2009-11-30", "authors_parsed": [["Dezani-Ciancaglini", "Mariangiola", "", "Dipartimento di Informatica,\n  Universit\u00e0 di Torino"], ["Giannini", "Paola", "", "Dipartimento di Informatica,\n  Universit\u00e0 del Piemonte Orientale"], ["Troina", "Angelo", "", "Dipartimento di\n  Informatica, Universit\u00e0 di Torino"]]}, {"id": "0911.5018", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Autosolvability of halting problem instances for instruction sequences", "comments": "18 pages; notational mistakes in tables 5 and 6 corrected; erroneous\n  definition in last paragraph of page 11 corrected", "journal-ref": null, "doi": null, "report-no": "PRG0914", "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We position Turing's result regarding the undecidability of the halting\nproblem as a result about programs rather than machines. The mere requirement\nthat a program of a certain kind must solve the halting problem for all\nprograms of that kind leads to a contradiction in the case of a recent\nunsolvability result regarding the halting problem for programs. In this paper,\nwe investigate this autosolvability requirement in a setting in which programs\ntake the form of instruction sequences.\n", "versions": [{"version": "v1", "created": "Thu, 26 Nov 2009 07:32:11 GMT"}, {"version": "v2", "created": "Sat, 8 May 2010 12:39:24 GMT"}, {"version": "v3", "created": "Sun, 17 Oct 2010 20:33:05 GMT"}], "update_date": "2010-10-19", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0911.5203", "submitter": "Xiaochu Qi", "authors": "Xiaochu Qi", "title": "An Implementation of the Language Lambda Prolog Organized around\n  Higher-Order Pattern Unification", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This thesis concerns the implementation of Lambda Prolog, a higher-order\nlogic programming language that supports the lambda-tree syntax approach to\nrepresenting and manipulating formal syntactic objects. Lambda Prolog achieves\nits functionality by extending a Prolog-like language by using typed lambda\nterms as data structures that it then manipulates via higher-order unification\nand some new program-level abstraction mechanisms. These additional features\nraise new implementation questions that must be adequately addressed for Lambda\nProlog to be an effective programming tool. We consider these questions here,\nproviding eventually a virtual machine and compilation based realization. A key\nidea is the orientation of the computation model of Lambda Prolog around a\nrestricted version of higher-order unification with nice algorithmic properties\nand appearing to encompass most interesting applications. Our virtual machine\nembeds a treatment of this form of unification within the structure of the\nWarren Abstract Machine that is used in traditional Prolog implementations.\nAlong the way, we treat various auxiliary issues such as the low-level\nrepresentation of lambda terms, the implementation of reduction on such terms\nand the optimized processing of types in computation. We also develop an actual\nimplementation of Lambda Prolog called Teyjus Version 2. A characteristic of\nthis system is that it realizes an emulator for the virtual machine in the C\nlanguage a compiler in the OCaml language. We present a treatment of the\nsoftware issues that arise from this kind of mixing of languages within one\nsystem and we discuss issues relevant to the portability of our virtual machine\nemulator across arbitrary architectures. Finally, we assess the the efficacy of\nour various design ideas through experiments carried out using the system.\n", "versions": [{"version": "v1", "created": "Fri, 27 Nov 2009 06:18:15 GMT"}], "update_date": "2009-11-30", "authors_parsed": [["Qi", "Xiaochu", ""]]}, {"id": "0911.5444", "submitter": "EPTCS", "authors": "Marco Carbone (IT University of Copenhagen), Joshua Guttman (Worcester\n  Polytechnic Institute)", "title": "Choreographies with Secure Boxes and Compromised Principals", "comments": null, "journal-ref": "EPTCS 12, 2009, pp. 1-15", "doi": "10.4204/EPTCS.12.1", "report-no": null, "categories": "cs.CR cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We equip choreography-level session descriptions with a simple abstraction of\na security infrastructure. Message components may be enclosed within (possibly\nnested) \"boxes\" annotated with the intended source and destination of those\ncomponents. The boxes are to be implemented with cryptography. Strand spaces\nprovide a semantics for these choreographies, in which some roles may be played\nby compromised principals. A skeleton is a partially ordered structure\ncontaining local behaviors (strands) executed by regular (non-compromised)\nprincipals. A skeleton is realized if it contains enough regular strands so\nthat it could actually occur, in combination with any possible activity of\ncompromised principals. It is delivery guaranteed (DG) realized if, in\naddition, every message transmitted to a regular participant is also delivered.\nWe define a novel transition system on skeletons, in which the steps add\nregular strands. These steps solve tests, i.e. parts of the skeleton that could\nnot occur without additional regular behavior. We prove three main results\nabout the transition system. First, each minimal DG realized skeleton is\nreachable, using the transition system, from any skeleton it embeds. Second, if\nno step is possible from a skeleton A, then A is DG realized. Finally, if a DG\nrealized B is accessible from A, then B is minimal. Thus, the transition system\nprovides a systematic way to construct the possible behaviors of the\nchoreography, in the presence of compromised principals.\n", "versions": [{"version": "v1", "created": "Sun, 29 Nov 2009 00:20:33 GMT"}], "update_date": "2009-12-01", "authors_parsed": [["Carbone", "Marco", "", "IT University of Copenhagen"], ["Guttman", "Joshua", "", "Worcester\n  Polytechnic Institute"]]}, {"id": "0911.5449", "submitter": "EPTCS", "authors": "Luca Padovani (University of Urbino)", "title": "Session Types at the Mirror", "comments": null, "journal-ref": "EPTCS 12, 2009, pp. 71-86", "doi": "10.4204/EPTCS.12.5", "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We (re)define session types as projections of process behaviors with respect\nto the communication channels they use. In this setting, we give session types\na semantics based on fair testing. The outcome is a unified theory of\nbehavioral types that shares common aspects with conversation types and that\nencompass features of both dyadic and multi-party session types. The point of\nview we provide sheds light on the nature of session types and gives us a\nchance to reason about them in a framework where every notion, from\nwell-typedness to the subtyping relation between session types, is semantically\n-rather than syntactically- grounded.\n", "versions": [{"version": "v1", "created": "Sun, 29 Nov 2009 00:35:42 GMT"}], "update_date": "2009-12-01", "authors_parsed": [["Padovani", "Luca", "", "University of Urbino"]]}]