[{"id": "0807.1211", "submitter": "James Cheney", "authors": "James Cheney", "title": "Flux: FunctionaL Updates for XML (extended report)", "comments": "Extended version of ICFP 2008 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  XML database query languages have been studied extensively, but XML database\nupdates have received relatively little attention, and pose many challenges to\nlanguage design. We are developing an XML update language called Flux, which\nstands for FunctionaL Updates for XML, drawing upon ideas from functional\nprogramming languages. In prior work, we have introduced a core language for\nFlux with a clear operational semantics and a sound, decidable static type\nsystem based on regular expression types.\n  Our initial proposal had several limitations. First, it lacked support for\nrecursive types or update procedures. Second, although a high-level source\nlanguage can easily be translated to the core language, it is difficult to\npropagate meaningful type errors from the core language back to the source.\nThird, certain updates are well-formed yet contain path errors, or ``dead''\nsubexpressions which never do any useful work. It would be useful to detect\npath errors, since they often represent errors or optimization opportunities.\n  In this paper, we address all three limitations. Specifically, we present an\nimproved, sound type system that handles recursion. We also formalize a source\nupdate language and give a translation to the core language that preserves and\nreflects typability. We also develop a path-error analysis (a form of dead-code\nanalysis) for updates.\n", "versions": [{"version": "v1", "created": "Tue, 8 Jul 2008 17:10:51 GMT"}], "update_date": "2008-07-09", "authors_parsed": [["Cheney", "James", ""]]}, {"id": "0807.3451", "submitter": "Etienne Payet", "authors": "Etienne Payet and Fred Mesnard", "title": "A Non-Termination Criterion for Binary Constraint Logic Programs", "comments": "32 pages. Long version of a paper accepted for publication in Theory\n  and Practice of Logic Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  On the one hand, termination analysis of logic programs is now a fairly\nestablished research topic within the logic programming community. On the other\nhand, non-termination analysis seems to remain a much less attractive subject.\nIf we divide this line of research into two kinds of approaches: dynamic versus\nstatic analysis, this paper belongs to the latter. It proposes a criterion for\ndetecting non-terminating atomic queries with respect to binary CLP rules,\nwhich strictly generalizes our previous works on this subject. We give a\ngeneric operational definition and an implemented logical form of this\ncriterion. Then we show that the logical form is correct and complete with\nrespect to the operational definition.\n", "versions": [{"version": "v1", "created": "Tue, 22 Jul 2008 13:51:33 GMT"}, {"version": "v2", "created": "Fri, 12 Dec 2008 11:26:03 GMT"}, {"version": "v3", "created": "Sat, 10 Jan 2009 11:09:46 GMT"}], "update_date": "2009-01-10", "authors_parsed": [["Payet", "Etienne", ""], ["Mesnard", "Fred", ""]]}, {"id": "0807.3879", "submitter": "Alessandra Di Pierro", "authors": "Alessandra Di Pierro, Chris Hankin and Herbert Wiklicky", "title": "Quantifying Timing Leaks and Cost Optimisation", "comments": "16 pages, 2 figures, 4 tables. A shorter version is included in the\n  proceedings of ICICS'08 - 10th International Conference on Information and\n  Communications Security, 20-22 October, 2008 Birmingham, UK", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a new notion of security against timing attacks where the attacker\nis able to simultaneously observe the execution time of a program and the\nprobability of the values of low variables. We then show how to measure the\nsecurity of a program with respect to this notion via a computable estimate of\nthe timing leakage and use this estimate for cost optimisation.\n", "versions": [{"version": "v1", "created": "Thu, 24 Jul 2008 13:17:19 GMT"}], "update_date": "2008-07-25", "authors_parsed": [["Di Pierro", "Alessandra", ""], ["Hankin", "Chris", ""], ["Wiklicky", "Herbert", ""]]}, {"id": "0807.3979", "submitter": "Maria Chiara Meo", "authors": "Maurizio Gabbrielli, Maria Chiara Meo, Paolo Tacchella", "title": "Unfolding in CHR", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program transformation is an appealing technique which allows to improve\nrun-time efficiency, space-consumption and more generally to optimize a given\nprogram. Essentially it consists of a sequence of syntactic program\nmanipulations which preserves some kind of semantic equivalence. One of the\nbasic operations which is used by most program transformation systems is\nunfolding which consists in the replacement of a procedure call by its\ndefinition. While there is a large body of literature on transformation and\nunfolding of sequential programs, very few papers have addressed this issue for\nconcurrent languages and, to the best of our knowledge, no other has considered\nunfolding of CHR programs.\n  This paper defines a correct unfolding system for CHR programs. We define an\nunfolding rule, show its correctness and discuss some conditions which can be\nused to delete an unfolded rule while preserving the program meaning. We prove\nthat confluence and termination properties are preserved by the above\ntransformations.\n", "versions": [{"version": "v1", "created": "Fri, 25 Jul 2008 15:21:46 GMT"}], "update_date": "2008-07-28", "authors_parsed": [["Gabbrielli", "Maurizio", ""], ["Meo", "Maria Chiara", ""], ["Tacchella", "Paolo", ""]]}]