[{"id": "0801.0133", "submitter": "Alexandr Savinov", "authors": "Alexandr Savinov", "title": "An Approach to Programming Based on Concepts", "comments": "49 pages. Related papers: http://conceptoriented.com", "journal-ref": "Institute of Mathematics and Computer Science, Academy of Sciences\n  of Moldova, Technical Report RT0005, 2007", "doi": null, "report-no": "Technical Report RT0005", "categories": "cs.PL", "license": null, "abstract": "  In this paper we describe a new approach to programming which generalizes\nobject-oriented programming. It is based on using a new programming construct,\ncalled concept, which generalizes classes. Concept is defined as a pair of two\nclasses: one reference class and one object class. Each concept has a parent\nconcept which is specified using inclusion relation generalizing inheritance.\nWe describe several important mechanisms such as reference resolution, context\nstack, dual methods and life-cycle management, inheritance and polymorphism.\nThis approach to programming is positioned as a new programming paradigm and\ntherefore we formulate its main principles and rules.\n", "versions": [{"version": "v1", "created": "Sun, 30 Dec 2007 14:43:27 GMT"}], "update_date": "2008-01-03", "authors_parsed": [["Savinov", "Alexandr", ""]]}, {"id": "0801.0135", "submitter": "Alexandr Savinov", "authors": "Alexandr Savinov", "title": "Concepts and their Use for Modelling Objects and References in\n  Programming Languages", "comments": "43 pages. Related papers: http://conceptoriented.com/", "journal-ref": "Institute of Mathematics and Computer Science, Academy of Sciences\n  of Moldova, Technical Report RT0004, 2007", "doi": null, "report-no": "Technical Report RT0004", "categories": "cs.PL", "license": null, "abstract": "  In the paper a new programming construct, called concept, is introduced.\nConcept is pair of two classes: a reference class and an object class.\nInstances of the reference classes are passed-by-value and are intended to\nrepresent objects. Instances of the object class are passed-by-reference. An\napproach to programming where concepts are used instead of classes is called\nconcept-oriented programming (CoP). In CoP objects are represented and accessed\nindirectly by means of references. The structure of concepts describes a\nhierarchical space with a virtual address system. The paper describes this new\napproach to programming including such mechanisms as reference resolution,\ncomplex references, method interception, dual methods, life-cycle management\ninheritance and polymorphism.\n", "versions": [{"version": "v1", "created": "Sun, 30 Dec 2007 14:50:01 GMT"}], "update_date": "2008-01-03", "authors_parsed": [["Savinov", "Alexandr", ""]]}, {"id": "0801.0136", "submitter": "Alexandr Savinov", "authors": "Alexandr Savinov", "title": "Indirect Object Representation and Access by Means of Concepts", "comments": "8 pages. Related papers: http://conceptoriented.com/", "journal-ref": "Institute of Mathematics and Computer Science, Academy of Sciences\n  of Moldova, Technical Report, 2006", "doi": null, "report-no": null, "categories": "cs.PL", "license": null, "abstract": "  The paper describes a mechanism for indirect object representation and access\n(ORA) in programming languages. The mechanism is based on using a new\nprogramming construct which is referred to as concept. Concept consists of one\nobject class and one reference class both having their fields and methods. The\nobject class is the conventional class as defined in OOP with instances passed\nby reference. Instances of the reference class are passed by value and are\nintended to represent objects. The reference classes are used to describe how\nobjects have to be represented and accessed by providing custom format for\ntheir identifiers and custom access procedures. Such an approach to programming\nwhere concepts are used instead of classes is referred to as concept-oriented\nprogramming. It generalizes OOP and its main advantage is that it allows the\nprogrammer to describe not only the functionality of target objects but also\nintermediate functions which are executed behind the scenes as an object is\nbeing accessed.\n", "versions": [{"version": "v1", "created": "Sun, 30 Dec 2007 14:56:05 GMT"}], "update_date": "2008-01-03", "authors_parsed": [["Savinov", "Alexandr", ""]]}, {"id": "0801.0714", "submitter": "James Cheney", "authors": "James Cheney", "title": "Regular Expression Subtyping for XML Query and Update Languages", "comments": "ESOP 2008. Companion technical report with proofs", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DB", "license": null, "abstract": "  XML database query languages such as XQuery employ regular expression types\nwith structural subtyping. Subtyping systems typically have two presentations,\nwhich should be equivalent: a declarative version in which the subsumption rule\nmay be used anywhere, and an algorithmic version in which the use of\nsubsumption is limited in order to make typechecking syntax-directed and\ndecidable. However, the XQuery standard type system circumvents this issue by\nusing imprecise typing rules for iteration constructs and defining only\nalgorithmic typechecking, and another extant proposal provides more precise\ntypes for iteration constructs but ignores subtyping. In this paper, we\nconsider a core XQuery-like language with a subsumption rule and prove the\ncompleteness of algorithmic typechecking; this is straightforward for XQuery\nproper but requires some care in the presence of more precise iteration typing\ndisciplines. We extend this result to an XML update language we have introduced\nin earlier work.\n", "versions": [{"version": "v1", "created": "Fri, 4 Jan 2008 18:13:48 GMT"}], "update_date": "2008-01-07", "authors_parsed": [["Cheney", "James", ""]]}, {"id": "0801.0882", "submitter": "Nina Bohr", "authors": "Neil D. Jones and Nina Bohr", "title": "Call-by-value Termination in the Untyped lambda-calculus", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 1 (March 17,\n  2008) lmcs:915", "doi": "10.2168/LMCS-4(1:3)2008", "report-no": null, "categories": "cs.PL", "license": null, "abstract": "  A fully-automated algorithm is developed able to show that evaluation of a\ngiven untyped lambda-expression will terminate under CBV (call-by-value). The\n``size-change principle'' from first-order programs is extended to arbitrary\nuntyped lambda-expressions in two steps. The first step suffices to show CBV\ntermination of a single, stand-alone lambda;-expression. The second suffices to\nshow CBV termination of any member of a regular set of lambda-expressions,\ndefined by a tree grammar. (A simple example is a minimum function, when\napplied to arbitrary Church numerals.) The algorithm is sound and proven so in\nthis paper. The Halting Problem's undecidability implies that any sound\nalgorithm is necessarily incomplete: some lambda-expressions may in fact\nterminate under CBV evaluation, but not be recognised as terminating.\n  The intensional power of the termination algorithm is reasonably high. It\ncertifies as terminating many interesting and useful general recursive\nalgorithms including programs with mutual recursion and parameter exchanges,\nand Colson's ``minimum'' algorithm. Further, our type-free approach allows use\nof the Y combinator, and so can identify as terminating a substantial subset of\nPCF.\n", "versions": [{"version": "v1", "created": "Sun, 6 Jan 2008 19:01:02 GMT"}, {"version": "v2", "created": "Mon, 17 Mar 2008 12:55:44 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Jones", "Neil D.", ""], ["Bohr", "Nina", ""]]}, {"id": "0801.1219", "submitter": "Andrey Breslav", "authors": "Andrey Breslav", "title": "DSL development based on target meta-models. Using AST transformations\n  for automating semantic analysis in a textual DSL framework", "comments": "15 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": null, "abstract": "  This paper describes an approach to creating textual syntax for Do-\nmain-Specific Languages (DSL). We consider target meta-model to be the main\nartifact and hence to be developed first. The key idea is to represent analysis\nof textual syntax as a sequence of transformations. This is made by explicit\nopera- tions on abstract syntax trees (ATS), for which a simple language is\nproposed. Text-to-model transformation is divided into two parts: text-to-AST\n(developed by openArchitectureWare [1]) and AST-to-model (proposed by this\npaper). Our approach simplifies semantic analysis and helps to generate as much\nas possi- ble.\n", "versions": [{"version": "v1", "created": "Tue, 8 Jan 2008 12:28:18 GMT"}], "update_date": "2008-01-09", "authors_parsed": [["Breslav", "Andrey", ""]]}, {"id": "0801.1251", "submitter": "Andrew Pitts", "authors": "Andrew M. Pitts and Mark R. Shinwell", "title": "Generative Unbinding of Names", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 1 (March 18,\n  2008) lmcs:916", "doi": "10.2168/LMCS-4(1:4)2008", "report-no": null, "categories": "cs.PL cs.LO", "license": null, "abstract": "  This paper is concerned with the form of typed name binding used by the\nFreshML family of languages. Its characteristic feature is that a name binding\nis represented by an abstract (name,value)-pair that may only be deconstructed\nvia the generation of fresh bound names. The paper proves a new result about\nwhat operations on names can co-exist with this construct. In FreshML the only\nobservation one can make of names is to test whether or not they are equal.\nThis restricted amount of observation was thought necessary to ensure that\nthere is no observable difference between alpha-equivalent name binders. Yet\nfrom an algorithmic point of view it would be desirable to allow other\noperations and relations on names, such as a total ordering. This paper shows\nthat, contrary to expectations, one may add not just ordering, but almost any\nrelation or numerical function on names without disturbing the fundamental\ncorrectness result about this form of typed name binding (that object-level\nalpha-equivalence precisely corresponds to contextual equivalence at the\nprogramming meta-level), so long as one takes the state of dynamically created\nnames into account.\n", "versions": [{"version": "v1", "created": "Tue, 8 Jan 2008 15:04:56 GMT"}, {"version": "v2", "created": "Tue, 18 Mar 2008 18:23:41 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Pitts", "Andrew M.", ""], ["Shinwell", "Mark R.", ""]]}, {"id": "0801.2201", "submitter": "Ed Harcourt", "authors": "Ed Harcourt", "title": "Policies of System Level Pipeline Modeling", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AR cs.PL", "license": null, "abstract": "  Pipelining is a well understood and often used implementation technique for\nincreasing the performance of a hardware system. We develop several SystemC/C++\nmodeling techniques that allow us to quickly model, simulate, and evaluate\npipelines. We employ a small domain specific language (DSL) based on resource\nusage patterns that automates the drudgery of boilerplate code needed to\nconfigure connectivity in simulation models. The DSL is embedded directly in\nthe host modeling language SystemC/C++. Additionally we develop several\ntechniques for parameterizing a pipeline's behavior based on policies of\nfunction, communication, and timing (performance modeling).\n", "versions": [{"version": "v1", "created": "Tue, 15 Jan 2008 15:44:28 GMT"}], "update_date": "2008-01-16", "authors_parsed": [["Harcourt", "Ed", ""]]}, {"id": "0801.2226", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Programming an interpreter using molecular dynamics", "comments": "27 pages", "journal-ref": "Scientific Annals of Computer Science, 17:47--81, 2007.\n  http://www.infoiasi.ro/bin/download/Annals/XVII/XVII_2.pdf", "doi": null, "report-no": "PRG0801", "categories": "cs.PL", "license": null, "abstract": "  PGA (ProGram Algebra) is an algebra of programs which concerns programs in\ntheir simplest form: sequences of instructions. Molecular dynamics is a simple\nmodel of computation developed in the setting of PGA, which bears on the use of\ndynamic data structures in programming. We consider the programming of an\ninterpreter for a program notation that is close to existing assembly languages\nusing PGA with the primitives of molecular dynamics as basic instructions. It\nhappens that, although primarily meant for explaining programming language\nfeatures relating to the use of dynamic data structures, the collection of\nprimitives of molecular dynamics in itself is suited to our programming wants.\n", "versions": [{"version": "v1", "created": "Tue, 15 Jan 2008 07:56:12 GMT"}], "update_date": "2008-04-08", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0801.3690", "submitter": "Grenville Croll", "authors": "Jocelyn Paine", "title": "Ensuring Spreadsheet Integrity with Model Master", "comments": "15 pages; substantive references; code examples", "journal-ref": "Proc. European Spreadsheet Risks Int. Grp. 2001 17-38 ISBN:1 86166\n  179 7", "doi": null, "report-no": null, "categories": "cs.PL cs.HC", "license": null, "abstract": "  We have developed the Model Master (MM) language for describing spreadsheets,\nand tools for converting MM programs to and from spreadsheets. The MM\ndecompiler translates a spreadsheet into an MM program which gives a concise\nsummary of its calculations, layout, and styling. This is valuable when trying\nto understand spreadsheets one has not seen before, and when checking for\nerrors. The MM compiler goes the other way, translating an MM program into a\nspreadsheet. This makes possible a new style of development, in which\nspreadsheets are generated from textual specifications. This can reduce error\nrates compared to working directly with the raw spreadsheet, and gives\nimportant facilities for code reuse. MM programs also offer advantages over\nExcel files for the interchange of spreadsheets.\n", "versions": [{"version": "v1", "created": "Thu, 24 Jan 2008 00:32:29 GMT"}], "update_date": "2008-03-10", "authors_parsed": [["Paine", "Jocelyn", ""]]}, {"id": "0801.3715", "submitter": "Annie Ressouche", "authors": "Annie Ressouche, Daniel Gaff\\'e (LEAT), Val\\'erie Roy", "title": "Modular Compilation of a Synchronous Language", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": null, "abstract": "  Synchronous languages rely on formal methods to ease the development of\napplications in an efficient and reusable way. Formal methods have been\nadvocated as a means of increasing the reliability of systems, especially those\nwhich are safety or business critical. It is still difficult to develop\nautomatic specification and verification tools due to limitations like state\nexplosion, undecidability, etc... In this work, we design a new specification\nmodel based on a reactive synchronous approach. Then, we benefit from a formal\nframework well suited to perform compilation and formal validation of systems.\nIn practice, we design and implement a special purpose language (LE) and its\ntwo semantics: the ehavioral semantics helps us to define a program by the set\nof its behaviors and avoid ambiguousness in programs' interpretation; the\nexecution equational semantics allows the modular compilation of programs into\nsoftware and hardware targets (c code, vhdl code, fpga synthesis, observers).\nOur approach is pertinent considering the two main requirements of critical\nrealistic applications: the modular compilation allows us to deal with large\nsystems, the model-based approach provides us with formal validation.\n", "versions": [{"version": "v1", "created": "Thu, 24 Jan 2008 15:24:46 GMT"}], "update_date": "2009-04-20", "authors_parsed": [["Ressouche", "Annie", "", "LEAT"], ["Gaff\u00e9", "Daniel", "", "LEAT"], ["Roy", "Val\u00e9rie", ""]]}, {"id": "0801.4230", "submitter": "Simon Perdrix", "authors": "Simon Perdrix", "title": "Quantum entanglement analysis based on abstract interpretation", "comments": "13 pages", "journal-ref": "Proc. of 15th International Static Analysis Symposium (SAS 2008).\n  LNCS 5079, pp 270-282", "doi": "10.1007/978-3-540-69166-2_18", "report-no": null, "categories": "cs.LO cs.PL quant-ph", "license": null, "abstract": "  Entanglement is a non local property of quantum states which has no classical\ncounterpart and plays a decisive role in quantum information theory. Several\nprotocols, like the teleportation, are based on quantum entangled states.\nMoreover, any quantum algorithm which does not create entanglement can be\nefficiently simulated on a classical computer. The exact role of the\nentanglement is nevertheless not well understood. Since an exact analysis of\nentanglement evolution induces an exponential slowdown, we consider\napproximative analysis based on the framework of abstract interpretation. In\nthis paper, a concrete quantum semantics based on superoperators is associated\nwith a simple quantum programming language. The representation of entanglement,\ni.e. the design of the abstract domain is a key issue. A representation of\nentanglement as a partition of the memory is chosen. An abstract semantics is\nintroduced, and the soundness of the approximation is proven.\n", "versions": [{"version": "v1", "created": "Mon, 28 Jan 2008 10:45:47 GMT"}], "update_date": "2008-12-08", "authors_parsed": [["Perdrix", "Simon", ""]]}, {"id": "0801.4280", "submitter": "Grenville Croll", "authors": "Yirsaw Ayalew, Roland Mittermeir", "title": "Spreadsheet Debugging", "comments": "13 Pages, 4 figues", "journal-ref": "Proc. European Spreadsheet Risks Int. Grp. 2003 67-79 ISBN 1 86166\n  199 1", "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": null, "abstract": "  Spreadsheet programs, artifacts developed by non-programmers, are used for a\nvariety of important tasks and decisions. Yet a significant proportion of them\nhave severe quality problems. To address this issue, our previous work\npresented an interval-based testing methodology for spreadsheets.\nInterval-based testing rests on the observation that spreadsheets are mainly\nused for numerical computations. It also incorporates ideas from symbolic\ntesting and interval analysis. This paper addresses the issue of efficiently\ndebugging spreadsheets. Based on the interval-based testing methodology, this\npaper presents a technique for tracing faults in spreadsheet programs. The\nfault tracing technique proposed uses the dataflow information and cell marks\nto identify the most influential faulty cell(s) for a given formula cell\ncontaining a propagated fault.\n", "versions": [{"version": "v1", "created": "Mon, 28 Jan 2008 14:07:58 GMT"}], "update_date": "2008-03-10", "authors_parsed": [["Ayalew", "Yirsaw", ""], ["Mittermeir", "Roland", ""]]}]