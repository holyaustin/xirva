[{"id": "0912.0555", "submitter": "EPTCS", "authors": "Pawe{\\l} Soboci\\'nski (ECS, University of Southampton)", "title": "A non-interleaving process calculus for multi-party synchronisation", "comments": null, "journal-ref": "EPTCS 12, 2009, pp. 87-98", "doi": "10.4204/EPTCS.12.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce the wire calculus. Its dynamic features are inspired by Milner's\nCCS: a unary prefix operation, binary choice and a standard recursion\nconstruct. Instead of an interleaving parallel composition operator there are\noperators for synchronisation along a common boundary and non-communicating\nparallel composition. The (operational) semantics is a labelled transition\nsystem obtained with SOS rules. Bisimilarity is a congruence with respect to\nthe operators of the language. Quotienting terms by bisimilarity results in a\ncompact closed category.\n", "versions": [{"version": "v1", "created": "Thu, 3 Dec 2009 00:19:08 GMT"}], "update_date": "2009-12-04", "authors_parsed": [["Soboci\u0144ski", "Pawe\u0142", "", "ECS, University of Southampton"]]}, {"id": "0912.0759", "submitter": "EPTCS", "authors": "Filippo Bonchi (CWI, Netherland), Davide Grohmann (University of\n  Udine, Italy), Paola Spoletini (University of Insubria - Como, Italy), Emilio\n  Tuosto (University of Leicester, UK)", "title": "Proceedings 2nd Interaction and Concurrency Experience: Structured\n  Interactions", "comments": null, "journal-ref": "EPTCS 12, 2009", "doi": "10.4204/EPTCS.12", "report-no": null, "categories": "cs.LO cs.CR cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the 2nd Workshop on Interaction and\nConcurrency Experience (ICE'09). The workshop was held in Bologna, Italy on\n31th of August 2009, as a satellite workshop of CONCUR'09. The previous edition\nof ICE has been organized in Reykjavik (2008).\n  The ICE workshop is intended as a series of international scientific meetings\noriented to researchers in various fields of theoretical computer science and,\neach year, the workshop focuses on a specific topic: ICE 2009 focused on\nstructured interactions meant as the class of synchronisations that go beyond\nthe \"simple\" point-to-point synchronisations (e.g., multicast or broadcast\nsynchronisations, even-notification based interactions, time dependent\ninteractions, distributed transactions,...).\n", "versions": [{"version": "v1", "created": "Thu, 3 Dec 2009 23:55:44 GMT"}], "update_date": "2009-12-07", "authors_parsed": [["Bonchi", "Filippo", "", "CWI, Netherland"], ["Grohmann", "Davide", "", "University of\n  Udine, Italy"], ["Spoletini", "Paola", "", "University of Insubria - Como, Italy"], ["Tuosto", "Emilio", "", "University of Leicester, UK"]]}, {"id": "0912.1072", "submitter": "Cameron Freer", "authors": "Cameron E. Freer, Daniel M. Roy", "title": "Computable de Finetti measures", "comments": "32 pages. Final journal version; expanded somewhat, with minor\n  corrections. To appear in Annals of Pure and Applied Logic. Extended abstract\n  appeared in Proceedings of CiE '09, LNCS 5635, pp. 218-231", "journal-ref": "Annals of Pure and Applied Logic 163 (2012) pp. 530-546", "doi": "10.1016/j.apal.2011.06.011", "report-no": null, "categories": "math.LO cs.LO cs.PL math.PR math.ST stat.ML stat.TH", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove a computable version of de Finetti's theorem on exchangeable\nsequences of real random variables. As a consequence, exchangeable stochastic\nprocesses expressed in probabilistic functional programming languages can be\nautomatically rewritten as procedures that do not modify non-local state. Along\nthe way, we prove that a distribution on the unit interval is computable if and\nonly if its moments are uniformly computable.\n", "versions": [{"version": "v1", "created": "Sun, 6 Dec 2009 02:50:35 GMT"}, {"version": "v2", "created": "Mon, 19 Dec 2011 09:28:50 GMT"}], "update_date": "2012-02-03", "authors_parsed": [["Freer", "Cameron E.", ""], ["Roy", "Daniel M.", ""]]}, {"id": "0912.2846", "submitter": "Agostino Dovier", "authors": "Agostino Dovier, Andrea Formisano, and Enrico Pontelli", "title": "Multi-valued Action Languages in CLP(FD)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Action description languages, such as A and B, are expressive instruments\nintroduced for formalizing planning domains and planning problem instances. The\npaper starts by proposing a methodology to encode an action language (with\nconditional effects and static causal laws), a slight variation of B, using\nConstraint Logic Programming over Finite Domains. The approach is then\ngeneralized to raise the use of constraints to the level of the action language\nitself. A prototype implementation has been developed, and the preliminary\nresults are presented and discussed.\n  To appear in Theory and Practice of Logic Programming (TPLP)\n", "versions": [{"version": "v1", "created": "Tue, 15 Dec 2009 11:10:13 GMT"}], "update_date": "2009-12-16", "authors_parsed": [["Dovier", "Agostino", ""], ["Formisano", "Andrea", ""], ["Pontelli", "Enrico", ""]]}, {"id": "0912.2861", "submitter": "Artur Ventura", "authors": "Artur Ventura", "title": "JSC : A JavaScript Object System", "comments": "7 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The JSC language is a superset of JavaScript designed to ease the development\nof large web applications. This language extends JavaScripts own object system\nby isolating code in a class declaration, simplifying multiple inheritance and\nusing method implementation agreements.\n", "versions": [{"version": "v1", "created": "Tue, 15 Dec 2009 12:26:02 GMT"}], "update_date": "2009-12-16", "authors_parsed": [["Ventura", "Artur", ""]]}, {"id": "0912.3510", "submitter": "Paul Fodor", "authors": "Diptikalyan Saha, Paul Fodor", "title": "A simple and efficient explicit parallelization of logic programs using\n  low-level threading primitives", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  In this work, we present an automatic way to parallelize logic programs for\nfinding all the answers to queries using a transformation to low level\nthreading primitives. Although much work has been done in parallelization of\nlogic programming more than a decade ago (e.g., Aurora, Muse, YapOR), the\ncurrent state of parallelizing logic programs is still very poor. This work\npresents a way for parallelism of tabled logic programs in XSB Prolog under the\nwell founded semantics. An important contribution of this work relies in\nmerging answer-tables from multiple children threads without incurring copying\nor full-sharing and synchronization of data-structures. The implementation of\nthe parent-children shared answer-tables surpasses in efficiency all the other\ndata-structures currently implemented for completion of answers in\nparallelization using multi-threading. The transformation and its lower-level\nanswer merging predicates were implemented as an extension to the XSB system.\n", "versions": [{"version": "v1", "created": "Thu, 17 Dec 2009 20:32:09 GMT"}, {"version": "v2", "created": "Mon, 28 Dec 2009 02:45:49 GMT"}], "update_date": "2009-12-28", "authors_parsed": [["Saha", "Diptikalyan", ""], ["Fodor", "Paul", ""]]}, {"id": "0912.3583", "submitter": "Martin Levesque", "authors": "Martin Levesque", "title": "A Metamodel of Unit Testing for Object-Oriented Programming Languages", "comments": "7 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A unit test is a method for verifying the accuracy and the proper functioning\nof a portion of a program. This work consists to study the relation and the\napproaches to test Object-Oriented Programming (OOP) programs and to propose a\nmetamodel that enables the programmer to write the tests while writing the\nsource code to be tested by exploiting the key features of OOP programming\nlanguages such as inheritance, polymorphism, etc.\n", "versions": [{"version": "v1", "created": "Fri, 18 Dec 2009 04:35:24 GMT"}], "update_date": "2009-12-21", "authors_parsed": [["Levesque", "Martin", ""]]}, {"id": "0912.4360", "submitter": "Danny De Schreye", "authors": "Manh Thang Nguyen, Danny De Schreye, J\\\"urgen Giesl, Peter\n  Schneider-Kamp", "title": "Polytool: polynomial interpretations as a basis for termination analysis\n  of Logic programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Our goal is to study the feasibility of porting termination analysis\ntechniques developed for one programming paradigm to another paradigm. In this\npaper, we show how to adapt termination analysis techniques based on polynomial\ninterpretations - very well known in the context of term rewrite systems (TRSs)\n- to obtain new (non-transformational) ter- mination analysis techniques for\ndefinite logic programs (LPs). This leads to an approach that can be seen as a\ndirect generalization of the traditional techniques in termination analysis of\nLPs, where linear norms and level mappings are used. Our extension general-\nizes these to arbitrary polynomials. We extend a number of standard concepts\nand results on termination analysis to the context of polynomial\ninterpretations. We also propose a constraint-based approach for automatically\ngenerating polynomial interpretations that satisfy the termination conditions.\nBased on this approach, we implemented a new tool, called Polytool, for\nautomatic termination analysis of LPs.\n", "versions": [{"version": "v1", "created": "Tue, 22 Dec 2009 10:44:03 GMT"}], "update_date": "2009-12-23", "authors_parsed": [["Nguyen", "Manh Thang", ""], ["De Schreye", "Danny", ""], ["Giesl", "J\u00fcrgen", ""], ["Schneider-Kamp", "Peter", ""]]}, {"id": "0912.4877", "submitter": "Julien Cohen", "authors": "Julien Cohen (LMI)", "title": "Typing rule-based transformations over topological collections", "comments": null, "journal-ref": "4th International Workshop on Rule-Based Programming, Valencia :\n  Spain (2003)", "doi": "10.1016/S1571-0661(04)80676-5", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Pattern-matching programming is an example of a rule-based programming style\ndeveloped in functional languages. This programming style is intensively used\nin dialects of ML but is restricted to algebraic data-types. This restriction\nlimits the field of application. However, as shown by Giavitto and Michel at\nRULE'02, case-based function definitions can be extended to more general data\nstructures called topological collections. We show in this paper that this\nextension retains the benefits of the typed discipline of the functional\nlanguages. More precisely, we show that topological collections and the\nrule-based definition of functions associated with them fit in a polytypic\nextension of mini-ML where type inference is still possible.\n", "versions": [{"version": "v1", "created": "Thu, 24 Dec 2009 15:27:18 GMT"}], "update_date": "2009-12-25", "authors_parsed": [["Cohen", "Julien", "", "LMI"]]}, {"id": "0912.4878", "submitter": "Julien Cohen", "authors": "Julien Cohen (LMI)", "title": "Typage fort et typage souple des collections topologiques et des\n  transformations", "comments": null, "journal-ref": "Journ\\'ees francophones des langages applicatifs,\n  Sainte-Marie-de-R\\'e : France (2004)", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Topological collections allow to consider uniformly many data structures in\nprogramming languages and are handled by functions defined by pattern matching\ncalled transformations. We present two type systems for languages with\ntopological collections and transformations. The first one is a strong type\nsystem \\`a la Hindley/Milner which can be entirely typed at compile time. The\nsecond one is a mixed static and dynamic type system allowing to handle\nheterogeneous collections, that is collections which contain values with\ndifferent types. In the two cases, automatic type inference is possible.\n", "versions": [{"version": "v1", "created": "Thu, 24 Dec 2009 15:27:50 GMT"}], "update_date": "2009-12-25", "authors_parsed": [["Cohen", "Julien", "", "LMI"]]}]