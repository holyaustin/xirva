[{"id": "1305.1459", "submitter": "Pier Stanislao Paolucci", "authors": "Pier Stanislao Paolucci, Iuliana Bacivarov, Gert Goossens, Rainer\n  Leupers, Fr\\'ed\\'eric Rousseau, Christoph Schumacher, Lothar Thiele, Piero\n  Vicini", "title": "EURETILE 2010-2012 summary: first three years of activity of the\n  European Reference Tiled Experiment", "comments": "56 pages", "journal-ref": null, "doi": "10.12837/2013T01", "report-no": null, "categories": "cs.DC cs.AR cs.NE cs.OS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is the summary of first three years of activity of the EURETILE FP7\nproject 247846. EURETILE investigates and implements brain-inspired and\nfault-tolerant foundational innovations to the system architecture of massively\nparallel tiled computer architectures and the corresponding programming\nparadigm. The execution targets are a many-tile HW platform, and a many-tile\nsimulator. A set of SW process - HW tile mapping candidates is generated by the\nholistic SW tool-chain using a combination of analytic and bio-inspired\nmethods. The Hardware dependent Software is then generated, providing OS\nservices with maximum efficiency/minimal overhead. The many-tile simulator\ncollects profiling data, closing the loop of the SW tool chain. Fine-grain\nparallelism inside processes is exploited by optimized intra-tile compilation\ntechniques, but the project focus is above the level of the elementary tile.\nThe elementary HW tile is a multi-processor, which includes a fault tolerant\nDistributed Network Processor (for inter-tile communication) and ASIP\naccelerators. Furthermore, EURETILE investigates and implements the innovations\nfor equipping the elementary HW tile with high-bandwidth, low-latency\nbrain-like inter-tile communication emulating 3 levels of connection hierarchy,\nnamely neural columns, cortical areas and cortex, and develops a dedicated\ncortical simulation benchmark: DPSNN-STDP (Distributed Polychronous Spiking\nNeural Net with synaptic Spiking Time Dependent Plasticity). EURETILE leverages\non the multi-tile HW paradigm and SW tool-chain developed by the FET-ACA SHAPES\nIntegrated Project (2006-2009).\n", "versions": [{"version": "v1", "created": "Tue, 7 May 2013 10:22:31 GMT"}], "update_date": "2013-06-24", "authors_parsed": [["Paolucci", "Pier Stanislao", ""], ["Bacivarov", "Iuliana", ""], ["Goossens", "Gert", ""], ["Leupers", "Rainer", ""], ["Rousseau", "Fr\u00e9d\u00e9ric", ""], ["Schumacher", "Christoph", ""], ["Thiele", "Lothar", ""], ["Vicini", "Piero", ""]]}, {"id": "1305.3103", "submitter": "Hassan Rashidi", "authors": "Hassan Rashidi", "title": "A fast method for implementation of the property lists in programming\n  languages", "comments": "9 Pages, 5 Figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One of the major challenges in programming languages is to support different\ndata structures and their variations in both static and dynamic aspects. One of\nthe these data structures is the property list which applications use it as a\nconvenient way to store, organize, and access standard types of data. In this\npaper, the standards methods for implementation of the Property Lists,\nincluding the Static Array, Link List, Hash and Tree are reviewed. Then an\nefficient method to implement the property list is presented. The experimental\nresults shows that our method is fast compared with the existing methods.\n", "versions": [{"version": "v1", "created": "Tue, 14 May 2013 10:45:16 GMT"}], "update_date": "2013-05-15", "authors_parsed": [["Rashidi", "Hassan", ""]]}, {"id": "1305.3163", "submitter": "J. Ian Johnson", "authors": "J. Ian Johnson and David Van Horn", "title": "Abstracting Abstract Control (Extended)", "comments": "To appear at DLS '14", "journal-ref": null, "doi": "10.1145/2661088.2661098", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The strength of a dynamic language is also its weakness: run-time flexibility\ncomes at the cost of compile-time predictability. Many of the hallmarks of\ndynamic languages such as closures, continuations, various forms of reflection,\nand a lack of static types make many programmers rejoice, while compiler\nwriters, tool developers, and verification engineers lament. The dynamism of\nthese features simply confounds statically reasoning about programs that use\nthem. Consequently, static analyses for dynamic languages are few, far between,\nand seldom sound.\n  The \"abstracting abstract machines\" (AAM) approach to constructing static\nanalyses has recently been proposed as a method to ameliorate the difficulty of\ndesigning analyses for such language features. The approach, so called because\nit derives a function for the sound and computable approximation of program\nbehavior starting from the abstract machine semantics of a language, provides a\nviable approach to dynamic language analysis since all that is required is a\nmachine description of the interpreter.\n  The original AAM recipe produces finite state abstractions, which cannot\nfaithfully represent an interpreter's control stack. Recent advances have shown\nthat higher-order programs can be approximated with pushdown systems. However,\nthese automata theoretic models either break down on features that inspect or\nmodify the control stack.\n  In this paper, we tackle the problem of bringing pushdown flow analysis to\nthe domain of dynamic language features. We revise the abstracting abstract\nmachines technique to target the stronger computational model of pushdown\nsystems. In place of automata theory, we use only abstract machines and\nmemoization. As case studies, we show the technique applies to a language with\nclosures, garbage collection, stack-inspection, and first-class composable\ncontinuations.\n", "versions": [{"version": "v1", "created": "Tue, 14 May 2013 14:19:00 GMT"}, {"version": "v2", "created": "Fri, 24 May 2013 12:36:14 GMT"}, {"version": "v3", "created": "Sun, 29 Sep 2013 18:10:34 GMT"}, {"version": "v4", "created": "Wed, 16 Oct 2013 18:47:21 GMT"}, {"version": "v5", "created": "Thu, 27 Mar 2014 22:39:04 GMT"}, {"version": "v6", "created": "Tue, 10 Jun 2014 16:10:10 GMT"}, {"version": "v7", "created": "Wed, 6 Aug 2014 14:45:24 GMT"}, {"version": "v8", "created": "Thu, 14 Aug 2014 21:13:51 GMT"}], "update_date": "2014-08-18", "authors_parsed": [["Johnson", "J. Ian", ""], ["Van Horn", "David", ""]]}, {"id": "1305.4584", "submitter": "Ludovic Courtes", "authors": "Ludovic Court\\`es", "title": "Functional Package Management with Guix", "comments": "European Lisp Symposium (2013)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe the design and implementation of GNU Guix, a purely functional\npackage manager designed to support a complete GNU/Linux distribution. Guix\nsupports transactional upgrades and roll-backs, unprivileged package\nmanagement, per-user profiles, and garbage collection. It builds upon the\nlow-level build and deployment layer of the Nix package manager. Guix uses\nScheme as its programming interface. In particular, we devise an embedded\ndomain-specific language (EDSL) to describe and compose packages. We\ndemonstrate how it allows us to benefit from the host general-purpose\nprogramming language while not compromising on expressiveness. Second, we show\nthe use of Scheme to write build programs, leading to \"two-tier\" programming\nsystem.\n", "versions": [{"version": "v1", "created": "Mon, 20 May 2013 17:38:19 GMT"}], "update_date": "2013-05-21", "authors_parsed": [["Court\u00e8s", "Ludovic", ""]]}, {"id": "1305.4957", "submitter": "Alexander Bau", "authors": "Alexander Bau, Johannes Waldmann", "title": "Propositional Encoding of Constraints over Tree-Shaped Data", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a functional programming language for specifying constraints over\ntree-shaped data. The language allows for Haskell-like algebraic data types and\npattern matching. Our constraint compiler CO4 translates these programs into\nsatisfiability problems in propositional logic. We present an application from\nthe area of automated analysis of (non-)termination of rewrite systems.\n", "versions": [{"version": "v1", "created": "Tue, 21 May 2013 20:35:20 GMT"}], "update_date": "2013-05-24", "authors_parsed": [["Bau", "Alexander", ""], ["Waldmann", "Johannes", ""]]}, {"id": "1305.6108", "submitter": "Keehang Kwon", "authors": "Keehang Kwon", "title": "Bounded Choice Queries for Logic Programming", "comments": "5 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Adding versatile interactions to goals and queries in logic programming is an\nessential task. Unfortunately, existing logic languages can take input from the\nuser only via the $read$ construct.\n  We propose to add a new interactive goal to allow for more controlled and\nmore guided participation from the user. We illustrate our idea via \\muprolog,\nan extension of Prolog with bounded choice goals.\n", "versions": [{"version": "v1", "created": "Mon, 27 May 2013 05:22:24 GMT"}, {"version": "v2", "created": "Sat, 3 Aug 2013 12:18:41 GMT"}], "update_date": "2013-08-06", "authors_parsed": [["Kwon", "Keehang", ""]]}, {"id": "1305.6113", "submitter": "EPTCS", "authors": "Frank Zeyda (University of York), Ana Cavalcanti (University of York)", "title": "Refining SCJ Mission Specifications into Parallel Handler Designs", "comments": "In Proceedings Refine 2013, arXiv:1305.5634", "journal-ref": "EPTCS 115, 2013, pp. 52-67", "doi": "10.4204/EPTCS.115.4", "report-no": null, "categories": "cs.LO cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Safety-Critical Java (SCJ) is a recent technology that restricts the\nexecution and memory model of Java in such a way that applications can be\nstatically analysed and certified for their real-time properties and safe use\nof memory. Our interest is in the development of comprehensive and sound\ntechniques for the formal specification, refinement, design, and implementation\nof SCJ programs, using a correct-by-construction approach. As part of this\nwork, we present here an account of laws and patterns that are of general use\nfor the refinement of SCJ mission specifications into designs of parallel\nhandlers used in the SCJ programming paradigm. Our notation is a combination of\nlanguages from the Circus family, supporting state-rich reactive models with\nthe addition of class objects and real-time properties. Our work is a first\nstep to elicit laws of programming for SCJ and fits into a refinement strategy\nthat we have developed previously to derive SCJ programs.\n", "versions": [{"version": "v1", "created": "Mon, 27 May 2013 05:40:09 GMT"}], "update_date": "2013-05-28", "authors_parsed": [["Zeyda", "Frank", "", "University of York"], ["Cavalcanti", "Ana", "", "University of York"]]}, {"id": "1305.6332", "submitter": "Kristin Erickson", "authors": "Kristin Grace Erickson", "title": "The Story of Telebrain: A multi-performer telematic platform for\n  performatization", "comments": "AISB symposium on Music and Unconventional Computing, conference\n  proceedings 2013, Exeter, UK", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.HC cs.ET cs.MM cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents Telebrain, a browser-based performatization platform\ninvented for organizing real-time telematic performances. Performatization is\nthe human performance of algorithms. When computers and humans performatize\ncooperatively, the human-computer interaction (HCI) becomes the location of\ncomputation. Novel modes of machine-human communication are necessary for\norganizing performatizations. Telebrain is designed to facilitate machine-human\nlanguages. Capitalizing on the ubiquity and cross-platform compatibility of the\nInternet, Telebrain is an open-source web application supporting PerPL\n(Performer Programming Language), a human-interpreted configurable language of\nmulti-media instructions used to program performers. Telebrain facilitates a\nvariety of performance disciplines such as music, theater, dance, computational\nperformance, networked scoring (image and audio), prompted improvisation,\nreal-space multi-player gaming, collaborative transdisciplinary karaoke and\nquantum square-dancing. (http://telebrain.org)\n", "versions": [{"version": "v1", "created": "Mon, 27 May 2013 21:28:04 GMT"}], "update_date": "2013-05-29", "authors_parsed": [["Erickson", "Kristin Grace", ""]]}, {"id": "1305.6543", "submitter": "Gregory Malecha", "authors": "Gregory Malecha, Adam Chlipala, Thomas Braibant, Patrick Hulin, Edward\n  Z. Yang", "title": "MirrorShard: Proof by Computational Reflection with Verified Hints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a method for building composable and extensible verification\nprocedures within the Coq proof assistant. Unlike traditional methods that rely\non run-time generation and checking of proofs, we use verified-correct\nprocedures with Coq soundness proofs. Though they are internalized in Coq's\nlogic, our provers support sound extension by users with hints over new\ndomains, enabling automated reasoning about user-defined abstract predicates.\nWe maintain soundness by developing an architecture for modular packaging,\nconstruction, and composition of hint databases, which had previously only been\nimplemented in Coq at the level of its dynamically typed, proof-generating\ntactic language. Our provers also include rich handling of unification\nvariables, enabling integration with other tactic-based deduction steps within\nCoq. We have implemented our techniques in MirrorShard, an open-source\nframework for reflective verification. We demonstrate its applicability by\ninstantiating it to separation logic in order to reason about imperative\nprogram verification.\n", "versions": [{"version": "v1", "created": "Tue, 28 May 2013 15:50:10 GMT"}], "update_date": "2013-05-29", "authors_parsed": [["Malecha", "Gregory", ""], ["Chlipala", "Adam", ""], ["Braibant", "Thomas", ""], ["Hulin", "Patrick", ""], ["Yang", "Edward Z.", ""]]}, {"id": "1305.6640", "submitter": "Dirk Beyer", "authors": "Sven Apel, Dirk Beyer, Karlheinz Friedberger, Franco Raimondi, and\n  Alexander von Rhein", "title": "Domain Types: Selecting Abstractions Based on Variable Usage", "comments": "13 pages, 9 figures, 2 tables", "journal-ref": null, "doi": null, "report-no": "MIP-1303", "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The success of software model checking depends on finding an appropriate\nabstraction of the subject program. The choice of the abstract domain and the\nanalysis configuration is currently left to the user, who may not be familiar\nwith the tradeoffs and performance details of the available abstract domains.\nWe introduce the concept of domain types, which classify the program variables\ninto types that are more fine-grained than standard declared types, such as int\nor long, in order to guide the selection of an appropriate abstract domain for\na model checker. Our implementation determines the domain type for each\nvariable in a pre-processing step, based on the variable usage in the program,\nand then assigns each variable to an abstract domain. The model-checking\nframework that we use supports to specify a separate analysis precision for\neach abstract domain, such that we can freely configure the analysis. We\nexperimentally demonstrate a significant impact of the choice of the abstract\ndomain per variable. We consider one explicit (hash tables for integer values)\nand one symbolic (binary decision diagrams) domain. The experiments are based\non standard verification tasks that are taken from recent competitions on\nsoftware verification. Each abstract domain has unique advantages in\nrepresenting the state space of variables of a certain domain type. Our\nexperiments show that software model checkers can be improved with a\ndomain-type guided combination of abstract domains.\n", "versions": [{"version": "v1", "created": "Tue, 28 May 2013 21:37:10 GMT"}], "update_date": "2013-05-30", "authors_parsed": [["Apel", "Sven", ""], ["Beyer", "Dirk", ""], ["Friedberger", "Karlheinz", ""], ["Raimondi", "Franco", ""], ["von Rhein", "Alexander", ""]]}, {"id": "1305.6721", "submitter": "Matthias Keil", "authors": "Matthias Keil and Peter Thiemann", "title": "Type-based Dependency Analysis for JavaScript", "comments": "Technical Report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dependency analysis is a program analysis that determines potential data flow\nbetween program points. While it is not a security analysis per se, it is a\nviable basis for investigating data integrity, for ensuring confidentiality,\nand for guaranteeing sanitization. A noninterference property can be stated and\nproved for the dependency analysis. We have designed and implemented a\ndependency analysis for JavaScript. We formalize this analysis as an\nabstraction of a tainting semantics. We prove the correctness of the tainting\nsemantics, the soundness of the abstraction, a noninterference property, and\nthe termination of the analysis.\n", "versions": [{"version": "v1", "created": "Wed, 29 May 2013 08:38:32 GMT"}], "update_date": "2013-05-30", "authors_parsed": [["Keil", "Matthias", ""], ["Thiemann", "Peter", ""]]}, {"id": "1305.6745", "submitter": "Yulia Demyanova", "authors": "Yulia Demyanova, Helmut Veith and Florian Zuleger", "title": "On the Concept of Variable Roles and its Use in Software Analysis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Human written source code in imperative programming languages exhibits\ntypical patterns for variable use such as flags, loop iterators, counters,\nindices, bitvectors etc. Although it is widely understood by practitioners that\nthese variable roles are important for automated software analysis tools, they\nare not systematically studied by the formal methods community, and not well\ndocumented in the research literature. In this paper, we study the notion of\nvariable roles on the example of basic types (int, float, char) in C. We\npropose a classification of the variables in a program by variable roles, and\ndemonstrate that classical data flow analysis lends itself naturally both as a\nspecification formalism and an analysis paradigm for this classification\nproblem. We demonstrate the practical applicability of our method by predicting\nmembership of source files to the different categories of the software\nverification competition SVCOMP 2013.\n", "versions": [{"version": "v1", "created": "Wed, 29 May 2013 09:59:58 GMT"}, {"version": "v2", "created": "Fri, 14 Jun 2013 11:45:32 GMT"}], "update_date": "2013-06-17", "authors_parsed": [["Demyanova", "Yulia", ""], ["Veith", "Helmut", ""], ["Zuleger", "Florian", ""]]}, {"id": "1305.6915", "submitter": "Dirk Beyer", "authors": "Dirk Beyer, Stefan L\\\"owe, Evgeny Novikov, Andreas Stahlbauer, and\n  Philipp Wendler", "title": "Reusing Precisions for Efficient Regression Verification", "comments": "14 pages, 2 figures, 6 tables", "journal-ref": null, "doi": null, "report-no": "MIP-1302", "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Continuous testing during development is a well-established technique for\nsoftware-quality assurance. Continuous model checking from revision to revision\nis not yet established as a standard practice, because the enormous resource\nconsumption makes its application impractical. Model checkers compute a large\nnumber of verification facts that are necessary for verifying if a given\nspecification holds. We have identified a category of such intermediate results\nthat are easy to store and efficient to reuse: abstraction precisions. The\nprecision of an abstract domain specifies the level of abstraction that the\nanalysis works on. Precisions are thus a precious result of the verification\neffort and it is a waste of resources to throw them away after each\nverification run. In particular, precisions are small and thus easy to store;\nthey are easy to process and have a large impact on resource consumption. We\nexperimentally show the impact of precision reuse on industrial verification\nproblems, namely, 59 device drivers with 1119 revisions from the Linux kernel.\n", "versions": [{"version": "v1", "created": "Wed, 29 May 2013 19:39:45 GMT"}], "update_date": "2013-05-30", "authors_parsed": [["Beyer", "Dirk", ""], ["L\u00f6we", "Stefan", ""], ["Novikov", "Evgeny", ""], ["Stahlbauer", "Andreas", ""], ["Wendler", "Philipp", ""]]}, {"id": "1305.7167", "submitter": "Pavel Zaichenkov", "authors": "Pavel Zaichenkov (1 and 4), Bert Gijsbers (2 and 3), Clemens Grelck\n  (3), Olga Tveretina (1), Alex Shafarenko (1) ((1) University of\n  Hertfordshire, (2) Ghent University, (3) University of Amsterdam, (4) Moscow\n  Institute of Physics and Technology)", "title": "A Case Study in Coordination Programming: Performance Evaluation of\n  S-Net vs Intel's Concurrent Collections", "comments": "9 pages, 8 figures, 1 table, accepted for PLC 2014 workshop", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a programming methodology and runtime performance case study\ncomparing the declarative data flow coordination language S-Net with Intel's\nConcurrent Collections (CnC). As a coordination language S-Net achieves a\nnear-complete separation of concerns between sequential software components\nimplemented in a separate algorithmic language and their parallel orchestration\nin an asynchronous data flow streaming network. We investigate the merits of\nS-Net and CnC with the help of a relevant and non-trivial linear algebra\nproblem: tiled Cholesky decomposition. We describe two alternative S-Net\nimplementations of tiled Cholesky factorization and compare them with two CnC\nimplementations, one with explicit performance tuning and one without, that\nhave previously been used to illustrate Intel CnC. Our experiments on a 48-core\nmachine demonstrate that S-Net manages to outperform CnC on this problem.\n", "versions": [{"version": "v1", "created": "Thu, 30 May 2013 17:21:26 GMT"}, {"version": "v2", "created": "Sat, 15 Jun 2013 11:01:14 GMT"}, {"version": "v3", "created": "Thu, 7 Nov 2013 00:40:07 GMT"}, {"version": "v4", "created": "Thu, 3 Apr 2014 12:24:47 GMT"}], "update_date": "2014-04-04", "authors_parsed": [["Zaichenkov", "Pavel", "", "1 and 4"], ["Gijsbers", "Bert", "", "2 and 3"], ["Grelck", "Clemens", ""], ["Tveretina", "Olga", ""], ["Shafarenko", "Alex", ""]]}]