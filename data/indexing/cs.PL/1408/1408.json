[{"id": "1408.0818", "submitter": "Himanshu Chauhan", "authors": "Weil-Lun Hung and Himanshu Chauhan and Vijay K. Garg", "title": "ActiveMonitor: Non-blocking Monitor Executions for Increased Parallelism", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a set of novel ideas on design and implementation of monitor\nobjects for multi-threaded programs. Our approach has two main goals: (a)\nincrease parallelism in monitor objects and thus provide performance gains\n(shorter runtimes) for multi-threaded programs, and (b) introduce constructs\nthat allow programmers to easily write monitor-based multi-threaded programs\nthat can achieve these performance gains. We describe the concepts of our\nframework, called ActiveMonitor, and its prototype implementation using\nfutures. We evaluate its performance in terms of runtimes of multi-threaded\nprograms on linked-list, bounded-buffer, and other fundamental problems\nimplemented in Java. We compare the runtimes of our implementation against\nimplementations using Java's reentrant locks, recently proposed automatic\nsignaling framework AutoSynch, and some other techniques from the literature.\nThe results of of the evaluation indicate that monitors based on our framework\nprovide significant gains in runtime performance in comparison to traditional\nmonitors implemented using Java's reentrant locks.\n", "versions": [{"version": "v1", "created": "Mon, 4 Aug 2014 20:58:16 GMT"}], "update_date": "2014-08-06", "authors_parsed": [["Hung", "Weil-Lun", ""], ["Chauhan", "Himanshu", ""], ["Garg", "Vijay K.", ""]]}, {"id": "1408.0957", "submitter": "Duc-Hiep Chu", "authors": "Duc-Hiep Chu and Joxan Jaffar", "title": "A Framework to Synergize Partial Order Reduction with State\n  Interpolation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address the problem of reasoning about interleavings in safety\nverification of concurrent programs. In the literature, there are two prominent\ntechniques for pruning the search space. First, there are well-investigated\ntrace-based methods, collectively known as \"Partial Order Reduction (POR)\",\nwhich operate by weakening the concept of a trace by abstracting the total\norder of its transitions into a partial order. Second, there is state-based\ninterpolation where a collection of formulas can be generalized by taking into\naccount the property to be verified. Our main contribution is a framework that\nsynergistically combines POR with state interpolation so that the sum is more\nthan its parts.\n", "versions": [{"version": "v1", "created": "Tue, 5 Aug 2014 13:27:09 GMT"}], "update_date": "2014-08-06", "authors_parsed": [["Chu", "Duc-Hiep", ""], ["Jaffar", "Joxan", ""]]}, {"id": "1408.1271", "submitter": "EPTCS", "authors": "Johannes Borgstr\\\"om (Uppsala University), Silvia Crafa (University of\n  Padova)", "title": "Proceedings Combined 21st International Workshop on Expressiveness in\n  Concurrency and 11th Workshop on Structural Operational Semantics", "comments": null, "journal-ref": "EPTCS 160, 2014", "doi": "10.4204/EPTCS.160", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Combined 21st International\nWorkshop on Expressiveness in Concurrency and the 11th Workshop on Structural\nOperational Semantics (EXPRESS/SOS 2014) which was held on 1st September 2014\nin Rome, Italy, as an affiliated workshop of CONCUR 2014, the 25th\nInternational Conference on Concurrency Theory.\n  The EXPRESS workshops aim at bringing together researchers interested in the\nexpressiveness of various formal systems and semantic notions, particularly in\nthe field of concurrency. Their focus has traditionally been on the comparison\nbetween programming concepts (such as concurrent, functional, imperative, logic\nand object-oriented programming) and between mathematical models of computation\n(such as process algebras, Petri nets, event structures, modal logics, and\nrewrite systems) on the basis of their relative expressive power. The EXPRESS\nworkshop series has run successfully since 1994 and over the years this focus\nhas become broadly construed.\n  The SOS workshops aim at being a forum for researchers, students and\npractitioners interested in new developments, and directions for future\ninvestigation, in the field of structural operational semantics. One of the\nspecific goals of the SOS workshop series is to establish synergies between the\nconcurrency and programming language communities working on the theory and\npractice of SOS. Reports on applications of SOS to other fields are also most\nwelcome, including: modelling and analysis of biological systems, security of\ncomputer systems programming, modelling and analysis of embedded systems,\nspecification of middle-ware and coordination languages, programming language\nsemantics and implementation, static analysis software and hardware\nverification, and semantics for domain-specific languages and model-based\nengineering.\n", "versions": [{"version": "v1", "created": "Wed, 6 Aug 2014 13:21:29 GMT"}], "update_date": "2014-08-07", "authors_parsed": [["Borgstr\u00f6m", "Johannes", "", "Uppsala University"], ["Crafa", "Silvia", "", "University of\n  Padova"]]}, {"id": "1408.1451", "submitter": "Ali Mashtizadeh", "authors": "Ali Jose Mashtizadeh, Andrea Bittau, David Mazieres, Dan Boneh", "title": "Cryptographically Enforced Control Flow Integrity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent Pwn2Own competitions have demonstrated the continued effectiveness of\ncontrol hijacking attacks despite deployed countermeasures including stack\ncanaries and ASLR. A powerful defense called Control flow Integrity (CFI)\noffers a principled approach to preventing such attacks. However, prior CFI\nimplementations use static analysis and must limit protection to remain\npractical. These limitations have enabled attacks against all known CFI\nsystems, as demonstrated in recent work.\n  This paper presents a cryptographic approach to control flow integrity (CCFI)\nthat is both fine-grain and practical: using message authentication codes (MAC)\nto protect control flow elements such as return addresses, function pointers,\nand vtable pointers. MACs on these elements prevent even powerful attackers\nwith random read/write access to memory from tampering with program control\nflow. We implemented CCFI in Clang/LLVM, taking advantage of recently available\ncryptographic CPU instructions. We evaluate our system on several large\nsoftware packages (including nginx, Apache and memcache) as well as all their\ndependencies. The cost of protection ranges from a 3-18% decrease in request\nrate.\n", "versions": [{"version": "v1", "created": "Thu, 7 Aug 2014 01:27:34 GMT"}], "update_date": "2014-08-08", "authors_parsed": [["Mashtizadeh", "Ali Jose", ""], ["Bittau", "Andrea", ""], ["Mazieres", "David", ""], ["Boneh", "Dan", ""]]}, {"id": "1408.1457", "submitter": "EPTCS", "authors": "Daniel Gebler (VU University Amsterdam), Simone Tini (University of\n  Insubria)", "title": "Fixed-point Characterization of Compositionality Properties of\n  Probabilistic Processes Combinators", "comments": "In Proceedings EXPRESS/SOS 2014, arXiv:1408.1271", "journal-ref": "EPTCS 160, 2014, pp. 63-78", "doi": "10.4204/EPTCS.160.7", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bisimulation metric is a robust behavioural semantics for probabilistic\nprocesses. Given any SOS specification of probabilistic processes, we provide a\nmethod to compute for each operator of the language its respective metric\ncompositionality property. The compositionality property of an operator is\ndefined as its modulus of continuity which gives the relative increase of the\ndistance between processes when they are combined by that operator. The\ncompositionality property of an operator is computed by recursively counting\nhow many times the combined processes are copied along their evolution. The\ncompositionality properties allow to derive an upper bound on the distance\nbetween processes by purely inspecting the operators used to specify those\nprocesses.\n", "versions": [{"version": "v1", "created": "Thu, 7 Aug 2014 01:57:06 GMT"}], "update_date": "2014-08-08", "authors_parsed": [["Gebler", "Daniel", "", "VU University Amsterdam"], ["Tini", "Simone", "", "University of\n  Insubria"]]}, {"id": "1408.1458", "submitter": "EPTCS", "authors": "Bartek Klin, Beata Nachy{\\l}a", "title": "Distributive Laws and Decidable Properties of SOS Specifications", "comments": "In Proceedings EXPRESS/SOS 2014, arXiv:1408.1271", "journal-ref": "EPTCS 160, 2014, pp. 79-93", "doi": "10.4204/EPTCS.160.8", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Some formats of well-behaved operational specifications, correspond to\nnatural transformations of certain types (for example, GSOS and coGSOS laws).\nThese transformations have a common generalization: distributive laws of monads\nover comonads. We prove that this elegant theoretical generalization has\nlimited practical benefits: it does not translate to any concrete rule format\nthat would be complete for specifications that contain both GSOS and coGSOS\nrules. This is shown for the case of labeled transition systems and\ndeterministic stream systems.\n", "versions": [{"version": "v1", "created": "Thu, 7 Aug 2014 01:57:17 GMT"}], "update_date": "2014-08-08", "authors_parsed": [["Klin", "Bartek", ""], ["Nachy\u0142a", "Beata", ""]]}, {"id": "1408.1459", "submitter": "EPTCS", "authors": "Simon J. Gay (School of Computing Science, University of Glasgow),\n  Nils Gesbert (Grenoble INP - Ensimag), Ant\\'onio Ravara (CITI and Dep de\n  Inform\\'atica, FCT, Universidade Nova de Lisboa)", "title": "Session Types as Generic Process Types", "comments": "In Proceedings EXPRESS/SOS 2014, arXiv:1408.1271", "journal-ref": "EPTCS 160, 2014, pp. 94-110", "doi": "10.4204/EPTCS.160.9", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Behavioural type systems ensure more than the usual safety guarantees of\nstatic analysis. They are based on the idea of \"types-as-processes\", providing\ndedicated type algebras for particular properties, ranging from protocol\ncompatibility to race-freedom, lock-freedom, or even responsiveness. Two\nsuccessful, although rather different, approaches, are session types and\nprocess types. The former allows to specify and verify (distributed)\ncommunication protocols using specific type (proof) systems; the latter allows\nto infer from a system specification a process abstraction on which it is\nsimpler to verify properties, using a generic type (proof) system. What is the\nrelationship between these approaches? Can the generic one subsume the specific\none? At what price? And can the former be used as a compiler for the latter?\nThe work presented herein is a step towards answers to such questions.\nConcretely, we define a stepwise encoding of a pi-calculus with sessions and\nsession types (the system of Gay and Hole) into a pi-calculus with process\ntypes (the Generic Type System of Igarashi and Kobayashi). We encode session\ntype environments, polarities (which distinguish session channels end-points),\nand labelled sums. We show forward and reverse operational correspondences for\nthe encodings, as well as typing correspondences. To faithfully encode session\nsubtyping in process types subtyping, one needs to add to the target language\nrecord constructors and new subtyping rules. In conclusion, the programming\nconvenience of session types as protocol abstractions can be combined with the\nsimplicity and power of the pi-calculus, taking advantage in particular of the\nframework provided by the Generic Type System.\n", "versions": [{"version": "v1", "created": "Thu, 7 Aug 2014 01:57:27 GMT"}], "update_date": "2014-08-08", "authors_parsed": [["Gay", "Simon J.", "", "School of Computing Science, University of Glasgow"], ["Gesbert", "Nils", "", "Grenoble INP - Ensimag"], ["Ravara", "Ant\u00f3nio", "", "CITI and Dep de\n  Inform\u00e1tica, FCT, Universidade Nova de Lisboa"]]}, {"id": "1408.1460", "submitter": "EPTCS", "authors": "Sonja Franke-Arnold (University of Glasgow), Simon J. Gay (University\n  of Glasgow), Ittoop Vergheese Puthoor (University of Glasgow)", "title": "Verification of Linear Optical Quantum Computing using Quantum Process\n  Calculus", "comments": "In Proceedings EXPRESS/SOS 2014, arXiv:1408.1271", "journal-ref": "EPTCS 160, 2014, pp. 111-129", "doi": "10.4204/EPTCS.160.10", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We explain the use of quantum process calculus to describe and analyse linear\noptical quantum computing (LOQC). The main idea is to define two processes, one\nmodelling a linear optical system and the other expressing a specification, and\nprove that they are behaviourally equivalent. We extend the theory of\nbehavioural equivalence in the process calculus Communicating Quantum Processes\n(CQP) to include multiple particles (namely photons) as information carriers,\ndescribed by Fock states or number states. We summarise the theory in this\npaper, including the crucial result that equivalence is a congruence, meaning\nthat it is preserved by embedding in any context. In previous work, we have\nused quantum process calculus to model LOQC but without verifying models\nagainst specifications. In this paper, for the first time, we are able to carry\nout verification. We illustrate this approach by describing and verifying two\nmodels of an LOQC CNOT gate.\n", "versions": [{"version": "v1", "created": "Thu, 7 Aug 2014 01:57:37 GMT"}], "update_date": "2014-08-08", "authors_parsed": [["Franke-Arnold", "Sonja", "", "University of Glasgow"], ["Gay", "Simon J.", "", "University\n  of Glasgow"], ["Puthoor", "Ittoop Vergheese", "", "University of Glasgow"]]}, {"id": "1408.1675", "submitter": "James Cheney", "authors": "James Cheney and Amal Ahmed and Umut A. Acar", "title": "Database Queries that Explain their Work", "comments": "PPDP 2014", "journal-ref": null, "doi": "10.1145/2643135.2643143", "report-no": null, "categories": "cs.PL cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Provenance for database queries or scientific workflows is often motivated as\nproviding explanation, increasing understanding of the underlying data sources\nand processes used to compute the query, and reproducibility, the capability to\nrecompute the results on different inputs, possibly specialized to a part of\nthe output. Many provenance systems claim to provide such capabilities;\nhowever, most lack formal definitions or guarantees of these properties, while\nothers provide formal guarantees only for relatively limited classes of\nchanges. Building on recent work on provenance traces and slicing for\nfunctional programming languages, we introduce a detailed tracing model of\nprovenance for multiset-valued Nested Relational Calculus, define trace slicing\nalgorithms that extract subtraces needed to explain or recompute specific parts\nof the output, and define query slicing and differencing techniques that\nsupport explanation. We state and prove correctness properties for these\ntechniques and present a proof-of-concept implementation in Haskell.\n", "versions": [{"version": "v1", "created": "Thu, 7 Aug 2014 18:29:38 GMT"}, {"version": "v2", "created": "Fri, 8 Aug 2014 17:02:26 GMT"}, {"version": "v3", "created": "Tue, 12 Aug 2014 10:50:02 GMT"}], "update_date": "2014-08-13", "authors_parsed": [["Cheney", "James", ""], ["Ahmed", "Amal", ""], ["Acar", "Umut A.", ""]]}, {"id": "1408.1754", "submitter": "Graeme Gange", "authors": "Graeme Gange and Jorge A. Navas and Peter Schachte and Harald\n  Sondergaard and Peter J. Stuckey", "title": "A Partial-Order Approach to Array Content Analysis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a parametric abstract domain for array content analysis. The\nmethod maintains invariants for contiguous regions of the array, similar to the\nmethods of Gopan, Reps and Sagiv, and of Halbwachs and Peron. However, it\nintroduces a novel concept of an array content graph, avoiding the need for an\nup-front factorial partitioning step. The resulting analysis can be used with\narbitrary numeric relational abstract domains; we evaluate the domain on a\nrange of array manipulating program fragments.\n", "versions": [{"version": "v1", "created": "Fri, 8 Aug 2014 03:11:41 GMT"}], "update_date": "2014-08-11", "authors_parsed": [["Gange", "Graeme", ""], ["Navas", "Jorge A.", ""], ["Schachte", "Peter", ""], ["Sondergaard", "Harald", ""], ["Stuckey", "Peter J.", ""]]}, {"id": "1408.2564", "submitter": "Ally Nyamawe S", "authors": "Ally S. Nyamawe", "title": "A Proposed Framework for Development of a Visualizer Based on Memory\n  Transfer Language (MTL)", "comments": "5 Pages, 15 Figures, Published with International Journal of Computer\n  Trends and Technology (IJCTT)", "journal-ref": null, "doi": "10.14445/22312803/IJCTT-V13P136", "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  Computer programming is among the fundamental aspects of computer science\ncurriculum. Many students first introduced to introductory computer programming\ncourses experience difficulties in learning and comprehending. Vast amount of\nresearches have revealed that, generally programming courses are regarded as\ndifficult and challenging and thus often have the highest dropout rates.\nMoreover, numerous researches have devoted in delivering new approaches and\ntools in enhancing the process of teaching and learning computer programming to\nnovice programmers. One among the tools that have emerged to offer positive\nresults is Program Visualization tool (Visualizer). Visualizers have shown\nremarkable contributions in facilitating novices to learn and comprehend\ncomputer programming. In addition to that, an approach to visualize codes\nexecution, Memory Transfer Language (MTL), allows a novice to animate the code\nthrough paper and pencil mechanism without actively involving the machine. MTL\ndepends on the concepts of RAM (Random Access Memory) to interpret the code\nline by line. Programming requires effort and special approach in the way it is\nlearned and taught, thus this paper aimed at presenting a proposed framework\nfor developing a visualizer that employs the use of MTL to enhance teaching and\nlearning programming.\n", "versions": [{"version": "v1", "created": "Mon, 11 Aug 2014 21:35:00 GMT"}], "update_date": "2014-08-13", "authors_parsed": [["Nyamawe", "Ally S.", ""]]}, {"id": "1408.2955", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "A Hoare-like logic of asserted single-pass instruction sequences", "comments": "22 pages, the preliminaries have textual overlaps with the\n  preliminaries in arXiv:1402.4950 [cs.LO] and earlier papers; introduction and\n  conclusions rewritten, explanatory remarks added; introduction partly\n  rewritten; 24 pages, clarifying examples added", "journal-ref": "Scientific Annals of Computer Science, 26(2):125--156 (2016)", "doi": "10.7561/SACS.2016.2.125", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a formal system for proving the partial correctness of a\nsingle-pass instruction sequence as considered in program algebra by\ndecomposition into proofs of the partial correctness of segments of the\nsingle-pass instruction sequence concerned. The system is similar to Hoare\nlogics, but takes into account that, by the presence of jump instructions,\nsegments of single-pass instruction sequences may have multiple entry points\nand multiple exit points. It is intended to support a sound general\nunderstanding of the issues with Hoare-like logics for low-level programming\nlanguages.\n", "versions": [{"version": "v1", "created": "Wed, 13 Aug 2014 09:41:13 GMT"}, {"version": "v2", "created": "Thu, 3 Dec 2015 14:09:34 GMT"}, {"version": "v3", "created": "Tue, 19 Jul 2016 11:54:17 GMT"}, {"version": "v4", "created": "Wed, 3 May 2017 11:53:03 GMT"}], "update_date": "2017-06-29", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "1408.4423", "submitter": "Frank Hannig", "authors": "Frank Hannig, Dirk Koch, Daniel Ziener", "title": "Proceedings of the First International Workshop on FPGAs for Software\n  Programmers (FSP 2014)", "comments": "Website of the workshop: https://www12.cs.fau.de/ws/fsp2014/", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AR cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the papers accepted at the First International Workshop\non FPGAs for Software Programmers (FSP 2014), held in Munich, Germany,\nSeptember 1st, 2014. FSP 2014 was co-located with the International Conference\non Field Programmable Logic and Applications (FPL).\n", "versions": [{"version": "v1", "created": "Mon, 18 Aug 2014 18:43:54 GMT"}, {"version": "v2", "created": "Fri, 27 Feb 2015 05:40:38 GMT"}], "update_date": "2015-03-02", "authors_parsed": [["Hannig", "Frank", ""], ["Koch", "Dirk", ""], ["Ziener", "Daniel", ""]]}, {"id": "1408.4715", "submitter": "Hugo A. Andrade", "authors": "Hugo A. Andrade, Simon Hogg, Stephan Ahrends", "title": "Making FPGAs Accessible to Scientists and Engineers as Domain Expert\n  Software Programmers with LabVIEW", "comments": "Presented at First International Workshop on FPGAs for Software\n  Programmers (FSP 2014) (arXiv:1408.4423)", "journal-ref": null, "doi": null, "report-no": "FSP/2014/02", "categories": "cs.SE cs.DC cs.OS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present a graphical programming framework, LabVIEW, and\nassociated language and libraries, as well as programming techniques and\npatterns that we have found useful in making FPGAs accessible to scientists and\nengineers as domain expert software programmers.\n", "versions": [{"version": "v1", "created": "Wed, 20 Aug 2014 16:39:15 GMT"}], "update_date": "2014-08-21", "authors_parsed": [["Andrade", "Hugo A.", ""], ["Hogg", "Simon", ""], ["Ahrends", "Stephan", ""]]}, {"id": "1408.4721", "submitter": "Frank Hannig", "authors": "Moritz Schmid, Oliver Reiche, Christian Schmitt, Frank Hannig,\n  J\\\"urgen Teich", "title": "Code Generation for High-Level Synthesis of Multiresolution Applications\n  on FPGAs", "comments": "Presented at First International Workshop on FPGAs for Software\n  Programmers (FSP 2014) (arXiv:1408.4423)", "journal-ref": null, "doi": null, "report-no": "FSP/2014/04", "categories": "cs.CV cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multiresolution Analysis (MRA) is a mathematical method that is based on\nworking on a problem at different scales. One of its applications is medical\nimaging where processing at multiple scales, based on the concept of Gaussian\nand Laplacian image pyramids, is a well-known technique. It is often applied to\nreduce noise while preserving image detail on different levels of granularity\nwithout modifying the filter kernel. In scientific computing, multigrid methods\nare a popular choice, as they are asymptotically optimal solvers for elliptic\nPartial Differential Equations (PDEs). As such algorithms have a very high\ncomputational complexity that would overwhelm CPUs in the presence of real-time\nconstraints, application-specific processors come into consideration for\nimplementation. Despite of huge advancements in leveraging productivity in the\nrespective fields, designers are still required to have detailed knowledge\nabout coding techniques and the targeted architecture to achieve efficient\nsolutions. Recently, the HIPAcc framework was proposed as a means for automatic\ncode generation of image processing algorithms, based on a Domain-Specific\nLanguage (DSL). From the same code base, it is possible to generate code for\nefficient implementations on several accelerator technologies including\ndifferent types of Graphics Processing Units (GPUs) as well as reconfigurable\nlogic (FPGAs). In this work, we demonstrate the ability of HIPAcc to generate\ncode for the implementation of multiresolution applications on FPGAs and\nembedded GPUs.\n", "versions": [{"version": "v1", "created": "Wed, 20 Aug 2014 16:56:42 GMT"}], "update_date": "2014-08-21", "authors_parsed": [["Schmid", "Moritz", ""], ["Reiche", "Oliver", ""], ["Schmitt", "Christian", ""], ["Hannig", "Frank", ""], ["Teich", "J\u00fcrgen", ""]]}, {"id": "1408.4964", "submitter": "Martin Margala", "authors": "Oren Segal, Martin Margala, Sai Rahul Chalamalasetti, Mitch Wright", "title": "High Level Programming for Heterogeneous Architectures", "comments": "Presented at First International Workshop on FPGAs for Software\n  Programmers (FSP 2014) (arXiv:1408.4423)", "journal-ref": null, "doi": null, "report-no": "FSP/2014/10", "categories": "cs.PF cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work presents an effort to bridge the gap between abstract high level\nprogramming and OpenCL by extending an existing high level Java programming\nframework (APARAPI), based on OpenCL, so that it can be used to program FPGAs\nat a high level of abstraction and increased ease of programmability. We run\nseveral real world algorithms to assess the performance of the framework on\nboth a low end and a high end system. On the low end and high end systems\nrespectively we observed up to 78-80 percent power reduction and 4.8X-5.3X\nspeed increase running NBody simulation, as well as up to 65-80 percent power\nreduction and 6.2X-7X speed increase for a KMeans, MapReduce algorithm running\non top of the Hadoop framework and APARAPI.\n", "versions": [{"version": "v1", "created": "Thu, 21 Aug 2014 11:23:54 GMT"}], "update_date": "2014-08-22", "authors_parsed": [["Segal", "Oren", ""], ["Margala", "Martin", ""], ["Chalamalasetti", "Sai Rahul", ""], ["Wright", "Mitch", ""]]}, {"id": "1408.4965", "submitter": "Gordon Inggs", "authors": "Gordon Inggs, David Thomas, Wayne Luk", "title": "A Domain Specific Approach to Heterogeneous Computing: From Availability\n  to Accessibility", "comments": "Presented at First International Workshop on FPGAs for Software\n  Programmers (FSP 2014) (arXiv:1408.4423)", "journal-ref": null, "doi": null, "report-no": "FSP/2014/11", "categories": "cs.CE cs.DC cs.PF cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We advocate a domain specific software development methodology for\nheterogeneous computing platforms such as Multicore CPUs, GPUs and FPGAs. We\nargue that three specific benefits are realised from adopting such an approach:\nportable, efficient implementations across heterogeneous platforms; domain\nspecific metrics of quality that characterise platforms in a form software\ndevelopers will understand; automatic, optimal partitioning across the\navailable computing resources. These three benefits allow a development\nmethodology for software developers where they describe their computational\nproblems in a single, easy to understand form, and after a modeling procedure\non the available resources, select how they would like to trade between various\ndomain specific metrics. Our work on the Forward Financial Framework ($F^3$)\ndemonstrates this methodology in practise. We are able to execute a range of\ncomputational finance option pricing tasks efficiently upon a wide range of\nCPU, GPU and FPGA computing platforms. We can also create accurate financial\ndomain metric models of walltime latency and statistical confidence.\nFurthermore, we believe that we can support automatic, optimal partitioning\nusing this execution and modelling capability.\n", "versions": [{"version": "v1", "created": "Thu, 21 Aug 2014 11:32:53 GMT"}], "update_date": "2014-08-22", "authors_parsed": [["Inggs", "Gordon", ""], ["Thomas", "David", ""], ["Luk", "Wayne", ""]]}, {"id": "1408.5564", "submitter": "EPTCS", "authors": "Marco Carbone (IT University of Copenhagen)", "title": "Proceedings Third Workshop on Behavioural Types", "comments": null, "journal-ref": "EPTCS 162, 2014", "doi": "10.4204/EPTCS.162", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of BEAT 2014, the third Workshop on\nBehavioural Types. The workshop took place in Rome, Italy, on September 1st\n2014, as a satellite even of CONCUR 2014, the 25th International Conference on\nConcurrency Theory.\n  The aim of this workshop is to bring together researchers in all aspects of\nbehavioural type theory and its applications, in order to share results,\nconsolidate the community, and discover opportunities for new collaborations\nand future directions.\n", "versions": [{"version": "v1", "created": "Sun, 24 Aug 2014 05:47:04 GMT"}], "update_date": "2014-08-26", "authors_parsed": [["Carbone", "Marco", "", "IT University of Copenhagen"]]}, {"id": "1408.5809", "submitter": "Tarmo Uustalu", "authors": "Danel Ahman (University of Edinburgh), James Chapman (Institute of\n  Cybernetics at TUT), Tarmo Uustalu (Institute of Cybernetics at TUT)", "title": "When is a container a comonad?", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 3 (September\n  3, 2014) lmcs:894", "doi": "10.2168/LMCS-10(3:14)2014", "report-no": null, "categories": "cs.PL cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Abbott, Altenkirch, Ghani and others have taught us that many parameterized\ndatatypes (set functors) can be usefully analyzed via container representations\nin terms of a set of shapes and a set of positions in each shape. This paper\nbuilds on the observation that datatypes often carry additional structure that\ncontainers alone do not account for. We introduce directed containers to\ncapture the common situation where every position in a data-structure\ndetermines another data-structure, informally, the sub-data-structure rooted by\nthat position. Some natural examples are non-empty lists and node-labelled\ntrees, and data-structures with a designated position (zippers). While\ncontainers denote set functors via a fully-faithful functor, directed\ncontainers interpret fully-faithfully into comonads. But more is true: every\ncomonad whose underlying functor is a container is represented by a directed\ncontainer. In fact, directed containers are the same as containers that are\ncomonads. We also describe some constructions of directed containers. We have\nformalized our development in the dependently typed programming language Agda.\n", "versions": [{"version": "v1", "created": "Mon, 25 Aug 2014 16:04:14 GMT"}, {"version": "v2", "created": "Tue, 2 Sep 2014 19:25:14 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Ahman", "Danel", "", "University of Edinburgh"], ["Chapman", "James", "", "Institute of\n  Cybernetics at TUT"], ["Uustalu", "Tarmo", "", "Institute of Cybernetics at TUT"]]}, {"id": "1408.5870", "submitter": "Janarbek Matai", "authors": "Janarbek Matai, Dustin Richmond, Dajung Lee, Ryan Kastner", "title": "Enabling FPGAs for the Masses", "comments": "Presented at First International Workshop on FPGAs for Software\n  Programmers (FSP 2014) (arXiv:1408.4423)", "journal-ref": null, "doi": null, "report-no": "FSP/2014/03", "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Implementing an application on a FPGA remains a difficult, non-intuitive task\nthat often requires hardware design expertise in a hardware description\nlanguage (HDL). High-level synthesis (HLS) raises the design abstraction from\nHDL to languages such as C/C++/Scala/Java. Despite this, in order to get a good\nquality of result (QoR), a designer must carefully craft the HLS code. In other\nwords, HLS designers must implement the application using an abstract language\nin a manner that generates an efficient micro-architecture; we call this\nprocess writing restructured code. This reduces the benefits of implementing\nthe application at a higher level of abstraction and limits the impact of HLS\nby requiring explicit knowledge of the underlying hardware architecture.\nDevelopers must know how to write code that reflects low level implementation\ndetails of the application at hand as it is interpreted by HLS tools. As a\nresult, FPGA design still largely remains job of either hardware engineers or\nexpert HLS designers. In this work, we aim to take a step towards making HLS\ntools useful for a broader set of programmers. To do this, we study\nmethodologies of restructuring software code for HLS tools; we provide examples\nof designing different kernels in state-of-the art HLS tools; and we present a\nlist of challenges for developing a hardware programming model for software\nprogrammers.\n", "versions": [{"version": "v1", "created": "Wed, 20 Aug 2014 16:46:48 GMT"}], "update_date": "2014-08-26", "authors_parsed": [["Matai", "Janarbek", ""], ["Richmond", "Dustin", ""], ["Lee", "Dajung", ""], ["Kastner", "Ryan", ""]]}, {"id": "1408.5977", "submitter": "EPTCS", "authors": "Silvia Ghilezan (Univerzitet u Novom Sadu, Serbia), Svetlana\n  Jak\\v{s}i\\'c (Univerzitet u Novom Sadu, Serbia), Jovanka Pantovi\\'c\n  (Univerzitet u Novom Sadu, Serbia), Jorge A. P\\'erez (University of\n  Groningen, The Netherlands), Hugo Torres Vieira (LaSIGE, Faculdade de\n  Ci\\^encias, Universidade de Lisboa, Portugal)", "title": "Dynamic Role Authorization in Multiparty Conversations", "comments": "In Proceedings BEAT 2014, arXiv:1408.5564", "journal-ref": "EPTCS 162, 2014, pp. 1-8", "doi": "10.4204/EPTCS.162.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Protocol specifications often identify the roles involved in communications.\nIn multiparty protocols that involve task delegation it is often useful to\nconsider settings in which different sites may act on behalf of a single role.\nIt is then crucial to control the roles that the different parties are\nauthorized to represent, including the case in which role authorizations are\ndetermined only at runtime. Building on previous work on conversation types\nwith flexible role assignment, here we report initial results on a typed\nframework for the analysis of multiparty communications with dynamic role\nauthorization and delegation. In the underlying process model, communication\nprefixes are annotated with role authorizations and authorizations can be\npassed around. We extend the conversation type system so as to statically\ndistinguish processes that never incur in authorization errors. The proposed\nstatic discipline guarantees that processes are always authorized to\ncommunicate on behalf of an intended role, also covering the case in which\nauthorizations are dynamically passed around in messages.\n", "versions": [{"version": "v1", "created": "Tue, 26 Aug 2014 02:15:19 GMT"}], "update_date": "2014-08-27", "authors_parsed": [["Ghilezan", "Silvia", "", "Univerzitet u Novom Sadu, Serbia"], ["Jak\u0161i\u0107", "Svetlana", "", "Univerzitet u Novom Sadu, Serbia"], ["Pantovi\u0107", "Jovanka", "", "Univerzitet u Novom Sadu, Serbia"], ["P\u00e9rez", "Jorge A.", "", "University of\n  Groningen, The Netherlands"], ["Vieira", "Hugo Torres", "", "LaSIGE, Faculdade de\n  Ci\u00eancias, Universidade de Lisboa, Portugal"]]}, {"id": "1408.5978", "submitter": "EPTCS", "authors": "Ilaria Castellani (INRIA Sophia-Antipolis, France), Mariangiola\n  Dezani-Ciancaglini (Universit\\`a di Torino, Italy), Jorge A. P\\'erez\n  (University of Groningen, The Netherlands)", "title": "Self-Adaptation and Secure Information Flow in Multiparty Structured\n  Communications: A Unified Perspective", "comments": "In Proceedings BEAT 2014, arXiv:1408.5564", "journal-ref": "EPTCS 162, 2014, pp. 9-18", "doi": "10.4204/EPTCS.162.2", "report-no": null, "categories": "cs.LO cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present initial results on a comprehensive model of structured\ncommunications, in which self- adaptation and security concerns are jointly\naddressed. More specifically, we propose a model of self-adaptive, multiparty\ncommunications with secure information flow guarantees. In this model, security\nviolations occur when processes attempt to read or write messages of\ninappropriate security levels within directed exchanges. Such violations\ntrigger adaptation mechanisms that prevent the violations to occur and/or to\npropagate their effect in the choreography. Our model is equipped with local\nand global mechanisms for reacting to security violations; type soundness\nresults ensure that global protocols are still correctly executed, while the\nsystem adapts itself to preserve security.\n", "versions": [{"version": "v1", "created": "Tue, 26 Aug 2014 02:15:28 GMT"}], "update_date": "2014-08-27", "authors_parsed": [["Castellani", "Ilaria", "", "INRIA Sophia-Antipolis, France"], ["Dezani-Ciancaglini", "Mariangiola", "", "Universit\u00e0 di Torino, Italy"], ["P\u00e9rez", "Jorge A.", "", "University of Groningen, The Netherlands"]]}, {"id": "1408.5980", "submitter": "EPTCS", "authors": "Ornela Dardha (School of Computing Science, University of Glasgow)", "title": "Recursive Session Types Revisited", "comments": "In Proceedings BEAT 2014, arXiv:1408.5564", "journal-ref": "EPTCS 162, 2014, pp. 27-34", "doi": "10.4204/EPTCS.162.4", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Session types model structured communication-based programming. In\nparticular, binary session types for the pi-calculus describe communication\nbetween exactly two participants in a distributed scenario. Adding sessions to\nthe pi-calculus means augmenting it with type and term constructs. In a\nprevious paper, we tried to understand to which extent the session constructs\nare more complex and expressive than the standard pi-calculus constructs. Thus,\nwe presented an encoding of binary session pi-calculus to the standard typed\npi-calculus by adopting linear and variant types and the continuation-passing\nprinciple. In the present paper, we focus on recursive session types and we\npresent an encoding into recursive linear pi-calculus. This encoding is a\nconservative extension of the former in that it preserves the results therein\nobtained. Most importantly, it adopts a new treatment of the duality relation,\nwhich in the presence of recursive types has been proven to be quite\nchallenging.\n", "versions": [{"version": "v1", "created": "Tue, 26 Aug 2014 02:15:51 GMT"}], "update_date": "2014-08-27", "authors_parsed": [["Dardha", "Ornela", "", "School of Computing Science, University of Glasgow"]]}]