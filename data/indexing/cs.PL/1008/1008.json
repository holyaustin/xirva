[{"id": "1008.0909", "submitter": "Li Qing'an", "authors": "Qing'an Li, Yanxiang He, Yong Chen, Wei Wu, Wenwen Xu", "title": "A Heuristic Algorithm for optimizing Page Selection Instructions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Page switching is a technique that increases the memory in microcontrollers\nwithout extending the address buses. This technique is widely used in the\ndesign of 8-bit MCUs. In this paper, we present an algorithm to reduce the\noverhead of page switching. To pursue small code size, we place the emphasis on\nthe allocation of functions into suitable pages with a heuristic algorithm,\nthereby the cost-effective placement of page selection instructions. Our\nexperimental results showed the optimization achieved a reduction in code size\nof 13.2 percent.\n", "versions": [{"version": "v1", "created": "Thu, 5 Aug 2010 03:47:48 GMT"}], "update_date": "2010-08-06", "authors_parsed": [["Li", "Qing'an", ""], ["He", "Yanxiang", ""], ["Chen", "Yong", ""], ["Wu", "Wei", ""], ["Xu", "Wenwen", ""]]}, {"id": "1008.1131", "submitter": "Chris Preston", "authors": "Chris Preston", "title": "Computing with Equations", "comments": "240 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The intention of these notes is to give a mathematical account of how I\nbelieve students could be taught to think about functional programming\nlanguages and to explain how such languages work.\n", "versions": [{"version": "v1", "created": "Fri, 6 Aug 2010 07:55:16 GMT"}], "update_date": "2010-08-09", "authors_parsed": [["Preston", "Chris", ""]]}, {"id": "1008.1459", "submitter": "Carl Hewitt", "authors": "Carl Hewitt", "title": "Actor Model of Computation: Scalable Robust Information Systems", "comments": "Relationship to Internet of Things. arXiv admin note: text overlap\n  with arXiv:0812.4852, arXiv:0901.4934", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Actor model is a mathematical theory that treats \"Actors\" as the\nuniversal primitives of concurrent digital computation. The model has been used\nboth as a framework for a theoretical understanding of concurrency, and as the\ntheoretical basis for several practical implementations of concurrent systems.\nUnlike previous models of computation, the Actor model was inspired by physical\nlaws. It was also influenced by the programming languages Lisp, Simula 67 and\nSmalltalk-72, as well as ideas for Petri Nets, capability-based systems and\npacket switching. The advent of massive concurrency through client-cloud\ncomputing and many-core computer architectures has galvanized interest in the\nActor model.\n  Actor technology will see significant application for integrating all kinds\nof digital information for individuals, groups, and organizations so their\ninformation usefully links together. Information integration needs to make use\nof the following information system principles:\n  * Persistence. Information is collected and indexed.\n  * Concurrency: Work proceeds interactively and concurrently, overlapping in\ntime.\n  * Quasi-commutativity: Information can be used regardless of whether it\ninitiates new work or become relevant to ongoing work.\n  * Sponsorship: Sponsors provide resources for computation, i.e., processing,\nstorage, and communications.\n  * Pluralism: Information is heterogeneous, overlapping and often\ninconsistent.\n  * Provenance: The provenance of information is carefully tracked and recorded\n  The Actor Model is intended to provide a foundation for inconsistency robust\ninformation integration\n", "versions": [{"version": "v1", "created": "Mon, 9 Aug 2010 06:52:55 GMT"}, {"version": "v10", "created": "Wed, 29 Dec 2010 13:33:01 GMT"}, {"version": "v11", "created": "Sun, 6 Mar 2011 23:56:37 GMT"}, {"version": "v12", "created": "Mon, 4 Apr 2011 23:42:07 GMT"}, {"version": "v13", "created": "Sun, 17 Apr 2011 21:46:50 GMT"}, {"version": "v14", "created": "Mon, 25 Apr 2011 14:05:47 GMT"}, {"version": "v15", "created": "Mon, 2 May 2011 14:12:40 GMT"}, {"version": "v16", "created": "Tue, 17 May 2011 14:33:28 GMT"}, {"version": "v17", "created": "Sat, 18 Jun 2011 07:44:44 GMT"}, {"version": "v18", "created": "Wed, 6 Jul 2011 14:10:59 GMT"}, {"version": "v19", "created": "Mon, 1 Aug 2011 19:32:05 GMT"}, {"version": "v2", "created": "Thu, 12 Aug 2010 17:53:51 GMT"}, {"version": "v20", "created": "Mon, 22 Aug 2011 06:42:08 GMT"}, {"version": "v21", "created": "Tue, 30 Aug 2011 16:07:18 GMT"}, {"version": "v22", "created": "Wed, 16 Nov 2011 21:14:21 GMT"}, {"version": "v23", "created": "Sun, 1 Jan 2012 01:22:28 GMT"}, {"version": "v24", "created": "Mon, 2 Jul 2012 14:51:27 GMT"}, {"version": "v25", "created": "Fri, 31 Aug 2012 20:16:41 GMT"}, {"version": "v26", "created": "Thu, 11 Oct 2012 17:04:44 GMT"}, {"version": "v27", "created": "Wed, 7 Nov 2012 18:07:19 GMT"}, {"version": "v28", "created": "Sun, 30 Dec 2012 16:58:43 GMT"}, {"version": "v29", "created": "Thu, 28 Mar 2013 20:47:40 GMT"}, {"version": "v3", "created": "Tue, 17 Aug 2010 11:38:39 GMT"}, {"version": "v30", "created": "Mon, 2 Dec 2013 12:58:35 GMT"}, {"version": "v31", "created": "Mon, 30 Dec 2013 22:07:42 GMT"}, {"version": "v32", "created": "Wed, 26 Mar 2014 00:03:15 GMT"}, {"version": "v33", "created": "Wed, 13 Aug 2014 21:08:33 GMT"}, {"version": "v34", "created": "Thu, 11 Sep 2014 15:08:31 GMT"}, {"version": "v35", "created": "Mon, 3 Nov 2014 18:41:22 GMT"}, {"version": "v36", "created": "Mon, 29 Dec 2014 17:00:36 GMT"}, {"version": "v37", "created": "Mon, 5 Jan 2015 16:57:16 GMT"}, {"version": "v38", "created": "Wed, 21 Jan 2015 18:38:30 GMT"}, {"version": "v4", "created": "Sun, 22 Aug 2010 14:17:37 GMT"}, {"version": "v5", "created": "Tue, 31 Aug 2010 14:51:58 GMT"}, {"version": "v6", "created": "Mon, 6 Sep 2010 13:39:42 GMT"}, {"version": "v7", "created": "Wed, 8 Sep 2010 19:33:43 GMT"}, {"version": "v8", "created": "Mon, 8 Nov 2010 01:08:39 GMT"}, {"version": "v9", "created": "Mon, 29 Nov 2010 22:17:07 GMT"}], "update_date": "2015-01-22", "authors_parsed": [["Hewitt", "Carl", ""]]}, {"id": "1008.1673", "submitter": "Alex Berka Mr", "authors": "Alex V Berka", "title": "Space and the Synchronic A-Ram", "comments": "8 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Space is a circuit oriented, spatial programming language designed to exploit\nthe massive parallelism available in a novel formal model of computation called\nthe Synchronic A-Ram, and physically related FPGA and reconfigurable\narchitectures. Space expresses variable grained MIMD parallelism, is modular,\nstrictly typed, and deterministic. Barring operations associated with memory\nallocation and compilation, modules cannot access global variables, and are\nreferentially transparent. At a high level of abstraction, modules exhibit a\nsmall, sequential state transition system, aiding verification. Space deals\nwith communication, scheduling, and resource contention issues in parallel\ncomputing, by resolving them explicitly in an incremental manner, module by\nmodule, whilst ascending the ladder of abstraction. Whilst the Synchronic A-Ram\nmodel was inspired by linguistic considerations, it is also put forward as a\nformal model for reconfigurable digital circuits. A programming environment has\nbeen developed, that incorporates a simulator and compiler that transform Space\nprograms into Synchronic A-Ram machine code, consisting of only three bit-level\ninstructions, and a marking instruction. Space and the Synchronic A-Ram point\nto novel routes out of the parallel computing crisis.\n", "versions": [{"version": "v1", "created": "Tue, 10 Aug 2010 09:46:21 GMT"}, {"version": "v2", "created": "Sat, 28 Aug 2010 10:33:08 GMT"}], "update_date": "2010-08-31", "authors_parsed": [["Berka", "Alex V", ""]]}, {"id": "1008.1906", "submitter": "EPTCS", "authors": "Luca Aceto (Reykjavik University, Iceland), Pawe{\\l} Soboci\\'nski\n  (University of Southampton, United Kingdom)", "title": "Proceedings Seventh Workshop on Structural Operational Semantics", "comments": null, "journal-ref": "EPTCS 32, 2010", "doi": "10.4204/EPTCS.32", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Structural operational semantics (SOS) is a technique for defining\noperational semantics for programming and specification languages. Because of\nits intuitive appeal and flexibility, SOS has found considerable application in\nthe study of the semantics of concurrent processes. It is also a viable\nalternative to denotational semantics in the static analysis of programs and in\nproving compiler correctness. Recently it has been applied in emerging areas\nsuch as probabilistic systems and systems biology.\n", "versions": [{"version": "v1", "created": "Wed, 11 Aug 2010 13:41:32 GMT"}], "update_date": "2010-08-12", "authors_parsed": [["Aceto", "Luca", "", "Reykjavik University, Iceland"], ["Soboci\u0144ski", "Pawe\u0142", "", "University of Southampton, United Kingdom"]]}, {"id": "1008.2108", "submitter": "EPTCS", "authors": "Ignacio F\\'abregas (Universidad Complutense de Madrid, Spain), David\n  de Frutos Escrig (Universidad Complutense de Madrid, Spain), Miguel Palomino\n  (Universidad Complutense de Madrid, Spain)", "title": "Equational Characterization of Covariant-Contravariant Simulation and\n  Conformance Simulation Semantics", "comments": "In Proceedings SOS 2010, arXiv:1008.1906", "journal-ref": "EPTCS 32, 2010, pp. 1-14", "doi": "10.4204/EPTCS.32.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Covariant-contravariant simulation and conformance simulation generalize\nplain simulation and try to capture the fact that it is not always the case\nthat \"the larger the number of behaviors, the better\". We have previously\nstudied their logical characterizations and in this paper we present the\naxiomatizations of the preorders defined by the new simulation relations and\ntheir induced equivalences. The interest of our results lies in the fact that\nthe axiomatizations help us to know the new simulations better, understanding\nin particular the role of the contravariant characteristics and their interplay\nwith the covariant ones; moreover, the axiomatizations provide us with a\npowerful tool to (algebraically) prove results of the corresponding semantics.\nBut we also consider our results interesting from a metatheoretical point of\nview: the fact that the covariant-contravariant simulation equivalence is\nindeed ground axiomatizable when there is no action that exhibits both a\ncovariant and a contravariant behaviour, but becomes non-axiomatizable whenever\nwe have together actions of that kind and either covariant or contravariant\nactions, offers us a new subtle example of the narrow border separating\naxiomatizable and non-axiomatizable semantics. We expect that by studying these\nexamples we will be able to develop a general theory separating axiomatizable\nand non-axiomatizable semantics.\n", "versions": [{"version": "v1", "created": "Thu, 12 Aug 2010 13:42:22 GMT"}], "update_date": "2010-08-13", "authors_parsed": [["F\u00e1bregas", "Ignacio", "", "Universidad Complutense de Madrid, Spain"], ["Escrig", "David de Frutos", "", "Universidad Complutense de Madrid, Spain"], ["Palomino", "Miguel", "", "Universidad Complutense de Madrid, Spain"]]}, {"id": "1008.2112", "submitter": "EPTCS", "authors": "Keiko Nakata (Institute of Cybernetics, Tallinn University of\n  Technology, Estonia), Tarmo Uustalu (Institute of Cybernetics, Tallinn\n  University of Technology, Estonia)", "title": "Resumptions, Weak Bisimilarity and Big-Step Semantics for While with\n  Interactive I/O: An Exercise in Mixed Induction-Coinduction", "comments": "In Proceedings SOS 2010, arXiv:1008.1906", "journal-ref": "EPTCS 32, 2010, pp. 57-75", "doi": "10.4204/EPTCS.32.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We look at the operational semantics of languages with interactive I/O\nthrough the glasses of constructive type theory. Following on from our earlier\nwork on coinductive trace-based semantics for While, we define several big-step\nsemantics for While with interactive I/O, based on resumptions and\ntermination-sensitive weak bisimilarity. These require nesting inductive\ndefinitions in coinductive definitions, which is interesting both\nmathematically and from the point-of-view of implementation in a proof\nassistant.\n  After first defining a basic semantics of statements in terms of resumptions\nwith explicit internal actions (delays), we introduce a semantics in terms of\ndelay-free resumptions that essentially removes finite sequences of delays on\nthe fly from those resumptions that are responsive. Finally, we also look at a\nsemantics in terms of delay-free resumptions supplemented with a silent\ndivergence option. This semantics hinges on decisions between convergence and\ndivergence and is only equivalent to the basic one classically.\n  We have fully formalized our development in Coq.\n", "versions": [{"version": "v1", "created": "Thu, 12 Aug 2010 13:42:48 GMT"}], "update_date": "2010-08-13", "authors_parsed": [["Nakata", "Keiko", "", "Institute of Cybernetics, Tallinn University of\n  Technology, Estonia"], ["Uustalu", "Tarmo", "", "Institute of Cybernetics, Tallinn\n  University of Technology, Estonia"]]}, {"id": "1008.2590", "submitter": "Hans H Zantema", "authors": "Hans H Zantema (Technische Universiteit Eindhoven, The Netherlands)", "title": "Well-definedness of Streams by Transformation and Termination", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (September\n  7, 2010) lmcs:1107", "doi": "10.2168/LMCS-6(3:21)2010", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Streams are infinite sequences over a given data type. A stream specification\nis a set of equations intended to define a stream. We propose a transformation\nfrom such a stream specification to a term rewriting system (TRS) in such a way\nthat termination of the resulting TRS implies that the stream specification is\nwell-defined, that is, admits a unique solution. As a consequence, proving\nwell-definedness of several interesting stream specifications can be done fully\nautomatically using present powerful tools for proving TRS termination. In\norder to increase the power of this approach, we investigate transformations\nthat preserve semantics and well-definedness. We give examples for which the\nabove mentioned technique applies for the ransformed specification while it\nfails for the original one.\n", "versions": [{"version": "v1", "created": "Mon, 16 Aug 2010 08:14:41 GMT"}, {"version": "v2", "created": "Tue, 7 Sep 2010 09:31:47 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Zantema", "Hans H", "", "Technische Universiteit Eindhoven, The Netherlands"]]}, {"id": "1008.2748", "submitter": "Carl Hewitt", "authors": "Carl Hewitt", "title": "ActorScript(TM) extension of C sharp (TM), Java(TM), and Objective\n  C(TM): iAdaptive(TM) concurrency for antiCloud(TM) privacy and security", "comments": "Added explanation of facets of an Actor. Admin note: text overlap\n  with arXiv:1008.1459", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  ActorScript(TM) is a general purpose programming language for implementing\ndiscretionary, adaptive concurrency that manages resources and demand.\n  It is differentiated from previous languages by the following:\n  - Universality\n  *** Ability to specify what Actors can do\n  *** Specify interface between hardware and software\n  *** Everything in the language is accomplished using message passing\nincluding the very definition of ActorScript itself\n  *** Functional, Imperative, Logic, and Concurrent programming are integrated.\n  *** Concurrency dynamically adapts to resources available and current load.\n  *** Programs do not expose low-level implementation mechanisms such as\nthreads, tasks, locks, cores, etc.\n  *** Messages can be directly communicated without requiring indirection\nthrough brokers, channels, class hierarchies, mailboxes, pipes, ports, queues\netc.\n  *** Variable races are eliminated.\n  *** Binary XML and JSON are data types.\n  *** Application binary interfaces are afforded so that no identifier symbol\nneed be looked up at runtime.\n  - Safety and Security\n  *** Programs are extension invariant, i.e., extending a program does not\nchange its meaning.\n  *** Applications cannot directly harm each other.\n  - Performance\n  *** Impose no overhead on implementation of Actor systems\n  *** Message passing has essentially same overhead as procedure calling and\nlooping.\n  *** Allow execution to be dynamically adjusted for system load and capacity\n(e.g. cores)\n  *** Locality because execution is not bound by a sequential global memory\nmodel\n  *** Inherent concurrency because execution is not bound by communicating\nsequential processes\n  *** Minimize latency along critical paths\n", "versions": [{"version": "v1", "created": "Mon, 16 Aug 2010 19:45:20 GMT"}, {"version": "v10", "created": "Wed, 29 Dec 2010 13:23:33 GMT"}, {"version": "v11", "created": "Wed, 16 Feb 2011 18:58:22 GMT"}, {"version": "v12", "created": "Sun, 6 Mar 2011 23:51:16 GMT"}, {"version": "v13", "created": "Mon, 2 May 2011 14:11:43 GMT"}, {"version": "v14", "created": "Sat, 18 Jun 2011 08:36:20 GMT"}, {"version": "v15", "created": "Wed, 6 Jul 2011 14:09:24 GMT"}, {"version": "v16", "created": "Mon, 18 Jul 2011 10:39:23 GMT"}, {"version": "v17", "created": "Mon, 1 Aug 2011 19:28:08 GMT"}, {"version": "v18", "created": "Mon, 7 Nov 2011 12:08:56 GMT"}, {"version": "v19", "created": "Tue, 15 Nov 2011 14:29:38 GMT"}, {"version": "v2", "created": "Wed, 18 Aug 2010 17:24:47 GMT"}, {"version": "v20", "created": "Mon, 21 Nov 2011 17:26:53 GMT"}, {"version": "v21", "created": "Tue, 13 Dec 2011 23:20:19 GMT"}, {"version": "v22", "created": "Tue, 3 Jan 2012 15:49:33 GMT"}, {"version": "v23", "created": "Wed, 11 Jan 2012 14:16:14 GMT"}, {"version": "v24", "created": "Sat, 14 Jan 2012 19:18:33 GMT"}, {"version": "v25", "created": "Fri, 9 Mar 2012 18:12:55 GMT"}, {"version": "v26", "created": "Mon, 25 Jun 2012 16:22:05 GMT"}, {"version": "v27", "created": "Thu, 2 Aug 2012 18:56:07 GMT"}, {"version": "v28", "created": "Tue, 28 Aug 2012 05:28:57 GMT"}, {"version": "v29", "created": "Fri, 19 Oct 2012 05:40:28 GMT"}, {"version": "v3", "created": "Mon, 23 Aug 2010 14:45:26 GMT"}, {"version": "v30", "created": "Wed, 7 Nov 2012 18:03:34 GMT"}, {"version": "v31", "created": "Tue, 4 Dec 2012 18:24:08 GMT"}, {"version": "v32", "created": "Tue, 8 Jan 2013 18:36:23 GMT"}, {"version": "v33", "created": "Wed, 27 Feb 2013 19:45:06 GMT"}, {"version": "v34", "created": "Tue, 26 Mar 2013 15:36:01 GMT"}, {"version": "v35", "created": "Tue, 23 Apr 2013 05:42:37 GMT"}, {"version": "v36", "created": "Mon, 29 Apr 2013 16:05:46 GMT"}, {"version": "v37", "created": "Tue, 7 May 2013 17:40:13 GMT"}, {"version": "v38", "created": "Tue, 25 Jun 2013 18:43:01 GMT"}, {"version": "v39", "created": "Mon, 15 Jul 2013 16:17:05 GMT"}, {"version": "v4", "created": "Tue, 31 Aug 2010 17:25:04 GMT"}, {"version": "v40", "created": "Mon, 19 Aug 2013 16:41:30 GMT"}, {"version": "v41", "created": "Tue, 24 Sep 2013 19:03:29 GMT"}, {"version": "v42", "created": "Tue, 15 Oct 2013 23:52:45 GMT"}, {"version": "v43", "created": "Mon, 16 Dec 2013 20:23:22 GMT"}, {"version": "v44", "created": "Wed, 1 Jan 2014 02:22:43 GMT"}, {"version": "v45", "created": "Fri, 14 Feb 2014 20:49:29 GMT"}, {"version": "v46", "created": "Mon, 21 Apr 2014 13:58:04 GMT"}, {"version": "v47", "created": "Wed, 14 May 2014 15:55:52 GMT"}, {"version": "v48", "created": "Wed, 11 Jun 2014 06:39:04 GMT"}, {"version": "v49", "created": "Mon, 16 Jun 2014 19:33:48 GMT"}, {"version": "v5", "created": "Thu, 9 Sep 2010 18:41:02 GMT"}, {"version": "v50", "created": "Tue, 14 Oct 2014 15:10:41 GMT"}, {"version": "v51", "created": "Wed, 15 Oct 2014 16:52:06 GMT"}, {"version": "v52", "created": "Wed, 5 Nov 2014 15:03:16 GMT"}, {"version": "v53", "created": "Mon, 24 Nov 2014 00:33:38 GMT"}, {"version": "v54", "created": "Mon, 29 Dec 2014 19:30:07 GMT"}, {"version": "v55", "created": "Sun, 11 Jan 2015 00:03:38 GMT"}, {"version": "v56", "created": "Mon, 19 Jan 2015 17:13:01 GMT"}, {"version": "v57", "created": "Sun, 25 Jan 2015 23:31:03 GMT"}, {"version": "v58", "created": "Mon, 9 Feb 2015 18:06:24 GMT"}, {"version": "v59", "created": "Tue, 17 Feb 2015 18:23:20 GMT"}, {"version": "v6", "created": "Mon, 4 Oct 2010 19:15:10 GMT"}, {"version": "v60", "created": "Wed, 4 Mar 2015 21:46:30 GMT"}, {"version": "v7", "created": "Sat, 6 Nov 2010 21:38:29 GMT"}, {"version": "v8", "created": "Mon, 29 Nov 2010 15:58:31 GMT"}, {"version": "v9", "created": "Mon, 6 Dec 2010 20:50:18 GMT"}], "update_date": "2015-03-26", "authors_parsed": [["Hewitt", "Carl", ""]]}, {"id": "1008.2909", "submitter": "Bjoern Andres", "authors": "Bjoern Andres, Ullrich Koethe, Thorben Kroeger, and Fred A. Hamprecht", "title": "Runtime-Flexible Multi-dimensional Arrays and Views for C++98 and C++0x", "comments": "Free source code available", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.MS cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multi-dimensional arrays are among the most fundamental and most useful data\nstructures of all. In C++, excellent template libraries exist for arrays whose\ndimension is fixed at runtime. Arrays whose dimension can change at runtime\nhave been implemented in C. However, a generic object-oriented C++\nimplementation of runtime-flexible arrays has so far been missing. In this\narticle, we discuss our new implementation called Marray, a package of class\ntemplates that fills this gap. Marray is based on views as an underlying\nconcept. This concept brings some of the flexibility known from script\nlanguages such as R and MATLAB to C++. Marray is free both for commercial and\nnon-commercial use and is publicly available from www.andres.sc/marray\n", "versions": [{"version": "v1", "created": "Tue, 17 Aug 2010 14:50:56 GMT"}], "update_date": "2010-08-18", "authors_parsed": [["Andres", "Bjoern", ""], ["Koethe", "Ullrich", ""], ["Kroeger", "Thorben", ""], ["Hamprecht", "Fred A.", ""]]}, {"id": "1008.3431", "submitter": "Venkatareddy Dwarampudi Mr.", "authors": "Venkatreddy Dwarampudi, Shahbaz Singh Dhillon, Jivitesh Shah, Nikhil\n  Joseph Sebastian, Nitin Kanigicharla", "title": "Comparative study of the Pros and Cons of Programming languages Java,\n  Scala, C++, Haskell, VB .NET, AspectJ, Perl, Ruby, PHP & Scheme - a Team 11\n  COMP6411-S10 Term Report", "comments": "28 pages, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  With the advent of numerous languages it is difficult to realize the edge of\none language in a particular scope over another one. We are making an effort,\nrealizing these few issues and comparing some main stream languages like Java,\nScala, C++, Haskell, VB .NET, AspectJ, Perl, Ruby, PHP and Scheme keeping in\nmind some core issues in program development.\n", "versions": [{"version": "v1", "created": "Fri, 20 Aug 2010 03:17:43 GMT"}], "update_date": "2010-08-23", "authors_parsed": [["Dwarampudi", "Venkatreddy", ""], ["Dhillon", "Shahbaz Singh", ""], ["Shah", "Jivitesh", ""], ["Sebastian", "Nikhil Joseph", ""], ["Kanigicharla", "Nitin", ""]]}, {"id": "1008.3434", "submitter": "Sultan Alqahtani Mr", "authors": "Sultan S. Al-Qahtani, Pawel Pietrzynski, Luis F. Guzman, Rafik Arif,\n  Adrien Tevoedjre", "title": "Comparing Selected Criteria of Programming Languages Java, PHP, C++,\n  Perl, Haskell, AspectJ, Ruby, COBOL, Bash Scripts and Scheme Revision 1.0 - a\n  Team CPLgroup COMP6411-S10 Term Report", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Comparison of programming languages is a common topic of discussion among\nsoftware engineers. Few languages ever become sufficiently popular that they\nare used by more than a few people or find their niche in research or\neducation; but professional programmers can easily use dozens of different\nlanguages during their career. Multiple programming languages are designed,\nspecified, and implemented every year in order to keep up with the changing\nprogramming paradigms, hardware evolution, etc. In this paper we present a\ncomparative study between ten programming languages: Haskell, Java, Perl, C++,\nAspectJ, COBOL, Ruby, PHP, Bash Scripts, and Scheme; with respect of the\nfollowing criteria: Secure programming practices, web applications development,\nweb services design and composition, object oriented-based abstraction,\nreflection, aspect-orientation, functional programming, declarative\nprogramming, batch scripting, and user interface prototype design.\n", "versions": [{"version": "v1", "created": "Fri, 20 Aug 2010 04:10:27 GMT"}], "update_date": "2010-08-23", "authors_parsed": [["Al-Qahtani", "Sultan S.", ""], ["Pietrzynski", "Pawel", ""], ["Guzman", "Luis F.", ""], ["Arif", "Rafik", ""], ["Tevoedjre", "Adrien", ""]]}, {"id": "1008.3561", "submitter": "Marinela Miladinova", "authors": "Rana Naim, Mohammad Fahim Nizam, Sheetal Hanamasagar, Jalal\n  Noureddine, Marinela Miladinova", "title": "Comparative Studies of 10 Programming Languages within 10 Diverse\n  Criteria - a Team 10 COMP6411-S10 Term Report", "comments": "126 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is a survey on the programming languages: C++, JavaScript, AspectJ, C#,\nHaskell, Java, PHP, Scala, Scheme, and BPEL. Our survey work involves a\ncomparative study of these ten programming languages with respect to the\nfollowing criteria: secure programming practices, web application development,\nweb service composition, OOP-based abstractions, reflection, aspect\norientation, functional programming, declarative programming, batch scripting,\nand UI prototyping. We study these languages in the context of the above\nmentioned criteria and the level of support they provide for each one of them.\n", "versions": [{"version": "v1", "created": "Fri, 20 Aug 2010 19:50:52 GMT"}], "update_date": "2010-08-23", "authors_parsed": [["Naim", "Rana", ""], ["Nizam", "Mohammad Fahim", ""], ["Hanamasagar", "Sheetal", ""], ["Noureddine", "Jalal", ""], ["Miladinova", "Marinela", ""]]}, {"id": "1008.3863", "submitter": "Carlos A. Romero-Diaz", "authors": "Mario Rodr\\'iguez-Artalejo and Carlos A. Romero-D\\'iaz", "title": "A Generic Scheme for Qualified Logic Programming", "comments": "23 pages, extended version with full proofs of Quantitative Logic\n  Programming Revisited, in J. Garrigue and M. Hermenegildo (Eds.), FLOPS 2008,\n  LNCS 4989, pp. 272-288, 2008. Springer-Verlag Berlin Heidelberg 2008", "journal-ref": null, "doi": null, "report-no": "SIC-1-08", "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Uncertainty in Logic Programming has been investigated since about 25 years,\npublishing papers dealing with various approaches to semantics and different\napplications. This report is intended as a first step towards the investigation\nof qualified computations in Constraint Functional Logic Programming, including\nuncertain computations as a particular case. We revise an early proposal,\nnamely van Emden's Quantitative Logic Programming, and we improve it in two\nways. Firstly, we generalize van Emden's QLP to a generic scheme QLP(D)\nparameterized by any given Qualification Domain D, which must be a lattice\nsatisfying certain natural axioms. We present several interesting instances for\nD, one of which corresponds to van Emden's QLP. Secondly, we generalize van\nEmden's results by providing stronger ones, concerning both semantics and goal\nsolving. We present Qualified SLD Resolution over D, a sound and strongly\ncomplete goal solving procedure for QLP(D), which is applicable to open goals\nand can be efficiently implemented using CLP technology over any constraint\ndomain CD able to deal with qualification constraints over D. We have developed\na prototype implementation of some instances of the QLP(D) scheme (including\nvan Emden's QLP) on top of the CFLP system TOY.\n", "versions": [{"version": "v1", "created": "Mon, 23 Aug 2010 17:19:52 GMT"}], "update_date": "2010-08-24", "authors_parsed": [["Rodr\u00edguez-Artalejo", "Mario", ""], ["Romero-D\u00edaz", "Carlos A.", ""]]}, {"id": "1008.3867", "submitter": "Carlos A. Romero-Diaz", "authors": "Rafael Caballero, Mario Rodr\\'iguez-Artalejo and Carlos A.\n  Romero-D\\'iaz", "title": "Similarity-based Reasoning in Qualified Logic Programming", "comments": "10 pages, 2 figures, revised edition of Similarity-based Reasoning in\n  Qualified Logic Programming, in PPDP '08: Proceedings of the 10th\n  international ACM SIGPLAN conference on Principles and Practice of\n  Declarative Programming. ACM, Valencia, Spain, 185-194. 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Similarity-based Logic Programming (briefly, SLP ) has been proposed to\nenhance the LP paradigm with a kind of approximate reasoning which supports\nflexible information retrieval applications. This approach uses a fuzzy\nsimilarity relation R between symbols in the program's signature, while keeping\nthe syntax for program clauses as in classical LP. Another recent proposal is\nthe QLP(D) scheme for Qualified Logic Programming, an extension of the LP\nparadigm which supports approximate reasoning and more. This approach uses\nannotated program clauses and a parametrically given domain D whose elements\nqualify logical assertions by measuring their closeness to various users'\nexpectations. In this paper we propose a more expressive scheme SQLP(R,D) which\nsubsumes both SLP and QLP(D) as particular cases. We also show that SQLP(R,D)\nprograms can be transformed into semantically equivalent QLP(D) programs. As a\nconsequence, existing QLP(D) implementations can be used to give efficient\nsupport for similarity-based reasoning.\n", "versions": [{"version": "v1", "created": "Mon, 23 Aug 2010 17:33:15 GMT"}], "update_date": "2010-08-24", "authors_parsed": [["Caballero", "Rafael", ""], ["Rodr\u00edguez-Artalejo", "Mario", ""], ["Romero-D\u00edaz", "Carlos A.", ""]]}, {"id": "1008.4188", "submitter": "Ralf L\\\"ammel", "authors": "Ralf L\\\"ammel and Vadim Zaytsev", "title": "Recovering Grammar Relationships for the Java Language Specification", "comments": null, "journal-ref": "Software Quality Journal, 19:2, pages 333-378. Springer, 2011", "doi": "10.1007/s11219-010-9116-5", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Grammar convergence is a method that helps discovering relationships between\ndifferent grammars of the same language or different language versions. The key\nelement of the method is the operational, transformation-based representation\nof those relationships. Given input grammars for convergence, they are\ntransformed until they are structurally equal. The transformations are composed\nfrom primitive operators; properties of these operators and the composed chains\nprovide quantitative and qualitative insight into the relationships between the\ngrammars at hand. We describe a refined method for grammar convergence, and we\nuse it in a major study, where we recover the relationships between all the\ngrammars that occur in the different versions of the Java Language\nSpecification (JLS). The relationships are represented as grammar\ntransformation chains that capture all accidental or intended differences\nbetween the JLS grammars. This method is mechanized and driven by nominal and\nstructural differences between pairs of grammars that are subject to\nasymmetric, binary convergence steps. We present the underlying operator suite\nfor grammar transformation in detail, and we illustrate the suite with many\nexamples of transformations on the JLS grammars. We also describe the\nextraction effort, which was needed to make the JLS grammars amenable to\nautomated processing. We include substantial metadata about the convergence\nprocess for the JLS so that the effort becomes reproducible and transparent.\n", "versions": [{"version": "v1", "created": "Wed, 25 Aug 2010 02:11:12 GMT"}], "update_date": "2011-07-20", "authors_parsed": [["L\u00e4mmel", "Ralf", ""], ["Zaytsev", "Vadim", ""]]}]