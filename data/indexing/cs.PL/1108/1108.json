[{"id": "1108.0190", "submitter": "Sergio Antoy", "authors": "Sergio Antoy", "title": "On the Correctness of Pull-Tabbing", "comments": null, "journal-ref": "Theory and Practice of Logic Programming, vol. 11, no. 4-5, pp.\n  713-730, 2011", "doi": "10.1017/S1471068411000263", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Pull-tabbing is an evaluation approach for functional logic computations,\nbased on a graph transformation recently proposed, which avoids making\nirrevocable non-deterministic choices that would jeopardize the completeness of\ncomputations. In contrast to other approaches with this property, it does not\nrequire an upfront cloning of a possibly large portion of the choice's context.\nWe formally define the pull-tab transformation, characterize the class of\nprograms for which the transformation is intended, extend the computations in\nthese programs to include the transformation, and prove the correctness of the\nextended computations.\n", "versions": [{"version": "v1", "created": "Sun, 31 Jul 2011 18:01:14 GMT"}], "update_date": "2011-08-02", "authors_parsed": [["Antoy", "Sergio", ""]]}, {"id": "1108.0229", "submitter": "EPTCS", "authors": "Ross Horne (University of Southampton), Vladimiro Sassone (University\n  of Southampton)", "title": "A Verified Algebra for Linked Data", "comments": "In Proceedings FOCLASA 2011, arXiv:1107.5847", "journal-ref": "EPTCS 58, 2011, pp. 20-33", "doi": "10.4204/EPTCS.58.2", "report-no": null, "categories": "cs.LO cs.NI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A foundation is investigated for the application of loosely structured data\non the Web. This area is often referred to as Linked Data, due to the use of\nURIs in data to establish links. This work focuses on emerging W3C standards\nwhich specify query languages for Linked Data. The approach is to provide an\nabstract syntax to capture Linked Data structures and queries, which are then\ninternalised in a process calculus. An operational semantics for the calculus\nspecifies how queries, data and processes interact. A labelled transition\nsystem is shown to be sound with respect to the operational semantics.\nBisimulation over the labelled transition system is used to verify an algebra\nover queries. The derived algebra is a contribution to the application domain.\nFor instance, the algebra may be used to rewrite a query to optimise its\ndistribution across a cluster of servers. The framework used to provide the\noperational semantics is powerful enough to model related calculi for the Web.\n", "versions": [{"version": "v1", "created": "Mon, 1 Aug 2011 03:58:02 GMT"}], "update_date": "2011-08-02", "authors_parsed": [["Horne", "Ross", "", "University of Southampton"], ["Sassone", "Vladimiro", "", "University\n  of Southampton"]]}, {"id": "1108.0329", "submitter": "Remy Haemmerle", "authors": "R\\'emy Haemmerl\\'e", "title": "Observational equivalences for linear logic CC languages", "comments": "17 pages", "journal-ref": "Theory and Practice of Logic Programming, 11(4-5): 469-485, 2011", "doi": "10.1017/S1471068411000123", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linear logic Concurrent Constraint programming (LCC) is an extension of\nconcurrent constraint programming (CC) where the constraint system is based on\nGirard's linear logic instead of the classical logic. In this paper we address\nthe problem of program equivalence for this programming framework. For this\npurpose, we present a structural operational semantics for LCC based on a label\ntransition system and investigate different notions of observational\nequivalences inspired by the state of art of process algebras. Then, we\ndemonstrate that the asynchronous \\pi-calculus can be viewed as simple\nsyntactical restrictions of LCC. Finally we show LCC observational equivalences\ncan be transposed straightforwardly to classical Concurrent Constraint\nlanguages and Constraint Handling Rules, and investigate the resulting\nequivalences.\n", "versions": [{"version": "v1", "created": "Mon, 1 Aug 2011 14:56:56 GMT"}], "update_date": "2011-08-02", "authors_parsed": [["Haemmerl\u00e9", "R\u00e9my", ""]]}, {"id": "1108.0330", "submitter": "Remy Haemmerle", "authors": "R\\'emy Haemmerl\\'e", "title": "(Co-)Inductive semantics for Constraint Handling Rules", "comments": "17 pages", "journal-ref": "Theory and Practice of Logic Programming, 11(4-5): 593-609, 2011", "doi": "10.1017/S1471068411000196", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we address the problem of defining a fixpoint semantics for\nConstraint Handling Rules (CHR) that captures the behavior of both\nsimplification and propagation rules in a sound and complete way with respect\nto their declarative semantics. Firstly, we show that the logical reading of\nstates with respect to a set of simplification rules can be characterized by a\nleast fixpoint over the transition system generated by the abstract operational\nsemantics of CHR. Similarly, we demonstrate that the logical reading of states\nwith respect to a set of propagation rules can be characterized by a greatest\nfixpoint. Then, in order to take advantage of both types of rules without\nlosing fixpoint characterization, we present an operational semantics with\npersistent. We finally establish that this semantics can be characterized by\ntwo nested fixpoints, and we show the resulting language is an elegant\nframework to program using coinductive reasoning.\n", "versions": [{"version": "v1", "created": "Mon, 1 Aug 2011 15:02:43 GMT"}], "update_date": "2011-08-02", "authors_parsed": [["Haemmerl\u00e9", "R\u00e9my", ""]]}, {"id": "1108.0363", "submitter": "Fabian Steeg", "authors": "Fabian Steeg", "title": "Typesafe Modeling in Text Mining", "comments": "63 pages, in German", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.IR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Based on the concept of annotation-based agents, this report introduces tools\nand a formal notation for defining and running text mining experiments using a\nstatically typed domain-specific language embedded in Scala. Using machine\nlearning for classification as an example, the framework is used to develop and\ndocument text mining experiments, and to show how the concept of generic,\ntypesafe annotation corresponds to a general information model that goes beyond\ntext processing.\n", "versions": [{"version": "v1", "created": "Thu, 28 Jul 2011 17:46:20 GMT"}], "update_date": "2011-08-02", "authors_parsed": [["Steeg", "Fabian", ""]]}, {"id": "1108.0464", "submitter": "EPTCS", "authors": "Vincenzo Ciancia", "title": "Interaction and observation, categorically", "comments": "In Proceedings ICE 2011, arXiv:1108.0144", "journal-ref": "EPTCS 59, 2011, pp. 25-36", "doi": "10.4204/EPTCS.59.3", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes to use dialgebras to specify the semantics of interactive\nsystems in a natural way. Dialgebras are a conservative extension of\ncoalgebras. In this categorical model, from the point of view that we provide,\nthe notions of observation and interaction are separate features. This is\nuseful, for example, in the specification of process equivalences, which are\nobtained as kernels of the homomorphisms of dialgebras. As an example we\npresent the asynchronous semantics of the CCS.\n", "versions": [{"version": "v1", "created": "Tue, 2 Aug 2011 02:27:04 GMT"}], "update_date": "2011-08-03", "authors_parsed": [["Ciancia", "Vincenzo", ""]]}, {"id": "1108.0466", "submitter": "EPTCS", "authors": "Viviana Bono (Torino, Italy), Luca Padovani (Torino, Italy)", "title": "Polymorphic Endpoint Types for Copyless Message Passing", "comments": "In Proceedings ICE 2011, arXiv:1108.0144", "journal-ref": "EPTCS 59, 2011, pp. 52-67", "doi": "10.4204/EPTCS.59.5", "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present PolySing#, a calculus that models process interaction based on\ncopyless message passing, in the style of Singularity OS. We equip the calculus\nwith a type system that accommodates polymorphic endpoint types, which are a\nvariant of polymorphic session types, and we show that well-typed processes are\nfree from faults, leaks, and communication errors. The type system is\nessentially linear, although linearity alone may leave room for scenarios where\nwell-typed processes leak memory. We identify a condition on endpoint types\nthat prevents these leaks from occurring.\n", "versions": [{"version": "v1", "created": "Tue, 2 Aug 2011 02:27:18 GMT"}], "update_date": "2011-08-03", "authors_parsed": [["Bono", "Viviana", "", "Torino, Italy"], ["Padovani", "Luca", "", "Torino, Italy"]]}, {"id": "1108.0468", "submitter": "EPTCS", "authors": "Sung-Shik T.Q. Jongmans, Farhad Arbab", "title": "Correlating Formal Semantic Models of Reo Connectors: Connector Coloring\n  and Constraint Automata", "comments": "In Proceedings ICE 2011, arXiv:1108.0144", "journal-ref": "EPTCS 59, 2011, pp. 84-103", "doi": "10.4204/EPTCS.59.8", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Over the past decades, coordination languages have emerged for the\nspecification and implementation of interaction protocols for communicating\nsoftware components. This class of languages includes Reo, a platform for\ncompositional construction of connectors. In recent years, various formalisms\nfor describing the behavior of Reo connectors have come to existence, each of\nthem serving its own purpose. Naturally, questions about how these models\nrelate to each other arise. From a theoretical point of view, answers to these\nquestions provide us with better insight into the fundamentals of Reo, while\nfrom a more practical perspective, these answers broaden the applicability of\nReo's development tools. In this paper, we address one of these questions: we\ninvestigate the equivalence between coloring models and constraint automata,\nthe two most dominant and practically relevant semantic models of Reo. More\nspecifically, we define operators that transform one model to the other (and\nvice versa), prove their correctness, and show that they distribute over\ncomposition. To ensure that the transformation operators map one-to-one\n(instead of many-to-one), we extend coloring models with data constraints.\nThough primarily a theoretical contribution, we sketch some potential\napplications of our results: the broadening of the applicability of existing\ntools for connector verification and animation.\n", "versions": [{"version": "v1", "created": "Tue, 2 Aug 2011 02:27:34 GMT"}], "update_date": "2011-08-03", "authors_parsed": [["Jongmans", "Sung-Shik T. Q.", ""], ["Arbab", "Farhad", ""]]}, {"id": "1108.0470", "submitter": "EPTCS", "authors": "Laura Bocchi (Department of Computer Science, University of\n  Leicester), Julien Lange (Department of Computer Science, University of\n  Leicester), Emilio Tuosto (Department of Computer Science, University of\n  Leicester)", "title": "Amending Contracts for Choreographies", "comments": "In Proceedings ICE 2011, arXiv:1108.0144", "journal-ref": "EPTCS 59, 2011, pp. 111-129", "doi": "10.4204/EPTCS.59.10", "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Distributed interactions can be suitably designed in terms of choreographies.\nSuch abstractions can be thought of as global descriptions of the coordination\nof several distributed parties. Global assertions define contracts for\nchoreographies by annotating multiparty session types with logical formulae to\nvalidate the content of the exchanged messages. The introduction of such\nconstraints is a critical design issue as it may be hard to specify contracts\nthat allow each party to be able to progress without violating the contract. In\nthis paper, we propose three methods that automatically correct inconsistent\nglobal assertions. The methods are compared by discussing their applicability\nand the relationships between the amended global assertions and the original\n(inconsistent) ones.\n", "versions": [{"version": "v1", "created": "Tue, 2 Aug 2011 02:27:44 GMT"}], "update_date": "2011-08-03", "authors_parsed": [["Bocchi", "Laura", "", "Department of Computer Science, University of\n  Leicester"], ["Lange", "Julien", "", "Department of Computer Science, University of\n  Leicester"], ["Tuosto", "Emilio", "", "Department of Computer Science, University of\n  Leicester"]]}, {"id": "1108.0471", "submitter": "EPTCS", "authors": "Massimo Bartoletti (Dipartimento di Matematica e Informatica,\n  Universita' degli Studi di Cagliari, Italy), Emilio Tuosto (Department of\n  Computer Science, University of Leicester, UK), Roberto Zunino\n  (DISI-Universita' degli Studi di Trento and COSBI, Italy)", "title": "Contracts in distributed systems", "comments": "In Proceedings ICE 2011, arXiv:1108.0144", "journal-ref": "EPTCS 59, 2011, pp. 130-147", "doi": "10.4204/EPTCS.59.11", "report-no": null, "categories": "cs.PL cs.DC cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a parametric calculus for contract-based computing in distributed\nsystems. By abstracting from the actual contract language, our calculus\ngeneralises both the contracts-as-processes and contracts-as-formulae\nparadigms. The calculus features primitives for advertising contracts, for\nreaching agreements, and for querying the fulfilment of contracts. Coordination\namong principals happens via multi-party sessions, which are created once\nagreements are reached. We present two instances of our calculus, by modelling\ncontracts as (i) processes in a variant of CCS, and (ii) as formulae in a\nlogic. With the help of a few examples, we discuss the primitives of our\ncalculus, as well as some possible variants.\n", "versions": [{"version": "v1", "created": "Tue, 2 Aug 2011 02:27:50 GMT"}], "update_date": "2011-08-03", "authors_parsed": [["Bartoletti", "Massimo", "", "Dipartimento di Matematica e Informatica,\n  Universita' degli Studi di Cagliari, Italy"], ["Tuosto", "Emilio", "", "Department of\n  Computer Science, University of Leicester, UK"], ["Zunino", "Roberto", "", "DISI-Universita' degli Studi di Trento and COSBI, Italy"]]}, {"id": "1108.0476", "submitter": "Saverio Perugini", "authors": "Saverio Perugini", "title": "Specifying and Staging Mixed-Initiative Dialogs with Program Generation\n  and Transformation", "comments": "combined/reorganized some figures/tables from version 4, and\n  corrected typos; 22 pages, 5 tables, 5 figures, and 5 listings", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI cs.HC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Specifying and implementing flexible human-computer dialogs, such as those\nused in kiosks and smart phone apps, is challenging because of the numerous and\nvaried directions in which each user might steer a dialog. The objective of\nthis research is to improve dialog specification and implementation. To do so\nwe enriched a notation based on concepts from programming languages, especially\npartial evaluation, for specifying a variety of unsolicited reporting,\nmixed-initiative dialogs in a concise representation that serves as a design\nfor dialog implementation. We also built a dialog mining system that extracts a\nspecification in this notation from requirements. To demonstrate that such a\nspecification provides a design for dialog implementation, we built a system\nthat automatically generates an implementation of the dialog, called a stager,\nfrom it. These two components constitute a dialog modeling toolkit that\nautomates dialog specification and implementation. These results provide a\nproof of concept and demonstrate the study of dialog specification and\nimplementation from a programming languages perspective. The ubiquity of\ndialogs in domains such as travel, education, and health care combined with the\ndemand for smart phone apps provide a landscape for further investigation of\nthese results.\n", "versions": [{"version": "v1", "created": "Tue, 2 Aug 2011 03:00:09 GMT"}, {"version": "v2", "created": "Tue, 20 May 2014 20:58:47 GMT"}, {"version": "v3", "created": "Sat, 30 Aug 2014 20:05:58 GMT"}, {"version": "v4", "created": "Thu, 17 Dec 2015 00:29:04 GMT"}, {"version": "v5", "created": "Mon, 21 Dec 2015 15:10:54 GMT"}], "update_date": "2015-12-22", "authors_parsed": [["Perugini", "Saverio", ""]]}, {"id": "1108.1452", "submitter": "EPTCS", "authors": "Luca Aceto (Reykjavik University), Mohammad Reza Mousavi (Eindhoven\n  University of Technology)", "title": "Proceedings First International Workshop on Process Algebra and\n  Coordination", "comments": null, "journal-ref": "EPTCS 60, 2011", "doi": "10.4204/EPTCS.60", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Process algebra provides abstract and rigorous means for studying\ncommunicating concurrent systems. Coordination languages also provide abstract\nmeans for the specifying and programming communication of components. Hence,\nthe two fields seem to have very much in common and the link between these two\nresearch areas have been established formally by means of several translations,\nmainly from coordination languages to process algebras. There have also been\nproposals of process algebras whose communication policy is inspired by the one\nunderlying coordination languages.\n  The aim of this workshop was to push the state of the art in the study of the\nconnections between process algebra and coordination languages by bringing\ntogether experts as well as young researchers from the two fields to\ncommunicate their ideas and findings. It includes both contributed and invited\npapers that have been presented during the one day meeting on Process Algebra\nand Coordination (PACO 2011) which took place on June 9, 2011 in Reykjavik,\nIceland.\n", "versions": [{"version": "v1", "created": "Sat, 6 Aug 2011 05:23:21 GMT"}], "update_date": "2011-08-09", "authors_parsed": [["Aceto", "Luca", "", "Reykjavik University"], ["Mousavi", "Mohammad Reza", "", "Eindhoven\n  University of Technology"]]}, {"id": "1108.1863", "submitter": "EPTCS", "authors": "Jos Baeten (Department of Mechanical Engineering, Eindhoven University\n  of Technology), Bert van Beek (Department of Mechanical Engineering,\n  Eindhoven University of Technology), Allan van Hulst (Department of\n  Mechanical Engineering, Eindhoven University of Technology), Jasen Markovski\n  (Department of Mechanical Engineering, Eindhoven University of Technology)", "title": "A Process Algebra for Supervisory Coordination", "comments": "In Proceedings PACO 2011, arXiv:1108.1452", "journal-ref": "EPTCS 60, 2011, pp. 36-55", "doi": "10.4204/EPTCS.60.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A supervisory controller controls and coordinates the behavior of different\ncomponents of a complex machine by observing their discrete behaviour.\nSupervisory control theory studies automated synthesis of controller models,\nknown as supervisors, based on formal models of the machine components and a\nformalization of the requirements. Subsequently, code generation can be used to\nimplement this supervisor in software, on a PLC, or embedded microprocessor. In\nthis article, we take a closer look at the control loop that couples the\nsupervisory controller and the machine. We model both event-based and\nstate-based observations using process algebra and bisimulation-based\nsemantics. The main application area of supervisory control that we consider is\ncoordination, referred to as supervisory coordination, and we give an academic\nand an industrial example, discussing the process-theoretic concepts employed.\n", "versions": [{"version": "v1", "created": "Tue, 9 Aug 2011 06:38:31 GMT"}], "update_date": "2011-08-10", "authors_parsed": [["Baeten", "Jos", "", "Department of Mechanical Engineering, Eindhoven University\n  of Technology"], ["van Beek", "Bert", "", "Department of Mechanical Engineering,\n  Eindhoven University of Technology"], ["van Hulst", "Allan", "", "Department of\n  Mechanical Engineering, Eindhoven University of Technology"], ["Markovski", "Jasen", "", "Department of Mechanical Engineering, Eindhoven University of Technology"]]}, {"id": "1108.2359", "submitter": "EPTCS", "authors": "Letterio Galletta (Dipartimento di Informatica, Universit\\`a di Pisa),\n  Giorgio Levi (Dipartimento di Informatica, Universit\\`a di Pisa)", "title": "An Abstract Semantics for Inference of Types and Effects in a Multi-Tier\n  Web Language", "comments": "In Proceedings WWV 2011, arXiv:1108.2085", "journal-ref": "EPTCS 61, 2011, pp. 81-95", "doi": "10.4204/EPTCS.61.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Types-and-effects are type systems, which allow one to express general\nsemantic properties and to statically reason about program's execution. They\nhave been widely exploited to specify static analyses, for example to track\ncomputational side effects, exceptions and communications in concurrent\nprograms. In this paper we adopt abstract interpretation techniques to\nreconstruct (following the Cousot's methodology) a types-and-effects system\ndeveloped to handle security problems of a multi-tier web language. Our\nreconstruction allows us to show that this types-and-effects system is not\nsound with respect to the semantics of the language. In addition, we correct\nthe soundness issues in the analysis and systematically construct a correct\nanalyser.\n", "versions": [{"version": "v1", "created": "Thu, 11 Aug 2011 09:27:54 GMT"}], "update_date": "2011-08-12", "authors_parsed": [["Galletta", "Letterio", "", "Dipartimento di Informatica, Universit\u00e0 di Pisa"], ["Levi", "Giorgio", "", "Dipartimento di Informatica, Universit\u00e0 di Pisa"]]}, {"id": "1108.2360", "submitter": "EPTCS", "authors": "Marco Giunti (INRIA and LIX, Ecole Polytechnique, France)", "title": "A type checking algorithm for qualified session types", "comments": "In Proceedings WWV 2011, arXiv:1108.2085", "journal-ref": "EPTCS 61, 2011, pp. 96-114", "doi": "10.4204/EPTCS.61.7", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a type checking algorithm for establishing a session-based\ndiscipline in the pi calculus of Milner, Parrow and Walker. Our session types\nare qualified as linear or unrestricted. Linearly typed communication channels\nare guaranteed to occur in exactly one thread, possibly multiple times;\nafterwards they evolve as unrestricted channels. Session protocols are\ndescribed by a type constructor that denotes the two ends of one and the same\ncommunication channel. We ensure the soundness of the algorithm by showing that\nprocesses consuming all linear resources are accepted by a type system\npreserving typings during the computation and that type checking is consistent\nw.r.t. structural congruence.\n", "versions": [{"version": "v1", "created": "Thu, 11 Aug 2011 09:28:01 GMT"}], "update_date": "2011-08-12", "authors_parsed": [["Giunti", "Marco", "", "INRIA and LIX, Ecole Polytechnique, France"]]}, {"id": "1108.2683", "submitter": "Hamid A. Toussi", "authors": "Hamid A. Toussi and Ahmed Khademzadeh", "title": "Improving bit-vector representation of points-to sets using class\n  hierarchy", "comments": null, "journal-ref": "Proceeding of ICSCT 2010, Kunming, China, November 2010", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Points-to analysis is the problem of approximating run-time values of\npointers statically or at compile-time. Points-to sets are used to store the\napproximated values of pointers during points-to analysis. Memory usage and\nrunning time limit the ability of points-to analysis to analyze large programs.\n  To our knowledge, works which have implemented a bit-vector representation of\npoints-to sets so far, allocates bits for each pointer without considering\npointer's type. By considering the type, we are able to allocate bits only for\na subset of all abstract objects which are of compatible type with the\npointer's type and as a consequence improve the memory usage and running time.\nTo achieve this goal, we number abstract objects in a way that all the abstract\nobjects of a type and all of its sub-types be consecutive in order.\n  Our most efficient implementation uses about 2.5 times less memory than\nhybrid points-to set (default points-to set in Spark) and also improves the\nanalysis time for sufficiently large programs.\n", "versions": [{"version": "v1", "created": "Fri, 12 Aug 2011 18:24:16 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Toussi", "Hamid A.", ""], ["Khademzadeh", "Ahmed", ""]]}, {"id": "1108.2796", "submitter": "EPTCS", "authors": "M.A. Reniers (Eindhoven University of Technology, The Netherlands), P.\n  Sobocinski (University of Southampton, United Kingdom)", "title": "Proceedings Eight Workshop on Structural Operational Semantics 2011", "comments": null, "journal-ref": "EPTCS 62, 2011", "doi": "10.4204/EPTCS.62", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of SOS 2011, the Eight Workshop on\nStructural Operational Semantics, held on the 5th of September 2011 in Aachen,\nGermany as an affiliated workshop of CONCUR 2011, the 22nd International\nConference on Concurrency Theory.\n  Structural operational semantics (SOS) provides a framework for giving\noperational semantics to programming and specification languages. A growing\nnumber of programming languages from commercial and academic spheres have been\ngiven usable semantic descriptions by means of structural operational\nsemantics. Because of its intuitive appeal and flexibility, structural\noperational semantics has found considerable application in the study of the\nsemantics of concurrent processes. It is also a viable alternative to\ndenotational semantics in the static analysis of programs, and in proving\ncompiler correctness. Moreover, it has found application in emerging areas of\ncomputing such as probabilistic systems and systems biology.\n  Structural operational semantics has been successfully applied as a formal\ntool to establish results that hold for classes of process description\nlanguages. This has allowed for the generalization of well-known results in the\nfield of process algebra, and for the development of a meta-theory for process\ncalculi based on the realization that many of the results in this field only\ndepend upon general semantic properties of language constructs.\n  The workshop is a forum for researchers, students and practitioners\ninterested in new developments and directions for future investigations. One of\nthe specific goals of the workshop is to provide a meeting point for the\nconcurrency and programming language communities. Another goal is the\ndissemination of the theory and practice of SOS amongst postgraduate students\nand young researchers worldwide.\n", "versions": [{"version": "v1", "created": "Sat, 13 Aug 2011 14:27:59 GMT"}], "update_date": "2011-08-16", "authors_parsed": [["Reniers", "M. A.", "", "Eindhoven University of Technology, The Netherlands"], ["Sobocinski", "P.", "", "University of Southampton, United Kingdom"]]}, {"id": "1108.3260", "submitter": "Esra Erdem", "authors": "Thomas Eiter and Esra Erdem and Halit Erdogan and Michael Fink", "title": "Finding Similar/Diverse Solutions in Answer Set Programming", "comments": "57 pages, 17 figures, 4 tables. To appear in Theory and Practice of\n  Logic Programming (TPLP)", "journal-ref": "Theory and Practice of Logic Programming, 13(3), 303-359, 2013", "doi": "10.1017/S1471068411000548", "report-no": null, "categories": "cs.AI cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For some computational problems (e.g., product configuration, planning,\ndiagnosis, query answering, phylogeny reconstruction) computing a set of\nsimilar/diverse solutions may be desirable for better decision-making. With\nthis motivation, we studied several decision/optimization versions of this\nproblem in the context of Answer Set Programming (ASP), analyzed their\ncomputational complexity, and introduced offline/online methods to compute\nsimilar/diverse solutions of such computational problems with respect to a\ngiven distance function. All these methods rely on the idea of computing\nsolutions to a problem by means of finding the answer sets for an ASP program\nthat describes the problem. The offline methods compute all solutions in\nadvance using the ASP formulation of the problem with an ASP solver, like\nClasp, and then identify similar/diverse solutions using clustering methods.\nThe online methods compute similar/diverse solutions following one of the three\napproaches: by reformulating the ASP representation of the problem to compute\nsimilar/diverse solutions at once using an ASP solver; by computing\nsimilar/diverse solutions iteratively (one after other) using an ASP solver; by\nmodifying the search algorithm of an ASP solver to compute similar/diverse\nsolutions incrementally. We modified Clasp to implement the last online method\nand called it Clasp-NK. In the first two online methods, the given distance\nfunction is represented in ASP; in the last one it is implemented in C++. We\nshowed the applicability and the effectiveness of these methods on\nreconstruction of similar/diverse phylogenies for Indo-European languages, and\non several planning problems in Blocks World. We observed that in terms of\ncomputational efficiency the last online method outperforms the others; also it\nallows us to compute similar/diverse solutions when the distance function\ncannot be represented in ASP.\n", "versions": [{"version": "v1", "created": "Tue, 16 Aug 2011 14:59:44 GMT"}], "update_date": "2013-09-19", "authors_parsed": [["Eiter", "Thomas", ""], ["Erdem", "Esra", ""], ["Erdogan", "Halit", ""], ["Fink", "Michael", ""]]}, {"id": "1108.3265", "submitter": "Matthew Hammer", "authors": "Matthew A. Hammer and Georg Neis and Yan Chen and Umut A. Acar", "title": "Self-Adjusting Stack Machines", "comments": "Full version of our OOPLSA 2011 paper. Contains a couple of\n  additional sections as well as an appendix with our proofs", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Self-adjusting computation offers a language-based approach to writing\nprograms that automatically respond to dynamically changing data. Recent work\nmade significant progress in developing sound semantics and associated\nimplementations of self-adjusting computation for high-level, functional\nlanguages. These techniques, however, do not address issues that arise for\nlow-level languages, i.e., stack-based imperative languages that lack strong\ntype systems and automatic memory management.\n  In this paper, we describe techniques for self-adjusting computation which\nare suitable for low-level languages. Necessarily, we take a different approach\nthan previous work: instead of starting with a high-level language with\nadditional primitives to support self-adjusting computation, we start with a\nlow-level intermediate language, whose semantics is given by a stack-based\nabstract machine. We prove that this semantics is sound: it always updates\ncomputations in a way that is consistent with full reevaluation. We give a\ncompiler and runtime system for the intermediate language used by our abstract\nmachine. We present an empirical evaluation that shows that our approach is\nefficient in practice, and performs favorably compared to prior proposals.\n", "versions": [{"version": "v1", "created": "Tue, 16 Aug 2011 15:19:42 GMT"}], "update_date": "2011-08-17", "authors_parsed": [["Hammer", "Matthew A.", ""], ["Neis", "Georg", ""], ["Chen", "Yan", ""], ["Acar", "Umut A.", ""]]}, {"id": "1108.4048", "submitter": "Timothy Wang", "authors": "Timothy Wang, Romain Jobredeaux, E. Feron", "title": "A graphical environment to express the semantics of control systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.PL math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present the concept of a unified graphical environment for expressing the\nsemantics of control systems. The graphical control system design environment\nin Simulink already allows engineers to insert a variety of assertions aimed\nthe verification and validation of the control software. We propose extensions\nto a Simulink-like environment's annotation capabilities to include formal\ncontrol system stability, performance properties and their proofs. We provide a\nconceptual description of a tool, that takes in a Simulink-like diagram of the\ncontrol system as the input, and generates a graphically annotated control\nsystem diagram as the output. The annotations can either be inserted by the\nuser or generated automatically by a third party control analysis software such\nas IQC$\\beta$ or $\\mu$-tool. We finally describe how the graphical\nrepresentation of the system and its properties can be translated to annotated\nprograms in a programming language used in verification and validation such as\nLustre or C.\n", "versions": [{"version": "v1", "created": "Fri, 19 Aug 2011 20:49:52 GMT"}], "update_date": "2011-08-23", "authors_parsed": [["Wang", "Timothy", ""], ["Jobredeaux", "Romain", ""], ["Feron", "E.", ""]]}, {"id": "1108.4467", "submitter": "EPTCS", "authors": "Ugo Dal Lago, Paolo Di Giamberardino", "title": "Soft Session Types", "comments": "In Proceedings EXPRESS 2011, arXiv:1108.4077", "journal-ref": "EPTCS 64, 2011, pp. 59-73", "doi": "10.4204/EPTCS.64.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show how systems of session types can enforce interactions to be bounded\nfor all typable processes. The type system we propose is based on Lafont's soft\nlinear logic and is strongly inspired by recent works about session types as\nintuitionistic linear logic formulas. Our main result is the existence, for\nevery typable process, of a polynomial bound on the length of any reduction\nsequence starting from it and on the size of any of its reducts.\n", "versions": [{"version": "v1", "created": "Tue, 23 Aug 2011 01:23:29 GMT"}], "update_date": "2011-08-24", "authors_parsed": [["Lago", "Ugo Dal", ""], ["Di Giamberardino", "Paolo", ""]]}, {"id": "1108.4547", "submitter": "William Harrison", "authors": "William Harrison", "title": "Language Support for Declarative Future Commitments", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Sequential programming and work-flow programming are two useful, but\nradically different, ways of describing computational processing. Of the two,\nit is sequential programming that we teach all programmers and support by\nprogramming languages, whether in procedural, objectoriented, or functional\nparadigms. We teach workflow as a secondary style of problem decomposition for\nuse in special situations, like distributed or networked processing. Both\nstyles offer complementary advantages, but the fact that they employ radically\ndifferent models for ownership of continuations interferes with our ability to\nintegrate them in a way that allows them to be taught and used in a single\nprogramming language. This paper describes a programming language construct,\ndeclarative future commitments, that permit better integration of the two.\n", "versions": [{"version": "v1", "created": "Tue, 23 Aug 2011 10:44:28 GMT"}], "update_date": "2011-08-24", "authors_parsed": [["Harrison", "William", ""]]}, {"id": "1108.4706", "submitter": "Stephen Chang", "authors": "Stephen Chang and John Clements and Eli Barzilay and Matthias\n  Felleisen", "title": "Stepping Lazy Programs", "comments": "submitted to ICFP 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Debugging lazy functional programs poses serious challenges. In support of\nthe \"stop, examine, and resume\" debugging style of imperative languages, some\ndebugging tools abandon lazy evaluation. Other debuggers preserve laziness but\npresent it in a way that may confuse programmers because the focus of\nevaluation jumps around in a seemingly random manner.\n  In this paper, we introduce a supplemental tool, the algebraic program\nstepper. An algebraic stepper shows computation as a mathematical calculation.\nAlgebraic stepping could be particularly useful for novice programmers or\nprogrammers new to lazy programming. Mathematically speaking, an algebraic\nstepper renders computation as the standard rewriting sequence of a lazy\nlambda-calculus. Our novel lazy semantics introduces lazy evaluation as a form\nof parallel program rewriting. It represents a compromise between Launchbury's\nstore-based semantics and a simple, axiomatic description of lazy computation\nas sharing-via-parameters. Finally, we prove that the stepper's run-time\nmachinery correctly reconstructs the standard rewriting sequence.\n", "versions": [{"version": "v1", "created": "Tue, 23 Aug 2011 21:37:59 GMT"}], "update_date": "2011-08-25", "authors_parsed": [["Chang", "Stephen", ""], ["Clements", "John", ""], ["Barzilay", "Eli", ""], ["Felleisen", "Matthias", ""]]}, {"id": "1108.4816", "submitter": "William Harrison", "authors": "William Harrison, Tim Walsh, Paul Biggar", "title": "Some Measurements of Nullable and Non-Nullable Parameter Declarations in\n  Relation to Software Malleability", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The usual advantages put forward for including nullability declarations in\nthe type systems of programming languages are that they improve program\nreliability or performance. But there is another, entirely different, reason\nfor doing so. In the right context, this information enables the software\nartifacts we produce, the objects and methods, to exhibit much greater\nmalleability. For declaratively typed languages, we can obtain greater software\nmalleability by extending the model of method call so that assurance of a\nmethod's availability can be provided by any non-nullable parameter, not simply\nthe target parameter, and by allowing the method's implementation to reside in\nclasses or objects other than the target..\n  This paper examines the question of whether this hypothetical improvement in\nsoftware malleability is consistent with existing programming practice by\nexamining the question of the extent to which methods in existing software have\nmultiplicities of non-nullable parameters. The circumstance occurs frequently\nenough to provide an important reason to introduce declarations of nullability\ninto programming languages.\n", "versions": [{"version": "v1", "created": "Wed, 24 Aug 2011 11:41:00 GMT"}], "update_date": "2011-08-25", "authors_parsed": [["Harrison", "William", ""], ["Walsh", "Tim", ""], ["Biggar", "Paul", ""]]}, {"id": "1108.5062", "submitter": "Samuel Mimram", "authors": "Romain Beauxis (LIX, INRIA Saclay - Ile de France), Samuel Mimram (CEA\n  LIST)", "title": "A Non-Standard Semantics for Kahn Networks in Continuous Time", "comments": "2010", "journal-ref": "Computer Science Logic (CSL'11) - 25th International Workshop/20th\n  Annual Conference of the EACSL 12 (2011) 35-50", "doi": "10.4230/LIPIcs.CSL.2011.35", "report-no": null, "categories": "cs.PL math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a seminal article, Kahn has introduced the notion of process network and\ngiven a semantics for those using Scott domains whose elements are (possibly\ninfinite) sequences of values. This model has since then become a standard tool\nfor studying distributed asynchronous computations. From the beginning, process\nnetworks have been drawn as particular graphs, but this syntax is never\nformalized. We take the opportunity to clarify it by giving a precise\ndefinition of these graphs, that we call nets. The resulting category is shown\nto be a fixpoint category, i.e. a cartesian category which is traced wrt the\nmonoidal structure given by the product, and interestingly this structure\ncharacterizes the category: we show that it is the free fixpoint category\ncontaining a given set of morphisms, thus providing a complete axiomatics that\nmodels of process networks should satisfy. We then use these tools to build a\nmodel of networks in which data vary over a continuous time, in order to\nelaborate on the idea that process networks should also be able to encompass\ncomputational models such as hybrid systems or electric circuits. We relate\nthis model to Kahn's semantics by introducing a third model of networks based\non non-standard analysis, whose elements form an internal complete partial\norder for which many properties of standard domains can be reformulated. The\nuse of hyperreals in this model allows it to formally consider the notion of\ninfinitesimal, and thus to make a bridge between discrete and continuous time:\ntime is \"discrete\", but the duration between two instants is infinitesimal.\nFinally, we give some examples of uses of the model by describing some networks\nimplementing common constructions in analysis.\n", "versions": [{"version": "v1", "created": "Thu, 25 Aug 2011 11:34:45 GMT"}], "update_date": "2011-09-07", "authors_parsed": [["Beauxis", "Romain", "", "LIX, INRIA Saclay - Ile de France"], ["Mimram", "Samuel", "", "CEA\n  LIST"]]}, {"id": "1108.5434", "submitter": "Kristian Reale", "authors": "Onofrio Febbraro, Nicola Leone, Kristian Reale and Francesco Ricca", "title": "Unit Testing in ASPIDE", "comments": "12 pages, 4 figures, Proceedings of the 25th Workshop on Logic\n  Programming (WLP 2011)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Answer Set Programming (ASP) is a declarative logic programming formalism,\nwhich is employed nowadays in both academic and industrial real-world\napplications. Although some tools for supporting the development of ASP\nprograms have been proposed in the last few years, the crucial task of testing\nASP programs received less attention, and is an Achilles' heel of the available\nprogramming environments.\n  In this paper we present a language for specifying and running unit tests on\nASP programs. The testing language has been implemented in ASPIDE, a\ncomprehensive IDE for ASP, which supports the entire life-cycle of ASP\ndevelopment with a collection of user-friendly graphical tools for program\ncomposition, testing, debugging, profiling, solver execution configuration, and\noutput-handling.\n", "versions": [{"version": "v1", "created": "Sat, 27 Aug 2011 09:36:35 GMT"}], "update_date": "2011-08-30", "authors_parsed": [["Febbraro", "Onofrio", ""], ["Leone", "Nicola", ""], ["Reale", "Kristian", ""], ["Ricca", "Francesco", ""]]}, {"id": "1108.5609", "submitter": "Michael Hanus", "authors": "Bernd Bra{\\ss}el, Michael Hanus, Bj\\\"orn Peem\\\"oller, Fabian Reck", "title": "Implementing Equational Constraints in a Functional Language", "comments": "To appear in the Proceedings of the 25th Workshop on Logic\n  Programming (WLP 2011)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  KiCS2 is a new system to compile functional logic programs of the source\nlanguage Curry into purely functional Haskell programs. The implementation is\nbased on the idea to represent the search space as a data structure and logic\nvariables as operations that generate their values. This has the advantage that\none can apply various, and in particular, complete search strategies to compute\nsolutions. However, the generation of all values for logic variables might be\ninefficient for applications that exploit constraints on partially known\nvalues. To overcome this drawback, we propose new techniques to implement\nequational constraints in this framework. In particular, we show how\nunification modulo function evaluation and functional patterns can be added\nwithout sacrificing the efficiency of the kernel implementation.\n", "versions": [{"version": "v1", "created": "Mon, 29 Aug 2011 15:38:31 GMT"}], "update_date": "2011-08-30", "authors_parsed": [["Bra\u00dfel", "Bernd", ""], ["Hanus", "Michael", ""], ["Peem\u00f6ller", "Bj\u00f6rn", ""], ["Reck", "Fabian", ""]]}]