[{"id": "1211.0557", "submitter": "Eric Schkufza", "authors": "Eric Schkufza, Rahul Sharma, Alex Aiken", "title": "Stochastic Superoptimization", "comments": "To appear in ASPLOS 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PF cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We formulate the loop-free, binary superoptimization task as a stochastic\nsearch problem. The competing constraints of transformation correctness and\nperformance improvement are encoded as terms in a cost function, and a Markov\nChain Monte Carlo sampler is used to rapidly explore the space of all possible\nprograms to find one that is an optimization of a given target program.\nAlthough our method sacrifices com- pleteness, the scope of programs we are\nable to reason about, and the quality of the programs we produce, far exceed\nthose of existing superoptimizers. Beginning from binaries com- piled by llvm\n-O0 for 64-bit X86, our prototype implemen- tation, STOKE, is able to produce\nprograms which either match or outperform the code sequences produced by gcc\nwith full optimizations enabled, and, in some cases, expert handwritten\nassembly.\n", "versions": [{"version": "v1", "created": "Fri, 2 Nov 2012 20:23:23 GMT"}], "update_date": "2012-11-06", "authors_parsed": [["Schkufza", "Eric", ""], ["Sharma", "Rahul", ""], ["Aiken", "Alex", ""]]}, {"id": "1211.0865", "submitter": "Garrin Kimmell", "authors": "Aaron Stump (University of Iowa), Garrin Kimmell (University of Iowa),\n  Hans Zantema (TU Eindhoven), Ruba El Haj Omar (University of Iowa)", "title": "A Rewriting View of Simple Typing", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 1 (February\n  27, 2013) lmcs:936", "doi": "10.2168/LMCS-9(1:4)2013", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper shows how a recently developed view of typing as small-step\nabstract reduction, due to Kuan, MacQueen, and Findler, can be used to recast\nthe development of simple type theory from a rewriting perspective. We show how\nstandard meta-theoretic results can be proved in a completely new way, using\nthe rewriting view of simple typing. These meta-theoretic results include\nstandard type preservation and progress properties for simply typed lambda\ncalculus, as well as generalized versions where typing is taken to include both\nabstract and concrete reduction. We show how automated analysis tools developed\nin the term-rewriting community can be used to help automate the proofs for\nthis meta-theory. Finally, we show how to adapt a standard proof of\nnormalization of simply typed lambda calculus, for the rewriting approach to\ntyping.\n", "versions": [{"version": "v1", "created": "Mon, 5 Nov 2012 14:05:51 GMT"}, {"version": "v2", "created": "Tue, 26 Feb 2013 11:32:47 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Stump", "Aaron", "", "University of Iowa"], ["Kimmell", "Garrin", "", "University of Iowa"], ["Zantema", "Hans", "", "TU Eindhoven"], ["Omar", "Ruba El Haj", "", "University of Iowa"]]}, {"id": "1211.1581", "submitter": "Volker Weinberg", "authors": "Volker Weinberg", "title": "Data-parallel programming with Intel Array Building Blocks (ArBB)", "comments": "13 pages, 7 figures, PRACE Whitepaper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PF cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Intel Array Building Blocks is a high-level data-parallel programming\nenvironment designed to produce scalable and portable results on existing and\nupcoming multi- and many-core platforms.\n  We have chosen several mathematical kernels - a dense matrix-matrix\nmultiplication, a sparse matrix-vector multiplication, a 1-D complex FFT and a\nconjugate gradients solver - as synthetic benchmarks and representatives of\nscientific codes and ported them to ArBB. This whitepaper describes the ArBB\nports and presents performance and scaling measurements on the Westmere-EX\nbased system SuperMIG at LRZ in comparison with OpenMP and MKL.\n", "versions": [{"version": "v1", "created": "Wed, 7 Nov 2012 16:00:28 GMT"}], "update_date": "2012-11-08", "authors_parsed": [["Weinberg", "Volker", ""]]}, {"id": "1211.2609", "submitter": "J\\\"urgen Koslowski", "authors": "Massimo Bartoletti, Alceste Scalas, Emilio Tuosto, Roberto Zunino", "title": "Honesty by Typing", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 4 (April 27,\n  2017) lmcs:2619", "doi": "10.2168/LMCS-12(4:7)2016", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a type system for a calculus of contracting processes. Processes\ncan establish sessions by stipulating contracts, and then can interact either\nby keeping the promises made, or not. Type safety guarantees that a typeable\nprocess is honest - that is, it abides by the contracts it has stipulated in\nall possible contexts, even in presence of dishonest adversaries. Type\ninference is decidable, and it allows to safely approximate the honesty of\nprocesses using either synchronous or asynchronous communication.\n", "versions": [{"version": "v1", "created": "Mon, 12 Nov 2012 13:39:51 GMT"}, {"version": "v2", "created": "Mon, 27 May 2013 14:02:57 GMT"}, {"version": "v3", "created": "Sun, 23 Oct 2016 10:26:20 GMT"}, {"version": "v4", "created": "Fri, 23 Dec 2016 09:31:16 GMT"}, {"version": "v5", "created": "Tue, 27 Dec 2016 20:50:47 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Bartoletti", "Massimo", ""], ["Scalas", "Alceste", ""], ["Tuosto", "Emilio", ""], ["Zunino", "Roberto", ""]]}, {"id": "1211.2776", "submitter": "Gwenael Delaval", "authors": "Gwena\\\"el Delaval (INRIA Grenoble Rh\\^one-Alpes / LIG Laboratoire\n  d'Informatique de Grenoble), Alain Girault (INRIA Grenoble Rh\\^one-Alpes /\n  LIG Laboratoire d'Informatique de Grenoble), Marc Pouzet (LRI)", "title": "A Type System for the Automatic Distribution of Higher-order Synchronous\n  Dataflow Programs", "comments": null, "journal-ref": "LCTES - ACM International Conference on Languages, Compilers, and\n  Tools for Embedded Systems (2008) 101-110", "doi": "10.1145/1375657.1375672", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address the design of distributed systems with synchronous dataflow\nprogramming languages. As modular design entails handling both architectural\nand functional modularity, our first contribution is to extend an existing\nsynchronous dataflow programming language with primitives allowing the\ndescription of a distributed architecture and the localization of some\nexpressions onto some processors. We also present a distributed semantics to\nformalize the distributed execution of synchronous programs. Our second\ncontribution is to provide a type system, in order to infer the localization of\nnon-annotated values by means of type inference and to ensure, at compilation\ntime, the consistency of the distribution. Our third contribution is to provide\na type-directed projection operation to obtain automatically,from a centralized\ntyped program, the local program to be executed by each computing resource. The\ntype system as well as the automatic distribution mechanism has been fully\nimplemented in the compiler of an existing synchronous data-flow programming\nlanguage.\n", "versions": [{"version": "v1", "created": "Mon, 12 Nov 2012 20:40:59 GMT"}], "update_date": "2012-11-13", "authors_parsed": [["Delaval", "Gwena\u00ebl", "", "INRIA Grenoble Rh\u00f4ne-Alpes / LIG Laboratoire\n  d'Informatique de Grenoble"], ["Girault", "Alain", "", "INRIA Grenoble Rh\u00f4ne-Alpes /\n  LIG Laboratoire d'Informatique de Grenoble"], ["Pouzet", "Marc", "", "LRI"]]}, {"id": "1211.3476", "submitter": "EPTCS", "authors": "Gabriel Ciobanu (Romanian Academy, Institute of Computer Science)", "title": "Proceedings 6th Workshop on Membrane Computing and Biologically Inspired\n  Process Calculi", "comments": null, "journal-ref": "EPTCS 100, 2012", "doi": "10.4204/EPTCS.100", "report-no": null, "categories": "cs.PL cs.ET cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the papers presented at the 6th Membrane Computing and\nBiologically Inspired Process Calculi (MeCBIC 2012), a satellite workshop of\nthe 23rd International Conference on Concurrency Theory (CONCUR) held on 8th\nSeptember 2012 in Newcastle upon Tyne, UK.\n", "versions": [{"version": "v1", "created": "Thu, 15 Nov 2012 01:33:41 GMT"}], "update_date": "2012-11-16", "authors_parsed": [["Ciobanu", "Gabriel", "", "Romanian Academy, Institute of Computer Science"]]}, {"id": "1211.3480", "submitter": "EPTCS", "authors": "Sandra Alves (University of Porto), Ian Mackie (\\'Ecole Polytechnique)", "title": "Proceedings 2nd International Workshop on Linearity", "comments": null, "journal-ref": "EPTCS 101, 2012", "doi": "10.4204/EPTCS.101", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains a selection of the papers presented at the 2nd\nInternational Workshop on Linearity (LINEARITY'2012), which took place 1 April\n2012 in Tallinn, Estonia. The workshop was a one-day satellite event of ETAPS\n2012, the 15th European Joint Conference on Theory and Practice of Software.\n  The aim of this workshop was to bring together researchers who are currently\ndeveloping theory and applications of linear calculi, in order to foster their\ninteraction, to provide a forum for presenting new ideas and work in progress,\nand to enable newcomers to learn about current activities in this area.\n", "versions": [{"version": "v1", "created": "Thu, 15 Nov 2012 02:09:29 GMT"}], "update_date": "2012-11-16", "authors_parsed": [["Alves", "Sandra", "", "University of Porto"], ["Mackie", "Ian", "", "\u00c9cole Polytechnique"]]}, {"id": "1211.3722", "submitter": "David Van Horn", "authors": "J. Ian Johnson, Nicholas Labich, Matthew Might, David Van Horn", "title": "Optimizing Abstract Abstract Machines", "comments": "Proceedings of the International Conference on Functional Programming\n  2013 (ICFP 2013). Boston, Massachusetts. September, 2013", "journal-ref": null, "doi": "10.1145/2500365.2500604", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The technique of abstracting abstract machines (AAM) provides a systematic\napproach for deriving computable approximations of evaluators that are easily\nproved sound. This article contributes a complementary step-by-step process for\nsubsequently going from a naive analyzer derived under the AAM approach, to an\nefficient and correct implementation. The end result of the process is a two to\nthree order-of-magnitude improvement over the systematically derived analyzer,\nmaking it competitive with hand-optimized implementations that compute\nfundamentally less precise results.\n", "versions": [{"version": "v1", "created": "Thu, 15 Nov 2012 20:37:01 GMT"}, {"version": "v2", "created": "Fri, 29 Mar 2013 21:21:57 GMT"}, {"version": "v3", "created": "Thu, 18 Jul 2013 01:28:29 GMT"}, {"version": "v4", "created": "Wed, 24 Jul 2013 19:53:30 GMT"}], "update_date": "2013-07-25", "authors_parsed": [["Johnson", "J. Ian", ""], ["Labich", "Nicholas", ""], ["Might", "Matthew", ""], ["Van Horn", "David", ""]]}, {"id": "1211.4101", "submitter": "Gang Liao", "authors": "Gang Liao, Zhi-hui Qin, Long-fei Ma, Qi Sun", "title": "Optimizing Synchronization Algorithm for Auto-parallelizing Compiler", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we focus on the need for two approaches to optimize producer\nand consumer synchronization for auto-parallelizing compiler. Emphasis is\nplaced on the construction of a criterion model by which the compiler reduce\nthe number of synchronization operations needed to synchronize the dependence\nin a loop and perform optimization reduces the overhead of enforcing all\ndependence. In accordance with our study, we transform to modify and eliminate\ndependence on iteration space diagram (ISD), and carry out the problems of\nacyclic and cyclic dependence in detail. we eliminate partial dependence and\noptimize the synchronize instructions. Some didactic examples are included to\nillustrate the optimize procedure.\n", "versions": [{"version": "v1", "created": "Sat, 17 Nov 2012 09:29:17 GMT"}, {"version": "v2", "created": "Mon, 26 Nov 2012 07:15:26 GMT"}, {"version": "v3", "created": "Fri, 1 Mar 2013 03:14:34 GMT"}], "update_date": "2013-03-04", "authors_parsed": [["Liao", "Gang", ""], ["Qin", "Zhi-hui", ""], ["Ma", "Long-fei", ""], ["Sun", "Qi", ""]]}, {"id": "1211.5904", "submitter": "Paolo Bientinesi", "authors": "Diego Fabregat-Traver (1), Paolo Bientinesi (1), ((1) AICES, RWTH\n  Aachen)", "title": "Application-tailored Linear Algebra Algorithms: A search-based Approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we tackle the problem of automatically generating algorithms\nfor linear algebra operations by taking advantage of problem-specific\nknowledge. In most situations, users possess much more information about the\nproblem at hand than what current libraries and computing environments accept;\nevidence shows that if properly exploited, such information leads to\nuncommon/unexpected speedups. We introduce a knowledge-aware linear algebra\ncompiler that allows users to input matrix equations together with properties\nabout the operands and the problem itself; for instance, they can specify that\nthe equation is part of a sequence, and how successive instances are related to\none another. The compiler exploits all this information to guide the generation\nof algorithms, to limit the size of the search space, and to avoid redundant\ncomputations. We applied the compiler to equations arising as part of\nsensitivity and genome studies; the algorithms produced exhibit, respectively,\n100- and 1000-fold speedups.\n", "versions": [{"version": "v1", "created": "Mon, 26 Nov 2012 10:15:29 GMT"}], "update_date": "2012-11-27", "authors_parsed": [["Fabregat-Traver", "Diego", ""], ["Bientinesi", "Paolo", ""]]}, {"id": "1211.6190", "submitter": "EPTCS", "authors": "Hendrik Tews (TU Dresden), Marcus V\\\"olp (TU Dresden), Tjark Weber\n  (Uppsala University)", "title": "On the Use of Underspecified Data-Type Semantics for Type Safety in\n  Low-Level Code", "comments": "In Proceedings SSV 2012, arXiv:1211.5873", "journal-ref": "EPTCS 102, 2012, pp. 73-87", "doi": "10.4204/EPTCS.102.8", "report-no": null, "categories": "cs.LO cs.OS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In recent projects on operating-system verification, C and C++ data types are\noften formalized using a semantics that does not fully specify the precise byte\nencoding of objects. It is well-known that such an underspecified data-type\nsemantics can be used to detect certain kinds of type errors. In general,\nhowever, underspecified data-type semantics are unsound: they assign\nwell-defined meaning to programs that have undefined behavior according to the\nC and C++ language standards.\n  A precise characterization of the type-correctness properties that can be\nenforced with underspecified data-type semantics is still missing. In this\npaper, we identify strengths and weaknesses of underspecified data-type\nsemantics for ensuring type safety of low-level systems code. We prove\nsufficient conditions to detect certain classes of type errors and, finally,\nidentify a trade-off between the complexity of underspecified data-type\nsemantics and their type-checking capabilities.\n", "versions": [{"version": "v1", "created": "Tue, 27 Nov 2012 02:36:45 GMT"}], "update_date": "2012-11-28", "authors_parsed": [["Tews", "Hendrik", "", "TU Dresden"], ["V\u00f6lp", "Marcus", "", "TU Dresden"], ["Weber", "Tjark", "", "Uppsala University"]]}, {"id": "1211.6192", "submitter": "EPTCS", "authors": "Eva Beckschulze (Embedded Software Laboratory RWTH Aachen University,\n  Germany), Sebastian Biallas (Embedded Software Laboratory RWTH Aachen\n  University, Germany), Stefan Kowalewski (Embedded Software Laboratory RWTH\n  Aachen University, Germany)", "title": "Static Analysis of Lockless Microcontroller C Programs", "comments": "In Proceedings SSV 2012, arXiv:1211.5873", "journal-ref": "EPTCS 102, 2012, pp. 103-114", "doi": "10.4204/EPTCS.102.10", "report-no": null, "categories": "cs.PL cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Concurrently accessing shared data without locking is usually a subject to\nrace conditions resulting in inconsistent or corrupted data. However, there are\nprograms operating correctly without locking by exploiting the atomicity of\ncertain operations on a specific hardware. In this paper, we describe how to\nprecisely analyze lockless microcontroller C programs with interrupts by taking\nthe hardware architecture into account. We evaluate this technique in an\noctagon-based value range analysis using access-based localization to increase\nefficiency.\n", "versions": [{"version": "v1", "created": "Tue, 27 Nov 2012 02:37:00 GMT"}], "update_date": "2012-11-28", "authors_parsed": [["Beckschulze", "Eva", "", "Embedded Software Laboratory RWTH Aachen University,\n  Germany"], ["Biallas", "Sebastian", "", "Embedded Software Laboratory RWTH Aachen\n  University, Germany"], ["Kowalewski", "Stefan", "", "Embedded Software Laboratory RWTH\n  Aachen University, Germany"]]}, {"id": "1211.6193", "submitter": "EPTCS", "authors": "Chris Hathhorn (University of Missouri), Michela Becchi (University of\n  Missouri), William L. Harrison (University of Missouri), Adam Procter\n  (University of Missouri)", "title": "Formal Semantics of Heterogeneous CUDA-C: A Modular Approach with\n  Applications", "comments": "In Proceedings SSV 2012, arXiv:1211.5873", "journal-ref": "EPTCS 102, 2012, pp. 115-124", "doi": "10.4204/EPTCS.102.11", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We extend an off-the-shelf, executable formal semantics of C (Ellison and\nRosu's K Framework semantics) with the core features of CUDA-C. The hybrid\nCPU/GPU computation model of CUDA-C presents challenges not just for\nprogrammers, but also for practitioners of formal methods. Our formal semantics\nhelps expose and clarify these issues. We demonstrate the usefulness of our\nsemantics by generating a tool from it capable of detecting some race\nconditions and deadlocks in CUDA-C programs. We discuss limitations of our\nmodel and argue that its extensibility can easily enable a wider range of\nverification tasks.\n", "versions": [{"version": "v1", "created": "Tue, 27 Nov 2012 02:37:06 GMT"}], "update_date": "2012-11-28", "authors_parsed": [["Hathhorn", "Chris", "", "University of Missouri"], ["Becchi", "Michela", "", "University of\n  Missouri"], ["Harrison", "William L.", "", "University of Missouri"], ["Procter", "Adam", "", "University of Missouri"]]}, {"id": "1211.6197", "submitter": "EPTCS", "authors": "David Cock (NICTA and School of Computer Science and Engineering,\n  University of New South Wales)", "title": "Verifying Probabilistic Correctness in Isabelle with pGCL", "comments": "In Proceedings SSV 2012, arXiv:1211.5873", "journal-ref": "EPTCS 102, 2012, pp. 167-178", "doi": "10.4204/EPTCS.102.15", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a formalisation of pGCL in Isabelle/HOL. Using a shallow\nembedding, we demonstrate close integration with existing automation support.\nWe demonstrate the facility with which the model can be extended to incorporate\nexisting results, including those of the L4.verified project. We motivate the\napplicability of the formalism to the mechanical verification of probabilistic\nsecurity properties, including the effectiveness of side-channel\ncountermeasures in real systems.\n", "versions": [{"version": "v1", "created": "Tue, 27 Nov 2012 02:37:33 GMT"}], "update_date": "2012-11-28", "authors_parsed": [["Cock", "David", "", "NICTA and School of Computer Science and Engineering,\n  University of New South Wales"]]}, {"id": "1211.6418", "submitter": "Iztok Fister", "authors": "Iztok Fister Jr., Iztok Fister", "title": "Measuring Time in Sporting Competitions with the Domain-Specific\n  Language EasyTime", "comments": null, "journal-ref": "Elektrotehniski vestnik, 78(1-2): 36-41, 2011", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Measuring time in mass sporting competitions is unthinkable manually today\nbecause of their long duration and unreliability. Besides, automatic timing\ndevices based on the RFID technology have become cheaper. However, these\ndevices cannot operate stand-alone. To work efficiently, they need a computer\ntiming system for monitoring results. Such system should be capable of\nprocessing the incoming events, encoding and assigning results to a individual\ncompetitor, sorting results according to the achieved time and printing them.\nIn this paper, a domain-specific language named EasyTime will be defined. It\nenables controlling an agent by writing events to a database. Using the agent,\nthe number of measuring devices can be reduced. Also, EasyTime is of a\nuniversal type that can be applied to many different sporting competitions\n", "versions": [{"version": "v1", "created": "Tue, 27 Nov 2012 20:48:02 GMT"}], "update_date": "2012-11-28", "authors_parsed": [["Fister", "Iztok", "Jr."], ["Fister", "Iztok", ""]]}, {"id": "1211.6535", "submitter": "Keehang Kwon", "authors": "Keehang Kwon and Mi-Young Park", "title": "Towards Interactive Logic Programming", "comments": "8 pages. It describes two execution models for interactive logic\n  programming", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linear logic programming uses provability as the basis for computation. In\nthe operational semantics based on provability, executing the\nadditive-conjunctive goal $G_1 \\& G_2$ from a program $P$ simply terminates\nwith a success if both $G_1$ and $G_2$ are solvable from $P$. This is an\nunsatisfactory situation, as a central action of \\& -- the action of choosing\neither $G_1$ or $G_2$ by the user -- is missing in this semantics.\n  We propose to modify the operational semantics above to allow for more active\nparticipation from the user. We illustrate our idea via muProlog, an extension\nof Prolog with additive goals.\n", "versions": [{"version": "v1", "created": "Wed, 28 Nov 2012 08:02:16 GMT"}, {"version": "v2", "created": "Wed, 1 Jul 2015 04:45:39 GMT"}], "update_date": "2015-07-02", "authors_parsed": [["Kwon", "Keehang", ""], ["Park", "Mi-Young", ""]]}, {"id": "1211.6940", "submitter": "Keehang Kwon", "authors": "Keehang Kwon", "title": "Choice Disjunctive Queries in Logic Programming", "comments": "8 pages. Implementation scheme from the previous version contains an\n  error. A new, correct implementation scheme is described", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One of the long-standing research problems on logic programming is to treat\nthe cut predicate in a logical, high-level way. We argue that this problem can\nbe solved by adopting linear logic and choice-disjunctive goal formulas of the\nform $G_0 \\add G_1$ where $G_0, G_1$ are goals. These goals have the following\nintended semantics: $choose$ the true disjunct $G_i$ and execute $G_i$ where $i\n(= 0\\ {\\rm or}\\ 1)$, while $discarding$ the unchosen disjunct. Note that only\none goal can remain alive during execution. These goals thus allow us to\nspecify mutually exclusive tasks in a high-level way.\n", "versions": [{"version": "v1", "created": "Thu, 29 Nov 2012 15:04:31 GMT"}, {"version": "v2", "created": "Mon, 22 Sep 2014 03:30:04 GMT"}, {"version": "v3", "created": "Fri, 4 Sep 2015 06:27:20 GMT"}], "update_date": "2015-09-07", "authors_parsed": [["Kwon", "Keehang", ""]]}]