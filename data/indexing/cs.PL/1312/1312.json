[{"id": "1312.0018", "submitter": "Scherer Gabriel", "authors": "Gabriel Scherer (INRIA Rocquencourt), Jan Hoffmann", "title": "Tracking Data-Flow with Open Closure Types", "comments": "Logic for Programming Artificial Intelligence and Reasoning (2013)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Type systems hide data that is captured by function closures in function\ntypes. In most cases this is a beneficial design that favors simplicity and\ncompositionality. However, some applications require explicit information about\nthe data that is captured in closures. This paper introduces open closure\ntypes, that is, function types that are decorated with type contexts. They are\nused to track data-flow from the environment into the function closure. A\nsimply-typed lambda calculus is used to study the properties of the type theory\nof open closure types. A distinctive feature of this type theory is that an\nopen closure type of a function can vary in different type contexts. To present\nan application of the type theory, it is shown that a type derivation\nestablishes a simple non-interference property in the sense of information-flow\ntheory. A publicly available prototype implementation of the system can be used\nto experiment with type derivations for example programs.\n", "versions": [{"version": "v1", "created": "Fri, 29 Nov 2013 21:06:29 GMT"}], "update_date": "2013-12-03", "authors_parsed": [["Scherer", "Gabriel", "", "INRIA Rocquencourt"], ["Hoffmann", "Jan", ""]]}, {"id": "1312.0078", "submitter": "Manuel Serrano", "authors": "G\\'erard Berry (INRIA Sophia Antipolis), Manuel Serrano", "title": "Hop and HipHop : Multitier Web Orchestration", "comments": "International Conference on Distributed Computing and Internet\n  Technology (2014)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Rich applications merge classical computing, client-server concurrency,\nweb-based interfaces, and the complex time- and event-based reactive\nprogramming found in embedded systems. To handle them, we extend the Hop web\nprogramming platform by HipHop, a domain-specific language dedicated to\nevent-based process orchestration. Borrowing the synchronous reactive model of\nEsterel, HipHop is based on synchronous concurrency and preemption primitives\nthat are known to be key components for the modular design of complex reactive\nbehaviors. HipHop departs from Esterel by its ability to handle the dynamicity\nof Web applications, thanks to the reflexivity of Hop. Using a music player\nexample, we show how to modularly build a non-trivial Hop application using\nHipHop orchestration code.\n", "versions": [{"version": "v1", "created": "Sat, 30 Nov 2013 08:48:02 GMT"}], "update_date": "2013-12-03", "authors_parsed": [["Berry", "G\u00e9rard", "", "INRIA Sophia Antipolis"], ["Serrano", "Manuel", ""]]}, {"id": "1312.0138", "submitter": "Krasimir Yordzhev", "authors": "Krasimir Yordzhev", "title": "The bitwise operations related to a fast sorting algorithm", "comments": null, "journal-ref": "(IJACSA) International Journal of Advanced Computer Science and\n  Applications, Vol. 4, No. 9, 2013", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the work we discuss the benefit of using bitwise operations in\nprogramming. Some interesting examples in this respect have been shown. What is\ndescribed in detail is an algorithm for sorting an integer array with the\nsubstantial use of the bitwise operations. Besides its correctness we strictly\nprove that the described algorithm works in time O(n). In the work during the\nrealisation of each of the examined algorithms we use the apparatus of the\nobject-oriented programming with the syntax and the semantics of the\nprogramming language C++.\n", "versions": [{"version": "v1", "created": "Sat, 30 Nov 2013 18:43:31 GMT"}], "update_date": "2013-12-03", "authors_parsed": [["Yordzhev", "Krasimir", ""]]}, {"id": "1312.0342", "submitter": "EPTCS", "authors": "Pieter Van Gorp (Eindhoven University of Technology), Louis M. Rose\n  (University of York)", "title": "The Petri-Nets to Statecharts Transformation Case", "comments": "In Proceedings TTC 2013, arXiv:1311.7536", "journal-ref": "EPTCS 135, 2013, pp. 16-31", "doi": "10.4204/EPTCS.135.3", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes a case study for the sixth Transformation Tool Contest.\nThe case is based on a mapping from Petri-Nets to statecharts (i.e., from flat\nprocess models to hierarchical ones). The case description separates a simple\nmapping phase from a phase that involves the step by step destruction Petri-Net\nelements and the corresponding construction of a hierarchy of statechart\nelements. Although the focus of this case study is on the comparison of the\nruntime performance of solutions, we also include correctness tests as well as\nbonus criteria for evaluating transformation language and tool features.\n", "versions": [{"version": "v1", "created": "Mon, 2 Dec 2013 06:59:06 GMT"}], "update_date": "2013-12-03", "authors_parsed": [["Van Gorp", "Pieter", "", "Eindhoven University of Technology"], ["Rose", "Louis M.", "", "University of York"]]}, {"id": "1312.0343", "submitter": "EPTCS", "authors": "Valerio Cosentino (AtlanMod, INRIA & Ecole des Mines de Nantes,\n  France), Massimo Tisi (AtlanMod, INRIA & Ecole des Mines de Nantes, France),\n  Fabian B\\\"uttner (AtlanMod, INRIA & Ecole des Mines de Nantes, France)", "title": "Analyzing Flowgraphs with ATL", "comments": "In Proceedings TTC 2013, arXiv:1311.7536", "journal-ref": "EPTCS 135, 2013, pp. 32-36", "doi": "10.4204/EPTCS.135.4", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a solution to the Flowgraphs case study for the\nTransformation Tool Contest 2013 (TTC 2013). Starting from Java source code, we\nexecute a chain of model transformations to derive a simplified model of the\nprogram, its control flow graph and its data flow graph. Finally we develop a\nmodel transformation that validates the program flow by comparing it with a set\nof flow specifications written in a domain specific language. The proposed\nsolution has been implemented using ATL.\n", "versions": [{"version": "v1", "created": "Mon, 2 Dec 2013 06:59:17 GMT"}], "update_date": "2013-12-03", "authors_parsed": [["Cosentino", "Valerio", "", "AtlanMod, INRIA & Ecole des Mines de Nantes,\n  France"], ["Tisi", "Massimo", "", "AtlanMod, INRIA & Ecole des Mines de Nantes, France"], ["B\u00fcttner", "Fabian", "", "AtlanMod, INRIA & Ecole des Mines de Nantes, France"]]}, {"id": "1312.0344", "submitter": "EPTCS", "authors": "Georg Hinkel (Karlsruhe Institute of Technology), Thomas Goldschmidt\n  (ABB Corporate Research), Lucia Happe (Karlsruhe Institute of Technology)", "title": "An NMF solution for the Flowgraphs case at the TTC 2013", "comments": "In Proceedings TTC 2013, arXiv:1311.7536", "journal-ref": "EPTCS 135, 2013, pp. 37-42", "doi": "10.4204/EPTCS.135.5", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Software systems are getting more and more complex. Model-driven engineering\n(MDE) offers ways to handle such increased complexity by lifting development to\na higher level of abstraction. A key part in MDE are transformations that\ntransform any given model into another. These transformations are used to\ngenerate all kinds of software artifacts from models. However, there is little\nconsensus about the transformation tools. Thus, the Transformation Tool Contest\n(TTC) 2013 aims to compare different transformation engines. This is achieved\nthrough three different cases that have to be tackled. One of these cases is\nthe Flowgraphs case. A solution has to transform a Java code model into a\nsimplified version and has to derive control and data flow. This paper presents\nthe solution for this case using NMF Transformations as transformation engine.\n", "versions": [{"version": "v1", "created": "Mon, 2 Dec 2013 06:59:30 GMT"}], "update_date": "2013-12-03", "authors_parsed": [["Hinkel", "Georg", "", "Karlsruhe Institute of Technology"], ["Goldschmidt", "Thomas", "", "ABB Corporate Research"], ["Happe", "Lucia", "", "Karlsruhe Institute of Technology"]]}, {"id": "1312.0348", "submitter": "EPTCS", "authors": "Anthony Anjorin (Technische Universit\\\"at Darmstadt), Marius Lauder\n  (Technische Universit\\\"at Darmstadt)", "title": "A Solution to the Flowgraphs Case Study using Triple Graph Grammars and\n  eMoflon", "comments": "In Proceedings TTC 2013, arXiv:1311.7536", "journal-ref": "EPTCS 135, 2013, pp. 69-74", "doi": "10.4204/EPTCS.135.8", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  After 20 years of Triple Graph Grammars (TGGs) and numerous actively\nmaintained implementations, there is now a need for challenging examples and\nsuccess stories to show that TGGs can be used for real-world bidirectional\nmodel transformations. Our primary goal in recent years has been to increase\nthe expressiveness of TGGs by providing a set of pragmatic features that allow\na controlled fallback to programmed graph transformations and Java.\n  Based on the Flowgraphs case study of the Transformation Tool Contest (TTC\n2013), we present (i) attribute constraints used to express complex\nbidirectional attribute manipulation, (ii) binding expressions for specifying\narbitrary context relationships, and (iii) post-processing methods as a black\nbox extension for TGG rules. In each case, we discuss the enabled trade-off\nbetween guaranteed formal properties and expressiveness. Our solution,\nimplemented with our metamodelling and model transformation tool eMoflon\n(www.emoflon.org), is available as a virtual machine hosted on Share.\n", "versions": [{"version": "v1", "created": "Mon, 2 Dec 2013 07:00:03 GMT"}], "update_date": "2013-12-03", "authors_parsed": [["Anjorin", "Anthony", "", "Technische Universit\u00e4t Darmstadt"], ["Lauder", "Marius", "", "Technische Universit\u00e4t Darmstadt"]]}, {"id": "1312.0466", "submitter": "Serguei Mokhov", "authors": "Serguei A. Mokhov", "title": "Intensional Cyberforensics", "comments": "412 pages, 94 figures, 18 tables, 19 algorithms and listings; PhD\n  thesis; v2 corrects some typos and refs; also available on Spectrum at\n  http://spectrum.library.concordia.ca/977460/", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.DC cs.LO cs.NI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work focuses on the application of intensional logic to cyberforensic\nanalysis and its benefits and difficulties are compared with the\nfinite-state-automata approach. This work extends the use of the intensional\nprogramming paradigm to the modeling and implementation of a cyberforensics\ninvestigation process with backtracing of event reconstruction, in which\nevidence is modeled by multidimensional hierarchical contexts, and proofs or\ndisproofs of claims are undertaken in an eductive manner of evaluation. This\napproach is a practical, context-aware improvement over the finite state\nautomata (FSA) approach we have seen in previous work. As a base implementation\nlanguage model, we use in this approach a new dialect of the Lucid programming\nlanguage, called Forensic Lucid, and we focus on defining hierarchical contexts\nbased on intensional logic for the distributed evaluation of cyberforensic\nexpressions. We also augment the work with credibility factors surrounding\ndigital evidence and witness accounts, which have not been previously modeled.\nThe Forensic Lucid programming language, used for this intensional\ncyberforensic analysis, formally presented through its syntax and operational\nsemantics. In large part, the language is based on its predecessor and\ncodecessor Lucid dialects, such as GIPL, Indexical Lucid, Lucx, Objective\nLucid, and JOOIP bound by the underlying intensional programming paradigm.\n", "versions": [{"version": "v1", "created": "Mon, 2 Dec 2013 14:16:48 GMT"}, {"version": "v2", "created": "Fri, 7 Mar 2014 19:06:53 GMT"}], "update_date": "2014-03-10", "authors_parsed": [["Mokhov", "Serguei A.", ""]]}, {"id": "1312.0596", "submitter": "EPTCS", "authors": "Georg Hinkel (Karlsruhe Institute of Technology), Thomas Goldschmidt\n  (ABB Corporate Research), Lucia Happe (Karlsruhe Institute of Technology)", "title": "An NMF solution for the Petri Nets to State Charts case study at the TTC\n  2013", "comments": "In Proceedings TTC 2013, arXiv:1311.7536. arXiv admin note:\n  substantial text overlap with arXiv:1312.0344", "journal-ref": "EPTCS 135, 2013, pp. 95-100", "doi": "10.4204/EPTCS.135.12", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Software systems are getting more and more complex. Model-driven engineering\n(MDE) offers ways to handle such increased complexity by lifting development to\na higher level of abstraction. A key part in MDE are transformations that\ntransform any given model into another. These transformations are used to\ngenerate all kinds of software artifacts from models. However, there is little\nconsensus about the transformation tools. Thus, the Transformation Tool Contest\n(TTC) 2013 aims to compare different transformation engines. This is achieved\nthrough three different cases that have to be tackled. One of these cases is\nthe Petri Net to State Chart case. A solution has to transform a Petri Net to a\nState Chart and has to derive a hierarchical structure within the State Chart.\nThis paper presents the solution for this case using NMF Transformations as\ntransformation engine.\n", "versions": [{"version": "v1", "created": "Mon, 2 Dec 2013 07:00:51 GMT"}], "update_date": "2013-12-04", "authors_parsed": [["Hinkel", "Georg", "", "Karlsruhe Institute of Technology"], ["Goldschmidt", "Thomas", "", "ABB Corporate Research"], ["Happe", "Lucia", "", "Karlsruhe Institute of Technology"]]}, {"id": "1312.0658", "submitter": "Paolo Giosu\\'e Giarrusso", "authors": "Yufei Cai, Paolo G. Giarrusso, Tillmann Rendel and Klaus Ostermann", "title": "A Theory of Changes for Higher-Order Languages - Incrementalizing\n  {\\lambda}-Calculi by Static Differentiation", "comments": "11 pages; unpublished preprint, under submission", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  If the result of an expensive computation is invalidated by a small change to\nthe input, the old result should be updated incrementally instead of\nreexecuting the whole computation. We incrementalize programs through their\nderivative. A derivative maps changes in the program's input directly to\nchanges in the program's output, without reexecuting the original program. We\npresent a program transformation taking programs to their derivatives, which is\nfully static and automatic, supports first-class functions, and produces\nderivatives amenable to standard optimization.\n  We prove the program transformation correct in Agda for a family of\nsimply-typed {\\lambda}-calculi, parameterized by base types and primitives. A\nprecise interface specifies what is required to incrementalize the chosen\nprimitives.\n  We investigate performance by a case study: We implement in Scala the program\ntransformation, a plugin and improve performance of a nontrivial program by\norders of magnitude.\n", "versions": [{"version": "v1", "created": "Mon, 2 Dec 2013 23:23:36 GMT"}], "update_date": "2013-12-04", "authors_parsed": [["Cai", "Yufei", ""], ["Giarrusso", "Paolo G.", ""], ["Rendel", "Tillmann", ""], ["Ostermann", "Klaus", ""]]}, {"id": "1312.0694", "submitter": "Jeremy Siek", "authors": "Jeremy G. Siek and Michael M. Vitousek", "title": "Monotonic References for Gradual Typing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe an alternative approach to handling mutable references (aka.\npointers) within a gradually typed language that has different efficiency\ncharacteristics than the prior approach of Herman et al. [2010]. In particular,\nwe reduce the costs of reading and writing through references in statically\ntyped regions of code. We reduce the costs to be the same as they would in a\nstatically typed language, that is, simply the cost of a load or store\ninstruction (for primitive data types). This reduction in cost is especially\nimportant for programmers who would like to use gradual typing to facilitate\ntransitioning from a dynamically-typed prototype of an algorithm to a\nstatically-typed, high-performance implementation. The programmers we have in\nmind are scientists and engineers who currently prototype in Matlab and then\nmanually translate their algorithms into Fortran. We present the static and\ndynamic semantics for mutable references and a mechanized proof of type safety\nusing the Isabelle proof assistant.\n", "versions": [{"version": "v1", "created": "Tue, 3 Dec 2013 04:24:44 GMT"}, {"version": "v2", "created": "Sat, 12 Jul 2014 17:16:12 GMT"}], "update_date": "2014-07-15", "authors_parsed": [["Siek", "Jeremy G.", ""], ["Vitousek", "Michael M.", ""]]}, {"id": "1312.1399", "submitter": "Matija Pretnar", "authors": "Gordon D Plotkin (Laboratory for Foundations of Computer Science,\n  School of Informatics, Universit), Matija Pretnar (Faculty for mathematics\n  and physics, University of Ljubljana)", "title": "Handling Algebraic Effects", "comments": "36 pages", "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 4 (December\n  17, 2013) lmcs:705", "doi": "10.2168/LMCS-9(4:23)2013", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Algebraic effects are computational effects that can be represented by an\nequational theory whose operations produce the effects at hand. The free model\nof this theory induces the expected computational monad for the corresponding\neffect. Algebraic effects include exceptions, state, nondeterminism,\ninteractive input/output, and time, and their combinations. Exception handling,\nhowever, has so far received no algebraic treatment. We present such a\ntreatment, in which each handler yields a model of the theory for exceptions,\nand each handling construct yields the homomorphism induced by the universal\nproperty of the free model. We further generalise exception handlers to\narbitrary algebraic effects. The resulting programming construct includes many\npreviously unrelated examples from both theory and practice, including\nrelabelling and restriction in Milner's CCS, timeout, rollback, and stream\nredirection.\n", "versions": [{"version": "v1", "created": "Thu, 5 Dec 2013 00:52:00 GMT"}, {"version": "v2", "created": "Mon, 16 Dec 2013 20:40:07 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Plotkin", "Gordon D", "", "Laboratory for Foundations of Computer Science,\n  School of Informatics, Universit"], ["Pretnar", "Matija", "", "Faculty for mathematics\n  and physics, University of Ljubljana"]]}, {"id": "1312.1431", "submitter": "Miles Lubin", "authors": "Miles Lubin and Iain Dunning", "title": "Computing in Operations Research using Julia", "comments": "Source code included in supplement", "journal-ref": null, "doi": "10.1287/ijoc.2014.0623", "report-no": null, "categories": "math.OC cs.NA cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The state of numerical computing is currently characterized by a divide\nbetween highly efficient yet typically cumbersome low-level languages such as\nC, C++, and Fortran and highly expressive yet typically slow high-level\nlanguages such as Python and MATLAB. This paper explores how Julia, a modern\nprogramming language for numerical computing which claims to bridge this divide\nby incorporating recent advances in language and compiler design (such as\njust-in-time compilation), can be used for implementing software and algorithms\nfundamental to the field of operations research, with a focus on mathematical\noptimization. In particular, we demonstrate algebraic modeling for linear and\nnonlinear optimization and a partial implementation of a practical simplex\ncode. Extensive cross-language benchmarks suggest that Julia is capable of\nobtaining state-of-the-art performance.\n", "versions": [{"version": "v1", "created": "Thu, 5 Dec 2013 04:29:20 GMT"}], "update_date": "2015-03-20", "authors_parsed": [["Lubin", "Miles", ""], ["Dunning", "Iain", ""]]}, {"id": "1312.1529", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Instruction sequences expressing multiplication algorithms", "comments": "14 pages, the preliminaries of this paper and arXiv:1308.0219 are the\n  same; 16 pages, results sharpened and presentation improved; 22 pages,\n  combined with arXiv:1312.1812; 22 pages, typos corrected and explanation\n  added", "journal-ref": "Scientific Annals of Computer Science 28(1):39--66, 2018", "doi": "10.7561/SACS.2018.1.39", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For each function on bit strings, its restriction to bit strings of any given\nlength can be computed by a finite instruction sequence that contains only\ninstructions to set and get the content of Boolean registers, forward jump\ninstructions, and a termination instruction. We describe instruction sequences\nof this kind that compute the function on bit strings that models\nmultiplication on natural numbers less than $2^N$ with respect to their binary\nrepresentation by bit strings of length $N$, for a fixed but arbitrary $N > 0$,\naccording to the long multiplication algorithm and the Karatsuba multiplication\nalgorithm. We find among other things that the instruction sequence expressing\nthe former algorithm is longer than the one expressing the latter algorithm\nonly if the length of the bit strings involved is greater than $2^8$. We also\ngo into the use of an instruction sequence with backward jump instructions for\nexpressing the long multiplication algorithm. This leads to an instruction\nsequence that it is shorter than the other two if the length of the bit strings\ninvolved is greater than $2$.\n", "versions": [{"version": "v1", "created": "Thu, 5 Dec 2013 12:53:56 GMT"}, {"version": "v2", "created": "Mon, 6 Nov 2017 14:14:49 GMT"}, {"version": "v3", "created": "Wed, 29 Nov 2017 14:13:04 GMT"}, {"version": "v4", "created": "Sun, 1 Jul 2018 10:08:12 GMT"}], "update_date": "2018-09-28", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "1312.1812", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Long multiplication by instruction sequences with backward jump\n  instructions", "comments": "17 pages, the preliminaries are about the same as the preliminaries\n  in arXiv:1308.0219 [cs.PL] and arXiv:1312.1529 [cs.PL]; minor errors\n  corrected, references added; section on indirect addressing added", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For each function on bit strings, its restriction to bit strings of any given\nlength can be computed by a finite instruction sequence that contains only\ninstructions to set and get the content of Boolean registers, forward jump\ninstructions, and a termination instruction. Backward jump instructions are not\nnecessary for this, but instruction sequences can be significantly shorter with\nthem. We take the function on bit strings that models the multiplication of\nnatural numbers on their representation in the binary number system to\ndemonstrate this by means of a concrete example. The example is reason to\ndiscuss points concerning the halting problem and the concept of an algorithm.\n", "versions": [{"version": "v1", "created": "Fri, 6 Dec 2013 09:41:06 GMT"}, {"version": "v2", "created": "Wed, 18 Dec 2013 12:47:24 GMT"}, {"version": "v3", "created": "Sun, 6 Apr 2014 14:56:30 GMT"}], "update_date": "2014-04-08", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "1312.2216", "submitter": "EPTCS", "authors": "Philip K.F. H\\\"olzenspies", "title": "Proceedings Second Workshop on Trends in Functional Programming In\n  Education", "comments": null, "journal-ref": "EPTCS 136, 2013", "doi": "10.4204/EPTCS.136", "report-no": null, "categories": "cs.CY cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Second International Workshop on Trends in Functional Programming in\nEducation, TFPIE 2013, was held on May 13, 2013 at Brigham Young University in\nProvo, Utah, USA. The goal of TFPIE is to gather researchers, professors,\nteachers, and all professionals interested in functional programming in\neducation. Submissions were vetted by the TFPIE 2013 program committee using\nprevailing academic standards. The 2 articles in this volume were selected for\npublication as the result of this process. Tobin-Hochstadt and Van Horn report\non their solution to the difficult transition between the first semester course\nin functional programming (using languages, programming environment, etc.\nintended for teaching) to the second semester course in object-oriented\nprogramming (with a production-oriented language, environment, etc.). Finding\nthat this confusing circumstance made the key concepts hard to grasp for\nstudents, the authors present and evaluate a new introduction to the second\nsemester course, based on the environment and languages the students used\nbefore, that focusses on key object-oriented concepts. Caldwell lays out an\neducation narrative that focusses on reasoning about programs, using structural\ninduction principles. He argues that more such formal reasoning should get more\nemphasis in programming education and demonstrates the feasibility thereof by\nreporting on his experiences using this narrative in the functional programming\ncourse at the University of Wyoming.\n", "versions": [{"version": "v1", "created": "Sun, 8 Dec 2013 14:08:57 GMT"}], "update_date": "2013-12-10", "authors_parsed": [["H\u00f6lzenspies", "Philip K. F.", ""]]}, {"id": "1312.2218", "submitter": "EPTCS", "authors": "Nobuko Yoshida (Imperial College London, UK), Wim Vanderbauwhede\n  (University of Glasgow, UK)", "title": "Proceedings 5th Workshop on Programming Language Approaches to\n  Concurrency and Communication-cEntric Software", "comments": null, "journal-ref": "EPTCS 137, 2013", "doi": "10.4204/EPTCS.137", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  PLACES 2013 (full title: Programming Language Approaches to Concurrency- and\nCommunication-cEntric Software) was the sixth edition of the PLACES workshop\nseries. After the first PLACES, which was affiliated to DisCoTec in 2008, the\nworkshop has been part of ETAPS every year since 2009 and is now an established\npart of the ETAPS satellite events. This year, PLACES was the best attended\nworkshop at ETAPS 2013.\n  The workshop series was started in order to promote the application of novel\nprogramming language ideas to the increasingly important problem of developing\nsoftware for systems in which concurrency and communication are intrinsic\naspects. This includes software for multi- and many-core systems, accelerators\nand large-scale distributed and/or service-oriented systems. The scope of\nPLACES includes new programming language features, whole new programming\nlanguage designs, new type systems, new semantic approaches, new program\nanalysis techniques, and new implementation mechanisms.\n", "versions": [{"version": "v1", "created": "Sun, 8 Dec 2013 14:19:11 GMT"}], "update_date": "2013-12-10", "authors_parsed": [["Yoshida", "Nobuko", "", "Imperial College London, UK"], ["Vanderbauwhede", "Wim", "", "University of Glasgow, UK"]]}, {"id": "1312.2334", "submitter": "Matija Pretnar", "authors": "Matija Pretnar (University of Ljubljana)", "title": "Inferring Algebraic Effects", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 3 (September\n  12, 2014) lmcs:1004", "doi": "10.2168/LMCS-10(3:21)2014", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a complete polymorphic effect inference algorithm for an ML-style\nlanguage with handlers of not only exceptions, but of any other algebraic\neffect such as input & output, mutable references and many others. Our main aim\nis to offer the programmer a useful insight into the effectful behaviour of\nprograms. Handlers help here by cutting down possible effects and the resulting\nlengthy output that often plagues precise effect systems. Additionally, we\npresent a set of methods that further simplify the displayed types, some even\nby deliberately hiding inferred information from the programmer.\n", "versions": [{"version": "v1", "created": "Mon, 9 Dec 2013 08:13:19 GMT"}, {"version": "v2", "created": "Mon, 8 Sep 2014 18:38:58 GMT"}, {"version": "v3", "created": "Thu, 11 Sep 2014 19:51:32 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Pretnar", "Matija", "", "University of Ljubljana"]]}, {"id": "1312.2696", "submitter": "EPTCS", "authors": "James Caldwell (University of Wyoming)", "title": "Structural Induction Principles for Functional Programmers", "comments": "In Proceedings TFPIE 2013, arXiv:1312.2216", "journal-ref": "EPTCS 136, 2013, pp. 16-26", "doi": "10.4204/EPTCS.136.2", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  User defined recursive types are a fundamental feature of modern functional\nprogramming languages like Haskell, Clean, and the ML family of languages.\nProperties of programs defined by recursion on the structure of recursive types\nare generally proved by structural induction on the type. It is well known in\nthe theorem proving community how to generate structural induction principles\nfrom data type declarations. These methods deserve to be better know in the\nfunctional programming community. Existing functional programming textbooks\ngloss over this material. And yet, if functional programmers do not know how to\nwrite down the structural induction principle for a new type - how are they\nsupposed to reason about it? In this paper we describe an algorithm to generate\nstructural induction principles from data type declarations. We also discuss\nhow these methods are taught in the functional programming course at the\nUniversity of Wyoming. A Haskell implementation of the algorithm is included in\nan appendix.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:00:53 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Caldwell", "James", "", "University of Wyoming"]]}, {"id": "1312.2698", "submitter": "EPTCS", "authors": "Luca Padovani (Dipartimento di Informatica, Universit\\`a di Torino)", "title": "From Lock Freedom to Progress Using Session Types", "comments": "In Proceedings PLACES 2013, arXiv:1312.2218", "journal-ref": "EPTCS 137, 2013, pp. 3-19", "doi": "10.4204/EPTCS.137.2", "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Inspired by Kobayashi's type system for lock freedom, we define a behavioral\ntype system for ensuring progress in a language of binary sessions. The key\nidea is to annotate actions in session types with priorities representing the\nurgency with which such actions must be performed and to verify that processes\nperform such actions with the required priority. Compared to related systems\nfor session-based languages, the presented type system is relatively simpler\nand establishes progress for a wider range of processes.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:03:18 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Padovani", "Luca", "", "Dipartimento di Informatica, Universit\u00e0 di Torino"]]}, {"id": "1312.2699", "submitter": "EPTCS", "authors": "Cinzia Di Giusto, Jorge A. P\\'erez", "title": "Session Types with Runtime Adaptation: Overview and Examples", "comments": "In Proceedings PLACES 2013, arXiv:1312.2218", "journal-ref": "EPTCS 137, 2013, pp. 21-32", "doi": "10.4204/EPTCS.137.3", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In recent work, we have developed a session types discipline for a calculus\nthat features the usual constructs for session establishment and communication,\nbut also two novel constructs that enable communicating processes to be\nstopped, duplicated, or discarded at runtime. The aim is to understand whether\nknown techniques for the static analysis of structured communications scale up\nto the challenging context of context-aware, adaptable distributed systems, in\nwhich disciplined interaction and runtime adaptation are intertwined concerns.\nIn this short note, we summarize the main features of our session-typed\nframework with runtime adaptation, and recall its basic correctness properties.\nWe illustrate our framework by means of examples. In particular, we present a\nsession representation of supervision trees, a mechanism for enforcing\nfault-tolerant applications in the Erlang language.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:03:27 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Di Giusto", "Cinzia", ""], ["P\u00e9rez", "Jorge A.", ""]]}, {"id": "1312.2700", "submitter": "EPTCS", "authors": "Yoichi Hirai (National Institute of Advanced Industrial Science and\n  Technology)", "title": "Session Types in Abelian Logic", "comments": "In Proceedings PLACES 2013, arXiv:1312.2218", "journal-ref": "EPTCS 137, 2013, pp. 33-52", "doi": "10.4204/EPTCS.137.4", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There was a PhD student who says \"I found a pair of wooden shoes. I put a\ncoin in the left and a key in the right. Next morning, I found those objects in\nthe opposite shoes.\" We do not claim existence of such shoes, but propose a\nsimilar programming abstraction in the context of typed lambda calculi. The\nresult, which we call the Amida calculus, extends Abramsky's linear lambda\ncalculus LF and characterizes Abelian logic.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:03:46 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Hirai", "Yoichi", "", "National Institute of Advanced Industrial Science and\n  Technology"]]}, {"id": "1312.2702", "submitter": "EPTCS", "authors": "Tarmo Uustalu", "title": "Coinductive Big-Step Semantics for Concurrency", "comments": "In Proceedings PLACES 2013, arXiv:1312.2218", "journal-ref": "EPTCS 137, 2013, pp. 63-78", "doi": "10.4204/EPTCS.137.6", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a paper presented at SOS 2010, we developed a framework for big-step\nsemantics for interactive input-output in combination with divergence, based on\ncoinductive and mixed inductive-coinductive notions of resumptions, evaluation\nand termination-sensitive weak bisimilarity. In contrast to standard\ninductively defined big-step semantics, this framework handles divergence\nproperly; in particular, runs that produce some observable effects and then\ndiverge, are not \"lost\". Here we scale this approach for shared-variable\nconcurrency on a simple example language. We develop the metatheory of our\nsemantics in a constructive logic.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:03:57 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Uustalu", "Tarmo", ""]]}, {"id": "1312.2703", "submitter": "EPTCS", "authors": "Ashkan Tousimojarad, Wim Vanderbauwhede", "title": "The Glasgow Parallel Reduction Machine: Programming Shared-memory\n  Many-core Systems using Parallel Task Composition", "comments": "In Proceedings PLACES 2013, arXiv:1312.2218", "journal-ref": "EPTCS 137, 2013, pp. 79-94", "doi": "10.4204/EPTCS.137.7", "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present the Glasgow Parallel Reduction Machine (GPRM), a novel, flexible\nframework for parallel task-composition based many-core programming. We allow\nthe programmer to structure programs into task code, written as C++ classes,\nand communication code, written in a restricted subset of C++ with functional\nsemantics and parallel evaluation. In this paper we discuss the GPRM, the\nvirtual machine framework that enables the parallel task composition approach.\nWe focus the discussion on GPIR, the functional language used as the\nintermediate representation of the bytecode running on the GPRM. Using examples\nin this language we show the flexibility and power of our task composition\nframework. We demonstrate the potential using an implementation of a merge sort\nalgorithm on a 64-core Tilera processor, as well as on a conventional Intel\nquad-core processor and an AMD 48-core processor system. We also compare our\nframework with OpenMP tasks in a parallel pointer chasing algorithm running on\nthe Tilera processor. Our results show that the GPRM programs outperform the\ncorresponding OpenMP codes on all test platforms, and can greatly facilitate\nwriting of parallel programs, in particular non-data parallel algorithms such\nas reductions.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:04:07 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Tousimojarad", "Ashkan", ""], ["Vanderbauwhede", "Wim", ""]]}, {"id": "1312.2704", "submitter": "EPTCS", "authors": "Rumyana Neykova (Imperial College)", "title": "Session Types Go Dynamic or How to Verify Your Python Conversations", "comments": "In Proceedings PLACES 2013, arXiv:1312.2218", "journal-ref": "EPTCS 137, 2013, pp. 95-102", "doi": "10.4204/EPTCS.137.8", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents the first implementation of session types in a\ndynamically-typed language - Python. Communication safety of the whole system\nis guaranteed at runtime by monitors that check the execution traces comply\nwith an associated protocol. Protocols are written in Scribble, a choreography\ndescription language based on multiparty session types, with addition of logic\nformulas for more precise behaviour properties. The presented framework\novercomes the limitations of previous works on the session types where all\nendpoints should be statically typed so that they do not permit\ninteroperability with untyped participants. The advantages, expressiveness and\nperformance of dynamic protocol checking are demonstrated through use case and\nbenchmarks.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:04:18 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Neykova", "Rumyana", "", "Imperial College"]]}, {"id": "1312.2705", "submitter": "EPTCS", "authors": "Eduardo R. B. Marques (LASIGE/FCUL, Universidade of Lisbon), Francisco\n  Martins (LASIGE/FCUL, Universidade of Lisbon), Vasco T. Vasconcelos\n  (LASIGE/FCUL, Universidade of Lisbon), Nicholas Ng (Imperial College London),\n  Nuno Martins (LASIGE/FCUL, Universidade of Lisbon)", "title": "Towards deductive verification of MPI programs against session types", "comments": "In Proceedings PLACES 2013, arXiv:1312.2218", "journal-ref": "EPTCS 137, 2013, pp. 103-113", "doi": "10.4204/EPTCS.137.9", "report-no": null, "categories": "cs.DC cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Message Passing Interface (MPI) is the de facto standard message-passing\ninfrastructure for developing parallel applications. Two decades after the\nfirst version of the library specification, MPI-based applications are nowadays\nroutinely deployed on super and cluster computers. These applications, written\nin C or Fortran, exhibit intricate message passing behaviours, making it hard\nto statically verify important properties such as the absence of deadlocks. Our\nwork builds on session types, a theory for describing protocols that provides\nfor correct-by-construction guarantees in this regard. We annotate MPI\nprimitives and C code with session type contracts, written in the language of a\nsoftware verifier for C. Annotated code is then checked for correctness with\nthe software verifier. We present preliminary results and discuss the\nchallenges that lie ahead for verifying realistic MPI program compliance\nagainst session types.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:04:28 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Marques", "Eduardo R. B.", "", "LASIGE/FCUL, Universidade of Lisbon"], ["Martins", "Francisco", "", "LASIGE/FCUL, Universidade of Lisbon"], ["Vasconcelos", "Vasco T.", "", "LASIGE/FCUL, Universidade of Lisbon"], ["Ng", "Nicholas", "", "Imperial College London"], ["Martins", "Nuno", "", "LASIGE/FCUL, Universidade of Lisbon"]]}, {"id": "1312.2706", "submitter": "EPTCS", "authors": "Romain Demeyer, Wim Vanhoof", "title": "Static Application-Level Race Detection in STM Haskell using Contracts", "comments": "In Proceedings PLACES 2013, arXiv:1312.2218. rde@info.fundp.ac.be;\n  wim.vanhoof@unamur.be", "journal-ref": "EPTCS 137, 2013, pp. 115-134", "doi": "10.4204/EPTCS.137.10", "report-no": null, "categories": "cs.LO cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Writing concurrent programs is a hard task, even when using high-level\nsynchronization primitives such as transactional memories together with a\nfunctional language with well-controlled side-effects such as Haskell, because\nthe interferences generated by the processes to each other can occur at\ndifferent levels and in a very subtle way. The problem occurs when a thread\nleaves or exposes the shared data in an inconsistent state with respect to the\napplication logic or the real meaning of the data. In this paper, we propose to\nassociate contracts to transactions and we define a program transformation that\nmakes it possible to extend static contract checking in the context of STM\nHaskell. As a result, we are able to check statically that each transaction of\na STM Haskell program handles the shared data in a such way that a given\nconsistency property, expressed in the form of a user-defined boolean function,\nis preserved. This ensures that bad interference will not occur during the\nexecution of the concurrent program.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:04:37 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Demeyer", "Romain", ""], ["Vanhoof", "Wim", ""]]}, {"id": "1312.2707", "submitter": "EPTCS", "authors": "Simon Dobson (University of St Andrews), Alan Dearle (University of St\n  Andrews), Barry Porter (University of St Andrews)", "title": "Minimising virtual machine support for concurrency", "comments": "In Proceedings PLACES 2013, arXiv:1312.2218", "journal-ref": "EPTCS 137, 2013, pp. 135-141", "doi": "10.4204/EPTCS.137.11", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Co-operative and pre-emptive scheduling are usually considered to be\ncomplementary models of threading. In the case of virtual machines, we show\nthat they can be unified using a single concept, the bounded execution of a\nthread of control, essentially providing a first-class representation of a\ncomputation as it is reduced. Furthermore this technique can be used to surface\nthe thread scheduler of a language into the language itself, allowing programs\nto provide their own schedulers without any additional support in the virtual\nmachine, and allowing the same virtual machine to support different thread\nmodels simultaneously and without re-compilation.\n", "versions": [{"version": "v1", "created": "Tue, 10 Dec 2013 08:04:46 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Dobson", "Simon", "", "University of St Andrews"], ["Dearle", "Alan", "", "University of St\n  Andrews"], ["Porter", "Barry", "", "University of St Andrews"]]}, {"id": "1312.3184", "submitter": "Matthias Keil", "authors": "Matthias Keil, Peter Thiemann", "title": "Efficient Dynamic Access Analysis Using JavaScript Proxies", "comments": "Technical Report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  JSConTest introduced the notions of effect monitoring and dynamic effect\ninference for JavaScript. It enables the description of effects with path\nspecifications resembling regular expressions. It is implemented by an offline\nsource code transformation.\n  To overcome the limitations of the JSConTest implementation, we redesigned\nand reimplemented effect monitoring by taking advantange of JavaScript proxies.\nOur new design avoids all drawbacks of the prior implementation. It guarantees\nfull interposition; it is not restricted to a subset of JavaScript; it is\nself-maintaining; and its scalability to large programs is significantly better\nthan with JSConTest.\n  The improved scalability has two sources. First, the reimplementation is\nsignificantly faster than the original, transformation-based implementation.\nSecond, the reimplementation relies on the fly-weight pattern and on trace\nreduction to conserve memory. Only the combination of these techniques enables\nmonitoring and inference for large programs.\n", "versions": [{"version": "v1", "created": "Wed, 11 Dec 2013 14:24:53 GMT"}], "update_date": "2013-12-12", "authors_parsed": [["Keil", "Matthias", ""], ["Thiemann", "Peter", ""]]}, {"id": "1312.3613", "submitter": "Jean-Baptiste  Tristan", "authors": "Jean-Baptiste Tristan, Daniel Huang, Joseph Tassarotti, Adam Pocock,\n  Stephen J. Green, Guy L. Steele Jr", "title": "Augur: a Modeling Language for Data-Parallel Probabilistic Inference", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "stat.ML cs.AI cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is time-consuming and error-prone to implement inference procedures for\neach new probabilistic model. Probabilistic programming addresses this problem\nby allowing a user to specify the model and having a compiler automatically\ngenerate an inference procedure for it. For this approach to be practical, it\nis important to generate inference code that has reasonable performance. In\nthis paper, we present a probabilistic programming language and compiler for\nBayesian networks designed to make effective use of data-parallel architectures\nsuch as GPUs. Our language is fully integrated within the Scala programming\nlanguage and benefits from tools such as IDE support, type-checking, and code\ncompletion. We show that the compiler can generate data-parallel inference code\nscalable to thousands of GPU cores by making use of the conditional\nindependence relationships in the Bayesian network.\n", "versions": [{"version": "v1", "created": "Thu, 12 Dec 2013 20:23:20 GMT"}, {"version": "v2", "created": "Tue, 10 Jun 2014 19:53:09 GMT"}], "update_date": "2014-06-11", "authors_parsed": [["Tristan", "Jean-Baptiste", ""], ["Huang", "Daniel", ""], ["Tassarotti", "Joseph", ""], ["Pocock", "Adam", ""], ["Green", "Stephen J.", ""], ["Steele", "Guy L.", "Jr"]]}, {"id": "1312.3739", "submitter": "Vijay Saraswat", "authors": "Silvia Crafa and David Cunningham and Vijay Saraswat and Avraham\n  Shinnar and Olivier Tardieu", "title": "Semantics of (Resilient) X10", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  We present a formal small-step structural operational semantics for a large\nfragment of X10, unifying past work. The fragment covers multiple places,\nmutable objects on the heap, sequencing, \\code{try/catch}, \\code{async},\n\\code{finish}, and \\code{at} constructs. This model accurately captures the\nbehavior of a large class of concurrent, multi-place X10 programs. Further, we\nintroduce a formal model of resilience in X10. During execution of an X10\nprogram, a place may fail for many reasons. Resilient X10 permits the program\nto continue executing, losing the data at the failed place, and most of the\ncontrol state, and repairing the global control state in such a way that key\nsemantic principles hold, the Invariant Happens Before Principle, and the\nFailure Masking Principle. These principles permit an X10 programmer to write\nclean code that continues to work in the presence of place failure. The given\nsemantics have additionally been mechanized in Coq.\n", "versions": [{"version": "v1", "created": "Fri, 13 Dec 2013 09:22:30 GMT"}], "update_date": "2013-12-16", "authors_parsed": [["Crafa", "Silvia", ""], ["Cunningham", "David", ""], ["Saraswat", "Vijay", ""], ["Shinnar", "Avraham", ""], ["Tardieu", "Olivier", ""]]}, {"id": "1312.3891", "submitter": "Michael Stewart", "authors": "Michael Stewart", "title": "Algorithmic Diversity for Software Security", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Software diversity protects against a modern-day exploits such as code-reuse\nattacks. When an attacker designs a code-reuse attack on an example executable,\nit relies on replicating the target environment. With software diversity, the\nattacker cannot reliably replicate their target. This is a security benefit\nwhich can be applied to massive-scale software distribution. When applied to\nlarge-scale communities, an invested attacker may perform analysis of samples\nto improve the chances of a successful attack (M. Franz).\n  We present a general NOP-insertion algorithm which can be expanded and\ncustomized for security, performance, or other costs. We demonstrate an\nimprovement in security so that a code-reuse attack based on any one variant\nhas minimal chances of success on another and analyse the costs of this method.\nAlternately, the variants may be customized to meet performance or memory\noverhead constraints. Deterministic diversification allows for the flexibility\nto balance these needs in a way that doesn't exist in a random online method.\n", "versions": [{"version": "v1", "created": "Fri, 13 Dec 2013 17:56:52 GMT"}], "update_date": "2013-12-16", "authors_parsed": [["Stewart", "Michael", ""]]}, {"id": "1312.4328", "submitter": "Angelika Kimmig", "authors": "Luc De Raedt and Angelika Kimmig", "title": "Probabilistic Programming Concepts", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A multitude of different probabilistic programming languages exists today,\nall extending a traditional programming language with primitives to support\nmodeling of complex, structured probability distributions. Each of these\nlanguages employs its own probabilistic primitives, and comes with a particular\nsyntax, semantics and inference procedure. This makes it hard to understand the\nunderlying programming concepts and appreciate the differences between the\ndifferent languages. To obtain a better understanding of probabilistic\nprogramming, we identify a number of core programming concepts underlying the\nprimitives used by various probabilistic languages, discuss the execution\nmechanisms that they require and use these to position state-of-the-art\nprobabilistic languages and their implementation. While doing so, we focus on\nprobabilistic extensions of logic programming languages such as Prolog, which\nhave been developed since more than 20 years.\n", "versions": [{"version": "v1", "created": "Mon, 16 Dec 2013 12:04:39 GMT"}], "update_date": "2013-12-17", "authors_parsed": [["De Raedt", "Luc", ""], ["Kimmig", "Angelika", ""]]}, {"id": "1312.4454", "submitter": "Jonathan Heras", "authors": "Ekaterina Komendantskaya, Martin Schmidt, J\\'onathan Heras", "title": "Exploiting Parallelism in Coalgebraic Logic Programming", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a parallel implementation of Coalgebraic Logic Programming (CoALP)\nin the programming language Go. CoALP was initially introduced to reflect\ncoalgebraic semantics of logic programming, with coalgebraic derivation\nalgorithm featuring both corecursion and parallelism. Here, we discuss how the\ncoalgebraic semantics influenced our parallel implementation of logic\nprogramming.\n", "versions": [{"version": "v1", "created": "Mon, 16 Dec 2013 18:39:55 GMT"}, {"version": "v2", "created": "Thu, 19 Dec 2013 07:39:12 GMT"}], "update_date": "2013-12-20", "authors_parsed": [["Komendantskaya", "Ekaterina", ""], ["Schmidt", "Martin", ""], ["Heras", "J\u00f3nathan", ""]]}, {"id": "1312.4917", "submitter": "Pierre Lescanne", "authors": "Pierre Lescanne (LIP)", "title": "An exercise on streams: convergence acceleration", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NA cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents convergence acceleration, a method for computing\nefficiently the limit of numerical sequences as a typical application of\nstreams and higher-order functions.\n", "versions": [{"version": "v1", "created": "Tue, 17 Dec 2013 19:53:28 GMT"}, {"version": "v2", "created": "Mon, 3 Mar 2014 19:43:27 GMT"}], "update_date": "2014-03-04", "authors_parsed": [["Lescanne", "Pierre", "", "LIP"]]}, {"id": "1312.5429", "submitter": "Matthias Keil", "authors": "Matthias Keil, Peter Thiemann", "title": "On the Proxy Identity Crisis", "comments": "Position Paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A proxy, in general, is an object mediating access to an arbitrary target\nobject. The proxy is then intended to be used in place of the target object.\nIdeally, a proxy is not distinguishable from other objects. Running a program\nwith a proxy leads to the same outcome as running the program with the target\nobject. Even though the approach provides a lot of power to the user, proxies\ncome with a limitation. Because a proxy, wrapping a target object, is a new\nobject and different from its target, the interposition changes the behaviour\nof some core components. For distinct proxies the double == and triple ===\nequal operator returns false, even if the target object is the same. More\nprecisely, the expected result depends on use case. To overcome this limitation\nwe will discuss alternatives.\n", "versions": [{"version": "v1", "created": "Thu, 19 Dec 2013 07:56:11 GMT"}], "update_date": "2013-12-20", "authors_parsed": [["Keil", "Matthias", ""], ["Thiemann", "Peter", ""]]}, {"id": "1312.6568", "submitter": "Ekaterina Komendantskaya Dr", "authors": "Ekaterina Komendantskaya, John Power and Martin Schmidt", "title": "Coalgebraic Logic Programming: from Semantics to Implementation", "comments": "Accepted for publication in Journal of Logic and Computation, 2014", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Coinductive definitions, such as that of an infinite stream, may often be\ndescribed by elegant logic programs, but ones for which SLD-refutation is of no\nvalue as SLD-derivations fall into infinite loops. Such definitions give rise\nto questions of lazy corecursive derivations and parallelism, as execution of\nsuch logic programs can have both recursive and corecursive features at once.\nObservational and coalgebraic semantics have been used to study them\nabstractly. The programming developments have often occurred separately and\nhave usually been implementation-led. Here, we give a coherent semantics-led\naccount of the issues, starting with abstract category theoretic semantics,\ndeveloping coalgebra to characterise naturally arising trees, and proceeding\ntowards implementation of a new dialect, CoALP, of logic programming,\ncharacterised by guarded lazy corecursion and parallelism.\n", "versions": [{"version": "v1", "created": "Mon, 23 Dec 2013 15:19:27 GMT"}], "update_date": "2013-12-24", "authors_parsed": [["Komendantskaya", "Ekaterina", ""], ["Power", "John", ""], ["Schmidt", "Martin", ""]]}, {"id": "1312.6624", "submitter": "Tomer Kotek", "authors": "Diego Calvanese, Tomer Kotek, Mantas \\v{S}imkus, Helmut Veith, Florian\n  Zuleger", "title": "Shape and Content: Incorporating Domain Knowledge into Shape Analysis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The verification community has studied dynamic data structures primarily in a\nbottom-up way by analyzing pointers and the shapes induced by them. Recent work\nin fields such as separation logic has made significant progress in extracting\nshapes from program source code. Many real world programs however manipulate\ncomplex data whose structure and content is most naturally described by\nformalisms from object oriented programming and databases. In this paper, we\nlook at the verification of programs with dynamic data structures from the\nperspective of content representation. Our approach is based on description\nlogic, a widely used knowledge representation paradigm which gives a logical\nunderpinning for diverse modeling frameworks such as UML and ER. Technically,\nwe assume that we have separation logic shape invariants obtained from a shape\nanalysis tool, and requirements on the program data in terms of description\nlogic. We show that the two-variable fragment of first order logic with\ncounting and trees %(whose decidability was proved at LICS 2013) can be used as\na joint framework to embed suitable fragments of description logic and\nseparation logic.\n", "versions": [{"version": "v1", "created": "Mon, 23 Dec 2013 18:07:08 GMT"}, {"version": "v2", "created": "Fri, 24 Jan 2014 14:51:14 GMT"}, {"version": "v3", "created": "Wed, 9 Jul 2014 10:24:25 GMT"}], "update_date": "2014-07-10", "authors_parsed": [["Calvanese", "Diego", ""], ["Kotek", "Tomer", ""], ["\u0160imkus", "Mantas", ""], ["Veith", "Helmut", ""], ["Zuleger", "Florian", ""]]}]