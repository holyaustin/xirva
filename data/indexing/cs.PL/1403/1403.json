[{"id": "1403.0461", "submitter": "Francesco Santini", "authors": "Stefano Bistarelli, Maurizio Gabbrielli, Maria Chiara Meo, Francesco\n  Santini", "title": "Timed Soft Concurrent Constraint Programs: An Interleaved and a Parallel\n  Approach", "comments": null, "journal-ref": "Theory and Practice of Logic Programming 15 (2014) 743-782", "doi": "10.1017/S1471068414000106", "report-no": null, "categories": "cs.PL cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a timed and soft extension of Concurrent Constraint Programming.\nThe time extension is based on the hypothesis of bounded asynchrony: the\ncomputation takes a bounded period of time and is measured by a discrete global\nclock. Action prefixing is then considered as the syntactic marker which\ndistinguishes a time instant from the next one. Supported by soft constraints\ninstead of crisp ones, tell and ask agents are now equipped with a preference\n(or consistency) threshold which is used to determine their success or\nsuspension. In the paper we provide a language to describe the agents behavior,\ntogether with its operational and denotational semantics, for which we also\nprove the compositionality and correctness properties. After presenting a\nsemantics using maximal parallelism of actions, we also describe a version for\ntheir interleaving on a single processor (with maximal parallelism for time\nelapsing). Coordinating agents that need to take decisions both on preference\nvalues and time events may benefit from this language. To appear in Theory and\nPractice of Logic Programming (TPLP).\n", "versions": [{"version": "v1", "created": "Mon, 24 Feb 2014 12:23:38 GMT"}, {"version": "v2", "created": "Tue, 22 Apr 2014 09:08:34 GMT"}], "update_date": "2015-10-07", "authors_parsed": [["Bistarelli", "Stefano", ""], ["Gabbrielli", "Maurizio", ""], ["Meo", "Maria Chiara", ""], ["Santini", "Francesco", ""]]}, {"id": "1403.0504", "submitter": "Brooks Paige", "authors": "Brooks Paige and Frank Wood", "title": "A Compilation Target for Probabilistic Programming Languages", "comments": "In Proceedings of the 31st International Conference on Machine\n  Learning (ICML), 2014", "journal-ref": "JMLR W&CP 32 (1) : 1935-1943, 2014", "doi": null, "report-no": null, "categories": "cs.AI cs.PL stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Forward inference techniques such as sequential Monte Carlo and particle\nMarkov chain Monte Carlo for probabilistic programming can be implemented in\nany programming language by creative use of standardized operating system\nfunctionality including processes, forking, mutexes, and shared memory.\nExploiting this we have defined, developed, and tested a probabilistic\nprogramming language intermediate representation language we call probabilistic\nC, which itself can be compiled to machine code by standard compilers and\nlinked to operating system libraries yielding an efficient, scalable, portable\nprobabilistic programming compilation target. This opens up a new hardware and\nsystems research path for optimizing probabilistic programming systems.\n", "versions": [{"version": "v1", "created": "Mon, 3 Mar 2014 18:08:57 GMT"}, {"version": "v2", "created": "Thu, 10 Jul 2014 17:41:10 GMT"}], "update_date": "2014-07-11", "authors_parsed": [["Paige", "Brooks", ""], ["Wood", "Frank", ""]]}, {"id": "1403.0749", "submitter": "EPTCS", "authors": "Paolo Capriotti (University of Nottingham), Ambrus Kaposi (University\n  of Nottingham)", "title": "Free Applicative Functors", "comments": "In Proceedings MSFP 2014, arXiv:1406.1534", "journal-ref": "EPTCS 153, 2014, pp. 2-30", "doi": "10.4204/EPTCS.153.2", "report-no": null, "categories": "cs.PL math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Applicative functors are a generalisation of monads. Both allow the\nexpression of effectful computations into an otherwise pure language, like\nHaskell. Applicative functors are to be preferred to monads when the structure\nof a computation is fixed a priori. That makes it possible to perform certain\nkinds of static analysis on applicative values. We define a notion of free\napplicative functor, prove that it satisfies the appropriate laws, and that the\nconstruction is left adjoint to a suitable forgetful functor. We show how free\napplicative functors can be used to implement embedded DSLs which can be\nstatically analysed.\n", "versions": [{"version": "v1", "created": "Tue, 4 Mar 2014 11:53:35 GMT"}, {"version": "v2", "created": "Wed, 5 Mar 2014 11:43:05 GMT"}, {"version": "v3", "created": "Mon, 9 Jun 2014 03:29:22 GMT"}], "update_date": "2014-06-10", "authors_parsed": [["Capriotti", "Paolo", "", "University of Nottingham"], ["Kaposi", "Ambrus", "", "University\n  of Nottingham"]]}, {"id": "1403.1477", "submitter": "Rasmus Ejle M{\\o}gelberg", "authors": "Rasmus Ejlers M{\\o}gelberg (IT University of Copenhagen), Sam Staton\n  (Computer Laboratory, University of Cambridge)", "title": "Linear usage of state", "comments": "This article expands on a paper presented at the Fourth International\n  Conference on Algebra and Coalgebra in Computer Science (CALCO 2011)", "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 1 (March 25,\n  2014) lmcs:743", "doi": "10.2168/LMCS-10(1:17)2014", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the phenomenon that \"every monad is a linear state monad\". We\ndo this by studying a fully-complete state-passing translation from an impure\ncall-by-value language to a new linear type theory: the enriched call-by-value\ncalculus. The results are not specific to store, but can be applied to any\ncomputational effect expressible using algebraic operations, even to effects\nthat are not usually thought of as stateful. There is a bijective\ncorrespondence between generic effects in the source language and state access\noperations in the enriched call-by-value calculus. From the perspective of\ncategorical models, the enriched call-by-value calculus suggests a refinement\nof the traditional Kleisli models of effectful call-by-value languages. The new\nmodels can be understood as enriched adjunctions.\n", "versions": [{"version": "v1", "created": "Thu, 6 Mar 2014 16:18:12 GMT"}, {"version": "v2", "created": "Fri, 21 Mar 2014 17:20:46 GMT"}, {"version": "v3", "created": "Sun, 30 Mar 2014 11:10:44 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["M\u00f8gelberg", "Rasmus Ejlers", "", "IT University of Copenhagen"], ["Staton", "Sam", "", "Computer Laboratory, University of Cambridge"]]}, {"id": "1403.1694", "submitter": "Anton Petrov A", "authors": "Anton Petrov", "title": "Methods of executable code protection", "comments": "11 pages, 5 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The article deals with the problems in constructing a protection system of\nexecutable code. The techniques of breaking the integrity of executable code\nand ways to eliminate them are described. The adoption of virtual machine\ntechnology in the context of executable code protection from analysis is\nconsidered. The substantiation of the application of virtual machines as the\nbest way to oppose the analysis of executable code is made. The protection of\nexecutable code by transferring the protected code in a virtual execution\nenvironment is considered. An efficient implementation of the method is\nproposed.\n", "versions": [{"version": "v1", "created": "Fri, 7 Mar 2014 09:30:38 GMT"}], "update_date": "2014-03-10", "authors_parsed": [["Petrov", "Anton", ""]]}, {"id": "1403.2765", "submitter": "Christophe Rhodes", "authors": "Christophe Rhodes, Jan Moringen and David Lichteblau", "title": "Generalizers: New Metaobjects for Generalized Dispatch", "comments": "8 pages; version accepted for presentation at 2014 European Lisp\n  Symposium. http://eprints.gold.ac.uk/9924/", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces a new metaobject, the generalizer, which complements\nthe existing specializer metaobject. With the help of examples, we show that\nthis metaobject allows for the efficient implementation of complex\nnon-class-based dispatch within the framework of existing metaobject protocols.\nWe present our modifications to the generic function invocation protocol from\nthe Art of the Metaobject Protocol; in combination with previous work, this\nproduces a fully-functional extension of the existing mechanism for method\nselection and combination, including support for method combination completely\nindependent from method selection. We discuss our implementation, within the\nSBCL implementation of Common Lisp, and in that context compare the performance\nof the new protocol with the standard one, demonstrating that the new protocol\ncan be tolerably efficient.\n", "versions": [{"version": "v1", "created": "Tue, 11 Mar 2014 21:35:41 GMT"}, {"version": "v2", "created": "Tue, 22 Apr 2014 09:51:33 GMT"}], "update_date": "2014-04-23", "authors_parsed": [["Rhodes", "Christophe", ""], ["Moringen", "Jan", ""], ["Lichteblau", "David", ""]]}, {"id": "1403.3336", "submitter": "Kenneth Knowles", "authors": "Kenneth Knowles", "title": "Executable Refinement Types", "comments": "Ph.D. dissertation. Accepted by the University of California, Santa\n  Cruz, in March 2014. 278 pages (295 including frontmatter)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This dissertation introduces executable refinement types, which refine\nstructural types by semi-decidable predicates, and establishes their metatheory\nand accompanying implementation techniques. These results are useful for\nundecidable type systems in general.\n  Particular contributions include: (1) Type soundness and a logical relation\nfor extensional equivalence for executable refinement types (though type\nchecking is undecidable); (2) hybrid type checking for executable refinement\ntypes, which blends static and dynamic checks in a novel way, in some sense\nperforming better statically than any decidable approximation; (3) a type\nreconstruction algorithm - reconstruction is decidable even though type\nchecking is not, when suitably redefined to apply to undecidable type systems;\n(4) a novel use of existential types with dependent types to ensure that the\nlanguage of logical formulae is closed under type checking (5) a prototype\nimplementation, Sage, of executable refinement types such that all dynamic\nerrors are communicated back to the compiler and are thenceforth static errors.\n", "versions": [{"version": "v1", "created": "Thu, 13 Mar 2014 17:31:39 GMT"}], "update_date": "2014-03-14", "authors_parsed": [["Knowles", "Kenneth", ""]]}, {"id": "1403.3752", "submitter": "Gav Wood", "authors": "Gavin Wood", "title": "Martta: A C++ Language Workbench", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Language-orientated programming promises to elevate programmer productivity\nthrough increased abstrac- tion capabilities. Structural programming\nenvironments provide apparatus to reduce the difficulties with syntax. The\nlanguage workbench, a conceptual combination of these two approaches, is a\ncomparatively novel approach to software development and has so far been\nattempted only in dynamic-dispatch, run-time-compiled languages (e.g. Java).\nHowever, it must be remembered that several fields of engineering exist, each\nhaving their own priorities. In the video games industry, where large, complex\nand diverse projects are routinely developed, efficiency is paramount and as\nsuch C++, as a development platform, is widely used. I explore the possibility\nof a language workbench capable of a gradual transition in both skills and code\nfrom the traditional C++ development environment. This article is the design\nfor a language workbench. It uses novel techniques including a\ncontext-sensitive event- driven input system and a hybrid\nsingle/multiple-inherited class model and through a prototype implementation\ndemon- strates that is both concise and practical for C++. I refute the\nhitherto implicit hypothesis that the language workbench paradigm is not\napplicable to the C++ language, showing that C++ can be used for creating an\neffective development framework usable in otherwise pure-C++ programming\nenvironments.\n", "versions": [{"version": "v1", "created": "Sat, 15 Mar 2014 04:12:39 GMT"}], "update_date": "2014-03-18", "authors_parsed": [["Wood", "Gavin", ""]]}, {"id": "1403.3964", "submitter": "Hirotaka Niitsuma", "authors": "Hirotaka Niitsuma", "title": "Image processing using miniKanren", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CV cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An integral image is one of the most efficient optimization technique for\nimage processing. However an integral image is only a special case of delayed\nstream or memoization. This research discusses generalizing concept of integral\nimage optimization technique, and how to generate an integral image optimized\nprogram code automatically from abstracted image processing algorithm. In oder\nto abstruct algorithms, we forces to miniKanren.\n", "versions": [{"version": "v1", "created": "Sun, 16 Mar 2014 22:03:45 GMT"}], "update_date": "2014-03-18", "authors_parsed": [["Niitsuma", "Hirotaka", ""]]}, {"id": "1403.3996", "submitter": "Vineeth Kashyap", "authors": "Vineeth Kashyap, Kyle Dewey, Ethan A. Kuefner, John Wagner, Kevin\n  Gibbons, John Sarracino, Ben Wiedermann, Ben Hardekopf", "title": "JSAI: Designing a Sound, Configurable, and Efficient Static Analyzer for\n  JavaScript", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe JSAI, an abstract interpreter for JavaScript. JSAI uses novel\nabstract domains to compute a reduced product of type inference, pointer\nanalysis, string analysis, integer and boolean constant propagation, and\ncontrol-flow analysis. In addition, JSAI allows for analysis control-flow\nsensitivity (i.e., context-, path-, and heap-sensitivity) to be modularly\nconfigured without requiring any changes to the analysis implementation. JSAI\nis designed to be provably sound with respect to a specific concrete semantics\nfor JavaScript, which has been extensively tested against existing\nproduction-quality JavaScript implementations.\n  We provide a comprehensive evaluation of JSAI's performance and precision\nusing an extensive benchmark suite. This benchmark suite includes real-world\nJavaScript applications, machine-generated JavaScript code via Emscripten, and\nbrowser addons. We use JSAI's configurability to evaluate a large number of\nanalysis sensitivities (some well-known, some novel) and observe some\nsurprising results. We believe that JSAI's configurability and its formal\nspecifications position it as a useful research platform to experiment on novel\nsensitivities, abstract domains, and client analyses for JavaScript.\n", "versions": [{"version": "v1", "created": "Mon, 17 Mar 2014 04:29:25 GMT"}], "update_date": "2014-03-18", "authors_parsed": [["Kashyap", "Vineeth", ""], ["Dewey", "Kyle", ""], ["Kuefner", "Ethan A.", ""], ["Wagner", "John", ""], ["Gibbons", "Kevin", ""], ["Sarracino", "John", ""], ["Wiedermann", "Ben", ""], ["Hardekopf", "Ben", ""]]}, {"id": "1403.4064", "submitter": "Ivan Radi\\v{c}ek", "authors": "Sumit Gulwani, Ivan Radi\\v{c}ek, Florian Zuleger", "title": "Feedback Generation for Performance Problems in Introductory Programming\n  Assignments", "comments": "Tech report/extended version of FSE 2014 paper", "journal-ref": null, "doi": "10.1145/2635868.2635912", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Providing feedback on programming assignments manually is a tedious, error\nprone, and time-consuming task. In this paper, we motivate and address the\nproblem of generating feedback on performance aspects in introductory\nprogramming assignments. We studied a large number of functionally correct\nstudent solutions to introductory programming assignments and observed: (1)\nThere are different algorithmic strategies, with varying levels of efficiency,\nfor solving a given problem. These different strategies merit different\nfeedback. (2) The same algorithmic strategy can be implemented in countless\ndifferent ways, which are not relevant for reporting feedback on the student\nprogram.\n  We propose a light-weight programming language extension that allows a\nteacher to define an algorithmic strategy by specifying certain key values that\nshould occur during the execution of an implementation. We describe a dynamic\nanalysis based approach to test whether a student's program matches a teacher's\nspecification. Our experimental results illustrate the effectiveness of both\nour specification language and our dynamic analysis. On one of our benchmarks\nconsisting of 2316 functionally correct implementations to 3 programming\nproblems, we identified 16 strategies that we were able to describe using our\nspecification language (in 95 minutes after inspecting 66, i.e., around 3%,\nimplementations). Our dynamic analysis correctly matched each implementation\nwith its corresponding specification, thereby automatically producing the\nintended feedback.\n", "versions": [{"version": "v1", "created": "Mon, 17 Mar 2014 11:09:59 GMT"}, {"version": "v2", "created": "Wed, 17 Sep 2014 10:01:03 GMT"}], "update_date": "2014-09-18", "authors_parsed": [["Gulwani", "Sumit", ""], ["Radi\u010dek", "Ivan", ""], ["Zuleger", "Florian", ""]]}, {"id": "1403.4813", "submitter": "Xianjin Fu", "authors": "Xianjin Fu, Zhenbang Chen, Yufeng Zhang, Chun Huang, Wei Dong and Ji\n  Wang", "title": "MPISE: Symbolic Execution of MPI Programs", "comments": "25pages, extended version (unpublished!) of paper submitted to ictac\n  2014. Version 0.2, we carry out experiments using release llvm istead of a\n  debug version one, which makes mpise 10 times faster", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Message Passing Interfaces (MPI) plays an important role in parallel\ncomputing. Many parallel applications are implemented as MPI programs. The\nexisting methods of bug detection for MPI programs have the shortage of\nproviding both input and non-determinism coverage, leading to missed bugs. In\nthis paper, we employ symbolic execution to ensure the input coverage, and\npropose an on-the-fly schedule algorithm to reduce the interleaving\nexplorations for non-determinism coverage, while ensuring the soundness and\ncompleteness. We have implemented our approach as a tool, called MPISE, which\ncan automatically detect the deadlock and runtime bugs in MPI programs. The\nresults of the experiments on benchmark programs and real world MPI programs\nindicate that MPISE finds bugs effectively and efficiently. In addition, our\ntool also provides diagnostic information and replay mechanism to help\nunderstanding bugs.\n", "versions": [{"version": "v1", "created": "Wed, 19 Mar 2014 14:23:24 GMT"}, {"version": "v2", "created": "Tue, 8 Apr 2014 11:49:01 GMT"}, {"version": "v3", "created": "Mon, 15 Sep 2014 08:21:28 GMT"}], "update_date": "2014-09-16", "authors_parsed": [["Fu", "Xianjin", ""], ["Chen", "Zhenbang", ""], ["Zhang", "Yufeng", ""], ["Huang", "Chun", ""], ["Dong", "Wei", ""], ["Wang", "Ji", ""]]}, {"id": "1403.4910", "submitter": "Vini Kanvar", "authors": "Vini Kanvar and Uday P. Khedker", "title": "Heap Abstractions for Static Analysis", "comments": "49 pages, 20 figures", "journal-ref": "ACM Computing Surveys, June 2016, Volume 49, Issue 2, Article 29\n  (http://dl.acm.org/citation.cfm?id=2931098)", "doi": "10.1145/2931098", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Heap data is potentially unbounded and seemingly arbitrary. As a consequence,\nunlike stack and static memory, heap memory cannot be abstracted directly in\nterms of a fixed set of source variable names appearing in the program being\nanalysed. This makes it an interesting topic of study and there is an abundance\nof literature employing heap abstractions. Although most studies have addressed\nsimilar concerns, their formulations and formalisms often seem dissimilar and\nsome times even unrelated. Thus, the insights gained in one description of heap\nabstraction may not directly carry over to some other description. This survey\nis a result of our quest for a unifying theme in the existing descriptions of\nheap abstractions. In particular, our interest lies in the abstractions and not\nin the algorithms that construct them.\n  In our search of a unified theme, we view a heap abstraction as consisting of\ntwo features: a heap model to represent the heap memory and a summarization\ntechnique for bounding the heap representation. We classify the models as\nstoreless, store based, and hybrid. We describe various summarization\ntechniques based on k-limiting, allocation sites, patterns, variables, other\ngeneric instrumentation predicates, and higher-order logics. This approach\nallows us to compare the insights of a large number of seemingly dissimilar\nheap abstractions and also paves way for creating new abstractions by\nmix-and-match of models and summarization techniques.\n", "versions": [{"version": "v1", "created": "Wed, 19 Mar 2014 18:59:56 GMT"}, {"version": "v2", "created": "Thu, 20 Mar 2014 08:32:37 GMT"}, {"version": "v3", "created": "Tue, 15 Apr 2014 19:38:45 GMT"}, {"version": "v4", "created": "Sun, 2 Nov 2014 16:57:45 GMT"}, {"version": "v5", "created": "Wed, 13 May 2015 17:55:53 GMT"}], "update_date": "2016-07-05", "authors_parsed": [["Kanvar", "Vini", ""], ["Khedker", "Uday P.", ""]]}, {"id": "1403.5843", "submitter": "Jedidiah McClurg", "authors": "Jedidiah McClurg, Hossein Hojjat, Pavol Cerny, Nate Foster", "title": "Efficient Synthesis of Network Updates", "comments": null, "journal-ref": null, "doi": "10.1145/2737924.2737980", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Software-defined networking (SDN) is revolutionizing the networking industry,\nbut current SDN programming platforms do not provide automated mechanisms for\nupdating global configurations on the fly. Implementing updates by hand is\nchallenging for SDN programmers because networks are distributed systems with\nhundreds or thousands of interacting nodes. Even if initial and final\nconfigurations are correct, naively updating individual nodes can lead to\nincorrect transient behaviors, including loops, black holes, and access control\nviolations. This paper presents an approach for automatically synthesizing\nupdates that are guaranteed to preserve specified properties. We formalize\nnetwork updates as a distributed programming problem and develop a synthesis\nalgorithm based on counterexample-guided search and incremental model checking.\nWe describe a prototype implementation, and present results from experiments on\nreal-world topologies and properties demonstrating that our tool scales to\nupdates involving over one-thousand nodes.\n", "versions": [{"version": "v1", "created": "Mon, 24 Mar 2014 03:34:49 GMT"}, {"version": "v2", "created": "Thu, 18 Dec 2014 07:31:19 GMT"}, {"version": "v3", "created": "Thu, 16 Apr 2015 20:50:29 GMT"}], "update_date": "2015-04-20", "authors_parsed": [["McClurg", "Jedidiah", ""], ["Hojjat", "Hossein", ""], ["Cerny", "Pavol", ""], ["Foster", "Nate", ""]]}, {"id": "1403.5952", "submitter": "Fabrice Rastello", "authors": "Andr\\'e Tavares (UFMG), Benoit Boissinot (INRIA Grenoble Rh\\^one-Alpes\n  / LIP Laboratoire de l'Informatique du Parall\\'elisme), Fernando Pereira\n  (LLP), Fabrice Rastello (INRIA Grenoble Rh\\^one-Alpes)", "title": "Parameterized Construction of Program Representations for Sparse\n  Dataflow Analyses", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Data-flow analyses usually associate information with control flow regions.\nInformally, if these regions are too small, like a point between two\nconsecutive statements, we call the analysis dense. On the other hand, if these\nregions include many such points, then we call it sparse. This paper presents a\nsystematic method to build program representations that support sparse\nanalyses. To pave the way to this framework we clarify the bibliography about\nwell-known intermediate program representations. We show that our approach, up\nto parameter choice, subsumes many of these representations, such as the SSA,\nSSI and e-SSA forms. In particular, our algorithms are faster, simpler and more\nfrugal than the previous techniques used to construct SSI - Static Single\nInformation - form programs. We produce intermediate representations isomorphic\nto Choi et al.'s Sparse Evaluation Graphs (SEG) for the family of data-flow\nproblems that can be partitioned per variables. However, contrary to SEGs, we\ncan handle - sparsely - problems that are not in this family.\n", "versions": [{"version": "v1", "created": "Fri, 21 Mar 2014 18:44:06 GMT"}], "update_date": "2014-03-25", "authors_parsed": [["Tavares", "Andr\u00e9", "", "UFMG"], ["Boissinot", "Benoit", "", "INRIA Grenoble Rh\u00f4ne-Alpes\n  / LIP Laboratoire de l'Informatique du Parall\u00e9lisme"], ["Pereira", "Fernando", "", "LLP"], ["Rastello", "Fabrice", "", "INRIA Grenoble Rh\u00f4ne-Alpes"]]}, {"id": "1403.6997", "submitter": "Martin Li\\v{s}ka", "authors": "Martin Li\\v{s}ka", "title": "Optimizing large applications", "comments": "78 pages, diploma thesis", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Both uppermost open source compilers, GCC and LLVM, are mature enough to\nlink-time optimize large applications. In case of large applications, we must\ntake into account, except standard speed efficiency and memory consumption,\ndifferent aspects. We focus on size of the code, cold start-up time, etc.\nDevelopers of applications often come up with ad-hoc solutions such as Elfhack\nutility, start-up of an application via a pre-loading utility and dlopen;\nprelinking and variety of different tools that reorder functions to fit the\norder of execution. The goal of the thesis is to analyse all existing\ntechniques of optimization, evaluate their efficiency and design new solutions\nbased on the link-time optimization platform.\n", "versions": [{"version": "v1", "created": "Thu, 27 Mar 2014 12:24:41 GMT"}], "update_date": "2014-03-28", "authors_parsed": [["Li\u0161ka", "Martin", ""]]}, {"id": "1403.7579", "submitter": "EPTCS", "authors": "Benedikt L\\\"owe, Glynn Winskel", "title": "Proceedings 8th International Workshop on Developments in Computational\n  Models", "comments": null, "journal-ref": "EPTCS 143, 2014", "doi": "10.4204/EPTCS.143", "report-no": null, "categories": "cs.LO cs.DC cs.DS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The aim of the workshop series Developments in Computational Models (DCM) is\nto bring together researchers who are currently developing new computational\nmodels or new features for traditional computational models, in order to foster\ntheir interaction, to provide a forum for presenting new ideas and work in\nprogress, and to enable newcomers to learn about current activities in this\narea. The eighth workshop in the series, DCM 2012, was part of the celebrations\nof the Turing Centenary and was held as a satellite event of the Turing\ncentenary conference Computability in Europe 2012 (CiE 2012) in Cambridge. It\ntook place at Corpus Christi College in Cambridge on Sunday, 17 June 2013.\n  This electronic proceedings volume includes one of the keynote papers as well\nas revised versions of papers accepted for presentation by the programme\ncommittee.\n", "versions": [{"version": "v1", "created": "Sat, 29 Mar 2014 01:54:28 GMT"}], "update_date": "2014-04-01", "authors_parsed": [["L\u00f6we", "Benedikt", ""], ["Winskel", "Glynn", ""]]}, {"id": "1403.7685", "submitter": "EPTCS", "authors": "Mauricio Ayala-Rinc\\'on, Eduardo Bonelli, Ian Mackie", "title": "Proceedings 9th International Workshop on Developments in Computational\n  Models", "comments": "EPTCS 144, 2014", "journal-ref": null, "doi": "10.4204/EPTCS.144", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains a selection of the papers presented at the Ninth\nInternational Workshop on Developments in Computational Models (DCM 2013) held\nin Buenos Aires, Argentina on 26th August 2013, as a satellite event of CONCUR\n2013. Several new models of computation have emerged in the last years, and\nmany developments of traditional computational models have been proposed with\nthe aim of taking into account the new demands of computer systems users and\nthe new capabilities of computation engines. A new computational model, or a\nnew feature in a traditional one, usually is reflected in a new family of\nprogramming languages, and new paradigms of software development. The aim of\nthis workshop is to bring together researchers who are currently developing new\ncomputational models or new features for traditional computational models, in\norder to foster their interaction, to provide a forum for presenting new ideas\nand work in progress, and to enable newcomers to learn about current activities\nin this area.\n", "versions": [{"version": "v1", "created": "Sun, 30 Mar 2014 00:58:40 GMT"}], "update_date": "2014-04-01", "authors_parsed": [["Ayala-Rinc\u00f3n", "Mauricio", ""], ["Bonelli", "Eduardo", ""], ["Mackie", "Ian", ""]]}, {"id": "1403.7840", "submitter": "EPTCS", "authors": "Andrew Noyes (Cornell University), Todd Warszawski (Cornell\n  University), Pavol \\v{C}ern\\'y (University of Colorado Boulder), Nate Foster\n  (Cornell University)", "title": "Toward Synthesis of Network Updates", "comments": "In Proceedings SYNT 2013, arXiv:1403.7264", "journal-ref": "EPTCS 142, 2014, pp. 8-23", "doi": "10.4204/EPTCS.142.8", "report-no": null, "categories": "cs.PL cs.LO cs.NI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Updates to network configurations are notoriously difficult to implement\ncorrectly. Even if the old and new configurations are correct, the update\nprocess can introduce transient errors such as forwarding loops, dropped\npackets, and access control violations. The key factor that makes updates\ndifficult to implement is that networks are distributed systems with hundreds\nor even thousands of nodes, but updates must be rolled out one node at a time.\nIn networks today, the task of determining a correct sequence of updates is\nusually done manually -- a tedious and error-prone process for network\noperators. This paper presents a new tool for synthesizing network updates\nautomatically. The tool generates efficient updates that are guaranteed to\nrespect invariants specified by the operator. It works by navigating through\nthe (restricted) space of possible solutions, learning from counterexamples to\nimprove scalability and optimize performance. We have implemented our tool in\nOCaml, and conducted experiments showing that it scales to networks with a\nthousand switches and tens of switches updating.\n", "versions": [{"version": "v1", "created": "Mon, 31 Mar 2014 00:30:25 GMT"}], "update_date": "2014-08-10", "authors_parsed": [["Noyes", "Andrew", "", "Cornell University"], ["Warszawski", "Todd", "", "Cornell\n  University"], ["\u010cern\u00fd", "Pavol", "", "University of Colorado Boulder"], ["Foster", "Nate", "", "Cornell University"]]}, {"id": "1403.8028", "submitter": "Mohamed El-Zawawy Dr.", "authors": "Mohamed A. El-Zawawy, Adel I. AlSalem", "title": "ImNet: An Imperative Network Programming Language", "comments": "8 pages, 8 figures, Mohamed A. El-Zawawy and Adel I. AlSalem. ImNet:\n  An Imperative Network Programming Language. Proceedings of The 14th\n  International Conference on Applied Computer Science, ACS 2014, Constantin\n  Buzatu (Ed): Modern Computer Applications in Science and Education, pp.\n  149--156", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.NI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One of the most recent architectures of networks is Software-Defined Networks\n(SDNs) using a con- troller appliance to control the set of switches on the\nnetwork. The controlling process includes installing or uninstalling\npacket-processing rules on flow tables of switches. This paper presents a\nhigh-level imperative network programming language, called ImNet, to facilitate\nwriting efficient, yet simple, programs executed by controller to manage\nswitches. ImNet is simply-structured, expressive, compositional, and\nimperative. This paper also introduces an operational semantics to ImNet.\nDetailed examples of programs (with their operational semantics) constructed in\nImNet are illustrated in the paper as well.\n", "versions": [{"version": "v1", "created": "Sun, 23 Feb 2014 19:20:18 GMT"}], "update_date": "2014-04-01", "authors_parsed": [["El-Zawawy", "Mohamed A.", ""], ["AlSalem", "Adel I.", ""]]}]