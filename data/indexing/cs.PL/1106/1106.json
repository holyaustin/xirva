[{"id": "1106.0447", "submitter": "Umut Acar", "authors": "Umut A. Acar and Guy E. Blelloch and Robert Harper", "title": "Selective Memoization", "comments": "Total of 31 pages. This is the full version of a conference paper\n  with the same title that appears in ACM Conference on Principles of\n  Programming Languages (POPL) in 2003", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents language techniques for applying memoization selectively.\nThe techniques provide programmer control over equality, space usage, and\nidentification of precise dependences so that memoization can be applied\naccording to the needs of an application. Two key properties of the approach\nare that it accepts and efficient implementation and yields programs whose\nperformance can be analyzed using standard analysis techniques. We describe our\napproach in the context of a functional language called MFL and an\nimplementation as a Standard ML library. The MFL language employs a modal type\nsystem to enable the programmer to express programs that reveal their true data\ndependences when executed. We prove that the MFL language is sound by showing\nthat that MFL programs yield the same result as they would with respect to a\nstandard, non-memoizing semantics. The SML implementation cannot support the\nmodal type system of MFL statically but instead employs run-time checks to\nensure correct usage of primitives.\n", "versions": [{"version": "v1", "created": "Thu, 2 Jun 2011 15:03:15 GMT"}], "update_date": "2011-06-03", "authors_parsed": [["Acar", "Umut A.", ""], ["Blelloch", "Guy E.", ""], ["Harper", "Robert", ""]]}, {"id": "1106.0478", "submitter": "Umut Acar", "authors": "Umut A. Acar and Matthias Blume and Jacob Donham", "title": "A Consistent Semantics of Self-Adjusting Computation", "comments": "91 pages including the full Twelf proof in the appendix. This paper\n  is a full version of the conference paper (published in European Symposium on\n  Programming, ESOP, 2007)", "journal-ref": null, "doi": null, "report-no": "CMU-CS-2007-18", "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a semantics of self-adjusting computation and proves that\nthe semantics are correct and consistent. The semantics integrate change\npropagation with the classic idea of memoization to enable reuse of\ncomputations under mutation to memory. During evaluation, reuse of a\ncomputation via memoization triggers a change propagation that adjusts the\nreused computation to reflect the mutated memory. Since the semantics integrate\nmemoization and change-propagation, it involves both non-determinism (due to\nmemoization) and mutation (due to change propagation). Our consistency theorem\nstates that the non-determinism is not harmful: any two evaluations of the same\nprogram starting at the same state yield the same result. Our correctness\ntheorem states that mutation is not harmful: self-adjusting programs are\nconsistent with purely functional programming. We formalize the semantics and\ntheir meta-theory in the LF logical framework and machine check our proofs\nusing Twelf.\n", "versions": [{"version": "v1", "created": "Thu, 2 Jun 2011 18:13:08 GMT"}], "update_date": "2011-06-03", "authors_parsed": [["Acar", "Umut A.", ""], ["Blume", "Matthias", ""], ["Donham", "Jacob", ""]]}, {"id": "1106.0776", "submitter": "Juan Carlos Nieves", "authors": "Juan Carlos Nieves, Mauricio Osorio and Ulises Cort\\'es", "title": "Semantics for Possibilistic Disjunctive Programs", "comments": "37 pages, 5 figures. To appear in Theory and Practice of Logic\n  Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  In this paper, a possibilistic disjunctive logic programming approach for\nmodeling uncertain, incomplete and inconsistent information is defined. This\napproach introduces the use of possibilistic disjunctive clauses which are able\nto capture incomplete information and incomplete states of a knowledge base at\nthe same time.\n  By considering a possibilistic logic program as a possibilistic logic theory,\na construction of a possibilistic logic programming semantic based on answer\nsets and the proof theory of possibilistic logic is defined. It shows that this\npossibilistic semantics for disjunctive logic programs can be characterized by\na fixed-point operator. It is also shown that the suggested possibilistic\nsemantics can be computed by a resolution algorithm and the consideration of\noptimal refutations from a possibilistic logic theory.\n  In order to manage inconsistent possibilistic logic programs, a preference\ncriterion between inconsistent possibilistic models is defined; in addition,\nthe approach of cuts for restoring consistency of an inconsistent possibilistic\nknowledge base is adopted. The approach is illustrated in a medical scenario.\n", "versions": [{"version": "v1", "created": "Fri, 3 Jun 2011 22:57:06 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Nieves", "Juan Carlos", ""], ["Osorio", "Mauricio", ""], ["Cort\u00e9s", "Ulises", ""]]}, {"id": "1106.1234", "submitter": "EPTCS", "authors": "Makoto Tatsuta (National Institute of Informatics), Ferruccio Damiani\n  (Universita di Torino)", "title": "Type Inference for Bimorphic Recursion", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 102-115", "doi": "10.4204/EPTCS.54.8", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes bimorphic recursion, which is restricted polymorphic\nrecursion such that every recursive call in the body of a function definition\nhas the same type. Bimorphic recursion allows us to assign two different types\nto a recursively defined function: one is for its recursive calls and the other\nis for its calls outside its definition. Bimorphic recursion in this paper can\nbe nested. This paper shows bimorphic recursion has principal types and\ndecidable type inference. Hence bimorphic recursion gives us flexible typing\nfor recursion with decidable type inference. This paper also shows that its\ntypability becomes undecidable because of nesting of recursions when one\nremoves the instantiation property from the bimorphic recursion.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:06:23 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Tatsuta", "Makoto", "", "National Institute of Informatics"], ["Damiani", "Ferruccio", "", "Universita di Torino"]]}, {"id": "1106.1311", "submitter": "Bart Demoen", "authors": "Phuong-Lan Nguyen and Bart Demoen", "title": "Representation Sharing for Prolog", "comments": "37 pages, 11 figures, 3 tables; To appear in Theory and Practice of\n  Logic Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Representation sharing can reduce the memory footprint of a program by\nsharing one representation between duplicate terms. The most common\nimplementation of representation sharing in functional programming systems is\nknown as hash-consing. In the context of Prolog, representation sharing has\nbeen given little attention. Some current techniques that deal with\nrepresentation sharing are reviewed. The new contributions are: (1) an easy\nimplementation of {\\em input sharing} for {\\em findall/3}; (2) a description of\na {\\em sharer} module that introduces representation sharing at runtime. Their\nrealization is shown in the context of the WAM as implemented by hProlog. Both\ncan be adapted to any WAM-like Prolog implementation. The sharer works\nindependently of the garbage collector, but it can be made to cooperate with\nthe garbage collector. Benchmark results show that the sharer has a cost\ncomparable to the heap garbage collector, that its effectiveness is highly\napplication dependent, and that its policy must be tuned to the collector. To\nappear in Theory and Practice of Logic Programming (TPLP)\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 10:34:53 GMT"}, {"version": "v2", "created": "Thu, 30 Jun 2011 07:09:53 GMT"}], "update_date": "2011-07-01", "authors_parsed": [["Nguyen", "Phuong-Lan", ""], ["Demoen", "Bart", ""]]}, {"id": "1106.1364", "submitter": "Andreas Gaiser", "authors": "Javier Esparza and Andreas Gaiser", "title": "Probabilistic Abstractions with Arbitrary Domains", "comments": "This is a technical report that goes along with an article to appear\n  in the Proceedings of the 18th International Static Analysis Symposium (SAS),\n  2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent work by Hermanns et al. and Kattenbelt et al. has extended\ncounterexample-guided abstraction refinement (CEGAR) to probabilistic programs.\nThese approaches are limited to predicate abstraction. We present a novel\ntechnique, based on the abstract reachability tree recently introduced by\nGulavani et al., that can use arbitrary abstract domains and widening operators\n(in the sense of abstract interpretation). We show how suitable widening\noperators can deduce loop invariants diffcult to find for predicate\nabstraction, and propose refinement techniques.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 14:39:44 GMT"}, {"version": "v2", "created": "Thu, 16 Jun 2011 10:54:26 GMT"}], "update_date": "2011-06-17", "authors_parsed": [["Esparza", "Javier", ""], ["Gaiser", "Andreas", ""]]}, {"id": "1106.1531", "submitter": "Johan Nystr\\\"om Persson", "authors": "Johan Nystr\\\"om-Persson and Shinichi Honiden", "title": "Poplar: A Java Extension for Evolvable Component Integration", "comments": "17 pages. Corrected typos", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Java programming language contains many features that aid component-based\nsoftware development (CBSD), such as interfaces, visibility levels, and strong\nsupport for encapsulation. However, component evolution often causes so-called\nbreaking changes, largely because of the rigidity of component interconnections\nin the form of explicit method calls and field accesses. We present a Java\nextension, Poplar, which we are currently developing. In Poplar,\ninter-component dependencies are expressed using declarative queries; concrete\nlinking code, generated using a planning algorithm, replaces these at compile\ntime. Poplar includes a minimal specification language based on typestate-like\nprotocols and labels, and a lightweight effect system, which ensures the\nabsence of unwanted interference between hand-written code and generated code.\nWe give several examples of fully automatic component integration using Poplar,\nand demonstrate its potential to simplify object-oriented software development\ngreatly through evolvable and statically checkable integration links.\n", "versions": [{"version": "v1", "created": "Wed, 8 Jun 2011 10:02:02 GMT"}, {"version": "v2", "created": "Thu, 9 Jun 2011 04:00:58 GMT"}], "update_date": "2011-06-10", "authors_parsed": [["Nystr\u00f6m-Persson", "Johan", ""], ["Honiden", "Shinichi", ""]]}, {"id": "1106.2575", "submitter": "Sam Tobin-Hochstadt", "authors": "Sam Tobin-Hochstadt and Matthias Felleisen", "title": "The Design and Implementation of Typed Scheme: From Scripts to Programs", "comments": "Accepted for publication in Higher Order and Symbolic Computation.\n  This is a revised and extended version of a paper presented at the 35th ACM\n  SIGPLAN-SIGACT Symposium on Principles of Programming Languages, 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  When scripts in untyped languages grow into large programs, maintaining them\nbecomes difficult. A lack of explicit type annotations in typical scripting\nlanguages forces programmers to must (re)discover critical pieces of design\ninformation every time they wish to change a program. This analysis step both\nslows down the maintenance process and may even introduce mistakes due to the\nviolation of undiscovered invariants.\n  This paper presents Typed Scheme, an explicitly typed extension of PLT\nScheme, an untyped scripting language. Its type system is based on the novel\nnotion of occurrence typing, which we formalize and mechanically prove sound.\nThe implementation of Typed Scheme additionally borrows elements from a range\nof approaches, including recursive types, true unions and subtyping, plus\npolymorphism combined with a modicum of local inference.\n  The formulation of occurrence typing naturally leads to a simple and\nexpressive version of predicates to describe refinement types. A Typed Scheme\nprogram can use these refinement types to keep track of arbitrary classes of\nvalues via the type system. Further, we show how the Typed Scheme type system,\nin conjunction with simple recursive types, is able to encode refinements of\nexisting datatypes, thus expressing both proposed variations of refinement\ntypes.\n", "versions": [{"version": "v1", "created": "Mon, 13 Jun 2011 23:41:05 GMT"}], "update_date": "2011-06-15", "authors_parsed": [["Tobin-Hochstadt", "Sam", ""], ["Felleisen", "Matthias", ""]]}, {"id": "1106.2578", "submitter": "Sam Tobin-Hochstadt", "authors": "Sam Tobin-Hochstadt", "title": "Extensible Pattern Matching in an Extensible Language", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Pattern matching is a widely used technique in functional languages,\nespecially those in the ML and Haskell traditions, where it is at the core of\nthe semantics. In languages in the Lisp tradition, in contrast, pattern\nmatching it typically provided by libraries built with macros. We present\nmatch, a sophisticated pattern matcher for Racket, implemented as language\nextension. using macros. The system supports novel and widely-useful\npattern-matching forms, and is itself extensible. The extensibility of match is\nimplemented via a general technique for creating extensible language\nextensions.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2011 00:06:58 GMT"}], "update_date": "2011-06-15", "authors_parsed": [["Tobin-Hochstadt", "Sam", ""]]}, {"id": "1106.2593", "submitter": "Oleg Mazonka", "authors": "Oleg Mazonka and Alex Kolodin", "title": "A Simple Multi-Processor Computer Based on Subleq", "comments": "24 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.AR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Subleq (Subtract and Branch on result Less than or Equal to zero) is both an\ninstruction set and a programming language for One Instruction Set Computer\n(OISC). We describe a hardware implementation of an array of 28 one-instruction\nSubleq processors on a low-cost FPGA board. Our test results demonstrate that\ncomputational power of our Subleq OISC multi-processor is comparable to that of\nCPU of a modern personal computer. Additionally, we provide implementation\ndetails of our complier from a C-style language to Subleq.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2011 01:26:41 GMT"}], "update_date": "2011-06-15", "authors_parsed": [["Mazonka", "Oleg", ""], ["Kolodin", "Alex", ""]]}, {"id": "1106.2637", "submitter": "David Monniaux", "authors": "David Monniaux (VERIMAG - IMAG), Laure Gonnord (LIFL)", "title": "Using Bounded Model Checking to Focus Fixpoint Iterations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two classical sources of imprecision in static analysis by abstract\ninterpretation are widening and merge operations. Merge operations can be done\naway by distinguishing paths, as in trace partitioning, at the expense of\nenumerating an exponential number of paths. In this article, we describe how to\navoid such systematic exploration by focusing on a single path at a time,\ndesignated by SMT-solving. Our method combines well with acceleration\ntechniques, thus doing away with widenings as well in some cases. We illustrate\nit over the well-known domain of convex polyhedra.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2011 08:34:11 GMT"}], "update_date": "2011-06-15", "authors_parsed": [["Monniaux", "David", "", "VERIMAG - IMAG"], ["Gonnord", "Laure", "", "LIFL"]]}, {"id": "1106.2684", "submitter": "Pascal Heus", "authors": "Pascal Heus, Richard Gomez", "title": "QIS-XML: An Extensible Markup Language for Quantum Information Science", "comments": "83 pages, 58 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.ET cs.PL quant-ph", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  This Master thesis examines issues of interoperability and integration\nbetween the Classic Information Science (CIS) and Quantum Information Science\n(QIS). It provides a short introduction to the Extensible Markup Language (XML)\nand proceeds to describe the development steps that have lead to a prototype\nXML specification for quantum computing (QIS-XML). QIS-XML is a proposed\nframework, based on the widely used standard (XML) to describe, visualize,\nexchange and process quantum gates and quantum circuits. It also provides a\npotential approach to a generic programming language for quantum computers\nthrough the concept of XML driven compilers. Examples are provided for the\ndescription of commonly used quantum gates and circuits, accompanied with tools\nto visualize them in standard web browsers. An algorithmic example is also\npresented, performing a simple addition operation with quantum circuits and\nrunning the program on a quantum computer simulator. Overall, this initial\neffort demonstrates how XML technologies could be at the core of the\narchitecture for describing and programming quantum computers. By leveraging a\nwidely accepted standard, QIS-XML also builds a bridge between classic and\nquantum IT, which could foster the acceptance of QIS by the ICT community and\nfacilitate the understanding of quantum technology by IT experts. This would\nsupport the consolidation of Classic Information Science and Quantum\nInformation Science into a Complete Information Science, a challenge that could\nbe referred to as the \"Information Science Grand Unification Challenge\".\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2011 12:04:57 GMT"}], "update_date": "2011-06-15", "authors_parsed": [["Heus", "Pascal", ""], ["Gomez", "Richard", ""]]}, {"id": "1106.2872", "submitter": "Yu Zhang", "authors": "Yuxin Deng, Yu Zhang", "title": "Program Equivalence in Linear Contexts", "comments": "Technical report, Laboratory for Computer Science, ISCAS", "journal-ref": null, "doi": null, "report-no": "ISCAS-SKLCS-11-04", "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program equivalence in linear contexts, where programs are used or executed\nexactly once, is an important issue in programming languages. However, existing\ntechniques like those based on bisimulations and logical relations only target\nat contextual equivalence in the usual (non-linear) functional languages, and\nfail in capturing non-trivial equivalent programs in linear contexts,\nparticularly when non-determinism is present. We propose the notion of linear\ncontextual equivalence to formally characterize such program equivalence, as\nwell as a novel and general approach to studying it in higher-order languages,\nbased on labeled transition systems specifically designed for functional\nlanguages. We show that linear contextual equivalence indeed coincides with\ntrace equivalence - it is sound and complete. We illustrate our technique in\nboth deterministic (a linear version of PCF) and non-deterministic (linear PCF\nin Moggi's framework) functional languages.\n", "versions": [{"version": "v1", "created": "Wed, 15 Jun 2011 04:48:17 GMT"}, {"version": "v2", "created": "Tue, 11 Oct 2011 05:15:38 GMT"}], "update_date": "2011-10-12", "authors_parsed": [["Deng", "Yuxin", ""], ["Zhang", "Yu", ""]]}, {"id": "1106.3314", "submitter": "Roman Gitlin", "authors": "Roman Gitlin", "title": "Reducing Interpolation on Multi-Grid to Quantizing Grid's Data-Base as a\n  Recursion", "comments": "75 pages, 2 code snippets", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.CG cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In his article \"Powerlist: A Structure for Parallel Recursion\" Jayadev Misra\nwrote:\n  \"Many data parallel algorithms Fast Fourier Transform, Batcher's sorting\nschemes and prefix sum -exhibit recursive structure. We propose a data\nstructure, powerlist, that permits succinct descriptions of such algorithms,\nhighlighting the roles of both parallelism and recursion. Simple algebraic\nproperties of this data structure can be exploited to derive properties of\nthese algorithms and establish equivalence of different algorithms that solve\nthe same problem.\"\n  The quote above illustrates a widely shared assumption about recursion\nimplementations: either they are done in purely structural terms or they cannot\nbe done at all.\n  Multi-dimensional interpolation on a grid is one of hosts of semi-recursive\nschemes that, while often referred to as recursive and routinely described in\nvaguely recursive terms, cannot be implemented as a recursion in their\nstructural entirety.\n  This article describes a computer-implemented scheme for isolating the\nrecursive core of interpolation on a multi-grid, an arrangement that both stems\nfrom and provides a structural framework to a number of multi-dimensional\ninterpolation optimization techniques that, once implemented, provide gains in\nmulti-dimensional interpolation speed that, compared to some known benchmarks,\nmeasure in multiple orders of magnitude.\n  Categories and Subject Descriptors: Multi-dimensional Programming; Concurrent\nProgramming; Recursion\n  General terms: Parallel Processing, Prioritized Processing, Interpolation,\nRecursion, Multi-Cube\n", "versions": [{"version": "v1", "created": "Thu, 16 Jun 2011 19:28:07 GMT"}, {"version": "v10", "created": "Thu, 1 Sep 2011 17:33:33 GMT"}, {"version": "v11", "created": "Mon, 5 Sep 2011 19:29:36 GMT"}, {"version": "v12", "created": "Tue, 6 Sep 2011 19:59:01 GMT"}, {"version": "v13", "created": "Wed, 7 Sep 2011 19:47:38 GMT"}, {"version": "v14", "created": "Fri, 9 Sep 2011 12:42:29 GMT"}, {"version": "v15", "created": "Mon, 12 Sep 2011 18:08:15 GMT"}, {"version": "v16", "created": "Sat, 17 Sep 2011 10:13:56 GMT"}, {"version": "v17", "created": "Wed, 21 Sep 2011 19:56:38 GMT"}, {"version": "v18", "created": "Thu, 22 Sep 2011 19:59:32 GMT"}, {"version": "v19", "created": "Mon, 26 Sep 2011 14:42:40 GMT"}, {"version": "v2", "created": "Tue, 19 Jul 2011 14:58:49 GMT"}, {"version": "v20", "created": "Wed, 28 Sep 2011 08:14:17 GMT"}, {"version": "v21", "created": "Thu, 29 Sep 2011 14:42:50 GMT"}, {"version": "v3", "created": "Fri, 22 Jul 2011 09:51:21 GMT"}, {"version": "v4", "created": "Tue, 26 Jul 2011 15:53:05 GMT"}, {"version": "v5", "created": "Thu, 28 Jul 2011 13:11:17 GMT"}, {"version": "v6", "created": "Sun, 31 Jul 2011 13:13:08 GMT"}, {"version": "v7", "created": "Tue, 9 Aug 2011 14:22:35 GMT"}, {"version": "v8", "created": "Mon, 29 Aug 2011 19:31:03 GMT"}, {"version": "v9", "created": "Wed, 31 Aug 2011 12:34:16 GMT"}], "update_date": "2011-09-30", "authors_parsed": [["Gitlin", "Roman", ""]]}, {"id": "1106.3445", "submitter": "Matthew R. Lakin", "authors": "Matthew R. Lakin (University of Cambridge)", "title": "Constraint solving in non-permutative nominal abstract syntax", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (August 25,\n  2011) lmcs:995", "doi": "10.2168/LMCS-7(3:6)2011", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Nominal abstract syntax is a popular first-order technique for encoding, and\nreasoning about, abstract syntax involving binders. Many of its applications\ninvolve constraint solving. The most commonly used constraint solving algorithm\nover nominal abstract syntax is the Urban-Pitts-Gabbay nominal unification\nalgorithm, which is well-behaved, has a well-developed theory and is applicable\nin many cases. However, certain problems require a constraint solver which\nrespects the equivariance property of nominal logic, such as Cheney's\nequivariant unification algorithm. This is more powerful but is more\ncomplicated and computationally hard. In this paper we present a novel\nalgorithm for solving constraints over a simple variant of nominal abstract\nsyntax which we call non-permutative. This constraint problem has similar\ncomplexity to equivariant unification but without many of the additional\ncomplications of the equivariant unification term language. We prove our\nalgorithm correct, paying particular attention to issues of termination, and\npresent an explicit translation of name-name equivariant unification problems\ninto non-permutative constraints.\n", "versions": [{"version": "v1", "created": "Fri, 17 Jun 2011 11:07:51 GMT"}, {"version": "v2", "created": "Tue, 23 Aug 2011 21:03:20 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Lakin", "Matthew R.", "", "University of Cambridge"]]}, {"id": "1106.3457", "submitter": "Panos Rondogiannis", "authors": "A. Charalambidis, K. Handjopoulos, P. Rondogiannis, W. W. Wadge", "title": "Extensional Higher-Order Logic Programming", "comments": "45 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a purely extensional semantics for higher-order logic programming.\nIn this semantics program predicates denote sets of ordered tuples, and two\npredicates are equal iff they are equal as sets. Moreover, every program has a\nunique minimum Herbrand model which is the greatest lower bound of all Herbrand\nmodels of the program and the least fixed-point of an immediate consequence\noperator. We also propose an SLD-resolution proof procedure which is proven\nsound and complete with respect to the minimum model semantics. In other words,\nwe provide a purely extensional theoretical framework for higher-order logic\nprogramming which generalizes the familiar theory of classical (first-order)\nlogic programming.\n", "versions": [{"version": "v1", "created": "Fri, 17 Jun 2011 12:01:01 GMT"}], "update_date": "2011-06-20", "authors_parsed": [["Charalambidis", "A.", ""], ["Handjopoulos", "K.", ""], ["Rondogiannis", "P.", ""], ["Wadge", "W. W.", ""]]}, {"id": "1106.3478", "submitter": "Joachim Breitner", "authors": "Joachim Breitner", "title": "Conditional Elimination through Code Duplication", "comments": "11 pages, 5 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  We propose an optimizing transformation which reduces program runtime at the\nexpense of program size by eliminating conditional jumps.\n", "versions": [{"version": "v1", "created": "Wed, 15 Jun 2011 08:27:04 GMT"}], "update_date": "2011-06-20", "authors_parsed": [["Breitner", "Joachim", ""]]}, {"id": "1106.4200", "submitter": "Damien Cassou", "authors": "Damien Cassou (INRIA Bordeaux - Sud-Ouest, LaBRI), Charles Consel\n  (INRIA Bordeaux - Sud-Ouest, ENSEIRB), Emilie Balland (INRIA Bordeaux -\n  Sud-Ouest), Julia Lawall (DIKU)", "title": "Faire levier sur les architectures logicielles pour guider et v\\'erifier\n  le d\\'eveloppement d'applications SCC", "comments": null, "journal-ref": "GDR GPL'11: 3\\`eme journ\\'ees du G\\'enie de la programmation et du\n  logiciel (2011) 33--34", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A software architecture describes the structure of a computing system by\nspecifying software components and their interactions. Mapping a software\narchitecture to an implementation is a well known challenge. A key element of\nthis mapping is the architecture's description of the data and control-flow\ninteractions between components. The characterization of these interactions can\nbe rather abstract or very concrete, providing more or less implementation\nguidance, programming support, and static verification. In this paper, we\nexplore one point in the design space between abstract and concrete component\ninteraction specifications. We introduce a notion of interaction contract that\nexpresses allowed interactions between components, describing both data and\ncontrol-flow constraints. This declaration is part of the architecture\ndescription, allows generation of extensive programming support, and enables\nvarious verifications. We instantiate our approach in an architecture\ndescription language for Sense/Compute/Control applications, and describe\nassociated compilation and verification strategies.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 13:35:22 GMT"}], "update_date": "2011-06-22", "authors_parsed": [["Cassou", "Damien", "", "INRIA Bordeaux - Sud-Ouest, LaBRI"], ["Consel", "Charles", "", "INRIA Bordeaux - Sud-Ouest, ENSEIRB"], ["Balland", "Emilie", "", "INRIA Bordeaux -\n  Sud-Ouest"], ["Lawall", "Julia", "", "DIKU"]]}, {"id": "1106.6159", "submitter": "Jitesh Dundas", "authors": "Jitesh Dundas", "title": "Understanding Code Patterns - Analysis, Interpretation & Measurement", "comments": "Index Terms - code area, code patterns, efficiency, lines of code,\n  pattern recognition, software quality; http://www.ijcee.org/papers/008.pdf", "journal-ref": "International Journal of Computer and Electrical Engineering, Vol.\n  1, No. 1, April 2009", "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This research paper aims to find, analyze and understand code patterns in any\nsoftware system and measure its quality by defining standards and proposing a\nformula for the same. Every code that is written can be divided into different\ncode segments, each having its own impact on the overall system. We can analyze\nthese code segments to get the code quality. The measures used in this paper\ninclude Lines of Code, Number of calls made by a module, Execution time, the\nsystem knowledge of user and developers, the use of generalization,\ninheritance, reusability and other object-oriented concepts. The entire\nsoftware code is divided into code snippets, based on the logic that they\nimplement. Each of these code snippets has an impact. This measure is called\nImpact Factor and is valued by the software developer and/or other system\nstakeholders. Efficiency = (Code Area / Execution Time) * Qr\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2011 09:33:18 GMT"}], "update_date": "2011-07-01", "authors_parsed": [["Dundas", "Jitesh", ""]]}, {"id": "1106.6196", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "On the behaviours produced by instruction sequences under execution", "comments": "36 pages, consolidates material from arXiv:0811.0436 [cs.PL],\n  arXiv:0902.2859 [cs.PL], and arXiv:0905.2257 [cs.PL]; abstract and\n  introduction rewritten, examples and proofs added", "journal-ref": "Fundamenta Informaticae, 120(2):111--144, 2012", "doi": "10.3233/FI-2012-753", "report-no": null, "categories": "cs.PL cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study several aspects of the behaviours produced by instruction sequences\nunder execution in the setting of the algebraic theory of processes known as\nACP. We use ACP to describe the behaviours produced by instruction sequences\nunder execution and to describe two protocols implementing these behaviours in\nthe case where the processing of instructions takes place remotely. We also\nshow that all finite-state behaviours considered in ACP can be produced by\ninstruction sequences under execution.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2011 11:51:25 GMT"}, {"version": "v2", "created": "Mon, 11 Jun 2012 07:11:09 GMT"}], "update_date": "2012-12-05", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}]