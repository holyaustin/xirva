[{"id": "1508.00455", "submitter": "EPTCS", "authors": "Cyprien Mangin (Univ Paris Diderot & \\'Ecole Polytechnique), Matthieu\n  Sozeau (Inria Paris & PPS, Univ Paris Diderot)", "title": "Equations for Hereditary Substitution in Leivant's Predicative System F:\n  A Case Study", "comments": "In Proceedings LFMTP 2015, arXiv:1507.07597. www:\n  http://equations-fpred.gforge.inria.fr/", "journal-ref": "EPTCS 185, 2015, pp. 71-86", "doi": "10.4204/EPTCS.185.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a case study of formalizing a normalization proof for\nLeivant's Predicative System F using the Equations package. Leivant's\nPredicative System F is a stratified version of System F, where type\nquantification is annotated with kinds representing universe levels. A weaker\nvariant of this system was studied by Stump & Eades, employing the hereditary\nsubstitution method to show normalization. We improve on this result by showing\nnormalization for Leivant's original system using hereditary substitutions and\na novel multiset ordering on types. Our development is done in the Coq proof\nassistant using the Equations package, which provides an interface to define\ndependently-typed programs with well-founded recursion and full dependent\npattern- matching. Equations allows us to define explicitly the hereditary\nsubstitution function, clarifying its algorithmic behavior in presence of term\nand type substitutions. From this definition, consistency can easily be\nderived. The algorithmic nature of our development is crucial to reflect\nlanguages with type quantification, enlarging the class of languages on which\nreflection methods can be used in the proof assistant.\n", "versions": [{"version": "v1", "created": "Wed, 29 Jul 2015 08:21:28 GMT"}], "update_date": "2015-08-04", "authors_parsed": [["Mangin", "Cyprien", "", "Univ Paris Diderot & \u00c9cole Polytechnique"], ["Sozeau", "Matthieu", "", "Inria Paris & PPS, Univ Paris Diderot"]]}, {"id": "1508.00628", "submitter": "Cristina Lopes", "authors": "Cristina V. Lopes and Joel Ossher", "title": "How Scale Affects Structure in Java Programs", "comments": "ACM Conference on Object-Oriented Programming, Systems, Languages and\n  Applications (OOPSLA), October 2015. (Preprint)", "journal-ref": null, "doi": "10.1145/2858965.2814300", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many internal software metrics and external quality attributes of Java\nprograms correlate strongly with program size. This knowledge has been used\npervasively in quantitative studies of software through practices such as\nnormalization on size metrics. This paper reports size-related super- and\nsublinear effects that have not been known before. Findings obtained on a very\nlarge collection of Java programs -- 30,911 projects hosted at Google Code as\nof Summer 2011 -- unveils how certain characteristics of programs vary\ndisproportionately with program size, sometimes even non-monotonically. Many of\nthe specific parameters of nonlinear relations are reported. This result gives\nfurther insights for the differences of \"programming in the small\" vs.\n\"programming in the large.\" The reported findings carry important consequences\nfor OO software metrics, and software research in general: metrics that have\nbeen known to correlate with size can now be properly normalized so that all\nthe information that is left in them is size-independent.\n", "versions": [{"version": "v1", "created": "Tue, 4 Aug 2015 00:24:25 GMT"}], "update_date": "2015-12-23", "authors_parsed": [["Lopes", "Cristina V.", ""], ["Ossher", "Joel", ""]]}, {"id": "1508.01288", "submitter": "Anvesh Komuravelli", "authors": "Anvesh Komuravelli, Nikolaj Bjorner, Arie Gurfinkel, Kenneth L.\n  McMillan", "title": "Compositional Verification of Procedural Programs using Horn Clauses\n  over Integers and Arrays", "comments": "8 pages, FMCAD 2015", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a compositional SMT-based algorithm for safety of procedural C\nprograms that takes the heap into consideration as well. Existing SMT-based\napproaches are either largely restricted to handling linear arithmetic\noperations and properties, or are non-compositional. We use Constrained Horn\nClauses (CHCs) to represent the verification conditions where the memory\noperations are modeled using the extensional theory of arrays (ARR). First, we\ndescribe an exponential time quantifier elimination (QE) algorithm for ARR\nwhich can introduce new quantifiers of the index and value sorts. Second, we\nadapt the QE algorithm to efficiently obtain under-approximations using models,\nresulting in a polynomial time Model Based Projection (MBP) algorithm. Third,\nwe integrate the MBP algorithm into the framework of compositional reasoning of\nprocedural programs using may and must summaries recently proposed by us. Our\nsolutions to the CHCs are currently restricted to quantifier-free formulas.\nFinally, we describe our practical experience over SV-COMP'15 benchmarks using\nan implementation in the tool SPACER.\n", "versions": [{"version": "v1", "created": "Thu, 6 Aug 2015 06:27:27 GMT"}], "update_date": "2015-08-07", "authors_parsed": [["Komuravelli", "Anvesh", ""], ["Bjorner", "Nikolaj", ""], ["Gurfinkel", "Arie", ""], ["McMillan", "Kenneth L.", ""]]}, {"id": "1508.03263", "submitter": "Keehang Kwon", "authors": "Keehang Kwon", "title": "Logic Programming with Macro Connectives", "comments": "6 pages, some new connectives are added to version 3", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logic programming such as Prolog is often sequential and slow because each\nexecution step processes only a single, $micro$ connective. To fix this\nproblem, we propose to use $macro$ connectives as the means of improving both\nreadability and performance.\n", "versions": [{"version": "v1", "created": "Thu, 13 Aug 2015 16:34:22 GMT"}, {"version": "v2", "created": "Tue, 21 Jun 2016 01:18:02 GMT"}, {"version": "v3", "created": "Sun, 2 Jul 2017 09:35:05 GMT"}, {"version": "v4", "created": "Mon, 7 May 2018 10:45:07 GMT"}], "update_date": "2018-05-08", "authors_parsed": [["Kwon", "Keehang", ""]]}, {"id": "1508.03388", "submitter": "EPTCS", "authors": "Catherine Dubois (ENSIIE), Paolo Masci (Queen Mary University of\n  London), Dominique M\\'ery (LORIA, Universit\\'e de Lorraine)", "title": "Proceedings Second International Workshop on Formal Integrated\n  Development Environment", "comments": null, "journal-ref": "EPTCS 187, 2015", "doi": "10.4204/EPTCS.187", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of F-IDE 2015, the second international\nworkshop on Formal Integrated Development Environment, which was held as an FM\n2015 satellite event, on June 22, 2015, in Oslo (Norway). High levels of\nsafety, security and also privacy standards require the use of formal methods\nto specify and develop compliant software (sub)systems. Any standard comes with\nan assessment process, which requires a complete documentation of the\napplication in order to ease the justification of design choices and the review\nof code and proofs. Thus tools are needed for handling specifications, program\nconstructs and verification artifacts. The aim of the F-IDE workshop is to\nprovide a forum for presenting and discussing research efforts as well as\nexperience returns on design, development and usage of formal IDE aiming at\nmaking formal methods \"easier\" for both specialists and non-specialists.\n", "versions": [{"version": "v1", "created": "Fri, 14 Aug 2015 00:14:35 GMT"}], "update_date": "2015-08-17", "authors_parsed": [["Dubois", "Catherine", "", "ENSIIE"], ["Masci", "Paolo", "", "Queen Mary University of\n  London"], ["M\u00e9ry", "Dominique", "", "LORIA, Universit\u00e9 de Lorraine"]]}, {"id": "1508.03389", "submitter": "EPTCS", "authors": "Maurice H. ter Beek (ISTI-CNR, Pisa, Italy), Alberto Lluch Lafuente\n  (DTU, Denmark)", "title": "Proceedings 11th International Workshop on Automated Specification and\n  Verification of Web Systems", "comments": null, "journal-ref": "EPTCS 188, 2015", "doi": "10.4204/EPTCS.188", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  These proceedings contain the papers presented at the 11th International\nWorkshop on Automated Specification and Verification of Web Systems (WWV 2015),\nwhich was held on 23 June 2015 in Oslo, Norway, as a satellite workshop of the\n20th International Symposium on Formal Methods (FM 2015). WWV is a yearly\ninterdisciplinary forum for researchers originating from the following areas:\ndeclarative, rule-based programming, formal methods, software engineering and\nweb-based systems. The workshop fosters the cross-fertilisation and advancement\nof hybrid methods from such areas.\n", "versions": [{"version": "v1", "created": "Fri, 14 Aug 2015 00:21:41 GMT"}], "update_date": "2015-08-17", "authors_parsed": [["ter Beek", "Maurice H.", "", "ISTI-CNR, Pisa, Italy"], ["Lafuente", "Alberto Lluch", "", "DTU, Denmark"]]}, {"id": "1508.03536", "submitter": "Tijs Van Der Storm", "authors": "Tijs van der Storm, Sebastian Erdweg", "title": "Proceedings of the 3rd Workshop on Domain-Specific Language Design and\n  Implementation (DSLDI 2015)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The goal of the DSLDI workshop is to bring together researchers and\npractitioners interested in sharing ideas on how DSLs should be designed,\nimplemented, supported by tools, and applied in realistic application contexts.\nWe are both interested in discovering how already known domains such as graph\nprocessing or machine learning can be best supported by DSLs, but also in\nexploring new domains that could be targeted by DSLs. More generally, we are\ninterested in building a community that can drive forward the development of\nmodern DSLs. These informal post-proceedings contain the submitted talk\nabstracts to the 3rd DSLDI workshop (DSLDI'15), and a summary of the panel\ndiscussion on Language Composition.\n", "versions": [{"version": "v1", "created": "Fri, 14 Aug 2015 15:05:14 GMT"}], "update_date": "2015-08-17", "authors_parsed": [["van der Storm", "Tijs", ""], ["Erdweg", "Sebastian", ""]]}, {"id": "1508.03837", "submitter": "Keehang Kwon", "authors": "Keehang Kwon", "title": "Incorporating User Interaction into Imperative Languages", "comments": "6 pages. arXiv admin note: text overlap with arXiv:1709.08193", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present two new forms of the $write$ statement: one of the\nform $write(x);G$ where $G$ is a statement and the other of the form\n$write(x);D$ where $D$ is a module. The former is a generalization of\ntraditional $write$ statement and is quite useful. The latter is useful for\nimplementing interactive modules.\n", "versions": [{"version": "v1", "created": "Sun, 16 Aug 2015 15:36:30 GMT"}, {"version": "v2", "created": "Wed, 24 Jan 2018 05:13:48 GMT"}], "update_date": "2018-01-26", "authors_parsed": [["Kwon", "Keehang", ""]]}, {"id": "1508.03892", "submitter": "EPTCS", "authors": "Dipak L. Chaudhari, Om Damani", "title": "Building an IDE for the Calculational Derivation of Imperative Programs", "comments": "In Proceedings F-IDE 2015, arXiv:1508.03388", "journal-ref": "EPTCS 187, 2015, pp. 1-13", "doi": "10.4204/EPTCS.187.1", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we describe an IDE called CAPS (Calculational Assistant for\nProgramming from Specifications) for the interactive, calculational derivation\nof imperative programs. In building CAPS, our aim has been to make the IDE\naccessible to non-experts while retaining the overall flavor of the\npen-and-paper calculational style. We discuss the overall architecture of the\nCAPS system, the main features of the IDE, the GUI design, and the trade-offs\ninvolved.\n", "versions": [{"version": "v1", "created": "Mon, 17 Aug 2015 01:36:36 GMT"}], "update_date": "2015-08-20", "authors_parsed": [["Chaudhari", "Dipak L.", ""], ["Damani", "Om", ""]]}, {"id": "1508.03896", "submitter": "EPTCS", "authors": "Nabil M. Kabbani (Clemson University), Daniel Welch (Clemson\n  University), Caleb Priester (Clemson University), Stephen Schaub (Clemson\n  University), Blair Durkee (Clemson University), Yu-Shan Sun (Clemson\n  University), Murali Sitaraman (Clemson University)", "title": "Formal Reasoning Using an Iterative Approach with an Integrated Web IDE", "comments": "In Proceedings F-IDE 2015, arXiv:1508.03388", "journal-ref": "EPTCS 187, 2015, pp. 56-71", "doi": "10.4204/EPTCS.187.5", "report-no": null, "categories": "cs.SE cs.HC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper summarizes our experience in communicating the elements of\nreasoning about correctness, and the central role of formal specifications in\nreasoning about modular, component-based software using a language and an\nintegrated Web IDE designed for the purpose. Our experience in using such an\nIDE, supported by a 'push-button' verifying compiler in a classroom setting,\nreveals the highly iterative process learners use to arrive at suitably\nspecified, automatically provable code. We explain how the IDE facilitates\nreasoning at each step of this process by providing human readable verification\nconditions (VCs) and feedback from an integrated prover that clearly indicates\nunprovable VCs to help identify obstacles to completing proofs. The paper\ndiscusses the IDE's usage in verified software development using several\nexamples drawn from actual classroom lectures and student assignments to\nillustrate principles of design-by-contract and the iterative process of\ncreating and subsequently refining assertions, such as loop invariants in\nobject-based code.\n", "versions": [{"version": "v1", "created": "Mon, 17 Aug 2015 01:37:08 GMT"}], "update_date": "2015-08-20", "authors_parsed": [["Kabbani", "Nabil M.", "", "Clemson University"], ["Welch", "Daniel", "", "Clemson\n  University"], ["Priester", "Caleb", "", "Clemson University"], ["Schaub", "Stephen", "", "Clemson\n  University"], ["Durkee", "Blair", "", "Clemson University"], ["Sun", "Yu-Shan", "", "Clemson\n  University"], ["Sitaraman", "Murali", "", "Clemson University"]]}, {"id": "1508.03901", "submitter": "EPTCS", "authors": "Adrian Francalanza (CS, ICT, University of Malta), Marco Giunti\n  (RELEASE, DI, Universidade da Beira Interior & NOVA LINCS, DI-FCT,\n  Universidade NOVA de Lisboa), Ant\\'onio Ravara (NOVA LINCS, DI-FCT,\n  Universidade NOVA de Lisboa)", "title": "Unlocking Blocked Communicating Processes", "comments": "In Proceedings WWV 2015, arXiv:1508.03389", "journal-ref": "EPTCS 188, 2015, pp. 23-32", "doi": "10.4204/EPTCS.188.4", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the problem of disentangling locked processes via code refactoring.\nWe identify and characterise a class of processes that is not lock-free; then\nwe formalise an algorithm that statically detects potential locks and propose\nrefactoring procedures that disentangle detected locks. Our development is cast\nwithin a simple setting of a finite linear CCS variant \\^a although it suffices\nto illustrate the main concepts, we also discuss how our work extends to other\nlanguage extensions.\n", "versions": [{"version": "v1", "created": "Mon, 17 Aug 2015 01:51:02 GMT"}], "update_date": "2016-08-08", "authors_parsed": [["Francalanza", "Adrian", "", "CS, ICT, University of Malta"], ["Giunti", "Marco", "", "RELEASE, DI, Universidade da Beira Interior & NOVA LINCS, DI-FCT,\n  Universidade NOVA de Lisboa"], ["Ravara", "Ant\u00f3nio", "", "NOVA LINCS, DI-FCT,\n  Universidade NOVA de Lisboa"]]}, {"id": "1508.03905", "submitter": "EPTCS", "authors": "Hai-Feng Guo (University of Nebraska at Omaha), Qing Ouyang\n  (University of Nebraska at Omaha), Harvey Siy (University of Nebraska at\n  Omaha)", "title": "Semantics-based Automated Web Testing", "comments": "In Proceedings WWV 2015, arXiv:1508.03389", "journal-ref": "EPTCS 188, 2015, pp. 59-74", "doi": "10.4204/EPTCS.188.7", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present TAO, a software testing tool performing automated test and oracle\ngeneration based on a semantic approach. TAO entangles grammar-based test\ngeneration with automated semantics evaluation using a denotational semantics\nframework. We show how TAO can be incorporated with the Selenium automation\ntool for automated web testing, and how TAO can be further extended to support\nautomated delta debugging, where a failing web test script can be\nsystematically reduced based on grammar-directed strategies. A real-life\nparking website is adopted throughout the paper to demonstrate the effectivity\nof our semantics-based web testing approach.\n", "versions": [{"version": "v1", "created": "Mon, 17 Aug 2015 01:51:35 GMT"}], "update_date": "2015-08-18", "authors_parsed": [["Guo", "Hai-Feng", "", "University of Nebraska at Omaha"], ["Ouyang", "Qing", "", "University of Nebraska at Omaha"], ["Siy", "Harvey", "", "University of Nebraska at\n  Omaha"]]}, {"id": "1508.04159", "submitter": "Andr\\'e Dietrich", "authors": "Andr\\'e Dietrich, Sebastian Zug, Luigi Nardi, J\\\"org Kaiser", "title": "Reasoning in complex environments with the SelectScript declarative\n  language", "comments": "15 pages, 7 figures, 6th International Workshop on Domain-Specific\n  Languages and models for ROBotic systems (DSLRob-15)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI cs.DB cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  SelectScript is an extendable, adaptable, and declarative domain-specific\nlanguage aimed at information retrieval from simulation environments and\nrobotic world models in an SQL-like manner. In this work we have extended the\nlanguage in two directions. First, we have implemented hierarchical queries;\nsecond, we improve efficiency enabling manual design space exploration on\ndifferent \"search\" strategies. We demonstrate the applicability of such\nextensions in two application problems; the basic language concepts are\nexplained by solving the classical problem of the Towers of Hanoi and then a\ncommon path planning problem in a complex 3D environment is implemented.\n", "versions": [{"version": "v1", "created": "Mon, 17 Aug 2015 21:26:39 GMT"}, {"version": "v2", "created": "Sun, 4 Oct 2015 15:53:29 GMT"}], "update_date": "2015-10-06", "authors_parsed": [["Dietrich", "Andr\u00e9", ""], ["Zug", "Sebastian", ""], ["Nardi", "Luigi", ""], ["Kaiser", "J\u00f6rg", ""]]}, {"id": "1508.04595", "submitter": "EPTCS", "authors": "Sophia Knight (CNRS, LORIA, Universit\\'e de Lorraine, France), Ivan\n  Lanese (University of Bologna/INRIA, Italy), Alberto Lluch Lafuente\n  (Technical University of Denmark, Denmark), Hugo Torres Vieira (IMT Institute\n  for Advanced Studies Lucca, Italy)", "title": "Proceedings 8th Interaction and Concurrency Experience", "comments": null, "journal-ref": "EPTCS 189, 2015", "doi": "10.4204/EPTCS.189", "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of ICE 2015, the 8th Interaction and\nConcurrency Experience, which was held in Grenoble, France on the 4th and 5th\nof June 2015 as a satellite event of DisCoTec 2015. The ICE procedure for paper\nselection allows PC members to interact, anonymously, with authors. During the\nreview phase, each submitted paper is published on a discussion forum with\naccess restricted to the authors and to all the PC members not declaring a\nconflict of interest. The PC members post comments and questions to which the\nauthors reply. Each paper was reviewed by three PC members, and altogether 9\npapers, including 1 short paper, were accepted for publication (the workshop\nalso featured 4 brief announcements which are not part of this volume). We were\nproud to host three invited talks, by Leslie Lamport (shared with the FRIDA\nworkshop), Joseph Sifakis and Steve Ross-Talbot. The abstracts of the last two\ntalks are included in this volume together with the regular papers.\n", "versions": [{"version": "v1", "created": "Wed, 19 Aug 2015 10:58:39 GMT"}], "update_date": "2015-08-20", "authors_parsed": [["Knight", "Sophia", "", "CNRS, LORIA, Universit\u00e9 de Lorraine, France"], ["Lanese", "Ivan", "", "University of Bologna/INRIA, Italy"], ["Lafuente", "Alberto Lluch", "", "Technical University of Denmark, Denmark"], ["Vieira", "Hugo Torres", "", "IMT Institute\n  for Advanced Studies Lucca, Italy"]]}, {"id": "1508.04627", "submitter": "Bhargava Shastry", "authors": "Bhargava Shastry, Fabian Yamaguchi, Konrad Rieck, and Jean-Pierre\n  Seifert", "title": "Towards Vulnerability Discovery Using Staged Program Analysis", "comments": "A revised version to appear in the proceedings of the 13th conference\n  on Detection of Intrusions and Malware & Vulnerability Assessment (DIMVA),\n  July 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Eliminating vulnerabilities from low-level code is vital for securing\nsoftware. Static analysis is a promising approach for discovering\nvulnerabilities since it can provide developers early feedback on the code they\nwrite. But, it presents multiple challenges not the least of which is\nunderstanding what makes a bug exploitable and conveying this information to\nthe developer. In this paper, we present the design and implementation of a\npractical vulnerability assessment framework, called Melange. Melange performs\ndata and control flow analysis to diagnose potential security bugs, and outputs\nwell-formatted bug reports that help developers understand and fix security\nbugs. Based on the intuition that real-world vulnerabilities manifest\nthemselves across multiple parts of a program, Melange performs both local and\nglobal analyses. To scale up to large programs, global analysis is\ndemand-driven. Our prototype detects multiple vulnerability classes in C and\nC++ code including type confusion, and garbage memory reads. We have evaluated\nMelange extensively. Our case studies show that Melange scales up to large\ncodebases such as Chromium, is easy-to-use, and most importantly, capable of\ndiscovering vulnerabilities in real-world code. Our findings indicate that\nstatic analysis is a viable reinforcement to the software testing tool set.\n", "versions": [{"version": "v1", "created": "Wed, 19 Aug 2015 13:00:56 GMT"}, {"version": "v2", "created": "Wed, 6 Apr 2016 18:38:03 GMT"}], "update_date": "2016-04-07", "authors_parsed": [["Shastry", "Bhargava", ""], ["Yamaguchi", "Fabian", ""], ["Rieck", "Konrad", ""], ["Seifert", "Jean-Pierre", ""]]}, {"id": "1508.04753", "submitter": "Gerhard Dueck", "authors": "Kim T. Briggs, Baoguo Zhou, Gerhard W. Dueck", "title": "Cold Object Identification in the Java Virtual Machine", "comments": "For submission to `Software: Practice and Experience'", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many Java applications instantiate objects within the Java heap that are\npersistent but seldom if ever referenced by the application. Examples include\nstrings, such as error messages, and collections of value objects that are\npreloaded for fast access but they may include objects that are seldom\nreferenced. This paper describes a stack-based framework for detecting these\n\"cold\" objects at runtime, with a view to marshaling and sequestering them in\ndesignated regions of the heap where they may be preferentially paged out to a\nbacking store, thereby freeing physical memory pages for occupation by more\nactive objects. Furthermore, we evaluate the correctness and efficiency of\nstack-based approach with an Access Barrier. The experimental results from a\nseries of SPECjvm2008 benchmarks are presented.\n", "versions": [{"version": "v1", "created": "Tue, 18 Aug 2015 19:50:17 GMT"}], "update_date": "2015-08-20", "authors_parsed": [["Briggs", "Kim T.", ""], ["Zhou", "Baoguo", ""], ["Dueck", "Gerhard W.", ""]]}, {"id": "1508.04848", "submitter": "EPTCS", "authors": "Kasper Dokter (CWI), Sung-Shik Jongmans (CWI), Farhad Arbab (CWI),\n  Simon Bliudze (EPFL)", "title": "Relating BIP and Reo", "comments": "In Proceedings ICE 2015, arXiv:1508.04595", "journal-ref": "EPTCS 189, 2015, pp. 3-20", "doi": "10.4204/EPTCS.189.3", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Coordination languages simplify design and development of concurrent systems.\nParticularly, exogenous coordination languages, like BIP and Reo, enable system\ndesigners to express the interactions among components in a system explicitly.\nIn this paper we establish a formal relation between BI(P) (i.e., BIP without\nthe priority layer) and Reo, by defining transformations between their semantic\nmodels. We show that these transformations preserve all properties expressible\nin a common semantics. This formal relation comprises the basis for a solid\ncomparison and consolidation of the fundamental coordination concepts behind\nthese two languages. Moreover, this basis offers translations that enable users\nof either language to benefit from the toolchains of the other.\n", "versions": [{"version": "v1", "created": "Thu, 20 Aug 2015 01:40:23 GMT"}], "update_date": "2015-08-21", "authors_parsed": [["Dokter", "Kasper", "", "CWI"], ["Jongmans", "Sung-Shik", "", "CWI"], ["Arbab", "Farhad", "", "CWI"], ["Bliudze", "Simon", "", "EPFL"]]}, {"id": "1508.04853", "submitter": "EPTCS", "authors": "Alceste Scalas (Universit\\`a di Cagliari, Italy and Imperial College\n  London, UK), Massimo Bartoletti (Universit\\`a di Cagliari, Italy)", "title": "The LTS WorkBench", "comments": "In Proceedings ICE 2015, arXiv:1508.04595", "journal-ref": "EPTCS 189, 2015, pp. 86-98", "doi": "10.4204/EPTCS.189.8", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Labelled Transition Systems (LTSs) are a fundamental semantic model in many\nareas of informatics, especially concurrency theory. Yet, reasoning on LTSs and\nrelations between their states can be difficult and elusive: very simple\nprocess algebra terms can give rise to a large (possibly infinite) number of\nintricate transitions and interactions. To ease this kind of study, we present\nLTSwb, a flexible and extensible LTS toolbox: this tutorial paper discusses its\ndesign and functionalities.\n", "versions": [{"version": "v1", "created": "Thu, 20 Aug 2015 01:41:07 GMT"}], "update_date": "2015-08-21", "authors_parsed": [["Scalas", "Alceste", "", "Universit\u00e0 di Cagliari, Italy and Imperial College\n  London, UK"], ["Bartoletti", "Massimo", "", "Universit\u00e0 di Cagliari, Italy"]]}, {"id": "1508.04856", "submitter": "EPTCS", "authors": "C\\'esar Santos (Lasige, Faculty of Sciences, University of Lisbon,\n  Portugal), Francisco Martins (Lasige, Faculty of Sciences, University of\n  Lisbon, Portugal), Vasco Thudichum Vasconcelos (Lasige, Faculty of Sciences,\n  University of Lisbon, Portugal)", "title": "Deductive Verification of Parallel Programs Using Why3", "comments": "In Proceedings ICE 2015, arXiv:1508.04595", "journal-ref": "EPTCS 189, 2015, pp. 128-142", "doi": "10.4204/EPTCS.189.11", "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Message Passing Interface specification (MPI) defines a portable\nmessage-passing API used to program parallel computers. MPI programs manifest a\nnumber of challenges on what concerns correctness: sent and expected values in\ncommunications may not match, resulting in incorrect computations possibly\nleading to crashes; and programs may deadlock resulting in wasted resources.\nExisting tools are not completely satisfactory: model-checking does not scale\nwith the number of processes; testing techniques wastes resources and are\nhighly dependent on the quality of the test set.\n  As an alternative, we present a prototype for a type-based approach to\nprogramming and verifying MPI like programs against protocols. Protocols are\nwritten in a dependent type language designed so as to capture the most common\nprimitives in MPI, incorporating, in addition, a form of primitive recursion\nand collective choice. Protocols are then translated into Why3, a deductive\nsoftware verification tool. Source code, in turn, is written in WhyML, the\nlanguage of the Why3 platform, and checked against the protocol. Programs that\npass verification are guaranteed to be communication safe and free from\ndeadlocks.\n  We verified several parallel programs from textbooks using our approach, and\nreport on the outcome.\n", "versions": [{"version": "v1", "created": "Thu, 20 Aug 2015 01:43:19 GMT"}], "update_date": "2015-08-21", "authors_parsed": [["Santos", "C\u00e9sar", "", "Lasige, Faculty of Sciences, University of Lisbon,\n  Portugal"], ["Martins", "Francisco", "", "Lasige, Faculty of Sciences, University of\n  Lisbon, Portugal"], ["Vasconcelos", "Vasco Thudichum", "", "Lasige, Faculty of Sciences,\n  University of Lisbon, Portugal"]]}, {"id": "1508.04958", "submitter": "Moritz Sinn", "authors": "Moritz Sinn, Florian Zuleger, Helmut Veith", "title": "Difference Constraints: An adequate Abstraction for Complexity Analysis\n  of Imperative Programs", "comments": "This is the extended version of our paper published at FMCAD 2015", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Difference constraints have been used for termination analysis in the\nliterature, where they denote relational inequalities of the form x' <= y + c,\nand describe that the value of x in the current state is at most the value of y\nin the previous state plus some integer constant c. In this paper, we argue\nthat the complexity of imperative programs typically arises from counter\nincrements and resets, which can be modeled naturally by difference\nconstraints. We present the first practical algorithm for the analysis of\ndifference constraint programs and describe how C programs can be abstracted to\ndifference constraint programs. Our approach contributes to the field of\nautomated complexity and (resource) bound analysis by enabling automated\namortized complexity analysis for a new class of programs and providing a\nconceptually simple program model that relates invariant- and bound analysis.\nWe demonstrate the effectiveness of our approach through a thorough\nexperimental comparison on real world C code: our tool Loopus computes the\ncomplexity for considerably more functions in less time than related tools from\nthe literature.\n", "versions": [{"version": "v1", "created": "Thu, 20 Aug 2015 11:32:47 GMT"}], "update_date": "2015-08-21", "authors_parsed": [["Sinn", "Moritz", ""], ["Zuleger", "Florian", ""], ["Veith", "Helmut", ""]]}, {"id": "1508.06320", "submitter": "Frank Hannig", "authors": "Frank Hannig, Dirk Koch, Daniel Ziener", "title": "Proceedings of the Second International Workshop on FPGAs for Software\n  Programmers (FSP 2015)", "comments": "Website of the workshop: https://www12.cs.fau.de/ws/fsp2015/", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AR cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the papers accepted at the Second International Workshop\non FPGAs for Software Programmers (FSP 2015), held in London, United Kingdom,\nSeptember 1st, 2015. FSP 2015 was co-located with the International Conference\non Field Programmable Logic and Applications (FPL).\n", "versions": [{"version": "v1", "created": "Tue, 25 Aug 2015 22:17:22 GMT"}], "update_date": "2015-08-27", "authors_parsed": [["Hannig", "Frank", ""], ["Koch", "Dirk", ""], ["Ziener", "Daniel", ""]]}, {"id": "1508.06526", "submitter": "Keehang Kwon", "authors": "Keehang Kwon", "title": "A Logical Approach to Event Handling in Imperative Languages", "comments": "6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While event handling is a key element in modern interactive programming, it\nis unfortunate that its theoretical foundation is rather weak. To solve this\nproblem, we propose to adopt a game-logical approach of computability logic\n\\cite{Jap08} to event handling.\n", "versions": [{"version": "v1", "created": "Wed, 26 Aug 2015 15:09:33 GMT"}], "update_date": "2015-08-27", "authors_parsed": [["Kwon", "Keehang", ""]]}, {"id": "1508.06707", "submitter": "EPTCS", "authors": "Ornela Dardha (University of Glasgow, United Kingdom), Jorge A.\n  P\\'erez (University of Groningen, The Netherlands)", "title": "Comparing Deadlock-Free Session Typed Processes", "comments": "In Proceedings EXPRESS/SOS 2015, arXiv:1508.06347", "journal-ref": "EPTCS 190, 2015, pp. 1-15", "doi": "10.4204/EPTCS.190.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Besides respecting prescribed protocols, communication-centric systems should\nnever \"get stuck\". This requirement has been expressed by liveness properties\nsuch as progress or (dead)lock freedom. Several typing disciplines that ensure\nthese properties for mobile processes have been proposed. Unfortunately, very\nlittle is known about the precise relationship between these disciplines--and\nthe classes of typed processes they induce.\n  In this paper, we compare L and K, two classes of deadlock-free, session\ntyped concurrent processes. The class L stands out for its canonicity: it\nresults naturally from interpretations of linear logic propositions as session\ntypes. The class K, obtained by encoding session types into Kobayashi's usage\ntypes, includes processes not typable in other type systems.\n  We show that L is strictly included in K. We also identify the precise\ncondition under which L and K coincide. One key observation is that the degree\nof sharing between parallel processes determines a new expressiveness hierarchy\nfor typed processes. We also provide a type-preserving rewriting procedure of\nprocesses in K into processes in L. This procedure suggests that, while\neffective, the degree of sharing is a rather subtle criteria for distinguishing\ntyped processes.\n", "versions": [{"version": "v1", "created": "Thu, 27 Aug 2015 03:21:08 GMT"}], "update_date": "2015-08-28", "authors_parsed": [["Dardha", "Ornela", "", "University of Glasgow, United Kingdom"], ["P\u00e9rez", "Jorge A.", "", "University of Groningen, The Netherlands"]]}, {"id": "1508.06709", "submitter": "EPTCS", "authors": "Jovana Dedei\\'c (University of Novi Sad, Serbia), Jovanka Pantovi\\'c\n  (University of Novi Sad, Serbia), Jorge A. P\\'erez (University of Groningen,\n  The Netherlands)", "title": "On Compensation Primitives as Adaptable Processes", "comments": "In Proceedings EXPRESS/SOS 2015, arXiv:1508.06347", "journal-ref": "EPTCS 190, 2015, pp. 16-30", "doi": "10.4204/EPTCS.190.2", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We compare mechanisms for compensation handling and dynamic update in calculi\nfor concurrency. These mechanisms are increasingly relevant in the\nspecification of reliable communicating systems. Compensations and updates are\nintuitively similar: both specify how the behavior of a concurrent system\nchanges at runtime in response to an exceptional event. However, calculi with\ncompensations and updates are technically quite different. We investigate the\nrelative expressiveness of these calculi: we develop encodings of core process\nlanguages with compensations into a calculus of adaptable processes developed\nin prior work. Our encodings shed light on the (intricate) semantics of\ncompensation handling and its key constructs. They also enable the transference\nof existing verification and reasoning techniques for adaptable processes to\ncore languages with compensation handling.\n", "versions": [{"version": "v1", "created": "Thu, 27 Aug 2015 03:21:16 GMT"}], "update_date": "2015-08-28", "authors_parsed": [["Dedei\u0107", "Jovana", "", "University of Novi Sad, Serbia"], ["Pantovi\u0107", "Jovanka", "", "University of Novi Sad, Serbia"], ["P\u00e9rez", "Jorge A.", "", "University of Groningen,\n  The Netherlands"]]}, {"id": "1508.06710", "submitter": "EPTCS", "authors": "Pedro R. D'Argenio (FaMAF, Universidad Nacional de C\\'ordoba -\n  CONICET), Matias David Lee (FaMAF, Universidad Nacional de C\\'ordoba -\n  CONICET), Daniel Gebler (Department of Computer Science, VU University\n  Amsterdam)", "title": "SOS rule formats for convex and abstract probabilistic bisimulations", "comments": "In Proceedings EXPRESS/SOS 2015, arXiv:1508.06347", "journal-ref": "EPTCS 190, 2015, pp. 31-45", "doi": "10.4204/EPTCS.190.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Probabilistic transition system specifications (PTSSs) in the $nt \\mu f\\theta\n/ nt\\mu x\\theta$ format provide structural operational semantics for\nSegala-type systems that exhibit both probabilistic and nondeterministic\nbehavior and guarantee that bisimilarity is a congruence for all operator\ndefined in such format. Starting from the $nt \\mu f\\theta / nt\\mu x\\theta$\nformat, we obtain restricted formats that guarantee that three coarser\nbisimulation equivalences are congruences. We focus on (i) Segala's variant of\nbisimulation that considers combined transitions, which we call here \"convex\nbisimulation\"; (ii) the bisimulation equivalence resulting from considering\nPark & Milner's bisimulation on the usual stripped probabilistic transition\nsystem (translated into a labelled transition system), which we call here\n\"probability obliterated bisimulation\"; and (iii) a \"probability abstracted\nbisimulation\", which, like bisimulation, preserves the structure of the\ndistributions but instead, it ignores the probability values. In addition, we\ncompare these bisimulation equivalences and provide a logic characterization\nfor each of them.\n", "versions": [{"version": "v1", "created": "Thu, 27 Aug 2015 03:21:26 GMT"}], "update_date": "2015-08-28", "authors_parsed": [["D'Argenio", "Pedro R.", "", "FaMAF, Universidad Nacional de C\u00f3rdoba -\n  CONICET"], ["Lee", "Matias David", "", "FaMAF, Universidad Nacional de C\u00f3rdoba -\n  CONICET"], ["Gebler", "Daniel", "", "Department of Computer Science, VU University\n  Amsterdam"]]}, {"id": "1508.06791", "submitter": "James Clarkson", "authors": "James Clarkson and Christos Kotselidis and Gavin Brown and Mikel\n  Luj\\'an", "title": "Boosting Java Performance using GPGPUs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Heterogeneous programming has started becoming the norm in order to achieve\nbetter performance by running portions of code on the most appropriate hardware\nresource. Currently, significant engineering efforts are undertaken in order to\nenable existing programming languages to perform heterogeneous execution mainly\non GPUs. In this paper we describe Jacc, an experimental framework which allows\ndevelopers to program GPGPUs directly from Java. By using the Jacc framework,\ndevelopers have the ability to add GPGPU support into their applications with\nminimal code refactoring.\n  To simplify the development of GPGPU applications we allow developers to\nmodel heterogeneous code using two key abstractions: \\textit{tasks}, which\nencapsulate all the information needed to execute code on a GPGPU; and\n\\textit{task graphs}, which capture the inter-task control-flow of the\napplication. Using this information the Jacc runtime is able to automatically\nhandle data movement and synchronization between the host and the GPGPU;\neliminating the need for explicitly managing disparate memory spaces.\n  In order to generate highly parallel GPGPU code, Jacc provides developers\nwith the ability to decorate key aspects of their code using annotations. The\ncompiler, in turn, exploits this information in order to automatically generate\ncode without requiring additional code refactoring.\n  Finally, we demonstrate the advantages of Jacc, both in terms of\nprogrammability and performance, by evaluating it against existing Java\nframeworks. Experimental results show an average performance speedup of 32x and\na 4.4x code decrease across eight evaluated benchmarks on a NVIDIA Tesla K20m\nGPU.\n", "versions": [{"version": "v1", "created": "Thu, 27 Aug 2015 10:15:31 GMT"}], "update_date": "2015-08-28", "authors_parsed": [["Clarkson", "James", ""], ["Kotselidis", "Christos", ""], ["Brown", "Gavin", ""], ["Luj\u00e1n", "Mikel", ""]]}, {"id": "1508.06836", "submitter": "Tim King", "authors": "Zvonimir Pavlinovic, Tim King, Thomas Wies", "title": "On Practical SMT-Based Type Error Localization", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compilers for statically typed functional programming languages are notorious\nfor generating confusing type error messages. When the compiler detects a type\nerror, it typically reports the program location where the type checking failed\nas the source of the error. Since other error sources are not even considered,\nthe actual root cause is often missed. A more adequate approach is to consider\nall possible error sources and report the most useful one subject to some\nusefulness criterion. In our previous work, we showed that this approach can be\nformulated as an optimization problem related to satisfiability modulo theories\n(SMT). This formulation cleanly separates the heuristic nature of usefulness\ncriteria from the underlying search problem. Unfortunately, algorithms that\nsearch for an optimal error source cannot directly use principal types which\nare crucial for dealing with the exponential-time complexity of the decision\nproblem of polymorphic type checking. In this paper, we present a new algorithm\nthat efficiently finds an optimal error source in a given ill-typed program.\nOur algorithm uses an improved SMT encoding to cope with the high complexity of\npolymorphic typing by iteratively expanding the typing constraints from which\nprincipal types are derived. The algorithm preserves the clean separation\nbetween the heuristics and the actual search. We have implemented our algorithm\nfor OCaml. In our experimental evaluation, we found that the algorithm reduces\nthe running times for optimal type error localization from minutes to seconds\nand scales better than previous localization algorithms.\n", "versions": [{"version": "v1", "created": "Thu, 27 Aug 2015 12:52:20 GMT"}], "update_date": "2015-08-28", "authors_parsed": [["Pavlinovic", "Zvonimir", ""], ["King", "Tim", ""], ["Wies", "Thomas", ""]]}, {"id": "1508.07136", "submitter": "Robert Stewart", "authors": "Robert Stewart, Deepayan Bhowmik, Greg Michaelson, Andrew Wallace", "title": "RIPL: An Efficient Image Processing DSL for FPGAs", "comments": "Presented at Second International Workshop on FPGAs for Software\n  Programmers (FSP 2015) (arXiv:1508.06320)", "journal-ref": "J. Funct. Prog. 17 (2007) 428-429", "doi": "10.1017/S0956796807006296", "report-no": "FSP/2015/16", "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Field programmable gate arrays (FPGAs) can accelerate image processing by\nexploiting fine-grained parallelism opportunities in image operations. FPGA\nlanguage designs are often subsets or extensions of existing languages, though\nthese typically lack suitable hardware computation models so compiling them to\nFPGAs leads to inefficient designs. Moreover, these languages lack image\nprocessing domain specificity. Our solution is RIPL, an image processing domain\nspecific language (DSL) for FPGAs. It has algorithmic skeletons to express\nimage processing, and these are exploited to generate deep pipelines of highly\nconcurrent and memory-efficient image processing components.\n", "versions": [{"version": "v1", "created": "Fri, 28 Aug 2015 09:08:49 GMT"}], "update_date": "2016-07-06", "authors_parsed": [["Stewart", "Robert", ""], ["Bhowmik", "Deepayan", ""], ["Michaelson", "Greg", ""], ["Wallace", "Andrew", ""]]}, {"id": "1508.07547", "submitter": "Yanping Chen", "authors": "Yanping Chen, Qinghua Zheng, Ping Chen", "title": "Protocol Programming: A Connection of the Digital World", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The current computer programmings encapsulate attributes and behaviours into\nobjects, but miss the mechanism to support the connection among objects. A\nprogramming paradigm is presented to connect all objects. The connection\nsupports communications. Protocols are defined to coordinate the behaviours\nbetween objects, which enable the interaction of objects across different\nplatforms. The connection also provides an efficient mechanism to support the\nconcurrency, parallelism, distribution, pipeline and adaptability, etc. They\ncan be governed transparently, autonomously, even adaptively. In this paper, an\nimplementation is also discussed to show the effectiveness of protocol\nprogramming.\n", "versions": [{"version": "v1", "created": "Sun, 30 Aug 2015 09:11:14 GMT"}, {"version": "v2", "created": "Tue, 22 Mar 2016 00:50:14 GMT"}], "update_date": "2016-03-23", "authors_parsed": [["Chen", "Yanping", ""], ["Zheng", "Qinghua", ""], ["Chen", "Ping", ""]]}, {"id": "1508.07829", "submitter": "Matt Lewis", "authors": "Cristina David and Daniel Kroening and Matt Lewis", "title": "Using Program Synthesis for Program Analysis", "comments": "19 pages, to appear in LPAR 2015. arXiv admin note: text overlap with\n  arXiv:1409.4925", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we identify a fragment of second-order logic with restricted\nquantification that is expressive enough to capture numerous static analysis\nproblems (e.g. safety proving, bug finding, termination and non-termination\nproving, superoptimisation). We call this fragment the {\\it synthesis\nfragment}. Satisfiability of a formula in the synthesis fragment is decidable\nover finite domains; specifically the decision problem is NEXPTIME-complete. If\na formula in this fragment is satisfiable, a solution consists of a satisfying\nassignment from the second order variables to \\emph{functions over finite\ndomains}. To concretely find these solutions, we synthesise \\emph{programs}\nthat compute the functions. Our program synthesis algorithm is complete for\nfinite state programs, i.e. every \\emph{function} over finite domains is\ncomputed by some \\emph{program} that we can synthesise. We can therefore use\nour synthesiser as a decision procedure for the synthesis fragment of\nsecond-order logic, which in turn allows us to use it as a powerful backend for\nmany program analysis tasks. To show the tractability of our approach, we\nevaluate the program synthesiser on several static analysis problems.\n", "versions": [{"version": "v1", "created": "Mon, 31 Aug 2015 13:58:14 GMT"}], "update_date": "2015-09-01", "authors_parsed": [["David", "Cristina", ""], ["Kroening", "Daniel", ""], ["Lewis", "Matt", ""]]}]