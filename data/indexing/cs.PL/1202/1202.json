[{"id": "1202.0359", "submitter": "Vijay Ganesh", "authors": "Vijay Ganesh, Michael Carbin, and Martin Rinard", "title": "Cryptographic Path Hardening: Hiding Vulnerabilities in Software through\n  Cryptography", "comments": "Accepted as part of Off-the-beaten track at POPL 2012", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a novel approach to improving software security called\nCryptographic Path Hardening, which is aimed at hiding security vulnerabilities\nin software from attackers through the use of provably secure and obfuscated\ncryptographic devices to harden paths in programs.\n  By \"harden\" we mean that certain error-checking if-conditionals in a given\nprogram P are replaced by equivalent\" we mean that adversaries cannot use\nsemi-automatic program analysis techniques to reason about the hardened program\npaths and thus cannot discover as-yet-unknown errors along those paths, except\nperhaps through black-box dictionary attacks or random testing (which we can\nnever prevent).\n  Other than these unpreventable attack methods, we can make program analysis\naimed at error-finding \"provably hard\" for a resource-bounded attacker, in the\nsame sense that cryptographic schemes are hard to break. Unlike\nsecurity-through-obscurity, in Cryptographic Path Hardening we use\nprovably-secure crypto devices to hide errors and our mathematical arguments of\nsecurity are the same as the standard ones used in cryptography.\n  One application of Cryptographic Path Hardening is that software patches or\nfilters often reveal enough information to an attacker that they can be used to\nconstruct error-revealing inputs to exploit an unpatched version of the\nprogram. By \"hardening\" the patch we make it difficult for the attacker to\nanalyze the patched program to construct error-revealing inputs, and thus\nprevent him from potentially constructing exploits.\n", "versions": [{"version": "v1", "created": "Thu, 2 Feb 2012 04:53:09 GMT"}], "update_date": "2012-02-03", "authors_parsed": [["Ganesh", "Vijay", ""], ["Carbin", "Michael", ""], ["Rinard", "Martin", ""]]}, {"id": "1202.0693", "submitter": "Dale Miller", "authors": "Ivan Gazeau (LIX, INRIA Saclay - Ile de France), Dale Miller (LIX,\n  INRIA Saclay - Ile de France), Catuscia Palamidessi (LIX, INRIA Saclay - Ile\n  de France)", "title": "A non-local method for robustness analysis of floating point programs", "comments": "QAPL - Tenth Workshop on Quantitative Aspects of Programming\n  Languages (2012)", "journal-ref": null, "doi": "10.4204/EPTCS.85.5", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Robustness is a standard correctness property which intuitively means that if\nthe input to the program changes less than a fixed small amount then the output\nchanges only slightly. This notion is useful in the analysis of rounding error\nfor floating point programs because it helps to establish bounds on output\nerrors introduced by both measurement errors and by floating point computation.\nCompositional methods often do not work since key constructs---like the\nconditional and the while-loop---are not robust. We propose a method for\nproving the robustness of a while-loop. This method is non-local in the sense\nthat instead of breaking the analysis down to single lines of code, it checks\ncertain global properties of its structure. We show the applicability of our\nmethod on two standard algorithms: the CORDIC computation of the cosine and\nDijkstra's shortest path algorithm.\n", "versions": [{"version": "v1", "created": "Fri, 3 Feb 2012 13:16:27 GMT"}, {"version": "v2", "created": "Fri, 8 Jun 2012 14:50:36 GMT"}, {"version": "v3", "created": "Mon, 9 Jul 2012 13:23:20 GMT"}], "update_date": "2012-07-10", "authors_parsed": [["Gazeau", "Ivan", "", "LIX, INRIA Saclay - Ile de France"], ["Miller", "Dale", "", "LIX,\n  INRIA Saclay - Ile de France"], ["Palamidessi", "Catuscia", "", "LIX, INRIA Saclay - Ile\n  de France"]]}, {"id": "1202.1641", "submitter": "Ugo Dal Lago", "authors": "Beniamino Accattoli, Ugo Dal Lago", "title": "On the Invariance of the Unitary Cost Model for Head Reduction (Long\n  Version)", "comments": "22 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The lambda calculus is a widely accepted computational model of higher-order\nfunctional pro- grams, yet there is not any direct and universally accepted\ncost model for it. As a consequence, the computational difficulty of reducing\nlambda terms to their normal form is typically studied by reasoning on concrete\nimplementation algorithms. In this paper, we show that when head reduction is\nthe underlying dynamics, the unitary cost model is indeed invariant. This\nimproves on known results, which only deal with weak (call-by-value or\ncall-by-name) reduction. Invariance is proved by way of a linear calculus of\nexplicit substitutions, which allows to nicely decompose any head reduction\nstep in the lambda calculus into more elementary substitution steps, thus\nmaking the combinatorics of head-reduction easier to reason about. The\ntechnique is also a promising tool to attack what we see as the main open\nproblem, namely understanding for which normalizing strategies derivation\ncomplexity is an invariant cost model, if any.\n", "versions": [{"version": "v1", "created": "Wed, 8 Feb 2012 10:02:15 GMT"}], "update_date": "2012-02-09", "authors_parsed": [["Accattoli", "Beniamino", ""], ["Lago", "Ugo Dal", ""]]}, {"id": "1202.2086", "submitter": "Luca Padovani", "authors": "Viviana Bono (Universit\\`a di Torino), Luca Padovani (Universit\\`a di\n  Torino)", "title": "Typing Copyless Message Passing", "comments": "50 pages", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 1 (March 2,\n  2012) lmcs:798", "doi": "10.2168/LMCS-8(1:17)2012", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a calculus that models a form of process interaction based on\ncopyless message passing, in the style of Singularity OS. The calculus is\nequipped with a type system ensuring that well-typed processes are free from\nmemory faults, memory leaks, and communication errors. The type system is\nessentially linear, but we show that linearity alone is inadequate, because it\nleaves room for scenarios where well-typed processes leak significant amounts\nof memory. We address these problems basing the type system upon an original\nvariant of session types.\n", "versions": [{"version": "v1", "created": "Thu, 9 Feb 2012 19:22:13 GMT"}, {"version": "v2", "created": "Thu, 1 Mar 2012 20:44:48 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Bono", "Viviana", "", "Universit\u00e0 di Torino"], ["Padovani", "Luca", "", "Universit\u00e0 di\n  Torino"]]}, {"id": "1202.2284", "submitter": "Drazen Lucanin MSc", "authors": "Drazen Lucanin and Ivan Fabek", "title": "A visual programming language for drawing and executing flowcharts", "comments": "6 pages, conference paper", "journal-ref": "Proceedings of the 34th International Convention MIPRO, 23-27 May\n  2011, p. 1679-1684", "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  With recent advances in graphical user interfaces, more and more tasks on\ncomputers have become easier to perform. Out of the belief that creating\ncomputer programs can also be one of them, visual programming languages (VPLs)\nhave emerged. The goal of VPLs is to shift a part of work from the programmer\nto the IDE so that the programmer can focus more on algorithm logic than the\nsyntax of the implementation programming language. In this article, the methods\nrequired to build a VPL are presented, with an emphasis on a novel method of\ncode generation in a WHILE language. Also, the methods for achieving basic\nprinciples of VPLs will be shown - suitable visual presentation of information\nand guiding the programmer in the right direction using constraints. These\nmethods are demonstrated on an example of vIDE, a VPL based on the Eclipse\nintegrated development environment (IDE). The design of vIDE with respect to\nthe Eclipse Graphical Modeling Framework (GMF) is described. The concept of a\nflowchart graphical notation is examined in contrast with the algorithm model\nit maps to. Finally, the disambiguity of the model representation of an\nalgorithm is discussed and the methods for transforming it to an actual\nimplementation in a programming language.\n", "versions": [{"version": "v1", "created": "Fri, 10 Feb 2012 15:36:42 GMT"}], "update_date": "2012-06-25", "authors_parsed": [["Lucanin", "Drazen", ""], ["Fabek", "Ivan", ""]]}, {"id": "1202.2287", "submitter": "Jean Goubault-Larrecq", "authors": "Jean Goubault-Larrecq (LSV, ENS Cachan, CNRS, INRIA)", "title": "QRB-Domains and the Probabilistic Powerdomain", "comments": "32 pages, 7 figures. An extended abstract already appeared in Proc.\n  25th Annual IEEE Symposium on Logic in Computer Science (LICS'10)", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 1 (February\n  29, 2012) lmcs:956", "doi": "10.2168/LMCS-8(1:14)2012", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Is there any Cartesian-closed category of continuous domains that would be\nclosed under Jones and Plotkin's probabilistic powerdomain construction? This\nis a major open problem in the area of denotational semantics of probabilistic\nhigher-order languages. We relax the question, and look for quasi-continuous\ndcpos instead. We introduce a natural class of such quasi-continuous dcpos, the\nomega-QRB-domains. We show that they form a category omega-QRB with pleasing\nproperties: omega-QRB is closed under the probabilistic powerdomain functor,\nunder finite products, under taking bilimits of expanding sequences, under\nretracts, and even under so-called quasi-retracts. But... omega-QRB is not\nCartesian closed. We conclude by showing that the QRB domains are just one half\nof an FS-domain, merely lacking control.\n", "versions": [{"version": "v1", "created": "Fri, 10 Feb 2012 15:46:29 GMT"}, {"version": "v2", "created": "Mon, 27 Feb 2012 20:49:09 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Goubault-Larrecq", "Jean", "", "LSV, ENS Cachan, CNRS, INRIA"]]}, {"id": "1202.2407", "submitter": "EPTCS", "authors": "James Chapman (Institute of Cybernetics, Tallinn), Paul Blain Levy\n  (University of Birmingham)", "title": "Proceedings Fourth Workshop on Mathematically Structured Functional\n  Programming", "comments": null, "journal-ref": "EPTCS 76, 2012", "doi": "10.4204/EPTCS.76", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Fourth Workshop on Mathematically\nStructured Functional Programming (MSFP 2012), taking place on 25 March, 2012\nin Tallinn, Estonia, as a satellite event of the European Joint Conferences on\nTheory and Practice of Software, ETAPS 2012.\n  MSFP is devoted to the derivation of functionality from structure. It\nhighlights concepts from algebra, semantics and type theory as they are\nincreasingly reflected in programming practice, especially functional\nprogramming. The workshop consists of two invited presentations and eight\ncontributed papers on a range of topics at that interface.\n", "versions": [{"version": "v1", "created": "Sat, 11 Feb 2012 03:55:47 GMT"}], "update_date": "2012-02-14", "authors_parsed": [["Chapman", "James", "", "Institute of Cybernetics, Tallinn"], ["Levy", "Paul Blain", "", "University of Birmingham"]]}, {"id": "1202.2486", "submitter": "Neal Glew", "authors": "Neal Glew", "title": "Subtyping for F-Bounded Quantifiers and Equirecursive Types (Extended\n  Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper defines a notion of binding trees that provide a suitable model\nfor second-order type systems with F-bounded quantifiers and equirecursive\ntypes. It defines a notion of regular binding trees that correspond in the\nright way to notions of regularity in the first-order case. It defines a notion\nof subtyping on these trees and proves various properties of the subtyping\nrelation. It defines a mapping from types to trees and shows that types produce\nregular binding trees. It presents a set of type equality and subtyping rules,\nand proves them sound and complete with respect to the tree interpretation. It\ndefines a notion of binding-tree automata and how these generate regular\nbinding trees. It gives a polynomial-time algorithm for deciding when two\nautomata's trees are in the subtyping relation.\n", "versions": [{"version": "v1", "created": "Sun, 12 Feb 2012 03:15:17 GMT"}], "update_date": "2015-03-20", "authors_parsed": [["Glew", "Neal", ""]]}, {"id": "1202.2736", "submitter": "Andr\\'e Gaul", "authors": "Andr\\'e Gaul", "title": "Function call overhead benchmarks with MATLAB, Octave, Python, Cython\n  and C", "comments": "The benchmark's source code is available under GPL3 at\n  https://bitbucket.org/andrenarchy/funcall", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.MS math.NA", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  We consider the overhead of function calls in the programming languages\nMATLAB/Octave, Python, Cython and C. In many applications a function has to be\ncalled very often inside a loop. One such application in numerical analysis is\nthe finite element method where integrals have to be computed on each element\nin a loop. The called functions can often be evaluated efficiently but the\nfunction call itself may be time-consuming. We present a benchmark whose goal\nis to identify and quantify optimization potentials with respect to time\nconsumption caused by function calls in the mentioned programming languages.\n", "versions": [{"version": "v1", "created": "Mon, 13 Feb 2012 14:14:00 GMT"}], "update_date": "2012-02-14", "authors_parsed": [["Gaul", "Andr\u00e9", ""]]}, {"id": "1202.2868", "submitter": "Drazen Lucanin MSc", "authors": "Drazen Lucanin", "title": "Visual definition of procedures for automatic virtual scene generation", "comments": "Master's thesis", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GR cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  With more and more digital media, especially in the field of virtual reality\nwhere detailed and convincing scenes are much required, procedural scene\ngeneration is a big helping tool for artists. A problem is that defining scene\ndescriptions through these procedures usually requires a knowledge in formal\nlanguage grammars, programming theory and manually editing textual files using\na strict syntax, making it less intuitive to use. Luckily, graphical user\ninterfaces has made a lot of tasks on computers easier to perform and out of\nthe belief that creating computer programs can also be one of them, visual\nprogramming languages (VPLs) have emerged. The goal in VPLs is to shift more\nwork from the programmer to the integrated development environment (IDE),\nmaking programming an user-friendlier task.\n  In this thesis, an approach of using a VPL for defining procedures that\nautomatically generate virtual scenes is presented. The methods required to\nbuild a VPL are presented, including a novel method of generating readable code\nin a structured programming language. Also, the methods for achieving basic\nprinciples of VPLs will be shown -- suitable visual presentation of information\nand guiding the programmer in the right direction using constraints. On the\nother hand, procedural generation methods are presented in the context of\nvisual programming -- adapting the application programming interface (API) of\nthese methods to better serve the user. The main focus will be on the methods\nfor urban modeling, such as building, city layout and details generation with\nrandom number generation used to create non-deterministic scenes.\n", "versions": [{"version": "v1", "created": "Fri, 10 Feb 2012 16:58:00 GMT"}], "update_date": "2012-02-15", "authors_parsed": [["Lucanin", "Drazen", ""]]}, {"id": "1202.2917", "submitter": "EPTCS", "authors": "Patrick Bahr (Department of Computer Science, University of\n  Copenhagen), Tom Hvitved (Department of Computer Science, University of\n  Copenhagen)", "title": "Parametric Compositional Data Types", "comments": "In Proceedings MSFP 2012, arXiv:1202.2407", "journal-ref": "EPTCS 76, 2012, pp. 3-24", "doi": "10.4204/EPTCS.76.3", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In previous work we have illustrated the benefits that compositional data\ntypes (CDTs) offer for implementing languages and in general for dealing with\nabstract syntax trees (ASTs). Based on Swierstra's data types \\'a la carte,\nCDTs are implemented as a Haskell library that enables the definition of\nrecursive data types and functions on them in a modular and extendable fashion.\nAlthough CDTs provide a powerful tool for analysing and manipulating ASTs, they\nlack a convenient representation of variable binders. In this paper we remedy\nthis deficiency by combining the framework of CDTs with Chlipala's parametric\nhigher-order abstract syntax (PHOAS). We show how a generalisation from\nfunctors to difunctors enables us to capture PHOAS while still maintaining the\nfeatures of the original implementation of CDTs, in particular its modularity.\nUnlike previous approaches, we avoid so-called exotic terms without resorting\nto abstract types: this is crucial when we want to perform transformations on\nCDTs that inspect the recursively computed CDTs, e.g. constant folding.\n", "versions": [{"version": "v1", "created": "Tue, 14 Feb 2012 03:01:17 GMT"}], "update_date": "2012-02-15", "authors_parsed": [["Bahr", "Patrick", "", "Department of Computer Science, University of\n  Copenhagen"], ["Hvitved", "Tom", "", "Department of Computer Science, University of\n  Copenhagen"]]}, {"id": "1202.2918", "submitter": "EPTCS", "authors": "Chris Casinghino (University of Pennsylvania), Vilhelm Sj\\\"oberg\n  (University of Pennsylvania), Stephanie Weirich (University of Pennsylvania)", "title": "Step-Indexed Normalization for a Language with General Recursion", "comments": "In Proceedings MSFP 2012, arXiv:1202.2407", "journal-ref": "EPTCS 76, 2012, pp. 25-39", "doi": "10.4204/EPTCS.76.4", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Trellys project has produced several designs for practical dependently\ntyped languages. These languages are broken into two\nfragments-a_logical_fragment where every term normalizes and which is\nconsistent when interpreted as a logic, and a_programmatic_fragment with\ngeneral recursion and other convenient but unsound features. In this paper, we\npresent a small example language in this style. Our design allows the\nprogrammer to explicitly mention and pass information between the two\nfragments. We show that this feature substantially complicates the metatheory\nand present a new technique, combining the traditional Girard-Tait method with\nstep-indexed logical relations, which we use to show normalization for the\nlogical fragment.\n", "versions": [{"version": "v1", "created": "Tue, 14 Feb 2012 03:01:23 GMT"}], "update_date": "2012-02-15", "authors_parsed": [["Casinghino", "Chris", "", "University of Pennsylvania"], ["Sj\u00f6berg", "Vilhelm", "", "University of Pennsylvania"], ["Weirich", "Stephanie", "", "University of Pennsylvania"]]}, {"id": "1202.2919", "submitter": "EPTCS", "authors": "Mauro Jaskelioff (Centro Internacional Franco Argentino de Ciencias de\n  la Informaci\\'on y de Sistemas/Universidad Nacional de Rosario, Rosario,\n  Argentina), Ondrej Rypacek (King's College, London, UK)", "title": "An Investigation of the Laws of Traversals", "comments": "In Proceedings MSFP 2012, arXiv:1202.2407", "journal-ref": "EPTCS 76, 2012, pp. 40-49", "doi": "10.4204/EPTCS.76.5", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Traversals of data structures are ubiquitous in programming. Consequently, it\nis important to be able to characterise those structures that are traversable\nand understand their algebraic properties. Traversable functors have been\ncharacterised by McBride and Paterson as those equipped with a distributive law\nover arbitrary applicative functors; however, laws that fully capture the\nintuition behind traversals are missing. This article is an attempt to remedy\nthis situation by proposing laws for characterising traversals that capture the\nintuition behind them. To support our claims, we prove that finitary containers\nare traversable in our sense and argue that elements in a traversable structure\nare visited exactly once.\n", "versions": [{"version": "v1", "created": "Tue, 14 Feb 2012 03:01:31 GMT"}], "update_date": "2012-02-15", "authors_parsed": [["Jaskelioff", "Mauro", "", "Centro Internacional Franco Argentino de Ciencias de\n  la Informaci\u00f3n y de Sistemas/Universidad Nacional de Rosario, Rosario,\n  Argentina"], ["Rypacek", "Ondrej", "", "King's College, London, UK"]]}, {"id": "1202.2920", "submitter": "EPTCS", "authors": "Jos\\'e Pedro Magalh\\~aes, Andres L\\\"oh", "title": "A Formal Comparison of Approaches to Datatype-Generic Programming", "comments": "In Proceedings MSFP 2012, arXiv:1202.2407", "journal-ref": "EPTCS 76, 2012, pp. 50-67", "doi": "10.4204/EPTCS.76.6", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Datatype-generic programming increases program abstraction and reuse by\nmaking functions operate uniformly across different types. Many approaches to\ngeneric programming have been proposed over the years, most of them for\nHaskell, but recently also for dependently typed languages such as Agda.\nDifferent approaches vary in expressiveness, ease of use, and implementation\ntechniques.\n  Some work has been done in comparing the different approaches informally.\nHowever, to our knowledge there have been no attempts to formally prove\nrelations between different approaches. We thus present a formal comparison of\ngeneric programming libraries. We show how to formalise different approaches in\nAgda, including a coinductive representation, and then establish theorems that\nrelate the approaches to each other. We provide constructive proofs of\ninclusion of one approach in another that can be used to convert between\napproaches, helping to reduce code duplication across different libraries. Our\nformalisation also helps in providing a clear picture of the potential of each\napproach, especially in relating different generic views and their\nexpressiveness.\n", "versions": [{"version": "v1", "created": "Tue, 14 Feb 2012 03:01:41 GMT"}], "update_date": "2012-02-15", "authors_parsed": [["Magalh\u00e3es", "Jos\u00e9 Pedro", ""], ["L\u00f6h", "Andres", ""]]}, {"id": "1202.2921", "submitter": "EPTCS", "authors": "Tomas Petricek (University of Cambridge)", "title": "Evaluation strategies for monadic computations", "comments": "In Proceedings MSFP 2012, arXiv:1202.2407", "journal-ref": "EPTCS 76, 2012, pp. 68-89", "doi": "10.4204/EPTCS.76.7", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Monads have become a powerful tool for structuring effectful computations in\nfunctional programming, because they make the order of effects explicit. When\ntranslating pure code to a monadic version, we need to specify evaluation order\nexplicitly. Two standard translations give call-by-value and call-by-name\nsemantics. The resulting programs have different structure and types, which\nmakes revisiting the choice difficult.\n  In this paper, we translate pure code to monadic using an additional\noperation malias that abstracts out the evaluation strategy. The malias\noperation is based on computational comonads; we use a categorical framework to\nspecify the laws that are required to hold about the operation.\n  For any monad, we show implementations of malias that give call-by-value and\ncall-by-name semantics. Although we do not give call-by-need semantics for all\nmonads, we show how to turn certain monads into an extended monad with\ncall-by-need semantics, which partly answers an open question. Moreover, using\nour unified translation, it is possible to change the evaluation strategy of\nfunctional code translated to the monadic form without changing its structure\nor types.\n", "versions": [{"version": "v1", "created": "Tue, 14 Feb 2012 03:01:45 GMT"}], "update_date": "2012-02-15", "authors_parsed": [["Petricek", "Tomas", "", "University of Cambridge"]]}, {"id": "1202.2922", "submitter": "EPTCS", "authors": "Maciej Pir\\'og (Department of Computer Science, University of Oxford),\n  Jeremy Gibbons (Department of Computer Science, University of Oxford)", "title": "Tracing monadic computations and representing effects", "comments": "In Proceedings MSFP 2012, arXiv:1202.2407", "journal-ref": "EPTCS 76, 2012, pp. 90-111", "doi": "10.4204/EPTCS.76.8", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In functional programming, monads are supposed to encapsulate computations,\neffectfully producing the final result, but keeping to themselves the means of\nacquiring it. For various reasons, we sometimes want to reveal the internals of\na computation. To make that possible, in this paper we introduce monad\ntransformers that add the ability to automatically accumulate observations\nabout the course of execution as an effect. We discover that if we treat the\nresulting trace as the actual result of the computation, we can find new\nfunctionality in existing monads, notably when working with non-terminating\ncomputations.\n", "versions": [{"version": "v1", "created": "Tue, 14 Feb 2012 03:01:53 GMT"}], "update_date": "2012-02-15", "authors_parsed": [["Pir\u00f3g", "Maciej", "", "Department of Computer Science, University of Oxford"], ["Gibbons", "Jeremy", "", "Department of Computer Science, University of Oxford"]]}, {"id": "1202.2923", "submitter": "EPTCS", "authors": "Vilhelm Sj\\\"oberg (University of Pennsylvania), Chris Casinghino\n  (University of Pennsylvania), Ki Yung Ahn (Portland State University), Nathan\n  Collins (Portland State University), Harley D. Eades III (University of\n  Iowa), Peng Fu (University of Iowa), Garrin Kimmell (University of Iowa), Tim\n  Sheard (Portland State University), Aaron Stump (University of Iowa),\n  Stephanie Weirich (University of Pennsylvania)", "title": "Irrelevance, Heterogeneous Equality, and Call-by-value Dependent Type\n  Systems", "comments": "In Proceedings MSFP 2012, arXiv:1202.2407", "journal-ref": "EPTCS 76, 2012, pp. 112-162", "doi": "10.4204/EPTCS.76.9", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a full-spectrum dependently typed core language which includes\nboth nontermination and computational irrelevance (a.k.a. erasure), a\ncombination which has not been studied before. The two features interact: to\nprotect type safety we must be careful to only erase terminating expressions.\nOur language design is strongly influenced by the choice of CBV evaluation, and\nby our novel treatment of propositional equality which has a heterogeneous,\ncompletely erased elimination form.\n", "versions": [{"version": "v1", "created": "Tue, 14 Feb 2012 03:01:59 GMT"}], "update_date": "2012-02-15", "authors_parsed": [["Sj\u00f6berg", "Vilhelm", "", "University of Pennsylvania"], ["Casinghino", "Chris", "", "University of Pennsylvania"], ["Ahn", "Ki Yung", "", "Portland State University"], ["Collins", "Nathan", "", "Portland State University"], ["Eades", "Harley D.", "III", "University of\n  Iowa"], ["Fu", "Peng", "", "University of Iowa"], ["Kimmell", "Garrin", "", "University of Iowa"], ["Sheard", "Tim", "", "Portland State University"], ["Stump", "Aaron", "", "University of Iowa"], ["Weirich", "Stephanie", "", "University of Pennsylvania"]]}, {"id": "1202.2924", "submitter": "EPTCS", "authors": "Wouter Swierstra (Radboud University Nijmegen)", "title": "From Mathematics to Abstract Machine: A formal derivation of an\n  executable Krivine machine", "comments": "In Proceedings MSFP 2012, arXiv:1202.2407", "journal-ref": "EPTCS 76, 2012, pp. 163-177", "doi": "10.4204/EPTCS.76.10", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents the derivation of an executable Krivine abstract machine\nfrom a small step interpreter for the simply typed lambda calculus in the\ndependently typed programming language Agda.\n", "versions": [{"version": "v1", "created": "Tue, 14 Feb 2012 03:02:06 GMT"}], "update_date": "2012-02-15", "authors_parsed": [["Swierstra", "Wouter", "", "Radboud University Nijmegen"]]}, {"id": "1202.3174", "submitter": "EPTCS", "authors": "Dale Miller (INRIA-Saclay, France), Zolt\\'an \\'Esik (University of\n  Szeged, Hungary)", "title": "Proceedings 8th Workshop on Fixed Points in Computer Science", "comments": "For more information about FICS 2012, please visit the webpage of the\n  conference: http://www.inf.u-szeged.hu/fics2012/", "journal-ref": "EPTCS 77, 2012", "doi": "10.4204/EPTCS.77", "report-no": null, "categories": "cs.LO cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Eighth Workshop on Fixed Points\nin Computer Science which took place on 24 March 2012 in Tallinn, Estonia as an\nETAPS-affiliated workshop. Past workshops have been held in Brno (1998,\nMFCS/CSL workshop), Paris (2000, LC workshop), Florence (2001, PLI workshop),\nCopenhagen (2002, LICS (FLoC) workshop), Warsaw (2003, ETAPS workshop), Coimbra\n(2009, CSL workshop), and Brno (2010, MFCS-CSL workshop).\n  Fixed points play a fundamental role in several areas of computer science and\nlogic by justifying induction and recursive definitions. The construction and\nproperties of fixed points have been investigated in many different frameworks\nsuch as: design and implementation of programming languages, program logics,\nand databases. The aim of this workshop is to provide a forum for researchers\nto present their results to those members of the computer science and logic\ncommunities who study or apply the theory of fixed points.\n", "versions": [{"version": "v1", "created": "Tue, 14 Feb 2012 23:15:54 GMT"}], "update_date": "2012-02-16", "authors_parsed": [["Miller", "Dale", "", "INRIA-Saclay, France"], ["\u00c9sik", "Zolt\u00e1n", "", "University of\n  Szeged, Hungary"]]}, {"id": "1202.3247", "submitter": "Gabriel Kerneis", "authors": "Gabriel Kerneis (PPS), Juliusz Chroboczek (PPS)", "title": "Lambda-lifting and CPS conversion in an imperative language", "comments": "arXiv admin note: substantial text overlap with arXiv:1011.4558", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper is a companion technical report to the article\n\"Continuation-Passing C: from threads to events through continuations\". It\ncontains the complete version of the proofs of correctness of lambda-lifting\nand CPS-conversion presented in the article.\n", "versions": [{"version": "v1", "created": "Wed, 15 Feb 2012 09:41:45 GMT"}], "update_date": "2012-02-16", "authors_parsed": [["Kerneis", "Gabriel", "", "PPS"], ["Chroboczek", "Juliusz", "", "PPS"]]}, {"id": "1202.3496", "submitter": "EPTCS", "authors": "Andreas Abel (Department of Computer Science,\n  Ludwig-Maximilians-University Munich)", "title": "Type-Based Termination, Inflationary Fixed-Points, and Mixed\n  Inductive-Coinductive Types", "comments": "In Proceedings FICS 2012, arXiv:1202.3174", "journal-ref": "EPTCS 77, 2012, pp. 1-11", "doi": "10.4204/EPTCS.77.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Type systems certify program properties in a compositional way. From a bigger\nprogram one can abstract out a part and certify the properties of the resulting\nabstract program by just using the type of the part that was abstracted away.\nTermination and productivity are non-trivial yet desired program properties,\nand several type systems have been put forward that guarantee termination,\ncompositionally. These type systems are intimately connected to the definition\nof least and greatest fixed-points by ordinal iteration. While most type\nsystems use conventional iteration, we consider inflationary iteration in this\narticle. We demonstrate how this leads to a more principled type system, with\nrecursion based on well-founded induction. The type system has a prototypical\nimplementation, MiniAgda, and we show in particular how it certifies\nproductivity of corecursive and mixed recursive-corecursive functions.\n", "versions": [{"version": "v1", "created": "Thu, 16 Feb 2012 02:41:10 GMT"}], "update_date": "2012-02-17", "authors_parsed": [["Abel", "Andreas", "", "Department of Computer Science,\n  Ludwig-Maximilians-University Munich"]]}, {"id": "1202.3499", "submitter": "EPTCS", "authors": "Andr\\'e Hirschowitz (Laboratoire J.-A. Dieudonn\\'e, Universit\\'e de\n  Nice - Sophia Antipolis), Marco Maggesi (Dipartimento di Matematica \"U.\n  Dini\", Universit\\`a degli Studi di Firenze)", "title": "Initial Semantics for Strengthened Signatures", "comments": "In Proceedings FICS 2012, arXiv:1202.3174", "journal-ref": "EPTCS 77, 2012, pp. 31-38", "doi": "10.4204/EPTCS.77.5", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give a new general definition of arity, yielding the companion notions of\nsignature and associated syntax. This setting is modular in the sense requested\nby Ghani and Uustalu: merging two extensions of syntax corresponds to building\nan amalgamated sum. These signatures are too general in the sense that we are\nnot able to prove the existence of an associated syntax in this general\ncontext. So we have to select arities and signatures for which there exists the\ndesired initial monad. For this, we follow a track opened by Matthes and\nUustalu: we introduce a notion of strengthened arity and prove that the\ncorresponding signatures have initial semantics (i.e. associated syntax). Our\nstrengthened arities admit colimits, which allows the treatment of the\n\\lambda-calculus with explicit substitution.\n", "versions": [{"version": "v1", "created": "Thu, 16 Feb 2012 02:41:30 GMT"}], "update_date": "2012-02-17", "authors_parsed": [["Hirschowitz", "Andr\u00e9", "", "Laboratoire J.-A. Dieudonn\u00e9, Universit\u00e9 de\n  Nice - Sophia Antipolis"], ["Maggesi", "Marco", "", "Dipartimento di Matematica \"U.\n  Dini\", Universit\u00e0 degli Studi di Firenze"]]}, {"id": "1202.3502", "submitter": "EPTCS", "authors": "Tarmo Uustalu", "title": "Structured general corecursion and coinductive graphs [extended\n  abstract]", "comments": "In Proceedings FICS 2012, arXiv:1202.3174", "journal-ref": "EPTCS 77, 2012, pp. 55-61", "doi": "10.4204/EPTCS.77.8", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bove and Capretta's popular method for justifying function definitions by\ngeneral recursive equations is based on the observation that any structured\ngeneral recursion equation defines an inductive subset of the intended domain\n(the \"domain of definedness\") for which the equation has a unique solution. To\naccept the definition, it is hence enough to prove that this subset contains\nthe whole intended domain.\n  This approach works very well for \"terminating\" definitions. But it fails to\naccount for \"productive\" definitions, such as typical definitions of\nstream-valued functions. We argue that such definitions can be treated in a\nsimilar spirit, proceeding from a different unique solvability criterion. Any\nstructured recursive equation defines a coinductive relation between the\nintended domain and intended codomain (the \"coinductive graph\"). This relation\nin turn determines a subset of the intended domain and a quotient of the\nintended codomain with the property that the equation is uniquely solved for\nthe subset and quotient. The equation is therefore guaranteed to have a unique\nsolution for the intended domain and intended codomain whenever the subset is\nthe full set and the quotient is by equality.\n", "versions": [{"version": "v1", "created": "Thu, 16 Feb 2012 02:41:50 GMT"}], "update_date": "2012-02-17", "authors_parsed": [["Uustalu", "Tarmo", ""]]}, {"id": "1202.4269", "submitter": "Henning Thielemann", "authors": "Henning Thielemann", "title": "Live-Musikprogrammierung in Haskell", "comments": "12 pages, 2 figures, 5. Arbeitstagung Programmiersprachen 2012,\n  ATPS'12", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SD", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We aim to compose algorithmic music in an interactive way with multiple\nparticipants. To this end we develop an interpreter for a sub-language of the\nnon-strict functional programming language Haskell that allows to modify the\nprogram during its execution. Our system can be used both for musical\nlive-coding and for demonstration and education of functional programming.\n", "versions": [{"version": "v1", "created": "Mon, 20 Feb 2012 09:44:47 GMT"}], "update_date": "2012-02-21", "authors_parsed": [["Thielemann", "Henning", ""]]}, {"id": "1202.4829", "submitter": "EPTCS", "authors": "Ralph-Johan Back ({\\AA}bo Akademi University), Johannes Eriksson\n  ({\\AA}bo Akademi University)", "title": "An Exercise in Invariant-based Programming with Interactive and\n  Automatic Theorem Prover Support", "comments": "In Proceedings THedu'11, arXiv:1202.4535", "journal-ref": "EPTCS 79, 2012, pp. 29-48", "doi": "10.4204/EPTCS.79.2", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Invariant-Based Programming (IBP) is a diagram-based correct-by-construction\nprogramming methodology in which the program is structured around the\ninvariants, which are additionally formulated before the actual code. Socos is\na program construction and verification environment built specifically to\nsupport IBP. The front-end to Socos is a graphical diagram editor, allowing the\nprogrammer to construct invariant-based programs and check their correctness.\nThe back-end component of Socos, the program checker, computes the verification\nconditions of the program and tries to prove them automatically. It uses the\ntheorem prover PVS and the SMT solver Yices to discharge as many of the\nverification conditions as possible without user interaction. In this paper, we\nfirst describe the Socos environment from a user and systems level perspective;\nwe then exemplify the IBP workflow by building a verified implementation of\nheapsort in Socos. The case study highlights the role of both automatic and\ninteractive theorem proving in three sequential stages of the IBP workflow:\ndeveloping the background theory, formulating the program specification and\ninvariants, and proving the correctness of the final implementation.\n", "versions": [{"version": "v1", "created": "Wed, 22 Feb 2012 06:41:29 GMT"}], "update_date": "2012-02-23", "authors_parsed": [["Back", "Ralph-Johan", "", "\u00c5bo Akademi University"], ["Eriksson", "Johannes", "", "\u00c5bo Akademi University"]]}, {"id": "1202.4832", "submitter": "EPTCS", "authors": "Walther Neuper", "title": "Automated Generation of User Guidance by Combining Computation and\n  Deduction", "comments": "In Proceedings THedu'11, arXiv:1202.4535", "journal-ref": "EPTCS 79, 2012, pp. 82-101", "doi": "10.4204/EPTCS.79.5", "report-no": null, "categories": "cs.LO cs.HC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Herewith, a fairly old concept is published for the first time and named\n\"Lucas Interpretation\". This has been implemented in a prototype, which has\nbeen proved useful in educational practice and has gained academic relevance\nwith an emerging generation of educational mathematics assistants (EMA) based\non Computer Theorem Proving (CTP).\n  Automated Theorem Proving (ATP), i.e. deduction, is the most reliable\ntechnology used to check user input. However ATP is inherently weak in\nautomatically generating solutions for arbitrary problems in applied\nmathematics. This weakness is crucial for EMAs: when ATP checks user input as\nincorrect and the learner gets stuck then the system should be able to suggest\npossible next steps.\n  The key idea of Lucas Interpretation is to compute the steps of a calculation\nfollowing a program written in a novel CTP-based programming language, i.e.\ncomputation provides the next steps. User guidance is generated by combining\ndeduction and computation: the latter is performed by a specific language\ninterpreter, which works like a debugger and hands over control to the learner\nat breakpoints, i.e. tactics generating the steps of calculation. The\ninterpreter also builds up logical contexts providing ATP with the data\nrequired for checking user input, thus combining computation and deduction.\n  The paper describes the concepts underlying Lucas Interpretation so that open\nquestions can adequately be addressed, and prerequisites for further work are\nprovided.\n", "versions": [{"version": "v1", "created": "Wed, 22 Feb 2012 06:41:51 GMT"}], "update_date": "2012-02-23", "authors_parsed": [["Neuper", "Walther", ""]]}, {"id": "1202.4834", "submitter": "EPTCS", "authors": "Wolfgang Schreiner", "title": "Computer-Assisted Program Reasoning Based on a Relational Semantics of\n  Programs", "comments": "In Proceedings THedu'11, arXiv:1202.4535", "journal-ref": "EPTCS 79, 2012, pp. 124-142", "doi": "10.4204/EPTCS.79.8", "report-no": null, "categories": "cs.LO cs.MS cs.PL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an approach to program reasoning which inserts between a program\nand its verification conditions an additional layer, the denotation of the\nprogram expressed in a declarative form. The program is first translated into\nits denotation from which subsequently the verification conditions are\ngenerated. However, even before (and independently of) any verification\nattempt, one may investigate the denotation itself to get insight into the\n\"semantic essence\" of the program, in particular to see whether the denotation\nindeed gives reason to believe that the program has the expected behavior.\nErrors in the program and in the meta-information may thus be detected and\nfixed prior to actually performing the formal verification. More concretely,\nfollowing the relational approach to program semantics, we model the effect of\na program as a binary relation on program states. A formal calculus is devised\nto derive from a program a logic formula that describes this relation and is\nsubject for inspection and manipulation. We have implemented this idea in a\ncomprehensive form in the RISC ProgramExplorer, a new program reasoning\nenvironment for educational purposes which encompasses the previously developed\nRISC ProofNavigator as an interactive proving assistant.\n", "versions": [{"version": "v1", "created": "Wed, 22 Feb 2012 06:42:11 GMT"}], "update_date": "2012-02-23", "authors_parsed": [["Schreiner", "Wolfgang", ""]]}, {"id": "1202.5509", "submitter": "Jacob Beal", "authors": "Jacob Beal, Stefan Dulman, Kyle Usbeck, Mirko Viroli, and Nikolaus\n  Correll", "title": "Organizing the Aggregate: Languages for Spatial Computing", "comments": "60 pages; Review chapter to appear as a chapter in book \"Formal and\n  Practical Aspects of Domain-Specific Languages: Recent Developments\"", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As the number of computing devices embedded into engineered systems continues\nto rise, there is a widening gap between the needs of the user to control\naggregates of devices and the complex technology of individual devices. Spatial\ncomputing attempts to bridge this gap for systems with local communication by\nexploiting the connection between physical locality and device connectivity. A\nlarge number of spatial computing domain specific languages (DSLs) have emerged\nacross diverse domains, from biology and reconfigurable computing, to sensor\nnetworks and agent-based systems. In this chapter, we develop a framework for\nanalyzing and comparing spatial computing DSLs, survey the current state of the\nart, and provide a roadmap for future spatial computing DSL investigation.\n", "versions": [{"version": "v1", "created": "Fri, 24 Feb 2012 17:35:03 GMT"}, {"version": "v2", "created": "Tue, 3 Apr 2012 03:13:16 GMT"}], "update_date": "2012-04-04", "authors_parsed": [["Beal", "Jacob", ""], ["Dulman", "Stefan", ""], ["Usbeck", "Kyle", ""], ["Viroli", "Mirko", ""], ["Correll", "Nikolaus", ""]]}, {"id": "1202.5539", "submitter": "Yin Wang", "authors": "Yin Wang, R. Kent Dybvig", "title": "Register Allocation By Model Transformer Semantics", "comments": "12 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Register allocation has long been formulated as a graph coloring problem,\ncoloring the conflict graph with physical registers. Such a formulation does\nnot fully capture the goal of the allocation, which is to minimize the traffic\nbetween registers and memory. Linear scan has been proposed as an alternative\nto graph coloring, but in essence, it can be viewed as a greedy algorithm for\ngraph coloring: coloring the vertices not in the order of their degrees, but in\nthe order of their occurence in the program. Thus it suffers from almost the\nsame constraints as graph coloring. In this article, I propose a new method of\nregister allocation based on the ideas of model transformer semantics (MTS) and\nstatic cache replacement (SCR). Model transformer semantics captures the\nsemantics of registers and the stack. Static cache replacement relaxes the\nassumptions made by graph coloring and linear scan, aiming directly at reducing\nregister-memory traffic. The method explores a much larger solution space than\nthat of graph coloring and linear scan, thus providing more opportunities of\noptimization. It seamlessly performs live range splitting, an optimization\nfound in extensions to graph coloring and linear scan. Also, it simplifies the\ncompiler, and its semantics-based approach provides possibilities of\nsimplifying the formal verification of compilers.\n", "versions": [{"version": "v1", "created": "Fri, 24 Feb 2012 19:58:26 GMT"}], "update_date": "2012-02-27", "authors_parsed": [["Wang", "Yin", ""], ["Dybvig", "R. Kent", ""]]}, {"id": "1202.5959", "submitter": "Dariusz Biernacki", "authors": "Dariusz Biernacki, Serguei Lenglet", "title": "Normal Form Bisimulations for Delimited-Control Operators", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define a notion of normal form bisimilarity for the untyped call-by-value\nlambda calculus extended with the delimited-control operators shift and reset.\nNormal form bisimilarities are simple, easy-to-use behavioral equivalences\nwhich relate terms without having to test them within all contexts (like\ncontextual equivalence), or by applying them to function arguments (like\napplicative bisimilarity). We prove that the normal form bisimilarity for shift\nand reset is sound but not complete w.r.t. contextual equivalence and we define\nup-to techniques that aim at simplifying bisimulation proofs. Finally, we\nillustrate the simplicity of the techniques we develop by proving several\nequivalences on terms.\n", "versions": [{"version": "v1", "created": "Mon, 27 Feb 2012 14:49:00 GMT"}, {"version": "v2", "created": "Tue, 28 Feb 2012 15:33:59 GMT"}], "update_date": "2012-02-29", "authors_parsed": [["Biernacki", "Dariusz", ""], ["Lenglet", "Serguei", ""]]}, {"id": "1202.6593", "submitter": "Luis Quesada", "authors": "Luis Quesada, Fernando Berzal, Juan-Carlos Cubero", "title": "A Model-Driven Parser Generator, from Abstract Syntax Trees to Abstract\n  Syntax Graphs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Model-based parser generators decouple language specification from language\nprocessing. The model-driven approach avoids the limitations that conventional\nparser generators impose on the language designer. Conventional tools require\nthe designed language grammar to conform to the specific kind of grammar\nsupported by the particular parser generator (being LL and LR parser generators\nthe most common). Model-driven parser generators, like ModelCC, do not require\na grammar specification, since that grammar can be automatically derived from\nthe language model and, if needed, adapted to conform to the requirements of\nthe given kind of parser, all of this without interfering with the conceptual\ndesign of the language and its associated applications. Moreover, model-driven\ntools such as ModelCC are able to automatically resolve references between\nlanguage elements, hence producing abstract syntax graphs instead of abstract\nsyntax trees as the result of the parsing process. Such graphs are not confined\nto directed acyclic graphs and they can contain cycles, since ModelCC supports\nanaphoric, cataphoric, and recursive references.\n", "versions": [{"version": "v1", "created": "Wed, 29 Feb 2012 16:27:06 GMT"}], "update_date": "2012-03-01", "authors_parsed": [["Quesada", "Luis", ""], ["Berzal", "Fernando", ""], ["Cubero", "Juan-Carlos", ""]]}]