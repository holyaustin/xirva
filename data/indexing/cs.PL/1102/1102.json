[{"id": "1102.0155", "submitter": "Wil  Dekkers", "authors": "Wil Dekkers", "title": "Weak mu-equality is decidable", "comments": "11 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we consider the set of mu-types, an extension of the set of\nsimple types freely generated from a set of atomic types and the type\nconstructor ->, by a new operator mu, to explicitly denote solutions of\nrecursive equations like A = A -> beta. We show that this so-called weak\nmu-equality for mu-types is decidable by defining a derivation system for weak\nmu-equality based on standard reduction for mu-types such that the number of\nnodes in a derivation tree for A = B is bounded as a function of A, B. We give\ntwo proofs. One for decidability of = for alpha-equivalence classes of mu-types\nand one for = for mu-types theselves. Both proofs are straightforward and\nelementary.\n", "versions": [{"version": "v1", "created": "Tue, 1 Feb 2011 13:32:26 GMT"}], "update_date": "2011-02-02", "authors_parsed": [["Dekkers", "Wil", ""]]}, {"id": "1102.0705", "submitter": "Jiang Liu", "authors": "Jiang Liu and Naijun Zhan and Hengjun Zhao", "title": "Computing Semi-algebraic Invariants for Polynomial Dynamical Systems", "comments": "28 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we consider an extended concept of invariant for polynomial\ndynamical system (PDS) with domain and initial condition, and establish a sound\nand complete criterion for checking semi-algebraic invariants (SAI) for such\nPDSs. The main idea is encoding relevant dynamical properties as conditions on\nthe high order Lie derivatives of polynomials occurring in the SAI. A direct\nconsequence of this criterion is a relatively complete method of SAI generation\nbased on template assumption and semi-algebraic constraint solving. Relative\ncompleteness means if there is an SAI in the form of a predefined template,\nthen our method can indeed find one using this template.\n", "versions": [{"version": "v1", "created": "Thu, 3 Feb 2011 15:30:53 GMT"}, {"version": "v2", "created": "Thu, 21 Jul 2011 13:36:46 GMT"}], "update_date": "2011-07-22", "authors_parsed": [["Liu", "Jiang", ""], ["Zhan", "Naijun", ""], ["Zhao", "Hengjun", ""]]}, {"id": "1102.0951", "submitter": "Gabriel Kerneis", "authors": "Gabriel Kerneis (PPS), Juliusz Chroboczek (PPS)", "title": "CPC: programming with a massive number of lightweight threads", "comments": "To appear in PLACES'11", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Threads are a convenient and modular abstraction for writing concurrent\nprograms, but often fairly expensive. The standard alternative to threads,\nevent-loop programming, allows much lighter units of concurrency, but leads to\ncode that is difficult to write and even harder to understand. Continuation\nPassing C (CPC) is a translator that converts a program written in threaded\nstyle into a program written with events and native system threads, at the\nprogrammer's choice. Together with two undergraduate students, we taught\nourselves how to program in CPC by writing Hekate, a massively concurrent\nnetwork server designed to efficiently handle tens of thousands of\nsimultaneously connected peers. In this paper, we describe a number of\nprogramming idioms that we learnt while writing Hekate; while some of these\nidioms are specific to CPC, many should be applicable to other programming\nsystems with sufficiently cheap threads.\n", "versions": [{"version": "v1", "created": "Fri, 4 Feb 2011 15:57:48 GMT"}], "update_date": "2011-02-07", "authors_parsed": [["Kerneis", "Gabriel", "", "PPS"], ["Chroboczek", "Juliusz", "", "PPS"]]}, {"id": "1102.1061", "submitter": "Danko Ilik", "authors": "Danko Ilik", "title": "Continuation-passing Style Models Complete for Intuitionistic Logic", "comments": null, "journal-ref": "Annals of Pure and Applied Logic 164(6), 2013", "doi": "10.1016/j.apal.2012.05.003", "report-no": null, "categories": "math.LO cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A class of models is presented, in the form of continuation monads\npolymorphic for first-order individuals, that is sound and complete for minimal\nintuitionistic predicate logic. The proofs of soundness and completeness are\nconstructive and the computational content of their composition is, in\nparticular, a $\\beta$-normalisation-by-evaluation program for simply typed\nlambda calculus with sum types. Although the inspiration comes from Danvy's\ntype-directed partial evaluator for the same lambda calculus, the there\nessential use of delimited control operators (i.e. computational effects) is\navoided. The role of polymorphism is crucial -- dropping it allows one to\nobtain a notion of model complete for classical predicate logic. The connection\nbetween ours and Kripke models is made through a strengthening of the\nDouble-negation Shift schema.\n", "versions": [{"version": "v1", "created": "Sat, 5 Feb 2011 09:11:04 GMT"}, {"version": "v2", "created": "Thu, 3 Mar 2011 20:55:20 GMT"}], "update_date": "2014-11-04", "authors_parsed": [["Ilik", "Danko", ""]]}, {"id": "1102.1178", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "The BinProlog Experience: Architecture and Implementation Choices for\n  Continuation Passing Prolog and First-Class Logic Engines", "comments": "To appear in Theory and Practice of Logic Programming (TPLP);\n  Keywords: Prolog, logic programming system, continuation passing style\n  compilation, implementation of Prolog, first-class logic engines,\n  data-representations for Prolog run-time systems", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe the BinProlog system's compilation technology, runtime system and\nits extensions supporting first-class Logic Engines while providing a short\nhistory of its development, details of some of its newer re-implementations as\nwell as an overview of the most important architectural choices involved in\ntheir design.\n  With focus on its differences with conventional WAM implementations, we\nexplain key details of BinProlog's compilation technique, which replaces the\nWAM with a simplified continuation passing runtime system (the \"BinWAM\"), based\non a mapping of full Prolog to binary logic programs. This is followed by a\ndescription of a term compression technique using a \"tag-on-data\"\nrepresentation.\n  Later derivatives, the Java-based Jinni Prolog compiler and the recently\ndeveloped Lean Prolog system refine the BinProlog architecture with first-class\nLogic Engines, made generic through the use of an Interactor interface. An\noverview of their applications with focus on the ability to express at source\nlevel a wide variety of Prolog built-ins and extensions, covers these newer\ndevelopments.\n", "versions": [{"version": "v1", "created": "Sun, 6 Feb 2011 17:43:54 GMT"}], "update_date": "2011-02-08", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1102.1237", "submitter": "Vadim Zaliva", "authors": "Vadim Zaliva", "title": "Applying static code analysis to firewall policies for the purpose of\n  anomaly detection", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CR cs.NI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Treating modern firewall policy languages as imperative, special purpose\nprogramming languages, in this article we will try to apply static code\nanalysis techniques for the purpose of anomaly detection.\n  We will first abstract a policy in common firewall policy language into an\nintermediate language, and then we will try to apply anomaly detection\nalgorithms to it.\n  The contributions made by this work are:\n  1. An analysis of various control flow instructions in popular firewall\npolicy languages 2. Introduction of an intermediate firewall policy language,\nwith emphasis on control flow constructs. 3. Application of \\textit{Static Code\nAnalysis} to detect anomalies in firewall policy, expressed in intermediate\nfirewall policy language. 4. Sample implementation of \\textit{Static Code\nAnalysis} of firewall policies, expressed in our abstract language using\nDatalog language.\n", "versions": [{"version": "v1", "created": "Mon, 7 Feb 2011 07:26:03 GMT"}], "update_date": "2011-02-08", "authors_parsed": [["Zaliva", "Vadim", ""]]}, {"id": "1102.2003", "submitter": "Paul Stansifer", "authors": "Paul Stansifer and Mitchell Wand", "title": "Parsing Reflective Grammars", "comments": "A shorter version appears in LDTA 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Existing technology can parse arbitrary context-free grammars, but only a\nsingle, static grammar per input. In order to support more powerful\nsyntax-extension systems, we propose reflective grammars, which can modify\ntheir own syntax during parsing. We demonstrate and prove the correctness of an\nalgorithm for parsing reflective grammars. The algorithm is based on Earley's\nalgorithm, and we prove that it performs asymptotically no worse than Earley's\nalgorithm on ordinary context-free grammars.\n", "versions": [{"version": "v1", "created": "Wed, 9 Feb 2011 22:44:26 GMT"}, {"version": "v2", "created": "Fri, 11 Feb 2011 17:03:17 GMT"}], "update_date": "2011-02-14", "authors_parsed": [["Stansifer", "Paul", ""], ["Wand", "Mitchell", ""]]}, {"id": "1102.2262", "submitter": "Siim Karus", "authors": "Siim Karus, Harald Gall", "title": "A Study of Language Usage Evolution in Open Source Software", "comments": "working paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The use of programming languages such as Java and C in Open Source Software\n(OSS) has been well studied. However, many other popular languages such as XSL\nor XML have received minor attention. In this paper, we discuss some trends in\nOSS development that we observed when considering multiple programming language\nevolution of OSS. Based on the revision data of 22 OSS projects, we tracked the\nevolution of language usage and other artefacts such as documentation files,\nbinaries and graphics files. In these systems several different languages and\nartefact types including C/C++, Java, XML, XSL, Makefile, Groovy, HTML, Shell\nscripts, CSS, Graphics files, JavaScript, JSP, Ruby, Phyton, XQuery,\nOpenDocument files, PHP, etc. have been used. We found that the amount of code\nwritten in different languages differs substantially. Some of our findings can\nbe summarized as follows: (1) JavaScript and CSS files most often co-evolve\nwith XSL; (2) Most Java developers but only every second C/C++ developer work\nwith XML; (3) and more generally, we observed a significant increase of usage\nof XML and XSL during recent years and found that Java or C are hardly ever the\nonly language used by a developer. In fact, a developer works with more than 5\ndifferent artefact types (or 4 different languages) in a project on average.\n", "versions": [{"version": "v1", "created": "Fri, 11 Feb 2011 00:09:27 GMT"}], "update_date": "2011-02-14", "authors_parsed": [["Karus", "Siim", ""], ["Gall", "Harald", ""]]}, {"id": "1102.2268", "submitter": "EPTCS", "authors": "Rachid Echahed", "title": "Proceedings 6th International Workshop on Computing with Terms and\n  Graphs", "comments": null, "journal-ref": "EPTCS 48, 2011", "doi": "10.4204/EPTCS.48", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Sixth International Workshop on\nComputing with Terms and Graphs (TERMGRAPH 2011). The workshop took place in\nSaarbruecken, Germany, on April 2nd, 2011, as part of the fourteenth edition of\nthe European Joint Conferences on Theory and Practice of Software (ETAPS 2011).\nResearch in term and graph rewriting ranges from theoretical questions to\npractical issues. Computing with graphs handles the sharing of common\nsubexpressions in a natural and seamless way, and improves the efficiency of\ncomputations in space and time. Sharing is ubiquitous in several research\nareas, for instance : the modelling of first- and higher-order term rewriting\nby (acyclic or cyclic) graph rewriting, the modelling of biological or chemical\nabstract machines, the implementation techniques of programming languages. Term\ngraphs are also used in automated theorem proving and symbolic computation\nsystems working on shared structures. The aim of this workshop is to bring\ntogether researchers working in different domains on term and graph\ntransformation and to foster their interaction, to provide a forum for\npresenting new ideas and work in progress, and to enable newcomers to learn\nabout current activities in term graph rewriting. These proceedings contain six\naccepted papers and the abstracts of three invited talks. All submissions were\nsubject to careful refereeing. The topics of accepted papers range over a wide\nspectrum, including theoretical aspects of term graph rewriting, proof methods,\nsemantics as well as application issues of term graph transformation.\n", "versions": [{"version": "v1", "created": "Fri, 11 Feb 2011 02:27:39 GMT"}], "update_date": "2011-02-14", "authors_parsed": [["Echahed", "Rachid", ""]]}, {"id": "1102.2330", "submitter": "Thomas Wahl", "authors": "Alastair Donaldson and Alexander Kaiser and Daniel Kroening and Thomas\n  Wahl", "title": "Symmetry-Aware Predicate Abstraction for Shared-Variable Concurrent\n  Programs (Extended Technical Report)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Predicate abstraction is a key enabling technology for applying finite-state\nmodel checkers to programs written in mainstream languages. It has been used\nvery successfully for debugging sequential system-level C code. Although model\nchecking was originally designed for analyzing concurrent systems, there is\nlittle evidence of fruitful applications of predicate abstraction to\nshared-variable concurrent software. The goal of this paper is to close this\ngap. We have developed a symmetry-aware predicate abstraction strategy: it\ntakes into account the replicated structure of C programs that consist of many\nthreads executing the same procedure, and generates a Boolean program template\nwhose multi-threaded execution soundly overapproximates the concurrent C\nprogram. State explosion during model checking parallel instantiations of this\ntemplate can now be absorbed by exploiting symmetry. We have implemented our\nmethod in the SATABS predicate abstraction framework, and demonstrate its\nsuperior performance over alternative approaches on a large range of\nsynchronization programs.\n", "versions": [{"version": "v1", "created": "Fri, 11 Feb 2011 11:31:23 GMT"}], "update_date": "2015-03-18", "authors_parsed": [["Donaldson", "Alastair", ""], ["Kaiser", "Alexander", ""], ["Kroening", "Daniel", ""], ["Wahl", "Thomas", ""]]}, {"id": "1102.2339", "submitter": "Roberto Amadio", "authors": "Roberto Amadio (PPS)", "title": "A decompilation of the pi-calculus and its application to termination", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the correspondence between a concurrent lambda-calculus in\nadministrative, continuation passing style and a pi-calculus and we derive a\ntermination result for the latter.\n", "versions": [{"version": "v1", "created": "Fri, 11 Feb 2011 12:53:14 GMT"}], "update_date": "2011-02-14", "authors_parsed": [["Amadio", "Roberto", "", "PPS"]]}, {"id": "1102.2653", "submitter": "EPTCS", "authors": "Wolfram Kahl (McMaster University)", "title": "Dependently-Typed Formalisation of Typed Term Graphs", "comments": "In Proceedings TERMGRAPH 2011, arXiv:1102.2268", "journal-ref": "EPTCS 48, 2011, pp. 38-53", "doi": "10.4204/EPTCS.48.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We employ the dependently-typed programming language Agda2 to explore\nformalisation of untyped and typed term graphs directly as set-based graph\nstructures, via the gs-monoidal categories of Corradini and Gadducci, and as\nnested let-expressions using Pouillard and Pottier's NotSoFresh library of\nvariable-binding abstractions.\n", "versions": [{"version": "v1", "created": "Mon, 14 Feb 2011 01:09:34 GMT"}], "update_date": "2011-02-15", "authors_parsed": [["Kahl", "Wolfram", "", "McMaster University"]]}, {"id": "1102.2656", "submitter": "EPTCS", "authors": "Jan Rochel (Utrecht University, The Netherlands), Clemens Grabmayer\n  (Utrecht University, The Netherlands)", "title": "Repetitive Reduction Patterns in Lambda Calculus with letrec (Work in\n  Progress)", "comments": "In Proceedings TERMGRAPH 2011, arXiv:1102.2268", "journal-ref": "EPTCS 48, 2011, pp. 85-100", "doi": "10.4204/EPTCS.48.9", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For the lambda-calculus with letrec we develop an optimisation, which is\nbased on the contraction of a certain class of 'future' (also: virtual)\nredexes.\n  In the implementation of functional programming languages it is common\npractice to perform beta-reductions at compile time whenever possible in order\nto produce code that requires fewer reductions at run time. This is, however,\nin principle limited to redexes and created redexes that are 'visible' (in the\nsense that they can be contracted without the need for unsharing), and cannot\ngenerally be extended to redexes that are concealed by sharing constructs such\nas letrec. In the case of recursion, concealed redexes become visible only\nafter unwindings during evaluation, and then have to be contracted time and\nagain.\n  We observe that in some cases such redexes exhibit a certain form of\nrepetitive behaviour at run time. We describe an analysis for identifying\nbinders that give rise to such repetitive reduction patterns, and eliminate\nthem by a sort of predictive contraction. Thereby these binders are lifted out\nof recursive positions or eliminated altogether, as a result alleviating the\namount of beta-reductions required for each recursive iteration.\n  Both our analysis and simplification are suitable to be integrated into\nexisting compilers for functional programming languages as an additional\noptimisation phase. With this work we hope to contribute to increasing the\nefficiency of executing programs written in such languages.\n", "versions": [{"version": "v1", "created": "Mon, 14 Feb 2011 01:09:58 GMT"}], "update_date": "2011-02-15", "authors_parsed": [["Rochel", "Jan", "", "Utrecht University, The Netherlands"], ["Grabmayer", "Clemens", "", "Utrecht University, The Netherlands"]]}, {"id": "1102.3129", "submitter": "Georg Moser", "authors": "Nao Hirokawa, Georg Moser", "title": "Automated Complexity Analysis Based on the Dependency Pair Method", "comments": "37 pages, submitted to Information & Computation", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.CC cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  This article is concerned with automated complexity analysis of term rewrite\nsystems. Since these systems underlie much of declarative programming, time\ncomplexity of functions defined by rewrite systems is of particular interest.\nAmong other results, we present a variant of the dependency pair method for\nanalysing runtime complexities of term rewrite systems automatically. The\nestablished results significantly extent previously known techniques: we give\nexamples of rewrite systems subject to our methods that could previously not\nbeen analysed automatically. Furthermore, the techniques have been implemented\nin the Tyrolean Complexity Tool. We provide ample numerical data for assessing\nthe viability of the method.\n", "versions": [{"version": "v1", "created": "Tue, 15 Feb 2011 17:16:23 GMT"}, {"version": "v2", "created": "Wed, 1 Jun 2011 18:19:59 GMT"}], "update_date": "2011-06-02", "authors_parsed": [["Hirokawa", "Nao", ""], ["Moser", "Georg", ""]]}, {"id": "1102.3420", "submitter": "Wouter Kuijper", "authors": "Wouter Kuijper, Michael Weber", "title": "Generic Programming of Reusable, High Performance Container Types using\n  Automatic Type Hierarchy Inference and Bidirectional Antichain Typing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new compile-time notion of type subsumption based on type\nsimulation. We show how to apply this static subsumption relation to support a\nmore intuitive, object oriented approach to generic programming of reusable,\nhigh performance container types. As a first step towards an efficient\nimplementation of the resulting type system in a compiler we present a novel\nalgorithm for bidirectional type inference over arbitrary syntax graphs. The\nalgorithm uses the new static type subsumption relation to compress the data\nthat has to be stored for each node in the typeflow graph. During typeflow\nanalysis this means that the set of types for a given node can be symbolically\nrepresented using antichains instead of using bitvectors or some other explicit\nset representation. This results in a typing algorithm that is both flexible\nand precise and shows good performance on representative instances.\n", "versions": [{"version": "v1", "created": "Wed, 16 Feb 2011 20:34:21 GMT"}], "update_date": "2011-02-17", "authors_parsed": [["Kuijper", "Wouter", ""], ["Weber", "Michael", ""]]}, {"id": "1102.3465", "submitter": "EPTCS", "authors": "Eduardo Bonelli (Universidad Nacional de Quilmes)", "title": "Proceedings 5th International Workshop on Higher-Order Rewriting", "comments": null, "journal-ref": "EPTCS 49, 2011", "doi": "10.4204/EPTCS.49", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  HOR 2010 is a forum to present work concerning all aspects of higher-order\nrewriting. The aim is to provide an informal and friendly setting to discuss\nrecent work and work in progress. Previous editions of HOR were held in\nCopenhagen - Denmark (HOR 2002), Aachen - Germany (HOR 2004), Seattle - USA\n(HOR 2006) and Paris - France (HOR 2007).\n", "versions": [{"version": "v1", "created": "Thu, 17 Feb 2011 01:14:50 GMT"}], "update_date": "2011-02-18", "authors_parsed": [["Bonelli", "Eduardo", "", "Universidad Nacional de Quilmes"]]}, {"id": "1102.3676", "submitter": "Dimitrios Vardoulakis", "authors": "Dimitrios Vardoulakis (Northeastern University), Olin Shivers\n  (Northeastern University)", "title": "CFA2: a Context-Free Approach to Control-Flow Analysis", "comments": "LMCS 7 (2:3) 2011", "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 2 (May 1,\n  2011) lmcs:684", "doi": "10.2168/LMCS-7(2:3)2011", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a functional language, the dominant control-flow mechanism is function\ncall and return. Most higher-order flow analyses, including k-CFA, do not\nhandle call and return well: they remember only a bounded number of pending\ncalls because they approximate programs with control-flow graphs. Call/return\nmismatch introduces precision-degrading spurious control-flow paths and\nincreases the analysis time. We describe CFA2, the first flow analysis with\nprecise call/return matching in the presence of higher-order functions and tail\ncalls. We formulate CFA2 as an abstract interpretation of programs in\ncontinuation-passing style and describe a sound and complete summarization\nalgorithm for our abstract semantics. A preliminary evaluation shows that CFA2\ngives more accurate data-flow information than 0CFA and 1CFA.\n", "versions": [{"version": "v1", "created": "Thu, 17 Feb 2011 19:59:51 GMT"}, {"version": "v2", "created": "Mon, 28 Mar 2011 18:33:31 GMT"}, {"version": "v3", "created": "Fri, 22 Apr 2011 07:37:22 GMT"}, {"version": "v4", "created": "Wed, 4 May 2011 16:56:52 GMT"}, {"version": "v5", "created": "Thu, 5 May 2011 09:05:54 GMT"}, {"version": "v6", "created": "Mon, 23 Apr 2012 18:47:23 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Vardoulakis", "Dimitrios", "", "Northeastern University"], ["Shivers", "Olin", "", "Northeastern University"]]}, {"id": "1102.3730", "submitter": "EPTCS", "authors": "Ariel Mendelzon (Departamento de Computaci\\'on, FCEyN, Universidad de\n  Buenos Aires), Alejandro R\\'ios (Departamento de Computaci\\'on, FCEyN,\n  Universidad de Buenos Aires), Beta Ziliani (Departamento de Computaci\\'on,\n  FCEyN, Universidad de Buenos Aires)", "title": "Swapping: a natural bridge between named and indexed explicit\n  substitution calculi", "comments": "In Proceedings HOR 2010, arXiv:1102.3465", "journal-ref": "EPTCS 49, 2011, pp. 1-15", "doi": "10.4204/EPTCS.49.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article is devoted to the presentation of lambda_rex, an explicit\nsubstitution calculus with de Bruijn indexes and a simple notation. By being\nisomorphic to lambda_ex - a recent formalism with variable names -, lambda_rex\naccomplishes simulation of beta-reduction (Sim), preservation of beta-strong\nnormalization (PSN) and meta-confluence (MC), among other desirable properties.\nOur calculus is based on a novel presentation of lambda_dB, using a swap notion\nthat was originally devised by de Bruijn. Besides lambda_rex, two other indexed\ncalculi isomorphic to lambda_x and lambda_xgc are presented, demonstrating the\npotential of our technique when applied to the design of indexed versions of\nknown named calculi.\n", "versions": [{"version": "v1", "created": "Fri, 18 Feb 2011 01:44:20 GMT"}], "update_date": "2011-02-21", "authors_parsed": [["Mendelzon", "Ariel", "", "Departamento de Computaci\u00f3n, FCEyN, Universidad de\n  Buenos Aires"], ["R\u00edos", "Alejandro", "", "Departamento de Computaci\u00f3n, FCEyN,\n  Universidad de Buenos Aires"], ["Ziliani", "Beta", "", "Departamento de Computaci\u00f3n,\n  FCEyN, Universidad de Buenos Aires"]]}, {"id": "1102.3731", "submitter": "EPTCS", "authors": "Thibaut Balabonski (PPS, Paris, France)", "title": "On the Implementation of Dynamic Patterns", "comments": "In Proceedings HOR 2010, arXiv:1102.3465", "journal-ref": "EPTCS 49, 2011, pp. 16-30", "doi": "10.4204/EPTCS.49.2", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The evaluation mechanism of pattern matching with dynamic patterns is\nmodelled in the Pure Pattern Calculus by one single meta-rule. This\ncontribution presents a refinement which narrows the gap between the abstract\ncalculus and its implementation. A calculus is designed to allow reasoning on\nmatching algorithms. The new calculus is proved to be confluent, and to\nsimulate the original Pure Pattern Calculus. A family of new, matching-driven,\nreduction strategies is proposed.\n", "versions": [{"version": "v1", "created": "Fri, 18 Feb 2011 01:44:25 GMT"}], "update_date": "2011-02-21", "authors_parsed": [["Balabonski", "Thibaut", "", "PPS, Paris, France"]]}, {"id": "1102.3732", "submitter": "EPTCS", "authors": "Kristoffer H. Rose (IBM T.J. Watson Research Center)", "title": "Higher-order Rewriting for Executable Compiler Specifications", "comments": "In Proceedings HOR 2010, arXiv:1102.3465", "journal-ref": "EPTCS 49, 2011, pp. 31-45", "doi": "10.4204/EPTCS.49.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we outline how a simple compiler can be completely specified\nusing higher order rewriting in all stages: parsing, analysis/optimization, and\ncode emission, specifically using the crsx.sf.net system for a small\ndeclarative language called \"X\" inspired by XQuery (for which we are building a\nproduction quality compiler in the same way).\n", "versions": [{"version": "v1", "created": "Fri, 18 Feb 2011 01:44:32 GMT"}], "update_date": "2011-02-21", "authors_parsed": [["Rose", "Kristoffer H.", "", "IBM T.J. Watson Research Center"]]}, {"id": "1102.3734", "submitter": "EPTCS", "authors": "Delia Kesner (PPS, CNRS and Universite Paris Diderot - France), Carlos\n  Lombardi (Universidad Nacional de Quilmes - Argentina), Alejandro R\\'ios\n  (Universidad de Buenos Aires - Argentina)", "title": "A standardisation proof for algebraic pattern calculi", "comments": "In Proceedings HOR 2010, arXiv:1102.3465", "journal-ref": "EPTCS 49, 2011, pp. 58-72", "doi": "10.4204/EPTCS.49.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work gives some insights and results on standardisation for call-by-name\npattern calculi. More precisely, we define standard reductions for a pattern\ncalculus with constructor-based data terms and patterns. This notion is based\non reduction steps that are needed to match an argument with respect to a given\npattern. We prove the Standardisation Theorem by using the technique developed\nby Takahashi and Crary for lambda-calculus. The proof is based on the fact that\nany development can be specified as a sequence of head steps followed by\ninternal reductions, i.e. reductions in which no head steps are involved.\n", "versions": [{"version": "v1", "created": "Fri, 18 Feb 2011 01:44:45 GMT"}], "update_date": "2011-02-21", "authors_parsed": [["Kesner", "Delia", "", "PPS, CNRS and Universite Paris Diderot - France"], ["Lombardi", "Carlos", "", "Universidad Nacional de Quilmes - Argentina"], ["R\u00edos", "Alejandro", "", "Universidad de Buenos Aires - Argentina"]]}, {"id": "1102.3896", "submitter": "V\\'itor Santos Costa", "authors": "V\\'itor Santos Costa, Lu\\'is Damas, Ricardo Rocha", "title": "The YAP Prolog System", "comments": "30 pages, 2 figures. To appear in Theory and Practice of Logic\n  Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Yet Another Prolog (YAP) is a Prolog system originally developed in the\nmid-eighties and that has been under almost constant development since then.\nThis paper presents the general structure and design of the YAP system,\nfocusing on three important contributions to the Logic Programming community.\nFirst, it describes the main techniques used in YAP to achieve an efficient\nProlog engine. Second, most Logic Programming systems have a rather limited\nindexing algorithm. YAP contributes to this area by providing a dynamic\nindexing mechanism, or just-in-time indexer (JITI). Third, a important\ncontribution of the YAP system has been the integration of both or-parallelism\nand tabling in a single Logic Programming system.\n", "versions": [{"version": "v1", "created": "Fri, 18 Feb 2011 19:57:18 GMT"}], "update_date": "2011-02-21", "authors_parsed": [["Costa", "V\u00edtor Santos", ""], ["Damas", "Lu\u00eds", ""], ["Rocha", "Ricardo", ""]]}, {"id": "1102.4563", "submitter": "Mikal Ziane", "authors": "Ulrik P. Schultz, Serge Stinckwich, Mikal Ziane", "title": "Proceedings of the first international workshop on domain-specific\n  languages for robotic systems (DSLRob 2010)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.RO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The First International Workshop on Domain-Specific Languages and models for\nROBotic systems (DSLRob'10) was held at the 2010 IEEE/RSJ International\nConference on Intelligent Robots and Systems (IROS'10), October 2010 in Taipei,\nTaiwan.\n  The main topics of the workshop were domain-specific languages and models. A\ndomain-specific language (DSL) is a programming language dedicated to a\nparticular problem domain that offers specific notations and abstractions that\nincrease programmer productivity within that domain. Models offer a high-level\nway for domain users to specify the functionality of their system at the right\nlevel of abstraction. DSLs and models have historically been used for\nprogramming complex systems. However recently they have garnered interest as a\nseparate field of study. Robotic systems blend hardware and software in a\nholistic way that intrinsically raises many crosscutting concerns (concurrency,\nuncertainty, time constraints, ...), for which reason, traditional\ngeneral-purpose languages often lead to a poor fit between the language\nfeatures and the implementation requirements. DSLs and models offer a powerful,\nsystematic way to overcome this problem, enabling the programmer to quickly and\nprecisely implement novel software solutions to complex problems within the\nrobotics domain.\n", "versions": [{"version": "v1", "created": "Tue, 22 Feb 2011 17:28:21 GMT"}], "update_date": "2011-02-23", "authors_parsed": [["Schultz", "Ulrik P.", ""], ["Stinckwich", "Serge", ""], ["Ziane", "Mikal", ""]]}, {"id": "1102.4971", "submitter": "Antoine Madet", "authors": "Antoine Madet (PPS), Roberto M. Amadio (PPS)", "title": "Elementary affine $lambda$-calculus with multithreading and side effects", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linear logic provides a framework to control the complexity of higher-order\nfunctional programs. We present an extension of this framework to programs with\nmultithreading and side effects focusing on the case of elementary time. Our\nmain contributions are as follows. First, we provide a new combinatorial proof\nof termination in elementary time for the functional case. Second, we develop\nan extension of the approach to a call-by-value $lambda$-calculus with\nmultithreading and side effects. Third, we introduce an elementary affine type\nsystem that guarantees the standard subject reduction and progress properties.\nFinally, we illustrate the programming of iterative functions with side effects\nin the presented formalism.\n", "versions": [{"version": "v1", "created": "Thu, 24 Feb 2011 12:28:36 GMT"}, {"version": "v2", "created": "Fri, 10 Jun 2011 14:32:34 GMT"}], "update_date": "2011-06-13", "authors_parsed": [["Madet", "Antoine", "", "PPS"], ["Amadio", "Roberto M.", "", "PPS"]]}, {"id": "1102.5497", "submitter": "Manuel Hermenegildo", "authors": "M. V. Hermenegildo, F. Bueno, M. Carro, P. L\\'opez-Garc\\'ia, E. Mera,\n  J. F. Morales, and G. Puebla", "title": "An overview of Ciao and its design philosophy", "comments": "Number of pages: 30, Number of figures: 14, Number of tables: 0.\n  Accepted for publication in TPLP (CUP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide an overall description of the Ciao multiparadigm programming\nsystem emphasizing some of the novel aspects and motivations behind its design\nand implementation. An important aspect of Ciao is that, in addition to\nsupporting logic programming (and, in particular, Prolog), it provides the\nprogrammer with a large number of useful features from different programming\nparadigms and styles, and that the use of each of these features (including\nthose of Prolog) can be turned on and off at will for each program module.\nThus, a given module may be using, e.g., higher order functions and\nconstraints, while another module may be using assignment, predicates, Prolog\nmeta-programming, and concurrency. Furthermore, the language is designed to be\nextensible in a simple and modular way. Another important aspect of Ciao is its\nprogramming environment, which provides a powerful preprocessor (with an\nassociated assertion language) capable of statically finding non-trivial bugs,\nverifying that programs comply with specifications, and performing many types\nof optimizations (including automatic parallelization). Such optimizations\nproduce code that is highly competitive with other dynamic languages or, with\nthe (experimental) optimizing compiler, even that of static languages, all\nwhile retaining the flexibility and interactive development of a dynamic\nlanguage. This compilation architecture supports modularity and separate\ncompilation throughout. The environment also includes a powerful\nauto-documenter and a unit testing framework, both closely integrated with the\nassertion system. The paper provides an informal overview of the language and\nprogram development environment. It aims at illustrating the design philosophy\nrather than at being exhaustive, which would be impossible in a single journal\npaper, pointing instead to previous Ciao literature.\n", "versions": [{"version": "v1", "created": "Sun, 27 Feb 2011 12:30:12 GMT"}], "update_date": "2011-03-01", "authors_parsed": [["Hermenegildo", "M. V.", ""], ["Bueno", "F.", ""], ["Carro", "M.", ""], ["L\u00f3pez-Garc\u00eda", "P.", ""], ["Mera", "E.", ""], ["Morales", "J. F.", ""], ["Puebla", "G.", ""]]}]