[{"id": "1310.0263", "submitter": "Noam Zeilberger", "authors": "Paul-Andr\\'e Melli\\`es and Noam Zeilberger", "title": "Type refinement and monoidal closed bifibrations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The concept of_refinement_ in type theory is a way of reconciling the\n\"intrinsic\" and the \"extrinsic\" meanings of types. We begin with a rigorous\nanalysis of this concept, settling on the simple conclusion that the\ntype-theoretic notion of \"type refinement system\" may be identified with the\ncategory-theoretic notion of \"functor\". We then use this correspondence to give\nan equivalent type-theoretic formulation of Grothendieck's definition of\n(bi)fibration, and extend this to a definition of_monoidal closed\nbifibrations_, which we see as a natural space in which to study the properties\nof proofs and programs. Our main result is a representation theorem for strong\nmonads on a monoidal closed fibration, describing sufficient conditions for a\nmonad to be isomorphic to a continuations monad \"up to pullback\".\n", "versions": [{"version": "v1", "created": "Tue, 1 Oct 2013 12:13:52 GMT"}], "update_date": "2013-10-02", "authors_parsed": [["Melli\u00e8s", "Paul-Andr\u00e9", ""], ["Zeilberger", "Noam", ""]]}, {"id": "1310.0794", "submitter": "Jean-Guillaume Dumas", "authors": "Jean-Guillaume Dumas (LJK), Dominique Duval (LJK), Burak Ekici (LJK),\n  Damien Pous (LIP)", "title": "Formal verification in Coq of program properties involving the global\n  state effect", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The syntax of an imperative language does not mention explicitly the state,\nwhile its denotational semantics has to mention it. In this paper we present a\nframework for the verification in Coq of properties of programs manipulating\nthe global state effect. These properties are expressed in a proof system which\nis close to the syntax, as in effect systems, in the sense that the state does\nnot appear explicitly in the type of expressions which manipulate it. Rather,\nthe state appears via decorations added to terms and to equations. In this\nsystem, proofs of programs thus present two aspects: properties can be verified\n{\\em up to effects} or the effects can be taken into account. The design of our\nCoq library consequently reflects these two aspects: our framework is centered\naround the construction of two inductive and dependent types, one for terms up\nto effects and one for the manipulation of decorations.\n", "versions": [{"version": "v1", "created": "Wed, 2 Oct 2013 18:52:45 GMT"}, {"version": "v2", "created": "Mon, 14 Oct 2013 06:24:12 GMT"}], "update_date": "2013-10-15", "authors_parsed": [["Dumas", "Jean-Guillaume", "", "LJK"], ["Duval", "Dominique", "", "LJK"], ["Ekici", "Burak", "", "LJK"], ["Pous", "Damien", "", "LIP"]]}, {"id": "1310.0802", "submitter": "Gordana Rakic", "authors": "Gordana Raki\\'c and Zoran Budimac", "title": "Introducing Enriched Concrete Syntax Trees", "comments": "14th International Multiconference on Information Society (IS),\n  Collaboration, Software And Services In Information Society (CSS), October\n  10-14, 2011, Ljubljana", "journal-ref": "In Proc. of the 14th International Multiconference on Information\n  Society (IS), Collaboration, Software And Services In Information Society\n  (CSS), October 10-14, 2011, Ljubljana, Slovenia, Volume A, pp. 211-214", "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In our earlier research an area of consistent and systematic application of\nsoftware metrics was explored. Strong dependency of applicability of software\nmetrics on input programming language was recognized as one of the main\nweaknesses in this field. Introducing enriched Concrete Syntax Tree (eCST) for\ninternal and intermediate representation of the source code resulted with step\nforward over this weakness. In this paper we explain innovation made by\nintroducing eCST and provide idea for broader applicability of eCST in some\nother fields of software engineering.\n", "versions": [{"version": "v1", "created": "Wed, 2 Oct 2013 19:39:11 GMT"}], "update_date": "2013-10-03", "authors_parsed": [["Raki\u0107", "Gordana", ""], ["Budimac", "Zoran", ""]]}, {"id": "1310.0867", "submitter": "Zheng Dong", "authors": "Zheng Dong and Arjmand Samuel", "title": "Touch-enabled Programming for the Lab of Things", "comments": "3 pages, 3 figures, PROMOTO 2013, 1309.5500", "journal-ref": null, "doi": null, "report-no": "PrMoTo/2013/06", "categories": "cs.PL cs.HC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Lab of Things (LoT, lab-of-things.com) is a research platform for\ninterconnection, programming, and large scale deployment of devices and\nsensors. These devices and sensors can then be used for deployment of field\nstudies in a variety of research areas including elderly care, energy\nmanagement, and the like. LoT is built on top of HomeOS, a middle-ware\ncomponent, making interconnection of a wide range of devices possible. LoT also\nprovides cloud storage and remote monitoring capabilities. Traditionally\nprogramming on the LoT platform has been done using C# in Microsoft Visual\nStudio. While LoT programs developed on the .NET framework offer a rich set of\nfunctionality, writing programs on LoT can be challenging for developers who\nare not experienced with the technology involved. In this demonstration, we\nintroduce an innovative programming approach on the LoT platform by building a\nGeneric Application and creating corresponding libraries on the user-friendly\nTouchDevelop (touchdevelop.com) programming environment. As an example, we\nimplemented the same functionality of the Lab of Things Alerts application\nusing the new Generic App. In addition to a touch-enabled programming\nenvironment, the new approach also significantly saves time and effort\ndevelopers have to devote when creating a customized Lab of Things application.\n", "versions": [{"version": "v1", "created": "Thu, 3 Oct 2013 00:21:53 GMT"}], "update_date": "2013-10-04", "authors_parsed": [["Dong", "Zheng", ""], ["Samuel", "Arjmand", ""]]}, {"id": "1310.0901", "submitter": "Jose Gracia", "authors": "Thomas M. Baumann, Jose Gracia", "title": "Cudagrind: A Valgrind Extension for CUDA", "comments": "10 pages, 2 figures, accepted for publication in ParCo 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.OS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Valgrind, and specifically the included tool Memcheck, offers an easy and\nreliable way for checking the correctness of memory operations in programs.\nThis works in an unintrusive way where Valgrind translates the program into\nintermediate code and executes it on an emulated CPU. The heavy weight tool\nMemcheck uses this to keep a full shadow copy of the memory used by a program\nand tracking accesses to it. This allows the detection of memory leaks and\nchecking the validity of accesses.\n  Though suited for a wide variety of programs, this approach still fails when\naccelerator based programming models are involved. The code running on these\ndevices is separate from the code running on the host. Access to memory on the\ndevice and starting of kernels is being handled by an API provided by the\ndriver being used. Hence Valgrind is unable to understand and instrument\noperations being run on the device.\n  To circumvent this limitation a new set of wrapper functions have been\nintroduced. These wrap a subset of the CUDA Driver API function that is\nresponsible for (de-)allocation memory regions on the device and the respective\nmemory copy operations. This allows to check whether memory is fully allocated\nduring a transfer and, through the functionality provided by Valgrind, whether\nthe memory transfered to the device from the host is defined and addressable.\nThrough this technique it is possible to detect a number of common programming\nmistakes, which are very difficult to debug by other means. The combination of\nthese wrappers together with the Valgrind tool Memcheck is being called\nCudagrind.\n", "versions": [{"version": "v1", "created": "Thu, 3 Oct 2013 05:51:48 GMT"}], "update_date": "2013-10-04", "authors_parsed": [["Baumann", "Thomas M.", ""], ["Gracia", "Jose", ""]]}, {"id": "1310.1763", "submitter": "Ugo Dal Lago", "authors": "Ugo Dal Lago, Giulio Pellitta", "title": "Complexity Analysis in Presence of Control Operators and Higher-Order\n  Functions (Long Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A polarized version of Girard, Scedrov and Scott's Bounded Linear Logic is\nintroduced and its normalization properties studied. Following Laurent, the\nlogic naturally gives rise to a type system for the lambda-mu-calculus, whose\nderivations reveal bounds on the time complexity of the underlying term. This\nis the first example of a type system for the lambda-mu-calculus guaranteeing\ntime complexity bounds for typable programs.\n", "versions": [{"version": "v1", "created": "Mon, 7 Oct 2013 12:55:05 GMT"}], "update_date": "2013-10-08", "authors_parsed": [["Lago", "Ugo Dal", ""], ["Pellitta", "Giulio", ""]]}, {"id": "1310.2300", "submitter": "Stefan Brunthaler", "authors": "Stefan Brunthaler", "title": "Speculative Staging for Interpreter Optimization", "comments": "16 pages, 4 figures, 3 tables. Uses CPython 3.2.3 and PyPy 1.9", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Interpreters have a bad reputation for having lower performance than\njust-in-time compilers. We present a new way of building high performance\ninterpreters that is particularly effective for executing dynamically typed\nprogramming languages. The key idea is to combine speculative staging of\noptimized interpreter instructions with a novel technique of incrementally and\niteratively concerting them at run-time.\n  This paper introduces the concepts behind deriving optimized instructions\nfrom existing interpreter instructions---incrementally peeling off layers of\ncomplexity. When compiling the interpreter, these optimized derivatives will be\ncompiled along with the original interpreter instructions. Therefore, our\ntechnique is portable by construction since it leverages the existing\ncompiler's backend. At run-time we use instruction substitution from the\ninterpreter's original and expensive instructions to optimized instruction\nderivatives to speed up execution.\n  Our technique unites high performance with the simplicity and portability of\ninterpreters---we report that our optimization makes the CPython interpreter up\nto more than four times faster, where our interpreter closes the gap between\nand sometimes even outperforms PyPy's just-in-time compiler.\n", "versions": [{"version": "v1", "created": "Tue, 8 Oct 2013 22:44:44 GMT"}], "update_date": "2013-10-10", "authors_parsed": [["Brunthaler", "Stefan", ""]]}, {"id": "1310.2741", "submitter": "Lse Lse", "authors": "Guido Chari (LAFHIS), Diego Garbervetsky (LAFHIS), Camillo Bruni\n  (INRIA Lille - Nord Europe), Marcus Denker (INRIA Lille - Nord Europe),\n  St\\'ephane Ducasse (INRIA Lille - Nord Europe)", "title": "Waterfall: Primitives Generation on the Fly", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modern languages are typically supported by managed runtimes (Virtual\nMachines). Since VMs have to deal with many concepts such as memory management,\nabstract execution model and scheduling, they tend to be very complex.\nAdditionally, VMs have to meet strong performance requirements. This demand of\nperformance is one of the main reasons why many VMs are built statically. Thus,\ndesign decisions are frozen at compile time preventing changes at runtime. One\nclear example is the impossibility to dynamically adapt or change primitives of\nthe VM once it has been compiled. In this work we present a toolchain that\nallows for altering and configuring components such as primitives and plug-ins\nat runtime. The main contribution is Waterfall, a dynamic and reflective\ntranslator from Slang, a restricted subset of Smalltalk, to native code.\nWaterfall generates primitives on demand and executes them on the fly. We\nvalidate our approach by implementing dynamic primitive modification and\nruntime customization of VM plug-ins.\n", "versions": [{"version": "v1", "created": "Thu, 10 Oct 2013 09:24:15 GMT"}], "update_date": "2013-10-11", "authors_parsed": [["Chari", "Guido", "", "LAFHIS"], ["Garbervetsky", "Diego", "", "LAFHIS"], ["Bruni", "Camillo", "", "INRIA Lille - Nord Europe"], ["Denker", "Marcus", "", "INRIA Lille - Nord Europe"], ["Ducasse", "St\u00e9phane", "", "INRIA Lille - Nord Europe"]]}, {"id": "1310.2923", "submitter": "Haipeng Cai", "authors": "Haipeng Cai, Jian Chen, Alexander P. Auchus, and David H. Laidlaw", "title": "Composing DTI Visualizations with End-user Programming", "comments": "11 pages, 9 figures, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GR cs.HC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present the design and prototype implementation of a scientific\nvisualization language called Zifazah for composing 3D visualizations of\ndiffusion tensor magnetic resonance imaging (DT-MRI or DTI) data. Unlike\nexisting tools allowing flexible customization of data visualizations that are\nprogrammer-oriented, we focus on domain scientists as end users in order to\nenable them to freely compose visualizations of their scientific data set. We\nanalyzed end-user descriptions extracted from interviews with neurologists and\nphysicians conducting clinical practices using DTI about how they would build\nand use DTI visualizations to collect syntax and semantics for the language\ndesign, and have discovered the elements and structure of the proposed\nlanguage. Zifazah makes use of the initial set of lexical terms and semantics\nto provide a declarative language in the spirit of intuitive syntax and usage.\nThis work contributes three, among others, main design principles for\nscientific visualization language design as well as a practice of such language\nfor DTI visualization with Zifazah. First, Zifazah incorporated visual symbolic\nmapping based on color, size and shape, which is a sub-set of Bertin's taxonomy\nmigrated to scientific visualizations. Second, Zifazah is defined as a spatial\nlanguage whereby lexical representation of spatial relationship for 3D object\nvisualization and manipulations, which is characteristic of scientific data,\ncan be programmed. Third, built on top of Bertin's semiology, flexible data\nencoding specifically for scientific visualizations is integrated in our\nlanguage in order to allow end users to achieve optimal visual composition at\ntheir best. Along with sample scripts representative of our language design\nfeatures, some new DTI visualizations as the running results created by end\nusers using the novel visualization language have also been presented.\n", "versions": [{"version": "v1", "created": "Thu, 10 Oct 2013 19:16:17 GMT"}], "update_date": "2013-10-11", "authors_parsed": [["Cai", "Haipeng", ""], ["Chen", "Jian", ""], ["Auchus", "Alexander P.", ""], ["Laidlaw", "David H.", ""]]}, {"id": "1310.3404", "submitter": "Gabriel Kerneis", "authors": "Gabriel Kerneis and Charlie Shepherd and Stefan Hajnoczi", "title": "QEMU/CPC: Static Analysis and CPS Conversion for Safe, Portable, and\n  Efficient Coroutines", "comments": "12 pages", "journal-ref": "Proceedings of the ACM SIGPLAN 2014 Workshop on Partial Evaluation\n  and Program Manipulation, PEPM 2014, San Diego, CA, USA, January 20-21, 2014.\n  ACM 2014", "doi": "10.1145/2543728.2543733", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Coroutines and events are two common abstractions for writing concurrent\nprograms. Because coroutines are often more convenient, but events more\nportable and efficient, it is natural to want to translate the former into the\nlatter. CPC is such a source-to-source translator for C programs, based on a\npartial conversion into continuation-passing style (CPS conversion) of\nfunctions annotated as cooperative.\n  In this article, we study the application of the CPC translator to QEMU, an\nopen-source machine emulator which also uses annotated coroutine functions for\nconcurrency. We first propose a new type of annotations to identify functions\nwhich never cooperate, and we introduce CoroCheck, a tool for the static\nanalysis and inference of cooperation annotations. Then, we improve the CPC\ntranslator, defining CPS conversion as a calling convention for the C language,\nwith support for indirect calls to CPS-converted function through function\npointers. Finally, we apply CoroCheck and CPC to QEMU (750 000 lines of C\ncode), fixing hundreds of missing annotations and comparing performance of the\ntranslated code with existing implementations of coroutines in QEMU.\n  Our work shows the importance of static annotation checking to prevent actual\nconcurrency bugs, and demonstrates that CPS conversion is a flexible, portable,\nand efficient compilation technique, even for very large programs written in an\nimperative language.\n", "versions": [{"version": "v1", "created": "Sat, 12 Oct 2013 16:46:28 GMT"}, {"version": "v2", "created": "Wed, 20 Nov 2013 10:35:31 GMT"}], "update_date": "2013-11-21", "authors_parsed": [["Kerneis", "Gabriel", ""], ["Shepherd", "Charlie", ""], ["Hajnoczi", "Stefan", ""]]}, {"id": "1310.3473", "submitter": "Rohit Jha", "authors": "Rohit Jha, Alfy Samuel, Ashmee Pawar, M. Kiruthika", "title": "A Domain-Specific Language for Discrete Mathematics", "comments": null, "journal-ref": "International Journal of Computer Applications 70(15):6-19, May\n  2013", "doi": "10.5120/12036-7257", "report-no": null, "categories": "cs.PL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper discusses a Domain Specific Language (DSL) that has been developed\nto enable implementation of concepts of discrete mathematics. A library of data\ntypes and functions provides functionality which is frequently required by\nusers. Covering the areas of Mathematical Logic, Set Theory, Functions, Graph\nTheory, Number Theory, Linear Algebra and Combinatorics, the language's syntax\nis close to the actual notation used in the specific fields.\n", "versions": [{"version": "v1", "created": "Sun, 13 Oct 2013 12:28:54 GMT"}], "update_date": "2013-10-15", "authors_parsed": [["Jha", "Rohit", ""], ["Samuel", "Alfy", ""], ["Pawar", "Ashmee", ""], ["Kiruthika", "M.", ""]]}, {"id": "1310.3481", "submitter": "Zachary Kincaid", "authors": "Azadeh Farzan and Zachary Kincaid", "title": "An Algebraic Framework for Compositional Program Analysis", "comments": "15 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The purpose of a program analysis is to compute an abstract meaning for a\nprogram which approximates its dynamic behaviour. A compositional program\nanalysis accomplishes this task with a divide-and-conquer strategy: the meaning\nof a program is computed by dividing it into sub-programs, computing their\nmeaning, and then combining the results. Compositional program analyses are\ndesirable because they can yield scalable (and easily parallelizable) program\nanalyses.\n  This paper presents algebraic framework for designing, implementing, and\nproving the correctness of compositional program analyses. A program analysis\nin our framework defined by an algebraic structure equipped with sequencing,\nchoice, and iteration operations. From the analysis design perspective, a\nparticularly interesting consequence of this is that the meaning of a loop is\ncomputed by applying the iteration operator to the loop body. This style of\ncompositional loop analysis can yield interesting ways of computing loop\ninvariants that cannot be defined iteratively. We identify a class of\nalgorithms, the so-called path-expression algorithms [Tarjan1981,Scholz2007],\nwhich can be used to efficiently implement analyses in our framework. Lastly,\nwe develop a theory for proving the correctness of an analysis by establishing\nan approximation relationship between an algebra defining a concrete semantics\nand an algebra defining an analysis.\n", "versions": [{"version": "v1", "created": "Sun, 13 Oct 2013 13:41:25 GMT"}], "update_date": "2013-10-15", "authors_parsed": [["Farzan", "Azadeh", ""], ["Kincaid", "Zachary", ""]]}, {"id": "1310.4019", "submitter": "EPTCS", "authors": "Marco Carbone (ITU, Denmark), Ivan Lanese (University of\n  Bologna/INRIA, Italy), Alberto Lluch Lafuente (IMT Institute for Advanced\n  Studies Lucca, Italy), Ana Sokolova (University of Salzburg, Austria)", "title": "Proceedings 6th Interaction and Concurrency Experience", "comments": null, "journal-ref": "EPTCS 131, 2013", "doi": "10.4204/EPTCS.131", "report-no": null, "categories": "cs.PL cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of ICE 2013, the 6th Interaction and\nConcurrency Experience workshop, which was held in Florence, Italy on the 6th\nof June 2013 as a satellite event of DisCoTec 2013. The ICE procedure for paper\nselection allows PC members to interact, anonymously, with authors. During the\nreview phase, each submitted paper is published on a Wiki and associated with a\ndiscussion forum whose access is restricted to the authors and to all the PC\nmembers not declaring a conflict of interests. The PC members post comments and\nquestions that the authors reply to. Each paper was reviewed by three PC\nmembers, and altogether 6 papers were accepted for publication. We were proud\nto host two invited talks, Davide Sangiorgi and Filippo Bonchi, whose abstracts\nare included in this volume together with the regular papers. The workshop also\nfeatured a brief announcement of an already published paper.\n", "versions": [{"version": "v1", "created": "Tue, 15 Oct 2013 12:04:04 GMT"}], "update_date": "2013-10-16", "authors_parsed": [["Carbone", "Marco", "", "ITU, Denmark"], ["Lanese", "Ivan", "", "University of\n  Bologna/INRIA, Italy"], ["Lafuente", "Alberto Lluch", "", "IMT Institute for Advanced\n  Studies Lucca, Italy"], ["Sokolova", "Ana", "", "University of Salzburg, Austria"]]}, {"id": "1310.4283", "submitter": "Arnaud Spiwack", "authors": "Arnaud Spiwack", "title": "Abstract interpretation as anti-refinement", "comments": "Working paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  This article shows a correspondence between abstract interpretation of\nimperative programs and the refinement calculus: in the refinement calculus, an\nabstract interpretation of a program is a specification which is a function.\n  This correspondence can be used to guide the design of mechanically verified\nstatic analyses, keeping the correctness proof well separated from the\nheuristic parts of the algorithms.\n", "versions": [{"version": "v1", "created": "Wed, 16 Oct 2013 07:16:49 GMT"}, {"version": "v2", "created": "Fri, 13 Jun 2014 12:28:39 GMT"}], "update_date": "2014-06-16", "authors_parsed": [["Spiwack", "Arnaud", ""]]}, {"id": "1310.4571", "submitter": "EPTCS", "authors": "Eduard Baranov (Ecole Polytechnique F\\'ed\\'erale de Lausanne,\n  Switzerland), Simon Bliudze (Ecole Polytechnique F\\'ed\\'erale de Lausanne,\n  Switzerland)", "title": "Extended Connectors: Structuring Glue Operators in BIP", "comments": "In Proceedings ICE 2013, arXiv:1310.4019", "journal-ref": "EPTCS 131, 2013, pp. 20-35", "doi": "10.4204/EPTCS.131.3", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Based on a variation of the BIP operational semantics using the offer\npredicate introduced in our previous work, we extend the algebras used to model\nglue operators in BIP to encompass priorities. This extension uses the Algebra\nof Causal Interaction Trees, T(P), as a pivot: existing transformations\nautomatically provide the extensions for the Algebra of Connectors. We then\nextend the axiomatisation of T(P), since the equivalence induced by the new\noperational semantics is weaker than that induced by the interaction semantics.\nThis extension leads to canonical normal forms for all structures and to a\nsimplification of the algorithm for the synthesis of connectors from Boolean\ncoordination constraints.\n", "versions": [{"version": "v1", "created": "Thu, 17 Oct 2013 03:47:49 GMT"}], "update_date": "2013-10-18", "authors_parsed": [["Baranov", "Eduard", "", "Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne,\n  Switzerland"], ["Bliudze", "Simon", "", "Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne,\n  Switzerland"]]}, {"id": "1310.4575", "submitter": "EPTCS", "authors": "Karl Palmskog (KTH Royal Institute of Technology), Mads Dam (KTH Royal\n  Institute of Technology), Andreas Lundblad (KTH Royal Institute of\n  Technology), Ali Jafari (Reykjavik University)", "title": "ABS-NET: Fully Decentralized Runtime Adaptation for Distributed Objects", "comments": "In Proceedings ICE 2013, arXiv:1310.4019", "journal-ref": "EPTCS 131, 2013, pp. 85-100", "doi": "10.4204/EPTCS.131.8", "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a formalized, fully decentralized runtime semantics for a core\nsubset of ABS, a language and framework for modelling distributed\nobject-oriented systems. The semantics incorporates an abstract graph\nrepresentation of a network infrastructure, with network endpoints represented\nas graph nodes, and links as arcs with buffers, corresponding to OSI layer 2\ninterconnects. The key problem we wish to address is how to allocate\ncomputational tasks to nodes so that certain performance objectives are met. To\nthis end, we use the semantics as a foundation for performing network-adaptive\ntask execution via object migration between nodes. Adaptability is analyzed in\nterms of three Quality of Service objectives: node load, arc load and message\nlatency. We have implemented the key parts of our semantics in a simulator and\nevaluated how well objectives are achieved for some application-relevant\nchoices of network topology, migration procedure and ABS program. The\nevaluation suggests that it is feasible in a decentralized setting to\ncontinually meet both the objective of a node-balanced task allocation and make\nheadway towards minimizing communication, and thus arc load and message\nlatency.\n", "versions": [{"version": "v1", "created": "Thu, 17 Oct 2013 03:48:39 GMT"}], "update_date": "2013-10-18", "authors_parsed": [["Palmskog", "Karl", "", "KTH Royal Institute of Technology"], ["Dam", "Mads", "", "KTH Royal\n  Institute of Technology"], ["Lundblad", "Andreas", "", "KTH Royal Institute of\n  Technology"], ["Jafari", "Ali", "", "Reykjavik University"]]}, {"id": "1310.4780", "submitter": "James Cheney", "authors": "James Cheney, Sam Lindley, Gabriel Radanne, and Philip Wadler", "title": "Effective Quotation: relating approaches to language-integrated query", "comments": "Proceedings of the ACM SIGPLAN 2014 Workshop on Partial Evaluation\n  and Program Manipulation, January 20-21, 2014, San Diego, CA, USA. Copyright\n  is held by the owner/author(s). Publication rights licensed to ACM", "journal-ref": null, "doi": "10.1145/2543728.2543738", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Language-integrated query techniques have been explored in a number of\ndifferent language designs. We consider two different, type-safe approaches\nemployed by Links and F#. Both approaches provide rich dynamic query generation\ncapabilities, and thus amount to a form of heterogeneous staged computation,\nbut to date there has been no formal investigation of their relative\nexpressiveness. We present two core calculi Eff and Quot, respectively\ncapturing the essential aspects of language-integrated querying using effects\nin Links and quotation in LINQ. We show via translations from Eff to Quot and\nback that the two approaches are equivalent in expressiveness. Based on the\ntranslation from Eff to Quot, we extend a simple Links compiler to handle\nqueries.\n", "versions": [{"version": "v1", "created": "Thu, 17 Oct 2013 17:29:40 GMT"}, {"version": "v2", "created": "Wed, 20 Nov 2013 11:28:05 GMT"}, {"version": "v3", "created": "Fri, 11 Apr 2014 13:35:48 GMT"}], "update_date": "2014-04-14", "authors_parsed": [["Cheney", "James", ""], ["Lindley", "Sam", ""], ["Radanne", "Gabriel", ""], ["Wadler", "Philip", ""]]}, {"id": "1310.5538", "submitter": "Vijay Saraswat", "authors": "Vijay Saraswat, Radha Jagadeesan and Vineet Gupta", "title": "TCC, with History", "comments": "17 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modern computer systems are awash in a sea of asynchronous events. There is\nan increasing need for a declarative language that can permit business users to\nspecify complex event-processing rules. Such rules should be able to correlate\ndifferent event streams, detect absence of events (negative information),\npermit aggregations over sliding windows, specify dependent sliding windows\netc. For instance it should be possible to precisely state a rule such as\n\"Every seventh trading session that DowJones has risen consecutively, and IBM's\nstock is off 3% over its average in this period, evaluate IBM position\",\n\"Declare the sensor as faulty if no reading has been received for 500 ms\", etc.\nFurther, the language should be implementable efficiently in an event-driven\nfashion.\n  We propose the Timed (Default) Concurrent Constraint, TCC, programming\nframework as a foundation for such complex event processing. While very rich,\nthe TCC framework \"forgets\" information from one instant to the next. We make\ntwo extensions. First, we extend the TCC model to carry the store from previous\ntime instants as \"past\" information in the current time instant. This permits\nrules to to be written with rich queries over the past. Second, we show that\nmany of the powerful properties of the agent language can be folded into the\nquery language by permitting agents and queries to be defined mutually\nrecursively, building on the testing interpretation of intuitionistic logic\ndescribed in RCC \\cite{radha-fsttcs05}. We show that this permits queries to\nmove \"back and forth\" in the past, e.g.{} \"Order a review if the last time that\nIBM stock price dropped by 10% in a day, there was more than 20% increase in\ntrading volume for Oracle the following day.\"\n  We provide a formal semantics for TCC + Histories and establish some basic\nproperties.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2013 13:33:21 GMT"}], "update_date": "2013-10-22", "authors_parsed": [["Saraswat", "Vijay", ""], ["Jagadeesan", "Radha", ""], ["Gupta", "Vineet", ""]]}, {"id": "1310.6299", "submitter": "James Cheney", "authors": "Umut A. Acar, Amal Ahmed, James Cheney, and Roly Perera", "title": "A Core Calculus for Provenance", "comments": null, "journal-ref": "Journal of Computer Security 21 (2013) 919-969", "doi": "10.3233/JCS-130487", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Provenance is an increasing concern due to the ongoing revolution in sharing\nand processing scientific data on the Web and in other computer systems. It is\nproposed that many computer systems will need to become provenance-aware in\norder to provide satisfactory accountability, reproducibility, and trust for\nscientific or other high-value data. To date, there is not a consensus\nconcerning appropriate formal models or security properties for provenance. In\nprevious work, we introduced a formal framework for provenance security and\nproposed formal definitions of properties called disclosure and obfuscation.\n  In this article, we study refined notions of positive and negative disclosure\nand obfuscation in a concrete setting, that of a general-purpose programing\nlanguage. Previous models of provenance have focused on special-purpose\nlanguages such as workflows and database queries. We consider a higher-order,\nfunctional language with sums, products, and recursive types and functions, and\nequip it with a tracing semantics in which traces themselves can be replayed as\ncomputations. We present an annotation-propagation framework that supports many\nprovenance views over traces, including standard forms of provenance studied\npreviously. We investigate some relationships among provenance views and\ndevelop some partial solutions to the disclosure and obfuscation problems,\nincluding correct algorithms for disclosure and positive obfuscation based on\ntrace slicing.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2013 17:14:33 GMT"}, {"version": "v2", "created": "Fri, 3 Jan 2014 15:12:12 GMT"}], "update_date": "2014-01-06", "authors_parsed": [["Acar", "Umut A.", ""], ["Ahmed", "Amal", ""], ["Cheney", "James", ""], ["Perera", "Roly", ""]]}, {"id": "1310.7449", "submitter": "Elena Giachino", "authors": "Elena Giachino and Cosimo Laneve", "title": "Deadlock detection in linear recursive programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deadlock detection in recursive programs that admit dynamic resource creation\nis extremely complex and solutions either give imprecise answers or do not\nscale.\n  We define an algorithm for detecting deadlocks of \"linear recursive programs\"\nof a basic model. The theory that underpins the algorithm is a generalization\nof the theory of permutations of names to so-called \"mutations\", which\ntransform tuples by introducing duplicates and fresh names.\n  Our algorithm realizes the back-end of deadlock analyzers for object-oriented\nprogramming languages, once the association programs/basic-model-programs has\nbeen defined as front-end.\n", "versions": [{"version": "v1", "created": "Mon, 28 Oct 2013 15:08:28 GMT"}], "update_date": "2013-10-29", "authors_parsed": [["Giachino", "Elena", ""], ["Laneve", "Cosimo", ""]]}, {"id": "1310.7774", "submitter": "Lse Lse", "authors": "Mariano Martinez Peck (INRIA Lille - Nord Europe, URIA), Noury\n  Bouraqadi (URIA), St\\'ephane Ducasse (INRIA Lille - Nord Europe), Luc\n  Fabresse (URIA), Marcus Denker (INRIA Lille - Nord Europe)", "title": "Ghost: A Uniform and General-Purpose Proxy Implementation", "comments": "in submission", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A proxy object is a surrogate or placeholder that controls access to another\ntarget object. Proxy objects are a widely used solution for different scenarios\nsuch as remote method invocation, future objects, behavioral reflection, object\ndatabases, inter-languages communications and bindings, access control, lazy or\nparallel evaluation, security, among others. Most proxy implementations support\nproxies for regular objects but are unable to create proxies for objects with\nan important role in the runtime infrastructure such as classes or methods.\nProxies can be complex to install, they can have a significant overhead, they\ncan be limited to certain kind of classes, etc. Moreover, proxy implementations\nare often not stratified and they do not have a clear separation between\nproxies (the objects intercepting messages) and handlers (the objects handling\ninterceptions). In this paper, we present Ghost: a uniform and general-purpose\nproxy implementation for the Pharo programming language. Ghost provides low\nmemory consuming proxies for regular objects as well as for classes and\nmethods. When a proxy takes the place of a class, it intercepts both the\nmessages received by the class and the lookup of methods for messages received\nby its instances. Similarly, if a proxy takes the place of a method, then the\nmethod execution is intercepted too.\n", "versions": [{"version": "v1", "created": "Tue, 29 Oct 2013 12:03:53 GMT"}], "update_date": "2013-10-30", "authors_parsed": [["Peck", "Mariano Martinez", "", "INRIA Lille - Nord Europe, URIA"], ["Bouraqadi", "Noury", "", "URIA"], ["Ducasse", "St\u00e9phane", "", "INRIA Lille - Nord Europe"], ["Fabresse", "Luc", "", "URIA"], ["Denker", "Marcus", "", "INRIA Lille - Nord Europe"]]}]