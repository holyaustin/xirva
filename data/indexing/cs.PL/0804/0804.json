[{"id": "0804.0876", "submitter": "Andreas Abel", "authors": "Andreas Abel", "title": "Semi-continuous Sized Types and Termination", "comments": "33 pages, extended version of CSL'06", "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 2 (April 10,\n  2008) lmcs:1236", "doi": "10.2168/LMCS-4(2:3)2008", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Some type-based approaches to termination use sized types: an ordinal bound\nfor the size of a data structure is stored in its type. A recursive function\nover a sized type is accepted if it is visible in the type system that\nrecursive calls occur just at a smaller size. This approach is only sound if\nthe type of the recursive function is admissible, i.e., depends on the size\nindex in a certain way. To explore the space of admissible functions in the\npresence of higher-kinded data types and impredicative polymorphism, a\nsemantics is developed where sized types are interpreted as functions from\nordinals into sets of strongly normalizing terms. It is shown that upper\nsemi-continuity of such functions is a sufficient semantic criterion for\nadmissibility. To provide a syntactical criterion, a calculus for\nsemi-continuous functions is developed.\n", "versions": [{"version": "v1", "created": "Sat, 5 Apr 2008 22:27:29 GMT"}, {"version": "v2", "created": "Thu, 10 Apr 2008 15:26:49 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Abel", "Andreas", ""]]}, {"id": "0804.0970", "submitter": "Marie-Claude Gaudel", "authors": "Marie-Claude Gaudel (LRI), Pascale Le Gall (IBISC)", "title": "Testing data types implementations from algebraic specifications", "comments": null, "journal-ref": "Formal Methods and Testing, Springer-Verlag (Ed.) (2008) 209-239", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Algebraic specifications of data types provide a natural basis for testing\ndata types implementations. In this framework, the conformance relation is\nbased on the satisfaction of axioms. This makes it possible to formally state\nthe fundamental concepts of testing: exhaustive test set, testability\nhypotheses, oracle. Various criteria for selecting finite test sets have been\nproposed. They depend on the form of the axioms, and on the possibilities of\nobservation of the implementation under test. This last point is related to the\nwell-known oracle problem. As the main interest of algebraic specifications is\ndata type abstraction, testing a concrete implementation raises the issue of\nthe gap between the abstract description and the concrete representation. The\nobservational semantics of algebraic specifications bring solutions on the\nbasis of the so-called observable contexts. After a description of testing\nmethods based on algebraic specifications, the chapter gives a brief\npresentation of some tools and case studies, and presents some applications to\nother formal methods involving datatypes.\n", "versions": [{"version": "v1", "created": "Mon, 7 Apr 2008 06:35:44 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Gaudel", "Marie-Claude", "", "LRI"], ["Gall", "Pascale Le", "", "IBISC"]]}, {"id": "0804.1118", "submitter": "Donald Sofge", "authors": "Donald A. Sofge", "title": "A Survey of Quantum Programming Languages: History, Methods, and Tools", "comments": "6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Quantum computer programming is emerging as a new subject domain from\nmultidisciplinary research in quantum computing, computer science, mathematics\n(especially quantum logic, lambda calculi, and linear logic), and engineering\nattempts to build the first non-trivial quantum computer. This paper briefly\nsurveys the history, methods, and proposed tools for programming quantum\ncomputers circa late 2007. It is intended to provide an extensive but\nnon-exhaustive look at work leading up to the current state-of-the-art in\nquantum computer programming. Further, it is an attempt to analyze the needed\nprogramming tools for quantum programmers, to use this analysis to predict the\ndirection in which the field is moving, and to make recommendations for further\ndevelopment of quantum programming language tools.\n", "versions": [{"version": "v1", "created": "Mon, 7 Apr 2008 19:48:31 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Sofge", "Donald A.", ""]]}, {"id": "0804.1435", "submitter": "Marc de Falco", "authors": "Marc de Falco", "title": "The Geometry of Interaction of Differential Interaction Nets", "comments": "20 pagee, to be published in the proceedings of LICS08", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Geometry of Interaction purpose is to give a semantic of proofs or\nprograms accounting for their dynamics. The initial presentation, translated as\nan algebraic weighting of paths in proofnets, led to a better characterization\nof the lambda-calculus optimal reduction. Recently Ehrhard and Regnier have\nintroduced an extension of the Multiplicative Exponential fragment of Linear\nLogic (MELL) that is able to express non-deterministic behaviour of programs\nand a proofnet-like calculus: Differential Interaction Nets. This paper\nconstructs a proper Geometry of Interaction (GoI) for this extension. We\nconsider it both as an algebraic theory and as a concrete reversible\ncomputation. We draw links between this GoI and the one of MELL. As a\nby-product we give for the first time an equational theory suitable for the GoI\nof the Multiplicative Additive fragment of Linear Logic.\n", "versions": [{"version": "v1", "created": "Wed, 9 Apr 2008 08:57:47 GMT"}], "update_date": "2008-04-10", "authors_parsed": [["de Falco", "Marc", ""]]}, {"id": "0804.1696", "submitter": "Freddy Munoz", "authors": "Freddy Munoz (IRISA), Benoit Baudry (IRISA), Olivier Barais (IRISA)", "title": "A classification of invasive patterns in AOP", "comments": null, "journal-ref": null, "doi": null, "report-no": "RR-6501", "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Aspect-Oriented Programming (AOP) improves modularity by encapsulating\ncrosscutting concerns into aspects. Some mechanisms to compose aspects allow\ninvasiveness as a mean to integrate concerns. Invasiveness means that AOP\nlanguages have unrestricted access to program properties. Such kind of\nlanguages are interesting because they allow performing complex operations and\nbetter introduce functionalities. In this report we present a classification of\ninvasive patterns in AOP. This classification characterizes the aspects\ninvasive behavior and allows developers to abstract about the aspect incidence\nover the program they crosscut.\n", "versions": [{"version": "v1", "created": "Thu, 10 Apr 2008 13:21:32 GMT"}, {"version": "v2", "created": "Thu, 24 Apr 2008 15:46:28 GMT"}], "update_date": "2009-04-20", "authors_parsed": [["Munoz", "Freddy", "", "IRISA"], ["Baudry", "Benoit", "", "IRISA"], ["Barais", "Olivier", "", "IRISA"]]}, {"id": "0804.2095", "submitter": "Paul Tarau", "authors": "Paul Tarau and Brenda Luderman", "title": "A Logic Programming Framework for Combinational Circuit Synthesis", "comments": null, "journal-ref": "23rd International Conference on Logic Programming (ICLP), LNCS\n  4670, 2007, pages 180-194", "doi": null, "report-no": null, "categories": "cs.LO cs.CE cs.DM cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logic Programming languages and combinational circuit synthesis tools share a\ncommon \"combinatorial search over logic formulae\" background. This paper\nattempts to reconnect the two fields with a fresh look at Prolog encodings for\nthe combinatorial objects involved in circuit synthesis. While benefiting from\nProlog's fast unification algorithm and built-in backtracking mechanism,\nefficiency of our search algorithm is ensured by using parallel bitstring\noperations together with logic variable equality propagation, as a mapping\nmechanism from primary inputs to the leaves of candidate Leaf-DAGs implementing\na combinational circuit specification. After an exhaustive expressiveness\ncomparison of various minimal libraries, a surprising first-runner, Strict\nBoolean Inequality \"<\" together with constant function \"1\" also turns out to\nhave small transistor-count implementations, competitive to NAND-only or\nNOR-only libraries. As a practical outcome, a more realistic circuit\nsynthesizer is implemented that combines rewriting-based simplification of\n(<,1) circuits with exhaustive Leaf-DAG circuit search.\n  Keywords: logic programming and circuit design, combinatorial object\ngeneration, exact combinational circuit synthesis, universal boolean logic\nlibraries, symbolic rewriting, minimal transistor-count circuit synthesis\n", "versions": [{"version": "v1", "created": "Mon, 14 Apr 2008 02:40:31 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Tarau", "Paul", ""], ["Luderman", "Brenda", ""]]}, {"id": "0804.3914", "submitter": "Andrew Gacek", "authors": "Andrew Gacek, Dale Miller, Gopalan Nadathur", "title": "Reasoning in Abella about Structural Operational Semantics\n  Specifications", "comments": "15 pages. To appear in LFMTP'08", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The approach to reasoning about structural operational semantics style\nspecifications supported by the Abella system is discussed. This approach uses\nlambda tree syntax to treat object language binding and encodes binding related\nproperties in generic judgments. Further, object language specifications are\nembedded directly into the reasoning framework through recursive definitions.\nThe treatment of binding via generic judgments implicitly enforces distinctness\nand atomicity in the names used for bound variables. These properties must,\nhowever, be made explicit in reasoning tasks. This objective can be achieved by\nallowing recursive definitions to also specify generic properties of atomic\npredicates. The utility of these various logical features in the Abella system\nis demonstrated through actual reasoning tasks. Brief comparisons with a few\nother logic based approaches are also made.\n", "versions": [{"version": "v1", "created": "Thu, 24 Apr 2008 15:22:02 GMT"}, {"version": "v2", "created": "Tue, 3 Jun 2008 01:09:16 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Gacek", "Andrew", ""], ["Miller", "Dale", ""], ["Nadathur", "Gopalan", ""]]}, {"id": "0804.4116", "submitter": "Mireille Ducasse", "authors": "Ludovic Langevine and Mireille Ducasse", "title": "Design and Implementation of a Tracer Driver: Easy and Efficient Dynamic\n  Analyses of Constraint Logic Programs", "comments": "To appear in Theory and Practice of Logic Programming (TPLP),\n  Cambridge University Press. 30 pages,", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Tracers provide users with useful information about program executions. In\nthis article, we propose a ``tracer driver''. From a single tracer, it provides\na powerful front-end enabling multiple dynamic analysis tools to be easily\nimplemented, while limiting the overhead of the trace generation. The relevant\nexecution events are specified by flexible event patterns and a large variety\nof trace data can be given either systematically or ``on demand''. The proposed\ntracer driver has been designed in the context of constraint logic programming;\nexperiments have been made within GNU-Prolog. Execution views provided by\nexisting tools have been easily emulated with a negligible overhead.\nExperimental measures show that the flexibility and power of the described\narchitecture lead to good performance. The tracer driver overhead is inversely\nproportional to the average time between two traced events. Whereas the\nprinciples of the tracer driver are independent of the traced programming\nlanguage, it is best suited for high-level languages, such as constraint logic\nprogramming, where each traced execution event encompasses numerous low-level\nexecution steps. Furthermore, constraint logic programming is especially hard\nto debug. The current environments do not provide all the useful dynamic\nanalysis tools. They can significantly benefit from our tracer driver which\nenables dynamic analyses to be integrated at a very low cost.\n", "versions": [{"version": "v1", "created": "Fri, 25 Apr 2008 14:05:36 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Langevine", "Ludovic", ""], ["Ducasse", "Mireille", ""]]}, {"id": "0804.4525", "submitter": "Krishnendu Chatterjee", "authors": "Krishnendu Chatterjee, Luca de Alfaro and Rupak Majumdar", "title": "The Complexity of Coverage", "comments": "15 Pages, 1 Figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the problem of generating a test sequence that achieves maximal\ncoverage for a reactive system under test. We formulate the problem as a\nrepeated game between the tester and the system, where the system state space\nis partitioned according to some coverage criterion and the objective of the\ntester is to maximize the set of partitions (or coverage goals) visited during\nthe game. We show the complexity of the maximal coverage problem for\nnon-deterministic systems is PSPACE-complete, but is NP-complete for\ndeterministic systems. For the special case of non-deterministic systems with a\nre-initializing ``reset'' action, which represent running a new test input on a\nre-initialized system, we show that the complexity is again co-NP-complete. Our\nproof technique for reset games uses randomized testing strategies that\ncircumvent the exponentially large memory requirement in the deterministic\ncase.\n", "versions": [{"version": "v1", "created": "Tue, 29 Apr 2008 04:26:08 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["de Alfaro", "Luca", ""], ["Majumdar", "Rupak", ""]]}]