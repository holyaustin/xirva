[{"id": "1504.00198", "submitter": "Nils Jansen", "authors": "Friedrich Gretz, Nils Jansen, Benjamin Lucien Kaminski, Joost-Pieter\n  Katoen, Annabelle McIver, Federico Olmedo", "title": "Conditioning in Probabilistic Programming", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the semantic intricacies of conditioning, a main feature in\nprobabilistic programming. We provide a weakest (liberal) pre-condition (w(l)p)\nsemantics for the elementary probabilistic programming language pGCL extended\nwith conditioning. We prove that quantitative weakest (liberal) pre-conditions\ncoincide with conditional (liberal) expected rewards in Markov chains and show\nthat semantically conditioning is a truly conservative extension. We present\ntwo program transformations which entirely eliminate conditioning from any\nprogram and prove their correctness using the w(l)p-semantics. Finally, we show\nhow the w(l)p-semantics can be used to determine conditional probabilities in a\nparametric anonymity protocol and show that an inductive w(l)p-semantics for\nconditioning in non-deterministic probabilistic programs cannot exist.\n", "versions": [{"version": "v1", "created": "Wed, 1 Apr 2015 12:29:10 GMT"}], "update_date": "2015-04-02", "authors_parsed": [["Gretz", "Friedrich", ""], ["Jansen", "Nils", ""], ["Kaminski", "Benjamin Lucien", ""], ["Katoen", "Joost-Pieter", ""], ["McIver", "Annabelle", ""], ["Olmedo", "Federico", ""]]}, {"id": "1504.00527", "submitter": "Francis Sergeraert", "authors": "Francis Sergeraert", "title": "Functional Programming is Free", "comments": "26 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A paper has recently been published in SIAM-JC. This paper is faulty: 1) The\nstandard requirements about the definition of an algorithm are not respected,\n2) The main point in the complexity study, namely the functional programming\ncomponent, is absent. The Editorial Board of the SIAM JC had been warned a\nconfirmed publication would be openly commented, it is the role of this text.\n", "versions": [{"version": "v1", "created": "Thu, 2 Apr 2015 12:40:18 GMT"}], "update_date": "2015-04-03", "authors_parsed": [["Sergeraert", "Francis", ""]]}, {"id": "1504.00693", "submitter": "Zakaria Alomari", "authors": "Zakaria Alomari, Oualid El Halimi, Kaushik Sivaprasad, Chitrang Pandit", "title": "Comparative Studies of Six Programming Languages", "comments": "arXiv admin note: text overlap with arXiv:1008.3434 by other authors", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Comparison of programming languages is a common topic of discussion among\nsoftware engineers. Multiple programming languages are designed, specified, and\nimplemented every year in order to keep up with the changing programming\nparadigms, hardware evolution, etc. In this paper we present a comparative\nstudy between six programming languages: C++, PHP, C#, Java, Python, VB ; These\nlanguages are compared under the characteristics of reusability, reliability,\nportability, availability of compilers and tools, readability, efficiency,\nfamiliarity and expressiveness.\n", "versions": [{"version": "v1", "created": "Thu, 2 Apr 2015 21:14:38 GMT"}], "update_date": "2015-04-06", "authors_parsed": [["Alomari", "Zakaria", ""], ["Halimi", "Oualid El", ""], ["Sivaprasad", "Kaushik", ""], ["Pandit", "Chitrang", ""]]}, {"id": "1504.00977", "submitter": "Sergii Dymchenko", "authors": "Sergii Dymchenko and Mariia Mykhailova", "title": "Declaratively solving Google Code Jam problems with Picat", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-319-19686-2_4", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present several examples of solving algorithmic problems\nfrom the Google Code Jam programming contest with Picat programming language\nusing declarative techniques: constraint logic programming and tabled logic\nprogramming. In some cases the use of Picat simplifies the implementation\ncompared to conventional imperative programming languages, while in others it\nallows to directly convert the problem statement into an efficiently solvable\ndeclarative problem specification without inventing an imperative algorithm.\n", "versions": [{"version": "v1", "created": "Sat, 4 Apr 2015 03:30:22 GMT"}], "update_date": "2015-06-17", "authors_parsed": [["Dymchenko", "Sergii", ""], ["Mykhailova", "Mariia", ""]]}, {"id": "1504.01842", "submitter": "Hendra Gunadi", "authors": "Hendra Gunadi, Alwen Tiu, and Rajeev Gore", "title": "Formal Certification of Android Bytecode", "comments": "12 pages content, 43 pages total including Appendices, double-column\n  IEEE", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Android is an operating system that has been used in a majority of mobile\ndevices. Each application in Android runs in an instance of the Dalvik virtual\nmachine, which is a register-based virtual machine (VM). Most applications for\nAndroid are developed using Java, compiled to Java bytecode and then translated\nto DEX bytecode using the dx tool in the Android SDK. In this work, we aim to\ndevelop a type-based method for certifying non-interference properties of DEX\nbytecode, following a methodology that has been developed for Java bytecode\ncertification by Barthe et al. To this end, we develop a formal operational\nsemantics of the Dalvik VM, a type system for DEX bytecode, and prove the\nsoundness of the type system with respect to a notion of non-interference. We\nthen study the translation process from Java bytecode to DEX bytecode, as\nimplemented in the dx tool in the Android SDK. We show that an abstracted\nversion of the translation from Java bytecode to DEX bytecode preserves the\nnon-interference property. More precisely, we show that if the Java bytecode is\ntypable in Barthe et al's type system (which guarantees non-interference) then\nits translation is typable in our type system. This result opens up the\npossibility to leverage existing bytecode verifiers for Java to certify\nnon-interference properties of Android bytecode.\n", "versions": [{"version": "v1", "created": "Wed, 8 Apr 2015 06:24:38 GMT"}, {"version": "v2", "created": "Thu, 16 Apr 2015 05:22:08 GMT"}, {"version": "v3", "created": "Wed, 4 May 2016 04:02:19 GMT"}, {"version": "v4", "created": "Mon, 9 May 2016 05:13:48 GMT"}, {"version": "v5", "created": "Thu, 6 Oct 2016 11:54:26 GMT"}], "update_date": "2016-10-07", "authors_parsed": [["Gunadi", "Hendra", ""], ["Tiu", "Alwen", ""], ["Gore", "Rajeev", ""]]}, {"id": "1504.01927", "submitter": "EPTCS", "authors": "Ugo Dal Lago, Russ Harmer", "title": "Proceedings Tenth International Workshop on Developments in\n  Computational Models", "comments": null, "journal-ref": "EPTCS 179, 2015", "doi": "10.4204/EPTCS.179", "report-no": null, "categories": "cs.LO cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the papers presented at the Tenth International Workshop\non Developments in Computational Models (DCM) held in Vienna, Austria on 13th\nJuly 2014, as part of the Vienna Summer of Logic.\n  Several new models of computation have emerged in the last years, and many\ndevelopments of traditional computational models have been proposed with the\naim of taking into account the new demands of computer systems users and the\nnew capabilities of computation engines. A new computational model, or a new\nfeature in a traditional one, usually is reflected in a new family of\nprogramming languages, and new paradigms of software development.\n  The aim of this workshop is to bring together researchers who are currently\ndeveloping new computational models or new features for traditional\ncomputational models, in order to foster their interaction, to provide a forum\nfor presenting new ideas and work in progress, and to enable newcomers to learn\nabout current activities in this area. Topics of interest include all abstract\nmodels of computation and their applications to the development of programming\nlanguages and systems.\n", "versions": [{"version": "v1", "created": "Wed, 8 Apr 2015 12:03:59 GMT"}], "update_date": "2015-04-09", "authors_parsed": [["Lago", "Ugo Dal", ""], ["Harmer", "Russ", ""]]}, {"id": "1504.02603", "submitter": "EPTCS", "authors": "Wolfram Kahl (McMaster University)", "title": "A Simple Parallel Implementation of Interaction Nets in Haskell", "comments": "In Proceedings DCM 2014, arXiv:1504.01927", "journal-ref": "EPTCS 179, 2015, pp. 33-47", "doi": "10.4204/EPTCS.179.3", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Due to their \"inherent parallelism\", interaction nets have since their\nintroduction been considered as an attractive implementation mechanism for\nfunctional programming. We show that a simple highly-concurrent implementation\nin Haskell can achieve promising speed-ups on multiple cores.\n", "versions": [{"version": "v1", "created": "Fri, 10 Apr 2015 09:31:32 GMT"}], "update_date": "2015-04-13", "authors_parsed": [["Kahl", "Wolfram", "", "McMaster University"]]}, {"id": "1504.02611", "submitter": "EPTCS", "authors": "Alexander Heu{\\ss}ner, Christopher M. Poskitt, Claudio Corrodi,\n  Benjamin Morandi", "title": "Towards Practical Graph-Based Verification for an Object-Oriented\n  Concurrency Model", "comments": "In Proceedings GaM 2015, arXiv:1504.02448", "journal-ref": "EPTCS 181, 2015, pp. 32-47", "doi": "10.4204/EPTCS.181.3", "report-no": null, "categories": "cs.SE cs.DC cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  To harness the power of multi-core and distributed platforms, and to make the\ndevelopment of concurrent software more accessible to software engineers,\ndifferent object-oriented concurrency models such as SCOOP have been proposed.\nDespite the practical importance of analysing SCOOP programs, there are\ncurrently no general verification approaches that operate directly on program\ncode without additional annotations. One reason for this is the multitude of\npartially conflicting semantic formalisations for SCOOP (either in theory or\nby-implementation). Here, we propose a simple graph transformation system (GTS)\nbased run-time semantics for SCOOP that grasps the most common features of all\nknown semantics of the language. This run-time model is implemented in the\nstate-of-the-art GTS tool GROOVE, which allows us to simulate, analyse, and\nverify a subset of SCOOP programs with respect to deadlocks and other\nbehavioural properties. Besides proposing the first approach to verify SCOOP\nprograms by automatic translation to GTS, we also highlight our experiences of\napplying GTS (and especially GROOVE) for specifying semantics in the form of a\nrun-time model, which should be transferable to GTS models for other concurrent\nlanguages and libraries.\n", "versions": [{"version": "v1", "created": "Fri, 10 Apr 2015 09:40:14 GMT"}], "update_date": "2015-04-13", "authors_parsed": [["Heu\u00dfner", "Alexander", ""], ["Poskitt", "Christopher M.", ""], ["Corrodi", "Claudio", ""], ["Morandi", "Benjamin", ""]]}, {"id": "1504.02621", "submitter": "EPTCS", "authors": "Christopher Bak, Glyn Faulkner, Detlef Plump, Colin Runciman", "title": "A Reference Interpreter for the Graph Programming Language GP 2", "comments": "In Proceedings GaM 2015, arXiv:1504.02448", "journal-ref": "EPTCS 181, 2015, pp. 48-64", "doi": "10.4204/EPTCS.181.4", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  GP 2 is an experimental programming language for computing by graph\ntransformation. An initial interpreter for GP 2, written in the functional\nlanguage Haskell, provides a concise and simply structured reference\nimplementation. Despite its simplicity, the performance of the interpreter is\nsufficient for the comparative investigation of a range of test programs. It\nalso provides a platform for the development of more sophisticated\nimplementations.\n", "versions": [{"version": "v1", "created": "Fri, 10 Apr 2015 09:50:23 GMT"}], "update_date": "2015-04-13", "authors_parsed": [["Bak", "Christopher", ""], ["Faulkner", "Glyn", ""], ["Plump", "Detlef", ""], ["Runciman", "Colin", ""]]}, {"id": "1504.03239", "submitter": "Rekha R", "authors": "Rekha R Pai", "title": "Global Value Numbering: A Precise and Efficient Algorithm", "comments": "6 pages, 3 figures, an extended version to be submitted to journal", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Global Value Numbering (GVN) is an important static analysis to detect\nequivalent expressions in a program. We present an iterative data-flow analysis\nGVN algorithm in SSA for the purpose of detecting total redundancies. The\ncentral challenge is defining a join operation to detect equivalences at a join\npoint in polynomial time such that later occurrences of redundant expressions\ncould be detected. For this purpose, we introduce the novel concept of value\n$\\phi$-function. We claim the algorithm is precise and takes only polynomial\ntime.\n", "versions": [{"version": "v1", "created": "Mon, 13 Apr 2015 16:14:43 GMT"}], "update_date": "2015-04-14", "authors_parsed": [["Pai", "Rekha R", ""]]}, {"id": "1504.03553", "submitter": "EPTCS", "authors": "Natallia Kokash (Leiden Institute of Advanced Computer Science\n  (LIACS))", "title": "Handshaking Protocol for Distributed Implementation of Reo", "comments": "In Proceedings FOCLASA 2014, arXiv:1502.03157", "journal-ref": "EPTCS 175, 2015, pp. 1-17", "doi": "10.4204/EPTCS.175.1", "report-no": null, "categories": "cs.DC cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reo, an exogenous channel-based coordination language, is a model for service\ncoordination wherein services communicate through connectors formed by joining\nbinary communication channels. In order to establish transactional\ncommunication among services as prescribed by connector semantics, distributed\nports exchange handshaking messages signalling which parties are ready to\nprovide or consume data. In this paper, we present a formal implementation\nmodel for distributed Reo with communication delays and outline ideas for its\nproof of correctness. To reason about Reo implementation formally, we introduce\nTimed Action Constraint Automata (TACA) and explain how to compare TACA with\nexisting automata-based semantics for Reo. We use TACA to describe handshaking\nbehavior of Reo modeling primitives and argue that in any distributed circuit\nremote Reo nodes and channels exposing such behavior commit to perform\ntransitions envisaged by the network semantics.\n", "versions": [{"version": "v1", "created": "Thu, 12 Feb 2015 02:14:37 GMT"}], "update_date": "2015-04-15", "authors_parsed": [["Kokash", "Natallia", "", "Leiden Institute of Advanced Computer Science"]]}, {"id": "1504.05018", "submitter": "Samir Genaim", "authors": "Amir M. Ben-Amram and Samir Genaim", "title": "Complexity of Bradley-Manna-Sipma Lexicographic Ranking Functions", "comments": "Technical report for a corresponding CAV'15 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we turn the spotlight on a class of lexicographic ranking\nfunctions introduced by Bradley, Manna and Sipma in a seminal CAV 2005 paper,\nand establish for the first time the complexity of some problems involving the\ninference of such functions for linear-constraint loops (without precondition).\nWe show that finding such a function, if one exists, can be done in polynomial\ntime in a way which is sound and complete when the variables range over the\nrationals (or reals). We show that when variables range over the integers, the\nproblem is harder -- deciding the existence of a ranking function is\ncoNP-complete. Next, we study the problem of minimizing the number of\ncomponents in the ranking function (a.k.a. the dimension). This number is\ninteresting in contexts like computing iteration bounds and loop\nparallelization. Surprisingly, and unlike the situation for some other classes\nof lexicographic ranking functions, we find that even deciding whether a\ntwo-component ranking function exists is harder than the unrestricted problem:\nNP-complete over the rationals and $\\Sigma^P_2$-complete over the integers.\n", "versions": [{"version": "v1", "created": "Mon, 20 Apr 2015 11:50:22 GMT"}], "update_date": "2015-04-21", "authors_parsed": [["Ben-Amram", "Amir M.", ""], ["Genaim", "Samir", ""]]}, {"id": "1504.05372", "submitter": "Wim Vanderbauwhede", "authors": "Wim Vanderbauwhede", "title": "Inferring Program Transformations from Type Transformations for\n  Partitioning of Ordered Sets", "comments": "This work is supported by the EPSRC through the TyTra project\n  (EP/L00058X/1)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper I introduce a mechanism to derive program transforma- tions\nfrom order-preserving transformations of vector types. The purpose of this work\nis to allow automatic generation of correct-by-construction instances of\nprograms in a streaming data processing paradigm suitable for FPGA processing.\nWe show that for it is possible to automatically derive instances for programs\nbased on combinations of opaque element- processing functions combined using\nfoldl and map, purely from the type transformations.\n", "versions": [{"version": "v1", "created": "Tue, 21 Apr 2015 10:19:57 GMT"}], "update_date": "2015-04-22", "authors_parsed": [["Vanderbauwhede", "Wim", ""]]}, {"id": "1504.07073", "submitter": "Manuel Mohr", "authors": "Sebastian Buchwald, Manuel Mohr, Ignaz Rutter", "title": "Optimal Shuffle Code with Permutation Instructions", "comments": "20 pages, 5 figures, full version of a paper accepted at WADS'15.\n  Minor update: fixed typos, corrected comma placement", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  During compilation of a program, register allocation is the task of mapping\nprogram variables to machine registers. During register allocation, the\ncompiler may introduce shuffle code, consisting of copy and swap operations,\nthat transfers data between the registers. Three common sources of shuffle code\nare conflicting register mappings at joins in the control flow of the program,\ne.g, due to if-statements or loops; the calling convention for procedures,\nwhich often dictates that input arguments or results must be placed in certain\nregisters; and machine instructions that only allow a subset of registers to\noccur as operands. Recently, Mohr et al. proposed to speed up shuffle code with\nspecial hardware instructions that arbitrarily permute the contents of up to\nfive registers and gave a heuristic for computing such shuffle codes. In this\npaper, we give an efficient algorithm for generating optimal shuffle code in\nthe setting of Mohr et al. An interesting special case occurs when no register\nhas to be transferred to more than one destination, i.e., it suffices to\npermute the contents of the registers. This case is equivalent to factoring a\npermutation into a minimal product of permutations, each of which permutes up\nto five elements.\n", "versions": [{"version": "v1", "created": "Mon, 27 Apr 2015 13:14:44 GMT"}, {"version": "v2", "created": "Mon, 18 May 2015 07:18:27 GMT"}], "update_date": "2015-05-19", "authors_parsed": [["Buchwald", "Sebastian", ""], ["Mohr", "Manuel", ""], ["Rutter", "Ignaz", ""]]}, {"id": "1504.07680", "submitter": "Jana Dunfield", "authors": "Jana Dunfield", "title": "Elaborating Evaluation-Order Polymorphism", "comments": "13 pages + appendix; in International Conference on Functional\n  Programming (ICFP) 2015. arXiv version 3 makes corrections to Figure 5 and\n  Section 2.4, preserving page breaks", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We classify programming languages according to evaluation order: each\nlanguage fixes one evaluation order as the default, making it transparent to\nprogram in that evaluation order, and troublesome to program in the other.\n  This paper develops a type system that is impartial with respect to\nevaluation order. Evaluation order is implicit in terms, and explicit in types,\nwith by-value and by-name versions of type connectives. A form of intersection\ntype quantifies over evaluation orders, describing code that is agnostic over\n(that is, polymorphic in) evaluation order. By allowing such generic code,\nprograms can express the by-value and by-name versions of a computation without\ncode duplication.\n  We also formulate a type system that only has by-value connectives, plus a\ntype that generalizes the difference between by-value and by-name connectives:\nit is either a suspension (by name) or a \"no-op\" (by value). We show a\nstraightforward encoding of the impartial type system into the more economical\none. Then we define an elaboration from the economical language to a\ncall-by-value semantics, and prove that elaborating a well-typed source\nprogram, where evaluation order is implicit, produces a well-typed target\nprogram where evaluation order is explicit. We also prove a simulation between\nevaluation of the target program and reductions (either by-value or by-name) in\nthe source program.\n  Finally, we prove that typing, elaboration, and evaluation are faithful to\nthe type annotations given in the source program: if the programmer only writes\nby-value types, no by-name reductions can occur at run time.\n", "versions": [{"version": "v1", "created": "Tue, 28 Apr 2015 22:50:15 GMT"}, {"version": "v2", "created": "Tue, 16 Jun 2015 00:35:16 GMT"}, {"version": "v3", "created": "Fri, 11 Sep 2015 23:17:21 GMT"}, {"version": "v4", "created": "Sat, 22 Aug 2020 18:49:37 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Dunfield", "Jana", ""]]}, {"id": "1504.07862", "submitter": "Marek Trt\\'ik", "authors": "Marek Trtik", "title": "Anonymous On-line Communication Between Program Analyses", "comments": "Technical report / Specification, 50 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a light-weight client-server model of communication between\nexisting implementations of different program analyses. The communication is\non-line and anonymous which means that all analyses simultaneously analyse the\nsame program and an analysis does not know what other analyses participate in\nthe communication. The anonymity and model's strong emphasis on independence of\nanalyses allow to preserve almost everything in existing implementations. An\nanalysis only has to add an implementation of a proposed communication\nprotocol, determine places in its code where information from others would\nhelp, and then check whether there is no communication scenario, which would\ncorrupt its result. We demonstrate functionality and effectiveness of the\nproposed communication model in a detailed case study with three analyses: two\nabstract interpreters and the classic symbolic execution. Results of the\nevaluation on SV-COMP benchmarks show impressive improvements in computed\ninvariants and increased counts of successfully analysed benchmarks.\n", "versions": [{"version": "v1", "created": "Wed, 29 Apr 2015 13:58:42 GMT"}], "update_date": "2015-04-30", "authors_parsed": [["Trtik", "Marek", ""]]}, {"id": "1504.08033", "submitter": "J. Ian Johnson", "authors": "James Ian Johnson", "title": "Automating Abstract Interpretation of Abstract Machines", "comments": "This dissertation has been accepted by the thesis committee", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Static program analysis is a valuable tool for any programming language that\npeople write programs in. The prevalence of scripting languages in the world\nsuggests programming language interpreters are relatively easy to write. Users\nof these languages lament their inability to analyze their code, therefore\nprogramming language analyzers are not easy to write. This thesis investigates\na systematic method of creating abstract interpreters from traditional\ninterpreters, called Abstracting Abstract Machines.\n  Abstract interpreters are difficult to develop due to technical, theoretical,\nand pragmatic problems. Technical problems include engineering data structures\nand algorithms. I show that modest and simple changes to the mathematical\npresentation of abstract machines result in 1000 times better running time -\njust seconds for moderately sized programs.\n  In the theoretical realm, abstraction can make correctness difficult to\nascertain. I provide proof techniques for proving the correctness of regular,\npushdown, and stack-inspecting pushdown models of abstract computation by\nleaving computational power to an external factor: allocation. Even if we don't\ntrust the proof, we can run models concretely against test suites to better\ntrust them.\n  In the pragmatic realm, I show that the systematic process of abstracting\nabstract machines is automatable. I develop a meta-language for expressing\nabstract machines similar to other semantics engineering languages. The\nlanguage's special feature is that it provides an interface to abstract\nallocation. The semantics guarantees that if allocation is finite, then the\nsemantics is a sound and computable approximation of the concrete semantics.\n", "versions": [{"version": "v1", "created": "Wed, 29 Apr 2015 21:46:52 GMT"}], "update_date": "2015-05-01", "authors_parsed": [["Johnson", "James Ian", ""]]}, {"id": "1504.08039", "submitter": "Panagiotis Vekris", "authors": "Panagiotis Vekris, Benjamin Cosman, Ranjit Jhala", "title": "Trust, but Verify: Two-Phase Typing for Dynamic Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A key challenge when statically typing so-called dynamic languages is the\nubiquity of value-based overloading, where a given function can dynamically\nreflect upon and behave according to the types of its arguments. Thus, to\nestablish basic types, the analysis must reason precisely about values, but in\nthe presence of higher-order functions and polymorphism, this reasoning itself\ncan require basic types. In this paper we address this chicken-and-egg problem\nby introducing the framework of two-phased typing. The first \"trust\" phase\nperforms classical, i.e. flow-, path- and value-insensitive type checking to\nassign basic types to various program expressions. When the check inevitably\nruns into \"errors\" due to value-insensitivity, it wraps problematic expressions\nwith DEAD-casts, which explicate the trust obligations that must be discharged\nby the second phase. The second phase uses refinement typing, a flow- and\npath-sensitive analysis, that decorates the first phase's types with logical\npredicates to track value relationships and thereby verify the casts and\nestablish other correctness properties for dynamically typed languages.\n", "versions": [{"version": "v1", "created": "Wed, 29 Apr 2015 22:31:14 GMT"}], "update_date": "2015-05-01", "authors_parsed": [["Vekris", "Panagiotis", ""], ["Cosman", "Benjamin", ""], ["Jhala", "Ranjit", ""]]}, {"id": "1504.08100", "submitter": "Matthias Keil", "authors": "Matthias Keil, Sankha Narayan Guria, Andreas Schlegel, Manuel Geffken,\n  and Peter Thiemann", "title": "Transparent Object Proxies for JavaScript", "comments": "Technical Report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Proxies are the swiss army knives of object adaptation. They introduce a\nlevel of indirection to intercept select operations on a target object and\ndivert them as method calls to a handler. Proxies have many uses like\nimplementing access control, enforcing contracts, virtualizing resources.\n  One important question in the design of a proxy API is whether a proxy object\nshould inherit the identity of its target. Apparently proxies should have their\nown identity for security-related applications whereas other applications, in\nparticular contract systems, require transparent proxies that compare equal to\ntheir target objects.\n  We examine the issue with transparency in various use cases for proxies,\ndiscuss different approaches to obtain transparency, and propose two designs\nthat require modest modifications in the JavaScript engine and cannot be\nbypassed by the programmer.\n  We implement our designs in the SpiderMonkey JavaScript interpreter and\nbytecode compiler. Our evaluation shows that these modifications of have no\nstatistically significant impact on the benchmark performance of the JavaScript\nengine. Furthermore, we demonstrate that contract systems based on wrappers\nrequire transparent proxies to avoid interference with program execution in\nrealistic settings.\n", "versions": [{"version": "v1", "created": "Thu, 30 Apr 2015 07:20:13 GMT"}], "update_date": "2015-05-01", "authors_parsed": [["Keil", "Matthias", ""], ["Guria", "Sankha Narayan", ""], ["Schlegel", "Andreas", ""], ["Geffken", "Manuel", ""], ["Thiemann", "Peter", ""]]}, {"id": "1504.08110", "submitter": "Matthias Keil", "authors": "Matthias Keil and Peter Thiemann", "title": "TreatJS: Higher-Order Contracts for JavaScript", "comments": "Technical Report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  TreatJS is a language embedded, higher-order contract system for JavaScript\nwhich enforces contracts by run-time monitoring. Beyond providing the standard\nabstractions for building higher-order contracts (base, function, and object\ncontracts), TreatJS's novel contributions are its guarantee of non-interfering\ncontract execution, its systematic approach to blame assignment, its support\nfor contracts in the style of union and intersection types, and its notion of a\nparameterized contract scope, which is the building block for composable\nrun-time generated contracts that generalize dependent function contracts.\n  TreatJS is implemented as a library so that all aspects of a contract can be\nspecified using the full JavaScript language. The library relies on JavaScript\nproxies to guarantee full interposition for contracts. It further exploits\nJavaScript's reflective features to run contracts in a sandbox environment,\nwhich guarantees that the execution of contract code does not modify the\napplication state. No source code transformation or change in the JavaScript\nrun-time system is required.\n  The impact of contracts on execution speed is evaluated using the Google\nOctane benchmark.\n", "versions": [{"version": "v1", "created": "Thu, 30 Apr 2015 08:18:29 GMT"}], "update_date": "2015-05-01", "authors_parsed": [["Keil", "Matthias", ""], ["Thiemann", "Peter", ""]]}, {"id": "1504.08309", "submitter": "Mike Dodds", "authors": "Matko Botin\\v{c}an, Mike Dodds, Stephen Magill", "title": "Refining Existential Properties in Separation Logic Analyses", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  In separation logic program analyses, tractability is generally achieved by\nrestricting invariants to a finite abstract domain. As this domain cannot vary,\nloss of information can cause failure even when verification is possible in the\nunderlying logic. In this paper, we propose a CEGAR-like method for detecting\nspurious failures and avoiding them by refining the abstract domain. Our\napproach is geared towards discovering existential properties, e.g. \"list\ncontains value x\". To diagnose failures, we use abduction, a technique for\ninferring command preconditions. Our method works backwards from an error,\nidentifying necessary information lost by abstraction, and refining the forward\nanalysis to avoid the error. We define domains for several classes of\nexistential properties, and show their effectiveness on case studies adapted\nfrom Redis, Azureus and FreeRTOS.\n", "versions": [{"version": "v1", "created": "Thu, 30 Apr 2015 17:09:57 GMT"}], "update_date": "2015-05-01", "authors_parsed": [["Botin\u010dan", "Matko", ""], ["Dodds", "Mike", ""], ["Magill", "Stephen", ""]]}]