[{"id": "1205.0170", "submitter": "Jesse Alama", "authors": "Czeslaw Bylinski and Jesse Alama", "title": "New developments in parsing Mizar", "comments": "5 pages. Accepted at Mathematical Knowledge Management 2012 Track D\n  (Systems and Projects), Bremen, Germany, July 2012", "journal-ref": null, "doi": "10.1007/978-3-642-31374-5_1", "report-no": null, "categories": "cs.PL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Mizar language aims to capture mathematical vernacular by providing a\nrich language for mathematics. From the perspective of a user, the richness of\nthe language is welcome because it makes writing texts more \"natural\". But for\nthe developer, the richness leads to syntactic complexity, such as dealing with\noverloading.\n  Recently the Mizar team has been making a fresh approach to the problem of\nparsing the Mizar language. One aim is to make the language accessible to users\nand other developers. In this paper we describe these new parsing efforts and\nsome applications thereof, such as large-scale text refactorings,\npretty-printing, HTTP parsing services, and normalizations of Mizar texts.\n", "versions": [{"version": "v1", "created": "Mon, 30 Apr 2012 12:45:39 GMT"}], "update_date": "2014-01-07", "authors_parsed": [["Bylinski", "Czeslaw", ""], ["Alama", "Jesse", ""]]}, {"id": "1205.0357", "submitter": "Patrick Bahr", "authors": "Patrick Bahr (Department of Computer Science, University of\n  Copenhagen)", "title": "Modes of Convergence for Term Graph Rewriting", "comments": "arXiv admin note: substantial text overlap with arXiv:1107.0666", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 2 (June 1,\n  2012) lmcs:935", "doi": "10.2168/LMCS-8(2:6)2012", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Term graph rewriting provides a simple mechanism to finitely represent\nrestricted forms of infinitary term rewriting. The correspondence between\ninfinitary term rewriting and term graph rewriting has been studied to some\nextent. However, this endeavour is impaired by the lack of an appropriate\ncounterpart of infinitary rewriting on the side of term graphs. We aim to fill\nthis gap by devising two modes of convergence based on a partial order\nrespectively a metric on term graphs. The thus obtained structures generalise\ncorresponding modes of convergence that are usually studied in infinitary term\nrewriting. We argue that this yields a common framework in which both term\nrewriting and term graph rewriting can be studied. In order to substantiate our\nclaim, we compare convergence on term graphs and on terms. In particular, we\nshow that the modes of convergence on term graphs are conservative extensions\nof the corresponding modes of convergence on terms and are preserved under\nunravelling term graphs to terms. Moreover, we show that many of the properties\nknown from infinitary term rewriting are preserved. This includes the intrinsic\ncompleteness of both modes of convergence and the fact that convergence via the\npartial order is a conservative extension of the metric convergence.\n", "versions": [{"version": "v1", "created": "Wed, 2 May 2012 08:51:15 GMT"}, {"version": "v2", "created": "Thu, 31 May 2012 06:55:28 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Bahr", "Patrick", "", "Department of Computer Science, University of\n  Copenhagen"]]}, {"id": "1205.1098", "submitter": "Jeremy Siek", "authors": "Geoffrey Belter, Elizabeth Jessup, Thomas Nelson, Boyana Norris,\n  Jeremy G. Siek", "title": "Reliable Generation of High-Performance Matrix Algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.PF cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Scientific programmers often turn to vendor-tuned Basic Linear Algebra\nSubprograms (BLAS) to obtain portable high performance. However, many numerical\nalgorithms require several BLAS calls in sequence, and those successive calls\nresult in suboptimal performance. The entire sequence needs to be optimized in\nconcert. Instead of vendor-tuned BLAS, a programmer could start with source\ncode in Fortran or C (e.g., based on the Netlib BLAS) and use a\nstate-of-the-art optimizing compiler. However, our experiments show that\noptimizing compilers often attain only one-quarter the performance of\nhand-optimized code. In this paper we present a domain-specific compiler for\nmatrix algebra, the Build to Order BLAS (BTO), that reliably achieves high\nperformance using a scalable search algorithm for choosing the best combination\nof loop fusion, array contraction, and multithreading for data parallelism. The\nBTO compiler generates code that is between 16% slower and 39% faster than\nhand-optimized code.\n", "versions": [{"version": "v1", "created": "Sat, 5 May 2012 04:30:14 GMT"}], "update_date": "2012-05-09", "authors_parsed": [["Belter", "Geoffrey", ""], ["Jessup", "Elizabeth", ""], ["Nelson", "Thomas", ""], ["Norris", "Boyana", ""], ["Siek", "Jeremy G.", ""]]}, {"id": "1205.2367", "submitter": "Adrian Jackson", "authors": "Adrian Jackson and Orestis Agathokleous", "title": "Dynamic Loop Parallelisation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Regions of nested loops are a common feature of High Performance Computing\n(HPC) codes. In shared memory programming models, such as OpenMP, these\nstructure are the most common source of parallelism. Parallelising these\nstructures requires the programmers to make a static decision on how\nparallelism should be applied. However, depending on the parameters of the\nproblem and the nature of the code, static decisions on which loop to\nparallelise may not be optimial, especially as they do not enable the\nexploitation of any runtime characteristics of the execution including changes\nto the iterations of the loops to be parallelised.\n  We have developed a system that allows a code to make a dynamic choice, at\nruntime, of what parallelism is applied to nested loops. Our method for\nproviding dynamic decisions on which loop to parallelise significantly\noutperforms the standard methods for acheiving this through OpenMP (using if\nclauses).\n", "versions": [{"version": "v1", "created": "Thu, 10 May 2012 11:18:40 GMT"}], "update_date": "2012-05-14", "authors_parsed": [["Jackson", "Adrian", ""], ["Agathokleous", "Orestis", ""]]}, {"id": "1205.2492", "submitter": "Patricia Johann", "authors": "Robert Atkey (University of Strathclyde), Patricia Johann (University\n  of Strathclyde), Neil Ghani (University of Strathclyde)", "title": "Refining Inductive Types", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 2 (June 4,\n  2012) lmcs:957", "doi": "10.2168/LMCS-8(2:9)2012", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dependently typed programming languages allow sophisticated properties of\ndata to be expressed within the type system. Of particular use in dependently\ntyped programming are indexed types that refine data by computationally useful\ninformation. For example, the N-indexed type of vectors refines lists by their\nlengths. Other data types may be refined in similar ways, but programmers must\nproduce purpose-specific refinements on an ad hoc basis, developers must\nanticipate which refinements to include in libraries, and implementations must\noften store redundant information about data and their refinements. In this\npaper we show how to generically derive inductive characterisations of\nrefinements of inductive types, and argue that these characterisations can\nalleviate some of the aforementioned difficulties associated with ad hoc\nrefinements. Our characterisations also ensure that standard techniques for\nprogramming with and reasoning about inductive types are applicable to\nrefinements, and that refinements can themselves be further refined.\n", "versions": [{"version": "v1", "created": "Fri, 11 May 2012 12:00:24 GMT"}, {"version": "v2", "created": "Fri, 1 Jun 2012 14:39:12 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Atkey", "Robert", "", "University of Strathclyde"], ["Johann", "Patricia", "", "University\n  of Strathclyde"], ["Ghani", "Neil", "", "University of Strathclyde"]]}, {"id": "1205.2636", "submitter": "Oleg Kiselyov", "authors": "Oleg Kiselyov, Chung-chieh Shan", "title": "Monolingual Probabilistic Programming Using Generalized Coroutines", "comments": "Appears in Proceedings of the Twenty-Fifth Conference on Uncertainty\n  in Artificial Intelligence (UAI2009)", "journal-ref": null, "doi": null, "report-no": "UAI-P-2009-PG-285-292", "categories": "cs.PL cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Probabilistic programming languages and modeling toolkits are two modular\nways to build and reuse stochastic models and inference procedures. Combining\nstrengths of both, we express models and inference as generalized coroutines in\nthe same general-purpose language. We use existing facilities of the language,\nsuch as rich libraries, optimizing compilers, and types, to develop concise,\ndeclarative, and realistic models with competitive performance on exact and\napproximate inference. In particular, a wide range of models can be expressed\nusing memoization. Because deterministic parts of models run at full speed,\ncustom inference procedures are trivial to incorporate, and inference\nprocedures can reason about themselves without interpretive overhead. Within\nthis framework, we introduce a new, general algorithm for importance sampling\nwith look-ahead.\n", "versions": [{"version": "v1", "created": "Wed, 9 May 2012 15:39:37 GMT"}], "update_date": "2012-05-14", "authors_parsed": [["Kiselyov", "Oleg", ""], ["Shan", "Chung-chieh", ""]]}, {"id": "1205.2670", "submitter": "Utku Kose UK", "authors": "Utku Kose, Omer Deperlioglu", "title": "Intelligent learning environments within blended learning for ensuring\n  effective C programming course", "comments": "20 pages, 7 figures, 5 tables", "journal-ref": null, "doi": "10.5121/ijaia.2012.3109", "report-no": null, "categories": "cs.CY cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes a blended learning implementation and experience\nsupported with intelligent learning environments included in a learning\nmanagement system (LMS) called @KU-UZEM. The blended learning model is realized\nas a combination of face to face education and e-learning. The intelligent\nlearning environments consist of two applications named CTutor, ITest. In\naddition to standard e-learning tools, students can use CTutor to resolve C\nprogramming exercises. CTutor is a problem-solving environment, which diagnoses\nstudents' knowledge level but also gives feedbacks and tips to help them to\nunderstand the course subject, overcome their misconceptions and reinforce\nlearnt concepts. ITest provides an assessment environment in which students can\ntake quizzes that were prepared according to their learning levels. The\nrealized model was used for two terms in the \"C Programming\" course given at\nAfyon Kocatepe University. A survey was conducted at the end of the course to\nfind out to what extent the students were accepting the blended learning model\nsupported with @KU-UZEM and to discover students' attitude towards intelligent\nlearning environments. Additionally, an experiment formed with an experimental\ngroup who took an active part in the realized model and a control group who\nonly took the face to face education was performed during the first term of the\ncourse. According to the results, students were satisfied with intelligent\nlearning environments and the realized learning model. Furthermore, the use of\nintelligent learning environments improved the students' knowledge about C\nprogramming.\n", "versions": [{"version": "v1", "created": "Wed, 8 Feb 2012 11:27:58 GMT"}], "update_date": "2012-05-14", "authors_parsed": [["Kose", "Utku", ""], ["Deperlioglu", "Omer", ""]]}, {"id": "1205.3981", "submitter": "Paolo Frasconi", "authors": "Paolo Frasconi, Fabrizio Costa, Luc De Raedt, Kurt De Grave", "title": "kLog: A Language for Logical and Relational Learning with Kernels", "comments": null, "journal-ref": null, "doi": "10.1016/j.artint.2014.08.003", "report-no": null, "categories": "cs.AI cs.LG cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce kLog, a novel approach to statistical relational learning.\nUnlike standard approaches, kLog does not represent a probability distribution\ndirectly. It is rather a language to perform kernel-based learning on\nexpressive logical and relational representations. kLog allows users to specify\nlearning problems declaratively. It builds on simple but powerful concepts:\nlearning from interpretations, entity/relationship data modeling, logic\nprogramming, and deductive databases. Access by the kernel to the rich\nrepresentation is mediated by a technique we call graphicalization: the\nrelational representation is first transformed into a graph --- in particular,\na grounded entity/relationship diagram. Subsequently, a choice of graph kernel\ndefines the feature space. kLog supports mixed numerical and symbolic data, as\nwell as background knowledge in the form of Prolog or Datalog programs as in\ninductive logic programming systems. The kLog framework can be applied to\ntackle the same range of tasks that has made statistical relational learning so\npopular, including classification, regression, multitask learning, and\ncollective classification. We also report about empirical comparisons, showing\nthat kLog can be either more accurate, or much faster at the same level of\naccuracy, than Tilde and Alchemy. kLog is GPLv3 licensed and is available at\nhttp://klog.dinfo.unifi.it along with tutorials.\n", "versions": [{"version": "v1", "created": "Thu, 17 May 2012 17:00:00 GMT"}, {"version": "v2", "created": "Fri, 18 May 2012 12:46:57 GMT"}, {"version": "v3", "created": "Fri, 22 Jun 2012 12:06:52 GMT"}, {"version": "v4", "created": "Mon, 17 Feb 2014 11:47:55 GMT"}, {"version": "v5", "created": "Mon, 28 Jul 2014 13:41:00 GMT"}], "update_date": "2014-10-17", "authors_parsed": [["Frasconi", "Paolo", ""], ["Costa", "Fabrizio", ""], ["De Raedt", "Luc", ""], ["De Grave", "Kurt", ""]]}, {"id": "1205.4672", "submitter": "Elloumi Yaroub", "authors": "Yaroub Elloumi, Mohamed Akil and Mohamed Hedi Bedoui", "title": "Timing and Code Size Optimization on Achieving Full Parallelism in\n  Uniform Nested Loops", "comments": "10 pages, 16 figures", "journal-ref": "Journal of Computing, Volume 3, Issue 7, July 2011, 68-77", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multidimensional Retiming is one of the most important optimization\ntechniques to improve timing parameters of nested loops. It consists in\nexploring the iterative and recursive structures of loops to redistribute\ncomputation nodes on cycle periods, and thus to achieve full parallelism.\nHowever, this technique introduces a large overhead in a loop generation due to\nthe loop transformation. The provided solutions are generally characterized by\nan important cycle number and a great code size. It represents the most\nlimiting factors while implementing them in embedded systems. In this paper, we\npresent a new Multidimensional Retiming technique, called \"Optimal\nMultidimensional Retiming\" (OMDR). It reveals the timing and data dependency\ncharacteristics of nodes, to minimize the overhead. The experimental results\nshow that the average improvement on the execution time of the nested loops by\nour technique is 19.31% compared to the experiments provided by an existent\nMultidimensional Retiming Technique. The average code size is reduced by 43.53%\ncompared to previous experiments.\n", "versions": [{"version": "v1", "created": "Thu, 17 May 2012 22:45:45 GMT"}], "update_date": "2012-05-22", "authors_parsed": [["Elloumi", "Yaroub", ""], ["Akil", "Mohamed", ""], ["Bedoui", "Mohamed Hedi", ""]]}, {"id": "1205.4691", "submitter": "Flavien Breuvart", "authors": "Flavien Breuvart (PPS)", "title": "On the discriminating power of tests in resource lambda-calculus", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Since its discovery, differential linear logic (DLL) inspired numerous\ndomains. In denotational semantics, categorical models of DLL are now commune,\nand the simplest one is Rel, the category of sets and relations. In proof\ntheory this naturally gave birth to differential proof nets that are full and\ncomplete for DLL. In turn, these tools can naturally be translated to their\nintuitionistic counterpart. By taking the co-Kleisly category associated to the\n! comonad, Rel becomes MRel, a model of the \\Lcalcul that contains a notion of\ndifferentiation. Proof nets can be used naturally to extend the \\Lcalcul into\nthe lambda calculus with resources, a calculus that contains notions of\nlinearity and differentiations. Of course MRel is a model of the \\Lcalcul with\nresources, and it has been proved adequate, but is it fully abstract? That was\na strong conjecture of Bucciarelli, Carraro, Ehrhard and Manzonetto. However,\nin this paper we exhibit a counter-example. Moreover, to give more intuition on\nthe essence of the counter-example and to look for more generality, we will use\nan extension of the resource \\Lcalcul also introduced by Bucciarelli et al for\nwhich $\\Minf$ is fully abstract, the tests.\n", "versions": [{"version": "v1", "created": "Mon, 21 May 2012 19:08:25 GMT"}, {"version": "v2", "created": "Tue, 22 May 2012 18:50:01 GMT"}], "update_date": "2012-05-23", "authors_parsed": [["Breuvart", "Flavien", "", "PPS"]]}, {"id": "1205.5344", "submitter": "Simon J. Gay", "authors": "Simon J. Gay (University of Glasgow), Nils Gesbert (Grenoble INP -\n  Ensimag), Ant\\'onio Ravara (Universidade Nova de Lisboa), Vasco T.\n  Vasconcelos (Universidade de Lisboa)", "title": "Modular session types for objects", "comments": "Logical Methods in Computer Science (LMCS), International Federation\n  for Computational Logic, 2015", "journal-ref": "Logical Methods in Computer Science, Volume 11, Issue 4 (December\n  16, 2015) lmcs:1613", "doi": "10.2168/LMCS-11(4:12)2015", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Session types allow communication protocols to be specified\ntype-theoretically so that protocol implementations can be verified by static\ntype checking. We extend previous work on session types for distributed\nobject-oriented languages in three ways. (1) We attach a session type to a\nclass definition, to specify the possible sequences of method calls. (2) We\nallow a session type (protocol) implementation to be modularized, i.e.\npartitioned into separately-callable methods. (3) We treat session-typed\ncommunication channels as objects, integrating their session types with the\nsession types of classes. The result is an elegant unification of communication\nchannels and their session types, distributed object-oriented programming, and\na form of typestate supporting non-uniform objects, i.e. objects that\ndynamically change the set of available methods. We define syntax, operational\nse-mantics, a sound type system, and a sound and complete type checking\nalgorithm for a small distributed class-based object-oriented language with\nstructural subtyping. Static typing guarantees that both sequences of messages\non channels, and sequences of method calls on objects, conform to\ntype-theoretic specifications, thus ensuring type-safety. The language includes\nexpected features of session types, such as delegation, and expected features\nof object-oriented programming, such as encapsulation of local state.\n", "versions": [{"version": "v1", "created": "Thu, 24 May 2012 06:30:42 GMT"}, {"version": "v2", "created": "Sat, 31 Jan 2015 18:19:46 GMT"}, {"version": "v3", "created": "Thu, 8 Oct 2015 15:21:36 GMT"}, {"version": "v4", "created": "Mon, 14 Dec 2015 23:34:19 GMT"}, {"version": "v5", "created": "Wed, 23 Dec 2015 19:03:16 GMT"}], "update_date": "2017-01-11", "authors_parsed": [["Gay", "Simon J.", "", "University of Glasgow"], ["Gesbert", "Nils", "", "Grenoble INP -\n  Ensimag"], ["Ravara", "Ant\u00f3nio", "", "Universidade Nova de Lisboa"], ["Vasconcelos", "Vasco T.", "", "Universidade de Lisboa"]]}, {"id": "1205.5975", "submitter": "Paolo Bientinesi", "authors": "Diego Fabregat-Traver (1) and Paolo Bientinesi (1), ((1) AICES, RWTH\n  Aachen)", "title": "A Domain-Specific Compiler for Linear Algebra Operations", "comments": null, "journal-ref": null, "doi": null, "report-no": "AICES-2012/01-2", "categories": "cs.MS cs.PL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a prototypical linear algebra compiler that automatically exploits\ndomain-specific knowledge to generate high-performance algorithms. The input to\nthe compiler is a target equation together with knowledge of both the structure\nof the problem and the properties of the operands. The output is a variety of\nhigh-performance algorithms, and the corresponding source code, to solve the\ntarget equation. Our approach consists in the decomposition of the input\nequation into a sequence of library-supported kernels. Since in general such a\ndecomposition is not unique, our compiler returns not one but a number of\nalgorithms. The potential of the compiler is shown by means of its application\nto a challenging equation arising within the genome-wide association study. As\na result, the compiler produces multiple \"best\" algorithms that outperform the\nbest existing libraries.\n", "versions": [{"version": "v1", "created": "Sun, 27 May 2012 15:22:23 GMT"}], "update_date": "2012-05-29", "authors_parsed": [["Fabregat-Traver", "Diego", ""], ["Bientinesi", "Paolo", ""]]}, {"id": "1205.6402", "submitter": "Robert Simmons", "authors": "Robert J. Simmons and Bernardo Toninho", "title": "Constructive Provability Logic", "comments": "Extended version of IMLA 2011 submission of the same title", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present constructive provability logic, an intuitionstic modal logic that\nvalidates the L\\\"ob rule of G\\\"odel and L\\\"ob's provability logic by permitting\nlogical reflection over provability. Two distinct variants of this logic, CPL\nand CPL*, are presented in natural deduction and sequent calculus forms which\nare then shown to be equivalent. In addition, we discuss the use of\nconstructive provability logic to justify stratified negation in logic\nprogramming within an intuitionstic and structural proof theory.\n", "versions": [{"version": "v1", "created": "Tue, 29 May 2012 15:53:50 GMT"}], "update_date": "2012-05-30", "authors_parsed": [["Simmons", "Robert J.", ""], ["Toninho", "Bernardo", ""]]}, {"id": "1205.6465", "submitter": "Alejandro Hernandez", "authors": "Alejandro Mario Hernandez", "title": "Globally reasoning about localised security policies in distributed\n  systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this report, we aim at establishing proper ways for model checking the\nglobal security of distributed systems, which are designed consisting of set of\nlocalised security policies that enforce specific issues about the security\nexpected.\n  The systems are formally specified following a syntax, defined in detail in\nthis report, and their behaviour is clearly established by the Semantics, also\ndefined in detail in this report. The systems include the formal attachment of\nsecurity policies into their locations, whose intended interactions are trapped\nby the policies, aiming at taking access control decisions of the system, and\nthe Semantics also takes care of this.\n  Using the Semantics, a Labelled Transition System (LTS) can be induced for\nevery particular system, and over this LTS some model checking tasks could be\ndone. We identify how this LTS is indeed obtained, and propose an alternative\nway of model checking the not-yet-induced LTS, by using the system design\ndirectly. This may lead to over-approximation thereby producing imprecise,\nthough safe, results. We restrict ourselves to finite systems, in the sake of\nbeing certain about the decidability of the proposed method.\n  To illustrate the usefulness and validity of our proposal, we present 2 small\ncase-study-like examples, where we show how the system can be specified, which\npolicies could be added to it, and how to decide if the desired global security\nproperty is met.\n  Finally, an Appendix is given for digging deeply into how a tool for\nautomatically performing this task is being built, including some\nimplementation issues. The tool takes advantage of the proposed method, and\ngiven some system and some desired global security property, it safely (i.e.\nwithout false positives) ensures satisfaction of it.\n", "versions": [{"version": "v1", "created": "Tue, 29 May 2012 19:59:00 GMT"}], "update_date": "2012-05-30", "authors_parsed": [["Hernandez", "Alejandro Mario", ""]]}, {"id": "1205.6527", "submitter": "Martin Sch\\\"af", "authors": "J\\\"urgen Christ, Jochen Hoenicke, Martin Sch\\\"af", "title": "Towards Bounded Infeasible Code Detection", "comments": "24 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A first step towards more reliable software is to execute each statement and\neach control-flow path in a method once. In this paper, we present a formal\nmethod to automatically compute test cases for this purpose based on the idea\nof a bounded infeasible code detection. The method first unwinds all loops in a\nprogram finitely often and then encodes all feasible executions of the\nloop-free programs in a logical formula. Helper variables are introduced such\nthat a theorem prover can reconstruct the control-flow path of a feasible\nexecution from a satisfying valuation of this formula. Based on this formula,\nwe present one algorithm that computes a feasible path cover and one algorithm\nthat computes a feasible statement cover. We show that the algorithms are\ncomplete for loop-free programs and that they can be implemented efficiently.\nWe further provide a sound algorithm to compute procedure summaries which makes\nthe method scalable to larger programs.\n", "versions": [{"version": "v1", "created": "Wed, 30 May 2012 01:50:30 GMT"}], "update_date": "2012-05-31", "authors_parsed": [["Christ", "J\u00fcrgen", ""], ["Hoenicke", "Jochen", ""], ["Sch\u00e4f", "Martin", ""]]}]