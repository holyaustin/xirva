[{"id": "0811.0166", "submitter": "David Monniaux", "authors": "David Monniaux (VERIMAG - Imag)", "title": "Automatic Modular Abstractions for Linear Constraints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a method for automatically generating abstract transformers for\nstatic analysis by abstract interpretation. The method focuses on linear\nconstraints on programs operating on rational, real or floating-point variables\nand containing linear assignments and tests. In addition to loop-free code, the\nsame method also applies for obtaining least fixed points as functions of the\nprecondition, which permits the analysis of loops and recursive functions. Our\nalgorithms are based on new quantifier elimination and symbolic manipulation\ntechniques. Given the specification of an abstract domain, and a program block,\nour method automatically outputs an implementation of the corresponding\nabstract transformer. It is thus a form of program transformation. The\nmotivation of our work is data-flow synchronous programming languages, used for\nbuilding control-command embedded systems, but it also applies to imperative\nand functional programming.\n", "versions": [{"version": "v1", "created": "Sun, 2 Nov 2008 14:47:44 GMT"}], "update_date": "2008-11-04", "authors_parsed": [["Monniaux", "David", "", "VERIMAG - Imag"]]}, {"id": "0811.0436", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Instruction sequences for the production of processes", "comments": "23 pages; acknowledgement corrected, reference updated", "journal-ref": null, "doi": null, "report-no": "PRG0814", "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Single-pass instruction sequences under execution are considered to produce\nbehaviours to be controlled by some execution environment. Threads as\nconsidered in thread algebra model such behaviours: upon each action performed\nby a thread, a reply from its execution environment determines how the thread\nproceeds. Threads in turn can be looked upon as producing processes as\nconsidered in process algebra. We show that, by apposite choice of basic\ninstructions, all processes that can only be in a finite number of states can\nbe produced by single-pass instruction sequences.\n", "versions": [{"version": "v1", "created": "Tue, 4 Nov 2008 07:24:12 GMT"}, {"version": "v2", "created": "Tue, 18 Nov 2008 10:08:03 GMT"}], "update_date": "2008-11-18", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0811.0819", "submitter": "Andreas Blass", "authors": "Andreas Blass (University of Michigan) and Yuri Gurevich (Microsoft\n  Research)", "title": "Persistent Queries", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a syntax and semantics for interactive abstract state machines to\ndeal with the following situation. A query is issued during a certain step, but\nthe step ends before any reply is received. Later, a reply arrives, and later\nyet the algorithm makes use of this reply. By a persistent query, we mean a\nquery for which a late reply might be used. Syntactically, our proposal\ninvolves issuing, along with a persistent query, a location where a late reply\nis to be stored. Semantically, it involves only a minor modification of the\nexisting theory of interactive small-step abstract state machines.\n", "versions": [{"version": "v1", "created": "Wed, 5 Nov 2008 21:10:33 GMT"}], "update_date": "2008-11-07", "authors_parsed": [["Blass", "Andreas", "", "University of Michigan"], ["Gurevich", "Yuri", "", "Microsoft\n  Research"]]}, {"id": "0811.2113", "submitter": "J\\\"urgen Koslowski", "authors": "Chris Heunen", "title": "Compactly accessible categories and quantum key distribution", "comments": "26 pages in Logical Methods in Computer Science, Volume 4, Issue 4\n  (November 17, 2008) lmcs:1129", "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (November\n  17, 2008) lmcs:1129", "doi": "10.2168/LMCS-4(4:9)2008", "report-no": null, "categories": "cs.LO cs.PL quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compact categories have lately seen renewed interest via applications to\nquantum physics. Being essentially finite-dimensional, they cannot accomodate\n(co)limit-based constructions. For example, they cannot capture protocols such\nas quantum key distribution, that rely on the law of large numbers. To overcome\nthis limitation, we introduce the notion of a compactly accessible category,\nrelying on the extra structure of a factorisation system. This notion allows\nfor infinite dimension while retaining key properties of compact categories:\nthe main technical result is that the choice-of-duals functor on the compact\npart extends canonically to the whole compactly accessible category. As an\nexample, we model a quantum key distribution protocol and prove its correctness\ncategorically.\n", "versions": [{"version": "v1", "created": "Thu, 13 Nov 2008 13:58:48 GMT"}, {"version": "v2", "created": "Mon, 17 Nov 2008 13:17:09 GMT"}, {"version": "v3", "created": "Tue, 19 Apr 2016 12:29:44 GMT"}], "update_date": "2016-04-20", "authors_parsed": [["Heunen", "Chris", ""]]}, {"id": "0811.2535", "submitter": "James Raynolds", "authors": "Harry B. Hunt, Lenore R. Mullin, Daniel J. Rosenkrantz, and James E.\n  Raynolds", "title": "A Transformation--Based Approach for the Design of Parallel/Distributed\n  Scientific Software: the FFT", "comments": "45 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a methodology for designing efficient parallel and distributed\nscientific software. This methodology utilizes sequences of mechanizable\nalgebra--based optimizing transformations. In this study, we apply our\nmethodology to the FFT, starting from a high--level algebraic algorithm\ndescription. Abstract multiprocessor plans are developed and refined to specify\nwhich computations are to be done by each processor. Templates are then created\nthat specify the locations of computations and data on the processors, as well\nas data flow among processors. Templates are developed in both the MPI and\nOpenMP programming styles.\n  Preliminary experiments comparing code constructed using our methodology with\ncode from several standard scientific libraries show that our code is often\ncompetitive and sometimes performs better. Interestingly, our code handled a\nlarger range of problem sizes on one target architecture.\n", "versions": [{"version": "v1", "created": "Sat, 15 Nov 2008 22:32:59 GMT"}], "update_date": "2008-11-18", "authors_parsed": [["Hunt", "Harry B.", ""], ["Mullin", "Lenore R.", ""], ["Rosenkrantz", "Daniel J.", ""], ["Raynolds", "James E.", ""]]}, {"id": "0811.3231", "submitter": "Olivier Danvy", "authors": "Olivier Danvy and Kevin Millikin", "title": "A Rational Deconstruction of Landin's SECD Machine with the J Operator", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (November\n  29, 2008) lmcs:1112", "doi": "10.2168/LMCS-4(4:12)2008", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Landin's SECD machine was the first abstract machine for applicative\nexpressions, i.e., functional programs. Landin's J operator was the first\ncontrol operator for functional languages, and was specified by an extension of\nthe SECD machine. We present a family of evaluation functions corresponding to\nthis extension of the SECD machine, using a series of elementary\ntransformations (transformation into continu-ation-passing style (CPS) and\ndefunctionalization, chiefly) and their left inverses (transformation into\ndirect style and refunctionalization). To this end, we modernize the SECD\nmachine into a bisimilar one that operates in lockstep with the original one\nbut that (1) does not use a data stack and (2) uses the caller-save rather than\nthe callee-save convention for environments. We also identify that the dump\ncomponent of the SECD machine is managed in a callee-save way. The caller-save\ncounterpart of the modernized SECD machine precisely corresponds to Thielecke's\ndouble-barrelled continuations and to Felleisen's encoding of J in terms of\ncall/cc. We then variously characterize the J operator in terms of CPS and in\nterms of delimited-control operators in the CPS hierarchy. As a byproduct, we\nalso present several reduction semantics for applicative expressions with the J\noperator, based on Curien's original calculus of explicit substitutions. These\nreduction semantics mechanically correspond to the modernized versions of the\nSECD machine and to the best of our knowledge, they provide the first syntactic\ntheories of applicative expressions with the J operator.\n", "versions": [{"version": "v1", "created": "Wed, 19 Nov 2008 22:31:34 GMT"}, {"version": "v2", "created": "Fri, 28 Nov 2008 23:19:23 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Danvy", "Olivier", ""], ["Millikin", "Kevin", ""]]}, {"id": "0811.4324", "submitter": "Pierre Genev\\`es", "authors": "Pierre Genev\\`es, Nabil Laya\\\"ida, and Vincent Quint", "title": "Ensuring Query Compatibility with Evolving XML Schemas", "comments": null, "journal-ref": null, "doi": null, "report-no": "RR-6711", "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  During the life cycle of an XML application, both schemas and queries may\nchange from one version to another. Schema evolutions may affect query results\nand potentially the validity of produced data. Nowadays, a challenge is to\nassess and accommodate the impact of theses changes in rapidly evolving XML\napplications.\n  This article proposes a logical framework and tool for verifying\nforward/backward compatibility issues involving schemas and queries. First, it\nallows analyzing relations between schemas. Second, it allows XML designers to\nidentify queries that must be reformulated in order to produce the expected\nresults across successive schema versions. Third, it allows examining more\nprecisely the impact of schema changes over queries, therefore facilitating\ntheir reformulation.\n", "versions": [{"version": "v1", "created": "Wed, 26 Nov 2008 14:37:01 GMT"}], "update_date": "2008-11-27", "authors_parsed": [["Genev\u00e8s", "Pierre", ""], ["Laya\u00efda", "Nabil", ""], ["Quint", "Vincent", ""]]}]