[{"id": "0712.1189", "submitter": "Olivier Zendra", "authors": "Olivier Zendra (INRIA Lorraine - LORIA), Eric Jul (DIKU), Roland\n  Ducournau (LIRMM), Etienne Gagnon, Richard E. Jones, Chandra Krintz (RACE\n  LAB), Philippe Mulet, Jan Vitek (S3L)", "title": "Implementation, Compilation, Optimization of Object-Oriented Languages,\n  Programs and Systems - Report on the Workshop ICOOOLPS'2007 at ECOOP'07", "comments": null, "journal-ref": "ECOOP 2007 Workshop Reader Springer (Ed.) (2008)", "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": null, "abstract": "  ICOOOLPS'2007 was the second edition of the ECOOP-ICOOOLPS workshop. ICOOOLPS\nintends to bring researchers and practitioners both from academia and industry\ntogether, with a spirit of openness, to try and identify and begin to address\nthe numerous and very varied issues of optimization. After a first successful\nedition, this second one put a stronger emphasis on exchanges and discussions\namongst the participants, progressing on the bases set last year in Nantes. The\nworkshop attendance was a success, since the 30-people limit we had set was\nreached about 2 weeks before the workshop itself. Some of the discussions (e.g.\nannotations) were so successful that they would required even more time than we\nwere able to dedicate to them. That's one area we plan to further improve for\nthe next edition.\n", "versions": [{"version": "v1", "created": "Fri, 7 Dec 2007 17:01:52 GMT"}], "update_date": "2007-12-10", "authors_parsed": [["Zendra", "Olivier", "", "INRIA Lorraine - LORIA"], ["Jul", "Eric", "", "DIKU"], ["Ducournau", "Roland", "", "LIRMM"], ["Gagnon", "Etienne", "", "RACE\n  LAB"], ["Jones", "Richard E.", "", "RACE\n  LAB"], ["Krintz", "Chandra", "", "RACE\n  LAB"], ["Mulet", "Philippe", "", "S3L"], ["Vitek", "Jan", "", "S3L"]]}, {"id": "0712.1205", "submitter": "James Riely", "authors": "Radha Jagadeesan, Alan Jeffrey, Corin Pitcher, James Riely", "title": "Lambda-RBAC: Programming with Role-Based Access Control", "comments": "LMCS", "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 1 (January 9,\n  2008) lmcs:1195", "doi": "10.2168/LMCS-4(1:2)2008", "report-no": null, "categories": "cs.PL cs.CR", "license": null, "abstract": "  We study mechanisms that permit program components to express role\nconstraints on clients, focusing on programmatic security mechanisms, which\npermit access controls to be expressed, in situ, as part of the code realizing\nbasic functionality. In this setting, two questions immediately arise: (1) The\nuser of a component faces the issue of safety: is a particular role sufficient\nto use the component? (2) The component designer faces the dual issue of\nprotection: is a particular role demanded in all execution paths of the\ncomponent? We provide a formal calculus and static analysis to answer both\nquestions.\n", "versions": [{"version": "v1", "created": "Fri, 7 Dec 2007 18:58:35 GMT"}, {"version": "v2", "created": "Wed, 9 Jan 2008 16:51:45 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Jagadeesan", "Radha", ""], ["Jeffrey", "Alan", ""], ["Pitcher", "Corin", ""], ["Riely", "James", ""]]}, {"id": "0712.1658", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Program algebra with a jump-shift instruction", "comments": "19 pages", "journal-ref": "Journal of Applied Logic, 6(4):553--563, 2008", "doi": "10.1016/j.jal.2008.07.001", "report-no": "PRG0711", "categories": "cs.PL", "license": null, "abstract": "  We study sequential programs that are instruction sequences with jump-shift\ninstructions in the setting of PGA (ProGram Algebra). Jump-shift instructions\npreceding a jump instruction increase the position to jump to. The jump-shift\ninstruction is not found in programming practice. Its merit is that the\nexpressive power of PGA extended with the jump-shift instruction, is not\nreduced if the reach of jump instructions is bounded. This is used to show that\nthere exists a finite-state execution mechanism that by making use of a counter\ncan produce each finite-state thread from some program that is a finite or\nperiodic infinite sequence of instructions from a finite set.\n", "versions": [{"version": "v1", "created": "Tue, 11 Dec 2007 08:53:49 GMT"}], "update_date": "2008-11-11", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0712.2630", "submitter": "Juan J. Merelo Pr.", "authors": "Nestor Zorzano, Daniel Merino, J.L.J. Laredo, J.P. Sevilla, Pablo\n  Garcia, J.J. Merelo", "title": "Evolving XSLT stylesheets", "comments": "First draft, preparing for WCCI 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NE cs.PL", "license": null, "abstract": "  This paper introduces a procedure based on genetic programming to evolve XSLT\nprograms (usually called stylesheets or logicsheets). XSLT is a general\npurpose, document-oriented functional language, generally used to transform XML\ndocuments (or, in general, solve any problem that can be coded as an XML\ndocument). The proposed solution uses a tree representation for the stylesheets\nas well as diverse specific operators in order to obtain, in the studied cases\nand a reasonable time, a XSLT stylesheet that performs the transformation.\nSeveral types of representation have been compared, resulting in different\nperformance and degree of success.\n", "versions": [{"version": "v1", "created": "Mon, 17 Dec 2007 19:59:42 GMT"}], "update_date": "2007-12-18", "authors_parsed": [["Zorzano", "Nestor", ""], ["Merino", "Daniel", ""], ["Laredo", "J. L. J.", ""], ["Sevilla", "J. P.", ""], ["Garcia", "Pablo", ""], ["Merelo", "J. J.", ""]]}, {"id": "0712.2737", "submitter": "Wim Vanhoof", "authors": "Kim Henriksen, Gourinath Banda, John Gallagher", "title": "Experiments with a Convex Polyhedral Analysis Tool for Logic Programs", "comments": "Paper presented at the 17th Workshop on Logic-based Methods in\n  Programming Environments (WLPE2007)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": null, "abstract": "  Convex polyhedral abstractions of logic programs have been found very useful\nin deriving numeric relationships between program arguments in order to prove\nprogram properties and in other areas such as termination and complexity\nanalysis. We present a tool for constructing polyhedral analyses of\n(constraint) logic programs. The aim of the tool is to make available, with a\nconvenient interface, state-of-the-art techniques for polyhedral analysis such\nas delayed widening, narrowing, \"widening up-to\", and enhanced automatic\nselection of widening points. The tool is accessible on the web, permits user\nprograms to be uploaded and analysed, and is integrated with related program\ntransformations such as size abstractions and query-answer transformation. We\nthen report some experiments using the tool, showing how it can be conveniently\nused to analyse transition systems arising from models of embedded systems, and\nan emulator for a PIC microcontroller which is used for example in wearable\ncomputing systems. We discuss issues including scalability, tradeoffs of\nprecision and computation time, and other program transformations that can\nenhance the results of analysis.\n", "versions": [{"version": "v1", "created": "Mon, 17 Dec 2007 15:11:36 GMT"}], "update_date": "2007-12-18", "authors_parsed": [["Henriksen", "Kim", ""], ["Banda", "Gourinath", ""], ["Gallagher", "John", ""]]}, {"id": "0712.3088", "submitter": "Zhaohua Luo", "authors": "Zhaohua Luo", "title": "Clones and Genoids in Lambda Calculus and First Order Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A genoid is a category of two objects such that one is the product of itself\nwith the other. A genoid may be viewed as an abstract substitution algebra. It\nis a remarkable fact that such a simple concept can be applied to present a\nunified algebraic approach to lambda calculus and first order logic.\n", "versions": [{"version": "v1", "created": "Wed, 19 Dec 2007 20:52:48 GMT"}, {"version": "v2", "created": "Wed, 19 Dec 2007 22:00:20 GMT"}, {"version": "v3", "created": "Fri, 7 Sep 2012 19:46:32 GMT"}], "update_date": "2012-09-10", "authors_parsed": [["Luo", "Zhaohua", ""]]}, {"id": "0712.3113", "submitter": "Wim Vanhoof", "authors": "Andr\\'as Gyorgy B\\'ek\\'es, P\\'eter Szeredi", "title": "Optimizing Queries in a Logic-based Information Integration System", "comments": "Paper presented at the 17th Workshop on Logic-based Methods in\n  Programming Environments (WLPE2007)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": null, "abstract": "  The SINTAGMA information integration system is an infrastructure for\naccessing several different information sources together. Besides providing a\nuniform interface to the information sources (databases, web services, web\nsites, RDF resources, XML files), semantic integration is also needed. Semantic\nintegration is carried out by providing a high-level model and the mappings to\nthe models of the sources. When executing a query of the high level model, a\nquery is transformed to a low-level query plan, which is a piece of Prolog code\nthat answers the high-level query. This transformation is done in two phases.\nFirst, the Query Planner produces a plan as a logic formula expressing the\nlow-level query. Next, the Query Optimizer transforms this formula to\nexecutable Prolog code and optimizes it according to structural and statistical\ninformation about the information sources.\n  This article discusses the main ideas of the optimization algorithm and its\nimplementation.\n", "versions": [{"version": "v1", "created": "Wed, 19 Dec 2007 08:07:30 GMT"}], "update_date": "2007-12-20", "authors_parsed": [["B\u00e9k\u00e9s", "Andr\u00e1s Gyorgy", ""], ["Szeredi", "P\u00e9ter", ""]]}, {"id": "0712.3116", "submitter": "Wim Vanhoof", "authors": "Patricia Hill, Wim Vanhoof", "title": "Proceedings of the 17th Workshop on Logic-based methods in Programming\n  Environments (WLPE 2007)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": null, "abstract": "  This volume contains the papers presented at WLPE 2007: the 17th Workshop on\nLogic-based Methods in Programming Environments on 13th September, 2007 in\nPorto, Portugal. It was held as a satellite workshop of ICLP 2007, the 23th\nInternational Conference on Logic Programming.\n", "versions": [{"version": "v1", "created": "Wed, 19 Dec 2007 08:28:12 GMT"}], "update_date": "2007-12-20", "authors_parsed": [["Hill", "Patricia", ""], ["Vanhoof", "Wim", ""]]}, {"id": "0712.3830", "submitter": "Tom Schrijvers", "authors": "Tom Schrijvers, Bart Demoen, David S. Warren", "title": "TCHR: a framework for tabled CLP", "comments": "Accepted for publication in Theory and Practice of Logic Programming", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": null, "abstract": "  Tabled Constraint Logic Programming is a powerful execution mechanism for\ndealing with Constraint Logic Programming without worrying about fixpoint\ncomputation. Various applications, e.g in the fields of program analysis and\nmodel checking, have been proposed. Unfortunately, a high-level system for\ndeveloping new applications is lacking, and programmers are forced to resort to\ncomplicated ad hoc solutions.\n  This papers presents TCHR, a high-level framework for tabled Constraint Logic\nProgramming. It integrates in a light-weight manner Constraint Handling Rules\n(CHR), a high-level language for constraint solvers, with tabled Logic\nProgramming. The framework is easily instantiated with new application-specific\nconstraint domains. Various high-level operations can be instantiated to\ncontrol performance. In particular, we propose a novel, generalized technique\nfor compacting answer sets.\n", "versions": [{"version": "v1", "created": "Wed, 26 Dec 2007 15:28:16 GMT"}], "update_date": "2007-12-27", "authors_parsed": [["Schrijvers", "Tom", ""], ["Demoen", "Bart", ""], ["Warren", "David S.", ""]]}]