[{"id": "0904.0570", "submitter": "Andreas Schnabl", "authors": "Georg Moser (University of Innsbruck), Andreas Schnabl (University of\n  Innsbruck)", "title": "The Derivational Complexity Induced by the Dependency Pair Method", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (July 13,\n  2011) lmcs:805", "doi": "10.2168/LMCS-7(3:1)2011", "report-no": null, "categories": "cs.LO cs.AI cs.CC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the derivational complexity induced by the dependency pair method,\nenhanced with standard refinements. We obtain upper bounds on the derivational\ncomplexity induced by the dependency pair method in terms of the derivational\ncomplexity of the base techniques employed. In particular we show that the\nderivational complexity induced by the dependency pair method based on some\ndirect technique, possibly refined by argument filtering, the usable rules\ncriterion, or dependency graphs, is primitive recursive in the derivational\ncomplexity induced by the direct method. This implies that the derivational\ncomplexity induced by a standard application of the dependency pair method\nbased on traditional termination orders like KBO, LPO, and MPO is exactly the\nsame as if those orders were applied as the only termination technique.\n", "versions": [{"version": "v1", "created": "Fri, 3 Apr 2009 15:10:50 GMT"}, {"version": "v2", "created": "Fri, 26 Jun 2009 11:33:52 GMT"}, {"version": "v3", "created": "Tue, 21 Sep 2010 08:52:40 GMT"}, {"version": "v4", "created": "Wed, 1 Jun 2011 17:22:27 GMT"}, {"version": "v5", "created": "Mon, 11 Jul 2011 21:10:44 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Moser", "Georg", "", "University of Innsbruck"], ["Schnabl", "Andreas", "", "University of\n  Innsbruck"]]}, {"id": "0904.2136", "submitter": "Fernando S\\'aenz-P\\'erez", "authors": "S. Est\\'evez-Mart\\'in, T. Hortal\\'a-Gonz\\'alez, Rodr\\'iguez-Artalejo,\n  R. del Vado-V\\'irseda, F. S\\'aenz-P\\'erez, and A. J. Fern\\'andez", "title": "On the Cooperation of the Constraint Domains H, R and FD in CFLP", "comments": "113 pages, 5 figures, 18 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a computational model for the cooperation of constraint\ndomains and an implementation for a particular case of practical importance.\nThe computational model supports declarative programming with lazy and possibly\nhigher-order functions, predicates, and the cooperation of different constraint\ndomains equipped with their respective solvers, relying on a so-called\nConstraint Functional Logic Programming (CFLP) scheme. The implementation has\nbeen developed on top of the CFLP system TOY, supporting the cooperation of the\nthree domains H, R and FD, which supply equality and disequality constraints\nover symbolic terms, arithmetic constraints over the real numbers, and finite\ndomain constraints over the integers, respectively. The computational model has\nbeen proved sound and complete w.r.t. the declarative semantics provided by the\n$CFLP$ scheme, while the implemented system has been tested with a set of\nbenchmarks and shown to behave quite efficiently in comparison to the closest\nrelated approach we are aware of.\n  To appear in Theory and Practice of Logic Programming (TPLP)\n", "versions": [{"version": "v1", "created": "Tue, 14 Apr 2009 14:58:46 GMT"}], "update_date": "2009-04-15", "authors_parsed": [["Est\u00e9vez-Mart\u00edn", "S.", ""], ["Hortal\u00e1-Gonz\u00e1lez", "T.", ""], ["Rodr\u00edguez-Artalejo", "", ""], ["del Vado-V\u00edrseda", "R.", ""], ["S\u00e1enz-P\u00e9rez", "F.", ""], ["Fern\u00e1ndez", "A. J.", ""]]}, {"id": "0904.3789", "submitter": "Serguei Mokhov", "authors": "Serguei A. Mokhov and Joey Paquet", "title": "Formally Specifying and Proving Operational Aspects of Forensic Lucid in\n  Isabelle", "comments": "23 pages, 3 listings, 3 figures, 1 table, 1 Appendix with theorems,\n  pp. 76--98. TPHOLs 2008 Emerging Trends Proceedings, August 18-21, Montreal,\n  Canada. Editors: Otmane Ait Mohamed and Cesar Munoz and Sofiene Tahar. The\n  individual paper's PDF is at\n  http://users.encs.concordia.ca/~tphols08/TPHOLs2008/ET/76-98.pdf", "journal-ref": null, "doi": null, "report-no": "2008-1-Ait Mohamed", "categories": "cs.LO cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A Forensic Lucid intensional programming language has been proposed for\nintensional cyberforensic analysis. In large part, the language is based on\nvarious predecessor and codecessor Lucid dialects bound by the higher-order\nintensional logic (HOIL) that is behind them. This work formally specifies the\noperational aspects of the Forensic Lucid language and compiles a theory of its\nconstructs using Isabelle, a proof assistant system.\n", "versions": [{"version": "v1", "created": "Fri, 24 Apr 2009 03:30:20 GMT"}], "update_date": "2009-05-08", "authors_parsed": [["Mokhov", "Serguei A.", ""], ["Paquet", "Joey", ""]]}, {"id": "0904.4120", "submitter": "Ugo Dal Lago", "authors": "Ugo Dal Lago and Simone Martini", "title": "On Constructor Rewrite Systems and the Lambda-Calculus (Long Version)", "comments": "20 pages. Extended version of a paper in the proceedings of ICALP\n  2009, Track B", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that orthogonal constructor term rewrite systems and lambda-calculus\nwith weak (i.e., no reduction is allowed under the scope of a\nlambda-abstraction) call-by-value reduction can simulate each other with a\nlinear overhead. In particular, weak call-by-value beta-reduction can be\nsimulated by an orthogonal constructor term rewrite system in the same number\nof reduction steps. Conversely, each reduction in a term rewrite system can be\nsimulated by a constant number of beta-reduction steps. This is relevant to\nimplicit computational complexity, because the number of beta steps to normal\nform is polynomially related to the actual cost (that is, as performed on a\nTuring machine) of normalization, under weak call-by-value reduction.\nOrthogonal constructor term rewrite systems and lambda-calculus are thus both\npolynomially related to Turing machines, taking as notion of cost their natural\nparameters.\n", "versions": [{"version": "v1", "created": "Mon, 27 Apr 2009 09:49:14 GMT"}, {"version": "v2", "created": "Sun, 5 Jul 2009 16:31:15 GMT"}, {"version": "v3", "created": "Tue, 20 Oct 2009 13:32:34 GMT"}, {"version": "v4", "created": "Thu, 2 Aug 2012 15:16:46 GMT"}], "update_date": "2012-08-03", "authors_parsed": [["Lago", "Ugo Dal", ""], ["Martini", "Simone", ""]]}, {"id": "0904.4709", "submitter": "Dirk Beyer", "authors": "Dirk Beyer, Alessandro Cimatti, Alberto Griggio, M. Erkan Keremoglu,\n  Roberto Sebastiani", "title": "Software Model Checking via Large-Block Encoding", "comments": "13 pages (11 without cover), 4 figures, 5 tables", "journal-ref": null, "doi": null, "report-no": "SFU-CS-2009-09", "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The construction and analysis of an abstract reachability tree (ART) are the\nbasis for a successful method for software verification. The ART represents\nunwindings of the control-flow graph of the program. Traditionally, a\ntransition of the ART represents a single block of the program, and therefore,\nwe call this approach single-block encoding (SBE). SBE may result in a huge\nnumber of program paths to be explored, which constitutes a fundamental source\nof inefficiency. We propose a generalization of the approach, in which\ntransitions of the ART represent larger portions of the program; we call this\napproach large-block encoding (LBE). LBE may reduce the number of paths to be\nexplored up to exponentially. Within this framework, we also investigate\nsymbolic representations: for representing abstract states, in addition to\nconjunctions as used in SBE, we investigate the use of arbitrary Boolean\nformulas; for computing abstract-successor states, in addition to Cartesian\npredicate abstraction as used in SBE, we investigate the use of Boolean\npredicate abstraction. The new encoding leverages the efficiency of\nstate-of-the-art SMT solvers, which can symbolically compute abstract\nlarge-block successors. Our experiments on benchmark C programs show that the\nlarge-block encoding outperforms the single-block encoding.\n", "versions": [{"version": "v1", "created": "Wed, 29 Apr 2009 21:53:56 GMT"}], "update_date": "2009-05-01", "authors_parsed": [["Beyer", "Dirk", ""], ["Cimatti", "Alessandro", ""], ["Griggio", "Alberto", ""], ["Keremoglu", "M. Erkan", ""], ["Sebastiani", "Roberto", ""]]}, {"id": "0904.4727", "submitter": "Yi-Dong Shen", "authors": "Yi-Dong Shen, Jia-Huai You, Li-Yan Yuan", "title": "Characterizations of Stable Model Semantics for Logic Programs with\n  Arbitrary Constraint Atoms", "comments": "34 pages. To appear in Theory and Practice of Logic Programming\n  (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies the stable model semantics of logic programs with\n(abstract) constraint atoms and their properties. We introduce a succinct\nabstract representation of these constraint atoms in which a constraint atom is\nrepresented compactly. We show two applications. First, under this\nrepresentation of constraint atoms, we generalize the Gelfond-Lifschitz\ntransformation and apply it to define stable models (also called answer sets)\nfor logic programs with arbitrary constraint atoms. The resulting semantics\nturns out to coincide with the one defined by Son et al., which is based on a\nfixpoint approach. One advantage of our approach is that it can be applied, in\na natural way, to define stable models for disjunctive logic programs with\nconstraint atoms, which may appear in the disjunctive head as well as in the\nbody of a rule. As a result, our approach to the stable model semantics for\nlogic programs with constraint atoms generalizes a number of previous\napproaches. Second, we show that our abstract representation of constraint\natoms provides a means to characterize dependencies of atoms in a program with\nconstraint atoms, so that some standard characterizations and properties\nrelying on these dependencies in the past for logic programs with ordinary\natoms can be extended to logic programs with constraint atoms.\n", "versions": [{"version": "v1", "created": "Thu, 30 Apr 2009 01:15:51 GMT"}], "update_date": "2009-05-01", "authors_parsed": [["Shen", "Yi-Dong", ""], ["You", "Jia-Huai", ""], ["Yuan", "Li-Yan", ""]]}, {"id": "0904.4902", "submitter": "Tal Lev-Ami", "authors": "Tal Lev-Ami, Neil Immerman, Thomas Reps, Mooly Sagiv, Siddharth\n  Srivastava, Greta Yorsh", "title": "Simulating reachability using first-order logic with applications to\n  verification of linked data structures", "comments": "30 pages, LMCS", "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 2 (May 28,\n  2009) lmcs:680", "doi": "10.2168/LMCS-5(2:12)2009", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper shows how to harness existing theorem provers for first-order\nlogic to automatically verify safety properties of imperative programs that\nperform dynamic storage allocation and destructive updating of pointer-valued\nstructure fields. One of the main obstacles is specifying and proving the\n(absence) of reachability properties among dynamically allocated cells.\n  The main technical contributions are methods for simulating reachability in a\nconservative way using first-order formulas--the formulas describe a superset\nof the set of program states that would be specified if one had a precise way\nto express reachability. These methods are employed for semi-automatic program\nverification (i.e., using programmer-supplied loop invariants) on programs such\nas mark-and-sweep garbage collection and destructive reversal of a singly\nlinked list. (The mark-and-sweep example has been previously reported as being\nbeyond the capabilities of ESC/Java.)\n", "versions": [{"version": "v1", "created": "Thu, 30 Apr 2009 17:54:54 GMT"}, {"version": "v2", "created": "Wed, 27 May 2009 22:05:51 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Lev-Ami", "Tal", ""], ["Immerman", "Neil", ""], ["Reps", "Thomas", ""], ["Sagiv", "Mooly", ""], ["Srivastava", "Siddharth", ""], ["Yorsh", "Greta", ""]]}]