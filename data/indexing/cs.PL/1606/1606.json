[{"id": "1606.00502", "submitter": "EPTCS", "authors": "Nafi Diallo (NJIT, Newark NJ), Wided Ghardallou (FST, Tunis, Tunisia),\n  Ali Mili (NJIT, Newark NJ)", "title": "Program Repair by Stepwise Correctness Enhancement", "comments": "In Proceedings PrePost 2016, arXiv:1605.08096", "journal-ref": "EPTCS 208, 2016, pp. 1-15", "doi": "10.4204/EPTCS.208.1", "report-no": null, "categories": "cs.SE cs.DM cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Relative correctness is the property of a program to be more-correct than\nanother with respect to a given specification. Whereas the traditional\ndefinition of (absolute) correctness divides candidate program into two classes\n(correct, and incorrect), relative correctness arranges candidate programs on\nthe richer structure of a partial ordering. In other venues we discuss the\nimpact of relative correctness on program derivation, and on program\nverification. In this paper, we discuss the impact of relative correctness on\nprogram testing; specifically, we argue that when we remove a fault from a\nprogram, we ought to test the new program for relative correctness over the old\nprogram, rather than for absolute correctness. We present analytical arguments\nto support our position, as well as an empirical argument in the form of a\nsmall program whose faults are removed in a stepwise manner as its relative\ncorrectness rises with each fault removal until we obtain a correct program.\n", "versions": [{"version": "v1", "created": "Wed, 1 Jun 2016 23:59:02 GMT"}], "update_date": "2016-06-03", "authors_parsed": [["Diallo", "Nafi", "", "NJIT, Newark NJ"], ["Ghardallou", "Wided", "", "FST, Tunis, Tunisia"], ["Mili", "Ali", "", "NJIT, Newark NJ"]]}, {"id": "1606.01081", "submitter": "Rod Moten", "authors": "Rod Moten, Kemafor Anyanwu-Ogan, Sahibi Miranshah", "title": "Implementing graph grammars for intelligence analysis in OCaml", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We report on implementing graph grammars for intelligence analysis in OCaml.\nGraph grammars are represented as elements of an algebraic data type in OCaml.\nIn addition to algebraic data types, we use other concepts from functional\nprogramming languages to implement features of graph grammars. We use type\nchecking to perform graph pattern matching. Graph transformations are defined\nas implicit coercions derived from structural subtyping proofs, subset types,\nlambda abstractions, and analytics. An analytic is a general-purpose OCaml\nfunction whose output is required to match a graph pattern described by an\nelement of an algebraic data type. By using a strongly-typed language for\nrepresenting graphs, we can ensure graphs produced from a graph transformation\nwill match a specific schema. This is a high priority requirement for\nintelligence analysis.\n", "versions": [{"version": "v1", "created": "Fri, 3 Jun 2016 13:28:37 GMT"}], "update_date": "2016-06-06", "authors_parsed": [["Moten", "Rod", ""], ["Anyanwu-Ogan", "Kemafor", ""], ["Miranshah", "Sahibi", ""]]}, {"id": "1606.01106", "submitter": "Tommaso Petrucciani", "authors": "Giuseppe Castagna (CNRS, IRIF), Tommaso Petrucciani (IRIF, DIBRIS),\n  Kim Nguyen (LRI)", "title": "Set-Theoretic Types for Polymorphic Variants", "comments": "ACM SIGPLAN International Conference on Functional Programming, Sep\n  2016, Nara, Japan. ICFP 16, 21st ACM SIGPLAN International Conference on\n  Functional Programming, 2016", "journal-ref": null, "doi": "10.1145/2951913.2951928", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Polymorphic variants are a useful feature of the OCaml language whose current\ndefinition and implementation rely on kinding constraints to simulate a\nsubtyping relation via unification. This yields an awkward formalization and\nresults in a type system whose behaviour is in some cases unintuitive and/or\nunduly restrictive. In this work, we present an alternative formalization of\npoly-morphic variants, based on set-theoretic types and subtyping, that yields\na cleaner and more streamlined system. Our formalization is more expressive\nthan the current one (it types more programs while preserving type safety), it\ncan internalize some meta-theoretic properties, and it removes some\npathological cases of the current implementation resulting in a more intuitive\nand, thus, predictable type system. More generally, this work shows how to add\nfull-fledged union types to functional languages of the ML family that usually\nrely on the Hindley-Milner type system. As an aside, our system also improves\nthe theory of semantic subtyping, notably by proving completeness for the type\nreconstruction algorithm.\n", "versions": [{"version": "v1", "created": "Fri, 3 Jun 2016 14:34:55 GMT"}, {"version": "v2", "created": "Tue, 5 Jul 2016 08:51:06 GMT"}], "update_date": "2016-07-06", "authors_parsed": [["Castagna", "Giuseppe", "", "CNRS, IRIF"], ["Petrucciani", "Tommaso", "", "IRIF, DIBRIS"], ["Nguyen", "Kim", "", "LRI"]]}, {"id": "1606.01400", "submitter": "Anton Podkopaev", "authors": "Anton Podkopaev, Ilya Sergey, Aleksandar Nanevski", "title": "Operational Aspects of C/C++ Concurrency", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we present a family of operational semantics that gradually\napproximates the realistic program behaviors in the C/C++11 memory model. Each\nsemantics in our framework is built by elaborating and combining two simple\ningredients: viewfronts and operation buffers. Viewfronts allow us to express\nthe spatial aspect of thread interaction, i.e., which values a thread can read,\nwhile operation buffers enable manipulation with the temporal execution aspect,\ni.e., determining the order in which the results of certain operations can be\nobserved by concurrently running threads.\n  Starting from a simple abstract state machine, through a series of gradual\nrefinements of the abstract state, we capture such language aspects and\nsynchronization primitives as release/acquire atomics, sequentially-consistent\nand non-atomic memory accesses, also providing a semantics for relaxed atomics,\nwhile avoiding the Out-of-Thin-Air problem. To the best of our knowledge, this\nis the first formal and executable operational semantics of C11 capable of\nexpressing all essential concurrent aspects of the standard.\n  We illustrate our approach via a number of characteristic examples, relating\nthe observed behaviors to those of standard litmus test programs from the\nliterature. We provide an executable implementation of the semantics in PLT\nRedex, along with a number of implemented litmus tests and examples, and\nshowcase our prototype on a large case study: randomized testing and debugging\nof a realistic Read-Copy-Update data structure.\n", "versions": [{"version": "v1", "created": "Sat, 4 Jun 2016 17:40:40 GMT"}, {"version": "v2", "created": "Sat, 9 Jul 2016 09:32:15 GMT"}], "update_date": "2016-07-12", "authors_parsed": [["Podkopaev", "Anton", ""], ["Sergey", "Ilya", ""], ["Nanevski", "Aleksandar", ""]]}, {"id": "1606.01451", "submitter": "Anthony Widjaja Lin", "authors": "Anthony W. Lin, Philipp Ruemmer", "title": "Liveness of Randomised Parameterised Systems under Arbitrary Schedulers\n  (Technical Report)", "comments": "Full version of CAV'16 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problem of verifying liveness for systems with a finite, but\nunbounded, number of processes, commonly known as parameterised systems.\nTypical examples of such systems include distributed protocols (e.g. for the\ndining philosopher problem). Unlike the case of verifying safety, proving\nliveness is still considered extremely challenging, especially in the presence\nof randomness in the system. In this paper we consider liveness under arbitrary\n(including unfair) schedulers, which is often considered a desirable property\nin the literature of self-stabilising systems. We introduce an automatic method\nof proving liveness for randomised parameterised systems under arbitrary\nschedulers. Viewing liveness as a two-player reachability game (between\nScheduler and Process), our method is a CEGAR approach that synthesises a\nprogress relation for Process that can be symbolically represented as a\nfinite-state automaton. The method is incremental and exploits both\nAngluin-style L*-learning and SAT-solvers. Our experiments show that our\nalgorithm is able to prove liveness automatically for well-known randomised\ndistributed protocols, including Lehmann-Rabin Randomised Dining Philosopher\nProtocol and randomised self-stabilising protocols (such as the Israeli-Jalfon\nProtocol). To the best of our knowledge, this is the first fully-automatic\nmethod that can prove liveness for randomised protocols.\n", "versions": [{"version": "v1", "created": "Sun, 5 Jun 2016 02:29:19 GMT"}], "update_date": "2016-06-07", "authors_parsed": [["Lin", "Anthony W.", ""], ["Ruemmer", "Philipp", ""]]}, {"id": "1606.02021", "submitter": "EPTCS", "authors": "Alvaro Miyazawa (University of York), Ana Cavalcanti (University of\n  York)", "title": "SCJ-Circus: a refinement-oriented formal notation for Safety-Critical\n  Java", "comments": "In Proceedings Refine'15, arXiv:1606.01344", "journal-ref": "EPTCS 209, 2016, pp. 71-86", "doi": "10.4204/EPTCS.209.6", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Safety-Critical Java (SCJ) is a version of Java whose goal is to support the\ndevelopment of real-time, embedded, safety-critical software. In particular,\nSCJ supports certification of such software by introducing abstractions that\nenforce a simpler architecture, and simpler concurrency and memory models. In\nthis paper, we present SCJ-Circus, a refinement-oriented formal notation that\nsupports the specification and verification of low-level programming models\nthat include the new abstractions introduced by SCJ. SCJ-Circus is part of the\nfamily of state-rich process algebra Circus, as such, SCJ-Circus includes the\nCircus constructs for modelling sequential and concurrent behaviour, real-time\nand object orientation. We present here the syntax and semantics of SCJ-Circus,\nwhich is defined by mapping SCJ-Circus constructs to those of standard Circus.\nThis is based on an existing approach for modelling SCJ programs. We also\nextend an existing Circus-based refinement strategy that targets SCJ programs\nto account for the generation of SCJ-Circus models close to implementations in\nSCJ.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2016 04:09:36 GMT"}], "update_date": "2016-06-08", "authors_parsed": [["Miyazawa", "Alvaro", "", "University of York"], ["Cavalcanti", "Ana", "", "University of\n  York"]]}, {"id": "1606.02022", "submitter": "EPTCS", "authors": "Jason Koenig (Stanford University), K. Rustan M. Leino (Microsoft\n  Research)", "title": "Programming Language Features for Refinement", "comments": "In Proceedings Refine'15, arXiv:1606.01344", "journal-ref": "EPTCS 209, 2016, pp. 87-106", "doi": "10.4204/EPTCS.209.7", "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Algorithmic and data refinement are well studied topics that provide a\nmathematically rigorous approach to gradually introducing details in the\nimplementation of software. Program refinements are performed in the context of\nsome programming language, but mainstream languages lack features for recording\nthe sequence of refinement steps in the program text. To experiment with the\ncombination of refinement, automated verification, and language design,\nrefinement features have been added to the verification-aware programming\nlanguage Dafny. This paper describes those features and reflects on some\ninitial usage thereof.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2016 04:09:44 GMT"}], "update_date": "2016-06-08", "authors_parsed": [["Koenig", "Jason", "", "Stanford University"], ["Leino", "K. Rustan M.", "", "Microsoft\n  Research"]]}, {"id": "1606.03180", "submitter": "Yoshihiko Kakutani", "authors": "Yoshihiko Kakutani", "title": "Calculi for Intuitionistic Normal Modal Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper provides a call-by-name and a call-by-value term calculus, both of\nwhich have a Curry-Howard correspondence to the box fragment of the\nintuitionistic modal logic IK. The strong normalizability and the confluency of\nthe calculi are shown. Moreover, we define a CPS transformation from the\ncall-by-value calculus to the call-by-name calculus, and show its soundness and\ncompleteness.\n", "versions": [{"version": "v1", "created": "Fri, 10 Jun 2016 05:19:27 GMT"}], "update_date": "2016-06-17", "authors_parsed": [["Kakutani", "Yoshihiko", ""]]}, {"id": "1606.03644", "submitter": "Matthias Springer", "authors": "Matthias Springer", "title": "Inter-language Collaboration in an Object-oriented Virtual Machine", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multi-language virtual machines have a number of advantages. They allow\nsoftware developers to use software libraries that were written for different\nprogramming languages. Furthermore, language implementors do not have to bother\nwith low-level VM functionality and their implementation can benefit from\noptimizations in existing virtual machines. MagLev is an implementation of the\nRuby programming language on top of the GemStone/S virtual machine for the\nSmalltalk programming language. In this work, we present how software\ncomponents written in both languages can interact. We show how MagLev unifies\nthe Smalltalk and the Ruby object model, taking into account Smalltalk meta\nclasses, Ruby singleton classes, and Ruby modules. Besides, we show how we can\ncall Ruby methods from Smalltalk and vice versa. We also present MagLev's\nconcept of bridge methods for implementing Ruby method calling conventions.\nFinally, we compare our solution to other language implementations and virtual\nmachines.\n", "versions": [{"version": "v1", "created": "Sat, 11 Jun 2016 23:52:54 GMT"}], "update_date": "2016-06-14", "authors_parsed": [["Springer", "Matthias", ""]]}, {"id": "1606.03809", "submitter": "Moez AbdelGawad", "authors": "Moez A. AbdelGawad", "title": "Why Nominal-Typing Matters in OOP", "comments": "19 pages. arXiv admin note: text overlap with arXiv:1603.08648", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The statements `inheritance is not subtyping' and `mainstream OO languages\nunnecessarily place restrictions over inheritance' have rippled as mantras\nthrough the PL research community for years. Many mainstream OO developers and\nOO language designers however do not accept these statements. In\n\\emph{nominally-typed} OO languages that these developers and language\ndesigners are dearly familiar with, inheritance simply is subtyping; and they\nbelieve OO type inheritance is an inherently nominal notion not a structural\none.\n  Nominally-typed OO languages are among the most used programming languages\ntoday. However, the value of nominal typing to mainstream OO developers, as a\nmeans for designing robust OO software, seems to be in wait for full\nappreciation among PL researchers--thereby perpetuating an unnecessary schism\nbetween many OO developers and language designers and many OO PL researchers,\nwith each side discounting, if not even disregarding, the views of the other.\n  In this essay we strengthen earlier efforts to demonstrate the semantic value\nof nominal typing by presenting a technical comparison between nominal OO type\nsystems and structural OO type systems. Recently, a domain-theoretic model of\nnominally-typed OOP was compared to well-known models of structurally-typed\nOOP. Combined, these comparisons provide a clear and deep account for the\nrelation between nominal and structural OO type systems that has not been\npresented before, and they help demonstrate the key value of nominal typing and\nnominal subtyping to OO developers and language designers.\n  We believe a clearer understanding of the key semantic advantage of pure\nnominal OO typing over pure structural OO typing can help remedy the existing\nschism. We believe future foundational OO PL research, to further its relevance\nto mainstream OOP, should be based less on structural models of OOP and more on\nnominal ones instead.\n", "versions": [{"version": "v1", "created": "Mon, 13 Jun 2016 04:37:13 GMT"}, {"version": "v2", "created": "Sun, 30 Oct 2016 16:13:16 GMT"}, {"version": "v3", "created": "Fri, 29 Dec 2017 17:42:42 GMT"}], "update_date": "2018-01-01", "authors_parsed": [["AbdelGawad", "Moez A.", ""]]}, {"id": "1606.04074", "submitter": "Pedro Lopez-Garcia", "authors": "Kerstin Eder and John P. Gallagher and Pedro Lopez-Garcia and Henk\n  Muller and Zorana Bankovic and Kyriakos Georgiou and Remy Haemmerle and\n  Manuel V. Hermenegildo and Bishoksan Kafle and Steve Kerrison and Maja\n  Kirkeby and Maximiliano Klemen and Xueliang Li and Umer Liqat and Jeremy\n  Morse and Morten Rhiger and Mads Rosendahl", "title": "ENTRA: Whole-Systems Energy Transparency", "comments": "Revised preprint submitted to MICPRO on 27 May 2016, 23 pages, 3\n  figures", "journal-ref": null, "doi": "10.1016/j.micpro.2016.07.003", "report-no": null, "categories": "cs.AR cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Promoting energy efficiency to a first class system design goal is an\nimportant research challenge. Although more energy-efficient hardware can be\ndesigned, it is software that controls the hardware; for a given system the\npotential for energy savings is likely to be much greater at the higher levels\nof abstraction in the system stack. Thus the greatest savings are expected from\nenergy-aware software development, which is the vision of the EU ENTRA project.\nThis article presents the concept of energy transparency as a foundation for\nenergy-aware software development. We show how energy modelling of hardware is\ncombined with static analysis to allow the programmer to understand the energy\nconsumption of a program without executing it, thus enabling exploration of the\ndesign space taking energy into consideration. The paper concludes by\nsummarising the current and future challenges identified in the ENTRA project.\n", "versions": [{"version": "v1", "created": "Mon, 13 Jun 2016 19:16:52 GMT"}, {"version": "v2", "created": "Sat, 18 Jun 2016 05:56:38 GMT"}], "update_date": "2020-05-18", "authors_parsed": [["Eder", "Kerstin", ""], ["Gallagher", "John P.", ""], ["Lopez-Garcia", "Pedro", ""], ["Muller", "Henk", ""], ["Bankovic", "Zorana", ""], ["Georgiou", "Kyriakos", ""], ["Haemmerle", "Remy", ""], ["Hermenegildo", "Manuel V.", ""], ["Kafle", "Bishoksan", ""], ["Kerrison", "Steve", ""], ["Kirkeby", "Maja", ""], ["Klemen", "Maximiliano", ""], ["Li", "Xueliang", ""], ["Liqat", "Umer", ""], ["Morse", "Jeremy", ""], ["Rhiger", "Morten", ""], ["Rosendahl", "Mads", ""]]}, {"id": "1606.04216", "submitter": "Yura Perov N", "authors": "Mike Wu, Yura Perov, Frank Wood, Hongseok Yang", "title": "Spreadsheet Probabilistic Programming", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Spreadsheet workbook contents are simple programs. Because of this,\nprobabilistic programming techniques can be used to perform Bayesian inversion\nof spreadsheet computations. What is more, existing execution engines in\nspreadsheet applications such as Microsoft Excel can be made to do this using\nonly built-in functionality. We demonstrate this by developing a native Excel\nimplementation of both a particle Markov Chain Monte Carlo variant and\nblack-box variational inference for spreadsheet probabilistic programming. The\nresulting engine performs probabilistically coherent inference over spreadsheet\ncomputations, notably including spreadsheets that include user-defined\nblack-box functions. Spreadsheet engines that choose to integrate the\nfunctionality we describe in this paper will give their users the ability to\nboth easily develop probabilistic models and maintain them over time by\nincluding actuals via a simple user-interface mechanism. For spreadsheet\nend-users this would mean having access to efficient and probabilistically\ncoherent probabilistic modeling and inference for use in all kinds of decision\nmaking under uncertainty.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2016 07:01:00 GMT"}], "update_date": "2016-06-15", "authors_parsed": [["Wu", "Mike", ""], ["Perov", "Yura", ""], ["Wood", "Frank", ""], ["Yang", "Hongseok", ""]]}, {"id": "1606.04240", "submitter": "Keehang Kwon", "authors": "Keehang Kwon", "title": "For-loops in Logic Programming", "comments": "5 pages. slightly revised from my previous Korean paper (KIPS\n  transactions, part A, vol 19, no.1, 2012.)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logic programming has traditiLogic programming has traditionally lacked\ndevices for expressing iterative tasks. To overcome this problem, this paper\nproposes iterative goal formulas of the form $\\seqandq{x}{L} G$ where $G$ is a\ngoal, $x$ is a variable, and $L$ is a list. $\\seqandq{x}{L}$ is called a\nparallel bounded quantifier. These goals allow us to specify the following\ntask: iterate $G$ with $x$ ranging over all the elements of $L$. onally lacked\ndevices for expressing iterative tasks. To overcome this problem, this paper\nproposes iterative goal formulas of the form $\\seqandq{x}{L} G$ where $G$ is a\ngoal, $x$ is a variable, and $L$ is a list. $\\seqandq{x}{L}$ is called a\nparallel bounded quantifier. These goals allow us to specify the following\ntask: iterate $G$ with $x$ ranging over all the elements of $L$.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2016 08:06:01 GMT"}], "update_date": "2016-06-15", "authors_parsed": [["Kwon", "Keehang", ""]]}, {"id": "1606.04282", "submitter": "Polyvios Pratikakis", "authors": "Spyros Lyberis, Polyvios Pratikakis, Iakovos Mavroidis, Dimitrios S.\n  Nikolopoulos", "title": "Myrmics: Scalable, Dependency-aware Task Scheduling on Heterogeneous\n  Manycores", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Task-based programming models have become very popular, as they offer an\nattractive solution to parallelize serial application code with task and data\nannotations. They usually depend on a runtime system that schedules the tasks\nto multiple cores in parallel while resolving any data hazards. However,\nexisting runtime system implementations are not ready to scale well on emerging\nmanycore processors, as they often rely on centralized structures and/or locks\non shared structures in a cache-coherent memory. We propose design choices,\npolicies and mechanisms to enhance runtime system scalability for single-chip\nprocessors with hundreds of cores. Based on these concepts, we create and\nevaluate Myrmics, a runtime system for a dependency-aware, task-based\nprogramming model on a heterogeneous hardware prototype platform that emulates\na single-chip processor of 8 latency-optimized and 512 throughput-optimized\nCPUs. We find that Myrmics scales successfully to hundreds of cores. Compared\nto MPI versions of the same benchmarks with hand-tuned message passing, Myrmics\nachieves similar scalability with a 10-30% performance overhead, but with less\nprogramming effort. We analyze the scalability of the runtime system in detail\nand identify the key factors that contribute to it.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2016 09:46:40 GMT"}], "update_date": "2016-06-15", "authors_parsed": [["Lyberis", "Spyros", ""], ["Pratikakis", "Polyvios", ""], ["Mavroidis", "Iakovos", ""], ["Nikolopoulos", "Dimitrios S.", ""]]}, {"id": "1606.04288", "submitter": "Polyvios Pratikakis", "authors": "Alexandros Labrineas, Polyvios Pratikakis, Dimitrios S. Nikolopoulos,\n  Angelos Bilas", "title": "BDDT-SCC: A Task-parallel Runtime for Non Cache-Coherent Multicores", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents BDDT-SCC, a task-parallel runtime system for non\ncache-coherent multicore processors, implemented for the Intel Single-Chip\nCloud Computer. The BDDT-SCC runtime includes a dynamic dependence analysis and\nautomatic synchronization, and executes OpenMP-Ss tasks on a non cache-coherent\narchitecture. We design a runtime that uses fast on-chip inter-core\ncommunication with small messages. At the same time, we use non coherent shared\nmemory to avoid large core-to-core data transfers that would incur a high\nvolume of unnecessary copying. We evaluate BDDT-SCC on a set of representative\nbenchmarks, in terms of task granularity, locality, and communication. We find\nthat memory locality and allocation plays a very important role in performance,\nas the architecture of the SCC memory controllers can create strong contention\neffects. We suggest patterns that improve memory locality and thus the\nperformance of applications, and measure their impact.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2016 10:09:42 GMT"}], "update_date": "2016-06-15", "authors_parsed": [["Labrineas", "Alexandros", ""], ["Pratikakis", "Polyvios", ""], ["Nikolopoulos", "Dimitrios S.", ""], ["Bilas", "Angelos", ""]]}, {"id": "1606.04296", "submitter": "Foivos Zakkak", "authors": "Foivos S. Zakkak and Polyvios Pratikakis", "title": "DiSquawk: 512 cores, 512 memories, 1 JVM", "comments": null, "journal-ref": null, "doi": null, "report-no": "FORTH-ICS/TR-470, June 2016", "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Trying to cope with the constantly growing number of cores per processor,\nhardware architects are experimenting with modular non-cache-coherent\narchitectures. Such architectures delegate the memory coherency to the\nsoftware. On the contrary, high productivity languages, like Java, are designed\nto abstract away the hardware details and allow developers to focus on the\nimplementation of their algorithm. Such programming languages rely on a process\nvirtual machine to perform the necessary operations to implement the\ncorresponding memory model. Arguing about the correctness of such\nimplementations is not trivial though.\n  In this work we present our implementation of the Java Memory Model in a Java\nVirtual Machine targeting a 512-core non-cache-coherent memory architecture. We\nshortly discuss design decisions and present early evaluation results, which\ndemonstrate that our implementation scales with the number of cores. We model\nour implementation as the operational semantics of a Java Core Calculus that we\nextend with synchronization actions, and prove its adherence to the Java Memory\nModel.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2016 10:43:18 GMT"}], "update_date": "2016-06-15", "authors_parsed": [["Zakkak", "Foivos S.", ""], ["Pratikakis", "Polyvios", ""]]}, {"id": "1606.05223", "submitter": "Hans Bugge Grathwohl", "authors": "Lars Birkedal, Ale\\v{s} Bizjak, Ranald Clouston, Hans Bugge Grathwohl,\n  Bas Spitters, Andrea Vezzosi", "title": "Guarded Cubical Type Theory: Path Equality for Guarded Recursion", "comments": "17 pages, to be published in proceedings of CSL 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper improves the treatment of equality in guarded dependent type\ntheory (GDTT), by combining it with cubical type theory (CTT). GDTT is an\nextensional type theory with guarded recursive types, which are useful for\nbuilding models of program logics, and for programming and reasoning with\ncoinductive types. We wish to implement GDTT with decidable type-checking,\nwhile still supporting non-trivial equality proofs that reason about the\nextensions of guarded recursive constructions. CTT is a variation of\nMartin-L\\\"of type theory in which the identity type is replaced by abstract\npaths between terms. CTT provides a computational interpretation of functional\nextensionality, is conjectured to have decidable type checking, and has an\nimplemented type-checker. Our new type theory, called guarded cubical type\ntheory, provides a computational interpretation of extensionality for guarded\nrecursive types. This further expands the foundations of CTT as a basis for\nformalisation in mathematics and computer science. We present examples to\ndemonstrate the expressivity of our type theory, all of which have been checked\nusing a prototype type-checker implementation, and present semantics in a\npresheaf category.\n", "versions": [{"version": "v1", "created": "Thu, 16 Jun 2016 15:32:47 GMT"}, {"version": "v2", "created": "Tue, 28 Jun 2016 11:42:40 GMT"}], "update_date": "2016-06-29", "authors_parsed": [["Birkedal", "Lars", ""], ["Bizjak", "Ale\u0161", ""], ["Clouston", "Ranald", ""], ["Grathwohl", "Hans Bugge", ""], ["Spitters", "Bas", ""], ["Vezzosi", "Andrea", ""]]}, {"id": "1606.05403", "submitter": "EPTCS", "authors": "Dominic Orchard (University of Cambridge), Nobuko Yoshida (Imperial\n  College London)", "title": "Proceedings of the Ninth workshop on Programming Language Approaches to\n  Concurrency- and Communication-cEntric Software", "comments": null, "journal-ref": "EPTCS 211, 2016", "doi": "10.4204/EPTCS.211", "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  PLACES 2016 (full title: Programming Language Approaches to Concurrency- and\nCommunication-Centric Software) is the ninth edition of the PLACES workshop\nseries. After the first PLACES, which was affiliated to DisCoTec in 2008, the\nworkshop has been part of ETAPS every year since 2009 and is now an established\npart of the ETAPS satellite events. PLACES 2016 was held on 8th April in\nEindhoven, The Netherlands. The workshop series was started in order to promote\nthe application of novel programming language ideas to the increasingly\nimportant problem of developing software for systems in which concurrency and\ncommunication are intrinsic aspects. This includes software for both multi-core\nsystems and large-scale distributed and/or service-oriented systems. The scope\nof PLACES includes new programming language features, whole new programming\nlanguage designs, new type systems, new semantic approaches, new program\nanalysis techniques, and new implementation mechanisms. This volume consists of\nthe papers accepted for presentation at the workshop.\n", "versions": [{"version": "v1", "created": "Fri, 17 Jun 2016 01:54:40 GMT"}], "update_date": "2016-06-20", "authors_parsed": [["Orchard", "Dominic", "", "University of Cambridge"], ["Yoshida", "Nobuko", "", "Imperial\n  College London"]]}, {"id": "1606.05416", "submitter": "Sizhuo Zhang", "authors": "Sizhuo Zhang, Arvind, Muralidaran Vijayaraghavan", "title": "Taming Weak Memory Models", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Speculative techniques in microarchitectures relax various dependencies in\nprograms, which contributes to the complexity of (weak) memory models. We show\nusing WMM, a new weak memory model, that the model becomes simpler if it\nincludes load-value speculation and thus, does not enforce any dependency!\nHowever, in the absence of good value-prediction techniques, a programmer may\nend up paying a price for the extra fences. Thus, we also present WMM-D, which\nenforces the dependencies captured by the current microarchitectures. WMM-D is\nstill much simpler than other existing models. We also show that non-atomic\nmulti-copy stores arise as a result of sharing write-through caches. We think\nrestricting microarchitectures to write-back caches (and thus simpler weak\nmemory models) will not incur any performance penalty. Nevertheless, we present\nWMM-S, another extension to WMM, which could model the effects of non-atomic\nmulti-copy stores. WMM, WMM-D, and WMM-S are all defined using Instantaneous\nInstruction Execution (I^2E), a new way of describing memory models without\nexplicit reordering or speculative execution.\n", "versions": [{"version": "v1", "created": "Fri, 17 Jun 2016 04:34:34 GMT"}], "update_date": "2016-06-20", "authors_parsed": [["Zhang", "Sizhuo", ""], ["Arvind", "", ""], ["Vijayaraghavan", "Muralidaran", ""]]}, {"id": "1606.05435", "submitter": "Chinmay Narayan", "authors": "Chinmay Narayan, Subodh Sharma, S.Arun-Kumar", "title": "Efficient Verification of Concurrent Programs Over TSO Memory Model", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address the problem of efficient verification of multi-threaded programs\nrunning over Total Store Order (TSO) memory model. It has been shown that even\nwith finite data domain programs, the complexity of control state reachability\nunder TSO is non-primitive recursive. In this paper, we first present a\nbounded-buffer verification approach wherein a bound on the size of buffers is\nplaced; verification is performed incrementally by increasing the size of the\nbuffer with each iteration of the verification procedure until the said bound\nis reached. For programs operating on finite data domains, we also demonstrate\nthe existence of a buffer bound k such that if the program is safe under that\nbound, then it is also safe for unbounded buffers. We have implemented this\ntechnique in a tool ProofTraPar. Our results against memorax [2], a\nstate-of-the-art sound and complete verifier for TSO memory model, have been\nencouraging.\n", "versions": [{"version": "v1", "created": "Fri, 17 Jun 2016 07:47:02 GMT"}], "update_date": "2016-06-20", "authors_parsed": [["Narayan", "Chinmay", ""], ["Sharma", "Subodh", ""], ["Arun-Kumar", "S.", ""]]}, {"id": "1606.05797", "submitter": "Jeremy Kepner", "authors": "Jeremy Kepner, Vijay Gadepally, Dylan Hutchison, Hayden Jananthan,\n  Timothy Mattson, Siddharth Samsi, Albert Reuther", "title": "Associative Array Model of SQL, NoSQL, and NewSQL Databases", "comments": "9 pages; 6 figures; accepted to IEEE High Performance Extreme\n  Computing (HPEC) conference 2016", "journal-ref": null, "doi": "10.1109/HPEC.2016.7761647", "report-no": null, "categories": "cs.DB cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The success of SQL, NoSQL, and NewSQL databases is a reflection of their\nability to provide significant functionality and performance benefits for\nspecific domains, such as financial transactions, internet search, and data\nanalysis. The BigDAWG polystore seeks to provide a mechanism to allow\napplications to transparently achieve the benefits of diverse databases while\ninsulating applications from the details of these databases. Associative arrays\nprovide a common approach to the mathematics found in different databases: sets\n(SQL), graphs (NoSQL), and matrices (NewSQL). This work presents the SQL\nrelational model in terms of associative arrays and identifies the key\nmathematical properties that are preserved within SQL. These properties include\nassociativity, commutativity, distributivity, identities, annihilators, and\ninverses. Performance measurements on distributivity and associativity show the\nimpact these properties can have on associative array operations. These results\ndemonstrate that associative arrays could provide a mathematical model for\npolystores to optimize the exchange of data and execution queries.\n", "versions": [{"version": "v1", "created": "Sat, 18 Jun 2016 19:29:17 GMT"}], "update_date": "2016-12-13", "authors_parsed": [["Kepner", "Jeremy", ""], ["Gadepally", "Vijay", ""], ["Hutchison", "Dylan", ""], ["Jananthan", "Hayden", ""], ["Mattson", "Timothy", ""], ["Samsi", "Siddharth", ""], ["Reuther", "Albert", ""]]}, {"id": "1606.05839", "submitter": "EPTCS", "authors": "Olivier Danvy (University of Aarhus), Ugo de'Liguoro (Universit\\`a di\n  Torino)", "title": "Proceedings of the Workshop on Continuations", "comments": null, "journal-ref": "EPTCS 212, 2016", "doi": "10.4204/EPTCS.212", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The notion of continuation is ubiquitous in many different areas of computer\nscience, including systems programming, programming languages, algorithmics,\nsemantics, logic, and constructive mathematics. In fact the concept of\ncontinuation nicely realizes sophisticated control mechanisms, which are widely\nused in a variety of applications. Since we cannot escape control features, it\nbecomes a challenge to provide them with sound reasoning principles.\n  Indeed there is much research activity on understanding, representing, and\nreasoning about elaborated non-local control structures, in particular in\ndeclarative programming languages such as functional and logic languages. The\nproceedings of the Workshop on Continuations 2015, held in London in April\n2015, illustrate some of the afore mentioned topics and hopefully they will\ninspire further research work on the subject.\n", "versions": [{"version": "v1", "created": "Sun, 19 Jun 2016 07:25:03 GMT"}], "update_date": "2016-06-21", "authors_parsed": [["Danvy", "Olivier", "", "University of Aarhus"], ["de'Liguoro", "Ugo", "", "Universit\u00e0 di\n  Torino"]]}, {"id": "1606.05939", "submitter": "EPTCS", "authors": "Pierpaolo Degano (Dipartimento di Informatica - Universit\\`a di Pisa),\n  Gian-Luigi Ferrari (Dipartimento di Informatica - Universit\\`a di Pisa),\n  Letterio Galletta (Dipartimento di Informatica - Universit\\`a di Pisa)", "title": "Event-driven Adaptation in COP", "comments": "In Proceedings PLACES 2016, arXiv:1606.05403", "journal-ref": "EPTCS 211, 2016, pp. 37-45", "doi": "10.4204/EPTCS.211.4", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Context-Oriented Programming languages provide us with primitive constructs\nto adapt program behaviour depending on the evolution of their operational\nenvironment, namely the context. In previous work we proposed ML_CoDa, a\ncontext-oriented language with two-components: a declarative constituent for\nprogramming the context and a functional one for computing. This paper\ndescribes an extension of ML_CoDa to deal with adaptation to unpredictable\ncontext changes notified by asynchronous events.\n", "versions": [{"version": "v1", "created": "Mon, 20 Jun 2016 01:09:07 GMT"}], "update_date": "2016-06-21", "authors_parsed": [["Degano", "Pierpaolo", "", "Dipartimento di Informatica - Universit\u00e0 di Pisa"], ["Ferrari", "Gian-Luigi", "", "Dipartimento di Informatica - Universit\u00e0 di Pisa"], ["Galletta", "Letterio", "", "Dipartimento di Informatica - Universit\u00e0 di Pisa"]]}, {"id": "1606.05940", "submitter": "EPTCS", "authors": "Tony Garnock-Jones (Northeastern University, Boston, USA)", "title": "From Events to Reactions: A Progress Report", "comments": "In Proceedings PLACES 2016, arXiv:1606.05403", "journal-ref": "EPTCS 211, 2016, pp. 46-55", "doi": "10.4204/EPTCS.211.5", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Syndicate is a new coordinated, concurrent programming language. It occupies\na novel point on the spectrum between the shared-everything paradigm of threads\nand the shared-nothing approach of actors. Syndicate actors exchange messages\nand share common knowledge via a carefully controlled database that clearly\nscopes conversations. This approach clearly simplifies coordination of\nconcurrent activities. Experience in programming with Syndicate, however,\nsuggests a need to raise the level of linguistic abstraction. In addition to\nwriting event handlers and managing event subscriptions directly, the language\nwill have to support a reactive style of programming. This paper presents\nevent-oriented Syndicate programming and then describes a preliminary design\nfor augmenting it with new reactive programming constructs.\n", "versions": [{"version": "v1", "created": "Mon, 20 Jun 2016 01:09:16 GMT"}], "update_date": "2016-06-21", "authors_parsed": [["Garnock-Jones", "Tony", "", "Northeastern University, Boston, USA"]]}, {"id": "1606.05941", "submitter": "EPTCS", "authors": "Claudio A. Mezzina (IMT School for Advanced Studies Lucca, Italy),\n  Jorge A. P\\'erez (University of Groningen, The Netherlands)", "title": "Reversible Sessions Using Monitors", "comments": "In Proceedings PLACES 2016, arXiv:1606.05403", "journal-ref": "EPTCS 211, 2016, pp. 56-64", "doi": "10.4204/EPTCS.211.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Much research has studied foundations for correct and reliable\ncommunication-centric systems. A salient approach to correctness uses session\ntypes to enforce structured communications; a recent approach to reliability\nuses reversible actions as a way of reacting to unanticipated events or\nfailures. This note develops a simple observation: the machinery required to\ndefine asynchronous semantics and monitoring can also support reversible\nprotocols. We propose a process framework of session communication in which\nmonitors support reversibility. A key novelty in our approach are session types\nwith present and past, which allow us to streamline the semantics of reversible\nactions.\n", "versions": [{"version": "v1", "created": "Mon, 20 Jun 2016 01:09:25 GMT"}], "update_date": "2016-06-21", "authors_parsed": [["Mezzina", "Claudio A.", "", "IMT School for Advanced Studies Lucca, Italy"], ["P\u00e9rez", "Jorge A.", "", "University of Groningen, The Netherlands"]]}, {"id": "1606.05942", "submitter": "EPTCS", "authors": "Wytse Oortwijn (University of Twente), Stefan Blom (University of\n  Twente), Marieke Huisman (University of Twente)", "title": "Future-based Static Analysis of Message Passing Programs", "comments": "In Proceedings PLACES 2016, arXiv:1606.05403", "journal-ref": "EPTCS 211, 2016, pp. 65-72", "doi": "10.4204/EPTCS.211.7", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Message passing is widely used in industry to develop programs consisting of\nseveral distributed communicating components. Developing functionally correct\nmessage passing software is very challenging due to the concurrent nature of\nmessage exchanges. Nonetheless, many safety-critical applications rely on the\nmessage passing paradigm, including air traffic control systems and emergency\nservices, which makes proving their correctness crucial. We focus on the\nmodular verification of MPI programs by statically verifying concrete Java\ncode. We use separation logic to reason about local correctness and define\nabstractions of the communication protocol in the process algebra used by\nmCRL2. We call these abstractions futures as they predict how components will\ninteract during program execution. We establish a provable link between futures\nand program code and analyse the abstract futures via model checking to prove\nglobal correctness. Finally, we verify a leader election protocol to\ndemonstrate our approach.\n", "versions": [{"version": "v1", "created": "Mon, 20 Jun 2016 01:09:35 GMT"}], "update_date": "2016-06-21", "authors_parsed": [["Oortwijn", "Wytse", "", "University of Twente"], ["Blom", "Stefan", "", "University of\n  Twente"], ["Huisman", "Marieke", "", "University of Twente"]]}, {"id": "1606.05943", "submitter": "EPTCS", "authors": "Roly Perera (University of Glasgow), Julien Lange (Imperial College\n  London), Simon J. Gay (University of Glasgow)", "title": "Multiparty Compatibility for Concurrent Objects", "comments": "In Proceedings PLACES 2016, arXiv:1606.05403", "journal-ref": "EPTCS 211, 2016, pp. 73-82", "doi": "10.4204/EPTCS.211.8", "report-no": null, "categories": "cs.PL cs.DC cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Objects and actors are communicating state machines, offering and consuming\ndifferent services at different points in their lifecycle. Two complementary\nchallenges arise when programming such systems. When objects interact, their\nstate machines must be \"compatible\", so that services are requested only when\nthey are available. Dually, when objects refine other objects, their state\nmachines must be \"compliant\", so that services are honoured whenever they are\npromised.\n  In this paper we show how the idea of multiparty compatibility from the\nsession types literature can be applied to both of these problems. We present\nan untyped language in which concurrent objects are checked automatically for\ncompatibility and compliance. For simple objects, checking can be exhaustive\nand has the feel of a type system. More complex objects can be partially\nvalidated via test cases, leading to a methodology closer to continuous\ntesting. Our proof-of-concept implementation is limited in some important\nrespects, but demonstrates the potential value of the approach and the\nrelationship to existing software development practices.\n", "versions": [{"version": "v1", "created": "Mon, 20 Jun 2016 01:09:44 GMT"}], "update_date": "2016-06-21", "authors_parsed": [["Perera", "Roly", "", "University of Glasgow"], ["Lange", "Julien", "", "Imperial College\n  London"], ["Gay", "Simon J.", "", "University of Glasgow"]]}, {"id": "1606.05944", "submitter": "EPTCS", "authors": "Sanjiva Prasad (Indian Institute of Technology Delhi, New Delhi,\n  India)", "title": "Program Execution on Reconfigurable Multicore Architectures", "comments": "In Proceedings PLACES 2016, arXiv:1606.05403", "journal-ref": "EPTCS 211, 2016, pp. 83-91", "doi": "10.4204/EPTCS.211.9", "report-no": null, "categories": "cs.PL cs.DC cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Based on the two observations that diverse applications perform better on\ndifferent multicore architectures, and that different phases of an application\nmay have vastly different resource requirements, Pal et al. proposed a novel\nreconfigurable hardware approach for executing multithreaded programs. Instead\nof mapping a concurrent program to a fixed architecture, the architecture\nadaptively reconfigures itself to meet the application's concurrency and\ncommunication requirements, yielding significant improvements in performance.\nBased on our earlier abstract operational framework for multicore execution\nwith hierarchical memory structures, we describe execution of multithreaded\nprograms on reconfigurable architectures that support a variety of clustered\nconfigurations. Such reconfiguration may not preserve the semantics of programs\ndue to the possible introduction of race conditions arising from concurrent\naccesses to shared memory by threads running on the different cores. We present\nan intuitive partial ordering notion on the cluster configurations, and show\nthat the semantics of multithreaded programs is always preserved for\nreconfigurations \"upward\" in that ordering, whereas semantics preservation for\narbitrary reconfigurations can be guaranteed for well-synchronised programs. We\nfurther show that a simple approximate notion of efficiency of execution on the\ndifferent configurations can be obtained using the notion of amortised\nbisimulations, and extend it to dynamic reconfiguration.\n", "versions": [{"version": "v1", "created": "Mon, 20 Jun 2016 01:09:54 GMT"}], "update_date": "2016-06-21", "authors_parsed": [["Prasad", "Sanjiva", "", "Indian Institute of Technology Delhi, New Delhi,\n  India"]]}, {"id": "1606.06125", "submitter": "Jirka Marsik", "authors": "Jirka Mar\\v{s}\\'ik (SEMAGRAMME), Maxime Amblard (MSH Lorraine,\n  SEMAGRAMME)", "title": "Introducing a Calculus of Effects and Handlers for Natural Language\n  Semantics", "comments": null, "journal-ref": "Formal Grammar 2016, Aug 2016, Bozen-Bolzano, Italy", "doi": null, "report-no": null, "categories": "cs.CL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In compositional model-theoretic semantics, researchers assemble\ntruth-conditions or other kinds of denotations using the lambda calculus. It\nwas previously observed that the lambda terms and/or the denotations studied\ntend to follow the same pattern: they are instances of a monad. In this paper,\nwe present an extension of the simply-typed lambda calculus that exploits this\nuniformity using the recently discovered technique of effect handlers. We prove\nthat our calculus exhibits some of the key formal properties of the lambda\ncalculus and we use it to construct a modular semantics for a small fragment\nthat involves multiple distinct semantic phenomena.\n", "versions": [{"version": "v1", "created": "Mon, 20 Jun 2016 14:05:59 GMT"}, {"version": "v2", "created": "Fri, 8 Jul 2016 07:14:44 GMT"}], "update_date": "2016-07-11", "authors_parsed": [["Mar\u0161\u00edk", "Jirka", "", "SEMAGRAMME"], ["Amblard", "Maxime", "", "MSH Lorraine,\n  SEMAGRAMME"]]}, {"id": "1606.06269", "submitter": "Yanhong Annie Liu", "authors": "Yanhong A. Liu and Scott D. Stoller", "title": "Founded Semantics and Constraint Semantics of Logic Rules", "comments": null, "journal-ref": "Journal of Logic and Computation, Volume 30, Issue 8, December\n  2020, Pages 1609-1668", "doi": "10.1093/logcom/exaa056", "report-no": null, "categories": "cs.LO cs.AI cs.DB cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logic rules and inference are fundamental in computer science and have been\nstudied extensively. However, prior semantics of logic languages can have\nsubtle implications and can disagree significantly, on even very simple\nprograms, including in attempting to solve the well-known Russell's paradox.\nThese semantics are often non-intuitive and hard-to-understand when\nunrestricted negation is used in recursion.\n  This paper describes a simple new semantics for logic rules, founded\nsemantics, and its straightforward extension to another simple new semantics,\nconstraint semantics, that unify the core of different prior semantics. The new\nsemantics support unrestricted negation, as well as unrestricted existential\nand universal quantifications. They are uniquely expressive and intuitive by\nallowing assumptions about the predicates, rules, and reasoning to be specified\nexplicitly, as simple and precise binary choices. They are completely\ndeclarative and relate cleanly to prior semantics. In addition, founded\nsemantics can be computed in linear time in the size of the ground program.\n", "versions": [{"version": "v1", "created": "Mon, 20 Jun 2016 19:48:20 GMT"}, {"version": "v2", "created": "Sun, 11 Sep 2016 18:28:29 GMT"}, {"version": "v3", "created": "Sat, 15 Apr 2017 00:24:14 GMT"}, {"version": "v4", "created": "Thu, 26 Mar 2020 15:34:32 GMT"}], "update_date": "2020-12-17", "authors_parsed": [["Liu", "Yanhong A.", ""], ["Stoller", "Scott D.", ""]]}, {"id": "1606.06376", "submitter": "EPTCS", "authors": "Tristan Crolard", "title": "A verified abstract machine for functional coroutines", "comments": "In Proceedings WoC 2015, arXiv:1606.05839", "journal-ref": "EPTCS 212, 2016, pp. 1-17", "doi": "10.4204/EPTCS.212.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Functional coroutines are a restricted form of control mechanism, where each\ncoroutine is represented with both a continuation and an environment. This\nrestriction was originally obtained by considering a constructive version of\nParigot's classical natural deduction which is sound and complete for the\nConstant Domain logic. In this article, we present a refinement of de Groote's\nabstract machine for functional coroutines and we prove its correctness.\nTherefore, this abstract machine also provides a direct computational\ninterpretation of the Constant Domain logic.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2016 00:45:32 GMT"}], "update_date": "2016-06-22", "authors_parsed": [["Crolard", "Tristan", ""]]}, {"id": "1606.06378", "submitter": "EPTCS", "authors": "Philip Johnson-Freyd (University of Oregon), Paul Downen (University\n  of Oregon), Zena M. Ariola (University of Oregon)", "title": "First Class Call Stacks: Exploring Head Reduction", "comments": "In Proceedings WoC 2015, arXiv:1606.05839", "journal-ref": "EPTCS 212, 2016, pp. 18-35", "doi": "10.4204/EPTCS.212.2", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Weak-head normalization is inconsistent with functional extensionality in the\ncall-by-name $\\lambda$-calculus. We explore this problem from a new angle via\nthe conflict between extensionality and effects. Leveraging ideas from work on\nthe $\\lambda$-calculus with control, we derive and justify alternative\noperational semantics and a sequence of abstract machines for performing head\nreduction. Head reduction avoids the problems with weak-head reduction and\nextensionality, while our operational semantics and associated abstract\nmachines show us how to retain weak-head reduction's ease of implementation.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2016 00:45:41 GMT"}], "update_date": "2016-06-22", "authors_parsed": [["Johnson-Freyd", "Philip", "", "University of Oregon"], ["Downen", "Paul", "", "University\n  of Oregon"], ["Ariola", "Zena M.", "", "University of Oregon"]]}, {"id": "1606.06379", "submitter": "EPTCS", "authors": "Ikuo Kobori, Yukiyoshi Kameyama, Oleg Kiselyov", "title": "Answer-Type Modification without Tears: Prompt-Passing Style Translation\n  for Typed Delimited-Control Operators", "comments": "In Proceedings WoC 2015, arXiv:1606.05839", "journal-ref": "EPTCS 212, 2016, pp. 36-52", "doi": "10.4204/EPTCS.212.3", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The salient feature of delimited-control operators is their ability to modify\nanswer types during computation. The feature, answer-type modification (ATM for\nshort), allows one to express various interesting programs such as typed printf\ncompactly and nicely, while it makes it difficult to embed these operators in\nstandard functional languages.\n  In this paper, we present a typed translation of delimited-control operators\nshift and reset with ATM into a familiar language with multi-prompt shift and\nreset without ATM, which lets us use ATM in standard languages without\nmodifying the type system. Our translation generalizes Kiselyov's direct-style\nimplementation of typed printf, which uses two prompts to emulate the\nmodification of answer types, and passes them during computation. We prove that\nour translation preserves typing. As the naive prompt-passing style translation\ngenerates and passes many prompts even for pure terms, we show an optimized\ntranslation that generate prompts only when needed, which is also\ntype-preserving. Finally, we give an implementation in the tagless-final style\nwhich respects typing by construction.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2016 00:45:51 GMT"}], "update_date": "2016-06-22", "authors_parsed": [["Kobori", "Ikuo", ""], ["Kameyama", "Yukiyoshi", ""], ["Kiselyov", "Oleg", ""]]}, {"id": "1606.06380", "submitter": "EPTCS", "authors": "Maciej Pir\\'og (University of Oxford), Jeremy Gibbons (University of\n  Oxford)", "title": "From Push/Enter to Eval/Apply by Program Transformation", "comments": "In Proceedings WoC 2015, arXiv:1606.05839", "journal-ref": "EPTCS 212, 2016, pp. 53-62", "doi": "10.4204/EPTCS.212.4", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Push/enter and eval/apply are two calling conventions used in implementations\nof functional languages. In this paper, we explore the following observation:\nwhen considering functions with multiple arguments, the stack under the\npush/enter and eval/apply conventions behaves similarly to two particular\nimplementations of the list datatype: the regular cons-list and a form of lists\nwith lazy concatenation respectively. Along the lines of Danvy et al.'s\nfunctional correspondence between definitional interpreters and abstract\nmachines, we use this observation to transform an abstract machine that\nimplements push/enter into an abstract machine that implements eval/apply. We\nshow that our method is flexible enough to transform the push/enter Spineless\nTagless G-machine (which is the semantic core of the GHC Haskell compiler) into\nits eval/apply variant.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2016 00:46:03 GMT"}], "update_date": "2016-06-22", "authors_parsed": [["Pir\u00f3g", "Maciej", "", "University of Oxford"], ["Gibbons", "Jeremy", "", "University of\n  Oxford"]]}, {"id": "1606.06381", "submitter": "EPTCS", "authors": "Neil Sculthorpe, Paolo Torrini, Peter D. Mosses", "title": "A Modular Structural Operational Semantics for Delimited Continuations", "comments": "In Proceedings WoC 2015, arXiv:1606.05839", "journal-ref": "EPTCS 212, 2016, pp. 63-80", "doi": "10.4204/EPTCS.212.5", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It has been an open question as to whether the Modular Structural Operational\nSemantics framework can express the dynamic semantics of call/cc. This paper\nshows that it can, and furthermore, demonstrates that it can express the more\ngeneral delimited control operators control and shift.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2016 00:46:13 GMT"}], "update_date": "2016-06-22", "authors_parsed": [["Sculthorpe", "Neil", ""], ["Torrini", "Paolo", ""], ["Mosses", "Peter D.", ""]]}, {"id": "1606.06382", "submitter": "EPTCS", "authors": "Hayo Thielecke (Computer Science, University of Birmingham)", "title": "Command injection attacks, continuations, and the Lambek calculus", "comments": "In Proceedings WoC 2015, arXiv:1606.05839", "journal-ref": "EPTCS 212, 2016, pp. 81-96", "doi": "10.4204/EPTCS.212.6", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper shows connections between command injection attacks,\ncontinuations, and the Lambek calculus: certain command injections, such as the\ntautology attack on SQL, are shown to be a form of control effect that can be\ntyped using the Lambek calculus, generalizing the double-negation typing of\ncontinuations. Lambek's syntactic calculus is a logic with two implicational\nconnectives taking their arguments from the left and right, respectively. These\nconnectives describe how strings interact with their left and right contexts\nwhen building up syntactic structures. The calculus is a form of propositional\nlogic without structural rules, and so a forerunner of substructural logics\nlike Linear Logic and Separation Logic.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2016 00:46:23 GMT"}], "update_date": "2016-06-22", "authors_parsed": [["Thielecke", "Hayo", "", "Computer Science, University of Birmingham"]]}, {"id": "1606.06704", "submitter": "Nicole Radziwill", "authors": "Morgan C. Benton, Nicole M. Radziwill", "title": "Improving Testability and Reuse by Transitioning to Functional\n  Programming", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Declarative styles such as functional programming (FP) are rapidly gaining\nground on their imperative cousins, including procedural and object-oriented\nprogramming. The shift is subtle because it is happening within the context of\nmultiparadigm programming languages such as JavaScript. FP is better suited to\nmodern processes like test-driven development (TDD), and architectures like\nmassively parallel, cloud-based computing. This article describes the technical\ndetails that characterize the shift from imperative to FP and implications for\nsoftware quality management, particularly reuse and testability.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2016 18:53:25 GMT"}], "update_date": "2016-06-22", "authors_parsed": [["Benton", "Morgan C.", ""], ["Radziwill", "Nicole M.", ""]]}, {"id": "1606.06726", "submitter": "Tobias Pape", "authors": "Tobias Pape, Carl Friedrich Bolz, Robert Hirschfeld", "title": "Adaptive Just-in-time Value Class Optimization for Lowering Memory\n  Consumption and Improving Execution Time Performance", "comments": null, "journal-ref": null, "doi": "10.1016/j.scico.2016.08.003", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The performance of value classes is highly dependent on how they are\nrepresented in the virtual machine. Value class instances are immutable, have\nno identity, and can only refer to other value objects or primitive values and\nsince they should be very lightweight and fast, it is important to optimize\nthem carefully. In this paper we present a technique to detect and compress\ncommon patterns of value class usage to improve memory usage and performance.\nThe technique identifies patterns of frequent value object references and\nintroduces abbreviated forms for them. This allows to store multiple\ninter-referenced value objects in an inlined memory representation, reducing\nthe overhead stemming from meta-data and object references. Applied to a small\nprototype and an implementation of the Racket language, we found improvements\nin memory usage and execution time for several micro-benchmarks.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2016 19:57:15 GMT"}], "update_date": "2016-08-30", "authors_parsed": [["Pape", "Tobias", ""], ["Bolz", "Carl Friedrich", ""], ["Hirschfeld", "Robert", ""]]}, {"id": "1606.07143", "submitter": "Justin Hsu", "authors": "Gilles Barthe, No\\'emie Fong, Marco Gaboardi, Benjamin Gr\\'egoire,\n  Justin Hsu, Pierre-Yves Strub", "title": "Advanced Probabilistic Couplings for Differential Privacy", "comments": null, "journal-ref": null, "doi": "10.1145/2976749.2978391", "report-no": null, "categories": "cs.LO cs.DS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Differential privacy is a promising formal approach to data privacy, which\nprovides a quantitative bound on the privacy cost of an algorithm that operates\non sensitive information. Several tools have been developed for the formal\nverification of differentially private algorithms, including program logics and\ntype systems. However, these tools do not capture fundamental techniques that\nhave emerged in recent years, and cannot be used for reasoning about\ncutting-edge differentially private algorithms. Existing techniques fail to\nhandle three broad classes of algorithms: 1) algorithms where privacy depends\naccuracy guarantees, 2) algorithms that are analyzed with the advanced\ncomposition theorem, which shows slower growth in the privacy cost, 3)\nalgorithms that interactively accept adaptive inputs.\n  We address these limitations with a new formalism extending apRHL, a\nrelational program logic that has been used for proving differential privacy of\nnon-interactive algorithms, and incorporating aHL, a (non-relational) program\nlogic for accuracy properties. We illustrate our approach through a single\nrunning example, which exemplifies the three classes of algorithms and explores\nnew variants of the Sparse Vector technique, a well-studied algorithm from the\nprivacy literature. We implement our logic in EasyCrypt, and formally verify\nprivacy. We also introduce a novel coupling technique called \\emph{optimal\nsubset coupling} that may be of independent interest.\n", "versions": [{"version": "v1", "created": "Thu, 23 Jun 2016 00:11:57 GMT"}, {"version": "v2", "created": "Wed, 17 Aug 2016 16:22:57 GMT"}], "update_date": "2018-03-16", "authors_parsed": [["Barthe", "Gilles", ""], ["Fong", "No\u00e9mie", ""], ["Gaboardi", "Marco", ""], ["Gr\u00e9goire", "Benjamin", ""], ["Hsu", "Justin", ""], ["Strub", "Pierre-Yves", ""]]}, {"id": "1606.07557", "submitter": "Eric Seidel", "authors": "Eric L Seidel, Ranjit Jhala, Westley Weimer", "title": "Dynamic Witnesses for Static Type Errors (or, Ill-Typed Programs Usually\n  Go Wrong)", "comments": "to appear in JFP", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Static type errors are a common stumbling block for newcomers to typed\nfunctional languages. We present a dynamic approach to explaining type errors\nby generating counterexample witness inputs that illustrate how an ill-typed\nprogram goes wrong. First, given an ill-typed function, we symbolically execute\nthe body to synthesize witness values that make the program go wrong. We prove\nthat our procedure synthesizes general witnesses in that if a witness is found,\nthen for all inhabited input types, there exist values that can make the\nfunction go wrong. Second, we show how to extend this procedure to produce a\nreduction graph that can be used to interactively visualize and debug witness\nexecutions. Third, we evaluate the coverage of our approach on two data sets\ncomprising over 4,500 ill-typed student programs. Our technique is able to\ngenerate witnesses for around 85% of the programs, our reduction graph yields\nsmall counterexamples for over 80% of the witnesses, and a simple heuristic\nallows us to use witnesses to locate the source of type errors with around 70%\naccuracy. Finally, we evaluate whether our witnesses help students understand\nand fix type errors, and find that students presented with our witnesses show a\ngreater understanding of type errors than those presented with a standard error\nmessage.\n", "versions": [{"version": "v1", "created": "Fri, 24 Jun 2016 03:42:28 GMT"}, {"version": "v2", "created": "Sun, 18 Mar 2018 15:45:27 GMT"}], "update_date": "2018-03-20", "authors_parsed": [["Seidel", "Eric L", ""], ["Jhala", "Ranjit", ""], ["Weimer", "Westley", ""]]}, {"id": "1606.07687", "submitter": "Stefan Schulze Frielinghaus", "authors": "Stefan Schulze Frielinghaus, Helmut Seidl, Ralf Vogler", "title": "Enforcing Termination of Interprocedural Analysis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Interprocedural analysis by means of partial tabulation of summary functions\nmay not terminate when the same procedure is analyzed for infinitely many\nabstract calling contexts or when the abstract domain has infinite strictly\nascending chains. As a remedy, we present a novel local solver for general\nabstract equation systems, be they monotonic or not, and prove that this solver\nfails to terminate only when infinitely many variables are encountered. We\nclarify in which sense the computed results are sound. Moreover, we show that\ninterprocedural analysis performed by this novel local solver, is guaranteed to\nterminate for all non-recursive programs --- irrespective of whether the\ncomplete lattice is infinite or has infinite strictly ascending or descending\nchains.\n", "versions": [{"version": "v1", "created": "Fri, 24 Jun 2016 13:57:35 GMT"}], "update_date": "2016-06-27", "authors_parsed": [["Frielinghaus", "Stefan Schulze", ""], ["Seidl", "Helmut", ""], ["Vogler", "Ralf", ""]]}, {"id": "1606.08708", "submitter": "Chelsea Battell", "authors": "Chelsea Battell", "title": "Domain Specific Language for Modular Knitting Pattern Definitions: Purl", "comments": "124 pages, undergraduate project", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Purl is a language to be used for modular definition and verification of\nknitting patterns. The syntax is similar to the standard knitting pattern\nnotation provided by the Craft Yarn Council. Purl provides constructs not\navailable in the standard notation to allow reuse of segments of patterns. This\nreport describes the basics of knitting and hand-knitting patterns. A knitting\npattern language more terse than the standard notation is presented with the\nimplementation of a compiler to this standard.\n", "versions": [{"version": "v1", "created": "Sat, 25 Jun 2016 14:15:34 GMT"}], "update_date": "2016-06-29", "authors_parsed": [["Battell", "Chelsea", ""]]}, {"id": "1606.08866", "submitter": "Terence Parr", "authors": "Terence Parr and Jurgin Vinju", "title": "Technical Report: Towards a Universal Code Formatter through Machine\n  Learning", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There are many declarative frameworks that allow us to implement code\nformatters relatively easily for any specific language, but constructing them\nis cumbersome. The first problem is that \"everybody\" wants to format their code\ndifferently, leading to either many formatter variants or a ridiculous number\nof configuration options. Second, the size of each implementation scales with a\nlanguage's grammar size, leading to hundreds of rules.\n  In this paper, we solve the formatter construction problem using a novel\napproach, one that automatically derives formatters for any given language\nwithout intervention from a language expert. We introduce a code formatter\ncalled CodeBuff that uses machine learning to abstract formatting rules from a\nrepresentative corpus, using a carefully designed feature set. Our experiments\non Java, SQL, and ANTLR grammars show that CodeBuff is efficient, has excellent\naccuracy, and is grammar invariant for a given language. It also generalizes to\na 4th language tested during manuscript preparation.\n", "versions": [{"version": "v1", "created": "Tue, 28 Jun 2016 20:04:07 GMT"}], "update_date": "2016-06-30", "authors_parsed": [["Parr", "Terence", ""], ["Vinju", "Jurgin", ""]]}, {"id": "1606.08948", "submitter": "Vishal Sharma", "authors": "Vishal Chandra Sharma, Ganesh Gopalakrishnan, Sriram Krishnamoorthy", "title": "PRESAGE: Protecting Structured Address Generation against Soft Errors", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modern computer scaling trends in pursuit of larger component counts and\npower efficiency have, unfortunately, lead to less reliable hardware and\nconsequently soft errors escaping into application data (\"silent data\ncorruptions\"). Techniques to enhance system resilience hinge on the\navailability of efficient error detectors that have high detection rates, low\nfalse positive rates, and lower computational overhead. Unfortunately,\nefficient detectors to detect faults during address generation (to index large\narrays) have not been widely researched. We present a novel lightweight\ncompiler-driven technique called PRESAGE for detecting bit-flips affecting\nstructured address computations. A key insight underlying PRESAGE is that any\naddress computation scheme that flows an already incurred error is better than\na scheme that corrupts one particular array access but otherwise (falsely)\nappears to compute perfectly. Enabling the flow of errors allows one to situate\ndetectors at loop exit points, and helps turn silent corruptions into easily\ndetectable error situations. Our experiments using PolyBench benchmark suite\nindicate that PRESAGE-based error detectors have a high error-detection rate\nwhile incurring low overheads.\n", "versions": [{"version": "v1", "created": "Wed, 29 Jun 2016 04:06:41 GMT"}], "update_date": "2016-07-05", "authors_parsed": [["Sharma", "Vishal Chandra", ""], ["Gopalakrishnan", "Ganesh", ""], ["Krishnamoorthy", "Sriram", ""]]}, {"id": "1606.09242", "submitter": "Yi Wu", "authors": "Yi Wu, Lei Li, Stuart Russell, Rastislav Bodik", "title": "Swift: Compiled Inference for Probabilistic Programming Languages", "comments": "IJCAI 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A probabilistic program defines a probability measure over its semantic\nstructures. One common goal of probabilistic programming languages (PPLs) is to\ncompute posterior probabilities for arbitrary models and queries, given\nobserved evidence, using a generic inference engine. Most PPL inference\nengines---even the compiled ones---incur significant runtime interpretation\noverhead, especially for contingent and open-universe models. This paper\ndescribes Swift, a compiler for the BLOG PPL. Swift-generated code incorporates\noptimizations that eliminate interpretation overhead, maintain dynamic\ndependencies efficiently, and handle memory management for possible worlds of\nvarying sizes. Experiments comparing Swift with other PPL engines on a variety\nof inference problems demonstrate speedups ranging from 12x to 326x.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2016 08:30:54 GMT"}], "update_date": "2016-07-01", "authors_parsed": [["Wu", "Yi", ""], ["Li", "Lei", ""], ["Russell", "Stuart", ""], ["Bodik", "Rastislav", ""]]}, {"id": "1606.09455", "submitter": "J\\\"urgen Koslowski", "authors": "Ranald Clouston, Ale\\v{s} Bizjak, Hans Bugge Grathwohl, Lars Birkedal\n  (Aarhus University, Denmark)", "title": "The Guarded Lambda-Calculus: Programming and Reasoning with Guarded\n  Recursion for Coinductive Types", "comments": "Accepted to Logical Methods in Computer Science special issue on the\n  18th International Conference on Foundations of Software Science and\n  Computation Structures (FoSSaCS 2015)", "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 3 (April 27,\n  2017) lmcs:2019", "doi": "10.2168/LMCS-12(3:7)2016", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present the guarded lambda-calculus, an extension of the simply typed\nlambda-calculus with guarded recursive and coinductive types. The use of\nguarded recursive types ensures the productivity of well-typed programs.\nGuarded recursive types may be transformed into coinductive types by a\ntype-former inspired by modal logic and Atkey-McBride clock quantification,\nallowing the typing of acausal functions. We give a call-by-name operational\nsemantics for the calculus, and define adequate denotational semantics in the\ntopos of trees. The adequacy proof entails that the evaluation of a program\nalways terminates. We introduce a program logic with L\\\"ob induction for\nreasoning about the contextual equivalence of programs. We demonstrate the\nexpressiveness of the calculus by showing the definability of solutions to\nRutten's behavioural differential equations.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2016 12:22:29 GMT"}, {"version": "v2", "created": "Mon, 5 Sep 2016 17:56:25 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Clouston", "Ranald", "", "Aarhus University, Denmark"], ["Bizjak", "Ale\u0161", "", "Aarhus University, Denmark"], ["Grathwohl", "Hans Bugge", "", "Aarhus University, Denmark"], ["Birkedal", "Lars", "", "Aarhus University, Denmark"]]}, {"id": "1606.09470", "submitter": "Michael Bukatin", "authors": "Michael Bukatin and Steve Matthews and Andrey Radul", "title": "Programming Patterns in Dataflow Matrix Machines and Generalized\n  Recurrent Neural Nets", "comments": "13 pages (v2 - update references)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.NE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dataflow matrix machines arise naturally in the context of synchronous\ndataflow programming with linear streams. They can be viewed as a rather\npowerful generalization of recurrent neural networks. Similarly to recurrent\nneural networks, large classes of dataflow matrix machines are described by\nmatrices of numbers, and therefore dataflow matrix machines can be synthesized\nby computing their matrices. At the same time, the evidence is fairly strong\nthat dataflow matrix machines have sufficient expressive power to be a\nconvenient general-purpose programming platform. Because of the network nature\nof this platform, programming patterns often correspond to patterns of\nconnectivity in the generalized recurrent neural networks understood as\nprograms. This paper explores a variety of such programming patterns.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2016 13:05:03 GMT"}, {"version": "v2", "created": "Fri, 3 Aug 2018 20:00:11 GMT"}], "update_date": "2018-08-07", "authors_parsed": [["Bukatin", "Michael", ""], ["Matthews", "Steve", ""], ["Radul", "Andrey", ""]]}]