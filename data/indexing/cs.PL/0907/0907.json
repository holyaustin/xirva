[{"id": "0907.0749", "submitter": "Dan Ghica", "authors": "Dan R. Ghica", "title": "Function Interface Models for Hardware Compilation: Types, Signatures,\n  Protocols", "comments": "25 pages, 8 figures", "journal-ref": null, "doi": null, "report-no": "University of Birmingham Technical Report CSR-08-04", "categories": "cs.PL cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of synthesis of gate-level descriptions of digital circuits from\nbehavioural specifications written in higher-level programming languages\n(hardware compilation) has been studied for a long time yet a definitive\nsolution has not been forthcoming. The argument of this essay is mainly\nmethodological, bringing a perspective that is informed by recent developments\nin programming-language theory. We argue that one of the major obstacles in the\nway of hardware compilation becoming a useful and mature technology is the lack\nof a well defined function interface model, i.e. a canonical way in which\nfunctions communicate with arguments. We discuss the consequences of this\nproblem and propose a solution based on new developments in programming\nlanguage theory. We conclude by presenting a prototype implementation and some\nexamples illustrating our principles.\n", "versions": [{"version": "v1", "created": "Sat, 4 Jul 2009 09:24:26 GMT"}], "update_date": "2009-07-07", "authors_parsed": [["Ghica", "Dan R.", ""]]}, {"id": "0907.2059", "submitter": "Sylvain Lebresne", "authors": "Sylvain Lebresne", "title": "A Type System For Call-By-Name Exceptions", "comments": "25 pages", "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 4 (November\n  2, 2009) lmcs:817", "doi": "10.2168/LMCS-5(4:1)2009", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an extension of System F with call-by-name exceptions. The type\nsystem is enriched with two syntactic constructs: a union type for programs\nwhose execution may raise an exception at top level, and a corruption type for\nprograms that may raise an exception in any evaluation context (not necessarily\nat top level). We present the syntax and reduction rules of the system, as well\nas its typing and subtyping rules. We then study its properties, such as\nconfluence. Finally, we construct a realizability model using orthogonality\ntechniques, from which we deduce that well-typed programs are weakly\nnormalizing and that the ones who have the type of natural numbers really\ncompute a natural number, without raising exceptions.\n", "versions": [{"version": "v1", "created": "Sun, 12 Jul 2009 18:30:31 GMT"}, {"version": "v2", "created": "Mon, 2 Nov 2009 15:11:52 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Lebresne", "Sylvain", ""]]}, {"id": "0907.2173", "submitter": "Oleg Mazonka", "authors": "Oleg Mazonka", "title": "Bit Copying - The Ultimate Computational Simplicity", "comments": null, "journal-ref": "Complex Systems Journal 2011, Vol 19, N3", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A computational abstract machine based on two operations: referencing and bit\ncopying is presented. These operations are sufficient for carrying out any\ncomputation. They can be used as the primitives for a Turing-complete\nprogramming language. The interesting point is that the computation can be done\nwithout logic operations such as AND or OR. The compiler and emulator of this\nlanguage with sample programs are available on the Internet.\n", "versions": [{"version": "v1", "created": "Mon, 13 Jul 2009 14:15:01 GMT"}, {"version": "v2", "created": "Mon, 6 Jun 2011 00:35:43 GMT"}], "update_date": "2011-06-07", "authors_parsed": [["Mazonka", "Oleg", ""]]}, {"id": "0907.2640", "submitter": "Serguei Mokhov", "authors": "Serguei A. Mokhov", "title": "Towards Hybrid Intensional Programming with JLucid, Objective Lucid, and\n  General Imperative Compiler Framework in the GIPSY", "comments": "222 pages, 82 figures, 2 tables, index, appendices; Master's thesis,\n  October 2005. Also appears at http://clues.concordia.ca/record=b2222169~S0\n  and at http://books.google.com/books?id=A2QvOzOxtC8C ; this revision fixes\n  empty Nat42.tex example", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Pure Lucid programs are concurrent with very fine granularity. Sequential\nThreads (STs) are functions introduced to enlarge the grain size; they are\npassed from server to workers by Communication Procedures (CPs) in the General\nIntensional Programming System (GIPSY). A JLucid program combines Java code for\nthe STs with Lucid code for parallel control. Thus first, in this thesis, we\ndescribe the way in which the new JLucid compiler generates STs and CPs. JLucid\nalso introduces array support.\n  Further exploration goes through the additional transformations that the\nLucid family of languages has undergone to enable the use of Java objects and\ntheir members, in the Generic Intensional Programming Language (GIPL), and\nIndexical Lucid: first, in the form of JLucid allowing the use of\npseudo-objects, and then through the specifically-designed the Objective Lucid\nlanguage. The syntax and semantic definitions of Objective Lucid and the\nmeaning of Java objects within an intensional program are provided with\ndiscussions and examples.\n  Finally, there are many useful scientific and utility routines written in\nmany imperative programming languages other than Java, for example in C, C++,\nFortran, Perl, etc. Therefore, it is wise to provide a framework to facilitate\ninclusion of these languages into the GIPSY and their use by Lucid programs. A\nGeneral Imperative Compiler Framework and its concrete implementation is\nproposed to address this issue.\n", "versions": [{"version": "v1", "created": "Wed, 15 Jul 2009 16:24:05 GMT"}, {"version": "v2", "created": "Fri, 24 Jul 2009 18:18:21 GMT"}, {"version": "v3", "created": "Mon, 21 Dec 2009 04:17:15 GMT"}], "update_date": "2009-12-21", "authors_parsed": [["Mokhov", "Serguei A.", ""]]}, {"id": "0907.3330", "submitter": "Carl Hewitt", "authors": "Carl Hewitt", "title": "Inconsistency Robustness in Foundations: Mathematics self proves its own\n  Consistency and Other Matters", "comments": "Notation was made consistent with other articles. arXiv admin note:\n  substantial text overlap with arXiv:0812.4852", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Inconsistency Robustness is performance of information systems with\npervasively inconsistent information. Inconsistency Robustness of the community\nof professional mathematicians is their performance repeatedly repairing\ncontradictions over the centuries. In the Inconsistency Robustness paradigm,\nderiving contradictions have been a progressive development and not \"game\nstoppers.\" Contradictions can be helpful instead of being something to be\n\"swept under the rug\" by denying their existence, which has been repeatedly\nattempted by Establishment Philosophers (beginning with some Pythagoreans).\nSuch denial has delayed mathematical development. This article reports how\nconsiderations of Inconsistency Robustness have recently influenced the\nfoundations of mathematics for Computer Science continuing a tradition\ndeveloping the sociological basis for foundations.\n  The current common understanding is that G\\\"odel proved \"Mathematics cannot\nprove its own consistency, if it is consistent.\" However, the consistency of\nmathematics is proved by a simple argument in this article. Consequently, the\ncurrent common understanding that G\\\"odel proved \"Mathematics cannot prove its\nown consistency, if it is consistent\" is inaccurate.\n  Wittgenstein long ago showed that contradiction in mathematics results from\nthe kind of \"self-referential\" sentence that G\\\"odel used in his argument that\nmathematics cannot prove its own consistency. However, using a typed grammar\nfor mathematical sentences, it can be proved that the kind \"self-referential\"\nsentence that G\\\"odel used in his argument cannot be constructed because\nrequired the fixed point that G\\\"odel used to the construct the\n\"self-referential\" sentence does not exist. In this way, consistency of\nmathematics is preserved without giving up power.\n", "versions": [{"version": "v1", "created": "Mon, 20 Jul 2009 01:44:33 GMT"}, {"version": "v10", "created": "Fri, 20 Nov 2009 21:32:18 GMT"}, {"version": "v11", "created": "Mon, 14 Dec 2009 20:41:52 GMT"}, {"version": "v12", "created": "Tue, 15 Dec 2009 06:42:36 GMT"}, {"version": "v13", "created": "Tue, 29 Dec 2009 22:47:55 GMT"}, {"version": "v14", "created": "Thu, 31 Dec 2009 18:11:14 GMT"}, {"version": "v15", "created": "Tue, 12 Jan 2010 13:35:17 GMT"}, {"version": "v16", "created": "Mon, 8 Mar 2010 15:43:27 GMT"}, {"version": "v17", "created": "Thu, 11 Mar 2010 18:45:30 GMT"}, {"version": "v18", "created": "Mon, 22 Mar 2010 15:06:23 GMT"}, {"version": "v19", "created": "Tue, 23 Mar 2010 06:44:32 GMT"}, {"version": "v2", "created": "Wed, 29 Jul 2009 14:30:08 GMT"}, {"version": "v20", "created": "Wed, 24 Mar 2010 15:33:13 GMT"}, {"version": "v21", "created": "Thu, 8 Apr 2010 10:27:18 GMT"}, {"version": "v22", "created": "Wed, 21 Apr 2010 17:38:39 GMT"}, {"version": "v23", "created": "Thu, 22 Apr 2010 11:40:50 GMT"}, {"version": "v24", "created": "Tue, 27 Apr 2010 02:15:43 GMT"}, {"version": "v25", "created": "Tue, 4 May 2010 16:34:52 GMT"}, {"version": "v26", "created": "Thu, 6 May 2010 20:46:16 GMT"}, {"version": "v27", "created": "Wed, 12 May 2010 16:20:38 GMT"}, {"version": "v28", "created": "Wed, 19 May 2010 18:15:24 GMT"}, {"version": "v29", "created": "Sat, 22 May 2010 14:41:14 GMT"}, {"version": "v3", "created": "Mon, 17 Aug 2009 14:29:50 GMT"}, {"version": "v30", "created": "Mon, 7 Jun 2010 23:11:19 GMT"}, {"version": "v31", "created": "Mon, 21 Jun 2010 16:43:08 GMT"}, {"version": "v32", "created": "Wed, 30 Jun 2010 06:16:43 GMT"}, {"version": "v33", "created": "Mon, 12 Jul 2010 15:51:20 GMT"}, {"version": "v34", "created": "Thu, 15 Jul 2010 17:36:15 GMT"}, {"version": "v35", "created": "Mon, 19 Jul 2010 07:48:43 GMT"}, {"version": "v36", "created": "Mon, 26 Jul 2010 16:48:39 GMT"}, {"version": "v37", "created": "Mon, 9 Aug 2010 08:44:32 GMT"}, {"version": "v38", "created": "Wed, 18 Aug 2010 17:28:42 GMT"}, {"version": "v39", "created": "Mon, 23 Aug 2010 14:48:39 GMT"}, {"version": "v4", "created": "Mon, 24 Aug 2009 14:30:19 GMT"}, {"version": "v40", "created": "Mon, 6 Sep 2010 13:37:37 GMT"}, {"version": "v41", "created": "Fri, 5 Nov 2010 19:37:11 GMT"}, {"version": "v42", "created": "Sat, 8 Jan 2011 03:38:48 GMT"}, {"version": "v43", "created": "Thu, 11 Oct 2012 16:31:11 GMT"}, {"version": "v44", "created": "Mon, 29 Dec 2014 19:46:13 GMT"}, {"version": "v45", "created": "Mon, 9 Feb 2015 05:18:48 GMT"}, {"version": "v46", "created": "Tue, 17 Feb 2015 18:32:13 GMT"}, {"version": "v5", "created": "Sun, 6 Sep 2009 00:43:37 GMT"}, {"version": "v6", "created": "Sun, 4 Oct 2009 16:59:37 GMT"}, {"version": "v7", "created": "Sun, 11 Oct 2009 16:52:58 GMT"}, {"version": "v8", "created": "Tue, 20 Oct 2009 17:59:23 GMT"}, {"version": "v9", "created": "Wed, 4 Nov 2009 16:44:00 GMT"}], "update_date": "2015-02-18", "authors_parsed": [["Hewitt", "Carl", ""]]}, {"id": "0907.4316", "submitter": "Krzysztof R. Apt", "authors": "Krzysztof R. Apt, Frank S. de Boer, Ernst-R\\\"udiger Olderog", "title": "Modular Verification of Recursive Programs", "comments": "21 pages. appeared in: Languages: From Formal to Natural, Essays\n  Dedicated to Nissim Francez on the Occasion of His 65th Birthday. Lecture\n  Notes in Computer Science 5533 Springer 2009", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We argue that verification of recursive programs by means of the assertional\nmethod of C.A.R. Hoare can be conceptually simplified using a modular\nreasoning. In this approach some properties of the program are established\nfirst and subsequently used to establish other program properties. We\nillustrate this approach by providing a modular correctness proof of the\nQuicksort program.\n", "versions": [{"version": "v1", "created": "Fri, 24 Jul 2009 15:06:46 GMT"}], "update_date": "2009-07-27", "authors_parsed": [["Apt", "Krzysztof R.", ""], ["de Boer", "Frank S.", ""], ["Olderog", "Ernst-R\u00fcdiger", ""]]}, {"id": "0907.4477", "submitter": "Nikos Tzevelekos", "authors": "Nikos Tzevelekos", "title": "Full abstraction for nominal general references", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 3 (September\n  11, 2009) lmcs:918", "doi": "10.2168/LMCS-5(3:8)2009", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Game semantics has been used with considerable success in formulating fully\nabstract semantics for languages with higher-order procedures and a wide range\nof computational effects. Recently, nominal games have been proposed for\nmodelling functional languages with names. These are ordinary, stateful games\ncast in the theory of nominal sets developed by Pitts and Gabbay. Here we take\nnominal games one step further, by developing a fully abstract semantics for a\nlanguage with nominal general references.\n", "versions": [{"version": "v1", "created": "Sun, 26 Jul 2009 13:27:38 GMT"}, {"version": "v2", "created": "Fri, 11 Sep 2009 19:57:27 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Tzevelekos", "Nikos", ""]]}, {"id": "0907.4622", "submitter": "Rajkumar Buyya", "authors": "Christian Vecchiola, Xingchen Chu, and Rajkumar Buyya", "title": "Aneka: A Software Platform for .NET-based Cloud Computing", "comments": "30 pages, 10 figures", "journal-ref": null, "doi": null, "report-no": "GRIDS-TR-2009-4, Grid Computing and Distributed Systems Laboratory,\n  The University of Melbourne, Australia, May 25, 2009", "categories": "cs.DC cs.CE cs.NI cs.OS cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Aneka is a platform for deploying Clouds developing applications on top of\nit. It provides a runtime environment and a set of APIs that allow developers\nto build .NET applications that leverage their computation on either public or\nprivate clouds. One of the key features of Aneka is the ability of supporting\nmultiple programming models that are ways of expressing the execution logic of\napplications by using specific abstractions. This is accomplished by creating a\ncustomizable and extensible service oriented runtime environment represented by\na collection of software containers connected together. By leveraging on these\narchitecture advanced services including resource reservation, persistence,\nstorage management, security, and performance monitoring have been implemented.\nOn top of this infrastructure different programming models can be plugged to\nprovide support for different scenarios as demonstrated by the engineering,\nlife science, and industry applications.\n", "versions": [{"version": "v1", "created": "Sun, 26 Jul 2009 02:19:42 GMT"}], "update_date": "2009-07-28", "authors_parsed": [["Vecchiola", "Christian", ""], ["Chu", "Xingchen", ""], ["Buyya", "Rajkumar", ""]]}, {"id": "0907.4640", "submitter": "Keiko Nakata Dr", "authors": "Keiko Nakata and Masahito Hasegawa", "title": "Small-step and big-step semantics for call-by-need", "comments": "29 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present natural semantics for acyclic as well as cyclic call-by-need\nlambda calculi, which are proved equivalent to the reduction semantics given by\nAriola and Felleisen. The natural semantics are big-step and use global heaps,\nwhere evaluation is suspended and memorized. The reduction semantics are\nsmall-step and evaluation is suspended and memorized locally in let-bindings.\nThus two styles of formalization describe the call-by-need strategy from\ndifferent angles.\n  The natural semantics for the acyclic calculus is revised from the previous\npresentation by Maraist et al. and its adequacy is ascribed to its\ncorrespondence with the reduction semantics, which has been proved equivalent\nto call-by-name by Ariola and Felleisen. The natural semantics for the cyclic\ncalculus is inspired by that of Launchbury and Sestoft and we state its\nadequacy using a denotational semantics in the style of Launchbury; adequacy of\nthe reduction semantics for the cyclic calculus is in turn ascribed to its\ncorrespondence with the natural semantics.\n", "versions": [{"version": "v1", "created": "Mon, 27 Jul 2009 17:19:28 GMT"}], "update_date": "2009-07-28", "authors_parsed": [["Nakata", "Keiko", ""], ["Hasegawa", "Masahito", ""]]}, {"id": "0907.4960", "submitter": "Muthiah Annamalai", "authors": "Muthiah Annamalai", "title": "Ezhil: A Tamil Programming Language", "comments": "6 pages, Tamil UTF-8 characters", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Ezhil is a Tamil language based interpreted procedural programming language.\nTamil keywords and grammar are chosen to make the native Tamil speaker write\nprograms in the Ezhil system. Ezhil allows easy representation of computer\nprogram closer to the Tamil language logical constructs equivalent to the\nconditional, branch and loop statements in modern English based programming\nlanguages. Ezhil is a compact programming language aimed towards Tamil speaking\nnovice computer users. Grammar for Ezhil and a few example programs are\nreported here, from the initial proof-of-concept implementation using the\nPython programming language1. To the best of our knowledge, Ezhil language is\nthe first freely available Tamil programming language.\n", "versions": [{"version": "v1", "created": "Tue, 28 Jul 2009 19:24:51 GMT"}], "update_date": "2009-07-29", "authors_parsed": [["Annamalai", "Muthiah", ""]]}, {"id": "0907.5162", "submitter": "Anya Tafliovich", "authors": "Anya Tafliovich and Eric C. R. Hehner", "title": "Programming with Quantum Communication", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work develops a formal framework for specifying, implementing, and\nanalysing quantum communication protocols. We provide tools for developing\nsimple proofs and analysing programs which involve communication, both via\nquantum channels and exhibiting the LOCC (local operations, classical\ncommunication) paradigm.\n", "versions": [{"version": "v1", "created": "Wed, 29 Jul 2009 15:38:02 GMT"}], "update_date": "2009-07-30", "authors_parsed": [["Tafliovich", "Anya", ""], ["Hehner", "Eric C. R.", ""]]}, {"id": "0907.5290", "submitter": "Alexander Shkotin", "authors": "Alex Shkotin", "title": "Program structure", "comments": "22 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A program is usually represented as a word chain. It is exactly a word chain\nthat appears as the lexical analyzer output and is parsed. The work shows that\na program can be syntactically represented as an oriented word tree, that is a\nsyntactic program tree, program words being located both in tree nodes and on\ntree arrows. The basic property of a tree is that arrows starting from each\nnode are marked by different words (including an empty word). Semantics can\nthen be directly specified on such tree using either requirements or additional\nlinks, and adding instructions to some tree nodes enables program execution\nspecification.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jul 2009 09:33:53 GMT"}, {"version": "v2", "created": "Thu, 22 Mar 2012 18:58:15 GMT"}], "update_date": "2012-03-23", "authors_parsed": [["Shkotin", "Alex", ""]]}]