[{"id": "1112.0922", "submitter": "J\\\"org P\\\"uhrer", "authors": "Johannes Oetsch, J\\\"org P\\\"uhrer, Hans Tompits", "title": "Extending Object-Oriented Languages by Declarative Specifications of\n  Complex Objects using Answer-Set Programming", "comments": "Submitted to the 34th International Conference on Software\n  Engineering (ICSE), New Ideas and Emerging Results (NIER) track", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many applications require complexly structured data objects. Developing new\nor adapting existing algorithmic solutions for creating such objects can be a\nnon-trivial and costly task if the considered objects are subject to different\napplication-specific constraints. Often, however, it is comparatively easy to\ndeclaratively describe the required objects. In this paper, we propose to use\nanswer-set programming (ASP)---a well-established declarative programming\nparadigm from the area of artificial intelligence---for instantiating objects\nin standard object-oriented programming languages. In particular, we extend\nJava with declarative specifications from which the required objects can be\nautomatically generated using available ASP solver technology.\n", "versions": [{"version": "v1", "created": "Mon, 5 Dec 2011 13:28:53 GMT"}, {"version": "v2", "created": "Tue, 6 Dec 2011 15:31:56 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Oetsch", "Johannes", ""], ["P\u00fchrer", "J\u00f6rg", ""], ["Tompits", "Hans", ""]]}, {"id": "1112.1751", "submitter": "Michael Cotterell", "authors": "Michael E. Cotterell, John A. Miller and Tom Horton", "title": "Unicode in Domain-Specific Programming Languages for Modeling &\n  Simulation: ScalaTion as a Case Study", "comments": null, "journal-ref": null, "doi": null, "report-no": "Technical Report #UGA-CS-LSDIS-TR-11-011, Department of Computer\n  Science, University of Georgia, Athens, Georgia (May 2011)", "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As recent programming languages provide improved conciseness and flexibility\nof syntax, the development of embedded or internal Domain-Specific Languages\nhas increased. The field of Modeling and Simulation has had a long history of\ninnovation in programming languages (e.g. Simula-67, GPSS). Much effort has\ngone into the development of Simulation Programming Languages.\n  The ScalaTion project is working to develop an embedded or internal\nDomain-Specific Language for Modeling and Simulation which could streamline\nlanguage innovation in this domain. One of its goals is to make the code\nconcise, readable, and in a form familiar to experts in the domain. In some\ncases the code looks very similar to textbook formulas. To enhance readability\nby domain experts, a version of ScalaTion is provided that heavily utilizes\nUnicode.\n  This paper discusses the development of the ScalaTion DSL and the underlying\nfeatures of Scala that make this possible. It then provides an overview of\nScalaTion highlighting some uses of Unicode. Statistical analysis capabilities\nneeded for Modeling and Simulation are presented in some detail. The notation\ndeveloped is clear and concise which should lead to improved usability and\nextendibility.\n", "versions": [{"version": "v1", "created": "Thu, 8 Dec 2011 02:17:18 GMT"}], "update_date": "2011-12-09", "authors_parsed": [["Cotterell", "Michael E.", ""], ["Miller", "John A.", ""], ["Horton", "Tom", ""]]}, {"id": "1112.2396", "submitter": "EPTCS", "authors": "Jean-Guillaume Dumas (LJK, Universit\\'e de Grenoble, France),\n  Dominique Duval (LJK, Universit\\'e de Grenoble, France), Laurent Fousse (LJK,\n  Universit\\'e de Grenoble, France), Jean-Claude Reynaud (LJK, Universit\\'e de\n  Grenoble, France)", "title": "Decorated proofs for computational effects: States", "comments": "In Proceedings ACCAT 2012, arXiv:1208.4301", "journal-ref": "EPTCS 93, 2012, pp. 45-59", "doi": "10.4204/EPTCS.93.3", "report-no": null, "categories": "cs.PL cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The syntax of an imperative language does not mention explicitly the state,\nwhile its denotational semantics has to mention it. In this paper we show that\nthe equational proofs about an imperative language may hide the state, in the\nsame way as the syntax does.\n", "versions": [{"version": "v1", "created": "Sun, 11 Dec 2011 20:29:40 GMT"}, {"version": "v2", "created": "Tue, 20 Dec 2011 15:38:36 GMT"}, {"version": "v3", "created": "Fri, 7 Sep 2012 01:22:05 GMT"}], "update_date": "2012-09-10", "authors_parsed": [["Dumas", "Jean-Guillaume", "", "LJK, Universit\u00e9 de Grenoble, France"], ["Duval", "Dominique", "", "LJK, Universit\u00e9 de Grenoble, France"], ["Fousse", "Laurent", "", "LJK,\n  Universit\u00e9 de Grenoble, France"], ["Reynaud", "Jean-Claude", "", "LJK, Universit\u00e9 de\n  Grenoble, France"]]}, {"id": "1112.3756", "submitter": "Mohamed El-Zawawy Dr.", "authors": "Mohamed A. El-Zawawy", "title": "Probabilistic pointer analysis for multithreaded programs", "comments": "12 pages", "journal-ref": "ScienceAsia 37 (2011): 344-354", "doi": "10.2306/scienceasia1513-1874.2011.37.344", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The use of pointers and data-structures based on pointers results in circular\nmemory references that are interpreted by a vital compiler analysis, namely\npointer analysis. For a pair of memory references at a program point, a typical\npointer analysis specifies if the points-to relation between them may exist,\ndefinitely does not exist, or definitely exists. The \"may be\" case, which\ndescribes the points-to relation for most of the pairs, cannot be dealt with by\nmost compiler optimizations. This is so to guarantee the soundness of these\noptimizations. However, the \"may be\" case can be capitalized by the modern\nclass of speculative optimizations if the probability that two memory\nreferences alias can be measured. Focusing on multithreading, a prevailing\ntechnique of programming, this paper presents a new flow-sensitive technique\nfor probabilistic pointer analysis of multithreaded programs. The proposed\ntechnique has the form of a type system and calculates the probability of every\npoints-to relation at each program point. The key to our approach is to\ncalculate the points-to information via a post-type derivation. The use of type\nsystems has the advantage of associating each analysis results with a\njustification (proof) for the correctness of the results. This justification\nhas the form of a type derivation and is very much required in applications\nlike certified code.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 10:52:35 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["El-Zawawy", "Mohamed A.", ""]]}, {"id": "1112.3779", "submitter": "Salvador Abreu", "authors": "Flavio Cruz and Ricardo Rocha", "title": "Single Time-Stamped Tries for Retroactive Call Subsumption", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Tabling is an evaluation strategy for Prolog programs that works by storing\nanswers in a table space and then by using them in similar subgoals. Some\ntabling engines use call by subsumption, where it is determined that a subgoal\nwill consume answers from a more general subgoal in order to reduce the search\nspace and increase efficiency. We designed an extension, named Retroactive Call\nSubsumption (RCS), that implements call by subsumption independently of the\ncall order, thus allowing a more general subgoal to force previous called\nsubgoals to become answer consumers. For this extension, we propose a new table\nspace design, the Single Time Stamped Trie (STST), that is organized to make\nanswer sharing across subsumed/subsuming subgoals simple and efficient. In this\npaper, we present the new STST table space design and we discuss the main\nmodifications made to the original Time Stamped Tries approach to\nnon-retroactive call by subsumption. In experimental results, with programs\nthat stress some deficiencies of the new STST design, some overheads may be\nobserved, however the results achieved with more realistic programs greatly\noffset these overheads.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:24:02 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Cruz", "Flavio", ""], ["Rocha", "Ricardo", ""]]}, {"id": "1112.3780", "submitter": "Salvador Abreu", "authors": "Jo\\~ao Raimundo and Ricardo Rocha", "title": "Global Trie for Subterms", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A critical component in the implementation of an efficient tabling system is\nthe design of the table space. The most popular and successful data structure\nfor representing tables is based on a two-level trie data structure, where one\ntrie level stores the tabled subgoal calls and the other stores the computed\nanswers. The Global Trie (GT) is an alternative table space organization\ndesigned with the intent to reduce the tables's memory usage, namely by storing\nterms in a global trie, thus preventing repeated representations of the same\nterm in different trie data structures. In this paper, we propose an extension\nto the GT organization, named Global Trie for Subterms (GT-ST), where compound\nsubterms in term arguments are represented as unique entries in the GT.\nExperiments results using the YapTab tabling system show that GT-ST support has\npotential to achieve significant reductions on memory usage, for programs with\nincreasing compound subterms in term arguments, without compromising the\nexecution time for other programs.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:24:12 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Raimundo", "Jo\u00e3o", ""], ["Rocha", "Ricardo", ""]]}, {"id": "1112.3782", "submitter": "Salvador Abreu", "authors": "Paul Tarau", "title": "Computing with Hereditarily Finite Sequences", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  e use Prolog as a flexible meta-language to provide executable specifications\nof some fundamental mathematical objects and their transformations. In the\nprocess, isomorphisms are unraveled between natural numbers and combinatorial\nobjects (rooted ordered trees representing hereditarily finite sequences and\nrooted ordered binary trees representing G\\\"odel's System {\\bf T} types).\n  This paper focuses on an application that can be seen as an unexpected\n\"paradigm shift\": we provide recursive definitions showing that the resulting\nrepresentations are directly usable to perform symbolically arbitrary-length\ninteger computations.\n  Besides the theoretically interesting fact of \"breaking the\narithmetic/symbolic barrier\", the arithmetic operations performed with symbolic\nobjects like trees or types turn out to be genuinely efficient -- we derive\nimplementations with asymptotic performance comparable to ordinary bitstring\nimplementations of arbitrary-length integer arithmetic.\n  The source code of the paper, organized as a literate Prolog program, is\navailable at \\url{http://logic.cse.unt.edu/tarau/research/2011/pPAR.pl}\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:24:21 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1112.3783", "submitter": "Salvador Abreu", "authors": "Paulo Moura and Artur Miguel Dias", "title": "L-FLAT: Logtalk Toolkit for Formal Languages and Automata Theory", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe L-FLAT, a Logtalk Toolkit for teaching Formal Languages and\nAutomata Theory. L-FLAT supports the definition of \\textsl{alphabets}, the\ndefinition of \\textsl{orders} over alphabet symbols, the partial definition of\n\\textsl{languages} using unit tests, and the definition of \\textsl{mechanisms},\nwhich implement language generators or language recognizers. Supported\nmechanisms include \\textsl{predicates}, \\textsl{regular expressions},\n\\textsl{finite automata}, \\textsl{context-free grammars}, \\textsl{Turing\nmachines}, and \\textsl{push-down automata}. L-FLAT entities are implemented\nusing the object-oriented features of Logtalk, providing a highly portable and\neasily extendable framework. The use of L-FLAT in educational environments is\nenhanced by supporting Mooshak, a web application that features automatic\ngrading of submitted programs.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:24:31 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Moura", "Paulo", ""], ["Dias", "Artur Miguel", ""]]}, {"id": "1112.3784", "submitter": "Salvador Abreu", "authors": "J\\'anos Csorba, Zsolt Zombori and P\\'eter Szeredi", "title": "Using Constraint Handling Rules to Provide Static Type Analysis for the\n  Q Functional Language", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe an application of Prolog: a type checking tool for the Q\nfunctional language. Q is a terse vector processing language, a descendant of\nAPL, which is getting more and more popular, especially in financial\napplications. Q is a dynamically typed language, much like Prolog. Extending Q\nwith static typing improves both the readability of programs and programmer\nproductivity, as type errors are discovered by the tool at compile time, rather\nthan through debugging the program execution.\n  The type checker uses constraints that are handled by Prolog Constraint\nHandling Rules. During the analysis, we determine the possible type values for\neach program expression and detect inconsistencies. As most built-in function\nnames of Q are overloaded, i.e. their meaning depends on the argument types, a\nquite complex system of constraints had to be implemented.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:25:12 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Csorba", "J\u00e1nos", ""], ["Zombori", "Zsolt", ""], ["Szeredi", "P\u00e9ter", ""]]}, {"id": "1112.3785", "submitter": "Salvador Abreu", "authors": "Theofrastos Mantadelis and Gerda Janssens", "title": "Nesting Probabilistic Inference", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  When doing inference in ProbLog, a probabilistic extension of Prolog, we\nextend SLD resolution with some additional bookkeeping. This additional\ninformation is used to compute the probabilistic results for a probabilistic\nquery. In Prolog's SLD, goals are nested very naturally. In ProbLog's SLD,\nnesting probabilistic queries interferes with the probabilistic bookkeeping. In\norder to support nested probabilistic inference we propose the notion of a\nparametrised ProbLog engine. Nesting becomes possible by suspending and\nresuming instances of ProbLog engines. With our approach we realise several\nextensions of ProbLog such as meta-calls, negation, and answers of\nprobabilistic goals.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:25:28 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Mantadelis", "Theofrastos", ""], ["Janssens", "Gerda", ""]]}, {"id": "1112.3786", "submitter": "Salvador Abreu", "authors": "Timon Van Overveldt and Bart Demoen", "title": "High-Level Multi-Threading in hProlog", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A new high-level interface to multi-threading in Prolog, implemented in\nhProlog, is described. Modern CPUs often contain multiple cores and through\nhigh-level multi-threading a programmer can leverage this power without having\nto worry about low-level details. Two common types of high-level explicit\nparallelism are discussed: independent and-parallelism and competitive\nor-parallelism. A new type of explicit parallelism, pipeline parallelism, is\nproposed. This new type can be used in certain cases where independent\nand-parallelism and competitive or-parallelism cannot be used.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:25:42 GMT"}, {"version": "v2", "created": "Fri, 23 Dec 2011 08:49:22 GMT"}], "update_date": "2011-12-26", "authors_parsed": [["Van Overveldt", "Timon", ""], ["Demoen", "Bart", ""]]}, {"id": "1112.3787", "submitter": "Salvador Abreu", "authors": "Dario Campagna, Beata Sarna-Starosta and Tom Schrijvers", "title": "Approximating Constraint Propagation in Datalog", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a technique exploiting Datalog with aggregates to improve the\nperformance of programs with arithmetic (in)equalities. Our approach employs a\nsource-to-source program transformation which approximates the propagation\ntechnique from Constraint Programming. The experimental evaluation of the\napproach shows good run time speed-ups on a range of non-recursive as well as\nrecursive programs. Furthermore, our technique improves upon the previously\nreported in the literature constraint magic set transformation approach.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:26:59 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Campagna", "Dario", ""], ["Sarna-Starosta", "Beata", ""], ["Schrijvers", "Tom", ""]]}, {"id": "1112.3788", "submitter": "Salvador Abreu", "authors": "Paul Tarau", "title": "Bijective Term Encodings", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We encode/decode Prolog terms as unique natural numbers. Our encodings have\nthe following properties: a) are bijective b) natural numbers always decode to\nsyntactically valid terms c) they work in low polynomial time in the bitsize of\nthe representations d) the bitsize of our encodings is within constant factor\nof the syntactic representation of the input.\n  We describe encodings of term algebras with finite signature as well as\nalgorithms that separate the \"structure\" of a term, a natural number encoding\nof a list of balanced parenthesis, from its \"content\", a list of atomic terms\nand Prolog variables. The paper is organized as a literate Prolog program\navailable from \\url{http://logic.cse.unt.edu/tarau/research/2011/bijenc.pl}.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:27:09 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1112.3789", "submitter": "Salvador Abreu", "authors": "Abdulla Alqaddoumi and Enrico Pontelli", "title": "An Implementation of Bubbling", "comments": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Non-determinism is of great importance in functional logic programming. It\nprovides expressiveness and efficiency to functional logic computations. In\nthis paper we describe an implementation of the multi-paradigm functional logic\nlanguage Curry. The evaluation strategy employed by the implementation is based\non definitional trees and needed narrowing for deterministic operations, while\nnon-deterministic operations will depend on the graph transformation, bubbling.\nBubbling preserves the completeness of non-deterministic operations and avoids\nunnecessary large-scale reconstruction of expressions done by other approaches.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 12:27:19 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Alqaddoumi", "Abdulla", ""], ["Pontelli", "Enrico", ""]]}, {"id": "1112.3833", "submitter": "Alasdair Armstrong", "authors": "Alasdair Armstrong, Simon Foster and Georg Struth", "title": "Dependently Typed Programming based on Automated Theorem Proving", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Mella is a minimalistic dependently typed programming language and\ninteractive theorem prover implemented in Haskell. Its main purpose is to\ninvestigate the effective integration of automated theorem provers in a pure\nand simple setting. Such integrations are essential for supporting program\ndevelopment in dependently typed languages. We integrate the equational theorem\nprover Waldmeister and test it on more than 800 proof goals from the TPTP\nlibrary. In contrast to previous approaches, the reconstruction of Waldmeister\nproofs within Mella is quite robust and does not generate a significant\noverhead to proof search. Mella thus yields a template for integrating more\nexpressive theorem provers in more sophisticated languages.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 14:48:42 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["Armstrong", "Alasdair", ""], ["Foster", "Simon", ""], ["Struth", "Georg", ""]]}, {"id": "1112.4106", "submitter": "Ravi Chugh", "authors": "Ravi Chugh and David Herman and Ranjit Jhala", "title": "Dependent Types for JavaScript", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present Dependent JavaScript (DJS), a statically-typed dialect of the\nimperative, object-oriented, dynamic language. DJS supports the particularly\nchallenging features such as run-time type-tests, higher-order functions,\nextensible objects, prototype inheritance, and arrays through a combination of\nnested refinement types, strong updates to the heap, and heap unrolling to\nprecisely track prototype hierarchies. With our implementation of DJS, we\ndemonstrate that the type system is expressive enough to reason about a variety\nof tricky idioms found in small examples drawn from several sources, including\nthe popular book JavaScript: The Good Parts and the SunSpider benchmark suite.\n", "versions": [{"version": "v1", "created": "Sun, 18 Dec 2011 01:42:11 GMT"}, {"version": "v2", "created": "Mon, 16 Apr 2012 07:22:59 GMT"}, {"version": "v3", "created": "Wed, 1 Aug 2012 04:56:07 GMT"}], "update_date": "2012-08-02", "authors_parsed": [["Chugh", "Ravi", ""], ["Herman", "David", ""], ["Jhala", "Ranjit", ""]]}, {"id": "1112.4993", "submitter": "Salvador Abreu", "authors": "Salvador Abreu and Vitor Santos Costa", "title": "Online Proceedings of the 11th International Colloquium on\n  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),\n  Lexington, KY, U.S.A., July 10, 2011", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  These are the revised versions of the papers presented at CICLOPS 2011, a\nworkshop colocated with ICLP 2011.\n", "versions": [{"version": "v1", "created": "Wed, 21 Dec 2011 11:31:42 GMT"}], "update_date": "2011-12-22", "authors_parsed": [["Abreu", "Salvador", ""], ["Costa", "Vitor Santos", ""]]}, {"id": "1112.5000", "submitter": "Uday Khedker", "authors": "Uday P. Khedker, Alan Mycroft, Prashant Singh Rawat", "title": "Lazy Pointer Analysis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Flow- and context-sensitive pointer analysis is generally considered too\nexpensive for large programs; most tools relax one or both of the requirements\nfor scalability. We formulate a flow- and context-sensitive points-to analysis\nthat is lazy in the following sense: points-to information is computed only for\nlive pointers and its propagation is sparse (restricted to live ranges of\nrespective pointers). Further, our analysis (a) uses strong liveness,\neffectively including dead code elimination; (b) afterwards calculates\nmust-points-to information from may-points-to information instead of using a\nmutual fixed-point; and (c) uses value-based termination of call strings during\ninterprocedural analysis (which reduces the number of call strings\nsignificantly).\n  A naive implementation of our analysis within GCC-4.6.0 gave analysis time\nand size of points-to measurements for SPEC2006. Using liveness reduced the\namount of points-to information by an order of magnitude with no loss of\nprecision. For all programs under 30kLoC we found that the results were much\nmore precise than gcc's analysis. What comes as a pleasant surprise however, is\nthe fact that below this cross-over point, our naive linked-list implementation\nis faster than a flow- and context-insensitive analysis which is primarily used\nfor efficiency. We speculate that lazy flow- and context-sensitive analyses may\nbe not only more precise, but also more efficient, than current approaches.\n", "versions": [{"version": "v1", "created": "Wed, 21 Dec 2011 12:01:37 GMT"}], "update_date": "2011-12-22", "authors_parsed": [["Khedker", "Uday P.", ""], ["Mycroft", "Alan", ""], ["Rawat", "Prashant Singh", ""]]}, {"id": "1112.5671", "submitter": "Jan  Strejcek", "authors": "Jan Strej\\v{c}ek, Marek Trt\\'ik", "title": "Abstracting Path Conditions", "comments": "a shorter version published at ISSTA 2012. arXiv admin note: text\n  overlap with arXiv:1112.4703", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a symbolic-execution-based algorithm that for a given program and\na given program location produces a nontrivial necessary condition on input\nvalues to drive the program execution to the given location. We also propose an\napplication of necessary conditions in contemporary bug-finding and\ntest-generation tools. Experimental results show that the presented technique\ncan significantly improve performance of the tools.\n", "versions": [{"version": "v1", "created": "Fri, 23 Dec 2011 23:17:10 GMT"}, {"version": "v2", "created": "Sun, 11 Dec 2016 00:18:33 GMT"}], "update_date": "2016-12-13", "authors_parsed": [["Strej\u010dek", "Jan", ""], ["Trt\u00edk", "Marek", ""]]}, {"id": "1112.5761", "submitter": "Grigore Rosu", "authors": "Grigore Rosu (University of Illinois at Urbana-Champaign), Feng Chen\n  (University of Illinois at Urbana-Champaign)", "title": "Semantics and Algorithms for Parametric Monitoring", "comments": "This paper will appear in LMCS. It is an extended version of a paper\n  presented in TACAS'09", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 1 (February\n  23, 2012) lmcs:710", "doi": "10.2168/LMCS-8(1:9)2012", "report-no": null, "categories": "cs.PL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Analysis of execution traces plays a fundamental role in many program\nanalysis approaches, such as runtime verification, testing, monitoring, and\nspecification mining. Execution traces are frequently parametric, i.e., they\ncontain events with parameter bindings. Each parametric trace usually consists\nof many meaningful trace slices merged together, each slice corresponding to\none parameter binding. This gives a semantics-based solution to parametric\ntrace analysis. A general-purpose parametric trace slicing technique is\nintroduced, which takes each event in the parametric trace and dispatches it to\nits corresponding trace slices. This parametric trace slicing technique can be\nused in combination with any conventional, non-parametric trace analysis\ntechnique, by applying the later on each trace slice. As an instance, a\nparametric property monitoring technique is then presented. The presented\nparametric trace slicing and monitoring techniques have been implemented and\nextensively evaluated. Measurements of runtime overhead confirm that the\ngenerality of the discussed techniques does not come at a performance expense\nwhen compared with existing parametric trace monitoring systems.\n", "versions": [{"version": "v1", "created": "Sun, 25 Dec 2011 00:02:26 GMT"}, {"version": "v2", "created": "Tue, 21 Feb 2012 21:58:42 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Rosu", "Grigore", "", "University of Illinois at Urbana-Champaign"], ["Chen", "Feng", "", "University of Illinois at Urbana-Champaign"]]}, {"id": "1112.6096", "submitter": "Jacopo Mauro", "authors": "Massimo Morara, Jacopo Mauro and Maurizio Gabbrielli", "title": "Solving XCSP problems by using Gecode", "comments": "5 pages, http://ceur-ws.org/Vol-810 CILC 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Gecode is one of the most efficient libraries that can be used for constraint\nsolving. However, using it requires dealing with C++ programming details. On\nthe other hand several formats for representing constraint networks have been\nproposed. Among them, XCSP has been proposed as a format based on XML which\nallows us to represent constraints defined either extensionally or\nintensionally, permits global constraints and has been the standard format of\nthe international competition of constraint satisfaction problems solvers. In\nthis paper we present a plug-in for solving problems specified in XCSP by\nexploiting the Gecode solver. This is done by dynamically translating\nconstraints into Gecode library calls, thus avoiding the need to interact with\nC++.\n", "versions": [{"version": "v1", "created": "Wed, 28 Dec 2011 10:49:18 GMT"}], "update_date": "2011-12-30", "authors_parsed": [["Morara", "Massimo", ""], ["Mauro", "Jacopo", ""], ["Gabbrielli", "Maurizio", ""]]}]