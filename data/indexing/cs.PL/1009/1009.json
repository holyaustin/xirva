[{"id": "1009.0305", "submitter": "Sleiman Rabah", "authors": "Sleiman Rabah, Jiang Li, Mingzhi Liu and Yuanwei Lai", "title": "Comparative Studies of 10 Programming Languages within 10 Diverse\n  Criteria -- a Team 7 COMP6411-S10 Term Report", "comments": "139 pages, programming languages comparison tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There are many programming languages in the world today.Each language has\ntheir advantage and disavantage. In this paper, we will discuss ten programming\nlanguages: C++, C#, Java, Groovy, JavaScript, PHP, Schalar, Scheme, Haskell and\nAspectJ. We summarize and compare these ten languages on ten different\ncriterion. For example, Default more secure programming practices, Web\napplications development, OO-based abstraction and etc. At the end, we will\ngive our conclusion that which languages are suitable and which are not for\nusing in some cases. We will also provide evidence and our analysis on why some\nlanguage are better than other or have advantages over the other on some\ncriterion.\n", "versions": [{"version": "v1", "created": "Wed, 1 Sep 2010 23:53:15 GMT"}], "update_date": "2010-09-03", "authors_parsed": [["Rabah", "Sleiman", ""], ["Li", "Jiang", ""], ["Liu", "Mingzhi", ""], ["Lai", "Yuanwei", ""]]}, {"id": "1009.0817", "submitter": "Jan Blech", "authors": "Jan Olaf Blech, Anton Hattendorf, Jia Huang", "title": "Towards a Property Preserving Transformation from IEC 61131-3 to BIP", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We report on a transformation from Sequential Function Charts of the IEC\n61131-3 standard to BIP. Our presentation features a description of formal\nsyntax and semantics representation of the involved languages and\ntransformation rules. Furthermore, we present a formalism for describing\ninvariants of IEC 61131-3 systems and establish a notion of invariant\npreservation between the two languages. For a subset of our transformation\nrules we sketch a proof showing invariant preservation during the\ntransformation of IEC 61131-3 to BIP and vice versa.\n", "versions": [{"version": "v1", "created": "Sat, 4 Sep 2010 09:39:53 GMT"}], "update_date": "2010-09-07", "authors_parsed": [["Blech", "Jan Olaf", ""], ["Hattendorf", "Anton", ""], ["Huang", "Jia", ""]]}, {"id": "1009.1341", "submitter": "Eric Seidel", "authors": "Gabrielle Allen, Tom Goodale, Frank L\\\"offler, David Rideout, Erik\n  Schnetter, and Eric L. Seidel", "title": "Component Specification in the Cactus Framework: The Cactus\n  Configuration Language", "comments": "10 pages", "journal-ref": null, "doi": "10.1109/GRID.2010.5698008", "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Component frameworks are complex systems that rely on many layers of\nabstraction to function properly. One essential requirement is a consistent\nmeans of describing each individual component and how it relates to both other\ncomponents and the whole framework. As component frameworks are designed to be\nflexible by nature, the description method should be simultaneously powerful,\nlead to efficient code, and be easy to use, so that new users can quickly adapt\ntheir own code to work with the framework. In this paper, we discuss the Cactus\nConfiguration Language (CCL) which is used to describe components (\"thorns'')\nin the Cactus Framework. The CCL provides a description language for the\nvariables, parameters, functions, scheduling and compilation of a component and\nincludes concepts such as interface and implementation which allow thorns\nproviding the same capabilities to be easily interchanged. We include several\napplication examples which illustrate how community toolkits use the CCL and\nCactus and identify needed additions to the language.\n", "versions": [{"version": "v1", "created": "Tue, 7 Sep 2010 17:04:06 GMT"}], "update_date": "2012-02-09", "authors_parsed": [["Allen", "Gabrielle", ""], ["Goodale", "Tom", ""], ["L\u00f6ffler", "Frank", ""], ["Rideout", "David", ""], ["Schnetter", "Erik", ""], ["Seidel", "Eric L.", ""]]}, {"id": "1009.1342", "submitter": "Eric Seidel", "authors": "Eric L. Seidel, Gabrielle Allen, Steven Brandt, Frank L\\\"offler, and\n  Erik Schnetter", "title": "Simplifying Complex Software Assembly: The Component Retrieval Language\n  and Implementation", "comments": "8 pages, 5 figures, TeraGrid 2010", "journal-ref": null, "doi": "10.1145/1838574.1838592", "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Assembling simulation software along with the associated tools and utilities\nis a challenging endeavor, particularly when the components are distributed\nacross multiple source code versioning systems. It is problematic for\nresearchers compiling and running the software across many different\nsupercomputers, as well as for novices in a field who are often presented with\na bewildering list of software to collect and install. In this paper, we\ndescribe a language (CRL) for specifying software components with the details\nneeded to obtain them from source code repositories. The language supports\npublic and private access. We describe a tool called GetComponents which\nimplements CRL and can be used to assemble software. We demonstrate the tool\nfor application scenarios with the Cactus Framework on the NSF TeraGrid\nresources. The tool itself is distributed with an open source license and\nfreely available from our web page.\n", "versions": [{"version": "v1", "created": "Tue, 7 Sep 2010 17:05:53 GMT"}], "update_date": "2010-09-08", "authors_parsed": [["Seidel", "Eric L.", ""], ["Allen", "Gabrielle", ""], ["Brandt", "Steven", ""], ["L\u00f6ffler", "Frank", ""], ["Schnetter", "Erik", ""]]}, {"id": "1009.1560", "submitter": "David Van Horn", "authors": "Christopher Earl, Matthew Might, David Van Horn", "title": "Stack-Summarizing Control-Flow Analysis of Higher-Order Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two sinks drain precision from higher-order flow analyses: (1) merging of\nargument values upon procedure call and (2) merging of return values upon\nprocedure return. To combat the loss of precision, these two sinks have been\naddressed independently. In the case of procedure calls, abstract garbage\ncollection reduces argument merging; while in the case of procedure returns,\ncontext-free approaches eliminate return value merging. It is natural to expect\na combined analysis could enjoy the mutually beneficial interaction between the\ntwo approaches. The central contribution of this work is a direct product of\nabstract garbage collection with context-free analysis. The central challenge\nto overcome is the conflict between the core constraint of a pushdown system\nand the needs of garbage collection: a pushdown system can only see the top of\nthe stack, yet garbage collection needs to see the entire stack during a\ncollection. To make the direct product computable, we develop \"stack\nsummaries,\" a method for tracking stack properties at each control state in a\npushdown analysis of higher-order programs.\n", "versions": [{"version": "v1", "created": "Wed, 8 Sep 2010 15:14:13 GMT"}], "update_date": "2011-11-10", "authors_parsed": [["Earl", "Christopher", ""], ["Might", "Matthew", ""], ["Van Horn", "David", ""]]}, {"id": "1009.1861", "submitter": "William Lovas", "authors": "William Lovas (Carnegie Mellon University), Frank Pfenning (Carnegie\n  Mellon University)", "title": "Refinement Types for Logical Frameworks and Their Interpretation as\n  Proof Irrelevance", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 4 (December\n  5, 2010) lmcs:1063", "doi": "10.2168/LMCS-6(4:5)2010", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Refinement types sharpen systems of simple and dependent types by offering\nexpressive means to more precisely classify well-typed terms. We present a\nsystem of refinement types for LF in the style of recent formulations where\nonly canonical forms are well-typed. Both the usual LF rules and the rules for\ntype refinements are bidirectional, leading to a straightforward proof of\ndecidability of typechecking even in the presence of intersection types.\nBecause we insist on canonical forms, structural rules for subtyping can now be\nderived rather than being assumed as primitive. We illustrate the expressive\npower of our system with examples and validate its design by demonstrating a\nprecise correspondence with traditional presentations of subtyping. Proof\nirrelevance provides a mechanism for selectively hiding the identities of terms\nin type theories. We show that LF refinement types can be interpreted as\npredicates using proof irrelevance, establishing a uniform relationship between\ntwo previously studied concepts in type theory. The interpretation and its\ncorrectness proof are surprisingly complex, lending support to the claim that\nrefinement types are a fundamental construct rather than just a convenient\nsurface syntax for certain uses of proof irrelevance.\n", "versions": [{"version": "v1", "created": "Thu, 9 Sep 2010 19:17:53 GMT"}, {"version": "v2", "created": "Sun, 5 Dec 2010 11:11:08 GMT"}, {"version": "v3", "created": "Thu, 9 Dec 2010 20:50:29 GMT"}, {"version": "v4", "created": "Mon, 13 Dec 2010 10:21:38 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Lovas", "William", "", "Carnegie Mellon University"], ["Pfenning", "Frank", "", "Carnegie\n  Mellon University"]]}, {"id": "1009.1976", "submitter": "Carlos A. Romero-Diaz", "authors": "Rafael Caballero, Mario Rodr\\'iguez-Artalejo and Carlos A.\n  Romero-D\\'iaz", "title": "A Transformation-based Implementation for CLP with Qualification and\n  Proximity", "comments": "49 pages, 5 figures, 1 table, preliminary version of an article of\n  the same title, published as Technical Report SIC-4-10, Universidad\n  Complutense, Departamento de Sistemas Inform\\'aticos y Computaci\\'on, Madrid,\n  Spain", "journal-ref": null, "doi": null, "report-no": "SIC-4-10", "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Uncertainty in logic programming has been widely investigated in the last\ndecades, leading to multiple extensions of the classical LP paradigm. However,\nfew of these are designed as extensions of the well-established and powerful\nCLP scheme for Constraint Logic Programming. In a previous work we have\nproposed the SQCLP (proximity-based qualified constraint logic programming)\nscheme as a quite expressive extension of CLP with support for qualification\nvalues and proximity relations as generalizations of uncertainty values and\nsimilarity relations, respectively. In this paper we provide a transformation\ntechnique for transforming SQCLP programs and goals into semantically\nequivalent CLP programs and goals, and a practical Prolog-based implementation\nof some particularly useful instances of the SQCLP scheme. We also illustrate,\nby showing some simple-and working-examples, how the prototype can be\neffectively used as a tool for solving problems where qualification values and\nproximity relations play a key role. Intended use of SQCLP includes flexible\ninformation retrieval applications.\n", "versions": [{"version": "v1", "created": "Fri, 10 Sep 2010 10:26:38 GMT"}], "update_date": "2010-09-13", "authors_parsed": [["Caballero", "Rafael", ""], ["Rodr\u00edguez-Artalejo", "Mario", ""], ["Romero-D\u00edaz", "Carlos A.", ""]]}, {"id": "1009.1977", "submitter": "Carlos A. Romero-Diaz", "authors": "Mario Rodr\\'iguez-Artalejo and Carlos A. Romero-D\\'iaz", "title": "Fixpoint & Proof-theoretic Semantics for CLP with Qualification and\n  Proximity", "comments": "47 pages, 2 figures, extended version with full proofs of A\n  Declarative Semantics for CLP with Qualification and Proximity\n  (arXiv:1007.3629). Theory and Practice of Logic Programming, 26th Int'l.\n  Conference on Logic Programming (ICLP'10) Special Issue, 10(4-6):627-642,\n  2010. Revised definition 2.10, theorem 2.1 & proposition 2.2, results\n  unchanged", "journal-ref": null, "doi": null, "report-no": "SIC-1-10", "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Uncertainty in Logic Programming has been investigated during the last\ndecades, dealing with various extensions of the classical LP paradigm and\ndifferent applications. Existing proposals rely on different approaches, such\nas clause annotations based on uncertain truth values, qualification values as\na generalization of uncertain truth values, and unification based on proximity\nrelations. On the other hand, the CLP scheme has established itself as a\npowerful extension of LP that supports efficient computation over specialized\ndomains while keeping a clean declarative semantics. In this report we propose\na new scheme SQCLP designed as an extension of CLP that supports qualification\nvalues and proximity relations. We show that several previous proposals can be\nviewed as particular cases of the new scheme, obtained by partial\ninstantiation. We present a declarative semantics for SQCLP that is based on\nobservables, providing fixpoint and proof-theoretical characterizations of\nleast program models as well as an implementation-independent notion of goal\nsolutions.\n", "versions": [{"version": "v1", "created": "Fri, 10 Sep 2010 10:42:09 GMT"}, {"version": "v2", "created": "Fri, 14 Jan 2011 14:21:03 GMT"}], "update_date": "2011-01-17", "authors_parsed": [["Rodr\u00edguez-Artalejo", "Mario", ""], ["Romero-D\u00edaz", "Carlos A.", ""]]}, {"id": "1009.2178", "submitter": "Lunjin Lu", "authors": "Lunjin Lu and John G. Cleary", "title": "Simplifying Negative Goals Using Typed Existence Properties", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A method for extracting positive information from negative goals is proposed.\nIt makes use of typed existence properties between arguments of a predicate to\nrewrite negative goals in a logic program. A typed existence property is a\ngeneralization of functional dependencies in that an input value maps to a\nfixed number of output values. Types are used to specify the domains of the\ninput and output values. An implementation of the simplification method is\npresented and its complexity is analyzed. A key algorithm of the implementation\nchecks if an atom in a negative goal can be extracted using a given typed\nexistence property. A digraph links an atom to the quantified variables\noccurring in the atom and is used to quickly retrieve atoms in the negative\ngoal that may become extractable after some other atom is extracted.\n", "versions": [{"version": "v1", "created": "Sat, 11 Sep 2010 14:56:36 GMT"}], "update_date": "2010-09-14", "authors_parsed": [["Lu", "Lunjin", ""], ["Cleary", "John G.", ""]]}, {"id": "1009.2189", "submitter": "EPTCS", "authors": "Karl Crary, Marino Miculan", "title": "Proceedings 5th International Workshop on Logical Frameworks and\n  Meta-languages: Theory and Practice", "comments": null, "journal-ref": "EPTCS 34, 2010", "doi": "10.4204/EPTCS.34", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Type theories, logical frameworks and meta-languages form a common foundation\nfor designing, implementing, and reasoning about formal languages and their\nsemantics. They are central to the design of modern programming languages,\ncertified software, and domain specific logics. More generally, they continue\nto influence applications in many areas in mathematics, logic and computer\nscience.\n  The Logical Frameworks and Meta-languages: Theory and Practice workshop aims\nto bring together designers, implementers, and practitioners working on these\nareas, and in particular about: the automation and implementation of the\nmeta-theory of programming languages and related calculi; the design of proof\nassistants, automated theorem provers, and formal digital libraries building\nupon logical framework technology; theoretical and practical issues concerning\nthe encoding of variable binding and fresh name generation, especially the\nrepresentation of, and reasoning about, datatypes defined from binding\nsignatures; case studies of meta-programming, and the mechanization of the\n(meta) theory of descriptions of programming languages and other calculi.\n  This volume contains the final and revised versions of the papers presented\nat LFMTP 2010, which was held on July 14, 2010 in Edinburgh (UK). LFMTP 2010\nwas part of the Federated Logic Conference (FLoC 2010), and affilated with LICS\n2010.\n", "versions": [{"version": "v1", "created": "Sat, 11 Sep 2010 17:43:53 GMT"}], "update_date": "2010-09-14", "authors_parsed": [["Crary", "Karl", ""], ["Miculan", "Marino", ""]]}, {"id": "1009.2405", "submitter": "Mart\\'{i}n Abadi", "authors": "Mart\\'in Abadi (Microsoft Research, Silicon Valley, University of\n  California, Santa Cruz), Gordon D. Plotkin (Microsoft Research, Silicon\n  Valley, LFCS, University of Edinburgh)", "title": "A Model of Cooperative Threads", "comments": "39 pages, 5 figures", "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 4 (October\n  20, 2010) lmcs:700", "doi": "10.2168/LMCS-6(4:2)2010", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a model of concurrent imperative programming with threads. We\nfocus on a small imperative language with cooperative threads which execute\nwithout interruption until they terminate or explicitly yield control. We\ndefine and study a trace-based denotational semantics for this language; this\nsemantics is fully abstract but mathematically elementary. We also give an\nequational theory for the computational effects that underlie the language,\nincluding thread spawning. We then analyze threads in terms of the free algebra\nmonad for this theory.\n", "versions": [{"version": "v1", "created": "Mon, 13 Sep 2010 14:28:30 GMT"}, {"version": "v2", "created": "Wed, 20 Oct 2010 11:02:30 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Abadi", "Mart\u00edn", "", "Microsoft Research, Silicon Valley, University of\n  California, Santa Cruz"], ["Plotkin", "Gordon D.", "", "Microsoft Research, Silicon\n  Valley, LFCS, University of Edinburgh"]]}, {"id": "1009.2789", "submitter": "EPTCS", "authors": "Andreas Abel (Ludwig-Maximilians-University), Brigitte Pientka (McGill\n  University)", "title": "Explicit Substitutions for Contextual Type Theory", "comments": "In Proceedings LFMTP 2010, arXiv:1009.2189", "journal-ref": "EPTCS 34, 2010, pp. 5-20", "doi": "10.4204/EPTCS.34.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present an explicit substitution calculus which\ndistinguishes between ordinary bound variables and meta-variables. Its typing\ndiscipline is derived from contextual modal type theory. We first present a\ndependently typed lambda calculus with explicit substitutions for ordinary\nvariables and explicit meta-substitutions for meta-variables. We then present a\nweak head normalization procedure which performs both substitutions lazily and\nin a single pass thereby combining substitution walks for the two different\nclasses of variables. Finally, we describe a bidirectional type checking\nalgorithm which uses weak head normalization and prove soundness.\n", "versions": [{"version": "v1", "created": "Tue, 14 Sep 2010 21:33:26 GMT"}], "update_date": "2010-09-16", "authors_parsed": [["Abel", "Andreas", "", "Ludwig-Maximilians-University"], ["Pientka", "Brigitte", "", "McGill\n  University"]]}, {"id": "1009.2791", "submitter": "EPTCS", "authors": "Maribel Fern\\'andez (King's College London), Murdoch J. Gabbay\n  (Heriot-Watt University)", "title": "Closed nominal rewriting and efficiently computable nominal algebra\n  equality", "comments": "In Proceedings LFMTP 2010, arXiv:1009.2189", "journal-ref": "EPTCS 34, 2010, pp. 37-51", "doi": "10.4204/EPTCS.34.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We analyse the relationship between nominal algebra and nominal rewriting,\ngiving a new and concise presentation of equational deduction in nominal\ntheories. With some new results, we characterise a subclass of equational\ntheories for which nominal rewriting provides a complete procedure to check\nnominal algebra equality. This subclass includes specifications of the\nlambda-calculus and first-order logic.\n", "versions": [{"version": "v1", "created": "Tue, 14 Sep 2010 21:33:35 GMT"}], "update_date": "2010-09-16", "authors_parsed": [["Fern\u00e1ndez", "Maribel", "", "King's College London"], ["Gabbay", "Murdoch J.", "", "Heriot-Watt University"]]}, {"id": "1009.2793", "submitter": "EPTCS", "authors": "Daniel R. Licata (Carnegie Mellon University), Robert Harper (Carnegie\n  Mellon University)", "title": "A Monadic Formalization of ML5", "comments": "In Proceedings LFMTP 2010, arXiv:1009.2189", "journal-ref": "EPTCS 34, 2010, pp. 69-83", "doi": "10.4204/EPTCS.34.7", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  ML5 is a programming language for spatially distributed computing, based on a\nCurry-Howard correspondence with the modal logic S5. Despite being designed by\na correspondence with S5 modal logic, the ML5 programming language differs from\nthe logic in several ways. In this paper, we explain these discrepancies\nbetween ML5 and S5 by translating ML5 into a slightly different logic:\nintuitionistic S5 extended with a lax modality that encapsulates effectful\ncomputations in a monad. This translation both explains the existing ML5 design\nand suggests some simplifications and generalizations. We have formalized our\ntranslation within the Agda proof assistant. Rather than formalizing lax S5 as\na proof theory, we \\emph{embed} it as a universe within the the dependently\ntyped host language, with the universe elimination given by implementing the\nmodal logic's Kripke semantics. This representation technique saves us the work\nof defining a proof theory for the logic and proving it correct, and\nadditionally allows us to inherit the equational theory of the meta-language,\nwhich can be exploited in proving that the semantics validates the operational\nsemantics of ML5.\n", "versions": [{"version": "v1", "created": "Tue, 14 Sep 2010 21:33:45 GMT"}], "update_date": "2010-09-16", "authors_parsed": [["Licata", "Daniel R.", "", "Carnegie Mellon University"], ["Harper", "Robert", "", "Carnegie\n  Mellon University"]]}, {"id": "1009.2900", "submitter": "Hariolf Betz", "authors": "Hariolf Betz, Thom W. Fr\\\"uhwirth", "title": "Linear-Logic Based Analysis of Constraint Handling Rules with\n  Disjunction", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Constraint Handling Rules (CHR) is a declarative committed-choice programming\nlanguage with a strong relationship to linear logic. Its generalization CHR\nwith Disjunction (CHRv) is a multi-paradigm declarative programming language\nthat allows the embedding of horn programs. We analyse the assets and the\nlimitations of the classical declarative semantics of CHR before we motivate\nand develop a linear-logic declarative semantics for CHR and CHRv. We show how\nto apply the linear-logic semantics to decide program properties and to prove\noperational equivalence of CHRv programs across the boundaries of language\nparadigms.\n", "versions": [{"version": "v1", "created": "Wed, 15 Sep 2010 11:43:13 GMT"}], "update_date": "2010-09-16", "authors_parsed": [["Betz", "Hariolf", ""], ["Fr\u00fchwirth", "Thom W.", ""]]}, {"id": "1009.3174", "submitter": "David Van Horn", "authors": "Stephen Chang, David Van Horn, Matthias Felleisen", "title": "Evaluating Call-By-Need on the Control Stack", "comments": "Symposium on Trends in Functional Programming (TFP 2010), Norman,\n  Oklahoma, May 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Ariola and Felleisen's call-by-need {\\lambda}-calculus replaces a variable\noccurrence with its value at the last possible moment. To support this gradual\nnotion of substitution, function applications-once established-are never\ndischarged. In this paper we show how to translate this notion of reduction\ninto an abstract machine that resolves variable references via the control\nstack. In particular, the machine uses the static address of a variable\noccurrence to extract its current value from the dynamic control stack.\n", "versions": [{"version": "v1", "created": "Thu, 16 Sep 2010 13:38:10 GMT"}], "update_date": "2010-09-17", "authors_parsed": [["Chang", "Stephen", ""], ["Van Horn", "David", ""], ["Felleisen", "Matthias", ""]]}, {"id": "1009.3306", "submitter": "EPTCS", "authors": "Gwen Sala\\\"un, Xiang Fu, Sylvain Hall\\'e", "title": "Proceedings Fourth International Workshop on Testing, Analysis and\n  Verification of Web Software", "comments": null, "journal-ref": "EPTCS 35, 2010", "doi": "10.4204/EPTCS.35", "report-no": null, "categories": "cs.SE cs.FL cs.LO cs.PL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the papers presented at the fourth international\nworkshop on Testing, Analysis and Verification of Software, which was\nassociated with the 25th IEEE/ACM International Conference on Automated\nSoftware Engineering (ASE 2010). The collection of papers includes research on\nformal specification, model-checking, testing, and debugging of Web software.\n", "versions": [{"version": "v1", "created": "Fri, 17 Sep 2010 00:54:03 GMT"}], "update_date": "2010-09-20", "authors_parsed": [["Sala\u00fcn", "Gwen", ""], ["Fu", "Xiang", ""], ["Hall\u00e9", "Sylvain", ""]]}, {"id": "1009.3770", "submitter": "Germ\\'an Vidal", "authors": "Petra Hofstedt", "title": "Realizing evaluation strategies by hierarchical graph rewriting", "comments": "Online proceedings of the Joint Workshop on Implementation of\n  Constraint Logic Programming Systems and Logic-based Methods in Programming\n  Environments (CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We discuss the realization of evaluation strategies for the concurrent\nconstraint-based functional language CCFL within the translation schemata when\ncompiling CCFL programs into the hierarchical graph rewriting language LMNtal.\n  The support of LMNtal to express local computations and to describe the\nmigration of processes and rules between local computation spaces allows a\nclear and simple encoding of typical evaluation strategies.\n", "versions": [{"version": "v1", "created": "Mon, 20 Sep 2010 10:50:09 GMT"}], "update_date": "2010-09-21", "authors_parsed": [["Hofstedt", "Petra", ""]]}, {"id": "1009.3771", "submitter": "Germ\\'an Vidal", "authors": "Nicos Angelopoulos and Paul Taylor", "title": "An extensible web interface for databases and its application to storing\n  biochemical data", "comments": "Online proceedings of the Joint Workshop on Implementation of\n  Constraint Logic Programming Systems and Logic-based Methods in Programming\n  Environments (CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a generic web-based database interface implemented in\nProlog. We discuss the advantages of the implementation platform and\ndemonstrate the system's applicability in providing access to integrated\nbiochemical data. Our system exploits two libraries of SWI-Prolog to create a\nschema-transparent interface within a relational setting. As is expected in\ndeclarative programming, the interface was written with minimal programming\neffort due to the high level of the language and its suitability to the task.\nWe highlight two of Prolog's features that are well suited to the task at hand:\nterm representation of structured documents and relational nature of Prolog\nwhich facilitates transparent integration of relational databases. Although we\ndeveloped the system for accessing in-house biochemical and genomic data the\ninterface is generic and provides a number of extensible features. We describe\nsome of these features with references to our research databases. Finally we\noutline an in-house library that facilitates interaction between Prolog and the\nR statistical package. We describe how it has been employed in the present\ncontext to store output from statistical analysis on to the database.\n", "versions": [{"version": "v1", "created": "Mon, 20 Sep 2010 11:06:25 GMT"}], "update_date": "2010-09-21", "authors_parsed": [["Angelopoulos", "Nicos", ""], ["Taylor", "Paul", ""]]}, {"id": "1009.3773", "submitter": "Germ\\'an Vidal", "authors": "Paulo Moura", "title": "Towards a Study of Meta-Predicate Semantics", "comments": "Online proceedings of the Joint Workshop on Implementation of\n  Constraint Logic Programming Systems and Logic-based Methods in Programming\n  Environments (CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe and compare design choices for meta-predicate semantics, as found\nin representative Prolog module systems and in Logtalk. We look at the\nconsequences of these design choices from a pragmatic perspective, discussing\nexplicit qualification semantics, computational reflection support,\nexpressiveness of meta-predicate declarations, safety of meta-predicate\ndefinitions, portability of meta-predicate definitions, and meta-predicate\nperformance. Our aim is to provide useful insight for debating meta-predicate\nsemantics and portability issues based on actual implementations and common\nusage patterns.\n", "versions": [{"version": "v1", "created": "Mon, 20 Sep 2010 11:09:27 GMT"}], "update_date": "2010-09-21", "authors_parsed": [["Moura", "Paulo", ""]]}, {"id": "1009.3796", "submitter": "Germ\\'an Vidal", "authors": "Jan Wielemaker and V\\'itor Santos Costa", "title": "Portability of Prolog programs: theory and case-studies", "comments": "Online proceedings of the Joint Workshop on Implementation of\n  Constraint Logic Programming Systems and Logic-based Methods in Programming\n  Environments (CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  (Non-)portability of Prolog programs is widely considered as an important\nfactor in the lack of acceptance of the language. Since 1995, the core of the\nlanguage is covered by the ISO standard 13211-1. Since 2007, YAP and SWI-Prolog\nhave established a basic compatibility framework. This article describes and\nevaluates this framework. The aim of the framework is running the same code on\nboth systems rather than migrating an application. We show that today, the\nportability within the family of Edinburgh/Quintus derived Prolog\nimplementations is good enough to allow for maintaining portable real-world\napplications.\n", "versions": [{"version": "v1", "created": "Mon, 20 Sep 2010 12:38:58 GMT"}], "update_date": "2010-09-21", "authors_parsed": [["Wielemaker", "Jan", ""], ["Costa", "V\u00edtor Santos", ""]]}, {"id": "1009.3800", "submitter": "Germ\\'an Vidal", "authors": "Vasco Pedro and Salvador Abreu", "title": "Distributed Work Stealing for Constraint Solving", "comments": "Online proceedings of the Joint Workshop on Implementation of\n  Constraint Logic Programming Systems and Logic-based Methods in Programming\n  Environments (CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  With the dissemination of affordable parallel and distributed hardware,\nparallel and distributed constraint solving has lately been the focus of some\nattention. To effectually apply the power of distributed computational systems,\nthere must be an effective sharing of the work involved in the search for a\nsolution to a Constraint Satisfaction Problem (CSP) between all the\nparticipating agents, and it must happen dynamically, since it is hard to\npredict the effort associated with the exploration of some part of the search\nspace. We describe and provide an initial experimental assessment of an\nimplementation of a work stealing-based approach to distributed CSP solving.\n", "versions": [{"version": "v1", "created": "Mon, 20 Sep 2010 12:52:40 GMT"}], "update_date": "2010-09-21", "authors_parsed": [["Pedro", "Vasco", ""], ["Abreu", "Salvador", ""]]}, {"id": "1009.3806", "submitter": "Germ\\'an Vidal", "authors": "Paulo Andr\\'e and Salvador Abreu", "title": "Casting of the WAM as an EAM", "comments": "Online proceedings of the Joint Workshop on Implementation of\n  Constraint Logic Programming Systems and Logic-based Methods in Programming\n  Environments (CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logic programming provides a very high-level view of programming, which comes\nat the cost of some execution efficiency. Improving performance of logic\nprograms is thus one of the holy grails of Prolog system implementations and a\nwide range of approaches have historically been taken towards this goal.\nDesigning computational models that both exploit the available parallelism in a\ngiven application and that try hard to reduce the explored search space has\nbeen an ongoing line of research for many years. These goals in particular have\nmotivated the design of several computational models, one of which is the\nExtended Andorra Model (EAM). In this paper, we present a preliminary\nspecification and implementation of the EAM with Implicit Control, the WAM2EAM,\nwhich supplies regular WAM instructions with an EAM-centered interpretation.\n", "versions": [{"version": "v1", "created": "Mon, 20 Sep 2010 13:04:13 GMT"}], "update_date": "2010-09-21", "authors_parsed": [["Andr\u00e9", "Paulo", ""], ["Abreu", "Salvador", ""]]}, {"id": "1009.4020", "submitter": "Germ\\'an Vidal", "authors": "German Vidal, Neng-Fa Zhou", "title": "Proceedings of CICLOPS-WLPE 2010", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Online proceedings of the Joint Workshop on Implementation of Constraint\nLogic Programming Systems and Logic-based Methods in Programming Environments\n(CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010.\n", "versions": [{"version": "v1", "created": "Tue, 21 Sep 2010 08:44:49 GMT"}], "update_date": "2010-09-22", "authors_parsed": [["Vidal", "German", ""], ["Zhou", "Neng-Fa", ""]]}, {"id": "1009.4260", "submitter": "EPTCS", "authors": "Musab AlTurki (University of Illinois at Urbana-Champaign), Jos\\'e\n  Meseguer (University of Illinois at Urbana-Champaign)", "title": "Dist-Orc: A Rewriting-based Distributed Implementation of Orc with\n  Formal Analysis", "comments": "In Proceedings RTRTS 2010, arXiv:1009.3982", "journal-ref": "EPTCS 36, 2010, pp. 26-45", "doi": "10.4204/EPTCS.36.2", "report-no": null, "categories": "cs.LO cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Orc is a theory of orchestration of services that allows structured\nprogramming of distributed and timed computations. Several formal semantics\nhave been proposed for Orc, including a rewriting logic semantics developed by\nthe authors. Orc also has a fully fledged implementation in Java with\nfunctional programming features. However, as with descriptions of most\ndistributed languages, there exists a fairly substantial gap between Orc's\nformal semantics and its implementation, in that: (i) programs in Orc are not\neasily deployable in a distributed implementation just by using Orc's formal\nsemantics, and (ii) they are not readily formally analyzable at the level of a\ndistributed Orc implementation. In this work, we overcome problems (i) and (ii)\nfor Orc. Specifically, we describe an implementation technique based on\nrewriting logic and Maude that narrows this gap considerably. The enabling\nfeature of this technique is Maude's support for external objects through TCP\nsockets. We describe how sockets are used to implement Orc site calls and\nreturns, and to provide real-time timing information to Orc expressions and\nsites. We then show how Orc programs in the resulting distributed\nimplementation can be formally analyzed at a reasonable level of abstraction by\ndefining an abstract model of time and the socket communication infrastructure,\nand discuss the assumptions under which the analysis can be deemed correct.\nFinally, the distributed implementation and the formal analysis methodology are\nillustrated with a case study.\n", "versions": [{"version": "v1", "created": "Wed, 22 Sep 2010 04:02:11 GMT"}], "update_date": "2010-09-23", "authors_parsed": [["AlTurki", "Musab", "", "University of Illinois at Urbana-Champaign"], ["Meseguer", "Jos\u00e9", "", "University of Illinois at Urbana-Champaign"]]}, {"id": "1009.4261", "submitter": "EPTCS", "authors": "Kyungmin Bae (University of Illinois at Urbana-Champaign), Peter Csaba\n  \\\"Olveczky (University of Oslo)", "title": "Extending the Real-Time Maude Semantics of Ptolemy to Hierarchical DE\n  Models", "comments": "In Proceedings RTRTS 2010, arXiv:1009.3982", "journal-ref": "EPTCS 36, 2010, pp. 46-66", "doi": "10.4204/EPTCS.36.3", "report-no": null, "categories": "cs.LO cs.FL cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper extends our Real-Time Maude formalization of the semantics of flat\nPtolemy II discrete-event (DE) models to hierarchical models, including modal\nmodels. This is a challenging task that requires combining synchronous\nfixed-point computations with hierarchical structure. The synthesis of a\nReal-Time Maude verification model from a Ptolemy II DE model, and the formal\nverification of the synthesized model in Real-Time Maude, have been integrated\ninto Ptolemy II, enabling a model-engineering process that combines the\nconvenience of Ptolemy II DE modeling and simulation with formal verification\nin Real-Time Maude.\n", "versions": [{"version": "v1", "created": "Wed, 22 Sep 2010 04:02:21 GMT"}], "update_date": "2010-09-23", "authors_parsed": [["Bae", "Kyungmin", "", "University of Illinois at Urbana-Champaign"], ["\u00d6lveczky", "Peter Csaba", "", "University of Oslo"]]}, {"id": "1009.4262", "submitter": "EPTCS", "authors": "Joakim Bj{\\o}rk (University of Oslo), Einar Broch Johnsen (University\n  of Oslo), Olaf Owe (University of Oslo), Rudolf Schlatte (University of Oslo)", "title": "Lightweight Time Modeling in Timed Creol", "comments": "In Proceedings RTRTS 2010, arXiv:1009.3982", "journal-ref": "EPTCS 36, 2010, pp. 67-81", "doi": "10.4204/EPTCS.36.4", "report-no": null, "categories": "cs.PL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Creol is an object-oriented modeling language in which inherently concurrent\nobjects exchange asynchronous method calls. The operational semantics of Creol\nis written in an actor-based style, formulated in rewriting logic. The\noperational semantics yields a language interpreter in the Maude system, which\ncan be used to analyze models. Recently, Creol has been applied to the modeling\nof systems with radio communication, such as sensor systems. With radio\ncommunication, messages expire and, if sent simultaneously, they may collide in\nthe air. In order to capture these and other properties of distributed systems,\nwe extended Creol's operational semantics with a notion of time. We exploit the\nframework of a language interpreter to use a lightweight notion of time, in\ncontrast to that needed for a general purpose specification language. This\npaper presents a timed extension of Creol, including the semantics and the\nimplementation strategy, and discusses its properties using an extended\nexample. The approach can be generalized to other concurrent object or\nactor-based systems.\n", "versions": [{"version": "v1", "created": "Wed, 22 Sep 2010 04:02:27 GMT"}], "update_date": "2010-09-23", "authors_parsed": [["Bj\u00f8rk", "Joakim", "", "University of Oslo"], ["Johnsen", "Einar Broch", "", "University\n  of Oslo"], ["Owe", "Olaf", "", "University of Oslo"], ["Schlatte", "Rudolf", "", "University of Oslo"]]}, {"id": "1009.5423", "submitter": "Serguei Mokhov", "authors": "Serguei A. Mokhov and Joey Paquet and Mourad Debbabi", "title": "The Need to Support of Data Flow Graph Visualization of Forensic Lucid\n  Programs, Forensic Evidence, and their Evaluation by GIPSY", "comments": "11 pages, 7 figures, index; extended abstract presented at VizSec'10\n  at http://www.vizsec2010.org/posters ; short paper accepted at PST'11", "journal-ref": null, "doi": "10.1109/PST.2011.5971973", "report-no": null, "categories": "cs.PL cs.CR cs.GR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Lucid programs are data-flow programs and can be visually represented as data\nflow graphs (DFGs) and composed visually. Forensic Lucid, a Lucid dialect, is a\nlanguage to specify and reason about cyberforensic cases. It includes the\nencoding of the evidence (representing the context of evaluation) and the crime\nscene modeling in order to validate claims against the model and perform event\nreconstruction, potentially within large swaths of digital evidence. To aid\ninvestigators to model the scene and evaluate it, instead of typing a Forensic\nLucid program, we propose to expand the design and implementation of the Lucid\nDFG programming onto Forensic Lucid case modeling and specification to enhance\nthe usability of the language and the system and its behavior. We briefly\ndiscuss the related work on visual programming an DFG modeling in an attempt to\ndefine and select one approach or a composition of approaches for Forensic\nLucid based on various criteria such as previous implementation, wide use,\nformal backing in terms of semantics and translation. In the end, we solicit\nthe readers' constructive, opinions, feedback, comments, and recommendations\nwithin the context of this short discussion.\n", "versions": [{"version": "v1", "created": "Tue, 28 Sep 2010 01:30:40 GMT"}, {"version": "v2", "created": "Mon, 30 May 2011 05:05:51 GMT"}], "update_date": "2013-07-08", "authors_parsed": [["Mokhov", "Serguei A.", ""], ["Paquet", "Joey", ""], ["Debbabi", "Mourad", ""]]}]