[{"id": "1301.0114", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "Tree-based Arithmetic and Compressed Representations of Giant Numbers", "comments": "UNPUBLISHED DRAFT, 26 pages, 2 figures, literate Haskell code\n  included", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DM cs.DS cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Can we do arithmetic in a completely different way, with a radically\ndifferent data structure? Could this approach provide practical benefits, like\noperations on giant numbers while having an average performance similar to\ntraditional bitstring representations?\n  While answering these questions positively, our tree based representation\ndescribed in this paper comes with a few extra benefits: it compresses giant\nnumbers such that, for instance, the largest known prime number as well as its\nrelated perfect number are represented as trees of small sizes. The same also\napplies to Fermat numbers and important computations like exponentiation of two\nbecome constant time operations.\n  At the same time, succinct representations of sparse sets, multisets and\nsequences become possible through bijections to our tree-represented natural\nnumbers.\n", "versions": [{"version": "v1", "created": "Tue, 1 Jan 2013 18:29:39 GMT"}], "update_date": "2013-01-03", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1301.0128", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "Binary Tree Arithmetic with Generalized Constructors", "comments": "UNPUBLISHED DRAFt, 7 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DM cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe arithmetic computations in terms of operations on some well known\nfree algebras (S1S, S2S and ordered rooted binary trees) while emphasizing the\ncommon structure present in all them when seen as isomorphic with the set of\nnatural numbers.\n  Constructors and deconstructors seen through an initial algebra semantics are\ngeneralized to recursively defined functions obeying similar laws.\n  Implementation using Scala's apply and unapply are discussed together with an\napplication to a realistic arbitrary size arithmetic package written in Scala,\nbased on the free algebra of rooted ordered binary trees, which also supports\nrational number operations through an extension to signed rationals of the\nCalkin-Wilf bijection.\n", "versions": [{"version": "v1", "created": "Tue, 1 Jan 2013 19:58:26 GMT"}], "update_date": "2013-01-03", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1301.0129", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "On Two Infinite Families of Pairing Bijections", "comments": "UNPUBLISHED DRAFT", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DM cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe two general mechanisms for producing pairing bijections\n(bijective functions defined from N x N to N).\n  The first mechanism, using n-adic valuations results in parameterized\nalgorithms generating a countable family of distinct pairing bijections.\n  The second mechanism, using characteristic functions of subsets of N provides\n2^N distinct pairing bijections.\n  Mechanisms to combine such pairing functions and their application to\ngenerate families of permutations of N are also described.\n  The paper uses a small subset of the functional language Haskell to provide\ntype checked executable specifications of all the functions defined in a\nliterate programming style. The self-contained Haskell code extracted from the\npaper is available at http://logic.cse.unt.edu/tarau/research/2012/infpair.hs .\n", "versions": [{"version": "v1", "created": "Tue, 1 Jan 2013 20:10:51 GMT"}], "update_date": "2013-01-03", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1301.0748", "submitter": "Dominik Charousset", "authors": "Dominik Charousset, Thomas C. Schmidt", "title": "libcppa - Designing an Actor Semantic for C++11", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parallel hardware makes concurrency mandatory for efficient program\nexecution. However, writing concurrent software is both challenging and\nerror-prone. C++11 provides standard facilities for multiprogramming, such as\natomic operations with acquire/release semantics and RAII mutex locking, but\nthese primitives remain too low-level. Using them both correctly and\nefficiently still requires expert knowledge and hand-crafting. The actor model\nreplaces implicit communication by sharing with an explicit message passing\nmechanism. It applies to concurrency as well as distribution, and a lightweight\nactor model implementation that schedules all actors in a properly\npre-dimensioned thread pool can outperform equivalent thread-based\napplications. However, the actor model did not enter the domain of native\nprogramming languages yet besides vendor-specific island solutions. With the\nopen source library libcppa, we want to combine the ability to build reliable\nand distributed systems provided by the actor model with the performance and\nresource-efficiency of C++11.\n", "versions": [{"version": "v1", "created": "Fri, 4 Jan 2013 15:23:43 GMT"}], "update_date": "2013-01-07", "authors_parsed": [["Charousset", "Dominik", ""], ["Schmidt", "Thomas C.", ""]]}, {"id": "1301.0849", "submitter": "Asiri Rathnayake", "authors": "James Kirrage, Asiri Rathnayake, Hayo Thielecke", "title": "Static Analysis for Regular Expression Denial-of-Service Attacks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Regular expressions are a concise yet expressive language for expressing\npatterns. For instance, in networked software, they are used for input\nvalidation and intrusion detection. Yet some widely deployed regular expression\nmatchers based on backtracking are themselves vulnerable to denial-of-service\nattacks, since their runtime can be exponential for certain input strings. This\npaper presents a static analysis for detecting such vulnerable regular\nexpressions. The running time of the analysis compares favourably with tools\nbased on fuzzing, that is, randomly generating inputs and measuring how long\nmatching them takes. Unlike fuzzers, the analysis pinpoints the source of the\nvulnerability and generates possible malicious inputs for programmers to use in\nsecurity testing. Moreover, the analysis has a firm theoretical foundation in\nabstract machines. Testing the analysis on two large repositories of regular\nexpressions shows that the analysis is able to find significant numbers of\nvulnerable regular expressions in a matter of seconds.\n", "versions": [{"version": "v1", "created": "Fri, 4 Jan 2013 23:54:49 GMT"}], "update_date": "2013-01-08", "authors_parsed": [["Kirrage", "James", ""], ["Rathnayake", "Asiri", ""], ["Thielecke", "Hayo", ""]]}, {"id": "1301.1386", "submitter": "Michael Fink", "authors": "Evgenii Balai, Michael Gelfond, and Yuanlin Zhang", "title": "SPARC - Sorted ASP with Consistency Restoring Rules", "comments": "Proceedings of Answer Set Programming and Other Computing Paradigms\n  (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest,\n  Hungary", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is a preliminary report on the work aimed at making CR-Prolog -- a\nversion of ASP with consistency restoring rules -- more suitable for use in\nteaching and large applications. First we describe a sorted version of\nCR-Prolog called SPARC. Second, we translate a basic version of the CR-Prolog\ninto the language of DLV and compare the performance with the state of the art\nCR-Prolog solver. The results form the foundation for future more efficient and\nuser friendly implementation of SPARC and shed some light on the relationship\nbetween two useful knowledge representation constructs: consistency restoring\nrules and weak constraints of DLV.\n", "versions": [{"version": "v1", "created": "Tue, 8 Jan 2013 02:29:00 GMT"}], "update_date": "2013-01-09", "authors_parsed": [["Balai", "Evgenii", ""], ["Gelfond", "Michael", ""], ["Zhang", "Yuanlin", ""]]}, {"id": "1301.1629", "submitter": "Michael Tautschnig", "authors": "Jade Alglave and Daniel Kroening and Michael Tautschnig", "title": "Partial Orders for Efficient BMC of Concurrent Software", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The vast number of interleavings that a concurrent program can have is\ntypically identified as the root cause of the difficulty of automatic analysis\nof concurrent software. Weak memory is generally believed to make this problem\neven harder. We address both issues by modelling programs' executions with\npartial orders rather than the interleaving semantics (SC). We implemented a\nsoftware analysis tool based on these ideas. It scales to programs of\nsufficient size to achieve first-time formal verification of non-trivial\nconcurrent systems code over a wide range of models, including SC, Intel x86\nand IBM Power.\n", "versions": [{"version": "v1", "created": "Tue, 8 Jan 2013 18:41:11 GMT"}], "update_date": "2013-01-09", "authors_parsed": [["Alglave", "Jade", ""], ["Kroening", "Daniel", ""], ["Tautschnig", "Michael", ""]]}, {"id": "1301.2443", "submitter": "Andreas Behrend", "authors": "Richard Tantius, Daniel Speicher, Andreas Behrend", "title": "Towards an Application of Update Propagation on Logic Programs\n  Representing Java Source Code", "comments": null, "journal-ref": "26th Workshop on Logic Programming (WLP 2012)", "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Logic programs are now used as a representation of object-oriented source\ncode in academic prototypes for about a decade. This representation allows a\nclear and concise implementation of analyses of the object-oriented source\ncode. The full potential of this approach is far from being explored. In this\npaper, we report about an application of the well-established theory of update\npropagation within logic programs. Given the representation of the\nobject-oriented code as facts in a logic program, a change to the code\ncorresponds to an update of these facts. We demonstrate how update propagation\nprovides a generic way to generate incremental versions of such analyses.\n", "versions": [{"version": "v1", "created": "Fri, 11 Jan 2013 10:26:48 GMT"}], "update_date": "2013-01-14", "authors_parsed": [["Tantius", "Richard", ""], ["Speicher", "Daniel", ""], ["Behrend", "Andreas", ""]]}, {"id": "1301.2763", "submitter": "Satoshi Matsuoka", "authors": "Satoshi Matsuoka", "title": "A New Proof of P-time Completeness of Linear Lambda Calculus", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give a new proof of P-time completeness of Linear Lambda Calculus, which\nwas originally given by H. Mairson in 2003. Our proof uses an essentially\ndifferent Boolean type from the type Mairson used. Moreover the correctness of\nour proof can be machined-checked using an implementation of Standard ML.\n", "versions": [{"version": "v1", "created": "Sun, 13 Jan 2013 10:47:32 GMT"}], "update_date": "2013-01-15", "authors_parsed": [["Matsuoka", "Satoshi", ""]]}, {"id": "1301.2903", "submitter": "Didier Remy", "authors": "Gabriel Scherer (INRIA Rocquencourt), Didier R\\'emy (INRIA\n  Rocquencourt)", "title": "GADTs meet subtyping", "comments": "arXiv admin note: substantial text overlap with arXiv:1210.5935", "journal-ref": "22nd European Symposium on Programming (ESOP), Rome : Italy (2013)", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While generalized algebraic datatypes (\\GADTs) are now considered\nwell-understood, adding them to a language with a notion of subtyping comes\nwith a few surprises. What does it mean for a \\GADT parameter to be covariant?\nThe answer turns out to be quite subtle. It involves fine-grained properties of\nthe subtyping relation that raise interesting design questions. We allow\nvariance annotations in \\GADT definitions, study their soundness, and present a\nsound and complete algorithm to check them. Our work may be applied to\nreal-world ML-like languages with explicit subtyping such as OCaml, or to\nlanguages with general subtyping constraints.\n", "versions": [{"version": "v1", "created": "Mon, 14 Jan 2013 10:22:57 GMT"}], "update_date": "2013-01-15", "authors_parsed": [["Scherer", "Gabriel", "", "INRIA Rocquencourt"], ["R\u00e9my", "Didier", "", "INRIA\n  Rocquencourt"]]}, {"id": "1301.3047", "submitter": "Jan Blech", "authors": "Jan Olaf Blech and Sidi Ould Biha", "title": "On Formal Reasoning on the Semantics of PLC using Coq", "comments": "arXiv admin note: text overlap with arXiv:1102.3529", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Programmable Logic Controllers (PLC) and its programming standard IEC 61131-3\nare widely used in embedded systems for the industrial automation domain. We\npropose a framework for the formal treatment of PLC based on the IEC 61131-3\nstandard. A PLC system description typically combines code written in different\nlanguages that are defined in IEC 61131-3. For the top-level specification we\nregard the Sequential Function Charts (SFC) language, a graphical high-level\nlanguage that allows to describe the main control-flow of the system. In\naddition to this, we describe the Instruction List (IL) language -- an assembly\nlike language -- and two other graphical languages: Ladder Diagrams (LD) and\nFunction Block Diagrams (FBD). IL, LD, and FBD are used to describe more low\nlevel structures of a PLC. We formalize the semantics of these languages and\ndescribe and prove relations between them. Formalization and associated proofs\nare carried out using the proof assistant Coq. In addition to this, we present\nwork on a tool for automatically generating SFC representations from a\ngraphical description -- the IL and LD languages can be handled in Coq directly\n-- and its usage for verification purposes. We sketch possible usages of our\nformal framework, and present an example application for a PLC in a project\ndemonstrator and prove safety properties.\n", "versions": [{"version": "v1", "created": "Mon, 14 Jan 2013 16:40:31 GMT"}], "update_date": "2013-01-15", "authors_parsed": [["Blech", "Jan Olaf", ""], ["Biha", "Sidi Ould", ""]]}, {"id": "1301.3443", "submitter": "Michael Shulman", "authors": "Daniel R. Licata and Michael Shulman", "title": "Calculating the Fundamental Group of the Circle in Homotopy Type Theory", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.PL math.AT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent work on homotopy type theory exploits an exciting new correspondence\nbetween Martin-Lof's dependent type theory and the mathematical disciplines of\ncategory theory and homotopy theory. The category theory and homotopy theory\nsuggest new principles to add to type theory, and type theory can be used in\nnovel ways to formalize these areas of mathematics. In this paper, we formalize\na basic result in algebraic topology, that the fundamental group of the circle\nis the integers. Though simple, this example is interesting for several\nreasons: it illustrates the new principles in homotopy type theory; it mixes\nideas from traditional homotopy-theoretic proofs of the result with\ntype-theoretic inductive reasoning; and it provides a context for understanding\nan existing puzzle in type theory---that a universe (type of types) is\nnecessary to prove that the constructors of inductive types are disjoint and\ninjective.\n", "versions": [{"version": "v1", "created": "Tue, 15 Jan 2013 18:30:31 GMT"}], "update_date": "2013-01-16", "authors_parsed": [["Licata", "Daniel R.", ""], ["Shulman", "Michael", ""]]}, {"id": "1301.4200", "submitter": "Fabian Hueske", "authors": "Fabian Hueske, Aljoscha Krettek, Kostas Tzoumas", "title": "Enabling Operator Reordering in Data Flow Programs Through Static Code\n  Analysis", "comments": "4 pages, accepted and presented at the First International Workshop\n  on Cross-model Language Design and Implementation (XLDI), affiliated with\n  ICFP 2012, Copenhagen", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In many massively parallel data management platforms, programs are\nrepresented as small imperative pieces of code connected in a data flow. This\npopular abstraction makes it hard to apply algebraic reordering techniques\nemployed by relational DBMSs and other systems that use an algebraic\nprogramming abstraction. We present a code analysis technique based on reverse\ndata and control flow analysis that discovers a set of properties from user\ncode, which can be used to emulate algebraic optimizations in this setting.\n", "versions": [{"version": "v1", "created": "Thu, 17 Jan 2013 19:42:55 GMT"}], "update_date": "2013-01-18", "authors_parsed": [["Hueske", "Fabian", ""], ["Krettek", "Aljoscha", ""], ["Tzoumas", "Kostas", ""]]}, {"id": "1301.4258", "submitter": "John Lasseter", "authors": "John Lasseter and John Cipriano", "title": "Design Pattern-Based Extension of Class Hierarchies to Support Runtime\n  Invariant Checks", "comments": "To appear in FASE 2013 proceedings. The final publication is\n  available at http://www.springerlink.com", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a technique for automatically weaving structural invariant checks\ninto an existing collection of classes. Using variations on existing design\npatterns, we use a concise specification to generate from this collection a new\nset of classes that implement the interfaces of the originals, but with the\naddition of user-specified class invariant checks. Our work is notable in the\nscarcity of assumptions made. Unlike previous design pattern approaches to this\nproblem, our technique requires no modification of the original source code,\nrelies only on single inheritance, and does not require that the attributes\nused in the checks be publicly visible. We are able to instrument a wide\nvariety of class hierarchies, including those with pure interfaces, abstract\nclasses and classes with type parameters. We have implemented the construction\nas an Eclipse plug-in for Java development.\n", "versions": [{"version": "v1", "created": "Thu, 17 Jan 2013 22:12:36 GMT"}], "update_date": "2013-01-21", "authors_parsed": [["Lasseter", "John", ""], ["Cipriano", "John", ""]]}, {"id": "1301.4334", "submitter": "Matthew Sottile", "authors": "Matthew J. Sottile and Geoffrey C. Hulette", "title": "Deriving program transformations by demonstration", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automatic code transformation in which transformations are tuned for specific\napplications and contexts are difficult to achieve in an accessible manner. In\nthis paper, we present an approach to build application specific code\ntransformations. Our approach is based on analysis of the abstract syntax\nrepresentation of exemplars of the essential change to the code before and\nafter the transformation is applied. This analysis entails a sequence of steps\nto identify the change, determine how to generalize it, and map it to term\nrewriting rules for the Stratego term rewriting system. The methods described\nin this paper assume programs are represented in a language-neutral term\nformat, allowing tools based on our methods to be applied to programs written\nin the major languages used by computational scientists utilizing high\nperformance computing systems.\n", "versions": [{"version": "v1", "created": "Fri, 18 Jan 2013 09:57:39 GMT"}], "update_date": "2013-01-21", "authors_parsed": [["Sottile", "Matthew J.", ""], ["Hulette", "Geoffrey C.", ""]]}, {"id": "1301.4650", "submitter": "EPTCS", "authors": "Marco T. Moraz\\'an (Seton Hall University), Peter Achten (Radboud\n  University Nijmegen)", "title": "Proceedings First International Workshop on Trends in Functional\n  Programming in Education", "comments": null, "journal-ref": "EPTCS 106, 2013", "doi": "10.4204/EPTCS.106", "report-no": null, "categories": "cs.PL cs.CY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The First International Workshop on Trends in Functional Programming in\nEducation, TFPIE 2012, was held on June 11, 2012 at the University of St\nAndrews in Scotland. The goal of TFPIE is to gather researchers, professors,\nteachers, and all professionals that use or are interested in the use of\nfunctional programming in education. Submissions were vetted by the TFPIE 2012\nprogram committee using prevailing academic standards. The 4 articles in this\nvolume were selected for publication as the result of this process. These\narticles cover a wide range of novel approaches in education using functional\nprogramming. Page and Gamboa describe how they introduce students to\ncomputational thinking and problem solving using logic and equation-based\nreasoning. O'Donnell describes efforts to make computer systems courses come\nalive through the use of simulation and a functional hardware description\nlanguage. Radge describes a novel approach to CS1 exploiting the interplay of\nthe imprecision found in mathematical abstractions and the precision that is\nrequired in programming. Stutterheim, Swierstra, and Swierstra describe a new\napproach to introduce high school students to programming and to important\nideas in Computer Science using a web-based interpreter and theorem prover.\n", "versions": [{"version": "v1", "created": "Sun, 20 Jan 2013 10:54:57 GMT"}], "update_date": "2013-01-22", "authors_parsed": [["Moraz\u00e1n", "Marco T.", "", "Seton Hall University"], ["Achten", "Peter", "", "Radboud\n  University Nijmegen"]]}, {"id": "1301.4779", "submitter": "Thomas Braibant", "authors": "Thomas Braibant (INRIA Rocquencourt), Adam Chlipala (CSAIL)", "title": "Formal Verification of Hardware Synthesis", "comments": null, "journal-ref": "Computer Aided Verification, Saint Petersburg : Russie,\n  F\\'ed\\'eration De (2013)", "doi": "10.1007/978-3-642-39799-8_14", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We report on the implementation of a certified compiler for a high-level\nhardware description language (HDL) called Fe-Si (FEatherweight SynthesIs).\nFe-Si is a simplified version of Bluespec, an HDL based on a notion of guarded\natomic actions. Fe-Si is defined as a dependently typed deep embedding in Coq.\nThe target language of the compiler corresponds to a synthesisable subset of\nVerilog or VHDL. A key aspect of our approach is that input programs to the\ncompiler can be defined and proved correct inside Coq. Then, we use extraction\nand a Verilog back-end (written in OCaml) to get a certified version of a\nhardware design.\n", "versions": [{"version": "v1", "created": "Mon, 21 Jan 2013 08:12:22 GMT"}], "update_date": "2013-11-08", "authors_parsed": [["Braibant", "Thomas", "", "INRIA Rocquencourt"], ["Chlipala", "Adam", "", "CSAIL"]]}, {"id": "1301.4858", "submitter": "Luis Quesada", "authors": "Luis Quesada, Fernando Berzal, Juan-Carlos Cubero", "title": "A DSL for Mapping Abstract Syntax Models to Concrete Syntax Models in\n  ModelCC", "comments": "arXiv admin note: substantial text overlap with arXiv:1202.6593", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  ModelCC is a model-based parser generator that decouples language design from\nlanguage processing. ModelCC provides two different mechanisms to specify the\nmapping from an abstract syntax model to a concrete syntax model: metadata\nannotations defined on top of the abstract syntax model specification and a\ndomain-specific language for defining ASM-CSM mappings. Using a domain-specific\nlanguage to specify the mapping from abstract to concrete syntax models allows\nthe definition of multiple concrete syntax models for the same abstract syntax\nmodel. In this paper, we describe the ModelCC domain-specific language for\nabstract syntax model to concrete syntax model mappings and we showcase its\ncapabilities by providing a meta-definition of that domain-specific language.\n", "versions": [{"version": "v1", "created": "Mon, 21 Jan 2013 13:18:10 GMT"}], "update_date": "2013-01-22", "authors_parsed": [["Quesada", "Luis", ""], ["Berzal", "Fernando", ""], ["Cubero", "Juan-Carlos", ""]]}, {"id": "1301.5075", "submitter": "EPTCS", "authors": "John T. O'Donnell (School of Computing Science, University of Glasgow)", "title": "Connecting the Dots: Computer Systems Education using a Functional\n  Hardware Description Language", "comments": "In Proceedings TFPIE 2012, arXiv:1301.4650", "journal-ref": "EPTCS 106, 2013, pp. 20-39", "doi": "10.4204/EPTCS.106.2", "report-no": null, "categories": "cs.CY cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A functional hardware description language enables students to gain a working\nunderstanding of computer systems, and to see how the levels of abstraction fit\ntogether. By simulating circuits, digital design becomes a living topic, like\nprogramming, and not just a set of inert facts to memorise. Experiences gained\nfrom more than 20 years of teaching computer systems via functional programming\nare discussed.\n", "versions": [{"version": "v1", "created": "Tue, 22 Jan 2013 05:17:34 GMT"}], "update_date": "2013-01-23", "authors_parsed": [["O'Donnell", "John T.", "", "School of Computing Science, University of Glasgow"]]}, {"id": "1301.5076", "submitter": "EPTCS", "authors": "Prabhakar Ragde (University of Waterloo)", "title": "Mathematics Is Imprecise", "comments": "In Proceedings TFPIE 2012, arXiv:1301.4650", "journal-ref": "EPTCS 106, 2013, pp. 40-49", "doi": "10.4204/EPTCS.106.3", "report-no": null, "categories": "cs.PL cs.CY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We commonly think of mathematics as bringing precision to application\ndomains, but its relationship with computer science is more complex. This\nexperience report on the use of Racket and Haskell to teach a required first\nuniversity CS course to students with very good mathematical skills focusses on\nthe ways that programming forces one to get the details right, with consequent\nbenefits in the mathematical domain. Conversely, imprecision in mathematical\nabstractions and notation can work to the benefit of beginning programmers, if\nhandled carefully.\n", "versions": [{"version": "v1", "created": "Tue, 22 Jan 2013 05:17:40 GMT"}], "update_date": "2013-01-23", "authors_parsed": [["Ragde", "Prabhakar", "", "University of Waterloo"]]}, {"id": "1301.5077", "submitter": "EPTCS", "authors": "Jurri\\\"en Stutterheim (Utrecht University), Wouter Swierstra (Utrecht\n  University), Doaitse Swierstra (Utrecht University)", "title": "Forty hours of declarative programming: Teaching Prolog at the Junior\n  College Utrecht", "comments": "In Proceedings TFPIE 2012, arXiv:1301.4650", "journal-ref": "EPTCS 106, 2013, pp. 50-62", "doi": "10.4204/EPTCS.106.4", "report-no": null, "categories": "cs.CY cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper documents our experience using declarative languages to give\nsecondary school students a first taste of Computer Science. The course aims to\nteach students a bit about programming in Prolog, but also exposes them to\nimportant Computer Science concepts, such as unification or searching\nstrategies. Using Haskell's Snap Framework in combination with our own\nNanoProlog library, we have developed a web application to teach this course.\n", "versions": [{"version": "v1", "created": "Tue, 22 Jan 2013 05:17:48 GMT"}], "update_date": "2013-01-23", "authors_parsed": [["Stutterheim", "Jurri\u00ebn", "", "Utrecht University"], ["Swierstra", "Wouter", "", "Utrecht\n  University"], ["Swierstra", "Doaitse", "", "Utrecht University"]]}, {"id": "1301.6260", "submitter": "Sim-Hui Tee", "authors": "Sim-Hui Tee", "title": "Problems of Inheritance at Java Inner Class", "comments": "4 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Single inheritance has been widely accepted in the current programming\npractice to avoid the complication that incurred by multiple inheritance.\nSingle inheritance enhances the reusability of codes and eliminates the\nconfusion of identical methods that possibly defined in two superclasses.\nHowever, the mechanism of inner class in Java potentially reintroduces the\nproblems encountered by multiple inheritance. When the depth of Java inner\nclass is increased, the problem becomes severe. This paper aims at exposing the\nproblems of inheritance at the Java inner class. In addition, a measure is\nproposed to evaluate the potential problem of inheritance for Java inner class\n", "versions": [{"version": "v1", "created": "Sat, 26 Jan 2013 14:25:54 GMT"}], "update_date": "2013-01-29", "authors_parsed": [["Tee", "Sim-Hui", ""]]}, {"id": "1301.6836", "submitter": "Mi-Young  Park", "authors": "Keehang Kwon, Kyunghwan Park, Mi-Young Park", "title": "Towards Interactive Object-Oriented Programming", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  To represent interactive objects, we propose a choice-disjunctive declaration\nstatement of the form S R where S;R are the (procedure or field) declaration\nstatements within a class. This statement has the following semantics: request\nthe user to choose one between S and R when an object of this class is created.\nThis statement is useful for representing interactive objects that require\ninteractions with the user.\n", "versions": [{"version": "v1", "created": "Tue, 29 Jan 2013 06:02:21 GMT"}], "update_date": "2013-01-30", "authors_parsed": [["Kwon", "Keehang", ""], ["Park", "Kyunghwan", ""], ["Park", "Mi-Young", ""]]}, {"id": "1301.6905", "submitter": "Robert Kowalski", "authors": "Robert Kowalski, Fariba Sadri", "title": "Towards a Logic-Based Unifying Framework for Computing", "comments": "An improved version of this paper will be published in the journal,\n  New Generation Computing, with the title \"Reactive Computing as Model\n  Generation\". In the meanwhile, a copy of the revised paper can be found on\n  http://www.doc.ic.ac.uk/~rak/", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.DB cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we propose a logic-based, framework inspired by artificial\nintelligence, but scaled down for practical database and programming\napplications. Computation in the framework is viewed as the task of generating\na sequence of state transitions, with the purpose of making an agent's goals\nall true. States are represented by sets of atomic sentences (or facts),\nrepresenting the values of program variables, tuples in a coordination\nlanguage, facts in relational databases, or Herbrand models.\n  In the model-theoretic semantics, the entire sequence of states and events\nare combined into a single model-theoretic structure, by associating timestamps\nwith facts and events. But in the operational semantics, facts are updated\ndestructively, without timestamps. We show that the model generated by\ndestructive updates is identical to the model generated by reasoning with facts\ncontaining timestamps. We also extend the model with intentional predicates and\ncomposite event predicates defined by logic programs containing conditions in\nfirst-order logic, which query the current state.\n", "versions": [{"version": "v1", "created": "Tue, 29 Jan 2013 12:23:26 GMT"}, {"version": "v2", "created": "Thu, 24 Apr 2014 07:25:29 GMT"}], "update_date": "2014-04-25", "authors_parsed": [["Kowalski", "Robert", ""], ["Sadri", "Fariba", ""]]}, {"id": "1301.7190", "submitter": "Marco Frigerio", "authors": "Marco Frigerio, Jonas Buchli and Darwin G. Caldwell", "title": "A Domain Specific Language for kinematic models and fast implementations\n  of robot dynamics algorithms", "comments": "Presented at DSLRob 2011 (arXiv:1212.3308)", "journal-ref": null, "doi": null, "report-no": "DSLRob/2011/02", "categories": "cs.RO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Rigid body dynamics algorithms play a crucial role in several components of a\nrobot controller and simulations. Real time constraints in high frequency\ncontrol loops and time requirements of specific applications demand these\nfunctions to be very efficient. Despite the availability of established\nalgorithms, their efficient implementation for a specific robot still is a\ntedious and error-prone task. However, these components are simply necessary to\nget high performance controllers.\n  To achieve efficient yet well maintainable implementations of dynamics\nalgorithms we propose to use a domain specific language to describe the\nkinematics/dynamics model of a robot. Since the algorithms are parameterized on\nthis model, executable code tailored for a specific robot can be generated,\nthanks to the facilities available for \\dsls. This approach allows the users to\ndeal only with the high level description of their robot and relieves them from\nproblematic hand-crafted development; resources and efforts can then be focused\non open research questions.\n  Preliminary results about the generation of efficient code for inverse\ndynamics will be presented as a proof of concept of this approach.\n", "versions": [{"version": "v1", "created": "Wed, 30 Jan 2013 10:40:21 GMT"}], "update_date": "2013-01-31", "authors_parsed": [["Frigerio", "Marco", ""], ["Buchli", "Jonas", ""], ["Caldwell", "Darwin G.", ""]]}, {"id": "1301.7669", "submitter": "Nicos Angelopoulos", "authors": "Jan Wielemaker", "title": "Extending the logical update view with transaction support", "comments": "Appeared in CICLOPS 2012. 9 Pages, 0 Figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Since the database update view was standardised in the Prolog ISO standard,\nthe so called logical update view is available in all actively maintained\nProlog systems. While this update view provided a well defined update semantics\nand allows for efficient handling of dynamic code, it does not help in\nmaintaining consistency of the dynamic database. With the introduction of\nmultiple threads and deployment of Prolog in continuously running server\napplications, consistency of the dynamic database becomes important.\n  In this article, we propose an extension to the generation-based\nimplementation of the logical update view that supports transactions.\nGeneration-based transactions have been implemented according to this\ndescription in the SWI-Prolog RDF store. The aim of this paper is to motivate\ntransactions, outline an implementation and generate discussion on the\ndesirable semantics and interface prior to implementation.\n", "versions": [{"version": "v1", "created": "Thu, 31 Jan 2013 16:23:43 GMT"}], "update_date": "2013-02-01", "authors_parsed": [["Wielemaker", "Jan", ""]]}, {"id": "1301.7673", "submitter": "Nicos Angelopoulos", "authors": "Neng-Fa Zhou and Jonathan Fruhman", "title": "Toward a Dynamic Programming Solution for the 4-peg Tower of Hanoi\n  Problem with Configurations", "comments": "Appeared in CICLOPS 2012. 15 Pages, 2 Figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Frame-Stewart algorithm for the 4-peg variant of the Tower of Hanoi,\nintroduced in 1941, partitions disks into intermediate towers before moving the\nremaining disks to their destination. Algorithms that partition the disks have\nnot been proven to be optimal, although they have been verified for up to 30\ndisks. This paper presents a dynamic programming approach to this algorithm,\nusing tabling in B-Prolog. This study uses a variation of the problem,\ninvolving configurations of disks, in order to contrast the tabling approach\nwith the approaches utilized by other solvers. A comparison of different\npartitioning locations for the Frame-Stewart algorithm indicates that, although\ncertain partitions are optimal for the classic problem, they need to be\nmodified for certain configurations, and that random configurations might\nrequire an entirely new algorithm.\n", "versions": [{"version": "v1", "created": "Thu, 31 Jan 2013 16:37:28 GMT"}], "update_date": "2013-02-01", "authors_parsed": [["Zhou", "Neng-Fa", ""], ["Fruhman", "Jonathan", ""]]}, {"id": "1301.7680", "submitter": "Nicos Angelopoulos", "authors": "Jo\\~ao Santos and Ricardo Rocha", "title": "Efficient Support for Mode-Directed Tabling in the YapTab Tabling System", "comments": "Appeared in CICLOPS 2012. 15 Pages, 12 Figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Mode-directed tabling is an extension to the tabling technique that supports\nthe definition of mode operators for specifying how answers are inserted into\nthe table space. In this paper, we focus our discussion on the efficient\nsupport for mode directed-tabling in the YapTab tabling system. We discuss 7\ndifferent mode operators and explain how we have extended and optimized\nYapTab's table space organization to support them. Initial experimental results\nshow that our implementation compares favorably with the B-Prolog and XSB\nstate-of-the-art Prolog tabling systems.\n", "versions": [{"version": "v1", "created": "Thu, 31 Jan 2013 16:55:52 GMT"}], "update_date": "2013-02-01", "authors_parsed": [["Santos", "Jo\u00e3o", ""], ["Rocha", "Ricardo", ""]]}, {"id": "1301.7690", "submitter": "Nicos Angelopoulos", "authors": "Rui Vieira and Ricardo Rocha and Fernando Silva", "title": "On Comparing Alternative Splitting Strategies for Or-Parallel Prolog\n  Execution on Multicores", "comments": "Appeared in CICLOPS 2012. 15 Pages, 6 Figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many or-parallel Prolog models exploiting implicit parallelism have been\nproposed in the past. Arguably, one of the most successful models is\nenvironment copying for shared memory architectures. With the increasing\navailability and popularity of multicore architectures, it makes sense to\nrecover the body of knowledge there is in this area and re-engineer prior\ncomputational models to evaluate their performance on newer architectures. In\nthis work, we focus on the implementation of splitting strategies for\nor-parallel Prolog execution on multicores and, for that, we develop a\nframework, on top of the YapOr system, that integrates and supports five\nalternative splitting strategies. Our implementation shares the underlying\nexecution environment and most of the data structures used to implement\nor-parallelism in YapOr. In particular, we took advantage of YapOr's\ninfrastructure for incremental copying and scheduling support, which we used\nwith minimal modifications. We thus argue that all these common support\nfeatures allow us to make a first and fair comparison between these five\nalternative splitting strategies and, therefore, better understand their\nadvantages and weaknesses.\n", "versions": [{"version": "v1", "created": "Thu, 31 Jan 2013 17:19:21 GMT"}], "update_date": "2013-02-01", "authors_parsed": [["Vieira", "Rui", ""], ["Rocha", "Ricardo", ""], ["Silva", "Fernando", ""]]}, {"id": "1301.7694", "submitter": "Nicos Angelopoulos", "authors": "Zo\\'e Drey and Jos\\'e F. Morales and Manuel V. Hermenegildo", "title": "Reversible Language Extensions and their Application in Debugging", "comments": "Appeared in CICLOPS 2012. 15 Pages, 7 Figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A range of methodologies and techniques are available to guide the design and\nimplementation of language extensions and domain-specific languages. A simple\nyet powerful technique is based on source-to-source transformations interleaved\nacross the compilation passes of a base language. Despite being a successful\napproach, it has the main drawback that the input source code is lost in the\nprocess. When considering the whole workflow of program development (warning\nand error reporting, debugging, or even program analysis), program translations\nare no more powerful than a glorified macro language. In this paper, we propose\nan augmented approach to language extensions for Prolog, where symbolic\nannotations are included in the target program. These annotations allow\nselectively reversing the translated code. We illustrate the approach by\nshowing that coupling it with minimal extensions to a generic Prolog debugger\nallows us to provide users with a familiar, source-level view during the\ndebugging of programs which use a variety of language extensions, such as\nfunctional notation, DCGs, or CLP{Q,R}.\n", "versions": [{"version": "v1", "created": "Thu, 31 Jan 2013 17:26:09 GMT"}], "update_date": "2013-02-01", "authors_parsed": [["Drey", "Zo\u00e9", ""], ["Morales", "Jos\u00e9 F.", ""], ["Hermenegildo", "Manuel V.", ""]]}, {"id": "1301.7699", "submitter": "Nicos Angelopoulos", "authors": "Rui Machado and Salvador Abreu and Daniel Diaz", "title": "Parallel Local Search: Experiments with a PGAS-based programming model", "comments": "Appeared in CICLOPS 2012. 17 Pages, 4 Figures. arXiv admin note: text\n  overlap with arXiv:1212.4287 by other authors", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Local search is a successful approach for solving combinatorial optimization\nand constraint satisfaction problems. With the progressing move toward multi\nand many-core systems, GPUs and the quest for Exascale systems, parallelism has\nbecome mainstream as the number of cores continues to increase. New programming\nmodels are required and need to be better understood as well as data structures\nand algorithms. Such is the case for local search algorithms when run on\nhundreds or thousands of processing units. In this paper, we discuss some\nexperiments we have been doing with Adaptive Search and present a new parallel\nversion of it based on GPI, a recent API and programming model for the\ndevelopment of scalable parallel applications. Our experiments on different\nproblems show interesting speedups and, more importantly, a deeper\ninterpretation of the parallelization of Local Search methods.\n", "versions": [{"version": "v1", "created": "Thu, 31 Jan 2013 17:35:55 GMT"}, {"version": "v2", "created": "Fri, 10 May 2013 14:46:14 GMT"}], "update_date": "2013-05-13", "authors_parsed": [["Machado", "Rui", ""], ["Abreu", "Salvador", ""], ["Diaz", "Daniel", ""]]}, {"id": "1301.7702", "submitter": "Nicos Angelopoulos", "authors": "Emilio Jes\\'us Gallego Arias and R\\'emy Haemmerl\\'e and Manuel V.\n  Hermenegildo and Jos\\'e F. Morales", "title": "The Ciao clp(FD) Library. A Modular CLP Extension for Prolog", "comments": "Appeared in CICLOPS 2012. 15 Pages, 5 Figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new free library for Constraint Logic Programming over Finite\nDomains, included with the Ciao Prolog system. The library is entirely written\nin Prolog, leveraging on Ciao's module system and code transformation\ncapabilities in order to achieve a highly modular design without compromising\nperformance. We describe the interface, implementation, and design rationale of\neach modular component.\n  The library meets several design goals: a high level of modularity, allowing\nthe individual components to be replaced by different versions;\nhigh-efficiency, being competitive with other FD implementations; a glass-box\napproach, so the user can specify new constraints at different levels; and a\nProlog implementation, in order to ease the integration with Ciao's code\nanalysis components.\n  The core is built upon two small libraries which implement integer ranges and\nclosures. On top of that, a finite domain variable datatype is defined, taking\ncare of constraint reexecution depending on range changes. These three\nlibraries form what we call the FD kernel of the library.\n  This FD kernel is used in turn to implement several higher-level finite\ndomain constraints, specified using indexicals. Together with a labeling module\nthis layer forms what we name \\emph{the FD solver}. A final level integrates\nthe clp(FD) paradigm with our FD solver. This is achieved using attributed\nvariables and a compiler from the clp(FD) language to the set of constraints\nprovided by the solver.\n  It should be noted that the user of the library is encouraged to work in any\nof those levels as seen convenient: from writing a new range module to\nenriching the set of FD constraints by writing new indexicals.\n", "versions": [{"version": "v1", "created": "Thu, 31 Jan 2013 17:49:20 GMT"}], "update_date": "2013-02-01", "authors_parsed": [["Arias", "Emilio Jes\u00fas Gallego", ""], ["Haemmerl\u00e9", "R\u00e9my", ""], ["Hermenegildo", "Manuel V.", ""], ["Morales", "Jos\u00e9 F.", ""]]}]