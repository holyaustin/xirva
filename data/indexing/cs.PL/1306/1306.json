[{"id": "1306.1870", "submitter": "Jos\\'e Guimar\\~aes", "authors": "Jos\\'e de Oliveira Guimar\\~aes", "title": "The Cyan Language", "comments": "248 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is the manual of Cyan, a prototype-based object-oriented language. Cyan\nsupports static typing, single inheritance, mixin objects (similar to mixin\nclasses with mixin inheritance), generic prototypes, and Java-like interfaces.\nThe language has several innovations: a completely object-oriented exception\nsystem, statically-typed closures, a kind of graphical metaobjects called\ncodegs, optional dynamic typing, user-defined literal objects (an innovative\nway of creating objects), context objects (a generalization of closures), and\ngrammar methods and message sends (which makes it easy to define Domain\nSpecific Languages).\n", "versions": [{"version": "v1", "created": "Sat, 8 Jun 2013 02:22:42 GMT"}], "update_date": "2013-06-11", "authors_parsed": [["Guimar\u00e3es", "Jos\u00e9 de Oliveira", ""]]}, {"id": "1306.1901", "submitter": "Roberto Bagnara", "authors": "Roberto Bagnara, Fred Mesnard", "title": "Eventual Linear Ranking Functions", "comments": "10 pages", "journal-ref": null, "doi": "10.1145/2505879.2505884", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program termination is a hot research topic in program analysis. The last few\nyears have witnessed the development of termination analyzers for programming\nlanguages such as C and Java with remarkable precision and performance. These\nsystems are largely based on techniques and tools coming from the field of\ndeclarative constraint programming. In this paper, we first recall an algorithm\nbased on Farkas' Lemma for discovering linear ranking functions proving\ntermination of a certain class of loops. Then we propose an extension of this\nmethod for showing the existence of eventual linear ranking functions, i.e.,\nlinear functions that become ranking functions after a finite unrolling of the\nloop. We show correctness and completeness of this algorithm.\n", "versions": [{"version": "v1", "created": "Sat, 8 Jun 2013 10:10:05 GMT"}], "update_date": "2013-07-26", "authors_parsed": [["Bagnara", "Roberto", ""], ["Mesnard", "Fred", ""]]}, {"id": "1306.1919", "submitter": "Lars Bergstrom", "authors": "Lars Bergstrom, Matthew Fluet, John Reppy, Nora Sandler", "title": "Practical Inlining of Functions with Free Variables", "comments": "Rejected from ICFP2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A long-standing practical challenge in the optimization of higher-order\nlanguages is inlining functions with free variables. Inlining code statically\nat a function call site is safe if the compiler can guarantee that the free\nvariables have the same bindings at the inlining point as they do at the point\nwhere the function is bound as a closure (code and free variables). There have\nbeen many attempts to create a heuristic to check this correctness condition,\nfrom Shivers' kCFA-based reflow analysis to Might's Delta-CFA and anodization,\nbut all of those have performance unsuitable for practical compiler\nimplementations. In practice, modern language implementations rely on a series\nof tricks to capture some common cases (e.g., closures whose free variables are\nonly top-level identifiers such as +) and rely on hand-inlining by the\nprogrammer for anything more complicated.\n  This work provides the first practical, general approach for inlining\nfunctions with free variables. We also provide a proof of correctness, an\nevaluation of both the execution time and performance impact of this\noptimization, and some tips and tricks for implementing an efficient and\nprecise control-flow analysis.\n", "versions": [{"version": "v1", "created": "Sat, 8 Jun 2013 13:31:59 GMT"}], "update_date": "2013-06-11", "authors_parsed": [["Bergstrom", "Lars", ""], ["Fluet", "Matthew", ""], ["Reppy", "John", ""], ["Sandler", "Nora", ""]]}, {"id": "1306.1945", "submitter": "Anvesh Komuravelli", "authors": "Anvesh Komuravelli, Arie Gurfinkel, Sagar Chaki and Edmund M. Clarke", "title": "Automatic Abstraction in SMT-Based Unbounded Software Model Checking", "comments": "Extended version of a paper in the proceedings of CAV 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Software model checkers based on under-approximations and SMT solvers are\nvery successful at verifying safety (i.e. reachability) properties. They\ncombine two key ideas -- (a) \"concreteness\": a counterexample in an\nunder-approximation is a counterexample in the original program as well, and\n(b) \"generalization\": a proof of safety of an under-approximation, produced by\nan SMT solver, are generalizable to proofs of safety of the original program.\nIn this paper, we present a combination of \"automatic abstraction\" with the\nunder-approximation-driven framework. We explore two iterative approaches for\nobtaining and refining abstractions -- \"proof based\" and \"counterexample based\"\n-- and show how they can be combined into a unified algorithm. To the best of\nour knowledge, this is the first application of Proof-Based Abstraction,\nprimarily used to verify hardware, to Software Verification. We have\nimplemented a prototype of the framework using Z3, and evaluate it on many\nbenchmarks from the Software Verification Competition. We show experimentally\nthat our combination is quite effective on hard instances.\n", "versions": [{"version": "v1", "created": "Sat, 8 Jun 2013 18:41:28 GMT"}], "update_date": "2013-06-11", "authors_parsed": [["Komuravelli", "Anvesh", ""], ["Gurfinkel", "Arie", ""], ["Chaki", "Sagar", ""], ["Clarke", "Edmund M.", ""]]}, {"id": "1306.2267", "submitter": "Patrizio Dazzi", "authors": "Patrizio Dazzi", "title": "Let's Annotate to Let Our Code Run in Parallel", "comments": "4 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents an approach that exploits Java annotations to provide\nmeta information needed to automatically transform plain Java programs into\nparallel code that can be run on multicore workstation. Programmers just need\nto decorate the methods that will eventually be executed in parallel with\nstandard Java annotations. Annotations are automatically processed at\nlaunch-time and parallel byte code is derived. Once in execution the program\nautomatically retrieves the information about the executing platform and\nevaluates the information specified inside the annotations to transform the\nbyte-code into a semantically equivalent multithreaded version, depending on\nthe target architecture features. The results returned by the annotated\nmethods, when invoked, are futures with a wait-by-necessity semantics.\n", "versions": [{"version": "v1", "created": "Thu, 6 Jun 2013 13:07:30 GMT"}], "update_date": "2013-06-11", "authors_parsed": [["Dazzi", "Patrizio", ""]]}, {"id": "1306.2291", "submitter": "Francesca Scozzari", "authors": "Gianluca Amato and Francesca Scozzari", "title": "Optimal multi-binding unification for sharing and linearity analysis", "comments": "To appear in Theory and Practice of Logic Programming (TPLP)", "journal-ref": "Theory and Practice of Logic Programming, 14, pp 379-400, 2014", "doi": "10.1017/S1471068413000070", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the analysis of logic programs, abstract domains for detecting sharing\nproperties are widely used. Recently the new domain $\\Linp$ has been introduced\nto generalize both sharing and linearity information. This domain is endowed\nwith an optimal abstract operator for single-binding unification. The authors\nclaim that the repeated application of this operator is also optimal for\nmulti-binding unification. This is the proof of such a claim.\n", "versions": [{"version": "v1", "created": "Mon, 10 Jun 2013 19:12:57 GMT"}], "update_date": "2016-03-18", "authors_parsed": [["Amato", "Gianluca", ""], ["Scozzari", "Francesca", ""]]}, {"id": "1306.2675", "submitter": "Noson S. Yanofsky", "authors": "Noson S. Yanofsky", "title": "Kolmogorov Complexity of Categories", "comments": "16 pages", "journal-ref": "An version of this is published in \"Computation, Logic, Games, and\n  Quantum Foundations - The Many Facets of Samson Abramsky: Essays Dedicted to\n  Samson Abramsky on the Occasion of His 60th Birthday\" Springer LNCS 7860.\n  2013", "doi": null, "report-no": null, "categories": "math.CT cs.IT cs.LO cs.PL math.IT math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Kolmogorov complexity theory is used to tell what the algorithmic\ninformational content of a string is. It is defined as the length of the\nshortest program that describes the string. We present a programming language\nthat can be used to describe categories, functors, and natural transformations.\nWith this in hand, we define the informational content of these categorical\nstructures as the shortest program that describes such structures. Some basic\nconsequences of our definition are presented including the fact that equivalent\ncategories have equal Kolmogorov complexity. We also prove different theorems\nabout what can and cannot be described by our programming language.\n", "versions": [{"version": "v1", "created": "Tue, 11 Jun 2013 23:40:36 GMT"}], "update_date": "2013-06-13", "authors_parsed": [["Yanofsky", "Noson S.", ""]]}, {"id": "1306.2692", "submitter": "EPTCS", "authors": "Paolo Tranquilli (DISI -- Universit\\`a di Bologna Alma Mater)", "title": "Indexed Labels for Loop Iteration Dependent Costs", "comments": "In Proceedings QAPL 2013, arXiv:1306.2413", "journal-ref": "EPTCS 117, 2013, pp. 19-33", "doi": "10.4204/EPTCS.117.2", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an extension to the labelling approach, a technique for lifting\nresource consumption information from compiled to source code. This approach,\nwhich is at the core of the annotating compiler from a large fragment of C to\n8051 assembly of the CerCo project, looses preciseness when differences arise\nas to the cost of the same portion of code, whether due to code transformation\nsuch as loop optimisations or advanced architecture features (e.g. cache). We\npropose to address this weakness by formally indexing cost labels with the\niterations of the containing loops they occur in. These indexes can be\ntransformed during the compilation, and when lifted back to source code they\nproduce dependent costs.\n  The proposed changes have been implemented in CerCo's untrusted prototype\ncompiler from a large fragment of C to 8051 assembly.\n", "versions": [{"version": "v1", "created": "Wed, 12 Jun 2013 01:55:23 GMT"}], "update_date": "2013-06-13", "authors_parsed": [["Tranquilli", "Paolo", "", "DISI -- Universit\u00e0 di Bologna Alma Mater"]]}, {"id": "1306.2743", "submitter": "Raphael kena Poss", "authors": "Raphael Poss and Merijn Verstraaten and Frank Penczek and Clemens\n  Grelck and Raimund Kirner and Alex Shafarenko", "title": "S+Net: extending functional coordination with extra-functional semantics", "comments": "34 pages, 11 figures, 3 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This technical report introduces S+Net, a compositional coordination language\nfor streaming networks with extra-functional semantics. Compositionality\nsimplifies the specification of complex parallel and distributed applications;\nextra-functional semantics allow the application designer to reason about and\ncontrol resource usage, performance and fault handling. The key feature of\nS+Net is that functional and extra-functional semantics are defined\northogonally from each other. S+Net can be seen as a simultaneous\nsimplification and extension of the existing coordination language S-Net, that\ngives control of extra-functional behavior to the S-Net programmer. S+Net can\nalso be seen as a transitional research step between S-Net and AstraKahn,\nanother coordination language currently being designed at the University of\nHertfordshire. In contrast with AstraKahn which constitutes a re-design from\nthe ground up, S+Net preserves the basic operational semantics of S-Net and\nthus provides an incremental introduction of extra-functional control in an\nexisting language.\n", "versions": [{"version": "v1", "created": "Wed, 12 Jun 2013 08:25:51 GMT"}], "update_date": "2013-06-13", "authors_parsed": [["Poss", "Raphael", ""], ["Verstraaten", "Merijn", ""], ["Penczek", "Frank", ""], ["Grelck", "Clemens", ""], ["Kirner", "Raimund", ""], ["Shafarenko", "Alex", ""]]}, {"id": "1306.3375", "submitter": "Raphael kena Poss", "authors": "Raphael 'kena' Poss", "title": "The essence of component-based design and coordination", "comments": "8 pages, 2 figures, 3 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Is there a characteristic of coordination languages that makes them\nqualitatively different from general programming languages and deserves special\nacademic attention? This report proposes a nuanced answer in three parts. The\nfirst part highlights that coordination languages are the means by which\ncomposite software applications can be specified using components that are only\navailable separately, or later in time, via standard interfacing mechanisms.\nThe second part highlights that most currently used languages provide\nmechanisms to use externally provided components, and thus exhibit some\nelements of coordination. However not all do, and the availability of an\nexternal interface thus forms an objective and qualitative criterion that\ndistinguishes coordination. The third part argues that despite the qualitative\ndifference, the segregation of academic attention away from general language\ndesign and implementation has non-obvious cost trade-offs.\n", "versions": [{"version": "v1", "created": "Fri, 14 Jun 2013 12:15:31 GMT"}], "update_date": "2013-06-17", "authors_parsed": [["Poss", "Raphael 'kena'", ""]]}, {"id": "1306.3833", "submitter": "Hyvernat Pierre", "authors": "Hyvernat Pierre (Universit\\'e de Savoie)", "title": "The Size-Change Termination Principle for Constructor Based Languages", "comments": "24 pages + appendix", "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 1 (February\n  13, 2014) lmcs:1003", "doi": "10.2168/LMCS-10(1:11)2014", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes an automatic termination checker for a generic\nfirst-order call-by-value language in ML style. We use the fact that value are\nbuilt from variants and tuples to keep some information about how arguments of\nrecursive call evolve during evaluation. The result is a criterion for\ntermination extending the size-change termination principle of Lee, Jones and\nBen-Amram that can detect size changes inside subvalues of arguments. Moreover\nthe corresponding algorithm is easy to implement, making it a good candidate\nfor experimentation.\n", "versions": [{"version": "v1", "created": "Mon, 17 Jun 2013 12:31:00 GMT"}, {"version": "v2", "created": "Fri, 20 Dec 2013 19:43:34 GMT"}, {"version": "v3", "created": "Thu, 2 Jan 2014 19:22:46 GMT"}, {"version": "v4", "created": "Thu, 9 Jan 2014 16:22:37 GMT"}, {"version": "v5", "created": "Wed, 12 Feb 2014 10:02:31 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Pierre", "Hyvernat", "", "Universit\u00e9 de Savoie"]]}, {"id": "1306.4473", "submitter": "Nuno Macedo", "authors": "Hugo Pacheco, Nuno Macedo, Alcino Cunha, Janis Voigtl\\\"ander", "title": "A Generic Scheme and Properties of Bidirectional Transformations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The recent rise of interest in bidirectional transformations (BXs) has led to\nthe development of many BX frameworks, originating in diverse computer science\ndisciplines. From a user perspective, these frameworks vary significantly in\nboth interface and predictability of the underlying bidirectionalization\ntechnique. In this paper we start by presenting a generic BX scheme that can be\ninstantiated to different concrete interfaces, by plugging-in the desired\nnotion of update and traceability. Based on that scheme, we then present\nseveral desirable generic properties that may characterize a BX framework, and\nshow how they can be instantiated to concrete interfaces. This generic\npresentation is useful when exploring the BX design space: it might help\ndevelopers when designing new frameworks and end-users when comparing existing\nones. We support the latter claim, by applying it in a comparative survey of\npopular existing BX frameworks.\n", "versions": [{"version": "v1", "created": "Wed, 19 Jun 2013 10:03:01 GMT"}, {"version": "v2", "created": "Wed, 26 Jun 2013 10:30:42 GMT"}], "update_date": "2013-06-27", "authors_parsed": [["Pacheco", "Hugo", ""], ["Macedo", "Nuno", ""], ["Cunha", "Alcino", ""], ["Voigtl\u00e4nder", "Janis", ""]]}, {"id": "1306.4713", "submitter": "EPTCS", "authors": "Sam Tobin-Hochstadt (Northeastern University), David Van Horn\n  (Northeastern University)", "title": "From Principles to Practice with Class in the First Year", "comments": "In Proceedings TFPIE 2013, arXiv:1312.2216", "journal-ref": "EPTCS 136, 2013, pp. 1-15", "doi": "10.4204/EPTCS.136.1", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a bridge between functional and object-oriented programming in the\nfirst-year curriculum. Traditionally, curricula that begin with functional\nprogramming transition to a professional, usually object-oriented, language in\nthe second course. This transition poses obstacles for students, and often\nresults in confusing the details of development environments, syntax, and\nlibraries with the fundamentals of OO programming that the course should focus\non. Instead, we propose to begin the second course with a sequence of custom\nteaching languages which minimize the transition from the first course, and\nallow students to focus on core ideas. After working through the sequence of\npedagogical languages, we then transition to Java, at which point students have\na strong command of the basic principles. We have 3 years of experience with\nthis course, with notable success.\n", "versions": [{"version": "v1", "created": "Wed, 19 Jun 2013 22:33:39 GMT"}, {"version": "v2", "created": "Tue, 10 Dec 2013 08:00:44 GMT"}], "update_date": "2013-12-11", "authors_parsed": [["Tobin-Hochstadt", "Sam", "", "Northeastern University"], ["Van Horn", "David", "", "Northeastern University"]]}, {"id": "1306.4898", "submitter": "Gabriel S. Hjort Blindell", "authors": "Gabriel S. Hjort Blindell", "title": "Survey on Instruction Selection: An Extensive and Modern Literature\n  Review", "comments": "Major changes: - Merged simulation chapter with macro expansion\n  chapter - Addressed misunderstandings of several approaches - Completely\n  rewrote many parts of the chapters; strengthened the discussion of many\n  approaches - Revised the drawing of all trees and graphs to put the root at\n  the top instead of at the bottom - Added appendix for listing the approaches\n  in a table See doc for more info", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Instruction selection is one of three optimisation problems involved in the\ncode generator backend of a compiler. The instruction selector is responsible\nof transforming an input program from its target-independent representation\ninto a target-specific form by making best use of the available machine\ninstructions. Hence instruction selection is a crucial part of efficient code\ngeneration.\n  Despite on-going research since the late 1960s, the last, comprehensive\nsurvey on the field was written more than 30 years ago. As new approaches and\ntechniques have appeared since its publication, this brings forth a need for a\nnew, up-to-date review of the current body of literature. This report addresses\nthat need by performing an extensive review and categorisation of existing\nresearch. The report therefore supersedes and extends the previous surveys, and\nalso attempts to identify where future research should be directed.\n", "versions": [{"version": "v1", "created": "Thu, 20 Jun 2013 14:49:35 GMT"}, {"version": "v2", "created": "Mon, 7 Oct 2013 12:05:02 GMT"}], "update_date": "2013-10-08", "authors_parsed": [["Blindell", "Gabriel S. Hjort", ""]]}, {"id": "1306.5061", "submitter": "Robert Jakob", "authors": "Robert Jakob and Peter Thiemann", "title": "Towards Tree Automata-based Success Types", "comments": "Abstract presented at HOPA 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Error detection facilities for dynamic languages are often based on unit\ntesting. Thus, the advantage of rapid prototyping and flexibility must be\nweighed against cumbersome and time consuming test suite development. Lindahl\nand Sagonas' success typings provide a means of static must-fail detection in\nErlang. Due to the constraint-based nature of the approach, some errors\ninvolving nested tuples and recursion cannot be detected.\n  We propose an approach that uses an extension of model checking for\npattern-matching recursion schemes with context-aware ranked tree automata to\nprovide improved success typings for a constructor-based first-order prototype\nlanguage.\n", "versions": [{"version": "v1", "created": "Fri, 21 Jun 2013 06:53:04 GMT"}], "update_date": "2013-06-24", "authors_parsed": [["Jakob", "Robert", ""], ["Thiemann", "Peter", ""]]}, {"id": "1306.5142", "submitter": "Daniel Langr", "authors": "Daniel Langr, Pavel Tvrd\\'ik, Tom\\'a\\v{s} Dytrych, Jerry P. Draayer", "title": "Fake Run-Time Selection of Template Arguments in C++", "comments": "Objects, Models, Components, Patterns (50th International Conference,\n  TOOLS 2012)", "journal-ref": "Lecture Notes in Computer Science, pages 140-154, volume 7304.\n  2012", "doi": "10.1007/978-3-642-30561-0_11", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  C++ does not support run-time resolution of template type arguments. To\ncircumvent this restriction, we can instantiate a template for all possible\ncombinations of type arguments at compile time and then select the proper\ninstance at run time by evaluation of some provided conditions. However, for\ntemplates with multiple type parameters such a solution may easily result in a\nbranching code bloat. We present a template metaprogramming algorithm called\nfor_id that allows the user to select the proper template instance at run time\nwith theoretical minimum sustained complexity of the branching code.\n", "versions": [{"version": "v1", "created": "Fri, 21 Jun 2013 14:01:43 GMT"}], "update_date": "2013-06-24", "authors_parsed": [["Langr", "Daniel", ""], ["Tvrd\u00edk", "Pavel", ""], ["Dytrych", "Tom\u00e1\u0161", ""], ["Draayer", "Jerry P.", ""]]}, {"id": "1306.5930", "submitter": "Jos\\'e Guimar\\~aes", "authors": "Jos\\'e de Oliveira Guimar\\~aes", "title": "The Green Language", "comments": "220 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Green is a statically-typed object-oriented language that separates subtyping\nfrom inheritance. It supports garbage collection, classes as first-class\nobjects, parameterized classes, introspective reflection and a kind of run-time\nmetaobjects called shells.\n", "versions": [{"version": "v1", "created": "Tue, 25 Jun 2013 11:54:48 GMT"}], "update_date": "2013-06-26", "authors_parsed": [["Guimar\u00e3es", "Jos\u00e9 de Oliveira", ""]]}, {"id": "1306.6029", "submitter": "Alex Shafarenko", "authors": "Alex Shafarenko", "title": "AstraKahn: A Coordination Language for Streaming Networks", "comments": "34 pages. Constraints (2020)", "journal-ref": "In: Constraints. 25, p. 21-159 5 Aug 2020", "doi": "10.1007/s10601-020-09309-y", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is a preliminary version of the language report. It contains key\ndefinitions, specifications and some examples, but lacks completeness. The full\ndocument will include Chapter 3 (Data and Instrumentation Layer) and will\ncomprise an appendix giving the complete syntax and some whole program\nexamples. The purpose of the present document is to fix the concepts and major\nfeatures of the language and to enable the production of the definition\ndocument that is required for implementation.\n", "versions": [{"version": "v1", "created": "Tue, 25 Jun 2013 16:49:16 GMT"}, {"version": "v2", "created": "Mon, 1 Jul 2013 23:13:51 GMT"}, {"version": "v3", "created": "Sat, 2 Nov 2013 18:31:03 GMT"}, {"version": "v4", "created": "Sun, 22 Jun 2014 20:43:48 GMT"}], "update_date": "2021-07-21", "authors_parsed": [["Shafarenko", "Alex", ""]]}, {"id": "1306.6032", "submitter": "Jana Dunfield", "authors": "Jana Dunfield and Neelakantan R. Krishnaswami", "title": "Complete and Easy Bidirectional Typechecking for Higher-Rank\n  Polymorphism", "comments": "13 pages + 78-page appendix, to appear in International Conference on\n  Functional Programming (ICFP) 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bidirectional typechecking, in which terms either synthesize a type or are\nchecked against a known type, has become popular for its scalability (unlike\nDamas-Milner type inference, bidirectional typing remains decidable even for\nvery expressive type systems), its error reporting, and its relative ease of\nimplementation. Following design principles from proof theory, bidirectional\ntyping can be applied to many type constructs. The principles underlying a\nbidirectional approach to polymorphism, however, are less obvious. We give a\ndeclarative, bidirectional account of higher-rank polymorphism, grounded in\nproof theory; this calculus enjoys many properties such as eta-reduction and\npredictability of annotations. We give an algorithm for implementing the\ndeclarative system; our algorithm is remarkably simple and well-behaved,\ndespite being both sound and complete.\n", "versions": [{"version": "v1", "created": "Tue, 25 Jun 2013 16:52:51 GMT"}, {"version": "v2", "created": "Sat, 22 Aug 2020 17:08:33 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Dunfield", "Jana", ""], ["Krishnaswami", "Neelakantan R.", ""]]}, {"id": "1306.6047", "submitter": "Alex Rubinsteyn", "authors": "Russell Power and Alex Rubinsteyn", "title": "How fast can we make interpreted Python?", "comments": "Tech Report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Python is a popular dynamic language with a large part of its appeal coming\nfrom powerful libraries and extension modules. These augment the language and\nmake it a productive environment for a wide variety of tasks, ranging from web\ndevelopment (Django) to numerical analysis (NumPy). Unfortunately, Python's\nperformance is quite poor when compared to modern implementations of languages\nsuch as Lua and JavaScript.\n  Why does Python lag so far behind these other languages? As we show, the very\nsame API and extension libraries that make Python a powerful language also make\nit very difficult to efficiently execute. Given that we want to retain access\nto the great extension libraries that already exist for Python, how fast can we\nmake it?\n  To evaluate this, we designed and implemented Falcon, a high-performance\nbytecode interpreter fully compatible with the standard CPython interpreter.\nFalcon applies a number of well known optimizations and introduces several new\ntechniques to speed up execution of Python bytecode. In our evaluation, we\nfound Falcon an average of 25% faster than the standard Python interpreter on\nmost benchmarks and in some cases about 2.5X faster.\n", "versions": [{"version": "v1", "created": "Tue, 25 Jun 2013 17:57:00 GMT"}, {"version": "v2", "created": "Tue, 13 Aug 2013 20:29:34 GMT"}], "update_date": "2013-08-15", "authors_parsed": [["Power", "Russell", ""], ["Rubinsteyn", "Alex", ""]]}, {"id": "1306.6316", "submitter": "Andrej Bauer", "authors": "Andrej Bauer (University of Ljubljana), Matija Pretnar (University of\n  Ljubljana)", "title": "An Effect System for Algebraic Effects and Handlers", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 4 (December\n  10, 2014) lmcs:1153", "doi": "10.2168/LMCS-10(4:9)2014", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an effect system for core Eff, a simplified variant of Eff, which\nis an ML-style programming language with first-class algebraic effects and\nhandlers. We define an expressive effect system and prove safety of operational\nsemantics with respect to it. Then we give a domain-theoretic denotational\nsemantics of core Eff, using Pitts's theory of minimal invariant relations, and\nprove it adequate. We use this fact to develop tools for finding useful\ncontextual equivalences, including an induction principle. To demonstrate their\nusefulness, we use these tools to derive the usual equations for mutable state,\nincluding a general commutativity law for computations using non-interfering\nreferences. We have formalized the effect system, the operational semantics,\nand the safety theorem in Twelf.\n", "versions": [{"version": "v1", "created": "Wed, 26 Jun 2013 19:04:17 GMT"}, {"version": "v2", "created": "Thu, 16 Oct 2014 19:14:46 GMT"}, {"version": "v3", "created": "Tue, 9 Dec 2014 10:09:44 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Bauer", "Andrej", "", "University of Ljubljana"], ["Pretnar", "Matija", "", "University of\n  Ljubljana"]]}, {"id": "1306.6526", "submitter": "Damiano Zanardini", "authors": "Damiano Zanardini and Samir Genaim", "title": "Inference of Field-Sensitive Reachability and Cyclicity", "comments": "38 pages + appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In heap-based languages, knowing that a variable x points to an acyclic data\nstructure is useful for analyzing termination: this information guarantees that\nthe depth of the data structure to which x points is greater than the depth of\nthe structure pointed to by x.fld, and allows bounding the number of iterations\nof a loop which traverses the data structure on fld. In general, proving\ntermination needs acyclicity, unless program-specific or non-automated\nreasoning is performed. However, recent work could prove that certain loops\nterminate even without inferring acyclicity, because they traverse data\nstructures \"acyclically\". Consider a double-linked list: if it is possible to\ndemonstrate that every cycle involves both the \"next\" and the \"prev\" field,\nthen a traversal on \"next\" terminates since no cycle will be traversed\ncompletely. This paper develops a static analysis inferring field-sensitive\nreachability and cyclicity information, which is more general than existing\napproaches. Propositional formulae are computed, which describe which fields\nmay or may not be traversed by paths in the heap. Consider a tree with edges\n\"left\" and \"right\" to the left and right sub-trees, and \"parent\" to the parent\nnode: termination of a loop traversing leaf-up cannot be guaranteed by\nstate-of-the-art analyses. Instead, propositional formulae computed by this\nanalysis indicate that cycles must traverse \"parent\" and at least one between\n\"left\" and \"right\": termination is guaranteed as no cycle is traversed\ncompletely. This paper defines the necessary abstract domains and builds an\nabstract semantics on them. A prototypical implementation provides the expected\nresult on relevant examples.\n", "versions": [{"version": "v1", "created": "Thu, 27 Jun 2013 14:48:27 GMT"}, {"version": "v2", "created": "Mon, 8 Jul 2013 14:32:27 GMT"}, {"version": "v3", "created": "Wed, 5 Mar 2014 15:29:26 GMT"}, {"version": "v4", "created": "Mon, 19 May 2014 10:26:26 GMT"}], "update_date": "2014-05-20", "authors_parsed": [["Zanardini", "Damiano", ""], ["Genaim", "Samir", ""]]}, {"id": "1306.6856", "submitter": "Marco Gaboardi", "authors": "Marco Gaboardi", "title": "Linear Dependent Types for Domain Specific Program Analysis (Extended\n  Abstract)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this tutorial I will present how a combination of linear and dependent\ntype can be useful to describe different properties about higher order\nprograms. Linear types have been proved particularly useful to express\nproperties of functions; dependent types are useful to describe the behavior of\nthe program in terms of its control flow. This two ideas fits together well\nwhen one is interested in analyze properties of functions depending on the\ncontrol flow of the program. I will present these ideas with example taken by\ncomplexity analysis and sensitivity analysis. I will conclude the tutorial by\narguing about the generality of this approach.\n", "versions": [{"version": "v1", "created": "Fri, 28 Jun 2013 14:38:13 GMT"}], "update_date": "2013-07-01", "authors_parsed": [["Gaboardi", "Marco", ""]]}]