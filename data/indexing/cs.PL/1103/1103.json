[{"id": "1103.0510", "submitter": "Derek Dreyer", "authors": "Derek Dreyer (MPI-SWS), Amal Ahmed (Indiana University), Lars Birkedal\n  (IT University of Copenhagen)", "title": "Logical Step-Indexed Logical Relations", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 2 (June 7,\n  2011) lmcs:698", "doi": "10.2168/LMCS-7(2:16)2011", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Appel and McAllester's \"step-indexed\" logical relations have proven to be a\nsimple and effective technique for reasoning about programs in languages with\nsemantically interesting types, such as general recursive types and general\nreference types. However, proofs using step-indexed models typically involve\ntedious, error-prone, and proof-obscuring step-index arithmetic, so it is\nimportant to develop clean, high-level, equational proof principles that avoid\nmention of step indices. In this paper, we show how to reason about binary\nstep-indexed logical relations in an abstract and elegant way. Specifically, we\ndefine a logic LSLR, which is inspired by Plotkin and Abadi's logic for\nparametricity, but also supports recursively defined relations by means of the\nmodal \"later\" operator from Appel, Melli\\`es, Richards, and Vouillon's \"very\nmodal model\" paper. We encode in LSLR a logical relation for reasoning\nrelationally about programs in call-by-value System F extended with general\nrecursive types. Using this logical relation, we derive a set of useful rules\nwith which we can prove contextual equivalence and approximation results\nwithout counting steps.\n", "versions": [{"version": "v1", "created": "Wed, 2 Mar 2011 18:21:59 GMT"}, {"version": "v2", "created": "Mon, 6 Jun 2011 05:34:04 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Dreyer", "Derek", "", "MPI-SWS"], ["Ahmed", "Amal", "", "Indiana University"], ["Birkedal", "Lars", "", "IT University of Copenhagen"]]}, {"id": "1103.0812", "submitter": "Neng-Fa Zhou", "authors": "Neng-Fa Zhou", "title": "The Language Features and Architecture of B-Prolog", "comments": "30 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  B-Prolog is a high-performance implementation of the standard Prolog language\nwith several extensions including matching clauses, action rules for event\nhandling, finite-domain constraint solving, arrays and hash tables, declarative\nloop constructs, and tabling. The B-Prolog system is based on the TOAM\narchitecture which differs from the WAM mainly in that (1) arguments are passed\nold-fashionedly through the stack, (2) only one frame is used for each\npredicate call, and (3) instructions are provided for encoding matching trees.\nThe most recent architecture, called TOAM Jr., departs further from the WAM in\nthat it employs no registers for arguments or temporary variables, and provides\nvariable-size instructions for encoding predicate calls. This paper gives an\noverview of the language features and a detailed description of the TOAM Jr.\narchitecture, including architectural support for action rules and tabling.\n", "versions": [{"version": "v1", "created": "Fri, 4 Mar 2011 02:14:29 GMT"}], "update_date": "2011-03-07", "authors_parsed": [["Zhou", "Neng-Fa", ""]]}, {"id": "1103.1362", "submitter": "David Van Horn", "authors": "Sam Tobin-Hochstadt and David Van Horn", "title": "Higher-Order Symbolic Execution via Contracts", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new approach to automated reasoning about higher-order programs\nby extending symbolic execution to use behavioral contracts as symbolic values,\nenabling symbolic approximation of higher-order behavior.\n  Our approach is based on the idea of an abstract reduction semantics that\ngives an operational semantics to programs with both concrete and symbolic\ncomponents. Symbolic components are approximated by their contract and our\nsemantics gives an operational interpretation of contracts-as-values. The\nresult is a executable semantics that soundly predicts program behavior,\nincluding contract failures, for all possible instantiations of symbolic\ncomponents. We show that our approach scales to an expressive language of\ncontracts including arbitrary programs embedded as predicates, dependent\nfunction contracts, and recursive contracts. Supporting this feature-rich\nlanguage of specifications leads to powerful symbolic reasoning using existing\nprogram assertions.\n  We then apply our approach to produce a verifier for contract correctness of\ncomponents, including a sound and computable approximation to our semantics\nthat facilitates fully automated contract verification. Our implementation is\ncapable of verifying contracts expressed in existing programs, and of\njustifying valuable contract-elimination optimizations.\n", "versions": [{"version": "v1", "created": "Mon, 7 Mar 2011 20:06:23 GMT"}, {"version": "v2", "created": "Wed, 16 Mar 2011 15:26:52 GMT"}, {"version": "v3", "created": "Wed, 13 Jul 2011 23:04:06 GMT"}, {"version": "v4", "created": "Thu, 26 Apr 2012 13:23:05 GMT"}], "update_date": "2012-04-27", "authors_parsed": [["Tobin-Hochstadt", "Sam", ""], ["Van Horn", "David", ""]]}, {"id": "1103.2027", "submitter": "Jorge A Navas", "authors": "Joxan Jaffar and Jorge A. Navas and Andrew E. Santosa", "title": "Symbolic Execution for Verification", "comments": "15 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In previous work, we presented a symbolic execution method which starts with\na concrete model of the program but progressively abstracts away details only\nwhen these are known to be irrelevant using interpolation. In this paper, we\nextend the technique to handle unbounded loops. The central idea is to\nprogressively discover the strongest invariants through a process of loop\nunrolling. The key feature of this technique, called the minimax algorithm, is\nintelligent backtracking which directs the search for the next invariant. We\nthen present an analysis of the main differences between our symbolic execution\nmethod and mainstream techniques mainly based on abstract refinement (CEGAR).\nFinally, we evaluate our technique against available state-of-the-art systems.\n", "versions": [{"version": "v1", "created": "Thu, 10 Mar 2011 13:12:34 GMT"}], "update_date": "2011-03-11", "authors_parsed": [["Jaffar", "Joxan", ""], ["Navas", "Jorge A.", ""], ["Santosa", "Andrew E.", ""]]}, {"id": "1103.2348", "submitter": "Lin Zhong", "authors": "Felix Xiaozhu Lin, Zhen Wang, Robert LiKamWa, and Lin Zhong", "title": "Transparent Programming of Heterogeneous Smartphones for Sensing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Sensing on smartphones is known to be power-hungry. It has been shown that\nthis problem can be solved by adding an ultra low-power processor to execute\nsimple, frequent sensor data processing. While very effective in saving energy,\nthis resulting heterogeneous, distributed architecture poses a significant\nchallenge to application development.\n  We present Reflex, a suite of runtime and compilation techniques to conceal\nthe heterogeneous, distributed nature from developers. The Reflex automatically\ntransforms the developer's code for distributed execution with the help of the\nReflex runtime. To create a unified system illusion, Reflex features a novel\nsoftware distributed shared memory (DSM) design that leverages the extreme\narchitectural asymmetry between the low-power processor and the powerful\ncentral processor to achieve both energy efficiency and performance.\n  We report a complete realization of Reflex for heterogeneous smartphones with\nMaemo/Linux as the central kernel. Using a tri-processor hardware prototype and\nsensing applications reported in recent literature, we evaluate the Reflex\nrealization for programming transparency, energy efficiency, and performance.\nWe show that Reflex supports a programming style that is very close to\ncontemporary smartphone programming. It allows existing sensing applications to\nbe ported with minor source code changes. Reflex reduces the system power in\nsensing by up to 83%, and its runtime system only consumes 10% local memory on\na typical ultra-low power processor.\n", "versions": [{"version": "v1", "created": "Fri, 11 Mar 2011 19:12:15 GMT"}], "update_date": "2011-03-14", "authors_parsed": [["Lin", "Felix Xiaozhu", ""], ["Wang", "Zhen", ""], ["LiKamWa", "Robert", ""], ["Zhong", "Lin", ""]]}, {"id": "1103.2841", "submitter": "Russell O'Connor", "authors": "Russell O'Connor", "title": "Functor is to Lens as Applicative is to Biplate: Introducing Multiplate", "comments": "To appear in ACM SIGPLAN 7th Workshop on Generic Programming, Tokyo,\n  18th September 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/publicdomain/", "abstract": "  This paper gives two new categorical characterisations of lenses: one as a\ncoalgebra of the store comonad, and the other as a monoidal natural\ntransformation on a category of a certain class of coalgebras. The store\ncomonad of the first characterisation can be generalized to a Cartesian store\ncomonad, and the coalgebras of this Cartesian store comonad turn out to be\nexactly the Biplates of the Uniplate generic programming library. On the other\nhand, the monoidal natural transformations on functors can be generalized to\nwork on a category of more specific coalgebras. This generalization turns out\nto be the type of compos from the Compos generic programming library. A\ntheorem, originally conjectured by van Laarhoven, proves that these two\ngeneralizations are isomorphic, thus the core data types of the Uniplate and\nCompos libraries supporting generic program on single recursive types are the\nsame. Both the Uniplate and Compos libraries generalize this core functionality\nto support mutually recursive types in different ways. This paper proposes a\nthird extension to support mutually recursive data types that is as powerful as\nCompos and as easy to use as Uniplate. This proposal, called Multiplate, only\nrequires rank 3 polymorphism in addition to the normal type class mechanism of\nHaskell.\n", "versions": [{"version": "v1", "created": "Tue, 15 Mar 2011 04:03:54 GMT"}, {"version": "v2", "created": "Mon, 11 Jul 2011 15:49:43 GMT"}], "update_date": "2011-07-12", "authors_parsed": [["O'Connor", "Russell", ""]]}, {"id": "1103.3111", "submitter": "EPTCS", "authors": "Tom Hirschowitz", "title": "Proceedings Types for Proofs and Programs, Revised Selected Papers", "comments": null, "journal-ref": "EPTCS 53, 2011", "doi": "10.4204/EPTCS.53", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Types for Proofs and Programs is the annual meeting of the Types Project,\nwhose aim is to develop the technology of formal reasoning and computer\nprogramming based on Type Theory. This is done by improving the languages and\ncomputerised tools for reasoning, and by applying the technology in several\ndomains such as analysis of programming languages, certified software,\nformalisation of mathematics and mathematics education.\n  The 2009 meeting took place in Aussois, France, and we thank the invited\nspeakers Richard Garner, Peter Hancock, Pawe{\\l} Urzyczyn for excellent talks.\nThe present volume consists of papers not necessarily presented at the\nworkshop, selected by Thorsten Altenkirch, Tom Hirschowitz, Christophe\nRaffalli, and Alan Schmitt, with help from Matthieu Sozeau and Makarius Wenzel.\n", "versions": [{"version": "v1", "created": "Wed, 16 Mar 2011 06:38:32 GMT"}], "update_date": "2011-03-17", "authors_parsed": [["Hirschowitz", "Tom", ""]]}, {"id": "1103.4133", "submitter": "Michael Hanus", "authors": "Michael Hanus and Sven Koschnicke", "title": "An ER-based Framework for Declarative Web Programming", "comments": "To appear in Theory and Practice of Logic Programming (TPLP)", "journal-ref": "Theory and Practice of Logic Programming 14 (2014) 269-291", "doi": "10.1017/S1471068412000385", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a framework to support the implementation of web-based systems\nintended to manipulate data stored in relational databases. Since the\nconceptual model of a relational database is often specified as an\nentity-relationship (ER) model, we propose to use the ER model to generate a\ncomplete implementation in the declarative programming language Curry. This\nimplementation contains operations to create and manipulate entities of the\ndata model, supports authentication, authorization, session handling, and the\ncomposition of individual operations to user processes. Furthermore, the\nimplementation ensures the consistency of the database w.r.t. the data\ndependencies specified in the ER model, i.e., updates initiated by the user\ncannot lead to an inconsistent state of the database. In order to generate a\nhigh-level declarative implementation that can be easily adapted to individual\ncustomer requirements, the framework exploits previous works on declarative\ndatabase programming and web user interface construction in Curry.\n", "versions": [{"version": "v1", "created": "Mon, 21 Mar 2011 20:01:02 GMT"}, {"version": "v2", "created": "Mon, 17 Sep 2012 11:46:56 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Hanus", "Michael", ""], ["Koschnicke", "Sven", ""]]}, {"id": "1103.5055", "submitter": "Ravi Chugh", "authors": "Ravi Chugh and Patrick M. Rondon and Ranjit Jhala", "title": "Nested Refinements for Dynamic Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Programs written in dynamic languages make heavy use of features --- run-time\ntype tests, value-indexed dictionaries, polymorphism, and higher-order\nfunctions --- that are beyond the reach of type systems that employ either\npurely syntactic or purely semantic reasoning. We present a core calculus,\nSystem D, that merges these two modes of reasoning into a single powerful\nmechanism of nested refinement types wherein the typing relation is itself a\npredicate in the refinement logic. System D coordinates SMT-based logical\nimplication and syntactic subtyping to automatically typecheck sophisticated\ndynamic language programs. By coupling nested refinements with McCarthy's\ntheory of finite maps, System D can precisely reason about the interaction of\nhigher-order functions, polymorphism, and dictionaries. The addition of type\npredicates to the refinement logic creates a circularity that leads to unique\ntechnical challenges in the metatheory, which we solve with a novel\nstratification approach that we use to prove the soundness of System D.\n", "versions": [{"version": "v1", "created": "Fri, 25 Mar 2011 18:19:55 GMT"}, {"version": "v2", "created": "Thu, 15 Sep 2011 06:38:17 GMT"}], "update_date": "2011-09-16", "authors_parsed": [["Chugh", "Ravi", ""], ["Rondon", "Patrick M.", ""], ["Jhala", "Ranjit", ""]]}, {"id": "1103.5167", "submitter": "David Van Horn", "authors": "Matthew Might and David Van Horn", "title": "A family of abstract interpretations for static analysis of concurrent\n  higher-order programs", "comments": "The 18th International Static Analysis Symposium (SAS 2011)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a framework for computing two foundational analyses for concurrent\nhigher-order programs: (control-)flow analysis (CFA) and may-happen-in-parallel\nanalysis (MHP). We pay special attention to the unique challenges posed by the\nunrestricted mixture of first-class continuations and dynamically spawned\nthreads. To set the stage, we formulate a concrete model of concurrent\nhigher-order programs: the P(CEK*)S machine. We find that the systematic\nabstract interpretation of this machine is capable of computing both flow and\nMHP analyses. Yet, a closer examination finds that the precision for MHP is\npoor. As a remedy, we adapt a shape analytic technique-singleton abstraction-to\ndynamically spawned threads (as opposed to objects in the heap). We then show\nthat if MHP analysis is not of interest, we can substantially accelerate the\ncomputation of flow analysis alone by collapsing thread interleavings with a\nsecond layer of abstraction.\n", "versions": [{"version": "v1", "created": "Sat, 26 Mar 2011 21:39:58 GMT"}, {"version": "v2", "created": "Tue, 14 Jun 2011 05:37:39 GMT"}], "update_date": "2011-06-15", "authors_parsed": [["Might", "Matthew", ""], ["Van Horn", "David", ""]]}, {"id": "1103.5901", "submitter": "David Lorenz", "authors": "David H. Lorenz and Boaz Rosenan", "title": "A Comparative Case Study of Code Reuse With Language Oriented\n  Programming", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There is a gap between our ability to reuse high-level concepts in software\ndesign and our ability to reuse the code implementing them. Language Oriented\nProgramming (LOP) is a software development paradigm that aims to close this\ngap, through extensive use of Domain Specific Languages (DSLs). With LOP, the\nhigh-level reusable concepts become reusable DSL constructs, and their\ntranslation into code level concepts is done in the DSL implementation.\nParticular products are implemented using DSL code, thus reusing only\nhigh-level concepts. In this paper we provide a comparison between two\nimplementation approaches for LOP: (a) using external DSLs with a projectional\nlanguage workbench (MPS); and (b) using internal DSLs with an LOP language\n(Cedalion). To demonstrate how reuse is achieved in each approach, we present a\nsmall case study, where LOP is used to build a Software Product Line (SPL) of\ncalculator software.\n", "versions": [{"version": "v1", "created": "Wed, 30 Mar 2011 12:12:00 GMT"}], "update_date": "2011-03-31", "authors_parsed": [["Lorenz", "David H.", ""], ["Rosenan", "Boaz", ""]]}]