[{"id": "1410.0198", "submitter": "Eva Darulova", "authors": "Eva Darulova, Viktor Kuncak", "title": "Towards a Compiler for Reals", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Numerical software, common in scientific computing or embedded systems,\ninevitably uses an approximation of the real arithmetic in which most\nalgorithms are designed. In many domains, roundoff errors are not the only\nsource of inaccuracy and measurement and other input errors further increase\nthe uncertainty of the computed results. Adequate tools are needed to help\nusers select suitable approximations, especially for safety-critical\napplications.\n  We present the source-to-source compiler Rosa which takes as input a\nreal-valued program with error specifications and synthesizes code over an\nappropriate floating-point or fixed-point data type. The main challenge of such\na compiler is a fully automated, sound and yet accurate enough numerical error\nestimation. We present a unified technique for floating-point and fixed-point\narithmetic of various precisions which can handle nonlinear arithmetic,\ndetermine closed- form symbolic invariants for unbounded loops and quantify the\neffects of discontinuities on numerical errors. We evaluate Rosa on a number of\nbenchmarks from scientific computing and embedded systems and, comparing it to\nstate-of-the-art in automated error estimation, show it presents an interesting\ntrade-off between accuracy and performance.\n", "versions": [{"version": "v1", "created": "Wed, 1 Oct 2014 12:17:40 GMT"}, {"version": "v2", "created": "Thu, 7 May 2015 07:42:45 GMT"}, {"version": "v3", "created": "Fri, 11 Mar 2016 13:43:19 GMT"}], "update_date": "2016-03-14", "authors_parsed": [["Darulova", "Eva", ""], ["Kuncak", "Viktor", ""]]}, {"id": "1410.2813", "submitter": "Michael Greenberg", "authors": "Michael Greenberg", "title": "Space-Efficient Manifest Contracts", "comments": "This is an extended version of a POPL'15 paper, with a great deal of\n  material that does not appear in the conference paper: an exploration of the\n  design space with two other space-efficient calculi and complete proofs", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The standard algorithm for higher-order contract checking can lead to\nunbounded space consumption and can destroy tail recursion, altering a\nprogram's asymptotic space complexity. While space efficiency for gradual\ntypes---contracts mediating untyped and typed code---is well studied, sound\nspace efficiency for manifest contracts---contracts that check stronger\nproperties than simple types, e.g., \"is a natural\" instead of \"is an\ninteger\"---remains an open problem.\n  We show how to achieve sound space efficiency for manifest contracts with\nstrong predicate contracts. The essential trick is breaking the contract\nchecking down into coercions: structured, blame-annotated lists of checks. By\ncarefully preventing duplicate coercions from appearing, we can restore space\nefficiency while keeping the same observable behavior.\n  Along the way, we define a framework for space efficiency, traversing the\ndesign space with three different space-efficient manifest calculi. We examine\nthe diverse correctness criteria for contract semantics; we conclude with a\ncoercion-based language whose contracts enjoy (galactically) bounded, sound\nspace consumption---they are observationally equivalent to the standard,\nspace-inefficient semantics.\n", "versions": [{"version": "v1", "created": "Fri, 10 Oct 2014 15:43:34 GMT"}, {"version": "v2", "created": "Tue, 4 Apr 2017 17:38:56 GMT"}], "update_date": "2017-04-05", "authors_parsed": [["Greenberg", "Michael", ""]]}, {"id": "1410.2901", "submitter": "Thomas Genet", "authors": "Thomas Genet", "title": "Towards Static Analysis of Functional Programs using Tree Automata\n  Completion", "comments": "Proceedings of WRLA'14. 2014", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents the first step of a wider research effort to apply tree\nautomata completion to the static analysis of functional programs. Tree\nAutomata Completion is a family of techniques for computing or approximating\nthe set of terms reachable by a rewriting relation. The completion algorithm we\nfocus on is parameterized by a set E of equations controlling the precision of\nthe approximation and influencing its termination. For completion to be used as\na static analysis, the first step is to guarantee its termination. In this\nwork, we thus give a sufficient condition on E and T(F) for completion\nalgorithm to always terminate. In the particular setting of functional\nprograms, this condition can be relaxed into a condition on E and T(C) (terms\nbuilt on the set of constructors) that is closer to what is done in the field\nof static analysis, where abstractions are performed on data.\n", "versions": [{"version": "v1", "created": "Tue, 7 Oct 2014 15:11:02 GMT"}], "update_date": "2014-10-14", "authors_parsed": [["Genet", "Thomas", ""]]}, {"id": "1410.3125", "submitter": "Martin Mladenov", "authors": "Kristian Kersting, Martin Mladenov, Pavel Tokmakov", "title": "Relational Linear Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.PL math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose relational linear programming, a simple framework for combing\nlinear programs (LPs) and logic programs. A relational linear program (RLP) is\na declarative LP template defining the objective and the constraints through\nthe logical concepts of objects, relations, and quantified variables. This\nallows one to express the LP objective and constraints relationally for a\nvarying number of individuals and relations among them without enumerating\nthem. Together with a logical knowledge base, effectively a logical program\nconsisting of logical facts and rules, it induces a ground LP. This ground LP\nis solved using lifted linear programming. That is, symmetries within the\nground LP are employed to reduce its dimensionality, if possible, and the\nreduced program is solved using any off-the-shelf LP solver. In contrast to\nmainstream LP template languages like AMPL, which features a mixture of\ndeclarative and imperative programming styles, RLP's relational nature allows a\nmore intuitive representation of optimization problems over relational domains.\nWe illustrate this empirically by experiments on approximate inference in\nMarkov logic networks using LP relaxations, on solving Markov decision\nprocesses, and on collective inference using LP support vector machines.\n", "versions": [{"version": "v1", "created": "Sun, 12 Oct 2014 18:06:07 GMT"}], "update_date": "2014-10-14", "authors_parsed": [["Kersting", "Kristian", ""], ["Mladenov", "Martin", ""], ["Tokmakov", "Pavel", ""]]}, {"id": "1410.3712", "submitter": "Fabrizio Montesi", "authors": "Fabrizio Montesi", "title": "Process-aware web programming with Jolie", "comments": "IMADA-preprint-cs", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.NI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We extend the Jolie programming language to capture the native modelling of\nprocess-aware web information systems, i.e., web information systems based upon\nthe execution of business processes. Our main contribution is to offer a\nunifying approach for the programming of distributed architectures on the web,\nwhich can capture web servers, stateful process execution, and the composition\nof services via mediation. We discuss applications of this approach through a\nseries of examples that cover, e.g., static content serving, multiparty\nsessions, and the evolution of web systems. Finally, we present a performance\nevaluation that includes a comparison of Jolie-based web systems to other\nframeworks and a measurement of its scalability.\n", "versions": [{"version": "v1", "created": "Tue, 14 Oct 2014 14:45:52 GMT"}, {"version": "v2", "created": "Wed, 15 Oct 2014 07:32:03 GMT"}, {"version": "v3", "created": "Thu, 21 Apr 2016 07:18:00 GMT"}], "update_date": "2016-04-22", "authors_parsed": [["Montesi", "Fabrizio", ""]]}, {"id": "1410.3735", "submitter": "Adam Petcher", "authors": "Adam Petcher and Greg Morrisett", "title": "The Foundational Cryptography Framework", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present the Foundational Cryptography Framework (FCF) for developing and\nchecking complete proofs of security for cryptographic schemes within a proof\nassistant. This is a general-purpose framework that is capable of modeling and\nreasoning about a wide range of cryptographic schemes, security definitions,\nand assumptions. Security is proven in the computational model, and the proof\nprovides concrete bounds as well as asymptotic conclusions. FCF provides a\nlanguage for probabilistic programs, a theory that is used to reason about\nprograms, and a library of tactics and definitions that are useful in proofs\nabout cryptography. The framework is designed to leverage fully the existing\ntheory and capabilities of the Coq proof assistant in order to reduce the\neffort required to develop proofs.\n", "versions": [{"version": "v1", "created": "Tue, 14 Oct 2014 15:34:39 GMT"}], "update_date": "2014-10-15", "authors_parsed": [["Petcher", "Adam", ""], ["Morrisett", "Greg", ""]]}, {"id": "1410.3772", "submitter": "Rishabh Jain", "authors": "Rishabh Jain and Sakshi Gupta", "title": "Optimizing the For loop: Comparison of For loop and micro For loop", "comments": "3 pages, 2 figures, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Looping is one of the fundamental logical instructions used for repeating a\nblock of code. It is used in programs across all programming languages.\nTraditionally, in languages like C, the for loop is used extensively for\nrepeated execution of a block of code, due to its ease for use and simplified\nrepresentation. This paper proposes a new way of representing the for loop to\nimprove its runtime efficiency and compares the experimental statistics with\nthe traditional for loop representation. It is found that for small number of\niterations, the difference in computational time may not be considerable. But\ngiven any large number of iterations, the difference is noticeable.\n", "versions": [{"version": "v1", "created": "Sun, 12 Oct 2014 15:16:55 GMT"}], "update_date": "2014-10-15", "authors_parsed": [["Jain", "Rishabh", ""], ["Gupta", "Sakshi", ""]]}, {"id": "1410.4011", "submitter": "EPTCS", "authors": "Amir M. Ben-Amram, Aviad Pineles", "title": "Flowchart Programs, Regular Expressions, and Decidability of Polynomial\n  Growth-Rate", "comments": "In Proceedings VPT 2016, arXiv:1607.01835", "journal-ref": "EPTCS 216, 2016, pp. 24-49", "doi": "10.4204/EPTCS.216.2", "report-no": null, "categories": "cs.PL cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new method for inferring complexity properties for a class of\nprograms in the form of flowcharts annotated with loop information.\nSpecifically, our method can (soundly and completely) decide if computed values\nare polynomially bounded as a function of the input; and similarly for the\nrunning time. Such complexity properties are undecidable for a Turing-complete\nprogramming language, and a common work-around in program analysis is to settle\nfor sound but incomplete solutions. In contrast, we consider a class of\nprograms that is Turing-incomplete, but strong enough to include several\nchallenges for this kind of analysis. For a related language that has\nwell-structured syntax, similar to Meyer and Ritchie's LOOP programs, the\nproblem has been previously proved to be decidable. The analysis relied on the\ncompositionality of programs, hence the challenge in obtaining similar results\nfor flowchart programs with arbitrary control-flow graphs. Our answer to the\nchallenge is twofold: first, we propose a class of loop-annotated flowcharts,\nwhich is more general than the class of flowcharts that directly represent\nstructured programs; secondly, we present a technique to reuse the ideas from\nthe work on tructured programs and apply them to such flowcharts. The technique\nis inspired by the classic translation of non-deterministic automata to regular\nexpressions, but we obviate the exponential cost of constructing such an\nexpression, obtaining a polynomial-time analysis. These ideas may well be\napplicable to other analysis problems.\n", "versions": [{"version": "v1", "created": "Wed, 15 Oct 2014 11:16:16 GMT"}, {"version": "v2", "created": "Sun, 13 Mar 2016 14:40:47 GMT"}, {"version": "v3", "created": "Sun, 20 Mar 2016 10:01:27 GMT"}, {"version": "v4", "created": "Wed, 1 Jun 2016 16:30:18 GMT"}, {"version": "v5", "created": "Fri, 8 Jul 2016 05:30:33 GMT"}], "update_date": "2016-07-11", "authors_parsed": [["Ben-Amram", "Amir M.", ""], ["Pineles", "Aviad", ""]]}, {"id": "1410.4345", "submitter": "Joel Akeret", "authors": "Joel Akeret, Lukas Gamper, Adam Amara, Alexandre Refregier (ETH\n  Zurich)", "title": "HOPE: A Python Just-In-Time compiler for astrophysical computations", "comments": "Accepted for publication in Astronomy and Computing. 14 pages, 1\n  figure. The code is available at http://hope.phys.ethz.ch", "journal-ref": null, "doi": null, "report-no": null, "categories": "astro-ph.IM cs.MS cs.PL physics.comp-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Python programming language is becoming increasingly popular for\nscientific applications due to its simplicity, versatility, and the broad range\nof its libraries. A drawback of this dynamic language, however, is its low\nruntime performance which limits its applicability for large simulations and\nfor the analysis of large data sets, as is common in astrophysics and\ncosmology. While various frameworks have been developed to address this\nlimitation, most focus on covering the complete language set, and either force\nthe user to alter the code or are not able to reach the full speed of an\noptimised native compiled language. In order to combine the ease of Python and\nthe speed of C++, we developed HOPE, a specialised Python just-in-time (JIT)\ncompiler designed for numerical astrophysical applications. HOPE focuses on a\nsubset of the language and is able to translate Python code into C++ while\nperforming numerical optimisation on mathematical expressions at runtime. To\nenable the JIT compilation, the user only needs to add a decorator to the\nfunction definition. We assess the performance of HOPE by performing a series\nof benchmarks and compare its execution speed with that of plain Python, C++\nand the other existing frameworks. We find that HOPE improves the performance\ncompared to plain Python by a factor of 2 to 120, achieves speeds comparable to\nthat of C++, and often exceeds the speed of the existing solutions. We discuss\nthe differences between HOPE and the other frameworks, as well as future\nextensions of its capabilities. The fully documented HOPE package is available\nat http://hope.phys.ethz.ch and is published under the GPLv3 license on PyPI\nand GitHub.\n", "versions": [{"version": "v1", "created": "Thu, 16 Oct 2014 09:28:18 GMT"}, {"version": "v2", "created": "Wed, 3 Dec 2014 15:08:33 GMT"}], "update_date": "2014-12-04", "authors_parsed": [["Akeret", "Joel", "", "ETH\n  Zurich"], ["Gamper", "Lukas", "", "ETH\n  Zurich"], ["Amara", "Adam", "", "ETH\n  Zurich"], ["Refregier", "Alexandre", "", "ETH\n  Zurich"]]}, {"id": "1410.4439", "submitter": "Victor Gomes", "authors": "Brijesh Dongol and Victor B. F. Gomes and Georg Struth", "title": "Principles for Verification Tools: Separation Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A principled approach to the design of program verification and con-\nstruction tools is applied to separation logic. The control flow is modelled by\npower series with convolution as separating conjunction. A generic construction\nlifts resource monoids to assertion and predicate transformer quantales. The\ndata flow is captured by concrete store/heap models. These are linked to the\nseparation algebra by soundness proofs. Verification conditions and\ntransformation laws are derived by equational reasoning within the predicate\ntransformer quantale. This separation of concerns makes an implementation in\nthe Isabelle/HOL proof as- sistant simple and highly automatic. The resulting\ntool is correct by construction; it is explained on the classical linked list\nreversal example.\n", "versions": [{"version": "v1", "created": "Thu, 16 Oct 2014 16:08:19 GMT"}], "update_date": "2014-10-17", "authors_parsed": [["Dongol", "Brijesh", ""], ["Gomes", "Victor B. F.", ""], ["Struth", "Georg", ""]]}, {"id": "1410.4956", "submitter": "David Insa", "authors": "David Insa and Josep Silva", "title": "Transforming while/do/for/foreach-Loops into Recursive Methods", "comments": "16 pages, 8 figures, 6 algorithms, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In software engineering, taking a good election between recursion and\niteration is essential because their efficiency and maintenance are different.\nIn fact, developers often need to transform iteration into recursion (e.g., in\ndebugging, to decompose the call graph into iterations); thus, it is quite\nsurprising that there does not exist a public transformation from loops to\nrecursion that handles all kinds of loops. This article describes a\ntransformation able to transform iterative loops into equivalent recursive\nmethods. The transformation is described for the programming language Java, but\nit is general enough as to be adapted to many other languages that allow\niteration and recursion. We describe the changes needed to transform loops of\ntypes while/do/for/foreach into recursion. Each kind of loop requires a\nparticular treatment that is described and exemplified.\n", "versions": [{"version": "v1", "created": "Sat, 18 Oct 2014 13:43:53 GMT"}, {"version": "v2", "created": "Tue, 21 Oct 2014 09:37:14 GMT"}], "update_date": "2014-10-22", "authors_parsed": [["Insa", "David", ""], ["Silva", "Josep", ""]]}, {"id": "1410.5370", "submitter": "Eric Seidel", "authors": "Eric L. Seidel, Niki Vazou, Ranjit Jhala", "title": "Type Targeted Testing", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-662-46669-8_33", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new technique called type targeted testing, which translates\nprecise refinement types into comprehensive test-suites. The key insight behind\nour approach is that through the lens of SMT solvers, refinement types can also\nbe viewed as a high-level, declarative, test generation technique, wherein\ntypes are converted to SMT queries whose models can be decoded into concrete\nprogram inputs. Our approach enables the systematic and exhaustive testing of\nimplementations from high-level declarative specifications, and furthermore,\nprovides a gradual path from testing to full verification. We have implemented\nour approach as a Haskell testing tool called TARGET, and present an evaluation\nthat shows how TARGET can be used to test a wide variety of properties and how\nit compares against state-of-the-art testing approaches.\n", "versions": [{"version": "v1", "created": "Mon, 20 Oct 2014 17:48:20 GMT"}, {"version": "v2", "created": "Fri, 16 Jan 2015 03:55:38 GMT"}], "update_date": "2017-08-29", "authors_parsed": [["Seidel", "Eric L.", ""], ["Vazou", "Niki", ""], ["Jhala", "Ranjit", ""]]}, {"id": "1410.5764", "submitter": "Matt Lewis", "authors": "Daniel Kroening and Matt Lewis and Georg Weissenbacher", "title": "Proving Safety with Trace Automata and Bounded Model Checking", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Loop under-approximation is a technique that enriches C programs with\nadditional branches that represent the effect of a (limited) range of loop\niterations. While this technique can speed up the detection of bugs\nsignificantly, it introduces redundant execution traces which may complicate\nthe verification of the program. This holds particularly true for verification\ntools based on Bounded Model Checking, which incorporate simplistic heuristics\nto determine whether all feasible iterations of a loop have been considered.\n  We present a technique that uses \\emph{trace automata} to eliminate redundant\nexecutions after performing loop acceleration. The method reduces the diameter\nof the program under analysis, which is in certain cases sufficient to allow a\nsafety proof using Bounded Model Checking. Our transformation is precise---it\ndoes not introduce false positives, nor does it mask any errors. We have\nimplemented the analysis as a source-to-source transformation, and present\nexperimental results showing the applicability of the technique.\n", "versions": [{"version": "v1", "created": "Tue, 21 Oct 2014 18:02:00 GMT"}], "update_date": "2014-10-22", "authors_parsed": [["Kroening", "Daniel", ""], ["Lewis", "Matt", ""], ["Weissenbacher", "Georg", ""]]}, {"id": "1410.6449", "submitter": "Jiahao Chen", "authors": "Jiahao Chen and Alan Edelman", "title": "Parallel Prefix Polymorphism Permits Parallelization, Presentation &\n  Proof", "comments": "10 pages, 3 figures. Proceedings of HPTCDL, the 1st Workshop on High\n  Performance Technical Computing in Dynamic Languages, November 17, 2014, New\n  Orleans, Louisiana, USA. Supporting Information available at\n  http://jiahao.github.io/parallel-prefix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Polymorphism in programming languages enables code reuse. Here, we show that\npolymorphism has broad applicability far beyond computations for technical\ncomputing: parallelism in distributed computing, presentation of visualizations\nof runtime data flow, and proofs for formal verification of correctness. The\nability to reuse a single codebase for all these purposes provides new ways to\nunderstand and verify parallel programs.\n", "versions": [{"version": "v1", "created": "Thu, 23 Oct 2014 18:42:57 GMT"}, {"version": "v2", "created": "Thu, 6 Nov 2014 19:27:27 GMT"}], "update_date": "2014-11-07", "authors_parsed": [["Chen", "Jiahao", ""], ["Edelman", "Alan", ""]]}, {"id": "1410.7013", "submitter": "EPTCS", "authors": "Ivan Lanese (Focus Team, University of Bologna/INRIA (Italy)), Alberto\n  Lluch Lafuente (DTU Compute, Technical University of Denmark (Denmark)), Ana\n  Sokolova (University of Salzburg (Austria)), Hugo Torres Vieira (LaSIGE,\n  University of Lisbon (Portugal))", "title": "Proceedings 7th Interaction and Concurrency Experience", "comments": null, "journal-ref": "EPTCS 166, 2014", "doi": "10.4204/EPTCS.166", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of ICE 2014, the 7th Interaction and\nConcurrency Experience, which was held in Berlin, Germany on the 6th of June\n2014 as a satellite event of DisCoTec 2014. The ICE procedure for paper\nselection allows PC members to interact, anonymously, with authors. During the\nreview phase, each submitted paper is published on a Wiki and associated with a\ndiscussion forum whose access is restricted to the authors and to all the PC\nmembers not declaring a conflict of interests. The PC members post comments and\nquestions that the authors reply to. Each paper was reviewed by three PC\nmembers, and altogether 8 papers (including 3 short papers) were accepted for\npublication. We were proud to host two invited talks, by Pavol Cerny and Kim\nLarsen, whose abstracts are included in this volume together with the regular\npapers.\n", "versions": [{"version": "v1", "created": "Sun, 26 Oct 2014 10:49:11 GMT"}], "update_date": "2014-10-28", "authors_parsed": [["Lanese", "Ivan", "", "Focus Team, University of Bologna/INRIA"], ["Lafuente", "Alberto Lluch", "", "DTU Compute, Technical University of Denmark"], ["Sokolova", "Ana", "", "University of Salzburg"], ["Vieira", "Hugo Torres", "", "LaSIGE,\n  University of Lisbon"]]}, {"id": "1410.7103", "submitter": "Jose Vergara JV", "authors": "Barry Jay and Jose Vergara", "title": "Confusion in the Church-Turing Thesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  The Church-Turing Thesis confuses numerical computations with symbolic\ncomputations. In particular, any model of computability in which equality is\nnot definable, such as the lambda-models underpinning higher-order programming\nlanguages, is not equivalent to the Turing model. However, a modern combinatory\ncalculus, the SF-calculus, can define equality of its closed normal forms, and\nso yields a model of computability that is equivalent to the Turing model. This\nhas profound implications for programming language design.\n", "versions": [{"version": "v1", "created": "Mon, 27 Oct 2014 00:38:47 GMT"}, {"version": "v2", "created": "Thu, 6 Nov 2014 02:06:02 GMT"}], "update_date": "2014-11-07", "authors_parsed": [["Jay", "Barry", ""], ["Vergara", "Jose", ""]]}, {"id": "1410.7467", "submitter": "EPTCS", "authors": "Sung-Shik T.Q. Jongmans (CWI), Farhad Arbab (CWI)", "title": "Toward Sequentializing Overparallelized Protocol Code", "comments": "In Proceedings ICE 2014, arXiv:1410.7013", "journal-ref": "EPTCS 166, 2014, pp. 38-44", "doi": "10.4204/EPTCS.166.5", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In our ongoing work, we use constraint automata to compile protocol\nspecifications expressed as Reo connectors into efficient executable code,\ne.g., in C. We have by now studied this automata based compilation approach\nrather well, and have devised effective solutions to some of its problems.\nBecause our approach is based on constraint automata, the approach, its\nproblems, and our solutions are in fact useful and relevant well beyond the\nspecific case of compiling Reo. In this short paper, we identify and analyze\ntwo such rather unexpected problems.\n", "versions": [{"version": "v1", "created": "Tue, 28 Oct 2014 00:40:55 GMT"}], "update_date": "2014-10-29", "authors_parsed": [["Jongmans", "Sung-Shik T. Q.", "", "CWI"], ["Arbab", "Farhad", "", "CWI"]]}, {"id": "1410.7472", "submitter": "EPTCS", "authors": "Massimo Bartoletti (University of Cagliari), Tiziana Cimoli\n  (University of Cagliari), G. Michele Pinna (University of Cagliari)", "title": "A note on two notions of compliance", "comments": "In Proceedings ICE 2014, arXiv:1410.7013", "journal-ref": "EPTCS 166, 2014, pp. 86-93", "doi": "10.4204/EPTCS.166.9", "report-no": null, "categories": "cs.PL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We establish a relation between two models of contracts: binary session\ntypes, and a model based on event structures and game-theoretic notions. In\nparticular, we show that compliance in session types corresponds to the\nexistence of certain winning strategies in game-based contracts.\n", "versions": [{"version": "v1", "created": "Tue, 28 Oct 2014 00:41:47 GMT"}], "update_date": "2014-10-29", "authors_parsed": [["Bartoletti", "Massimo", "", "University of Cagliari"], ["Cimoli", "Tiziana", "", "University of Cagliari"], ["Pinna", "G. Michele", "", "University of Cagliari"]]}, {"id": "1410.7724", "submitter": "Andreas Pavlogiannis", "authors": "Krishnendu Chatterjee, Rasmus Ibsen-Jensen, Andreas Pavlogiannis,\n  Prateesh Goyal", "title": "Faster Algorithms for Algebraic Path Properties in RSMs with Constant\n  Treewidth", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Interprocedural analysis is at the heart of numerous applications in\nprogramming languages, such as alias analysis, constant propagation, etc.\nRecursive state machines (RSMs) are standard models for interprocedural\nanalysis. We consider a general framework with RSMs where the transitions are\nlabeled from a semiring, and path properties are algebraic with semiring\noperations. RSMs with algebraic path properties can model interprocedural\ndataflow analysis problems, the shortest path problem, the most probable path\nproblem, etc. The traditional algorithms for interprocedural analysis focus on\npath properties where the starting point is \\emph{fixed} as the entry point of\na specific method. In this work, we consider possible multiple queries as\nrequired in many applications such as in alias analysis. The study of multiple\nqueries allows us to bring in a very important algorithmic distinction between\nthe resource usage of the \\emph{one-time} preprocessing vs for \\emph{each\nindividual} query. The second aspect that we consider is that the control flow\ngraphs for most programs have constant treewidth.\n  Our main contributions are simple and implementable algorithms that support\nmultiple queries for algebraic path properties for RSMs that have constant\ntreewidth. Our theoretical results show that our algorithms have small\nadditional one-time preprocessing, but can answer subsequent queries\nsignificantly faster as compared to the current best-known solutions for\nseveral important problems, such as interprocedural reachability and shortest\npath. We provide a prototype implementation for interprocedural reachability\nand intraprocedural shortest path that gives a significant speed-up on several\nbenchmarks.\n", "versions": [{"version": "v1", "created": "Tue, 28 Oct 2014 18:27:10 GMT"}, {"version": "v2", "created": "Tue, 25 Nov 2014 21:40:40 GMT"}], "update_date": "2014-11-27", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Ibsen-Jensen", "Rasmus", ""], ["Pavlogiannis", "Andreas", ""], ["Goyal", "Prateesh", ""]]}]