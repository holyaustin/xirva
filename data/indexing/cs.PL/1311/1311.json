[{"id": "1311.0044", "submitter": "Rasha Salah Omar", "authors": "Rasha Salah Omar, Ahmed El-Mahdy, and Erven Rohou", "title": "Thread-Based Obfuscation through Control-Flow Mangling", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The increasing use of cloud computing and remote execution have made program\nsecurity especially important. Code obfuscation has been proposed to make the\nunderstanding of programs more complicated to attackers. In this paper, we\nexploit multi-core processing to substantially increase the complexity of\nprograms, making reverse engineering more complicated. We propose a novel\nmethod that automatically partitions any serial thread into an arbitrary number\nof parallel threads, at the basic-block level. The method generates new\ncontrol-flow graphs, preserving the blocks' serial successor relations and\nguaranteeing that one basic-block is active at a time using guards. The method\ngenerates m^n different combinations for m threads and n basic-blocks,\nsignificantly complicating the execution state. We provide a correctness proof\nfor the algorithm and implement the algorithm in the LLVM compilation\nframework.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2013 22:00:08 GMT"}], "update_date": "2013-11-04", "authors_parsed": [["Omar", "Rasha Salah", ""], ["El-Mahdy", "Ahmed", ""], ["Rohou", "Erven", ""]]}, {"id": "1311.0728", "submitter": "Alaa Elnashar", "authors": "Alaa I. El-Nashar and Nakamura Masaki", "title": "To parallelize or not to parallelize, bugs issue", "comments": null, "journal-ref": "International Journal of Intelligent Computing and Information\n  Science, Egypt, IJICIS, Vol.10, No. 2, JULY 2010", "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program correctness is one of the most difficult challenges in parallel\nprogramming. Message Passing Interface MPI is widely used in writing parallel\napplications. Since MPI is not a compiled language, the programmer will be\nenfaced with several programming bugs.This paper presents the most common\nprogramming bugs arise in MPI programs to help the programmer to compromise\nbetween the advantage of parallelism and the extra effort needed to detect and\nfix such bugs. An algebraic specification of an MPI-like programming language,\ncalled Simple MPI (SMPI), to be used in writing MPI programs specification has\nalso been proposed. In addition, both nondeterminacy and deadlocks arise in\nSMPI programs have been verified using Maud system.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2013 15:19:47 GMT"}], "update_date": "2013-11-05", "authors_parsed": [["El-Nashar", "Alaa I.", ""], ["Masaki", "Nakamura", ""]]}, {"id": "1311.0731", "submitter": "Alaa Elnashar", "authors": "Alaa I. Elnashar", "title": "To parallelize or not to parallelize, control and data flow issue", "comments": null, "journal-ref": "International Journal of Intelligent Computing and Information\n  Science IJICS, Egypt, v. 9, no. 2, July 2009", "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  New trends towards multiple core processors imply using standard programming\nmodels to develop efficient, reliable and portable programs for distributed\nmemory multiprocessors and workstation PC clusters. Message passing using MPI\nis widely used to write efficient, reliable and portable applications. Control\nand data flow analysis concepts, techniques and tools are needed to understand\nand analyze MPI programs. If our point of interest is the program control and\ndata flow analysis, to decide to parallelize or not to parallelize our\napplications, there is a question to be answered, \" Can the existing concepts,\ntechniques and tools used to analyze sequential programs also be used to\nanalyze parallel ones written in MPI?\". In this paper we'll try to answer this\nquestion.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2013 15:24:47 GMT"}], "update_date": "2013-11-05", "authors_parsed": [["Elnashar", "Alaa I.", ""]]}, {"id": "1311.0768", "submitter": "Bertrand Jeannet", "authors": "Bertrand Jeannet and Peter Schrammel and Sriram Sankaranarayanan", "title": "Abstract Acceleration of General Linear Loops", "comments": "Extended version with appendices of paper accepted to POPL'2014", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present abstract acceleration techniques for computing loop invariants for\nnumerical programs with linear assignments and conditionals. Whereas abstract\ninterpretation techniques typically over-approximate the set of reachable\nstates iteratively, abstract acceleration captures the effect of the loop with\na single, non-iterative transfer function applied to the initial states at the\nloop head. In contrast to previous acceleration techniques, our approach\napplies to any linear loop without restrictions. Its novelty lies in the use of\nthe Jordan normal form decomposition of the loop body to derive symbolic\nexpressions for the entries of the matrix modeling the effect of n>=0\niterations of the loop. The entries of such a matrix depend on $n$ through\ncomplex polynomial, exponential and trigonometric functions. Therefore, we\nintroduces an abstract domain for matrices that captures the linear inequality\nrelations between these complex expressions. This results in an abstract matrix\nfor describing the fixpoint semantics of the loop.\n  Our approach integrates smoothly into standard abstract interpreters and can\nhandle programs with nested loops and loops containing conditional branches. We\nevaluate it over small but complex loops that are commonly found in control\nsoftware, comparing it with other tools for computing linear loop invariants.\nThe loops in our benchmarks typically exhibit polynomial, exponential and\noscillatory behaviors that present challenges to existing approaches. Our\napproach finds non-trivial invariants to prove useful bounds on the values of\nvariables for such loops, clearly outperforming the existing approaches in\nterms of precision while exhibiting good performance.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2013 17:03:17 GMT"}, {"version": "v2", "created": "Mon, 6 Jan 2014 14:15:50 GMT"}], "update_date": "2014-01-07", "authors_parsed": [["Jeannet", "Bertrand", ""], ["Schrammel", "Peter", ""], ["Sankaranarayanan", "Sriram", ""]]}, {"id": "1311.0864", "submitter": "Alaa Elnashar", "authors": "Alaa Ismail Elnashar, Sultan Aljahdali and Mosaid Al Sadhan", "title": "Two automated techniques for analyzing and debugging Mpi-based programs", "comments": "arXiv admin note: substantial text overlap with arXiv:1311.0731", "journal-ref": null, "doi": null, "report-no": "978-1-880843-83-3/ISCA CAINE/November 2011", "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Message Passing Interface (MPI) is the most commonly used paradigm in writing\nparallel programs since it can be employed not only within a single processing\nnode but also across several connected ones. Data flow analysis concepts,\ntechniques and tools are needed to understand and analyze MPI-based programs to\ndetect bugs arise in these programs. In this paper we propose two automated\ntechniques to analyze and debug MPI-based programs source codes.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2013 15:32:51 GMT"}], "update_date": "2013-11-06", "authors_parsed": [["Elnashar", "Alaa Ismail", ""], ["Aljahdali", "Sultan", ""], ["Sadhan", "Mosaid Al", ""]]}, {"id": "1311.1722", "submitter": "Ugo Dal Lago", "authors": "Ugo Dal Lago, Davide Sangiorgi, Michele Alberti", "title": "On Coinductive Equivalences for Higher-Order Probabilistic Functional\n  Programs (Long Version)", "comments": "47 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study bisimulation and context equivalence in a probabilistic\n$\\lambda$-calculus. The contributions of this paper are threefold. Firstly we\nshow a technique for proving congruence of probabilistic applicative\nbisimilarity. While the technique follows Howe's method, some of the\ntechnicalities are quite different, relying on non-trivial \"disentangling\"\nproperties for sets of real numbers. Secondly we show that, while bisimilarity\nis in general strictly finer than context equivalence, coincidence between the\ntwo relations is attained on pure $\\lambda$-terms. The resulting equality is\nthat induced by Levy-Longo trees, generally accepted as the finest extensional\nequivalence on pure $\\lambda$-terms under a lazy regime. Finally, we derive a\ncoinductive characterisation of context equivalence on the whole probabilistic\nlanguage, via an extension in which terms akin to distributions may appear in\nredex position. Another motivation for the extension is that its operational\nsemantics allows us to experiment with a different congruence technique, namely\nthat of logical bisimilarity.\n", "versions": [{"version": "v1", "created": "Thu, 7 Nov 2013 15:58:59 GMT"}], "update_date": "2013-11-08", "authors_parsed": [["Lago", "Ugo Dal", ""], ["Sangiorgi", "Davide", ""], ["Alberti", "Michele", ""]]}, {"id": "1311.2290", "submitter": "Peter Selinger", "authors": "Michele Pagani, Peter Selinger, Beno\\^it Valiron", "title": "Applying quantitative semantics to higher-order quantum computing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Finding a denotational semantics for higher order quantum computation is a\nlong-standing problem in the semantics of quantum programming languages. Most\npast approaches to this problem fell short in one way or another, either\nlimiting the language to an unusably small finitary fragment, or giving up\nimportant features of quantum physics such as entanglement. In this paper, we\npropose a denotational semantics for a quantum lambda calculus with recursion\nand an infinite data type, using constructions from quantitative semantics of\nlinear logic.\n", "versions": [{"version": "v1", "created": "Sun, 10 Nov 2013 17:56:21 GMT"}], "update_date": "2013-11-12", "authors_parsed": [["Pagani", "Michele", ""], ["Selinger", "Peter", ""], ["Valiron", "Beno\u00eet", ""]]}, {"id": "1311.2927", "submitter": "Archana Kale", "authors": "Archana Kale, Amitkumar Patil, Supratim Biswas", "title": "Parallelization of Loops with Variable Distance Data Dependences", "comments": "10 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The extent of parallelization of a loop is largely determined by the\ndependences between its statements. While dependence free loops are fully\nparallelizable, those with loop carried dependences are not. Dependence\ndistance is a measure of absolute difference between a pair of dependent\niterations. Loops with constant distance data dependence, because of uniform\ndistance between the dependent iterations, lead to easy partitioning of the\niteration space and hence they have been successfully dealt with.\n  Parallelization of loops with variable distance data dependences is a\nconsiderably difficult problem. It is our belief that partitioning the\niteration space in such loops cannot be done without examining solutions of the\ncorresponding Linear Diophantine Equations. Focus of this work is to study\nvariable distance data dependences and examine the relation between dependent\niterations. Our analysis based on parametric solution leads to a mathematical\nformulation capturing dependence between iterations. Our approach shows the\nexistence of reasonable exploitable parallelism in variable distance data\ndependences loops with multiple LDEs.\n", "versions": [{"version": "v1", "created": "Tue, 12 Nov 2013 05:21:54 GMT"}], "update_date": "2013-11-14", "authors_parsed": [["Kale", "Archana", ""], ["Patil", "Amitkumar", ""], ["Biswas", "Supratim", ""]]}, {"id": "1311.3130", "submitter": "Niranjan  Kumar Parvatham", "authors": "Niranjan Kumar Parvatham", "title": "Impact of Indentation in Programming", "comments": null, "journal-ref": "International Journal of Programming Languages and Applications (\n  IJPLA ) Vol.3, No.4, October 2013", "doi": "10.5121/ijpla.2013.3403", "report-no": null, "categories": "cs.PL cs.HC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In computer programming languages, indentation formats program source code to\nimprove readability. Programming languages make use of indentation to define\nprogram structure .Programmers use indentation to understand the structure of\ntheir programs to human readers. Especially, indentation is the better way to\nrepresent the relationship between control flow constructs such as selection\nstatements or loops and code contained within and outside them. This paper\ndescribes about different indentation styles used in Programming and also\ndescribes context of each indentation style. It also describes indentation\nstyles used for various programming constructs and the best practice for a\nparticular programming construct. This paper helps the beginners to understand\nvarious indentation styles used in programming and also to choose suitable\nindentation style.\n", "versions": [{"version": "v1", "created": "Wed, 13 Nov 2013 13:51:55 GMT"}], "update_date": "2013-11-14", "authors_parsed": [["Parvatham", "Niranjan Kumar", ""]]}, {"id": "1311.3293", "submitter": "Brijender Kahanwal Dr.", "authors": "Dr. Brijender Kahanwal", "title": "Abstraction Level Taxonomy of Programming Language Frameworks", "comments": "12 pages, 3 figures", "journal-ref": "International Journal of Programming Languages and Applications,\n  Volume 3, No. 4, pp. 1-12, 2013", "doi": "10.5121/ijpla.2013.3401", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The main purpose of this article is to describe the taxonomy of computer\nlanguages according to the levels of abstraction. There exists so many computer\nlanguages because of so many reasons like the evolution of better computer\nlanguages over the time; the socio-economic factors as the proprietary\ninterests, commercial advantages; expressive power; ease of use of novice;\norientation toward special purposes; orientation toward special hardware; and\ndiverse ideas about most suitability. Moreover, the important common properties\nof most of these languages are discussed here. No programming language is\ndesigned in a vacuity, but it solves some specific kinds of problems. There is\na different framework for each problem and best suitable framework for each\nproblem. A single framework is not best for all types of problems. So, it is\nimportant to select vigilantly the frameworks supported by the language. The\nfive generation of the computer programming languages are explored in this\npaper to some extent.\n", "versions": [{"version": "v1", "created": "Wed, 13 Nov 2013 10:21:31 GMT"}], "update_date": "2013-11-15", "authors_parsed": [["Kahanwal", "Dr. Brijender", ""]]}, {"id": "1311.3336", "submitter": "Alexander Sprintson", "authors": "C. Jasson Casey, Andrew Sutton, Gabriel Dos Reis, and Alex Sprintson", "title": "Eliminating Network Protocol Vulnerabilities Through Abstraction and\n  Systems Language Design", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Incorrect implementations of network protocol message specifications affect\nthe stability, security, and cost of network system development. Most\nimplementation defects fall into one of three categories of well defined\nmessage constraints. However, the general process of constructing network\nprotocol stacks and systems does not capture these categorical con- straints.\nWe introduce a systems programming language with new abstractions that capture\nthese constraints. Safe and efficient implementations of standard message\nhandling operations are synthesized by our compiler, and whole-program analysis\nis used to ensure constraints are never violated. We present language examples\nusing the OpenFlow protocol.\n", "versions": [{"version": "v1", "created": "Wed, 13 Nov 2013 23:08:12 GMT"}], "update_date": "2013-11-15", "authors_parsed": [["Casey", "C. Jasson", ""], ["Sutton", "Andrew", ""], ["Reis", "Gabriel Dos", ""], ["Sprintson", "Alex", ""]]}, {"id": "1311.3852", "submitter": "Gordana Rakic", "authors": "Gordana Rakic, Zoran Budimac", "title": "Problems in Systematic Application of Software Metrics and Possible\n  Solution", "comments": "Rakic G, Budimac Z., Problems In Systematic Application Of Software\n  Metrics And Possible Solution, In Proc. of The 5th International Conference\n  on Information Technology (ICIT) May 11-13, 2011, Amman, Jordan", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Systematic application of software metric techniques can lead to significant\nimprovements of the quality of a final software product. However, there is\nstill the evident lack of wider utilization of software metrics techniques and\ntools due to many reasons. In this paper we investigate some limitations of\ncontemporary software metrics tools and then propose construction of a new tool\nthat would solve some of the problems. We describe the promising prototype, its\ninternal structure, and then focus on its independency of the input language.\n", "versions": [{"version": "v1", "created": "Fri, 15 Nov 2013 13:54:57 GMT"}], "update_date": "2013-11-18", "authors_parsed": [["Rakic", "Gordana", ""], ["Budimac", "Zoran", ""]]}, {"id": "1311.4198", "submitter": "David Van Horn", "authors": "Shuying Liang, Matthew Might, David Van Horn", "title": "AnaDroid: Malware Analysis of Android with User-supplied Predicates", "comments": "Appears in the Workshop on Tools for Automatic Program Analysis,\n  Seattle, Washington, June 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Today's mobile platforms provide only coarse-grained permissions to users\nwith regard to how third- party applications use sensitive private data.\nUnfortunately, it is easy to disguise malware within the boundaries of\nlegitimately-granted permissions. For instance, granting access to \"contacts\"\nand \"internet\" may be necessary for a text-messaging application to function,\neven though the user does not want contacts transmitted over the internet. To\nunderstand fine-grained application use of permissions, we need to statically\nanalyze their behavior. Even then, malware detection faces three hurdles: (1)\nanalyses may be prohibitively expensive, (2) automated analyses can only find\nbehaviors that they are designed to find, and (3) the maliciousness of any\ngiven behavior is application-dependent and subject to human judgment. To\nremedy these issues, we propose semantic-based program analysis, with a human\nin the loop as an alternative approach to malware detection. In particular, our\nanalysis allows analyst-crafted semantic predicates to search and filter\nanalysis results. Human-oriented semantic-based program analysis can\nsystematically, quickly and concisely characterize the behaviors of mobile\napplications. We describe a tool that provides analysts with a library of the\nsemantic predicates and the ability to dynamically trade speed and precision.\nIt also provides analysts the ability to statically inspect details of every\nsuspicious state of (abstract) execution in order to make a ruling as to\nwhether or not the behavior is truly malicious with respect to the intent of\nthe application. In addition, permission and profiling reports are generated to\naid analysts in identifying common malicious behaviors.\n", "versions": [{"version": "v1", "created": "Sun, 17 Nov 2013 18:47:15 GMT"}], "update_date": "2013-11-19", "authors_parsed": [["Liang", "Shuying", ""], ["Might", "Matthew", ""], ["Van Horn", "David", ""]]}, {"id": "1311.4201", "submitter": "David Van Horn", "authors": "Shuying Liang, Andrew W. Keep, Matthew Might, Steven Lyde, Thomas\n  Gilray, Petey Aldous, David Van Horn", "title": "Sound and Precise Malware Analysis for Android via Pushdown Reachability\n  and Entry-Point Saturation", "comments": "Appears in 3rd Annual ACM CCS workshop on Security and Privacy in\n  SmartPhones and Mobile Devices (SPSM'13), Berlin, Germany, 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present Anadroid, a static malware analysis framework for Android apps.\nAnadroid exploits two techniques to soundly raise precision: (1) it uses a\npushdown system to precisely model dynamically dispatched interprocedural and\nexception-driven control-flow; (2) it uses Entry-Point Saturation (EPS) to\nsoundly approximate all possible interleavings of asynchronous entry points in\nAndroid applications. (It also integrates static taint-flow analysis and least\npermissions analysis to expand the class of malicious behaviors which it can\ncatch.) Anadroid provides rich user interface support for human analysts which\nmust ultimately rule on the \"maliciousness\" of a behavior.\n  To demonstrate the effectiveness of Anadroid's malware analysis, we had teams\nof analysts analyze a challenge suite of 52 Android applications released as\npart of the Auto- mated Program Analysis for Cybersecurity (APAC) DARPA\nprogram. The first team analyzed the apps using a ver- sion of Anadroid that\nuses traditional (finite-state-machine-based) control-flow-analysis found in\nexisting malware analysis tools; the second team analyzed the apps using a\nversion of Anadroid that uses our enhanced pushdown-based\ncontrol-flow-analysis. We measured machine analysis time, human analyst time,\nand their accuracy in flagging malicious applications. With pushdown analysis,\nwe found statistically significant (p < 0.05) decreases in time: from 85\nminutes per app to 35 minutes per app in human plus machine analysis time; and\nstatistically significant (p < 0.05) increases in accuracy with the\npushdown-driven analyzer: from 71% correct identification to 95% correct\nidentification.\n", "versions": [{"version": "v1", "created": "Sun, 17 Nov 2013 19:11:45 GMT"}], "update_date": "2013-11-19", "authors_parsed": [["Liang", "Shuying", ""], ["Keep", "Andrew W.", ""], ["Might", "Matthew", ""], ["Lyde", "Steven", ""], ["Gilray", "Thomas", ""], ["Aldous", "Petey", ""], ["Van Horn", "David", ""]]}, {"id": "1311.4231", "submitter": "David Van Horn", "authors": "Matthew Might, Yannis Smaragdakis, David Van Horn", "title": "Resolving and Exploiting the $k$-CFA Paradox", "comments": "Appears in the ACM SIGPLAN 2010 Conference on Programming Language\n  Design and Implementation (PLDI'10)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Low-level program analysis is a fundamental problem, taking the shape of\n\"flow analysis\" in functional languages and \"points-to\" analysis in imperative\nand object-oriented languages. Despite the similarities, the vocabulary and\nresults in the two communities remain largely distinct, with limited\ncross-understanding. One of the few links is Shivers's $k$-CFA work, which has\nadvanced the concept of \"context-sensitive analysis\" and is widely known in\nboth communities.\n  Recent results indicate that the relationship between the functional and\nobject-oriented incarnations of $k$-CFA is not as well understood as thought.\nVan Horn and Mairson proved $k$-CFA for $k \\geq 1$ to be EXPTIME-complete;\nhence, no polynomial-time algorithm can exist. Yet, there are several\npolynomial-time formulations of context-sensitive points-to analyses in\nobject-oriented languages. Thus, it seems that functional $k$-CFA may actually\nbe a profoundly different analysis from object-oriented $k$-CFA. We resolve\nthis paradox by showing that the exact same specification of $k$-CFA is\npolynomial-time for object-oriented languages yet exponential- time for\nfunctional ones: objects and closures are subtly different, in a way that\ninteracts crucially with context-sensitivity and complexity. This illumination\nleads to an immediate payoff: by projecting the object-oriented treatment of\nobjects onto closures, we derive a polynomial-time hierarchy of\ncontext-sensitive CFAs for functional programs.\n", "versions": [{"version": "v1", "created": "Sun, 17 Nov 2013 23:59:28 GMT"}], "update_date": "2013-11-19", "authors_parsed": [["Might", "Matthew", ""], ["Smaragdakis", "Yannis", ""], ["Van Horn", "David", ""]]}, {"id": "1311.4305", "submitter": "Tomofumi Yuki", "authors": "Tomofumi Yuki and Paul Feautrier and Sanjay Rajopadhye and Vijay\n  Saraswat", "title": "Checking Race Freedom of Clocked X10 Programs", "comments": "11 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One of many approaches to better take advantage of parallelism, which has now\nbecome mainstream, is the introduction of parallel programming languages.\nHowever, parallelism is by nature non-deterministic, and not all parallel bugs\ncan be avoided by language design. This paper proposes a method for\nguaranteeing absence of data races in the polyhedral subset of clocked X10\nprograms.\n  Clocks in X10 are similar to barriers, but are more dynamic; the subset of\nprocesses that participate in the synchronization can dynamically change at\nruntime. We construct the happens-before relation for clocked X10 programs, and\nshow that the problem of race detection is undecidable. However, in many\npractical cases, modern tools are able to find solutions or disprove their\nexistence. We present a set of benchmarks for which the analysis is possible\nand has an acceptable running time.\n", "versions": [{"version": "v1", "created": "Mon, 18 Nov 2013 09:36:31 GMT"}], "update_date": "2013-11-19", "authors_parsed": [["Yuki", "Tomofumi", ""], ["Feautrier", "Paul", ""], ["Rajopadhye", "Sanjay", ""], ["Saraswat", "Vijay", ""]]}, {"id": "1311.4733", "submitter": "David Van Horn", "authors": "David Van Horn", "title": "The Complexity of Flow Analysis in Higher-Order Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This dissertation proves lower bounds on the inherent difficulty of deciding\nflow analysis problems in higher-order programming languages. We give exact\ncharacterizations of the computational complexity of 0CFA, the $k$CFA\nhierarchy, and related analyses. In each case, we precisely capture both the\nexpressiveness and feasibility of the analysis, identifying the elements\nresponsible for the trade-off.\n  0CFA is complete for polynomial time. This result relies on the insight that\nwhen a program is linear (each bound variable occurs exactly once), the\nanalysis makes no approximation; abstract and concrete interpretation coincide,\nand therefore pro- gram analysis becomes evaluation under another guise.\nMoreover, this is true not only for 0CFA, but for a number of further\napproximations to 0CFA. In each case, we derive polynomial time completeness\nresults.\n  For any $k > 0$, $k$CFA is complete for exponential time. Even when $k = 1$,\nthe distinction in binding contexts results in a limited form of closures,\nwhich do not occur in 0CFA. This theorem validates empirical observations that\n$k$CFA is intractably slow for any $k > 0$. There is, in the worst case---and\nplausibly, in practice---no way to tame the cost of the analysis. Exponential\ntime is required. The empirically observed intractability of this analysis can\nbe understood as being inherent in the approximation problem being solved,\nrather than reflecting unfortunate gaps in our programming abilities.\n", "versions": [{"version": "v1", "created": "Tue, 19 Nov 2013 13:31:54 GMT"}], "update_date": "2013-11-20", "authors_parsed": [["Van Horn", "David", ""]]}, {"id": "1311.5058", "submitter": "EPTCS", "authors": "Sebastian Maneth (University of Edinburgh)", "title": "Proceedings Second International Workshop on Trends in Tree Automata and\n  Tree Transducers", "comments": null, "journal-ref": "EPTCS 134, 2013", "doi": "10.4204/EPTCS.134", "report-no": null, "categories": "cs.FL cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the papers that were presented at the second\ninternational workshop on Trends in Tree Automata and Transducers (TTATT 2013)\nwhich took place on October 19th, 2013 in Hanoi/Vietnam. The workshop was\ncolocated with the verification conference ATVA. The first edition of the\nworkshop was colocated with RTA and took place in Nagoya/Japan. The interest of\nthe workshop lies at the intersection of programming languages, verification,\nand database theory, which are areas to which tree automata and transducers are\napplied recently.\n", "versions": [{"version": "v1", "created": "Wed, 20 Nov 2013 14:11:27 GMT"}], "update_date": "2013-11-21", "authors_parsed": [["Maneth", "Sebastian", "", "University of Edinburgh"]]}, {"id": "1311.5126", "submitter": "Jan Wolter", "authors": "Jan Wolter", "title": "Visual Representation of 3D Language Constructs Specified by Generic\n  Depictions", "comments": "16 pages, 11 figures, extended version of conference paper\n  \"Specifying Generic Depictions of Language Constructs for 3D Visual\n  Languages\", which I presented at the VL/HCC 2013:\n  http://dx.doi.org/10.1109/VLHCC.2013.6645258", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Several modeling domains make use of three-dimensional representations, e.g.,\nthe \"ball-and-stick\" models of molecules. Our generator framework DEViL3D\nsupports the design and implementation of visual 3D languages for such modeling\npurposes. The front-end of a language implementation generated by DEViL3D is a\ndedicated 3D graphical structure editor, which is used to construct programs in\nthat domain. DEViL3D supports the language designer to describe the visual\nappearance of the constructs of the particular language in terms of generic 3D\ndepictions. Their parameters specify where substructures are embedded, and how\nthe graphic adapts to space requirements of nested constructs. The 3D editor\nused for such specifications is generated by DEViL3D, too. In this paper, we\nbriefly introduce the research field of 3D visual languages and report about\nour generator framework and the role that generic depictions play in the\nspecification process for 3D languages. Our results show that our approach is\nsuitable for a wide range of 3D languages. We emphasize this suitability by\npresenting requirements on the visual appearance for different languages.\n", "versions": [{"version": "v1", "created": "Wed, 20 Nov 2013 16:28:52 GMT"}], "update_date": "2013-11-21", "authors_parsed": [["Wolter", "Jan", ""]]}, {"id": "1311.5810", "submitter": "David Van Horn", "authors": "David Van Horn, Harry G. Mairson", "title": "Deciding $k$CFA is complete for EXPTIME", "comments": "Appeared in The 13th ACM SIGPLAN International Conference on\n  Functional Programming (ICFP'08), Victoria, British Columbia, Canada,\n  September 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give an exact characterization of the computational complexity of the\n$k$CFA hierarchy. For any $k > 0$, we prove that the control flow decision\nproblem is complete for deterministic exponential time. This theorem validates\nempirical observations that such control flow analysis is intractable. It also\nprovides more general insight into the complexity of abstract interpretation.\n", "versions": [{"version": "v1", "created": "Fri, 22 Nov 2013 16:50:48 GMT"}], "update_date": "2013-11-25", "authors_parsed": [["Van Horn", "David", ""], ["Mairson", "Harry G.", ""]]}, {"id": "1311.5825", "submitter": "David Van Horn", "authors": "David Van Horn, Harry G. Mairson", "title": "Flow analysis, linearity, and PTIME", "comments": "Appears in The 15th International Static Analysis Symposium (SAS\n  2008), Valencia, Spain, July 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Flow analysis is a ubiquitous and much-studied component of compiler\ntechnology---and its variations abound. Amongst the most well known is Shivers'\n0CFA; however, the best known algorithm for 0CFA requires time cubic in the\nsize of the analyzed program and is unlikely to be improved. Consequently,\nseveral analyses have been designed to approximate 0CFA by trading precision\nfor faster computation. Henglein's simple closure analysis, for example,\nforfeits the notion of directionality in flows and enjoys an \"almost linear\"\ntime algorithm. But in making trade-offs between precision and complexity, what\nhas been given up and what has been gained? Where do these analyses differ and\nwhere do they coincide?\n  We identify a core language---the linear $\\lambda$-calculus---where 0CFA,\nsimple closure analysis, and many other known approximations or restrictions to\n0CFA are rendered identical. Moreover, for this core language, analysis\ncorresponds with (instrumented) evaluation. Because analysis faithfully\ncaptures evaluation, and because the linear $\\lambda$-calculus is complete for\nPTIME, we derive PTIME-completeness results for all of these analyses.\n", "versions": [{"version": "v1", "created": "Fri, 22 Nov 2013 17:23:55 GMT"}], "update_date": "2013-11-25", "authors_parsed": [["Van Horn", "David", ""], ["Mairson", "Harry G.", ""]]}, {"id": "1311.6563", "submitter": "Philip Atzemoglou", "authors": "Philip Atzemoglou", "title": "Higher-order semantics for quantum programming languages with classical\n  control", "comments": "DPhil Thesis. See full text for unabridged abstract", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL math.CT quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This thesis studies the categorical formalisation of quantum computing,\nthrough the prism of type theory, in a three-tier process. The first stage of\nour investigation involves the creation of the dagger lambda calculus, a lambda\ncalculus for dagger compact categories. Our second contribution lifts the\nexpressive power of the dagger lambda calculus, to that of a quantum\nprogramming language, by adding classical control in the form of complementary\nclassical structures and dualisers. Finally, our third contribution\ndemonstrates how our lambda calculus can be applied to various well known\nproblems in quantum computation.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2013 06:08:34 GMT"}], "update_date": "2013-11-27", "authors_parsed": [["Atzemoglou", "Philip", ""]]}, {"id": "1311.6929", "submitter": "Jonathan Protzenko", "authors": "Jonathan Protzenko", "title": "Illustrating the Mezzo programming language", "comments": null, "journal-ref": "1st French Singaporean Workshop on Formal Methods and Applications\n  (FSFMA 2013)", "doi": "10.4230/OASIcs.FSFMA.2013.68", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  When programmers want to prove strong program invariants, they are usually\nfaced with a choice between using theorem provers and using traditional\nprogramming languages. The former requires them to provide program proofs,\nwhich, for many applications, is considered a heavy burden. The latter provides\nless guarantees and the programmer usually has to write run-time assertions to\ncompensate for the lack of suitable invariants expressible in the type system.\n  We introduce Mezzo, a programming language in the tradition of ML, in which\nthe usual concept of a type is replaced by a more precise notion of a\npermission. Programs written in Mezzo usually enjoy stronger guarantees than\nprograms written in pure ML. However, because Mezzo is based on a type system,\nthe reasoning requires no user input. In this paper, we illustrate the key\nconcepts of Mezzo, highlighting the static guarantees our language provides.\n", "versions": [{"version": "v1", "created": "Wed, 27 Nov 2013 10:57:10 GMT"}], "update_date": "2013-11-28", "authors_parsed": [["Protzenko", "Jonathan", ""]]}, {"id": "1311.7203", "submitter": "Brijender Kahanwal Dr.", "authors": "Dr. Brijender Kahanwal, Dr. T. P. Singh", "title": "Function Overloading Implementation in C++", "comments": "7 pages, 9 Figures", "journal-ref": "International Journal of Advances in Engineering Sciences (e-ISSN:\n  2231-0347, ISSN: 2231-2013), Volume 3, Issue 4, pp. 12-18, 2013", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this article the function overloading in object-oriented programming is\nelaborated and how they are implemented in C++. The language supports a variety\nof programming styles. Here we are describing the polymorphism and its types in\nbrief. The main stress is given on the function overloading implementation\nstyles in the language. The polymorphic nature of languages has advantages like\nthat we can add new code without requiring changes to the other classes and\ninterfaces (in Java language) are easily implemented. In this technique, the\nrun-time overhead is also introduced in dynamic binding which increases the\nexecution time of the software. But there are no such types of overheads in\nthis static type of polymorphism because everything is resolved at the time of\ncompile time. Polymorphism; Function Overloading; Static Polymorphism;\nOverloading; Compile Time Polymorphism.\n", "versions": [{"version": "v1", "created": "Thu, 28 Nov 2013 04:16:49 GMT"}], "update_date": "2013-12-02", "authors_parsed": [["Kahanwal", "Dr. Brijender", ""], ["Singh", "Dr. T. P.", ""]]}, {"id": "1311.7242", "submitter": "Jonathan Protzenko", "authors": "Jonathan Protzenko and Fran\\c{c}ois Pottier", "title": "Programming with Permissions in Mezzo", "comments": null, "journal-ref": "ICFP 2013, Proceedings of the 18th ACM SIGPLAN international\n  conference on Functional programming", "doi": "10.1145/2500365.2500598", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present Mezzo, a typed programming language of ML lineage. Mezzo is\nequipped with a novel static discipline of duplicable and affine permissions,\nwhich controls aliasing and ownership. This rules out certain mistakes,\nincluding representation exposure and data races, and enables new idioms, such\nas gradual initialization, memory re-use, and (type)state changes. Although the\ncore static discipline disallows sharing a mutable data structure, Mezzo offers\nseveral ways of working around this restriction, including a novel dynamic\nownership control mechanism which we dub \"adoption and abandon\".\n", "versions": [{"version": "v1", "created": "Thu, 28 Nov 2013 09:15:55 GMT"}], "update_date": "2013-12-02", "authors_parsed": [["Protzenko", "Jonathan", ""], ["Pottier", "Fran\u00e7ois", ""]]}, {"id": "1311.7256", "submitter": "Jonathan Protzenko", "authors": "Arma\\\"el Gu\\'eneau, Fran\\c{c}ois Pottier and Jonathan Protzenko", "title": "The ins and outs of iteration in Mezzo", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is a talk proposal for HOPE 2013. Using iteration over a collection as a\ncase study, we wish to illustrate the strengths and weaknesses of the prototype\nprogramming language Mezzo.\n", "versions": [{"version": "v1", "created": "Thu, 28 Nov 2013 09:58:55 GMT"}], "update_date": "2013-12-02", "authors_parsed": [["Gu\u00e9neau", "Arma\u00ebl", ""], ["Pottier", "Fran\u00e7ois", ""], ["Protzenko", "Jonathan", ""]]}, {"id": "1311.7536", "submitter": "EPTCS", "authors": "Pieter Van Gorp (Eindhoven University of Technology), Louis M. Rose\n  (University of York), Christian Krause (SAP)", "title": "Proceedings Sixth Transformation Tool Contest", "comments": null, "journal-ref": "EPTCS 135, 2013", "doi": "10.4204/EPTCS.135", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The aim of the Transformation Tool Contest (TTC) series is to compare the\nexpressiveness, the usability and the performance of graph and model\ntransformation tools along a number of selected case studies. Participants want\nto learn about the pros and cons of each tool considering different\napplications. A deeper understanding of the relative merits of different tool\nfeatures will help to further improve graph and model transformation tools and\nto indicate open problems.\n  TTC 2013 involved 18 offline case study solutions: 6 solutions to the\nFlowGraphs case, 9 solutions to the Petri Nets to Statecharts case and 3\nsolutions to the Restructuring case. 13 of the 18 solutions have undergone a\nnon-blind peer review before the workshop and were presented and evaluated\nduring the workshop in Budapest. This volume contains the submissions that have\npassed an additional (post-workshop, blind) reviewing round.\n", "versions": [{"version": "v1", "created": "Fri, 29 Nov 2013 12:03:59 GMT"}], "update_date": "2013-12-02", "authors_parsed": [["Van Gorp", "Pieter", "", "Eindhoven University of Technology"], ["Rose", "Louis M.", "", "University of York"], ["Krause", "Christian", "", "SAP"]]}]