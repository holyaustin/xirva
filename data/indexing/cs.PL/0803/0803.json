[{"id": "0803.0014", "submitter": "Peter Schneider-Kamp", "authors": "P. Schneider-Kamp, J. Giesl, A. Serebrenik, R. Thiemann", "title": "Automated Termination Proofs for Logic Programs by Term Rewriting", "comments": "49 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There are two kinds of approaches for termination analysis of logic programs:\n\"transformational\" and \"direct\" ones. Direct approaches prove termination\ndirectly on the basis of the logic program. Transformational approaches\ntransform a logic program into a term rewrite system (TRS) and then analyze\ntermination of the resulting TRS instead. Thus, transformational approaches\nmake all methods previously developed for TRSs available for logic programs as\nwell. However, the applicability of most existing transformations is quite\nrestricted, as they can only be used for certain subclasses of logic programs.\n(Most of them are restricted to well-moded programs.) In this paper we improve\nthese transformations such that they become applicable for any definite logic\nprogram. To simulate the behavior of logic programs by TRSs, we slightly modify\nthe notion of rewriting by permitting infinite terms. We show that our\ntransformation results in TRSs which are indeed suitable for automated\ntermination analysis. In contrast to most other methods for termination of\nlogic programs, our technique is also sound for logic programming without occur\ncheck, which is typically used in practice. We implemented our approach in the\ntermination prover AProVE and successfully evaluated it on a large collection\nof examples.\n", "versions": [{"version": "v1", "created": "Sun, 2 Mar 2008 14:53:01 GMT"}, {"version": "v2", "created": "Mon, 1 Sep 2008 09:50:07 GMT"}], "update_date": "2008-09-01", "authors_parsed": [["Schneider-Kamp", "P.", ""], ["Giesl", "J.", ""], ["Serebrenik", "A.", ""], ["Thiemann", "R.", ""]]}, {"id": "0803.2305", "submitter": "Andrew Gacek", "authors": "Andrew Gacek", "title": "The Abella Interactive Theorem Prover (System Description)", "comments": "7 pages, to appear in IJCAR'08", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Abella is an interactive system for reasoning about aspects of object\nlanguages that have been formally presented through recursive rules based on\nsyntactic structure. Abella utilizes a two-level logic approach to\nspecification and reasoning. One level is defined by a specification logic\nwhich supports a transparent encoding of structural semantics rules and also\nenables their execution. The second level, called the reasoning logic, embeds\nthe specification logic and allows the development of proofs of properties\nabout specifications. An important characteristic of both logics is that they\nexploit the lambda tree syntax approach to treating binding in object\nlanguages. Amongst other things, Abella has been used to prove normalizability\nproperties of the lambda calculus, cut admissibility for a sequent calculus and\ntype uniqueness and subject reduction properties. This paper discusses the\nlogical foundations of Abella, outlines the style of theorem proving that it\nsupports and finally describes some of its recent applications.\n", "versions": [{"version": "v1", "created": "Sat, 15 Mar 2008 16:15:10 GMT"}, {"version": "v2", "created": "Fri, 23 May 2008 15:28:08 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Gacek", "Andrew", ""]]}, {"id": "0803.3099", "submitter": "Mark Burgin", "authors": "Mark Burgin a and Marc L. Smith", "title": "Concurrent Composition and Algebras of Events, Actions, and Processes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There are many different models of concurrent processes. The goal of this\nwork is to introduce a common formalized framework for current research in this\narea and to eliminate shortcomings of existing models of concurrency. Following\nup the previous research of the authors and other researchers on concurrency,\nhere we build a high-level metamodel EAP (event-action-process) for concurrent\nprocesses. This metamodel comprises a variety of other models of concurrent\nprocesses. We shape mathematical models for, and study events, actions, and\nprocesses in relation to important practical problems, such as communication in\nnetworks, concurrent programming, and distributed computations. In the third\nsection of the work, a three-level algebra of events, actions and processes is\nconstructed and studied as a new stage of algebra for concurrent processes.\nRelations between EAP process algebra and other models of concurrency are\nconsidered in the fourth section of this work.\n", "versions": [{"version": "v1", "created": "Fri, 21 Mar 2008 00:27:38 GMT"}], "update_date": "2008-03-24", "authors_parsed": [["a", "Mark Burgin", ""], ["Smith", "Marc L.", ""]]}, {"id": "0803.3230", "submitter": "Avik Chaudhuri", "authors": "Avik Chaudhuri, Prasad Naldurg, and Sriram Rajamani", "title": "A Type System for Data-Flow Integrity on Windows Vista", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Windows Vista operating system implements an interesting model of\nmulti-level integrity. We observe that in this model, trusted code can be\nblamed for any information-flow attack; thus, it is possible to eliminate such\nattacks by static analysis of trusted code. We formalize this model by\ndesigning a type system that can efficiently enforce data-flow integrity on\nWindows Vista. Typechecking guarantees that objects whose contents are\nstatically trusted never contain untrusted values, regardless of what untrusted\ncode runs in the environment. Some of Windows Vista's runtime access checks are\nnecessary for soundness; others are redundant and can be optimized away.\n", "versions": [{"version": "v1", "created": "Fri, 21 Mar 2008 21:28:16 GMT"}, {"version": "v2", "created": "Thu, 8 May 2008 02:55:57 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Chaudhuri", "Avik", ""], ["Naldurg", "Prasad", ""], ["Rajamani", "Sriram", ""]]}, {"id": "0803.4025", "submitter": "Ganesh M. Narayan", "authors": "Ganesh M. Narayan, K. Gopinath, V. Sridhar", "title": "Structure and Interpretation of Computer Programs", "comments": "9 pages, 10pt, double column, 15 figures", "journal-ref": "2nd IEEE International Symposium on Theoretical Aspects of\n  Software Engineering, 2008, Nanjing, China", "doi": "10.1109/TASE.2008.40", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Call graphs depict the static, caller-callee relation between \"functions\" in\na program. With most source/target languages supporting functions as the\nprimitive unit of composition, call graphs naturally form the fundamental\ncontrol flow representation available to understand/develop software. They are\nalso the substrate on which various interprocedural analyses are performed and\nare integral part of program comprehension/testing. Given their universality\nand usefulness, it is imperative to ask if call graphs exhibit any intrinsic\ngraph theoretic features -- across versions, program domains and source\nlanguages. This work is an attempt to answer these questions: we present and\ninvestigate a set of meaningful graph measures that help us understand call\ngraphs better; we establish how these measures correlate, if any, across\ndifferent languages and program domains; we also assess the overall, language\nindependent software quality by suitably interpreting these measures.\n", "versions": [{"version": "v1", "created": "Thu, 27 Mar 2008 22:58:43 GMT"}], "update_date": "2016-11-17", "authors_parsed": [["Narayan", "Ganesh M.", ""], ["Gopinath", "K.", ""], ["Sridhar", "V.", ""]]}]