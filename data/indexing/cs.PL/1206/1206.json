[{"id": "1206.0357", "submitter": "Neil Ghani", "authors": "Neil Ghani (University of Strathclyde), Patricia Johann (University of\n  Strathclyde), Clement Fumex (University of Strathclyde)", "title": "Generic Fibrational Induction", "comments": "For Special Issue from CSL 2010", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 2 (June 19,\n  2012) lmcs:717", "doi": "10.2168/LMCS-8(2:12)2012", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper provides an induction rule that can be used to prove properties of\ndata structures whose types are inductive, i.e., are carriers of initial\nalgebras of functors. Our results are semantic in nature and are inspired by\nHermida and Jacobs' elegant algebraic formulation of induction for polynomial\ndata types. Our contribution is to derive, under slightly different\nassumptions, a sound induction rule that is generic over all inductive types,\npolynomial or not. Our induction rule is generic over the kinds of properties\nto be proved as well: like Hermida and Jacobs, we work in a general fibrational\nsetting and so can accommodate very general notions of properties on inductive\ntypes rather than just those of a particular syntactic form. We establish the\nsoundness of our generic induction rule by reducing induction to iteration. We\nthen show how our generic induction rule can be instantiated to give induction\nrules for the data types of rose trees, finite hereditary sets, and\nhyperfunctions. The first of these lies outside the scope of Hermida and\nJacobs' work because it is not polynomial, and as far as we are aware, no\ninduction rules have been known to exist for the second and third in a general\nfibrational framework. Our instantiation for hyperfunctions underscores the\nvalue of working in the general fibrational setting since this data type cannot\nbe interpreted as a set.\n", "versions": [{"version": "v1", "created": "Sat, 2 Jun 2012 09:26:53 GMT"}, {"version": "v2", "created": "Sun, 17 Jun 2012 20:51:46 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Ghani", "Neil", "", "University of Strathclyde"], ["Johann", "Patricia", "", "University of\n  Strathclyde"], ["Fumex", "Clement", "", "University of Strathclyde"]]}, {"id": "1206.1090", "submitter": "Mohamed El-Zawawy Dr.", "authors": "Mohamed A. El-Zawawy and Nagwan M. Daoud", "title": "Dynamic Verification for File Safety of Multithreaded Programs", "comments": "7 pages, http://paper.ijcsns.org/07_book/201205/20120503.pdf", "journal-ref": "IJCSNS International Journal of Computer Science and Network\n  Security, VOL.12 No.5, pp 14-20, May 2012", "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present a new semantics to check file safety of\nmultithreaded programs. A file-safe program is one that reaches a final\nconfiguration under the proposed semantics. We extend the While language with\nfile operations and multi-threading commands, and call the new language whilef.\nThis paper shows that the file safety is an un-decidable property for whilef.\nThe file safety becomes a decidable property in a special case shown in this\npaper. The case happens when users provide pointer information. If the file is\nsafe we call it a strongly safe file program. We modify the syntax and the\nsemantic of the language and called it SafeWhilef.\n", "versions": [{"version": "v1", "created": "Tue, 5 Jun 2012 23:37:00 GMT"}], "update_date": "2012-06-07", "authors_parsed": [["El-Zawawy", "Mohamed A.", ""], ["Daoud", "Nagwan M.", ""]]}, {"id": "1206.1687", "submitter": "Silvia Crafa", "authors": "Silvia Crafa", "title": "Behavioural Types for Actor Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent mainstream programming languages such as Erlang or Scala have renewed\nthe interest on the Actor model of concurrency. However, the literature on the\nstatic analysis of actor systems is still lacking of mature formal methods. In\nthis paper we present a minimal actor calculus that takes as primitive the\nbasic constructs of Scala's Actors API. More precisely, actors can send\nasynchronous messages, process received messages according to a pattern\nmatching mechanism, and dynamically create new actors, whose scope can be\nextruded by passing actor names as message parameters. Drawing inspiration from\nthe linear types and session type theories developed for process calculi, we\nput forward a behavioural type system that addresses the key issues of an actor\ncalculus. We then study a safety property dealing with the determinism of\nfinite actor com- munication. More precisely, we show that well typed and\nbalanced actor systems are (i) deadlock-free and (ii) any message will\neventually be handled by the target actor, and dually no actor will\nindefinitely wait for an expected message\n", "versions": [{"version": "v1", "created": "Fri, 8 Jun 2012 07:42:55 GMT"}], "update_date": "2012-06-11", "authors_parsed": [["Crafa", "Silvia", ""]]}, {"id": "1206.1969", "submitter": "Iztok Fister", "authors": "Iztok Fister Jr., Marjan Mernik, Iztok Fister, Dejan Hrn\\v{c}i\\v{c}", "title": "Implementation of EasyTime Formal Semantics using a LISA Compiler\n  Generator", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A manual measuring time tool in mass sporting competitions would not be\nimaginable nowadays, because many modern disciplines, such as IRONMAN, last a\nlong-time and, therefore, demand additional reliability. Moreover, automatic\ntiming-devices based on RFID technology, have become cheaper. However, these\ndevices cannot operate as stand-alone because they need a computer measuring\nsystem that is capable of processing incoming events, encoding the results,\nassigning them to the correct competitor, sorting the results according to the\nachieved times, and then providing a printout of the results. This article\npresents the domain-specific language EasyTime, which enables the controlling\nof an agent by writing the events within a database. It focuses, in particular,\non the implementation of EasyTime with a LISA tool that enables the automatic\nconstruction of compilers from language specifications, using Attribute\nGrammars.\n", "versions": [{"version": "v1", "created": "Sat, 9 Jun 2012 20:10:16 GMT"}], "update_date": "2012-06-12", "authors_parsed": [["Fister", "Iztok", "Jr."], ["Mernik", "Marjan", ""], ["Fister", "Iztok", ""], ["Hrn\u010di\u010d", "Dejan", ""]]}, {"id": "1206.2188", "submitter": "Damiano Zanardini", "authors": "Samir Genaim, Damiano Zanardini", "title": "Reachability-based Acyclicity Analysis by Abstract Interpretation", "comments": "38 pages (included proofs)", "journal-ref": "Theoretical Computer Science, 474(0), pages 60-79, 2013. Elsevier", "doi": "10.1016/j.tcs.2012.12.018", "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  In programming languages with dynamic use of memory, such as Java, knowing\nthat a reference variable x points to an acyclic data structure is valuable for\nthe analysis of termination and resource usage (e.g., execution time or memory\nconsumption). For instance, this information guarantees that the depth of the\ndata structure to which x points is greater than the depth of the data\nstructure pointed to by x.f for any field f of x. This, in turn, allows\nbounding the number of iterations of a loop which traverses the structure by\nits depth, which is essential in order to prove the termination or infer the\nresource usage of the loop. The present paper provides an\nAbstract-Interpretation-based formalization of a static analysis for inferring\nacyclicity, which works on the reduced product of two abstract domains:\nreachability, which models the property that the location pointed to by a\nvariable w can be reached by dereferencing another variable v (in this case, v\nis said to reach w); and cyclicity, modeling the property that v can point to a\ncyclic data structure. The analysis is proven to be sound and optimal with\nrespect to the chosen abstraction.\n", "versions": [{"version": "v1", "created": "Mon, 11 Jun 2012 12:56:28 GMT"}, {"version": "v2", "created": "Wed, 13 Feb 2013 13:00:37 GMT"}], "update_date": "2013-02-14", "authors_parsed": [["Genaim", "Samir", ""], ["Zanardini", "Damiano", ""]]}, {"id": "1206.2542", "submitter": "Iztok Fister", "authors": "Iztok Fister Jr, Marjan Mernik, Iztok Fister, Dejan Hrn\\v{c}i\\v{c}", "title": "Implementation of the Domain-Specific Language EasyTime using a LISA\n  Compiler Generator", "comments": "arXiv admin note: substantial text overlap with arXiv:1206.1969", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A manually time-measuring tool in mass sporting competitions cannot be\nimagined nowadays because many modern disciplines, such as IronMan, take a long\ntime and, therefore, demand additional reliability. Moreover, automatic timing\ndevices, based on RFID technology, have become cheaper. However, these devices\ncannot operate stand-alone because they need a computer measuring system that\nis capable of processing the incoming events, encoding the results, assigning\nthem to the correct competitor, sorting the results according to the achieved\ntimes, and then providing a printout of the results. In this article, the\ndomain-specific language EasyTime is presented, which enables the controlling\nof an agent by writing the events in a database. In particular, we are focused\non the implementation of EasyTime with a LISA tool that enables the automatic\nconstruction of compilers from language specifications using Attribute\nGrammars. By using of EasyTime, we can also decrease the number of measuring\ndevices. Furthermore, EasyTime is universal and can be applied to many\ndifferent sporting competitions in practice.\n", "versions": [{"version": "v1", "created": "Tue, 12 Jun 2012 14:25:17 GMT"}], "update_date": "2012-06-13", "authors_parsed": [["Fister", "Iztok", "Jr"], ["Mernik", "Marjan", ""], ["Fister", "Iztok", ""], ["Hrn\u010di\u010d", "Dejan", ""]]}, {"id": "1206.3182", "submitter": "Marco Roveri", "authors": "Alessandro Cimatti (Fondazione Bruno Kessler), Iman Narasamdya\n  (Fondazione Bruno Kessler), Marco Roveri (Fondazione Bruno Kessler)", "title": "Software Model Checking with Explicit Scheduler and Symbolic Threads", "comments": "40 pages, 10 figures, accepted for publication in journal of logical\n  methods in computer science", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 2 (August 5,\n  2012) lmcs:1032", "doi": "10.2168/LMCS-8(2:18)2012", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In many practical application domains, the software is organized into a set\nof threads, whose activation is exclusive and controlled by a cooperative\nscheduling policy: threads execute, without any interruption, until they either\nterminate or yield the control explicitly to the scheduler. The formal\nverification of such software poses significant challenges. On the one side,\neach thread may have infinite state space, and might call for abstraction. On\nthe other side, the scheduling policy is often important for correctness, and\nan approach based on abstracting the scheduler may result in loss of precision\nand false positives. Unfortunately, the translation of the problem into a\npurely sequential software model checking problem turns out to be highly\ninefficient for the available technologies. We propose a software model\nchecking technique that exploits the intrinsic structure of these programs.\nEach thread is translated into a separate sequential program and explored\nsymbolically with lazy abstraction, while the overall verification is\norchestrated by the direct execution of the scheduler. The approach is\noptimized by filtering the exploration of the scheduler with the integration of\npartial-order reduction. The technique, called ESST (Explicit Scheduler,\nSymbolic Threads) has been implemented and experimentally evaluated on a\nsignificant set of benchmarks. The results demonstrate that ESST technique is\nway more effective than software model checking applied to the sequentialized\nprograms, and that partial-order reduction can lead to further performance\nimprovements.\n", "versions": [{"version": "v1", "created": "Thu, 14 Jun 2012 17:07:19 GMT"}, {"version": "v2", "created": "Tue, 31 Jul 2012 07:04:37 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Cimatti", "Alessandro", "", "Fondazione Bruno Kessler"], ["Narasamdya", "Iman", "", "Fondazione Bruno Kessler"], ["Roveri", "Marco", "", "Fondazione Bruno Kessler"]]}, {"id": "1206.3255", "submitter": "Daniel Roy", "authors": "Noah Goodman, Vikash Mansinghka, Daniel M. Roy, Keith Bonawitz, Joshua\n  B. Tenenbaum", "title": "Church: a language for generative models", "comments": "Minor revisions. Fixed errors in author list", "journal-ref": null, "doi": null, "report-no": "UAI-P-2008-PG-220-229", "categories": "cs.PL cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce Church, a universal language for describing stochastic\ngenerative processes. Church is based on the Lisp model of lambda calculus,\ncontaining a pure Lisp as its deterministic subset. The semantics of Church is\ndefined in terms of evaluation histories and conditional distributions on such\nhistories. Church also includes a novel language construct, the stochastic\nmemoizer, which enables simple description of many complex non-parametric\nmodels. We illustrate language features through several examples, including: a\ngeneralized Bayes net in which parameters cluster over trials, infinite PCFGs,\nplanning by inference, and various non-parametric clustering models. Finally,\nwe show how to implement query on any Church program, exactly and\napproximately, using Monte Carlo techniques.\n", "versions": [{"version": "v1", "created": "Wed, 13 Jun 2012 15:30:30 GMT"}, {"version": "v2", "created": "Tue, 15 Jul 2014 08:32:38 GMT"}], "update_date": "2014-07-16", "authors_parsed": [["Goodman", "Noah", ""], ["Mansinghka", "Vikash", ""], ["Roy", "Daniel M.", ""], ["Bonawitz", "Keith", ""], ["Tenenbaum", "Joshua B.", ""]]}, {"id": "1206.3357", "submitter": "Andre Platzer", "authors": "Andre Platzer (Carnegie Mellon University)", "title": "A Complete Axiomatization of Quantified Differential Dynamic Logic for\n  Distributed Hybrid Systems", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 4 (November\n  26, 2012) lmcs:720", "doi": "10.2168/LMCS-8(4:17)2012", "report-no": null, "categories": "cs.LO cs.PL math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address a fundamental mismatch between the combinations of dynamics that\noccur in cyber-physical systems and the limited kinds of dynamics supported in\nanalysis. Modern applications combine communication, computation, and control.\nThey may even form dynamic distributed networks, where neither structure nor\ndimension stay the same while the system follows hybrid dynamics, i.e., mixed\ndiscrete and continuous dynamics. We provide the logical foundations for\nclosing this analytic gap. We develop a formal model for distributed hybrid\nsystems. It combines quantified differential equations with quantified\nassignments and dynamic dimensionality-changes. We introduce a dynamic logic\nfor verifying distributed hybrid systems and present a proof calculus for this\nlogic. This is the first formal verification approach for distributed hybrid\nsystems. We prove that our calculus is a sound and complete axiomatization of\nthe behavior of distributed hybrid systems relative to quantified differential\nequations. In our calculus we have proven collision freedom in distributed car\ncontrol even when an unbounded number of new cars may appear dynamically on the\nroad.\n", "versions": [{"version": "v1", "created": "Fri, 15 Jun 2012 01:33:02 GMT"}, {"version": "v2", "created": "Thu, 25 Oct 2012 16:12:28 GMT"}, {"version": "v3", "created": "Thu, 22 Nov 2012 14:10:00 GMT"}], "update_date": "2016-12-02", "authors_parsed": [["Platzer", "Andre", "", "Carnegie Mellon University"]]}, {"id": "1206.3523", "submitter": "Norman Danner", "authors": "N. Danner, J. Paykin, J. S. Royer", "title": "A static cost analysis for a higher-order language", "comments": "Final version", "journal-ref": "M. Might and D. V. Horn (eds.), Proceedings of the 7th workshop on\n  Programming languages meets program verification, pages 25-34. ACM Press,\n  2013", "doi": "10.1145/2428116.2428123", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a static complexity analysis for a higher-order functional\nlanguage with structural list recursion. The complexity of an expression is a\npair consisting of a cost and a potential. The former is defined to be the size\nof the expression's evaluation derivation in a standard big-step operational\nsemantics. The latter is a measure of the \"future\" cost of using the value of\nthat expression. A translation function tr maps target expressions to\ncomplexities. Our main result is the following Soundness Theorem: If t is a\nterm in the target language, then the cost component of tr(t) is an upper bound\non the cost of evaluating t. The proof of the Soundness Theorem is formalized\nin Coq, providing certified upper bounds on the cost of any expression in the\ntarget language.\n", "versions": [{"version": "v1", "created": "Fri, 15 Jun 2012 17:31:29 GMT"}, {"version": "v2", "created": "Tue, 9 Oct 2012 15:50:12 GMT"}, {"version": "v3", "created": "Wed, 19 Dec 2012 18:45:34 GMT"}], "update_date": "2013-05-29", "authors_parsed": [["Danner", "N.", ""], ["Paykin", "J.", ""], ["Royer", "J. S.", ""]]}, {"id": "1206.4234", "submitter": "David Monniaux", "authors": "Julien Henry (VERIMAG - IMAG), David Monniaux (VERIMAG - IMAG),\n  Matthieu Moy (VERIMAG - IMAG)", "title": "Succinct Representations for Abstract Interpretation", "comments": "Static analysis symposium (SAS), Deauville : France (2012)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Abstract interpretation techniques can be made more precise by distinguishing\npaths inside loops, at the expense of possibly exponential complexity.\nSMT-solving techniques and sparse representations of paths and sets of paths\navoid this pitfall. We improve previously proposed techniques for guided static\nanalysis and the generation of disjunctive invariants by combining them with\ntechniques for succinct representations of paths and symbolic representations\nfor transitions based on static single assignment. Because of the\nnon-monotonicity of the results of abstract interpretation with widening\noperators, it is difficult to conclude that some abstraction is more precise\nthan another based on theoretical local precision results. We thus conducted\nextensive comparisons between our new techniques and previous ones, on a\nvariety of open-source packages.\n", "versions": [{"version": "v1", "created": "Tue, 19 Jun 2012 15:20:30 GMT"}], "update_date": "2012-06-20", "authors_parsed": [["Henry", "Julien", "", "VERIMAG - IMAG"], ["Monniaux", "David", "", "VERIMAG - IMAG"], ["Moy", "Matthieu", "", "VERIMAG - IMAG"]]}, {"id": "1206.4833", "submitter": "Alo\\\"is Brunel", "authors": "Alo\\\"is Brunel and Antoine Madet", "title": "Indexed realizability for bounded-time programming with references and\n  type fixpoints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The field of implicit complexity has recently produced several\nbounded-complexity programming languages. This kind of language allows to\nimplement exactly the functions belonging to a certain complexity class. We\nhere present a realizability semantics for a higher-order functional language\nbased on a fragment of linear logic called LAL which characterizes the\ncomplexity class PTIME. This language features recursive types and higher-order\nstore. Our realizability is based on biorthogonality, step-indexing and is\nmoreover quantitative. This last feature enables us not only to derive a\nsemantical proof of termination, but also to give bounds on the number of\ncomputational steps needed by typed programs to terminate.\n", "versions": [{"version": "v1", "created": "Thu, 21 Jun 2012 11:09:02 GMT"}], "update_date": "2012-06-22", "authors_parsed": [["Brunel", "Alo\u00efs", ""], ["Madet", "Antoine", ""]]}, {"id": "1206.5112", "submitter": "Marcin  Benke", "authors": "Viviana Bono, Marcin Benke, Aleksy Schubert", "title": "Lucretia - a type system for objects in languages with reflection", "comments": "21 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Object-oriented scripting languages such as JavaScript or Python gain in\npopularity due to their flexibility. Still, the growing code bases written in\nthe languages call for methods that make possible to automatically control the\nproperties of the programs that ensure their stability in the running time. We\npropose a type system, called Lucretia, that makes possible to control the\nobject structure of languages with reflection. Subject reduction and soundness\nof the type system with respect to the semantics of the language is proved.\n", "versions": [{"version": "v1", "created": "Fri, 22 Jun 2012 11:07:14 GMT"}], "update_date": "2012-06-26", "authors_parsed": [["Bono", "Viviana", ""], ["Benke", "Marcin", ""], ["Schubert", "Aleksy", ""]]}, {"id": "1206.5386", "submitter": "Jana Dunfield", "authors": "Jana Dunfield", "title": "Elaborating Intersection and Union Types", "comments": "13 pages, 12 figures, to appear in International Conference on\n  Functional Programming (ICFP) 2012", "journal-ref": "J. Funct. Prog. 24 (2014) 133-165", "doi": "10.1017/S0956796813000270", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Designing and implementing typed programming languages is hard. Every new\ntype system feature requires extending the metatheory and implementation, which\nare often complicated and fragile. To ease this process, we would like to\nprovide general mechanisms that subsume many different features.\n  In modern type systems, parametric polymorphism is fundamental, but\nintersection polymorphism has gained little traction in programming languages.\nMost practical intersection type systems have supported only refinement\nintersections, which increase the expressiveness of types (more precise\nproperties can be checked) without altering the expressiveness of terms;\nrefinement intersections can simply be erased during compilation. In contrast,\nunrestricted intersections increase the expressiveness of terms, and can be\nused to encode diverse language features, promising an economy of both theory\nand implementation.\n  We describe a foundation for compiling unrestricted intersection and union\ntypes: an elaboration type system that generates ordinary lambda-calculus\nterms. The key feature is a Forsythe-like merge construct. With this construct,\nnot all reductions of the source program preserve types; however, we prove that\nordinary call-by-value evaluation of the elaborated program corresponds to a\ntype-preserving evaluation of the source program.\n  We also describe a prototype implementation and applications of unrestricted\nintersections and unions: records, operator overloading, and simulating dynamic\ntyping.\n", "versions": [{"version": "v1", "created": "Sat, 23 Jun 2012 12:25:22 GMT"}, {"version": "v2", "created": "Sat, 15 Aug 2020 17:10:09 GMT"}], "update_date": "2020-08-18", "authors_parsed": [["Dunfield", "Jana", ""]]}, {"id": "1206.5648", "submitter": "Carlo Alberto Furia", "authors": "Marco Trudel, Carlo A. Furia, Martin Nordio, Bertrand Meyer, Manuel\n  Oriol", "title": "C to O-O Translation: Beyond the Easy Stuff", "comments": null, "journal-ref": "Proceedings of the 19th Working Conference on Reverse Engineering\n  (WCRE'12). Pgg. 19--28, IEEE Computer Society, October 2012", "doi": "10.1109/WCRE.2012.12", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Can we reuse some of the huge code-base developed in C to take advantage of\nmodern programming language features such as type safety, object-orientation,\nand contracts? This paper presents a source-to-source translation of C code\ninto Eiffel, a modern object-oriented programming language, and the supporting\ntool C2Eif. The translation is completely automatic and supports the entire C\nlanguage (ANSI, as well as many GNU C Compiler extensions, through CIL) as used\nin practice, including its usage of native system libraries and inlined\nassembly code. Our experiments show that C2Eif can handle C applications and\nlibraries of significant size (such as vim and libgsl), as well as challenging\nbenchmarks such as the GCC torture tests. The produced Eiffel code is\nfunctionally equivalent to the original C code, and takes advantage of some of\nEiffel's object-oriented features to produce safe and easy-to-debug\ntranslations.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jun 2012 11:20:33 GMT"}, {"version": "v2", "created": "Thu, 30 Aug 2012 11:56:05 GMT"}, {"version": "v3", "created": "Thu, 19 Sep 2013 15:23:12 GMT"}], "update_date": "2013-09-20", "authors_parsed": [["Trudel", "Marco", ""], ["Furia", "Carlo A.", ""], ["Nordio", "Martin", ""], ["Meyer", "Bertrand", ""], ["Oriol", "Manuel", ""]]}, {"id": "1206.6098", "submitter": "EPTCS", "authors": "Adrien Basso-Blandin (IBISC Lab), Franck Delaplace (IBISC Lab)", "title": "GUBS, a Behavior-based Language for Open System Dedicated to Synthetic\n  Biology", "comments": "In Proceedings MeCBIC 2012, arXiv:1211.3476", "journal-ref": "EPTCS 100, 2012, pp. 29-47", "doi": "10.4204/EPTCS.100.3", "report-no": null, "categories": "cs.PL cs.CE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this article, we propose a domain specific language, GUBS (Genomic Unified\nBehavior Specification), dedicated to the behavioral specification of synthetic\nbiological devices, viewed as discrete open dynamical systems. GUBS is a\nrule-based declarative language. By contrast to a closed system, a program is\nalways a partial description of the behavior of the system. The semantics of\nthe language accounts the existence of some hidden non-specified actions\npossibly altering the behavior of the programmed device. The compilation\nframework follows a scheme similar to automatic theorem proving, aiming at\nimproving synthetic biological design safety.\n", "versions": [{"version": "v1", "created": "Tue, 26 Jun 2012 19:56:41 GMT"}, {"version": "v2", "created": "Mon, 19 Nov 2012 00:07:07 GMT"}], "update_date": "2012-11-20", "authors_parsed": [["Basso-Blandin", "Adrien", "", "IBISC Lab"], ["Delaplace", "Franck", "", "IBISC Lab"]]}, {"id": "1206.6466", "submitter": "Lawrence McAfee", "authors": "Lawrence McAfee (Stanford University), Kunle Olukotun (Stanford\n  University)", "title": "Utilizing Static Analysis and Code Generation to Accelerate Neural\n  Networks", "comments": "Appears in Proceedings of the 29th International Conference on\n  Machine Learning (ICML 2012)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NE cs.MS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As datasets continue to grow, neural network (NN) applications are becoming\nincreasingly limited by both the amount of available computational power and\nthe ease of developing high-performance applications. Researchers often must\nhave expert systems knowledge to make their algorithms run efficiently.\nAlthough available computing power increases rapidly each year, algorithm\nefficiency is not able to keep pace due to the use of general purpose\ncompilers, which are not able to fully optimize specialized application\ndomains. Within the domain of NNs, we have the added knowledge that network\narchitecture remains constant during training, meaning the architecture's data\nstructure can be statically optimized by a compiler. In this paper, we present\nSONNC, a compiler for NNs that utilizes static analysis to generate optimized\nparallel code. We show that SONNC's use of static optimizations make it able to\noutperform hand-optimized C++ code by up to 7.8X, and MATLAB code by up to 24X.\nAdditionally, we show that use of SONNC significantly reduces code complexity\nwhen using structurally sparse networks.\n", "versions": [{"version": "v1", "created": "Wed, 27 Jun 2012 19:59:59 GMT"}], "update_date": "2012-07-03", "authors_parsed": [["McAfee", "Lawrence", "", "Stanford University"], ["Olukotun", "Kunle", "", "Stanford\n  University"]]}]