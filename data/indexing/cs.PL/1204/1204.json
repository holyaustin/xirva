[{"id": "1204.0221", "submitter": "Youssef Bassil", "authors": "Youssef Bassil, Aziz Barbar", "title": "MyProLang - My Programming Language: A Template-Driven Automatic Natural\n  Programming Language", "comments": "WCECS 2008, October 22-24, 2008, San Francisco, USA", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modern computer programming languages are governed by complex syntactic\nrules. They are unlike natural languages; they require extensive manual work\nand a significant amount of learning and practicing for an individual to become\nskilled at and to write correct programs. Computer programming is a difficult,\ncomplicated, unfamiliar, non-automated, and a challenging discipline for\neveryone; especially, for students, new programmers and end-users. This paper\nproposes a new programming language and an environment for writing computer\napplications based on source-code generation. It is mainly a template-driven\nautomatic natural imperative programming language called MyProLang. It\nharnesses GUI templates to generate proprietary natural language source-code,\ninstead of having computer programmers write the code manually. MyProLang is a\nblend of five elements. A proprietary natural programming language with\nunsophisticated grammatical rules and expressive syntax; automation templates\nthat automate the generation of instructions and thereby minimizing the\nlearning and training time; an NLG engine to generate natural instructions; a\nsource-to-source compiler that analyzes, parses, and build executables; and an\nergonomic IDE that houses diverse functions whose role is to simplify the\nsoftware development process. MyProLang is expected to make programming open to\neveryone including students, programmers and end-users. In that sense, anyone\ncan start programming systematically, in an automated manner and in natural\nlanguage; without wasting time in learning how to formulate instructions and\narrange expressions, without putting up with unfamiliar structures and symbols,\nand without being annoyed by syntax errors. In the long run, this increases the\nproductivity, quality and time-to-market in software development.\n", "versions": [{"version": "v1", "created": "Sun, 1 Apr 2012 15:35:11 GMT"}], "update_date": "2012-04-03", "authors_parsed": [["Bassil", "Youssef", ""], ["Barbar", "Aziz", ""]]}, {"id": "1204.1147", "submitter": "Thomas Martin Gawlitza", "authors": "Thomas Martin Gawlitza and Helmut Seidl", "title": "Numerical Invariants through Convex Relaxation and Max-Strategy\n  Iteration", "comments": "42 pages, conference version appears in the proceedings of the Static\n  Analysis Symposium 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this article we develop a max-strategy improvement algorithm for computing\nleast fixpoints of operators on on the reals that are point-wise maxima of\nfinitely many monotone and order-concave operators. Computing the uniquely\ndetermined least fixpoint of such operators is a problem that occurs frequently\nin the context of numerical program/systems verification/analysis. As an\nexample for an application we discuss how our algorithm can be applied to\ncompute numerical invariants of programs by abstract interpretation based on\nquadratic templates.\n", "versions": [{"version": "v1", "created": "Thu, 5 Apr 2012 08:33:16 GMT"}], "update_date": "2012-04-06", "authors_parsed": [["Gawlitza", "Thomas Martin", ""], ["Seidl", "Helmut", ""]]}, {"id": "1204.1568", "submitter": "Georg Moser", "authors": "Georg Moser and Michael Schaper", "title": "A Complexity Preserving Transformation from Jinja Bytecode to Rewrite\n  Systems", "comments": "36 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  We revisit known transformations from Jinja bytecode to rewrite systems from\nthe viewpoint of runtime complexity. Suitably generalising the constructions\nproposed in the literature, we define an alternative representation of Jinja\nbytecode (JBC) executions as \"computation graphs\" from which we obtain a novel\nrepresentation of JBC executions as \"constrained rewrite systems\". We prove\nnon-termination and complexity preservation of the transformation. We restrict\nto well-formed JBC programs that only make use of non-recursive methods and\nexpect tree-shaped objects as input. Our approach allows for simplified\ncorrectness proofs and provides a framework for the combination of the\ncomputation graph method with standard techniques from static program analysis\nlike for example \"reachability analysis\".\n", "versions": [{"version": "v1", "created": "Fri, 6 Apr 2012 21:38:22 GMT"}, {"version": "v2", "created": "Tue, 10 Apr 2012 00:33:09 GMT"}, {"version": "v3", "created": "Thu, 7 Feb 2013 11:54:48 GMT"}, {"version": "v4", "created": "Thu, 25 Apr 2013 23:30:32 GMT"}, {"version": "v5", "created": "Tue, 6 May 2014 14:35:23 GMT"}], "update_date": "2014-05-07", "authors_parsed": [["Moser", "Georg", ""], ["Schaper", "Michael", ""]]}, {"id": "1204.1751", "submitter": "Rishabh Singh", "authors": "Rishabh Singh, Sumit Gulwani and Armando Solar-Lezama", "title": "Automated Feedback Generation for Introductory Programming Assignments", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new method for automatically providing feedback for introductory\nprogramming problems. In order to use this method, we need a reference\nimplementation of the assignment, and an error model consisting of potential\ncorrections to errors that students might make. Using this information, the\nsystem automatically derives minimal corrections to student's incorrect\nsolutions, providing them with a quantifiable measure of exactly how incorrect\na given solution was, as well as feedback about what they did wrong.\n  We introduce a simple language for describing error models in terms of\ncorrection rules, and formally define a rule-directed translation strategy that\nreduces the problem of finding minimal corrections in an incorrect program to\nthe problem of synthesizing a correct program from a sketch. We have evaluated\nour system on thousands of real student attempts obtained from 6.00 and 6.00x.\nOur results show that relatively simple error models can correct on average 65%\nof all incorrect submissions.\n", "versions": [{"version": "v1", "created": "Sun, 8 Apr 2012 18:08:43 GMT"}, {"version": "v2", "created": "Sat, 2 Jun 2012 04:29:05 GMT"}, {"version": "v3", "created": "Thu, 26 Jul 2012 03:41:50 GMT"}, {"version": "v4", "created": "Fri, 16 Nov 2012 06:31:27 GMT"}], "update_date": "2012-11-19", "authors_parsed": [["Singh", "Rishabh", ""], ["Gulwani", "Sumit", ""], ["Solar-Lezama", "Armando", ""]]}, {"id": "1204.2203", "submitter": "Istvan David", "authors": "Istvan David", "title": "A model-driven approach for processing complex events", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  By adequate employing of complex event processing (CEP), valuable information\ncan be extracted from the underlying complex system and used in controlling and\ndecision situations. An example application area is management of IT systems\nfor maintaining required dependability attributes of services based on the\ninfrastructure. In practice, one usually faces the problem of the vast number\nof distributed event sources, which makes depicting complex event patterns a\nnon-trivial task. In this paper, I present a novel, model-driven approach to\ndefine complex event patterns and directly generate event processing\nconfiguration for an open source CEP engine widely used in the industry. One of\nthe key results of my research work is a textual modeling language called\nComplex Event Description Language (CEDL), which will be presented by its\nalgebraic semantics and some typical examples.\n", "versions": [{"version": "v1", "created": "Tue, 10 Apr 2012 16:03:12 GMT"}, {"version": "v2", "created": "Thu, 26 Apr 2012 15:43:56 GMT"}, {"version": "v3", "created": "Wed, 1 Aug 2012 17:33:53 GMT"}], "update_date": "2012-08-02", "authors_parsed": [["David", "Istvan", ""]]}, {"id": "1204.2566", "submitter": "Julien Lange", "authors": "Julien Lange and Emilio Tuosto", "title": "Synthesising Choreographies from Local Session Types (extended version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Designing and analysing multiparty distributed interactions can be achieved\neither by means of a global view (e.g. in choreography-based approaches) or by\ncomposing available computational entities (e.g. in service orchestration).\nThis paper proposes a typing systems which allows, under some conditions, to\nsynthesise a choreography (i.e. a multiparty global type) from a set of local\nsession types which describe end-point behaviours (i.e. local types).\n", "versions": [{"version": "v1", "created": "Wed, 11 Apr 2012 20:52:29 GMT"}], "update_date": "2012-04-13", "authors_parsed": [["Lange", "Julien", ""], ["Tuosto", "Emilio", ""]]}, {"id": "1204.4322", "submitter": "David Pichardie", "authors": "Thomas Jensen (INRIA Rennes), Florent Kirchner (INRIA Rennes), David\n  Pichardie (INRIA Rennes)", "title": "Secure the Clones", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 2 (May 31,\n  2012) lmcs:801", "doi": "10.2168/LMCS-8(2:5)2012", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Exchanging mutable data objects with untrusted code is a delicate matter\nbecause of the risk of creating a data space that is accessible by an attacker.\nConsequently, secure programming guidelines for Java stress the importance of\nusing defensive copying before accepting or handing out references to an\ninternal mutable object. However, implementation of a copy method (like\nclone()) is entirely left to the programmer. It may not provide a sufficiently\ndeep copy of an object and is subject to overriding by a malicious sub-class.\nCurrently no language-based mechanism supports secure object cloning. This\npaper proposes a type-based annotation system for defining modular copy\npolicies for class-based object-oriented programs. A copy policy specifies the\nmaximally allowed sharing between an object and its clone. We present a static\nenforcement mechanism that will guarantee that all classes fulfil their copy\npolicy, even in the presence of overriding of copy methods, and establish the\nsemantic correctness of the overall approach in Coq. The mechanism has been\nimplemented and experimentally evaluated on clone methods from several Java\nlibraries.\n", "versions": [{"version": "v1", "created": "Thu, 19 Apr 2012 11:49:03 GMT"}, {"version": "v2", "created": "Wed, 30 May 2012 19:21:46 GMT"}, {"version": "v3", "created": "Mon, 4 Jun 2012 10:04:07 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Jensen", "Thomas", "", "INRIA Rennes"], ["Kirchner", "Florent", "", "INRIA Rennes"], ["Pichardie", "David", "", "INRIA Rennes"]]}, {"id": "1204.4804", "submitter": "Josh Berdine", "authors": "Josh Berdine, Cristiano Calcagno, Peter W. O'Hearn", "title": "Verification Condition Generation and Variable Conditions in Smallfoot", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  These notes are a companion to [1] which describe - the variable conditions\nthat Smallfoot checks, - the analysis used to check them, - the algorithm used\nto compute a set of verification conditions corresponding to an annotated\nprogram, and - the treatment of concurrent resource initialization code.\n", "versions": [{"version": "v1", "created": "Sat, 21 Apr 2012 11:46:38 GMT"}], "update_date": "2012-04-24", "authors_parsed": [["Berdine", "Josh", ""], ["Calcagno", "Cristiano", ""], ["O'Hearn", "Peter W.", ""]]}, {"id": "1204.5280", "submitter": "Pierre Deransart", "authors": "Armando Gon\\c{c}alves Da Silva Junior (CIn), Pierre Deransart (INRIA\n  Rocquencourt), Luis-Carlos Menezes (CIn), Marcos-Aur\\'elio Almeida Da Silva\n  (LPMC), Jacques Robin (TRT)", "title": "Towards a Generic Trace for Rule Based Constraint Reasoning", "comments": null, "journal-ref": "N&deg; RR-7939 (2012)", "doi": null, "report-no": "RR-7939", "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  CHR is a very versatile programming language that allows programmers to\ndeclaratively specify constraint solvers. An important part of the development\nof such solvers is in their testing and debugging phases. Current CHR\nimplementations support those phases by offering tracing facilities with\nlimited information. In this report, we propose a new trace for CHR which\ncontains enough information to analyze any aspects of \\CHRv\\ execution at some\nuseful abstract level, common to several implementations. %a large family of\nrule based solvers. This approach is based on the idea of generic trace. Such a\ntrace is formally defined as an extension of the $\\omega_r^\\lor$ semantics of\nCHR. We show that it can be derived form the SWI Prolog CHR trace.\n", "versions": [{"version": "v1", "created": "Tue, 24 Apr 2012 06:57:10 GMT"}], "update_date": "2012-04-25", "authors_parsed": [["Junior", "Armando Gon\u00e7alves Da Silva", "", "CIn"], ["Deransart", "Pierre", "", "INRIA\n  Rocquencourt"], ["Menezes", "Luis-Carlos", "", "CIn"], ["Da Silva", "Marcos-Aur\u00e9lio Almeida", "", "LPMC"], ["Robin", "Jacques", "", "TRT"]]}, {"id": "1204.5318", "submitter": "EPTCS", "authors": "Santiago Escobar (Universitat Polit\\`ecnica de Val\\`encia)", "title": "Proceedings 10th International Workshop on Reduction Strategies in\n  Rewriting and Programming", "comments": null, "journal-ref": "EPTCS 82, 2012", "doi": "10.4204/EPTCS.82", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains a selection of the papers presented at the 10th\nInternational Workshop on Reduction Strategies in Rewriting and Programming\n(WRS'2011), held on 29 May 2011 in Novi Sad, Serbia. Previous editions of the\nworkshop were held in Utrecht (2001), Copenhagen (2002), Valencia (2003),\nAachen (2004), Nara (2005), Seattle (2006), Paris (2007), Hagenberg (2008),\nBrasilia (2009), and Edinburgh (2010); the last one as a joint workshop with\nthe STRATEGIES workshop.\n  The WRS 2011 workshop was part of the Federated Conference on Rewriting,\nDeduction, and Programming (RDP'1), which grouped together different events\nincluding the 22th International Conference on Rewriting Techniques and\nApplications (RTA'11) and the 10th International Conference on Typed Lambda\nCalculi and Applications (TLCA'11).\n", "versions": [{"version": "v1", "created": "Tue, 24 Apr 2012 09:29:14 GMT"}], "update_date": "2012-04-25", "authors_parsed": [["Escobar", "Santiago", "", "Universitat Polit\u00e8cnica de Val\u00e8ncia"]]}, {"id": "1204.5541", "submitter": "EPTCS", "authors": "Detlef Plump (The University of York)", "title": "The Design of GP 2", "comments": "In Proceedings WRS 2011, arXiv:1204.5318", "journal-ref": "EPTCS 82, 2012, pp. 1-16", "doi": "10.4204/EPTCS.82.1", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This papers defines the syntax and semantics of GP 2, a revised version of\nthe graph programming language GP. New concepts are illustrated and explained\nwith example programs. Changes to the first version of GP include an improved\ntype system for labels, a built-in marking mechanism for nodes and edges, a\nmore powerful edge predicate for conditional rule schemata, and functions\nreturning the indegree and outdegree of matched nodes. Moreover, the semantics\nof the branching and loop statement have been simplified to allow their\nefficient implementation.\n", "versions": [{"version": "v1", "created": "Wed, 25 Apr 2012 02:41:47 GMT"}], "update_date": "2012-04-26", "authors_parsed": [["Plump", "Detlef", "", "The University of York"]]}, {"id": "1204.5542", "submitter": "EPTCS", "authors": "Alberto Verdejo (Universidad Complutense de Madrid), Narciso\n  Mart\\'i-Oliet (Universidad Complutense de Madrid)", "title": "Basic completion strategies as another application of the Maude strategy\n  language", "comments": "In Proceedings WRS 2011, arXiv:1204.5318", "journal-ref": "EPTCS 82, 2012, pp. 17-36", "doi": "10.4204/EPTCS.82.2", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The two levels of data and actions on those data provided by the separation\nbetween equations and rules in rewriting logic are completed by a third level\nof strategies to control the application of those actions. This level is\nimplemented on top of Maude as a strategy language, which has been successfully\nused in a wide range of applications. First we summarize the Maude strategy\nlanguage design and review some of its applications; then, we describe a new\ncase study, namely the description of completion procedures as transition rules\n+ control, as proposed by Lescanne.\n", "versions": [{"version": "v1", "created": "Wed, 25 Apr 2012 02:41:54 GMT"}], "update_date": "2012-04-26", "authors_parsed": [["Verdejo", "Alberto", "", "Universidad Complutense de Madrid"], ["Mart\u00ed-Oliet", "Narciso", "", "Universidad Complutense de Madrid"]]}, {"id": "1204.5543", "submitter": "EPTCS", "authors": "Walid Belkhir (University of Franche-Comt\\'e), Alain Giorgetti\n  (University of Franche-Comt\\'e)", "title": "Lazy AC-Pattern Matching for Rewriting", "comments": "In Proceedings WRS 2011, arXiv:1204.5318", "journal-ref": "EPTCS 82, 2012, pp. 37-51", "doi": "10.4204/EPTCS.82.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define a lazy pattern-matching mechanism modulo associativity and\ncommutativity. The solutions of a pattern-matching problem are stored in a lazy\nlist composed of a first substitution at the head and a non-evaluated object\nthat encodes the remaining computations. We integrate the lazy AC-matching in a\nstrategy language: rewriting rule and strategy application produce a lazy list\nof terms.\n", "versions": [{"version": "v1", "created": "Wed, 25 Apr 2012 02:42:03 GMT"}], "update_date": "2012-04-26", "authors_parsed": [["Belkhir", "Walid", "", "University of Franche-Comt\u00e9"], ["Giorgetti", "Alain", "", "University of Franche-Comt\u00e9"]]}, {"id": "1204.5544", "submitter": "EPTCS", "authors": "Matthias Raffelsieper (TU Eindhoven)", "title": "Productivity of Non-Orthogonal Term Rewrite Systems", "comments": "In Proceedings WRS 2011, arXiv:1204.5318", "journal-ref": "EPTCS 82, 2012, pp. 53-67", "doi": "10.4204/EPTCS.82.4", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Productivity is the property that finite prefixes of an infinite constructor\nterm can be computed using a given term rewrite system. Hitherto, productivity\nhas only been considered for orthogonal systems, where non-determinism is not\nallowed. This paper presents techniques to also prove productivity of\nnon-orthogonal term rewrite systems. For such systems, it is desired that one\ndoes not have to guess the reduction steps to perform, instead any\noutermost-fair reduction should compute an infinite constructor term in the\nlimit. As a main result, it is shown that for possibly non-orthogonal term\nrewrite systems this kind of productivity can be concluded from\ncontext-sensitive termination. This result can be applied to prove\nstabilization of digital circuits, as will be illustrated by means of an\nexample.\n", "versions": [{"version": "v1", "created": "Wed, 25 Apr 2012 02:42:12 GMT"}], "update_date": "2012-04-26", "authors_parsed": [["Raffelsieper", "Matthias", "", "TU Eindhoven"]]}, {"id": "1204.5545", "submitter": "EPTCS", "authors": "Hans Zantema (University of Technology Eindhoven)", "title": "Strategy Independent Reduction Lengths in Rewriting and Binary\n  Arithmetic", "comments": "In Proceedings WRS 2011, arXiv:1204.5318", "journal-ref": "EPTCS 82, 2012, pp. 69-76", "doi": "10.4204/EPTCS.82.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we give a criterion by which one can conclude that every\nreduction of a basic term to normal form has the same length. As a consequence,\nthe number of steps to reach the normal form is independent of the chosen\nstrategy. In particular this holds for TRSs computing addition and\nmultiplication of natural numbers, both in unary and binary notation.\n", "versions": [{"version": "v1", "created": "Wed, 25 Apr 2012 02:42:18 GMT"}], "update_date": "2012-04-26", "authors_parsed": [["Zantema", "Hans", "", "University of Technology Eindhoven"]]}, {"id": "1204.6411", "submitter": "Wolfgang Slany", "authors": "Wolfgang Slany", "title": "Catroid: A Mobile Visual Programming System for Children", "comments": "4 pages. Demo paper at the 11th International Conference on\n  Interaction Design and Children (IDC 2012)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CY cs.HC cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Catroid is a free and open source visual programming language, programming\nenvironment, image manipulation program, and website. Catroid allows casual and\nfirst-time users starting from age eight to develop their own animations and\ngames solely using their Android phones or tablets. Catroid also allows to\nwirelessly control external hardware such as Lego Mindstorms robots via\nBluetooth, Bluetooth Arduino boards, as well as Parrot's popular and\ninexpensive AR.Drone quadcopters via WiFi.\n", "versions": [{"version": "v1", "created": "Sat, 28 Apr 2012 14:26:56 GMT"}], "update_date": "2012-05-01", "authors_parsed": [["Slany", "Wolfgang", ""]]}, {"id": "1204.6492", "submitter": "Fernando Brito e Abreu", "authors": "Tiago Pessoa, Fernando Brito e Abreu, Miguel Pessoa Monteiro, Sergio\n  Bryton", "title": "An Eclipse Plugin to Support Code Smells Detection", "comments": "12 pages, 7 figures", "journal-ref": "INFORUM'2011 conference proceedings, Luis Caires e Raul Barbosa\n  (eds.), 8-9 September, Coimbra, Portugal, 2011", "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Eradication of code smells is often pointed out as a way to improve\nreadability, extensibility and design in existing software. However, code smell\ndetection in large systems remains time consuming and error-prone, partly due\nto the inherent subjectivity of the detection processes presently available. In\nview of mitigating the subjectivity problem, this paper presents a tool that\nautomates a technique for the detection and assessment of code smells in Java\nsource code, developed as an Eclipse plug-in. The technique is based upon a\nBinary Logistic Regression model and calibrated by expert's knowledge. A short\noverview of the technique is provided and the tool is described.\n", "versions": [{"version": "v1", "created": "Sun, 29 Apr 2012 16:33:53 GMT"}], "update_date": "2012-05-01", "authors_parsed": [["Pessoa", "Tiago", ""], ["Abreu", "Fernando Brito e", ""], ["Monteiro", "Miguel Pessoa", ""], ["Bryton", "Sergio", ""]]}]