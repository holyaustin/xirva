[{"id": "1111.0041", "submitter": "R. H. Bordini", "authors": "R. H. Bordini, A. F. Moreira, R. Vieira, M. Wooldridge", "title": "On the Formal Semantics of Speech-Act Based Communication in an\n  Agent-Oriented Programming Language", "comments": null, "journal-ref": "Journal Of Artificial Intelligence Research, Volume 29, pages\n  221-267, 2007", "doi": "10.1613/jair.2221", "report-no": null, "categories": "cs.AI cs.MA cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Research on agent communication languages has typically taken the speech acts\nparadigm as its starting point. Despite their manifest attractions, speech-act\nmodels of communication have several serious disadvantages as a foundation for\ncommunication in artificial agent systems. In particular, it has proved to be\nextremely difficult to give a satisfactory semantics to speech-act based agent\ncommunication languages. In part, the problem is that speech-act semantics\ntypically make reference to the \"mental states\" of agents (their beliefs,\ndesires, and intentions), and there is in general no way to attribute such\nattitudes to arbitrary computational agents. In addition, agent programming\nlanguages have only had their semantics formalised for abstract, stand-alone\nversions, neglecting aspects such as communication primitives. With respect to\ncommunication, implemented agent programming languages have tended to be rather\nad hoc. This paper addresses both of these problems, by giving semantics to\nspeech-act based messages received by an AgentSpeak agent. AgentSpeak is a\nlogic-based agent programming language which incorporates the main features of\nthe PRS model of reactive planning systems. The paper builds upon a structural\noperational semantics to AgentSpeak that we developed in previous work. The\nmain contributions of this paper are as follows: an extension of our earlier\nwork on the theoretical foundations of AgentSpeak interpreters; a\ncomputationally grounded semantics for (the core) performatives used in\nspeech-act based agent communication languages; and a well-defined extension of\nAgentSpeak that supports agent communication.\n", "versions": [{"version": "v1", "created": "Mon, 31 Oct 2011 21:40:21 GMT"}], "update_date": "2011-11-02", "authors_parsed": [["Bordini", "R. H.", ""], ["Moreira", "A. F.", ""], ["Vieira", "R.", ""], ["Wooldridge", "M.", ""]]}, {"id": "1111.0085", "submitter": "EPTCS", "authors": "Andreas Abel (LMU Munich), Nicolai Kraus (University of Nottingham)", "title": "A Lambda Term Representation Inspired by Linear Ordered Logic", "comments": "In Proceedings LFMTP 2011, arXiv:1110.6685", "journal-ref": "EPTCS 71, 2011, pp. 1-13", "doi": "10.4204/EPTCS.71.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new nameless representation of lambda terms inspired by\nordered logic. At a lambda abstraction, number and relative position of all\noccurrences of the bound variable are stored, and application carries the\nadditional information where to cut the variable context into function and\nargument part. This way, complete information about free variable occurrence is\navailable at each subterm without requiring a traversal, and environments can\nbe kept exact such that they only assign values to variables that actually\noccur in the associated term. Our approach avoids space leaks in interpreters\nthat build function closures.\n  In this article, we prove correctness of the new representation and present\nan experimental evaluation of its performance in a proof checker for the\nEdinburgh Logical Framework.\n  Keywords: representation of binders, explicit substitutions, ordered\ncontexts, space leaks, Logical Framework.\n", "versions": [{"version": "v1", "created": "Tue, 1 Nov 2011 00:17:57 GMT"}], "update_date": "2011-11-02", "authors_parsed": [["Abel", "Andreas", "", "LMU Munich"], ["Kraus", "Nicolai", "", "University of Nottingham"]]}, {"id": "1111.0087", "submitter": "EPTCS", "authors": "Mathieu Boespflug (McGill University), Brigitte Pientka (McGill\n  University)", "title": "Multi-level Contextual Type Theory", "comments": "In Proceedings LFMTP 2011, arXiv:1110.6685", "journal-ref": "EPTCS 71, 2011, pp. 29-43", "doi": "10.4204/EPTCS.71.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Contextual type theory distinguishes between bound variables and\nmeta-variables to write potentially incomplete terms in the presence of\nbinders. It has found good use as a framework for concise explanations of\nhigher-order unification, characterize holes in proofs, and in developing a\nfoundation for programming with higher-order abstract syntax, as embodied by\nthe programming and reasoning environment Beluga. However, to reason about\nthese applications, we need to introduce meta^2-variables to characterize the\ndependency on meta-variables and bound variables. In other words, we must go\nbeyond a two-level system granting only bound variables and meta-variables.\n  In this paper we generalize contextual type theory to n levels for arbitrary\nn, so as to obtain a formal system offering bound variables, meta-variables and\nso on all the way to meta^n-variables. We obtain a uniform account by\ncollapsing all these different kinds of variables into a single notion of\nvariabe indexed by some level k. We give a decidable bi-directional type system\nwhich characterizes beta-eta-normal forms together with a generalized\nsubstitution operation.\n", "versions": [{"version": "v1", "created": "Tue, 1 Nov 2011 00:18:10 GMT"}], "update_date": "2011-11-02", "authors_parsed": [["Boespflug", "Mathieu", "", "McGill University"], ["Pientka", "Brigitte", "", "McGill\n  University"]]}, {"id": "1111.0089", "submitter": "EPTCS", "authors": "Murdoch J. Gabbay, Dominic P. Mulligan", "title": "Nominal Henkin Semantics: simply-typed lambda-calculus models in nominal\n  sets", "comments": "In Proceedings LFMTP 2011, arXiv:1110.6685", "journal-ref": "EPTCS 71, 2011, pp. 58-75", "doi": "10.4204/EPTCS.71.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate a class of nominal algebraic Henkin-style models for the\nsimply typed lambda-calculus in which variables map to names in the denotation\nand lambda-abstraction maps to a (non-functional) name-abstraction operation.\nThe resulting denotations are smaller and better-behaved, in ways we make\nprecise, than functional valuation-based models.\n  Using these new models, we then develop a generalisation of \\lambda-term\nsyntax enriching them with existential meta-variables, thus yielding a theory\nof incomplete functions. This incompleteness is orthogonal to the usual notion\nof incompleteness given by function abstraction and application, and\ncorresponds to holes and incomplete objects.\n", "versions": [{"version": "v1", "created": "Tue, 1 Nov 2011 00:18:23 GMT"}], "update_date": "2011-11-02", "authors_parsed": [["Gabbay", "Murdoch J.", ""], ["Mulligan", "Dominic P.", ""]]}, {"id": "1111.0090", "submitter": "EPTCS", "authors": "Alan J. Martin (University of Ottawa), Amy P. Felty (University of\n  Ottawa)", "title": "An Improved Implementation and Abstract Interface for Hybrid", "comments": "In Proceedings LFMTP 2011, arXiv:1110.6685", "journal-ref": "EPTCS 71, 2011, pp. 76-90", "doi": "10.4204/EPTCS.71.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hybrid is a formal theory implemented in Isabelle/HOL that provides an\ninterface for representing and reasoning about object languages using\nhigher-order abstract syntax (HOAS). This interface is built around an HOAS\nvariable-binding operator that is constructed definitionally from a de Bruijn\nindex representation. In this paper we make a variety of improvements to\nHybrid, culminating in an abstract interface that on one hand makes Hybrid a\nmore mathematically satisfactory theory, and on the other hand has important\npractical benefits. We start with a modification of Hybrid's type of terms that\nbetter hides its implementation in terms of de Bruijn indices, by excluding at\nthe type level terms with dangling indices. We present an improved set of\ndefinitions, and a series of new lemmas that provide a complete\ncharacterization of Hybrid's primitives in terms of properties stated at the\nHOAS level. Benefits of this new package include a new proof of adequacy and\nimprovements to reasoning about object logics. Such proofs are carried out at\nthe higher level with no involvement of the lower level de Bruijn syntax.\n", "versions": [{"version": "v1", "created": "Tue, 1 Nov 2011 00:18:29 GMT"}], "update_date": "2011-11-02", "authors_parsed": [["Martin", "Alan J.", "", "University of Ottawa"], ["Felty", "Amy P.", "", "University of\n  Ottawa"]]}, {"id": "1111.3606", "submitter": "Hamid A. Toussi", "authors": "Hamid A. Toussi", "title": "tym: Typed Matlab", "comments": "Presented at University of Sistan and Baluchestan, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Although, many scientists and engineers use Octave or MATLAB as their\npreferred programming language, dynamic nature of these languages can lead to\nslower running-time of programs written in these languages compared to programs\nwritten in languages which are not as dynamic, like C, C++ and Fortran. In this\nwork we developed a translator for a new programming language (tym) which tries\nto address performance issues, common in scientific programs, by adding new\nconstructs to a subset of Octave/MATLAB language. Our translator compiles\nprograms written in tym, to efficient C++ code.\n", "versions": [{"version": "v1", "created": "Tue, 15 Nov 2011 18:32:29 GMT"}, {"version": "v2", "created": "Thu, 10 Jan 2013 19:28:21 GMT"}, {"version": "v3", "created": "Thu, 12 Feb 2015 13:12:12 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Toussi", "Hamid A.", ""]]}, {"id": "1111.3673", "submitter": "Zolt\\'an K\\'asa", "authors": "N. Pataki", "title": "C++ Standard Template Library by template specialized containers", "comments": null, "journal-ref": "Acta Univ. Sapientiae, Inform. 3,2 (2011) 141--157", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The C++ Standard Template Library is the flagship example for libraries based\non the generic programming paradigm. The usage of this library is intended to\nminimize the number of classical C/C++ errors, but does not warrant bug-free\nprograms. Furthermore, many new kinds of errors may arise from the inaccurate\nuse of the generic programming paradigm, like dereferencing invalid iterators\nor misunderstanding remove-like algorithms. In this paper we present some\ntypical scenarios that may cause runtime or portability problems. We emit\nwarnings and errors while these risky constructs are used. We also present a\ngeneral approach to emit \"customized\" warnings. We support the so-called\n\"believe-me marks\" to disable warnings. We present another typical usage of our\ntechnique, when classes become deprecated during the software lifecycle.\n", "versions": [{"version": "v1", "created": "Tue, 15 Nov 2011 22:00:48 GMT"}], "update_date": "2011-11-17", "authors_parsed": [["Pataki", "N.", ""]]}, {"id": "1111.4407", "submitter": "EPTCS", "authors": "Pieter Van Gorp (Eindhoven University of Technology), Steffen Mazanek,\n  Louis Rose (University of York)", "title": "Proceedings Fifth Transformation Tool Contest", "comments": "EPTCS 74, 2011", "journal-ref": null, "doi": "10.4204/EPTCS.74", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The aim of the Transformation Tool Contest (TTC) series is to compare the\nexpressiveness, the usability and the performance of graph and model\ntransformation tools along a number of selected case studies. Participants want\nto learn about the pros and cons of each tool considering different\napplications. A deeper understanding of the relative merits of different tool\nfeatures will help to further improve graph and model transformation tools and\nto indicate open problems.\n  TTC 2011 involved 25 offline case study solutions: 12 solutions to the Hello\nWorld case, 2 solutions to the GMF Model Migration case, 5 solutions to the\nCompiler Optimization case, and 7 solutions to the Reengineering (i.e., Program\nUnderstanding) case. This volume contains the submissions that have passed an\nadditional (post-workshop) reviewing round.\n", "versions": [{"version": "v1", "created": "Wed, 16 Nov 2011 23:40:15 GMT"}], "update_date": "2011-11-21", "authors_parsed": [["Van Gorp", "Pieter", "", "Eindhoven University of Technology"], ["Mazanek", "Steffen", "", "University of York"], ["Rose", "Louis", "", "University of York"]]}, {"id": "1111.4737", "submitter": "EPTCS", "authors": "Sebastian Buchwald (Karlsruhe Institute of Technology (KIT)), Edgar\n  Jakumeit (Karlsruhe Institute of Technology (KIT))", "title": "Compiler Optimization: A Case for the Transformation Tool Contest", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 6-16", "doi": "10.4204/EPTCS.74.2", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An optimizing compiler consists of a front end parsing a textual programming\nlanguage into an intermediate representation (IR), a middle end performing\noptimizations on the IR, and a back end lowering the IR to a target\nrepresentation (TR) built of operations supported by the target hardware. In\nmodern compiler construction graph-based IRs are employed. Optimization and\nlowering tasks can then be implemented with graph transformation rules. This\ncase provides two compiler tasks to evaluate the participating tools regarding\nperformance.\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:24:23 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Buchwald", "Sebastian", "", "Karlsruhe Institute of Technology"], ["Jakumeit", "Edgar", "", "Karlsruhe Institute of Technology"]]}, {"id": "1111.4738", "submitter": "EPTCS", "authors": "Tassilo Horn (University Koblenz-Landau)", "title": "Program Understanding: A Reengineering Case for the Transformation Tool\n  Contest", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 17-21", "doi": "10.4204/EPTCS.74.3", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In Software Reengineering, one of the central artifacts is the source code of\nthe legacy system in question. In fact, in most cases it is the only definitive\nartifact, because over the time the code has diverged from the original\narchitecture and design documents. The first task of any reengineering project\nis to gather an understanding of the system's architecture. Therefore, a common\napproach is to use parsers to translate the source code into a model conforming\nto the abstract syntax of the programming language the system is implemented in\nwhich can then be subject to querying. Despite querying, transformations can be\nused to generate more abstract views on the system's architecture. This\ntransformation case deals with the creation of a state machine model out of a\nJava syntax graph. It is derived from a task that originates from a real\nreengineering project.\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:24:29 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Horn", "Tassilo", "", "University Koblenz-Landau"]]}, {"id": "1111.4742", "submitter": "EPTCS", "authors": "Sebastian Buchwald (Karlsruhe Institute of Technology (KIT)), Edgar\n  Jakumeit (Karlsruhe Institute of Technology (KIT))", "title": "Solving the TTC 2011 Compiler Optimization Case with GrGen.NET", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 42-53", "doi": "10.4204/EPTCS.74.7", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The challenge of the Compiler Optimization Case is to perform local\noptimizations and instruction selection on the graph-based intermediate\nrepresentation of a compiler. The case is designed to compare participating\ntools regarding their performance. We tackle this task employing the general\npurpose graph rewrite system GrGen.NET (www.grgen.net).\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:24:59 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Buchwald", "Sebastian", "", "Karlsruhe Institute of Technology"], ["Jakumeit", "Edgar", "", "Karlsruhe Institute of Technology"]]}, {"id": "1111.4744", "submitter": "EPTCS", "authors": "Markus Lepper, Baltasar Tranc\\'on y Widemann", "title": "Solving the TTC 2011 Compiler Optimization Task with metatools", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 70-115", "doi": "10.4204/EPTCS.74.9", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The authors' \"metatools\" are a collection of tools for generic programming.\nThis includes generating Java sources from mathematically well-founded\nspecifications, as well as the creation of strictly typed document object\nmodels for XML encoded texts. In this context, almost every computer-internal\nstructure is treated as a \"model\", and every computation is a kind of model\ntransformation.\n  This concept differs significantly from \"classical model transformation\"\nexecuted by specialized tools and languages. Therefore it seemed promising to\nthe organizers of the TTC 2011, as well as to the authors, to apply metatools\nto one of the challenges, namely to the \"compiler optimization task\". This is a\nreport on the resulting experiences.\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:25:16 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Lepper", "Markus", ""], ["Widemann", "Baltasar Tranc\u00f3n y", ""]]}, {"id": "1111.4745", "submitter": "EPTCS", "authors": "Tassilo Horn (University Koblenz-Landau)", "title": "Solving the TTC 2011 Compiler Optimization Case with GReTL", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 116-125", "doi": "10.4204/EPTCS.74.10", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper discusses the GReTL solution of the TTC 2011 Compiler Optimization\ncase. The submitted solution covers both the constant folding task and the\ninstruction selection task. The verifier for checking the validity of the graph\nis also implemented, and some additional test graphs are provided as requested\nby the extension.\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:25:21 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Horn", "Tassilo", "", "University Koblenz-Landau"]]}, {"id": "1111.4747", "submitter": "EPTCS", "authors": "Tassilo Horn (University Koblenz-Landau)", "title": "Solving the TTC 2011 Reengineering Case with GReTL", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 131-135", "doi": "10.4204/EPTCS.74.12", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper discusses the GReTL reference solution of the TTC 2011\nReengineering case. Given a Java syntax graph, a simple state machine model has\nto be extracted. The submitted solution covers both the core task and the two\nextension tasks.\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:25:35 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Horn", "Tassilo", "", "University Koblenz-Landau"]]}, {"id": "1111.4750", "submitter": "EPTCS", "authors": "Agris Sostaks, Elina Kalnina, Audris Kalnins, Edgars Celms, Janis\n  Iraids", "title": "Solving the TTC 2011 Reengineering Case with MOLA and Higher-Order\n  Transformations", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 159-167", "doi": "10.4204/EPTCS.74.15", "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Reengineering Case of the Transformation Tool Contest 2011 deals with\nautomatic extraction of state machine from Java source code. The transformation\ntask involves complex, non-local matching of model elements. This paper\ncontains the solution of the task using model transformation language MOLA. The\nMOLA solution uses higher-order transformations (HOT-s) to generate a part of\nthe required MOLA program. The described HOT approach allows creating reusable,\ncomplex model transformation libraries for generic tasks without modifying an\nimplementation of a model transformation language. Thus model transformation\nusers who are not the developers of the language can achieve the desired\nfunctionality more easily.\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:26:06 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Sostaks", "Agris", ""], ["Kalnina", "Elina", ""], ["Kalnins", "Audris", ""], ["Celms", "Edgars", ""], ["Iraids", "Janis", ""]]}, {"id": "1111.4751", "submitter": "EPTCS", "authors": "Edgar Jakumeit (Karlsruhe Institute of Technology (KIT)), Sebastian\n  Buchwald (Karlsruhe Institute of Technology (KIT))", "title": "Solving the TTC 2011 Reengineering Case with GrGen.NET", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 168-180", "doi": "10.4204/EPTCS.74.16", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The challenge of the Reengineering Case is to extract a state machine model\nout of the abstract syntax graph of a Java program. The extracted state machine\noffers a reduced view on the full program graph and thus helps to understand\nthe program regarding the question of interest. We tackle this task employing\nthe general purpose graph rewrite system GrGen.NET (www.grgen.net).\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:26:14 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Jakumeit", "Edgar", "", "Karlsruhe Institute of Technology"], ["Buchwald", "Sebastian", "", "Karlsruhe Institute of Technology"]]}, {"id": "1111.4755", "submitter": "EPTCS", "authors": "Elina Kalnina (Institute of Mathematics and Computer Science,\n  University of Latvia), Audris Kalnins (Institute of Mathematics and Computer\n  Science, University of Latvia), Agris Sostaks (Institute of Mathematics and\n  Computer Science, University of Latvia), Janis Iraids (Institute of\n  Mathematics and Computer Science, University of Latvia), Edgars Celms\n  (Institute of Mathematics and Computer Science, University of Latvia)", "title": "Saying Hello World with MOLA - A Solution to the TTC 2011 Instructive\n  Case", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 237-252", "doi": "10.4204/EPTCS.74.21", "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes the solution of Hello World transformations in MOLA\ntransformation language. Transformations implementing the task are relatively\nstraightforward and easily inferable from the task specification. The required\nadditional steps related to model import and export are also described.\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:26:57 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Kalnina", "Elina", "", "Institute of Mathematics and Computer Science,\n  University of Latvia"], ["Kalnins", "Audris", "", "Institute of Mathematics and Computer\n  Science, University of Latvia"], ["Sostaks", "Agris", "", "Institute of Mathematics and\n  Computer Science, University of Latvia"], ["Iraids", "Janis", "", "Institute of\n  Mathematics and Computer Science, University of Latvia"], ["Celms", "Edgars", "", "Institute of Mathematics and Computer Science, University of Latvia"]]}, {"id": "1111.4757", "submitter": "EPTCS", "authors": "Sebastian Buchwald (Karlsruhe Institute of Technology (KIT)), Edgar\n  Jakumeit (Karlsruhe Institute of Technology (KIT))", "title": "Saying Hello World with GrGen.NET - A Solution to the TTC 2011\n  Instructive Case", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 281-294", "doi": "10.4204/EPTCS.74.23", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce the graph transformation tool GrGen.NET (www.grgen.net) by\nsolving the Hello World Case of the Transformation Tool Contest 2011 which\nconsists of a collection of small transformation tasks; for each task a section\nis given explaining our implementation.\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:27:20 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Buchwald", "Sebastian", "", "Karlsruhe Institute of Technology"], ["Jakumeit", "Edgar", "", "Karlsruhe Institute of Technology"]]}, {"id": "1111.4762", "submitter": "EPTCS", "authors": "Tassilo Horn (University Koblenz-Landau)", "title": "Saying Hello World with GReTL - A Solution to the TTC 2011 Instructive\n  Case", "comments": "In Proceedings TTC 2011, arXiv:1111.4407", "journal-ref": "EPTCS 74, 2011, pp. 295-301", "doi": "10.4204/EPTCS.74.24", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper discusses the GReTL solution of the TTC 2011 Hello World case. The\nsubmitted solution covers all tasks including the optional ones.\n", "versions": [{"version": "v1", "created": "Mon, 21 Nov 2011 05:55:48 GMT"}], "update_date": "2011-11-22", "authors_parsed": [["Horn", "Tassilo", "", "University Koblenz-Landau"]]}, {"id": "1111.6756", "submitter": "Riyadh Baghdadi", "authors": "Riyadh Baghdadi, Albert Cohen, Cedric Bastoul, Louis-Noel Pouchet and\n  Lawrence Rauchwerger", "title": "The Potential of Synergistic Static, Dynamic and Speculative Loop Nest\n  Optimizations for Automatic Parallelization", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PF cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Research in automatic parallelization of loop-centric programs started with\nstatic analysis, then broadened its arsenal to include dynamic\ninspection-execution and speculative execution, the best results involving\nhybrid static-dynamic schemes. Beyond the detection of parallelism in a\nsequential program, scalable parallelization on many-core processors involves\nhard and interesting parallelism adaptation and mapping challenges. These\nchallenges include tailoring data locality to the memory hierarchy, structuring\nindependent tasks hierarchically to exploit multiple levels of parallelism,\ntuning the synchronization grain, balancing the execution load, decoupling the\nexecution into thread-level pipelines, and leveraging heterogeneous hardware\nwith specialized accelerators. The polyhedral framework allows to model,\nconstruct and apply very complex loop nest transformations addressing most of\nthe parallelism adaptation and mapping challenges. But apart from\nhardware-specific, back-end oriented transformations (if-conversion, trace\nscheduling, value prediction), loop nest optimization has essentially ignored\ndynamic and speculative techniques. Research in polyhedral compilation recently\nreached a significant milestone towards the support of dynamic, data-dependent\ncontrol flow. This opens a large avenue for blending dynamic analyses and\nspeculative techniques with advanced loop nest optimizations. Selecting\nreal-world examples from SPEC benchmarks and numerical kernels, we make a case\nfor the design of synergistic static, dynamic and speculative loop\ntransformation techniques. We also sketch the embedding of dynamic information,\nincluding speculative assumptions, in the heart of affine transformation search\nspaces.\n", "versions": [{"version": "v1", "created": "Tue, 29 Nov 2011 10:40:44 GMT"}], "update_date": "2011-11-30", "authors_parsed": [["Baghdadi", "Riyadh", ""], ["Cohen", "Albert", ""], ["Bastoul", "Cedric", ""], ["Pouchet", "Louis-Noel", ""], ["Rauchwerger", "Lawrence", ""]]}]