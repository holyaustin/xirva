[{"id": "0812.0564", "submitter": "James Cheney", "authors": "James Cheney, Umut Acar, Amal Ahmed", "title": "Provenance Traces", "comments": "Technical report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Provenance is information about the origin, derivation, ownership, or history\nof an object. It has recently been studied extensively in scientific databases\nand other settings due to its importance in helping scientists judge data\nvalidity, quality and integrity. However, most models of provenance have been\nstated as ad hoc definitions motivated by informal concepts such as \"comes\nfrom\", \"influences\", \"produces\", or \"depends on\". These models lack clear\nformalizations describing in what sense the definitions capture these intuitive\nconcepts. This makes it difficult to compare approaches, evaluate their\neffectiveness, or argue about their validity.\n  We introduce provenance traces, a general form of provenance for the nested\nrelational calculus (NRC), a core database query language. Provenance traces\ncan be thought of as concrete data structures representing the operational\nsemantics derivation of a computation; they are related to the traces that have\nbeen used in self-adjusting computation, but differ in important respects. We\ndefine a tracing operational semantics for NRC queries that produces both an\nordinary result and a trace of the execution. We show that three pre-existing\nforms of provenance for the NRC can be extracted from provenance traces.\nMoreover, traces satisfy two semantic guarantees: consistency, meaning that the\ntraces describe what actually happened during execution, and fidelity, meaning\nthat the traces \"explain\" how the expression would behave if the input were\nchanged. These guarantees are much stronger than those contemplated for\nprevious approaches to provenance; thus, provenance traces provide a general\nsemantic foundation for comparing and unifying models of provenance in\ndatabases.\n", "versions": [{"version": "v1", "created": "Tue, 2 Dec 2008 18:17:23 GMT"}], "update_date": "2008-12-03", "authors_parsed": [["Cheney", "James", ""], ["Acar", "Umut", ""], ["Ahmed", "Amal", ""]]}, {"id": "0812.0790", "submitter": "Tran Cao Son", "authors": "Enrico Pontelli, Tran Cao Son, and Omar Elkhatib", "title": "Justifications for Logic Programs under Answer Set Semantics", "comments": "59 pages, 7 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper introduces the notion of off-line justification for Answer Set\nProgramming (ASP). Justifications provide a graph-based explanation of the\ntruth value of an atom w.r.t. a given answer set. The paper extends also this\nnotion to provide justification of atoms during the computation of an answer\nset (on-line justification), and presents an integration of on-line\njustifications within the computation model of Smodels. Off-line and on-line\njustifications provide useful tools to enhance understanding of ASP, and they\noffer a basic data structure to support methodologies and tools for debugging\nanswer set programs. A preliminary implementation has been developed in\nASP-PROLOG.\n  (To appear in Theory and Practice of Logic Programming (TPLP))\n", "versions": [{"version": "v1", "created": "Wed, 3 Dec 2008 20:10:00 GMT"}], "update_date": "2008-12-04", "authors_parsed": [["Pontelli", "Enrico", ""], ["Son", "Tran Cao", ""], ["Elkhatib", "Omar", ""]]}, {"id": "0812.1986", "submitter": "Eric Feron", "authors": "Eric Feron and Fernando Alegre", "title": "Control software analysis, part II: Closed-loop analysis", "comments": "16 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The analysis and proper documentation of the properties of closed-loop\ncontrol software presents many distinct aspects from the analysis of the same\nsoftware running open-loop. Issues of physical system representations arise,\nand it is desired that such representations remain independent from the\nrepresentations of the control program. For that purpose, a concurrent program\nrepresentation of the plant and the control processes is proposed, although the\nclosed-loop system is sufficiently serialized to enable a sequential analysis.\nWhile dealing with closed-loop system properties, it is also shown by means of\nexamples how special treatment of nonlinearities extends from the analysis of\ncontrol specifications to code analysis.\n", "versions": [{"version": "v1", "created": "Wed, 10 Dec 2008 17:57:14 GMT"}], "update_date": "2008-12-11", "authors_parsed": [["Feron", "Eric", ""], ["Alegre", "Fernando", ""]]}, {"id": "0812.2926", "submitter": "Gheorghe Stefanescu", "authors": "Gheorghe Stefanescu and Camelia Chira", "title": "New parallel programming language design: a bridge between brain models\n  and multi-core/many-core computers?", "comments": "To appear in: \"From Natural Language to Soft Computing: New Paradigms\n  in Artificial Intelligence,\", L.A. Zadeh et.al (Eds.), Editing House of\n  Romanian Academy, 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The recurrent theme of this paper is that sequences of long temporal patterns\nas opposed to sequences of simple statements are to be fed into computation\ndevices, being them (new proposed) models for brain activity or\nmulti-core/many-core computers. In such models, parts of these long temporal\npatterns are already committed while other are predicted. This combination of\nmatching patterns and making predictions appears as a key element in producing\nintelligent processing in brain models and getting efficient speculative\nexecution on multi-core/many-core computers. A bridge between these far-apart\nmodels of computation could be provided by appropriate design of massively\nparallel, interactive programming languages. Agapia is a recently proposed\nlanguage of this kind, where user controlled long high-level temporal\nstructures occur at the interaction interfaces of processes. In this paper\nAgapia is used to link HTMs brain models with TRIPS multi-core/many-core\narchitectures.\n", "versions": [{"version": "v1", "created": "Mon, 15 Dec 2008 22:55:19 GMT"}], "update_date": "2008-12-17", "authors_parsed": [["Stefanescu", "Gheorghe", ""], ["Chira", "Camelia", ""]]}, {"id": "0812.3550", "submitter": "Pierre Genev\\`es", "authors": "Pierre Geneves and Nabil Layaida", "title": "XML Static Analyzer User Manual", "comments": null, "journal-ref": null, "doi": null, "report-no": "RR-6726", "categories": "cs.PL cs.DB cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This document describes how to use the XML static analyzer in practice. It\nprovides informal documentation for using the XML reasoning solver\nimplementation. The solver allows automated verification of properties that are\nexpressed as logical formulas over trees. A logical formula may for instance\nexpress structural constraints or navigation properties (like e.g. path\nexistence and node selection) in finite trees. Logical formulas can be\nexpressed using the syntax of XPath expressions, DTD, XML Schemas, and Relax NG\ndefinitions.\n", "versions": [{"version": "v1", "created": "Thu, 18 Dec 2008 15:22:46 GMT"}], "update_date": "2008-12-19", "authors_parsed": [["Geneves", "Pierre", ""], ["Layaida", "Nabil", ""]]}, {"id": "0812.4852", "submitter": "Carl Hewitt", "authors": "Carl Hewitt", "title": "Formalizing common sense for scalable inconsistency-robust information\n  integration using Direct Logic(TM) reasoning and the Actor Model", "comments": "Corrected: all types are strict", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Because contemporary large software systems are pervasively inconsistent, it\nis not safe to reason about them using classical logic. The goal of Direct\nLogic is to be a minimal fix to classical mathematical logic that meets the\nrequirements of large-scale Internet applications (including sense making for\nnatural language) by addressing the following issues: inconsistency robustness,\ncontrapositive inference bug, and direct argumentation.\n  Direct Logic makes the following contributions over previous work:\n  * Direct Inference (no contrapositive bug for inference)\n  * Direct Argumentation (inference directly expressed)\n  * Inconsistency-robust deduction without artifices such as indices (labels)\non propositions or restrictions on reiteration\n  * Intuitive inferences hold including the following:\n  * Boolean Equivalences\n  * Reasoning by splitting for disjunctive cases\n  * Soundness\n  * Inconsistency-robust Proof by Contradiction\n  Since the global state model of computation (first formalized by Turing) is\ninadequate to the needs of modern large-scale Internet applications the Actor\nModel was developed to meet this need. Using, the Actor Model, this paper\nproves that Logic Programming is not computationally universal in that there\nare computations that cannot be implemented using logical inference.\nConsequently the Logic Programming paradigm is strictly less general than the\nProcedural Embedding of Knowledge paradigm.\n", "versions": [{"version": "v1", "created": "Sun, 28 Dec 2008 21:37:23 GMT"}, {"version": "v10", "created": "Fri, 12 Jun 2009 21:10:35 GMT"}, {"version": "v100", "created": "Wed, 5 Nov 2014 14:09:33 GMT"}, {"version": "v101", "created": "Sun, 23 Nov 2014 22:59:31 GMT"}, {"version": "v102", "created": "Mon, 29 Dec 2014 16:47:29 GMT"}, {"version": "v103", "created": "Mon, 2 Mar 2015 06:39:17 GMT"}, {"version": "v11", "created": "Tue, 14 Jul 2009 00:08:22 GMT"}, {"version": "v12", "created": "Fri, 17 Jul 2009 05:28:44 GMT"}, {"version": "v13", "created": "Fri, 14 Aug 2009 07:48:39 GMT"}, {"version": "v14", "created": "Thu, 20 Aug 2009 18:19:06 GMT"}, {"version": "v15", "created": "Sat, 26 Sep 2009 18:10:14 GMT"}, {"version": "v16", "created": "Sun, 8 Nov 2009 07:43:45 GMT"}, {"version": "v17", "created": "Fri, 20 Nov 2009 16:05:14 GMT"}, {"version": "v18", "created": "Tue, 24 Nov 2009 05:50:49 GMT"}, {"version": "v19", "created": "Thu, 3 Dec 2009 15:42:13 GMT"}, {"version": "v2", "created": "Tue, 30 Dec 2008 23:30:05 GMT"}, {"version": "v20", "created": "Thu, 3 Dec 2009 23:03:29 GMT"}, {"version": "v21", "created": "Thu, 10 Dec 2009 07:12:22 GMT"}, {"version": "v22", "created": "Tue, 29 Dec 2009 23:00:04 GMT"}, {"version": "v23", "created": "Thu, 31 Dec 2009 20:06:59 GMT"}, {"version": "v24", "created": "Sat, 9 Jan 2010 18:28:38 GMT"}, {"version": "v25", "created": "Wed, 13 Jan 2010 22:53:30 GMT"}, {"version": "v26", "created": "Sat, 16 Jan 2010 21:02:44 GMT"}, {"version": "v27", "created": "Sun, 31 Jan 2010 11:51:22 GMT"}, {"version": "v28", "created": "Sun, 7 Feb 2010 22:47:16 GMT"}, {"version": "v29", "created": "Thu, 11 Feb 2010 22:23:44 GMT"}, {"version": "v3", "created": "Mon, 26 Jan 2009 18:10:14 GMT"}, {"version": "v30", "created": "Wed, 17 Feb 2010 17:54:03 GMT"}, {"version": "v31", "created": "Wed, 24 Feb 2010 01:49:48 GMT"}, {"version": "v32", "created": "Sat, 27 Feb 2010 14:08:25 GMT"}, {"version": "v33", "created": "Sat, 6 Mar 2010 17:44:48 GMT"}, {"version": "v34", "created": "Thu, 11 Mar 2010 15:34:10 GMT"}, {"version": "v35", "created": "Mon, 22 Mar 2010 01:39:19 GMT"}, {"version": "v36", "created": "Sun, 4 Apr 2010 10:13:36 GMT"}, {"version": "v37", "created": "Tue, 13 Apr 2010 16:37:09 GMT"}, {"version": "v38", "created": "Mon, 19 Apr 2010 16:28:14 GMT"}, {"version": "v39", "created": "Thu, 22 Apr 2010 19:20:04 GMT"}, {"version": "v4", "created": "Fri, 20 Mar 2009 17:32:25 GMT"}, {"version": "v40", "created": "Mon, 26 Apr 2010 16:52:49 GMT"}, {"version": "v41", "created": "Tue, 27 Apr 2010 16:17:39 GMT"}, {"version": "v42", "created": "Tue, 25 May 2010 14:53:37 GMT"}, {"version": "v43", "created": "Thu, 1 Jul 2010 14:48:06 GMT"}, {"version": "v44", "created": "Mon, 12 Jul 2010 15:46:06 GMT"}, {"version": "v45", "created": "Mon, 2 Aug 2010 10:51:53 GMT"}, {"version": "v46", "created": "Mon, 9 Aug 2010 11:11:23 GMT"}, {"version": "v47", "created": "Mon, 30 Aug 2010 17:19:34 GMT"}, {"version": "v48", "created": "Mon, 13 Sep 2010 19:00:50 GMT"}, {"version": "v49", "created": "Thu, 23 Sep 2010 17:42:38 GMT"}, {"version": "v5", "created": "Mon, 30 Mar 2009 14:24:19 GMT"}, {"version": "v50", "created": "Sun, 3 Oct 2010 02:36:47 GMT"}, {"version": "v51", "created": "Sun, 17 Oct 2010 00:29:19 GMT"}, {"version": "v52", "created": "Mon, 15 Nov 2010 23:37:16 GMT"}, {"version": "v53", "created": "Tue, 23 Nov 2010 19:19:16 GMT"}, {"version": "v54", "created": "Thu, 9 Dec 2010 13:25:55 GMT"}, {"version": "v55", "created": "Wed, 29 Dec 2010 13:27:45 GMT"}, {"version": "v56", "created": "Thu, 20 Jan 2011 07:46:17 GMT"}, {"version": "v57", "created": "Wed, 26 Jan 2011 08:31:46 GMT"}, {"version": "v58", "created": "Mon, 31 Jan 2011 00:17:50 GMT"}, {"version": "v59", "created": "Thu, 10 Feb 2011 08:28:00 GMT"}, {"version": "v6", "created": "Mon, 30 Mar 2009 23:44:01 GMT"}, {"version": "v60", "created": "Tue, 15 Mar 2011 16:15:16 GMT"}, {"version": "v61", "created": "Wed, 23 Mar 2011 13:25:55 GMT"}, {"version": "v62", "created": "Wed, 30 Mar 2011 06:55:12 GMT"}, {"version": "v63", "created": "Mon, 11 Apr 2011 16:45:02 GMT"}, {"version": "v64", "created": "Sun, 17 Apr 2011 23:39:33 GMT"}, {"version": "v65", "created": "Wed, 27 Apr 2011 08:28:01 GMT"}, {"version": "v66", "created": "Mon, 2 May 2011 14:13:51 GMT"}, {"version": "v67", "created": "Mon, 9 May 2011 16:14:00 GMT"}, {"version": "v68", "created": "Mon, 16 May 2011 03:13:50 GMT"}, {"version": "v69", "created": "Tue, 31 May 2011 10:21:32 GMT"}, {"version": "v7", "created": "Mon, 27 Apr 2009 08:17:17 GMT"}, {"version": "v70", "created": "Mon, 6 Jun 2011 17:00:09 GMT"}, {"version": "v71", "created": "Thu, 16 Jun 2011 18:37:21 GMT"}, {"version": "v72", "created": "Mon, 27 Jun 2011 19:40:09 GMT"}, {"version": "v73", "created": "Thu, 7 Jul 2011 00:36:10 GMT"}, {"version": "v74", "created": "Mon, 1 Aug 2011 19:25:13 GMT"}, {"version": "v75", "created": "Mon, 22 Aug 2011 06:42:33 GMT"}, {"version": "v76", "created": "Thu, 25 Aug 2011 14:51:09 GMT"}, {"version": "v77", "created": "Sun, 18 Sep 2011 14:44:39 GMT"}, {"version": "v78", "created": "Mon, 26 Sep 2011 20:45:24 GMT"}, {"version": "v79", "created": "Tue, 15 Nov 2011 15:31:31 GMT"}, {"version": "v8", "created": "Sat, 30 May 2009 23:38:27 GMT"}, {"version": "v80", "created": "Mon, 21 Nov 2011 20:08:06 GMT"}, {"version": "v81", "created": "Sun, 1 Jan 2012 00:46:32 GMT"}, {"version": "v82", "created": "Tue, 31 Jan 2012 03:10:35 GMT"}, {"version": "v83", "created": "Mon, 13 Feb 2012 07:17:46 GMT"}, {"version": "v84", "created": "Mon, 27 Feb 2012 23:02:35 GMT"}, {"version": "v85", "created": "Mon, 2 Apr 2012 14:16:11 GMT"}, {"version": "v86", "created": "Tue, 4 Dec 2012 18:26:14 GMT"}, {"version": "v87", "created": "Mon, 11 Mar 2013 19:40:08 GMT"}, {"version": "v88", "created": "Fri, 2 Aug 2013 21:41:29 GMT"}, {"version": "v89", "created": "Tue, 27 Aug 2013 13:27:49 GMT"}, {"version": "v9", "created": "Wed, 10 Jun 2009 14:59:46 GMT"}, {"version": "v90", "created": "Tue, 24 Sep 2013 19:05:21 GMT"}, {"version": "v91", "created": "Sat, 2 Nov 2013 04:51:44 GMT"}, {"version": "v92", "created": "Tue, 18 Feb 2014 19:43:19 GMT"}, {"version": "v93", "created": "Mon, 3 Mar 2014 07:52:01 GMT"}, {"version": "v94", "created": "Thu, 19 Jun 2014 22:03:58 GMT"}, {"version": "v95", "created": "Sat, 5 Jul 2014 22:04:00 GMT"}, {"version": "v96", "created": "Mon, 21 Jul 2014 12:48:15 GMT"}, {"version": "v97", "created": "Mon, 28 Jul 2014 14:54:56 GMT"}, {"version": "v98", "created": "Mon, 4 Aug 2014 16:55:37 GMT"}, {"version": "v99", "created": "Mon, 18 Aug 2014 14:28:05 GMT"}], "update_date": "2015-03-03", "authors_parsed": [["Hewitt", "Carl", ""]]}, {"id": "0812.4973", "submitter": "Neil Dickson", "authors": "Neil G. Dickson", "title": "A Simple, Linear-Time Algorithm for x86 Jump Encoding", "comments": "5 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of space-optimal jump encoding in the x86 instruction set, also\nknown as branch displacement optimization, is described, and a linear-time\nalgorithm is given that uses no complicated data structures, no recursion, and\nno randomization. The only assumption is that there are no array declarations\nwhose size depends on the negative of the size of a section of code (Hyde\n2006), which is reasonable for real code.\n", "versions": [{"version": "v1", "created": "Mon, 29 Dec 2008 21:07:52 GMT"}], "update_date": "2009-09-29", "authors_parsed": [["Dickson", "Neil G.", ""]]}]