[{"id": "1208.0515", "submitter": "Simone Martini", "authors": "Ugo Dal Lago (Universit\\`a di Bologna - Dipartimento di Scienze\n  dell'Informazione), Simone Martini (Universit\\`a di Bologna - Dipartimento di\n  Scienze dell'Informazione)", "title": "On Constructor Rewrite Systems and the Lambda Calculus", "comments": "27 pages. arXiv admin note: substantial text overlap with\n  arXiv:0904.4120", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 3 (August 14,\n  2012) lmcs:1213", "doi": "10.2168/LMCS-8(3:12)2012", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that orthogonal constructor term rewrite systems and lambda-calculus\nwith weak (i.e., no reduction is allowed under the scope of a\nlambda-abstraction) call-by-value reduction can simulate each other with a\nlinear overhead. In particular, weak call-by- value beta-reduction can be\nsimulated by an orthogonal constructor term rewrite system in the same number\nof reduction steps. Conversely, each reduction in a term rewrite system can be\nsimulated by a constant number of beta-reduction steps. This is relevant to\nimplicit computational complexity, because the number of beta steps to normal\nform is polynomially related to the actual cost (that is, as performed on a\nTuring machine) of normalization, under weak call-by-value reduction.\nOrthogonal constructor term rewrite systems and lambda-calculus are thus both\npolynomially related to Turing machines, taking as notion of cost their natural\nparameters.\n", "versions": [{"version": "v1", "created": "Thu, 2 Aug 2012 15:21:44 GMT"}, {"version": "v2", "created": "Sat, 11 Aug 2012 19:01:18 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Lago", "Ugo Dal", "", "Universit\u00e0 di Bologna - Dipartimento di Scienze\n  dell'Informazione"], ["Martini", "Simone", "", "Universit\u00e0 di Bologna - Dipartimento di\n  Scienze dell'Informazione"]]}, {"id": "1208.0535", "submitter": "Jeremy Siek", "authors": "Christopher Schwaab and Jeremy G. Siek", "title": "Modular Type-Safety Proofs using Dependant Types", "comments": "8 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While methods of code abstraction and reuse are widespread and well\nresearched, methods of proof abstraction and reuse are still emerging. We\nconsider the use of dependent types for this purpose, introducing a completely\nmechanical approach to proof composition. We show that common techniques for\nabstracting algorithms over data structures naturally translate to abstractions\nover proofs. We first introduce a language composed of a series of smaller\nlanguage components tied together by standard techniques from Malcom (1990). We\nproceed by giving proofs of type preservation for each language component and\nshow that the basic ideas used in composing the syntactic data structures can\nbe applied to their semantics as well.\n", "versions": [{"version": "v1", "created": "Thu, 2 Aug 2012 16:38:13 GMT"}], "update_date": "2012-08-03", "authors_parsed": [["Schwaab", "Christopher", ""], ["Siek", "Jeremy G.", ""]]}, {"id": "1208.2013", "submitter": "Alvin Cheung", "authors": "Alvin Cheung and Armando Solar-Lezama and Samuel Madden", "title": "Inferring SQL Queries Using Program Synthesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Developing high-performance applications that interact with databases is a\ndifficult task, as developers need to understand both the details of the\nlanguage in which their applications are written in, and also the intricacies\nof the relational model. One popular solution to this problem is the use of\nobject-relational mapping (ORM) libraries that provide transparent access to\nthe database using the same language that the application is written in.\nUnfortunately, using such frameworks can easily lead to applications with poor\nperformance because developers often end up implementing relational operations\nin application code, and doing so usually does not take advantage of the\noptimized implementations of relational operations, efficient query plans, or\npush down of predicates that database systems provide. In this paper we present\nQBS, an algorithm that automatically identifies fragments of application logic\nthat can be pushed into SQL queries. The QBS algorithm works by automatically\nsynthesizing invariants and postconditions for the original code fragment. The\npostconditions and invariants are expressed using a theory of ordered relations\nthat allows us to reason precisely about the contents and order of the records\nproduced even by complex code fragments that compute joins and aggregates. The\ntheory is close in expressiveness to SQL, so the synthesized postconditions can\nbe readily translated to SQL queries. Using 40 code fragments extracted from\nover 120k lines of open-source code written using the Java Hibernate ORM, we\ndemonstrate that our approach can convert a variety of imperative constructs\ninto relational specifications.\n", "versions": [{"version": "v1", "created": "Thu, 9 Aug 2012 19:26:29 GMT"}], "update_date": "2015-03-20", "authors_parsed": [["Cheung", "Alvin", ""], ["Solar-Lezama", "Armando", ""], ["Madden", "Samuel", ""]]}, {"id": "1208.2383", "submitter": "Clemens Grabmayer", "authors": "Clemens Grabmayer and Jan Rochel", "title": "Expressibility in the Lambda Calculus with Letrec", "comments": "79 pages, 25 figures", "journal-ref": null, "doi": "10.4230/LIPIcs.RTA.2013.206", "report-no": "1304.6284", "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the relationship between finite terms in lambda-letrec, the\nlambda calculus with letrec, and the infinite lambda terms they express. As\nthere are easy examples of lambda-terms that, intuitively, are not unfoldings\nof terms in lambda-letrec, we consider the question: How can those infinite\nlambda terms be characterised that are lamda-letrec-expressible in the sense\nthat they can be obtained as infinite unfoldings of terms in lambda-letrec?\n  For 'observing' infinite lambda-terms through repeated 'experiments' carried\nout at the head of the term we introduce two rewrite systems (with rewrite\nrelations) -reg-> and -reg+-> that decompose the term, and produce 'generated\nsubterms' in two notions. Thereby the sort of the step can be observed as well\nas its target, a generated subterm. In both systems there are four sorts of\ndecomposition steps: -lambda-> steps (decomposing a lambda-abstraction), -@0>\nand -@1> steps (decomposing an application into its function and argument), and\nrespectively, -del-> steps (delimiting the scope of an abstraction, for\n-reg->), and -S-> (delimiting of scopes, for -reg+->). These steps take place\non infinite lambda-terms furnished with a leading prefix of abstractions for\ngathering previously encountered lambda-abstractions and keeping the generated\nsubterms closed. We call an infinite lambda-term 'regular'/'strongly regular'\nif its set of -reg-> -reachable / -reg-> -reachable generated subterms is\nfinite. Furthermore, we analyse the binding structure of lambda-terms with the\nconcept of 'binding-capturing chain'.\n  Using these concepts, we answer the question above by providing two\ncharacterisations of lambda-letrec-expressibility. For all infinite\nlambda-terms M, the following statements are equivalent: (i) M is\nlambda-letrec-expressible; (ii) M is strongly regular; (iii) M is regular, and\nit only has finite binding-capturing chains.\n", "versions": [{"version": "v1", "created": "Sat, 11 Aug 2012 20:07:00 GMT"}, {"version": "v2", "created": "Mon, 3 Sep 2012 23:31:57 GMT"}, {"version": "v3", "created": "Tue, 12 Feb 2013 10:29:05 GMT"}, {"version": "v4", "created": "Fri, 15 Feb 2013 02:12:14 GMT"}, {"version": "v5", "created": "Thu, 2 May 2013 09:30:42 GMT"}], "update_date": "2015-12-04", "authors_parsed": [["Grabmayer", "Clemens", ""], ["Rochel", "Jan", ""]]}, {"id": "1208.2440", "submitter": "EPTCS", "authors": "Bas Luttik, Michel A. Reniers", "title": "Proceedings Combined 19th International Workshop on Expressiveness in\n  Concurrency and 9th Workshop on Structured Operational Semantics", "comments": null, "journal-ref": "EPTCS 89, 2012", "doi": "10.4204/EPTCS.89", "report-no": null, "categories": "cs.LO cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Combined 19th International\nWorkshop on Expressiveness in Concurrency and the 9th Workshop on Structural\nOperational Semantics (EXPRESS/SOS 2012), which took place on 3rd September\n2012 in Newcastle upon Tyne, as a satellite workshop of CONCUR 2012. The\nEXPRESS workshop series aims at bringing together researchers interested in the\nexpressiveness of various formal systems and semantic notions, particularly in\nthe field of concurrency. The SOS workshop series aims at being a forum for\nresearchers, students and practitioners interested in new developments, and\ndirections for future investigation, in the field of structural operational\nsemantics. In 2012, the EXPRESS and SOS communities organized a joint\nEXPRESS/SOS 2012 workshop on the formal semantics of systems and programming\nconcepts, and on the expressiveness of mathematical models of computation.\n", "versions": [{"version": "v1", "created": "Sun, 12 Aug 2012 16:17:56 GMT"}], "update_date": "2012-08-14", "authors_parsed": [["Luttik", "Bas", ""], ["Reniers", "Michel A.", ""]]}, {"id": "1208.2585", "submitter": "EPTCS", "authors": "Nachum Dershowitz (Tel Aviv University)", "title": "The Generic Model of Computation", "comments": "In Proceedings DCM 2011, arXiv:1207.6821", "journal-ref": "EPTCS 88, 2012, pp. 59-71", "doi": "10.4204/EPTCS.88.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Over the past two decades, Yuri Gurevich and his colleagues have formulated\naxiomatic foundations for the notion of algorithm, be it classical,\ninteractive, or parallel, and formalized them in the new generic framework of\nabstract state machines. This approach has recently been extended to suggest a\nformalization of the notion of effective computation over arbitrary countable\ndomains. The central notions are summarized herein.\n", "versions": [{"version": "v1", "created": "Tue, 31 Jul 2012 02:06:34 GMT"}], "update_date": "2012-08-14", "authors_parsed": [["Dershowitz", "Nachum", "", "Tel Aviv University"]]}, {"id": "1208.2749", "submitter": "EPTCS", "authors": "Marco Giunti (CITI and DI-FCT, Universidade Nova de Lisboa, Portugal),\n  Catuscia Palamidessi (INRIA Saclay and LIX, Ecole Polytechnique, France),\n  Frank D. Valencia (INRIA Saclay and LIX, Ecole Polytechnique, France)", "title": "Hide and New in the Pi-Calculus", "comments": "In Proceedings EXPRESS/SOS 2012, arXiv:1208.2440", "journal-ref": "EPTCS 89, 2012, pp. 65-79", "doi": "10.4204/EPTCS.89.6", "report-no": null, "categories": "cs.PL cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we enrich the pi-calculus with an operator for confidentiality\n(hide), whose main effect is to restrict the access to the object of the\ncommunication, thus representing confidentiality in a natural way. The hide\noperator is meant for local communication, and it differs from new in that it\nforbids the extrusion of the name and hence has a static scope. Consequently, a\ncommunication channel in the scope of a hide can be implemented as a dedicated\nchannel, and it is more secure than one in the scope of a new. To emphasize the\ndifference, we introduce a spy context that represents a side-channel attack\nand breaks some of the standard security equations for new. To formally reason\non the security guarantees provided by the hide construct, we introduce an\nobservational theory and establish stronger equivalences by relying on a proof\ntechnique based on bisimulation semantics.\n", "versions": [{"version": "v1", "created": "Tue, 14 Aug 2012 01:51:57 GMT"}], "update_date": "2012-08-15", "authors_parsed": [["Giunti", "Marco", "", "CITI and DI-FCT, Universidade Nova de Lisboa, Portugal"], ["Palamidessi", "Catuscia", "", "INRIA Saclay and LIX, Ecole Polytechnique, France"], ["Valencia", "Frank D.", "", "INRIA Saclay and LIX, Ecole Polytechnique, France"]]}, {"id": "1208.2752", "submitter": "EPTCS", "authors": "Matias David Lee (Famaf, UNC - Conicet), Daniel Gebler (VU University\n  Amsterdam), Pedro R. D'Argenio (Famaf, UNC - Conicet)", "title": "Tree rules in probabilistic transition system specifications with\n  negative and quantitative premises", "comments": "In Proceedings EXPRESS/SOS 2012, arXiv:1208.2440", "journal-ref": "EPTCS 89, 2012, pp. 115-130", "doi": "10.4204/EPTCS.89.9", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Probabilistic transition system specifications (PTSSs) in the ntmufnu/ntmuxnu\nformat provide structural operational semantics for Segala-type systems that\nexhibit both probabilistic and nondeterministic behavior and guarantee that\nisimilarity is a congruence.Similar to the nondeterministic case of rule format\ntyft/tyxt, we show that the well-foundedness requirement is unnecessary in the\nprobabilistic setting. To achieve this, we first define an extended version of\nthe ntmufnu/ntmuxnu format in which quantitative premises and conclusions\ninclude nested convex combinations of distributions. This format also\nguarantees that bisimilarity is a congruence. Then, for a given (possibly\nnon-well-founded) PTSS in the new format, we construct an equivalent\nwell-founded transition system consisting of only rules of the simpler\n(well-founded) probabilistic ntree format. Furthermore, we develop a\nproof-theoretic notion for these PTSSs that coincides with the existing\nstratification-based meaning in case the PTSS is stratifiable. This continues\nthe line of research lifting structural operational semantic results from the\nnondeterministic setting to systems with both probabilistic and\nnondeterministic behavior.\n", "versions": [{"version": "v1", "created": "Tue, 14 Aug 2012 01:52:18 GMT"}], "update_date": "2012-08-15", "authors_parsed": [["Lee", "Matias David", "", "Famaf, UNC - Conicet"], ["Gebler", "Daniel", "", "VU University\n  Amsterdam"], ["D'Argenio", "Pedro R.", "", "Famaf, UNC - Conicet"]]}, {"id": "1208.2754", "submitter": "EPTCS", "authors": "Maxim Strygin (School of Computer Science University of Birmingham),\n  Hayo Thielecke (School of Computer Science University of Birmingham)", "title": "Operational semantics for signal handling", "comments": "In Proceedings EXPRESS/SOS 2012, arXiv:1208.2440", "journal-ref": "EPTCS 89, 2012, pp. 149-163", "doi": "10.4204/EPTCS.89.11", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Signals are a lightweight form of interprocess communication in Unix. When a\nprocess receives a signal, the control flow is interrupted and a previously\ninstalled signal handler is run. Signal handling is reminiscent both of\nexception handling and concurrent interleaving of processes. In this paper, we\ninvestigate different approaches to formalizing signal handling in operational\nsemantics, and compare them in a series of examples. We find the big-step style\nof operational semantics to be well suited to modelling signal handling. We\nintegrate exception handling with our big-step semantics of signal handling, by\nadopting the exception convention as defined in the Definition of Standard ML.\nThe semantics needs to capture the complex interactions between signal handling\nand exception handling.\n", "versions": [{"version": "v1", "created": "Tue, 14 Aug 2012 01:52:37 GMT"}], "update_date": "2012-08-15", "authors_parsed": [["Strygin", "Maxim", "", "School of Computer Science University of Birmingham"], ["Thielecke", "Hayo", "", "School of Computer Science University of Birmingham"]]}, {"id": "1208.2925", "submitter": "Alvin Cheung", "authors": "Alvin Cheung, Armando Solar-Lezama, Samuel Madden", "title": "Using Program Synthesis for Social Recommendations", "comments": null, "journal-ref": null, "doi": null, "report-no": "MIT-CSAIL-TR-2012-025", "categories": "cs.LG cs.DB cs.PL cs.SI physics.soc-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a new approach to select events of interest to a user in\na social media setting where events are generated by the activities of the\nuser's friends through their mobile devices. We argue that given the unique\nrequirements of the social media setting, the problem is best viewed as an\ninductive learning problem, where the goal is to first generalize from the\nusers' expressed \"likes\" and \"dislikes\" of specific events, then to produce a\nprogram that can be manipulated by the system and distributed to the collection\ndevices to collect only data of interest. The key contribution of this paper is\na new algorithm that combines existing machine learning techniques with new\nprogram synthesis technology to learn users' preferences. We show that when\ncompared with the more standard approaches, our new algorithm provides up to\norder-of-magnitude reductions in model training time, and significantly higher\nprediction accuracies for our target application. The approach also improves on\nstandard machine learning techniques in that it produces clear programs that\ncan be manipulated to optimize data collection and filtering.\n", "versions": [{"version": "v1", "created": "Tue, 14 Aug 2012 17:04:19 GMT"}], "update_date": "2012-08-15", "authors_parsed": [["Cheung", "Alvin", ""], ["Solar-Lezama", "Armando", ""], ["Madden", "Samuel", ""]]}, {"id": "1208.3773", "submitter": "Francisco Carvalho-Junior Dr", "authors": "Francisco Heron de Carvalho Junior, Rafael Dueire Lins", "title": "Haskell_#: Coordinating Functional Processes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents Haskell#, a coordination language targeted at the\nefficient implementation of parallel scientific applications on loosely coupled\nparallel architectures, using the functional language Haskell. Examples of\napplications, their implementation details and performance figures are\npresented.\n", "versions": [{"version": "v1", "created": "Sat, 18 Aug 2012 18:29:00 GMT"}], "update_date": "2012-08-21", "authors_parsed": [["Junior", "Francisco Heron de Carvalho", ""], ["Lins", "Rafael Dueire", ""]]}, {"id": "1208.3836", "submitter": "Vishnuvardhan Mannava M.E", "authors": "Vishnuvardhan Mannava and T. Ramesh", "title": "Composite Design Pattern for Feature Oriented Service Injection and\n  Composition of Web Services for Distributed Computing Systems with Service\n  Oriented Architecture", "comments": "12 pages, 7 figures, International Journal of Web & Semantic\n  Technology (IJWesT)", "journal-ref": "Volume 3, Number 3, Page Number 73--84, July 2012", "doi": "10.5121/ijwest", "report-no": null, "categories": "cs.SE cs.DC cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  With the advent of newly introduced programming models like Feature-Oriented\nProgramming (FOP), we feel that it will be more flexible to include the new\nservice invocation function into the service providing server as a Feature\nModule for the self-adaptive distributed systems. A composite design patterns\nshows a synergy that makes the composition more than just the sum of its parts\nwhich leads to ready-made software architectures. In this paper we describe the\namalgamation of Visitor and Case-Based Reasoning Design Patterns to the\ndevelopment of the Service Invocation and Web Services Composition through SOA\nwith the help of JWS technologies and FOP. As far as we know, there are no\nstudies on composition of design patterns for self adaptive distributed\ncomputing domain. We have provided with the sample code developed for the\napplication and simple UML class diagram is used to describe the architecture.\n", "versions": [{"version": "v1", "created": "Sun, 19 Aug 2012 13:57:10 GMT"}], "update_date": "2012-08-21", "authors_parsed": [["Mannava", "Vishnuvardhan", ""], ["Ramesh", "T.", ""]]}, {"id": "1208.3882", "submitter": "Francisco Carvalho-Junior Dr", "authors": "Francisco Heron de Carvalho-Junior, Rafael Dueire Lins", "title": "Coordination Level Modeling and Analysis of Parallel Programs using\n  Petri Nets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the last fifteen years, the high performance computing (HPC) community has\nclaimed for parallel programming environments that reconciles generality,\nhigher level of abstraction, portability, and efficiency for distributed-memory\nparallel computing platforms. The Hash component model appears as an\nalternative for addressing HPC community claims for fitting these requirements.\nThis paper presents foundations that will enable a parallel programming\nenvironment based on the Hash model to address the problems of \"debugging\",\nperformance evaluation and verification of formal properties of parallel\nprogram by means of a powerful, simple, and widely adopted formalism: Petri\nnets.\n", "versions": [{"version": "v1", "created": "Sun, 19 Aug 2012 19:31:40 GMT"}], "update_date": "2012-08-21", "authors_parsed": [["de Carvalho-Junior", "Francisco Heron", ""], ["Lins", "Rafael Dueire", ""]]}, {"id": "1208.4035", "submitter": "Denis Barthou", "authors": "Denis Barthou (LaBRI, INRIA Bordeaux - Sud-Ouest), Gilbert Grosdidier\n  (LAL), Michael Kruse (LRI), Olivier P\\`ene (LPT), Claude Tadonki", "title": "QIRAL: A High Level Language for Lattice QCD Code Generation", "comments": "ETAPS 2012, Tallin : Estonia (2012)", "journal-ref": null, "doi": "10.4204/EPTCS", "report-no": "LPT-ORSAY 12-08", "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Quantum chromodynamics (QCD) is the theory of subnuclear physics, aiming at\nmod- eling the strong nuclear force, which is responsible for the interactions\nof nuclear particles. Lattice QCD (LQCD) is the corresponding discrete\nformulation, widely used for simula- tions. The computational demand for the\nLQCD is tremendous. It has played a role in the history of supercomputers, and\nhas also helped defining their future. Designing efficient LQCD codes that\nscale well on large (probably hybrid) supercomputers requires to express many\nlevels of parallelism, and then to explore different algorithmic solutions.\nWhile al- gorithmic exploration is the key for efficient parallel codes, the\nprocess is hampered by the necessary coding effort. We present in this paper a\ndomain-specific language, QIRAL, for a high level expression of parallel\nalgorithms in LQCD. Parallelism is expressed through the mathematical struc-\nture of the sparse matrices defining the problem. We show that from these\nexpressions and from algorithmic and preconditioning formulations, a parallel\ncode can be automatically generated. This separates algorithms and mathematical\nformulations for LQCD (that be- long to the field of physics) from the\neffective orchestration of parallelism, mainly related to compilation and\noptimization for parallel architectures.\n", "versions": [{"version": "v1", "created": "Thu, 16 Aug 2012 12:14:39 GMT"}], "update_date": "2012-08-21", "authors_parsed": [["Barthou", "Denis", "", "LaBRI, INRIA Bordeaux - Sud-Ouest"], ["Grosdidier", "Gilbert", "", "LAL"], ["Kruse", "Michael", "", "LRI"], ["P\u00e8ne", "Olivier", "", "LPT"], ["Tadonki", "Claude", ""]]}, {"id": "1208.4041", "submitter": "Samir Genaim", "authors": "Amir M. Ben-Amram and Samir Genaim", "title": "Ranking Functions for Linear-Constraint Loops", "comments": "51 pages, extended and revised version of the POPL'13 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we study the complexity of the problems: given a loop,\ndescribed by linear constraints over a finite set of variables, is there a\nlinear or lexicographical-linear ranking function for this loop? While\nexistence of such functions implies termination, these problems are not\nequivalent to termination. When the variables range over the rationals (or\nreals), it is known that both problems are PTIME decidable. However, when they\nrange over the integers, whether for single-path or multipath loops, the\ncomplexity has not yet been determined. We show that both problems are\ncoNP-complete. However, we point out some special cases of importance of PTIME\ncomplexity. We also present complete algorithms for synthesizing linear and\nlexicographical-linear ranking functions, both for the general case and the\nspecial PTIME cases. Moreover, in the rational setting, our algorithm for\nsynthesizing lexicographical-linear ranking functions extends existing ones,\nbecause our class of ranking functions is more general, yet it has polynomial\ntime complexity.\n", "versions": [{"version": "v1", "created": "Mon, 20 Aug 2012 15:25:45 GMT"}, {"version": "v2", "created": "Tue, 29 Jan 2013 11:51:29 GMT"}, {"version": "v3", "created": "Tue, 9 Jul 2013 09:09:24 GMT"}], "update_date": "2013-07-10", "authors_parsed": [["Ben-Amram", "Amir M.", ""], ["Genaim", "Samir", ""]]}, {"id": "1208.4126", "submitter": "Iztok Fister", "authors": "Iztok Fister Jr., Toma\\v{z} Kosar, Marjan Mernik, Iztok Fister", "title": "Upgrading EasyTime: from a textual to a visual language", "comments": null, "journal-ref": "I. Fister Jr., T. Kosar, M. Mernik, I. Fister, Upgrading EasyTime:\n  from a textual to a visual language, In Proceedings of the 21st International\n  Electrotechnical and Computer Science Conference, Portoro\\v{z}, Slovenia,\n  2012", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Measuring time in mass sports competitions is usually performed using\nexpensive measuring devices. Unfortunately, these solutions are not acceptable\nby many organizers of sporting competitions. In order to make the measuring\ntime as cheap as possible, the domain-specific language (DSL) EasyTime was\nproposed. In practice, it has been proven to be universal, flexible, and\nefficient. It can even reduce the number of required measuring devices. On the\nother hand, programming in EasyTime is not easy, because it requires a\ndomain-expert to program in a textual manner. In this paper, the\ndomain-specific modeling language (DSML) EasyTime II is proposed, which\nsimplifies the programming of the measuring system. First, the DSL EasyTime\ndomain analysis is presented. Then, the development of DSML is described in\ndetail. Finally, the DSML was tested by regular organizers of a sporting\ncompetition. This test showed that DSML can be used by end-users without any\nprevious programming knowledge.\n", "versions": [{"version": "v1", "created": "Mon, 20 Aug 2012 21:48:43 GMT"}], "update_date": "2012-08-22", "authors_parsed": [["Fister", "Iztok", "Jr."], ["Kosar", "Toma\u017e", ""], ["Mernik", "Marjan", ""], ["Fister", "Iztok", ""]]}, {"id": "1208.4327", "submitter": "EPTCS", "authors": "Natallia Kokash, Ant\\'onio Ravara", "title": "Proceedings 11th International Workshop on Foundations of Coordination\n  Languages and Self Adaptation", "comments": null, "journal-ref": "EPTCS 91, 2012", "doi": "10.4204/EPTCS.91", "report-no": null, "categories": "cs.DC cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Welcome to the proceedings of FOCLASA 2012, the 11th International Workshop\non the Foundations of Coordination Languages and Self-Adaptation. FOCLASA 2012\nwas held in Newcastle upon Tyne, UK, on September 8, 2012 as a satellite event\nof CONCUR 2012, the 23rd International Conference on Concurrency Theory. The\nworkshop provides a venue where researchers and practitioners could meet,\nexchange ideas, identify common problems, determine some of the key and\nfundamental issues related to coordination languages and self adaptation, and\nexplore together and disseminate solutions. Indeed, a number of hot research\ntopics are currently sharing the common problem of combining concurrent,\ndistributed, mobile and heterogeneous components, trying to harness the\nintrinsic complexity of the resulting systems. Computation nowadays is becoming\ninherently concurrent, either because of characteristics of the hardware (with\nmulticore processors becoming omnipresent) or due to the ubiquitous presence of\ndistributed systems (incarnated in the Internet). Computational systems are\ntherefore typically distributed, concurrent, mobile, and often involve\ncomposition of heterogeneous components. To specify and reason about such\nsystems and go beyond the functional correctness proofs, e.g., by supporting\nreusability and improving maintainability, approaches such as coordination\nlanguages and self adaptation are recognised as fundamental.\n  This year, we received 13 submissions involving 35 authors from 10 different\ncountries. Papers underwent a rigorous review process, and all accepted papers\nreceived 3 review reports. After the review process, the international Program\nCommittee of FOCLASA 2012 decided to select 8 papers for presentation during\nthe workshop and inclusion in these proceedings. These papers tackle different\nissues that are currently central to our community, self-adaptation and\ncoordination, processes and coordination, and type systems. The workshop\nfeatures an invited talk by Sebastian Uchitel from Imperial College London\n(UK).\n", "versions": [{"version": "v1", "created": "Wed, 15 Aug 2012 15:38:34 GMT"}], "update_date": "2012-08-22", "authors_parsed": [["Kokash", "Natallia", ""], ["Ravara", "Ant\u00f3nio", ""]]}, {"id": "1208.4572", "submitter": "Raphael Poss", "authors": "Raphael Poss", "title": "SL: a \"quick and dirty\" but working intermediate language for SVP\n  systems", "comments": "22 pages, 3 figures, 18 listings, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The CSA group at the University of Amsterdam has developed SVP, a framework\nto manage and program many-core and hardware multithreaded processors. In this\narticle, we introduce the intermediate language SL, a common vehicle to program\nSVP platforms. SL is designed as an extension to the standard C language (ISO\nC99/C11). It includes primitive constructs to bulk create threads, bulk\nsynchronize on termination of threads, and communicate using word-sized\ndataflow channels between threads. It is intended for use as target language\nfor higher-level parallelizing compilers. SL is a research vehicle; as of this\nwriting, it is the only interface language to program a main SVP platform, the\nnew Microgrid chip architecture. This article provides an overview of the\nlanguage, to complement a detailed specification available separately.\n", "versions": [{"version": "v1", "created": "Wed, 22 Aug 2012 18:49:33 GMT"}], "update_date": "2015-03-20", "authors_parsed": [["Poss", "Raphael", ""]]}, {"id": "1208.4630", "submitter": "EPTCS", "authors": "Joakim Bj{\\o}rk (University of Oslo), Dave Clarke (Katholieke\n  Universiteit Leuven), Einar Broch Johnsen (University of Oslo), Olaf Owe\n  (University of Oslo)", "title": "A Type-Safe Model of Adaptive Object Groups", "comments": "In Proceedings FOCLASA 2012, arXiv:1208.4327", "journal-ref": "EPTCS 91, 2012, pp. 1-15", "doi": "10.4204/EPTCS.91.1", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Services are autonomous, self-describing, technology-neutral software units\nthat can be described, published, discovered, and composed into software\napplications at runtime. Designing software services and composing services in\norder to form applications or composite services requires abstractions beyond\nthose found in typical object-oriented programming languages. This paper\nexplores service-oriented abstractions such as service adaptation, discovery,\nand querying in an object-oriented setting. We develop a formal model of\nadaptive object-oriented groups which offer services to their environment.\nThese groups fit directly into the object-oriented paradigm in the sense that\nthey can be dynamically created, they have an identity, and they can receive\nmethod calls. In contrast to objects, groups are not used for structuring code.\nA group exports its services through interfaces and relies on objects to\nimplement these services. Objects may join or leave different groups. Groups\nmay dynamically export new interfaces, they support service discovery, and they\ncan be queried at runtime for the interfaces they support. We define an\noperational semantics and a static type system for this model of adaptive\nobject groups, and show that well-typed programs do not cause\nmethod-not-understood errors at runtime.\n", "versions": [{"version": "v1", "created": "Wed, 22 Aug 2012 21:57:45 GMT"}], "update_date": "2012-08-24", "authors_parsed": [["Bj\u00f8rk", "Joakim", "", "University of Oslo"], ["Clarke", "Dave", "", "Katholieke\n  Universiteit Leuven"], ["Johnsen", "Einar Broch", "", "University of Oslo"], ["Owe", "Olaf", "", "University of Oslo"]]}, {"id": "1208.4632", "submitter": "EPTCS", "authors": "Minas Charalambides (University of Illinois at Urbana-Champaign),\n  Peter Dinges (University of Illinois at Urbana-Champaign), Gul Agha\n  (University of Illinois at Urbana-Champaign)", "title": "Parameterized Concurrent Multi-Party Session Types", "comments": "In Proceedings FOCLASA 2012, arXiv:1208.4327", "journal-ref": "EPTCS 91, 2012, pp. 16-30", "doi": "10.4204/EPTCS.91.2", "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Session types have been proposed as a means of statically verifying\nimplementations of communication protocols. Although prior work has been\nsuccessful in verifying some classes of protocols, it does not cope well with\nparameterized, multi-actor scenarios with inherent asynchrony. For example, the\nsliding window protocol is inexpressible in previously proposed session type\nsystems. This paper describes System-A, a new typing language which overcomes\nmany of the expressiveness limitations of prior work. System-A explicitly\nsupports asynchrony and parallelism, as well as multiple forms of\nparameterization. We define System-A and show how it can be used for the static\nverification of a large class of asynchronous communication protocols.\n", "versions": [{"version": "v1", "created": "Wed, 22 Aug 2012 21:58:46 GMT"}], "update_date": "2012-08-24", "authors_parsed": [["Charalambides", "Minas", "", "University of Illinois at Urbana-Champaign"], ["Dinges", "Peter", "", "University of Illinois at Urbana-Champaign"], ["Agha", "Gul", "", "University of Illinois at Urbana-Champaign"]]}, {"id": "1208.5895", "submitter": "Jacob Thamsborg", "authors": "Jacob Thamsborg (IT University of Copenhagen), Lars Birkedal (IT\n  University of Copenhagen), Hongseok Yang (University of Oxford)", "title": "Two for the Price of One: Lifting Separation Logic Assertions", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 3 (September\n  21, 2012) lmcs:997", "doi": "10.2168/LMCS-8(3:22)2012", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recently, data abstraction has been studied in the context of separation\nlogic, with noticeable practical successes: the developed logics have enabled\nclean proofs of tricky challenging programs, such as subject-observer patterns,\nand they have become the basis of efficient verification tools for Java\n(jStar), C (VeriFast) and Hoare Type Theory (Ynot). In this paper, we give a\nnew semantic analysis of such logic-based approaches using Reynolds's\nrelational parametricity. The core of the analysis is our lifting theorems,\nwhich give a sound and complete condition for when a true implication between\nassertions in the standard interpretation entails that the same implication\nholds in a relational interpretation. Using these theorems, we provide an\nalgorithm for identifying abstraction-respecting client-side proofs; the proofs\nensure that clients cannot distinguish two appropriately-related module\nimplementations.\n", "versions": [{"version": "v1", "created": "Wed, 29 Aug 2012 12:25:10 GMT"}, {"version": "v2", "created": "Thu, 20 Sep 2012 08:02:36 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Thamsborg", "Jacob", "", "IT University of Copenhagen"], ["Birkedal", "Lars", "", "IT\n  University of Copenhagen"], ["Yang", "Hongseok", "", "University of Oxford"]]}, {"id": "1208.5915", "submitter": "EPTCS", "authors": "G\\'erard Boudol (INRIA Sophia Antipolis), Gustavo Petri (Purdue\n  University), Bernard Serpette (INRIA Sophia Antipolis)", "title": "Relaxed Operational Semantics of Concurrent Programming Languages", "comments": "In Proceedings EXPRESS/SOS 2012, arXiv:1208.2440", "journal-ref": "EPTCS 89, 2012, pp. 19-33", "doi": "10.4204/EPTCS.89.3", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a novel, operational framework to formally describe the semantics\nof concurrent programs running within the context of a relaxed memory model.\nOur framework features a \"temporary store\" where the memory operations issued\nby the threads are recorded, in program order. A memory model then specifies\nthe conditions under which a pending operation from this sequence is allowed to\nbe globally performed, possibly out of order. The memory model also involves a\n\"write grain,\" accounting for architectures where a thread may read a write\nthat is not yet globally visible. Our formal model is supported by a software\nsimulator, allowing us to run litmus tests in our semantics.\n", "versions": [{"version": "v1", "created": "Tue, 14 Aug 2012 01:51:38 GMT"}], "update_date": "2012-08-30", "authors_parsed": [["Boudol", "G\u00e9rard", "", "INRIA Sophia Antipolis"], ["Petri", "Gustavo", "", "Purdue\n  University"], ["Serpette", "Bernard", "", "INRIA Sophia Antipolis"]]}, {"id": "1208.6152", "submitter": "Egor Derevenetc", "authors": "Ahmed Bouajjani, Egor Derevenetc, Roland Meyer", "title": "Checking Robustness against TSO", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present algorithms for checking and enforcing robustness of concurrent\nprograms against the Total Store Ordering (TSO) memory model. A program is\nrobust if all its TSO computations correspond to computations under the\nSequential Consistency (SC) semantics.\n  We provide a complete characterization of non-robustness in terms of\nso-called attacks: a restricted form of (harmful) out-of-program-order\nexecutions. Then, we show that detecting attacks can be parallelized, and can\nbe solved using state reachability queries under SC semantics in a suitably\ninstrumented program obtained by a linear size source-to-source translation.\nImportantly, the construction is valid for an arbitrary number of addresses and\nan arbitrary number of parallel threads, and it is independent from the data\ndomain and from the size of store buffers in the TSO semantics. In particular,\nwhen the data domain is finite and the number of addresses is fixed, we obtain\ndecidability and complexity results for robustness, even for an arbitrary\nnumber of threads.\n  As a second contribution, we provide an algorithm for computing an optimal\nset of fences that enforce robustness. We consider two criteria of optimality:\nminimization of program size and maximization of its performance. The\nalgorithms we define are implemented, and we successfully applied them to\nanalyzing and correcting several concurrent algorithms.\n", "versions": [{"version": "v1", "created": "Thu, 30 Aug 2012 12:32:01 GMT"}, {"version": "v2", "created": "Mon, 29 Oct 2012 10:31:44 GMT"}], "update_date": "2012-10-30", "authors_parsed": [["Bouajjani", "Ahmed", ""], ["Derevenetc", "Egor", ""], ["Meyer", "Roland", ""]]}]