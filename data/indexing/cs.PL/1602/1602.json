[{"id": "1602.00602", "submitter": "Edd Barrett Dr", "authors": "Edd Barrett, Carl Friedrich Bolz-Tereick, Rebecca Killick, Sarah\n  Mount, Laurence Tratt", "title": "Virtual Machine Warmup Blows Hot and Cold", "comments": "40 pages, 11 figures, 9 tables, 3 listings", "journal-ref": "Object-Oriented Programming, Systems, Languages & Applications.\n  October 2017, Pages 52:1--52:27", "doi": "10.1145/3133876", "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Virtual Machines (VMs) with Just-In-Time (JIT) compilers are traditionally\nthought to execute programs in two phases: the initial warmup phase determines\nwhich parts of a program would most benefit from dynamic compilation, before\nJIT compiling those parts into machine code; subsequently the program is said\nto be at a steady state of peak performance. Measurement methodologies almost\nalways discard data collected during the warmup phase such that reported\nmeasurements focus entirely on peak performance. We introduce a fully automated\nstatistical approach, based on changepoint analysis, which allows us to\ndetermine if a program has reached a steady state and, if so, whether that\nrepresents peak performance or not. Using this, we show that even when run in\nthe most controlled of circumstances, small, deterministic, widely studied\nmicrobenchmarks often fail to reach a steady state of peak performance on a\nvariety of common VMs. Repeating our experiment on 3 different machines, we\nfound that at most 43.5% of <VM, benchmark> pairs consistently reach a steady\nstate of peak performance.\n", "versions": [{"version": "v1", "created": "Mon, 1 Feb 2016 17:27:06 GMT"}, {"version": "v2", "created": "Thu, 22 Dec 2016 23:48:19 GMT"}, {"version": "v3", "created": "Mon, 24 Apr 2017 11:57:38 GMT"}, {"version": "v4", "created": "Thu, 27 Jul 2017 16:14:42 GMT"}, {"version": "v5", "created": "Wed, 20 Sep 2017 16:20:23 GMT"}, {"version": "v6", "created": "Fri, 6 Oct 2017 16:51:52 GMT"}], "update_date": "2018-04-23", "authors_parsed": [["Barrett", "Edd", ""], ["Bolz-Tereick", "Carl Friedrich", ""], ["Killick", "Rebecca", ""], ["Mount", "Sarah", ""], ["Tratt", "Laurence", ""]]}, {"id": "1602.00786", "submitter": "EPTCS", "authors": "Pavol \\v{C}ern\\'y (University of Colorado Boulder), Viktor Kuncak\n  (EPFL), Madhusudan Parthasarathy (University of Illinois Urbana-Champaign)", "title": "Proceedings Fourth Workshop on Synthesis", "comments": null, "journal-ref": "EPTCS 202, 2016", "doi": "10.4204/EPTCS.202", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The SYNT workshop aims to bring together researchers interested in the broad\narea of synthesis of computing systems. The goal is to foster the development\nof frontier techniques in automating the development of computing system.\nContributions of interest include algorithms, complexity and decidability\nanalysis, as well as reproducible heuristics, implemented tools, and\nexperimental evaluation. Application domains include software, hardware,\nembedded, and cyberphysical systems. Computation models include functional,\nreactive, hybrid and timed systems. Identifying, formalizing, and evaluating\nsynthesis in particular application domains is encouraged.\n  The fourth iteration of the workshop took place in San Francisco, CA, USA. It\nwas co-located with the 27th International Conference on Computer Aided\nVerification. The workshop included five contributed talks and two invited\ntalks. In addition, it featured a special session about the Syntax-Guided\nSynthesis Competition (SyGuS) and the SyntComp Synthesis competition.\n", "versions": [{"version": "v1", "created": "Tue, 2 Feb 2016 04:25:10 GMT"}], "update_date": "2016-02-03", "authors_parsed": [["\u010cern\u00fd", "Pavol", "", "University of Colorado Boulder"], ["Kuncak", "Viktor", "", "EPFL"], ["Parthasarathy", "Madhusudan", "", "University of Illinois Urbana-Champaign"]]}, {"id": "1602.00981", "submitter": "Oliver Bra\\v{c}evac", "authors": "Oliver Bra\\v{c}evac and Sebastian Erdweg and Guido Salvaneschi and\n  Mira Mezini", "title": "CPL: A Core Language for Cloud Computing -- Technical Report", "comments": "Technical report accompanying the MODULARITY '16 submission", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Running distributed applications in the cloud involves deployment. That is,\ndistribution and configuration of application services and middleware\ninfrastructure. The considerable complexity of these tasks resulted in the\nemergence of declarative JSON-based domain-specific deployment languages to\ndevelop deployment programs. However, existing deployment programs unsafely\ncompose artifacts written in different languages, leading to bugs that are hard\nto detect before run time. Furthermore, deployment languages do not provide\nextension points for custom implementations of existing cloud services such as\napplication-specific load balancing policies.\n  To address these shortcomings, we propose CPL (Cloud Platform Language), a\nstatically-typed core language for programming both distributed applications as\nwell as their deployment on a cloud platform. In CPL, application services and\ndeployment programs interact through statically typed, extensible interfaces,\nand an application can trigger further deployment at run time. We provide a\nformal semantics of CPL and demonstrate that it enables type-safe, composable\nand extensible libraries of service combinators, such as load balancing and\nfault tolerance.\n", "versions": [{"version": "v1", "created": "Tue, 2 Feb 2016 15:48:50 GMT"}, {"version": "v2", "created": "Fri, 5 Feb 2016 19:24:30 GMT"}], "update_date": "2016-02-08", "authors_parsed": [["Bra\u010devac", "Oliver", ""], ["Erdweg", "Sebastian", ""], ["Salvaneschi", "Guido", ""], ["Mezini", "Mira", ""]]}, {"id": "1602.01075", "submitter": "Mehrdad Afshari", "authors": "Mehrdad Afshari, Zhendong Su", "title": "Toward Rapid Transformation of Ideas into Software", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A key mission of computer science is to enable people realize their creative\nideas as naturally and painlessly as possible. Software engineering is at the\ncenter of this mission -- software technologies enable reification of ideas\ninto working systems. As computers become ubiquitous, both in availability and\nthe aspects of human lives they touch, the quantity and diversity of ideas also\nrapidly grow. Our programming systems and technologies need to evolve to make\nthis reification process -- transforming ideas to software -- as quick and\naccessible as possible.\n  The goal of this paper is twofold. First, it advocates and highlights the\n\"transforming ideas to software\" mission as a moonshot for software engineering\nresearch. This is a long-term direction for the community, and there is no\nsilver bullet that can get us there. To make this mission a reality, as a\ncommunity, we need to improve the status quo across many dimensions. Thus, the\nsecond goal is to outline a number of directions to modernize our contemporary\nprogramming technologies for decades to come, describe work that has been\nundertaken along those vectors, and pinpoint critical challenges.\n", "versions": [{"version": "v1", "created": "Tue, 2 Feb 2016 20:43:59 GMT"}], "update_date": "2016-02-04", "authors_parsed": [["Afshari", "Mehrdad", ""], ["Su", "Zhendong", ""]]}, {"id": "1602.01170", "submitter": "EPTCS", "authors": "Rajeev Alur (University of Pennsylvania), Dana Fisman (University of\n  Pennsylvania), Rishabh Singh (Microsoft Research), Armando Solar-Lezama\n  (Massachusetts Institute of Technology)", "title": "Results and Analysis of SyGuS-Comp'15", "comments": "In Proceedings SYNT 2015, arXiv:1602.00786", "journal-ref": "EPTCS 202, 2016, pp. 3-26", "doi": "10.4204/EPTCS.202.3", "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Syntax-Guided Synthesis (SyGuS) is the computational problem of finding an\nimplementation f that meets both a semantic constraint given by a logical\nformula $\\varphi$ in a background theory T, and a syntactic constraint given by\na grammar G, which specifies the allowed set of candidate implementations. Such\na synthesis problem can be formally defined in SyGuS-IF, a language that is\nbuilt on top of SMT-LIB.\n  The Syntax-Guided Synthesis Competition (SyGuS-comp) is an effort to\nfacilitate, bring together and accelerate research and development of efficient\nsolvers for SyGuS by providing a platform for evaluating different synthesis\ntechniques on a comprehensive set of benchmarks. In this year's competition we\nadded two specialized tracks: a track for conditional linear arithmetic, where\nthe grammar need not be specified and is implicitly assumed to be that of the\nLIA logic of SMT-LIB, and a track for invariant synthesis problems, with\nspecial constructs conforming to the structure of an invariant synthesis\nproblem. This paper presents and analyzes the results of SyGuS-comp'15.\n", "versions": [{"version": "v1", "created": "Wed, 3 Feb 2016 02:49:40 GMT"}], "update_date": "2016-02-04", "authors_parsed": [["Alur", "Rajeev", "", "University of Pennsylvania"], ["Fisman", "Dana", "", "University of\n  Pennsylvania"], ["Singh", "Rishabh", "", "Microsoft Research"], ["Solar-Lezama", "Armando", "", "Massachusetts Institute of Technology"]]}, {"id": "1602.01173", "submitter": "EPTCS", "authors": "Ioannis Filippidis, Richard M. Murray, Gerard J. Holzmann", "title": "A multi-paradigm language for reactive synthesis", "comments": "In Proceedings SYNT 2015, arXiv:1602.00786", "journal-ref": "EPTCS 202, 2016, pp. 73-97", "doi": "10.4204/EPTCS.202.6", "report-no": null, "categories": "cs.LO cs.PL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes a language for describing reactive synthesis problems\nthat integrates imperative and declarative elements. The semantics is defined\nin terms of two-player turn-based infinite games with full information.\nCurrently, synthesis tools accept linear temporal logic (LTL) as input, but\nthis description is less structured and does not facilitate the expression of\nsequential constraints. This motivates the use of a structured programming\nlanguage to specify synthesis problems. Transition systems and guarded commands\nserve as imperative constructs, expressed in a syntax based on that of the\nmodeling language Promela. The syntax allows defining which player controls\ndata and control flow, and separating a program into assumptions and\nguarantees. These notions are necessary for input to game solvers. The\nintegration of imperative and declarative paradigms allows using the paradigm\nthat is most appropriate for expressing each requirement. The declarative part\nis expressed in the LTL fragment of generalized reactivity(1), which admits\nefficient synthesis algorithms, extended with past LTL. The implementation\ntranslates Promela to input for the Slugs synthesizer and is written in Python.\nThe AMBA AHB bus case study is revisited and synthesized efficiently,\nidentifying the need to reorder binary decision diagrams during strategy\nconstruction, in order to prevent the exponential blowup observed in previous\nwork.\n", "versions": [{"version": "v1", "created": "Wed, 3 Feb 2016 02:50:18 GMT"}], "update_date": "2016-02-04", "authors_parsed": [["Filippidis", "Ioannis", ""], ["Murray", "Richard M.", ""], ["Holzmann", "Gerard J.", ""]]}, {"id": "1602.02715", "submitter": "Stanis{\\l}aw  Ambroszkiewicz", "authors": "Stanislaw Ambroszkiewicz", "title": "On the notion of \"von Neumann vicious circle\" coined by John Backus", "comments": "In this version (March 7, 2016) only small error in Fig. 3 was\n  removed. Keywords: von Neumann bottleneck, von Neumann vicious circle,\n  non-von Neumann computer architectures, lazy evaluation, higher order\n  functionals, functional programming languages, higher order HDL (Hardware\n  Description Language)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  \"The von Neumann vicious circle\" means that non-von Neumann computer\narchitectures cannot be developed because of the lack of widely available and\neffective non-von Neumann languages. New languages cannot be created because of\nlack of conceptual foundations for non-von Neumann architectures. The reason is\nthat programming languages are high-level abstract isomorphic copies of von\nNeumann computer architectures. This constitutes the current paradigm in\nComputer Science. The paradigm is equivalent to the predominant view that\ncomputations on higher order objects (functionals) can be done only\nsymbolically, i.e. by term rewriting. The paper is a short introduction to the\npapers arXiv:1501.03043 and arXiv:1510.02787 trying to break the paradigm by\nintroducing a framework that may be seen as a higher order functional HDL\n(Hardware Description Language).\n", "versions": [{"version": "v1", "created": "Wed, 3 Feb 2016 19:36:23 GMT"}, {"version": "v2", "created": "Mon, 7 Mar 2016 20:20:10 GMT"}], "update_date": "2016-03-08", "authors_parsed": [["Ambroszkiewicz", "Stanislaw", ""]]}, {"id": "1602.03254", "submitter": "EPTCS", "authors": "Simon Gay (University of Glasgow, UK), Jade Alglave (University\n  College London, UK)", "title": "Proceedings Eighth International Workshop on Programming Language\n  Approaches to Concurrency- and Communication-cEntric Software", "comments": null, "journal-ref": "EPTCS 203, 2016", "doi": "10.4204/EPTCS.203", "report-no": null, "categories": "cs.PL cs.DC cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  PLACES 2015 (full title: Programming Language Approaches to Concurrency- and\nCommunication-Centric Software) is the eighth edition of the PLACES workshop\nseries. After the first PLACES, which was affiliated to DisCoTec in 2008, the\nworkshop has been part of ETAPS every year since 2009 and is now an established\npart of the ETAPS satellite events. PLACES 2015 was held on 18th April in\nLondon, UK.\n  The workshop series was started in order to promote the application of novel\nprogramming language ideas to the increasingly important problem of developing\nsoftware for systems in which concurrency and communication are intrinsic\naspects. This includes software for both multi-core systems and large-scale\ndistributed and/or service-oriented systems. The scope of PLACES includes new\nprogramming language features, whole new programming language designs, new type\nsystems, new semantic approaches, new program analysis techniques, and new\nimplementation mechanisms.\n  This volume consists of revised versions of the papers that were presented at\nthe workshop.\n", "versions": [{"version": "v1", "created": "Wed, 10 Feb 2016 03:45:11 GMT"}], "update_date": "2016-02-11", "authors_parsed": [["Gay", "Simon", "", "University of Glasgow, UK"], ["Alglave", "Jade", "", "University\n  College London, UK"]]}, {"id": "1602.03591", "submitter": "EPTCS", "authors": "Dominic Orchard (Imperial College London), Nobuko Yoshida (Imperial\n  College London)", "title": "Using session types as an effect system", "comments": "In Proceedings PLACES 2015, arXiv:1602.03254", "journal-ref": "EPTCS 203, 2016, pp. 1-13", "doi": "10.4204/EPTCS.203.1", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Side effects are a core part of practical programming. However, they are\noften hard to reason about, particularly in a concurrent setting. We propose a\nfoundation for reasoning about concurrent side effects using sessions.\nPrimarily, we show that session types are expressive enough to encode an effect\nsystem for stateful processes. This is formalised via an effect-preserving\nencoding of a simple imperative language with an effect system into the\npi-calculus with session primitives and session types (into which we encode\neffect specifications). This result goes towards showing a connection between\nthe expressivity of session types and effect systems. We briefly discuss how\nthe encoding could be extended and applied to reason about and control\nconcurrent side effects.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2016 01:19:51 GMT"}], "update_date": "2016-02-12", "authors_parsed": [["Orchard", "Dominic", "", "Imperial College London"], ["Yoshida", "Nobuko", "", "Imperial\n  College London"]]}, {"id": "1602.03593", "submitter": "EPTCS", "authors": "Mariangiola Dezani-Ciancaglini (Universit\\`a di Torino, Italy), Silvia\n  Ghilezan (Univerzitet u Novom Sadu, Serbia), Svetlana Jak\\v{s}i\\'c\n  (Univerzitet u Novom Sadu, Serbia), Jovanka Pantovi\\'c (Univerzitet u Novom\n  Sadu, Serbia), Nobuko Yoshida (Imperial College London, UK)", "title": "Precise subtyping for synchronous multiparty sessions", "comments": "In Proceedings PLACES 2015, arXiv:1602.03254", "journal-ref": "EPTCS 203, 2016, pp. 29-43", "doi": "10.4204/EPTCS.203.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The notion of subtyping has gained an important role both in theoretical and\napplicative domains: in lambda and concurrent calculi as well as in programming\nlanguages. The soundness and the completeness, together referred to as the\npreciseness of subtyping, can be considered from two different points of view:\noperational and denotational. The former preciseness has been recently\ndeveloped with respect to type safety, i.e. the safe replacement of a term of a\nsmaller type when a term of a bigger type is expected. The latter preciseness\nis based on the denotation of a type which is a mathematical object that\ndescribes the meaning of the type in accordance with the denotations of other\nexpressions from the language. The result of this paper is the operational and\ndenotational preciseness of the subtyping for a synchronous multiparty session\ncalculus. The novelty of this paper is the introduction of characteristic\nglobal types to prove the operational completeness.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2016 01:20:10 GMT"}], "update_date": "2016-02-12", "authors_parsed": [["Dezani-Ciancaglini", "Mariangiola", "", "Universit\u00e0 di Torino, Italy"], ["Ghilezan", "Silvia", "", "Univerzitet u Novom Sadu, Serbia"], ["Jak\u0161i\u0107", "Svetlana", "", "Univerzitet u Novom Sadu, Serbia"], ["Pantovi\u0107", "Jovanka", "", "Univerzitet u Novom\n  Sadu, Serbia"], ["Yoshida", "Nobuko", "", "Imperial College London, UK"]]}, {"id": "1602.03594", "submitter": "EPTCS", "authors": "Geoffrey Brown (Indiana University School of Informatics and\n  Computing), Amr Sabry (Indiana University School of Informatics and\n  Computing)", "title": "Reversible Communicating Processes", "comments": "In Proceedings PLACES 2015, arXiv:1602.03254", "journal-ref": "EPTCS 203, 2016, pp. 45-59", "doi": "10.4204/EPTCS.203.4", "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reversible distributed programs have the ability to abort unproductive\ncomputation paths and backtrack, while unwinding communication that occurred in\nthe aborted paths. While it is natural to assume that reversibility implies\nfull state recovery (as with traditional roll-back recovery protocols), an\ninteresting alternative is to separate backtracking from local state recovery.\nFor example, such a model could be used to create complex transactions out of\nnested compensable transactions where a programmer-supplied compensation\ndefines the work required to \"unwind\" a transaction.\n  Reversible distributed computing has received considerable theoretical\nattention, but little reduction to practice; the few published implementations\nof languages supporting reversibility depend upon a high degree of central\ncontrol. The objective of this paper is to demonstrate that a practical\nreversible distributed language can be efficiently implemented in a fully\ndistributed manner.\n  We discuss such a language, supporting CSP-style synchronous communication,\nembedded in Scala. While this language provided the motivation for the work\ndescribed in this paper, our focus is upon the distributed implementation. In\nparticular, we demonstrate that a \"high-level\" semantic model can be\nimplemented using a simple point-to-point protocol.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2016 01:20:19 GMT"}], "update_date": "2016-02-12", "authors_parsed": [["Brown", "Geoffrey", "", "Indiana University School of Informatics and\n  Computing"], ["Sabry", "Amr", "", "Indiana University School of Informatics and\n  Computing"]]}, {"id": "1602.03595", "submitter": "EPTCS", "authors": "Franco Barbanera (Dipartimento di Matematica e Informatica, University\n  of Catania), Mariangiola Dezani-Ciancaglini (Dipartimento di Informatica,\n  University of Torino), Ivan Lanese (Dipartimento di Informatica - Scienza e\n  Ingegneria, University of Bologna/INRIA), Ugo de'Liguoro (Dipartimento di\n  Informatica, University of Torino)", "title": "Retractable Contracts", "comments": "In Proceedings PLACES 2015, arXiv:1602.03254", "journal-ref": "EPTCS 203, 2016, pp. 61-72", "doi": "10.4204/EPTCS.203.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In calculi for modelling communication protocols, internal and external\nchoices play dual roles. Two external choices can be viewed naturally as dual\ntoo, as they represent an agreement between the communicating parties. If the\ninteraction fails, the past agreements are good candidates as points where to\nroll back, in order to take a different agreement. We propose a variant of\ncontracts with synchronous rollbacks to agreement points in case of deadlock.\nThe new calculus is equipped with a compliance relation which is shown to be\ndecidable.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2016 01:20:29 GMT"}], "update_date": "2016-02-12", "authors_parsed": [["Barbanera", "Franco", "", "Dipartimento di Matematica e Informatica, University\n  of Catania"], ["Dezani-Ciancaglini", "Mariangiola", "", "Dipartimento di Informatica,\n  University of Torino"], ["Lanese", "Ivan", "", "Dipartimento di Informatica - Scienza e\n  Ingegneria, University of Bologna/INRIA"], ["de'Liguoro", "Ugo", "", "Dipartimento di\n  Informatica, University of Torino"]]}, {"id": "1602.03596", "submitter": "EPTCS", "authors": "Silvia Ghilezan (University of Novi Sad, Serbia), Svetlana\n  Jak\\v{s}i\\'c (University of Novi Sad, Serbia), Jovanka Pantovi\\'c (University\n  of Novi Sad, Serbia), Jorge A. P\\'erez (University of Groningen, The\n  Netherlands), Hugo Torres Vieira (IMT Institute for Advanced Studies Lucca,\n  Italy)", "title": "A Typed Model for Dynamic Authorizations", "comments": "In Proceedings PLACES 2015, arXiv:1602.03254", "journal-ref": "EPTCS 203, 2016, pp. 73-84", "doi": "10.4204/EPTCS.203.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Security requirements in distributed software systems are inherently dynamic.\nIn the case of authorization policies, resources are meant to be accessed only\nby authorized parties, but the authorization to access a resource may be\ndynamically granted/yielded. We describe ongoing work on a model for specifying\ncommunication and dynamic authorization handling. We build upon the pi-calculus\nso as to enrich communication-based systems with authorization specification\nand delegation; here authorizations regard channel usage and delegation refers\nto the act of yielding an authorization to another party. Our model includes:\n(i) a novel scoping construct for authorization, which allows to specify\nauthorization boundaries, and (ii) communication primitives for authorizations,\nwhich allow to pass around authorizations to act on a given channel. An\nauthorization error may consist in, e.g., performing an action along a name\nwhich is not under an appropriate authorization scope. We introduce a typing\ndiscipline that ensures that processes never reduce to authorization errors,\neven when authorizations are dynamically delegated.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2016 01:20:38 GMT"}], "update_date": "2016-02-12", "authors_parsed": [["Ghilezan", "Silvia", "", "University of Novi Sad, Serbia"], ["Jak\u0161i\u0107", "Svetlana", "", "University of Novi Sad, Serbia"], ["Pantovi\u0107", "Jovanka", "", "University\n  of Novi Sad, Serbia"], ["P\u00e9rez", "Jorge A.", "", "University of Groningen, The\n  Netherlands"], ["Vieira", "Hugo Torres", "", "IMT Institute for Advanced Studies Lucca,\n  Italy"]]}, {"id": "1602.03598", "submitter": "EPTCS", "authors": "Philipp Haller (KTH Royal Institute of Technology), Heather Miller\n  (EPFL)", "title": "Distributed Programming via Safe Closure Passing", "comments": "In Proceedings PLACES 2015, arXiv:1602.03254", "journal-ref": "EPTCS 203, 2016, pp. 99-107", "doi": "10.4204/EPTCS.203.8", "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Programming systems incorporating aspects of functional programming, e.g.,\nhigher-order functions, are becoming increasingly popular for large-scale\ndistributed programming. New frameworks such as Apache Spark leverage\nfunctional techniques to provide high-level, declarative APIs for in-memory\ndata analytics, often outperforming traditional \"big data\" frameworks like\nHadoop MapReduce. However, widely-used programming models remain rather ad-hoc;\naspects such as implementation trade-offs, static typing, and semantics are not\nyet well-understood. We present a new asynchronous programming model that has\nat its core several principles facilitating functional processing of\ndistributed data. The emphasis of our model is on simplicity, performance, and\nexpressiveness. The primary means of communication is by passing functions\n(closures) to distributed, immutable data. To ensure safe and efficient\ndistribution of closures, our model leverages both syntactic and type-based\nrestrictions. We report on a prototype implementation in Scala. Finally, we\npresent preliminary experimental results evaluating the performance impact of a\nstatic, type-based optimization of serialization.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2016 01:20:58 GMT"}], "update_date": "2016-02-12", "authors_parsed": [["Haller", "Philipp", "", "KTH Royal Institute of Technology"], ["Miller", "Heather", "", "EPFL"]]}, {"id": "1602.03599", "submitter": "EPTCS", "authors": "Juliana Franco (Imperial College London), Sophia Drossopoulou\n  (Imperial College London)", "title": "Behavioural types for non-uniform memory accesses", "comments": "In Proceedings PLACES 2015, arXiv:1602.03254", "journal-ref": "EPTCS 203, 2016, pp. 109-120", "doi": "10.4204/EPTCS.203.9", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Concurrent programs executing on NUMA architectures consist of concurrent\nentities (e.g. threads, actors) and data placed on different nodes. Execution\nof these concurrent entities often reads or updates states from remote nodes.\nThe performance of such systems depends on the extent to which the concurrent\nentities can be executing in parallel, and on the amount of the remote reads\nand writes.\n  We consider an actor-based object oriented language, and propose a type\nsystem which expresses the topology of the program (the placement of the actors\nand data on the nodes), and an effect system which characterises remote reads\nand writes (in terms of which node reads/writes from which other nodes). We use\na variant of ownership types for the topology, and a combination of behavioural\nand ownership types for the effect system.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2016 01:21:09 GMT"}], "update_date": "2016-02-12", "authors_parsed": [["Franco", "Juliana", "", "Imperial College London"], ["Drossopoulou", "Sophia", "", "Imperial College London"]]}, {"id": "1602.03729", "submitter": "Fabrizio Montesi", "authors": "Lu\\'is Cruz-Filipe and Fabrizio Montesi", "title": "A Language for the Declarative Composition of Concurrent Protocols", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-319-60225-7_7", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A recent study of bugs in real-world concurrent and distributed systems found\nthat, while implementations of individual protocols tend to be robust, the\ncomposition of multiple protocols and its interplay with internal computation\nis the culprit for most errors. Multiparty Session Types and Choreographic\nProgramming are methodologies for developing correct-by-construction concurrent\nand distributed software, based on global descriptions of communication flows.\nHowever, protocol composition is either limited or left unchecked. Inspired by\nthese two methodologies, in this work we present a new language model for the\nsafe composition of protocols, called Procedural Choreographies (PC). Protocols\nin PC are procedures, parameterised on the processes that enact them.\nProcedures define communications declaratively using global descriptions, and\nprograms are written by invoking and composing these procedures. An\nimplementation in terms of a process model is then mechanically synthesised,\nguaranteeing correctness and deadlock-freedom. We study PC in the settings of\nsynchronous and asynchronous communications, and illustrate its expressivity\nwith some representative examples.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2016 14:02:09 GMT"}, {"version": "v2", "created": "Mon, 24 Oct 2016 06:38:19 GMT"}], "update_date": "2017-08-09", "authors_parsed": [["Cruz-Filipe", "Lu\u00eds", ""], ["Montesi", "Fabrizio", ""]]}, {"id": "1602.04056", "submitter": "Mathias Payer", "authors": "Nathan Burow, Scott A. Carr, Joseph Nash, Per Larsen, Michael Franz,\n  Stefan Brunthaler, Mathias Payer", "title": "Control-Flow Integrity: Precision, Security, and Performance", "comments": "Version submitted to ACM CSUR 01/27/17", "journal-ref": null, "doi": "10.1109/TSE.2016.2625248", "report-no": null, "categories": "cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Memory corruption errors in C/C++ programs remain the most common source of\nsecurity vulnerabilities in today's systems. Control-flow hijacking attacks\nexploit memory corruption vulnerabilities to divert program execution away from\nthe intended control flow. Researchers have spent more than a decade studying\nand refining defenses based on Control-Flow Integrity (CFI), and this technique\nis now integrated into several production compilers. However, so far no study\nhas systematically compared the various proposed CFI mechanisms, nor is there\nany protocol on how to compare such mechanisms.\n  We compare a broad range of CFI mechanisms using a unified nomenclature based\non (i) a qualitative discussion of the conceptual security guarantees, (ii) a\nquantitative security evaluation, and (iii) an empirical evaluation of their\nperformance in the same test environment. For each mechanism, we evaluate (i)\nprotected types of control-flow transfers, (ii) the precision of the protection\nfor forward and backward edges. For open-source compiler-based implementations,\nwe additionally evaluate (iii) the generated equivalence classes and target\nsets, and (iv) the runtime performance.\n", "versions": [{"version": "v1", "created": "Fri, 12 Feb 2016 13:52:34 GMT"}, {"version": "v2", "created": "Mon, 2 May 2016 21:03:55 GMT"}, {"version": "v3", "created": "Fri, 27 Jan 2017 16:23:22 GMT"}], "update_date": "2019-11-26", "authors_parsed": [["Burow", "Nathan", ""], ["Carr", "Scott A.", ""], ["Nash", "Joseph", ""], ["Larsen", "Per", ""], ["Franz", "Michael", ""], ["Brunthaler", "Stefan", ""], ["Payer", "Mathias", ""]]}, {"id": "1602.04503", "submitter": "Catalin Hritcu", "authors": "Yannis Juglaret, Catalin Hritcu, Arthur Azevedo de Amorim, Boris Eng,\n  Benjamin C. Pierce", "title": "Beyond Good and Evil: Formalizing the Security Guarantees of\n  Compartmentalizing Compilation", "comments": "Nits", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compartmentalization is good security-engineering practice. By breaking a\nlarge software system into mutually distrustful components that run with\nminimal privileges, restricting their interactions to conform to well-defined\ninterfaces, we can limit the damage caused by low-level attacks such as\ncontrol-flow hijacking. When used to defend against such attacks,\ncompartmentalization is often implemented cooperatively by a compiler and a\nlow-level compartmentalization mechanism. However, the formal guarantees\nprovided by such compartmentalizing compilation have seen surprisingly little\ninvestigation.\n  We propose a new security property, secure compartmentalizing compilation\n(SCC), that formally characterizes the guarantees provided by\ncompartmentalizing compilation and clarifies its attacker model. We reconstruct\nour property by starting from the well-established notion of fully abstract\ncompilation, then identifying and lifting three important limitations that make\nstandard full abstraction unsuitable for compartmentalization. The connection\nto full abstraction allows us to prove SCC by adapting established proof\ntechniques; we illustrate this with a compiler from a simple unsafe imperative\nlanguage with procedures to a compartmentalized abstract machine.\n", "versions": [{"version": "v1", "created": "Sun, 14 Feb 2016 20:37:10 GMT"}, {"version": "v2", "created": "Tue, 16 Feb 2016 08:50:32 GMT"}, {"version": "v3", "created": "Mon, 21 Mar 2016 22:21:24 GMT"}, {"version": "v4", "created": "Sat, 7 May 2016 06:41:04 GMT"}, {"version": "v5", "created": "Thu, 13 Apr 2017 15:47:20 GMT"}, {"version": "v6", "created": "Sat, 15 Apr 2017 09:46:32 GMT"}], "update_date": "2017-04-18", "authors_parsed": [["Juglaret", "Yannis", ""], ["Hritcu", "Catalin", ""], ["de Amorim", "Arthur Azevedo", ""], ["Eng", "Boris", ""], ["Pierce", "Benjamin C.", ""]]}, {"id": "1602.05010", "submitter": "Baltasar Tranc\\'on y Widemann", "authors": "Baltasar Tranc\\'on y Widemann", "title": "Higher-Order Recursion Abstraction: How to Make Ackermann, Knuth and\n  Conway Look Like a Bunch of Primitives, Figuratively Speaking", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  The Ackermann function is a famous total recursive binary function on the\nnatural numbers. It is the archetypal example of such a function that is not\nprimitive recursive, in the sense of classical recursion theory. However, and\nin seeming contradiction, there are generalized notions of total recursion, for\nwhich the Ackermann function is in fact primitive recursive, and often featured\nas a witness for the additional power gained by the generalization. Here, we\ninvestigate techniques for finding and analyzing the primitive form of\ncomplicated recursive functions, namely also Knuth's and Conway's arrow\nnotations, in particular by recursion abstraction, in a framework of functional\nprogram transformation.\n", "versions": [{"version": "v1", "created": "Tue, 16 Feb 2016 13:25:15 GMT"}], "update_date": "2016-02-17", "authors_parsed": [["Widemann", "Baltasar Tranc\u00f3n y", ""]]}, {"id": "1602.05365", "submitter": "Marco Peressotti", "authors": "Marino Miculan, Marco Peressotti", "title": "A Specification of Open Transactional Memory for Haskell", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Transactional memory (TM) has emerged as a promising abstraction for\nconcurrent programming alternative to lock-based synchronizations. However,\nmost TM models admit only isolated transactions, which are not adequate in\nmulti-threaded programming where transactions have to interact via shared data\nbefore committing. In this paper, we present Open Transactional Memory (OTM), a\nprogramming abstraction supporting safe, data-driven interactions between\ncomposable memory transactions. This is achieved by relaxing isolation between\ntransactions, still ensuring atomicity: threads of different transactions can\ninteract by accessing shared variables, but then their transactions have to\ncommit together-actually, these transactions are transparently merged. This\nmodel allows for loosely-coupled interactions since transaction merging is\ndriven only by accesses to shared data, with no need to specify participants\nbeforehand. In this paper we provide a specification of the OTM in the setting\nof Concurrent Haskell, showing that it is a conservative extension of current\nSTM abstraction. In particular, we provide a formal semantics, which allows us\nto prove that OTM satisfies the \\emph{opacity} criterion.\n", "versions": [{"version": "v1", "created": "Wed, 17 Feb 2016 10:46:45 GMT"}], "update_date": "2016-02-18", "authors_parsed": [["Miculan", "Marino", ""], ["Peressotti", "Marco", ""]]}, {"id": "1602.05681", "submitter": "Justin Hsu", "authors": "Gilles Barthe, Marco Gaboardi, Benjamin Gr\\'egoire, Justin Hsu,\n  Pierre-Yves Strub", "title": "A program logic for union bounds", "comments": null, "journal-ref": null, "doi": "10.4230/LIPIcs.ICALP.2016.107", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a probabilistic Hoare logic aHL based on the union bound, a tool\nfrom basic probability theory. While the union bound is simple, it is an\nextremely common tool for analyzing randomized algorithms. In formal\nverification terms, the union bound allows flexible and compositional reasoning\nover possible ways an algorithm may go wrong. It also enables a clean\nseparation between reasoning about probabilities and reasoning about events,\nwhich are expressed as standard first-order formulas in our logic. Notably,\nassertions in our logic are non-probabilistic, even though we can conclude\nprobabilistic facts from the judgments.\n  Our logic can also prove accuracy properties for interactive programs, where\nthe program must produce intermediate outputs as soon as pieces of the input\narrive, rather than accessing the entire input at once. This setting also\nenables adaptivity, where later inputs may depend on earlier intermediate\noutputs. We show how to prove accuracy for several examples from the\ndifferential privacy literature, both interactive and non-interactive.\n", "versions": [{"version": "v1", "created": "Thu, 18 Feb 2016 05:46:25 GMT"}, {"version": "v2", "created": "Mon, 9 May 2016 20:20:08 GMT"}, {"version": "v3", "created": "Fri, 8 Nov 2019 06:05:16 GMT"}], "update_date": "2019-11-11", "authors_parsed": [["Barthe", "Gilles", ""], ["Gaboardi", "Marco", ""], ["Gr\u00e9goire", "Benjamin", ""], ["Hsu", "Justin", ""], ["Strub", "Pierre-Yves", ""]]}, {"id": "1602.05891", "submitter": "Marco Tulio Valente", "authors": "Leonardo Humberto Silva, Daniel Hovadick, Marco Tulio Valente,\n  Alexandre Bergel, Nicolas Anquetil, Anne Etien", "title": "JSClassFinder: A Tool to Detect Class-like Structures in JavaScript", "comments": "VI Brazilian Conference on Software: Theory and Practice (Tools\n  Track), p. 1-8, 2015", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  With the increasing usage of JavaScript in web applications, there is a great\ndemand to write JavaScript code that is reliable and maintainable. To achieve\nthese goals, classes can be emulated in the current JavaScript standard\nversion. In this paper, we propose a reengineering tool to identify such\nclass-like structures and to create an object-oriented model based on\nJavaScript source code. The tool has a parser that loads the AST (Abstract\nSyntax Tree) of a JavaScript application to model its structure. It is also\nintegrated with the Moose platform to provide powerful visualization, e.g., UML\ndiagram and Distribution Maps, and well-known metric values for software\nanalysis. We also provide some examples with real JavaScript applications to\nevaluate the tool.\n", "versions": [{"version": "v1", "created": "Thu, 18 Feb 2016 17:45:05 GMT"}], "update_date": "2016-02-19", "authors_parsed": [["Silva", "Leonardo Humberto", ""], ["Hovadick", "Daniel", ""], ["Valente", "Marco Tulio", ""], ["Bergel", "Alexandre", ""], ["Anquetil", "Nicolas", ""], ["Etien", "Anne", ""]]}, {"id": "1602.06420", "submitter": "Jonathan Warrell", "authors": "Jonathan H. Warrell", "title": "A Probabilistic Dependent Type System based on Non-Deterministic Beta\n  Reduction", "comments": "15 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce Probabilistic Dependent Type Systems (PDTS) via a functional\nlanguage based on a subsystem of intuitionistic type theory including dependent\nsums and products, which is expanded to include stochastic functions. We\nprovide a sampling-based semantics for the language based on non-deterministic\nbeta reduction. Further, we derive a probabilistic logic from the PDTS\nintroduced as a direct result of the Curry-Howard isomorphism. The\nprobabilistic logic derived is shown to provide a universal representation for\nfinite discrete distributions.\n", "versions": [{"version": "v1", "created": "Sat, 20 Feb 2016 15:31:27 GMT"}, {"version": "v2", "created": "Tue, 23 Feb 2016 23:05:10 GMT"}], "update_date": "2016-02-25", "authors_parsed": [["Warrell", "Jonathan H.", ""]]}, {"id": "1602.06568", "submitter": "Martin Berger", "authors": "Martin Berger, Laurence Tratt, Christian Urban", "title": "Modelling homogeneous generative meta-programming", "comments": "ECOOP 2017, to appear", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Homogeneous generative meta-programming (HGMP) enables the generation of\nprogram fragments at compile-time or run-time. We present the first\nfoundational calculus which can model powerful HGMP languages such as Template\nHaskell. The calculus is designed such that we can gradually enhance it with\nthe features needed to model many of the advanced features of real languages.\nAs a demonstration of the flexibility of our approach, we also provide a simple\ntype system for the calculus.\n", "versions": [{"version": "v1", "created": "Sun, 21 Feb 2016 19:18:58 GMT"}, {"version": "v2", "created": "Sun, 23 Apr 2017 18:35:46 GMT"}], "update_date": "2017-04-25", "authors_parsed": [["Berger", "Martin", ""], ["Tratt", "Laurence", ""], ["Urban", "Christian", ""]]}, {"id": "1602.06823", "submitter": "Manuel Mazzara", "authors": "Alexander Tchitchigin, Larisa Safina, Manuel Mazzara, Mohamed Elwakil,\n  Fabrizio Montesi and Victor Rivera", "title": "Refinement types in Jolie", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Jolie is the first language for microservices and it is currently dynamically\ntype checked. This paper considers the opportunity to integrate dynamic and\nstatic type checking with the introduction of refinement types, verified via\nSMT solver. The integration of the two aspects allows a scenario where the\nstatic verification of internal services and the dynamic verification of\n(potentially malicious) external services cooperates in order to reduce testing\neffort and enhancing security.\n", "versions": [{"version": "v1", "created": "Mon, 22 Feb 2016 15:40:04 GMT"}], "update_date": "2016-02-23", "authors_parsed": [["Tchitchigin", "Alexander", ""], ["Safina", "Larisa", ""], ["Mazzara", "Manuel", ""], ["Elwakil", "Mohamed", ""], ["Montesi", "Fabrizio", ""], ["Rivera", "Victor", ""]]}, {"id": "1602.07285", "submitter": "Rohit Singh", "authors": "Rohit Singh, Armando Solar-Lezama", "title": "Automatic Generation of Formula Simplifiers based on Conditional Rewrite\n  Rules", "comments": "Submitted for peer reviewed conference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper addresses the problem of creating simplifiers for logic formulas\nbased on conditional term rewriting. In particular, the paper focuses on a\nprogram synthesis application where formula simplifications have been shown to\nhave a significant impact. We show that by combining machine learning\ntechniques with constraint-based synthesis, it is possible to synthesize a\nformula simplifier fully automatically from a corpus of representative\nproblems, making it possible to create formula simplifiers tailored to specific\nproblem domains. We demonstrate the benefits of our approach for synthesis\nbenchmarks from the SyGuS competition and automated grading.\n", "versions": [{"version": "v1", "created": "Tue, 23 Feb 2016 20:09:33 GMT"}], "update_date": "2016-02-24", "authors_parsed": [["Singh", "Rohit", ""], ["Solar-Lezama", "Armando", ""]]}, {"id": "1602.08406", "submitter": "Nikos Tzevelekos", "authors": "Guilhem Jaber, Nikos Tzevelekos", "title": "Trace semantics for polymorphic references", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a trace semantics for a call-by-value language with full\npolymorphism and higher-order references. This is an operational game semantics\nmodel based on a nominal interpretation of parametricity whereby polymorphic\nvalues are abstracted with special kinds of names. The use of polymorphic\nreferences leads to violations of parametricity which we counter by closely\nrecoding the disclosure of typing information in the semantics. We prove the\nmodel sound for the full language and strengthen our result to full abstraction\nfor a large fragment where polymorphic references obey specific inhabitation\nconditions.\n", "versions": [{"version": "v1", "created": "Fri, 26 Feb 2016 17:14:18 GMT"}, {"version": "v2", "created": "Sun, 14 Aug 2016 15:28:05 GMT"}], "update_date": "2016-08-16", "authors_parsed": [["Jaber", "Guilhem", ""], ["Tzevelekos", "Nikos", ""]]}, {"id": "1602.08778", "submitter": "W{\\l}odzimierz Drabent", "authors": "W{\\l}odzimierz Drabent", "title": "Proving completeness of logic programs with the cut", "comments": "17 pages", "journal-ref": "final version: Formal Aspects of Computing, 2017, 29(1),155-172", "doi": "10.1007/s00165-016-0392-0", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Completeness of a logic program means that the program produces all the\nanswers required by its specification. The cut is an important construct of\nprogramming language Prolog. It prunes part of the search space, this may\nresult in a loss of completeness. This paper proposes a way of proving\ncompleteness of programs with the cut. The semantics of the cut is formalized\nby describing how SLD-trees are pruned. A sufficient condition for completeness\nis presented, proved sound, and illustrated by examples.\n", "versions": [{"version": "v1", "created": "Sun, 28 Feb 2016 22:27:25 GMT"}], "update_date": "2020-01-03", "authors_parsed": [["Drabent", "W\u0142odzimierz", ""]]}, {"id": "1602.08863", "submitter": "Lu\\'is Cruz-Filipe", "authors": "Lu\\'is Cruz-Filipe and Fabrizio Montesi", "title": "Choreographies in Practice", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-319-39570-8_8", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Choreographic Programming is a development methodology for concurrent\nsoftware that guarantees correctness by construction. The key to this paradigm\nis to disallow mismatched I/O operations in programs, called choreographies,\nand then mechanically synthesise distributed implementations in terms of\nstandard process models via a mechanism known as EndPoint Projection (EPP).\n  Despite the promise of choreographic programming, there is still a lack of\npractical evaluations that illustrate the applicability of choreographies to\nconcrete computational problems with standard concurrent solutions. In this\nwork, we explore the potential of choreographies by using Procedural\nChoreographies (PC), a model that we recently proposed, to write distributed\nalgorithms for sorting (Quicksort), solving linear equations (Gaussian\nelimination), and computing Fast Fourier Transform. We discuss the lessons\nlearned from this experiment, giving possible directions for the usage and\nfuture improvements of choreography languages.\n", "versions": [{"version": "v1", "created": "Mon, 29 Feb 2016 08:49:49 GMT"}], "update_date": "2017-08-09", "authors_parsed": [["Cruz-Filipe", "Lu\u00eds", ""], ["Montesi", "Fabrizio", ""]]}, {"id": "1602.09061", "submitter": "Witold Charatonik", "authors": "Witold Charatonik and Piotr Witkowski", "title": "Bounded Model Checking of Pointer Programs Revisited", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bounded model checking of pointer programs is a debugging technique for\nprograms that manipulate dynamically allocated pointer structures on the heap.\nIt is based on the following four observations. First, error conditions like\ndereference of a dangling pointer, are expressible in a~fragment of first-order\nlogic with two-variables. Second, the fragment is closed under weakest\npreconditions wrt. finite paths. Third, data structures like trees, lists etc.\nare expressible by inductive predicates defined in a fragment of Datalog.\nFinally, the combination of the two fragments of the two-variable logic and\nDatalog is decidable.\n  In this paper we improve this technique by extending the expressivity of the\nunderlying logics. In a~sequence of examples we demonstrate that the new logic\nis capable of modeling more sophisticated data structures with more complex\ndependencies on heaps and more complex analyses.\n", "versions": [{"version": "v1", "created": "Mon, 29 Feb 2016 17:35:28 GMT"}], "update_date": "2016-03-02", "authors_parsed": [["Charatonik", "Witold", ""], ["Witkowski", "Piotr", ""]]}]