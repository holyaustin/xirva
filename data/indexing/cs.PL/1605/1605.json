[{"id": "1605.00283", "submitter": "Justin Hsu", "authors": "Gilles Barthe, Gian Pietro Farina, Marco Gaboardi, Emilio Jes\\`us\n  Gallego Arias, Andy Gordon, Justin Hsu, Pierre-Yves Strub", "title": "Differentially Private Bayesian Programming", "comments": null, "journal-ref": null, "doi": "10.1145/2976749.2978371", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present PrivInfer, an expressive framework for writing and verifying\ndifferentially private Bayesian machine learning algorithms. Programs in\nPrivInfer are written in a rich functional probabilistic programming language\nwith constructs for performing Bayesian inference. Then, differential privacy\nof programs is established using a relational refinement type system, in which\nrefinements on probability types are indexed by a metric on distributions. Our\nframework leverages recent developments in Bayesian inference, probabilistic\nprogramming languages, and in relational refinement types. We demonstrate the\nexpressiveness of PrivInfer by verifying privacy for several examples of\nprivate Bayesian inference.\n", "versions": [{"version": "v1", "created": "Sun, 1 May 2016 17:49:30 GMT"}, {"version": "v2", "created": "Wed, 17 Aug 2016 16:27:17 GMT"}], "update_date": "2018-03-16", "authors_parsed": [["Barthe", "Gilles", ""], ["Farina", "Gian Pietro", ""], ["Gaboardi", "Marco", ""], ["Arias", "Emilio Jes\u00f9s Gallego", ""], ["Gordon", "Andy", ""], ["Hsu", "Justin", ""], ["Strub", "Pierre-Yves", ""]]}, {"id": "1605.01352", "submitter": "Michael Hanus", "authors": "Sergio Antoy and Michael Hanus", "title": "Default Rules for Curry", "comments": "To appear in Theory and Practice of Logic Programming (TPLP)", "journal-ref": null, "doi": "10.1017/S1471068416000168", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In functional logic programs, rules are applicable independently of textual\norder, i.e., any rule can potentially be used to evaluate an expression. This\nis similar to logic languages and contrary to functional languages, e.g.,\nHaskell enforces a strict sequential interpretation of rules. However, in some\nsituations it is convenient to express alternatives by means of compact default\nrules. Although default rules are often used in functional programs, the\nnon-deterministic nature of functional logic programs does not allow to\ndirectly transfer this concept from functional to functional logic languages in\na meaningful way. In this paper we propose a new concept of default rules for\nCurry that supports a programming style similar to functional programming while\npreserving the core properties of functional logic programming, i.e.,\ncompleteness, non-determinism, and logic-oriented use of functions. We discuss\nthe basic concept and propose an implementation which exploits advanced\nfeatures of functional logic languages.\n", "versions": [{"version": "v1", "created": "Wed, 4 May 2016 17:18:05 GMT"}], "update_date": "2016-07-06", "authors_parsed": [["Antoy", "Sergio", ""], ["Hanus", "Michael", ""]]}, {"id": "1605.01362", "submitter": "Colin Gordon", "authors": "Esben Andreasen, Colin S. Gordon, Satish Chandra, Manu Sridharan,\n  Frank Tip, Koushik Sen", "title": "Trace Typing: An Approach for Evaluating Retrofitted Type Systems\n  (Extended Version)", "comments": "Samsung Research America Technical Report", "journal-ref": null, "doi": null, "report-no": "SRA-CSIC-2016-001", "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent years have seen growing interest in the retrofitting of type systems\nonto dynamically-typed programming languages, in order to improve type safety,\nprogrammer productivity, or performance. In such cases, type system developers\nmust strike a delicate balance between disallowing certain coding patterns to\nkeep the type system simple, or including them at the expense of additional\ncomplexity and effort. Thus far, the process for designing retrofitted type\nsystems has been largely ad hoc, because evaluating multiple variations of a\ntype system on large bodies of existing code is a significant undertaking.\n  We present trace typing: a framework for automatically and quantitatively\nevaluating variations of a retrofitted type system on large code bases. The\ntrace typing approach involves gathering traces of program executions,\ninferring types for instances of variables and expressions occurring in a\ntrace, and merging types according to merge strategies that reflect specific\n(combinations of) choices in the source-level type system design space.\n  We evaluated trace typing through several experiments. We compared several\nvariations of type systems retrofitted onto JavaScript, measuring the number of\nprogram locations with type errors in each case on a suite of over fifty\nthousand lines of JavaScript code. We also used trace typing to validate and\nguide the design of a new retrofitted type system that enforces fixed object\nlayout for JavaScript objects. Finally, we leveraged the types computed by\ntrace typing to automatically identify tag tests --- dynamic checks that refine\na type --- and examined the variety of tests identified.\n", "versions": [{"version": "v1", "created": "Wed, 4 May 2016 17:59:58 GMT"}], "update_date": "2016-05-05", "authors_parsed": [["Andreasen", "Esben", ""], ["Gordon", "Colin S.", ""], ["Chandra", "Satish", ""], ["Sridharan", "Manu", ""], ["Tip", "Frank", ""], ["Sen", "Koushik", ""]]}, {"id": "1605.01480", "submitter": "Moez AbdelGawad", "authors": "Moez A. AbdelGawad", "title": "Towards Understanding Generics in Mainstream OOP", "comments": "29 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article reports on steps towards building a simple and accurate\ndomain-theoretic model of generic nominally-typed OOP.\n", "versions": [{"version": "v1", "created": "Thu, 5 May 2016 03:19:11 GMT"}, {"version": "v2", "created": "Fri, 29 Dec 2017 17:40:58 GMT"}], "update_date": "2018-01-01", "authors_parsed": [["AbdelGawad", "Moez A.", ""]]}, {"id": "1605.02033", "submitter": "Ramkumar  Lakshminarayanan", "authors": "Ramkumar Lakshminarayanan and Balaji Dhanasekaran and Ben George Ephre", "title": "A Study on Features and Limitations of On-line C Compilers", "comments": null, "journal-ref": "International Journal of Computer Applications 0975 8887 Volume\n  125 No.9, September 2015", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compilers are used to run programs that are written in a range of designs\nfrom text to executable formats. With the advent of the internet, studies\nrelated to the development of cloud based compilers are being carried out.\nThere is a considerable increase of on-line compilers enabling on-line\ncompilation of user programs without any mandate to. This study is specific to\non-line C compilers to investigate the correctness, issues and limitations.\n", "versions": [{"version": "v1", "created": "Sat, 30 Apr 2016 09:41:07 GMT"}], "update_date": "2016-05-09", "authors_parsed": [["Lakshminarayanan", "Ramkumar", ""], ["Dhanasekaran", "Balaji", ""], ["Ephre", "Ben George", ""]]}, {"id": "1605.02043", "submitter": "Lingda Li", "authors": "Lingda Li, Ari B. Hayes, Stephen A. Hackler, Eddy Z. Zhang, Mario\n  Szegedy, Shuaiwen Leon Song", "title": "A Graph-based Model for GPU Caching Problems", "comments": "Currently under submission", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modeling data sharing in GPU programs is a challenging task because of the\nmassive parallelism and complex data sharing patterns provided by GPU\narchitectures. Better GPU caching efficiency can be achieved through careful\ntask scheduling among different threads. Traditionally, in the field of\nparallel computing, graph partition models are used to model data communication\nand guide task scheduling. However, we discover that the previous methods are\neither inaccurate or expensive when applied to GPU programs. In this paper, we\npropose a novel task partition model that is accurate and gives rise to the\ndevelopment of fast and high quality task/data reorganization algorithms. We\ndemonstrate the effectiveness of the proposed model by rigorous theoretical\nanalysis of the algorithm bounds and extensive experimental analysis. The\nexperimental results show that it achieves significant performance improvement\nacross a representative set of GPU applications.\n", "versions": [{"version": "v1", "created": "Fri, 6 May 2016 19:12:06 GMT"}], "update_date": "2016-10-04", "authors_parsed": [["Li", "Lingda", ""], ["Hayes", "Ari B.", ""], ["Hackler", "Stephen A.", ""], ["Zhang", "Eddy Z.", ""], ["Szegedy", "Mario", ""], ["Song", "Shuaiwen Leon", ""]]}, {"id": "1605.02142", "submitter": "Jonathan Sterling", "authors": "Jonathan Sterling", "title": "Nominal LCF: A Language for Generic Proof", "comments": "Accepted to TFP 2016, the paper has been withdrawn by the author\n  because he has found a serious flaw in the denotational semantics given in\n  section 5", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The syntax and semantics of user-supplied hypothesis names in tactic\nlanguages is a thorny problem, because the binding structure of a proof is a\nfunction of the goal at which a tactic script is executed. We contribute a new\nlanguage to deal with the dynamic and interactive character of names in tactic\nscripts called Nominal LCF, and endow it with a denotational semantics in\ndI-domains. A large fragment of Nominal LCF has already been implemented and\nused to great effect in the new RedPRL proof assistant.\n", "versions": [{"version": "v1", "created": "Sat, 7 May 2016 05:05:40 GMT"}, {"version": "v2", "created": "Sat, 14 May 2016 01:24:06 GMT"}], "update_date": "2016-05-17", "authors_parsed": [["Sterling", "Jonathan", ""]]}, {"id": "1605.02311", "submitter": "J\\\"urgen Koslowski", "authors": "Andrzej S. Murawski (University of Warwick) and Nikos Tzevelekos\n  (Queen Mary University of London)", "title": "Block structure vs scope extrusion: between innocence and omniscience", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 3 (April 27,\n  2017) lmcs:2007", "doi": "10.2168/LMCS-12(3:3)2016", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the semantic meaning of block structure using game semantics. To\nthat end, we introduce the notion of block-innocent strategies and characterise\ncall-by-value computation with block-allocated storage through soundness,\nfinite definability and universality results. This puts us in a good position\nto conduct a comparative study of purely functional computation, computation\nwith block storage as well as that with dynamic memory allocation. For example,\nwe can show that dynamic variable allocation can be replaced with\nblock-allocated variables exactly when the term involved (open or closed) is of\nbase type and that block-allocated storage can be replaced with purely\nfunctional computation when types of order two are involved. To illustrate the\nrestrictive nature of block structure further, we prove a decidability result\nfor a finitary fragment of call-by-value Idealized Algol for which it is known\nthat allowing for dynamic memory allocation leads to undecidability.\n", "versions": [{"version": "v1", "created": "Sun, 8 May 2016 11:50:43 GMT"}, {"version": "v2", "created": "Tue, 16 Aug 2016 19:19:27 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Murawski", "Andrzej S.", "", "University of Warwick"], ["Tzevelekos", "Nikos", "", "Queen Mary University of London"]]}, {"id": "1605.02350", "submitter": "Zachary Kincaid", "authors": "Azadeh Farzan, Zachary Kincaid, Andreas Podelski", "title": "Proving Liveness of Parameterized Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Correctness of multi-threaded programs typically requires that they satisfy\nliveness properties. For example, a program may require that no thread is\nstarved of a shared resource, or that all threads eventually agree on a single\nvalue. This paper presents a method for proving that such liveness properties\nhold. Two particular challenges addressed in this work are that (1) the\ncorrectness argument may rely on global behaviour of the system (e.g., the\ncorrectness argument may require that all threads collectively progress towards\n\"the good thing\" rather than one thread progressing while the others do not\ninterfere), and (2) such programs are often designed to be executed by any\nnumber of threads, and the desired liveness properties must hold regardless of\nthe number of threads that are active in the program.\n", "versions": [{"version": "v1", "created": "Sun, 8 May 2016 19:10:11 GMT"}], "update_date": "2016-05-10", "authors_parsed": [["Farzan", "Azadeh", ""], ["Kincaid", "Zachary", ""], ["Podelski", "Andreas", ""]]}, {"id": "1605.02765", "submitter": "Justin Hsu", "authors": "Gilles Barthe, Thomas Espitau, Luis Mar\\'ia Ferrer Fioriti, Justin Hsu", "title": "Synthesizing Probabilistic Invariants via Doob's Decomposition", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-319-41528-4_3", "report-no": null, "categories": "cs.PL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  When analyzing probabilistic computations, a powerful approach is to first\nfind a martingale---an expression on the program variables whose expectation\nremains invariant---and then apply the optional stopping theorem in order to\ninfer properties at termination time. One of the main challenges, then, is to\nsystematically find martingales.\n  We propose a novel procedure to synthesize martingale expressions from an\narbitrary initial expression. Contrary to state-of-the-art approaches, we do\nnot rely on constraint solving. Instead, we use a symbolic construction based\non Doob's decomposition. This procedure can produce very complex martingales,\nexpressed in terms of conditional expectations.\n  We show how to automatically generate and simplify these martingales, as well\nas how to apply the optional stopping theorem to infer properties at\ntermination time. This last step typically involves some simplification steps,\nand is usually done manually in current approaches. We implement our techniques\nin a prototype tool and demonstrate our process on several classical examples.\nSome of them go beyond the capability of current semi-automatic approaches.\n", "versions": [{"version": "v1", "created": "Mon, 9 May 2016 20:30:20 GMT"}], "update_date": "2018-03-16", "authors_parsed": [["Barthe", "Gilles", ""], ["Espitau", "Thomas", ""], ["Fioriti", "Luis Mar\u00eda Ferrer", ""], ["Hsu", "Justin", ""]]}, {"id": "1605.02778", "submitter": "Mounir Assaf", "authors": "Mounir Assaf, David A. Naumann", "title": "Calculational Design of Information Flow Monitors (extended version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Fine grained information flow monitoring can in principle address a wide\nrange of security and privacy goals, for example in web applications. But it is\nvery difficult to achieve sound monitoring with acceptable runtime cost and\nsufficient precision to avoid impractical restrictions on programs and\npolicies. We present a systematic technique for design of monitors that are\ncorrect by construction. It encompasses policies with downgrading. The\ntechnique is based on abstract interpretation which is a standard basis for\nstatic analysis of programs. This should enable integration of a wide range of\nanalysis techniques, enabling more sophisticated engineering of monitors to\naddress the challenges of precision and scaling to widely used programming\nlanguages.\n", "versions": [{"version": "v1", "created": "Mon, 9 May 2016 20:56:28 GMT"}], "update_date": "2016-05-11", "authors_parsed": [["Assaf", "Mounir", ""], ["Naumann", "David A.", ""]]}, {"id": "1605.02935", "submitter": "Casper Bach Poulsen", "authors": "Casper Bach Poulsen and Peter D. Mosses", "title": "Flag-Based Big-Step Semantics", "comments": "To appear in The Journal of Logical and Algebraic Methods in\n  Programming, Special Issue: 26th Nordic Workshop for Programming Theory, 2014", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Structural operational semantic specifications come in different styles:\nsmall-step and big-step. A problem with the big-step style is that specifying\ndivergence and abrupt termination gives rise to annoying duplication. We\npresent a novel approach to representing divergence and abrupt termination in\nbig-step semantics using status flags. This avoids the duplication problem, and\nuses fewer rules and premises for representing divergence than previous\napproaches in the literature.\n", "versions": [{"version": "v1", "created": "Tue, 10 May 2016 10:47:02 GMT"}], "update_date": "2016-05-11", "authors_parsed": [["Poulsen", "Casper Bach", ""], ["Mosses", "Peter D.", ""]]}, {"id": "1605.02941", "submitter": "Tomas Petricek", "authors": "Tomas Petricek, Gustavo Guerra, Don Syme", "title": "Types from data: Making structured data first-class citizens in F#", "comments": "In proceedings of ACM SIGPLAN conference on Programming Language\n  Design and Implementation, PLDI 2016, Santa Barbara", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most modern applications interact with external services and access data in\nstructured formats such as XML, JSON and CSV. Static type systems do not\nunderstand such formats, often making data access more cumbersome. Should we\ngive up and leave the messy world of external data to dynamic typing and\nruntime checks? Of course, not!\n  We present F# Data, a library that integrates external structured data into\nF#. As most real-world data does not come with an explicit schema, we develop a\nshape inference algorithm that infers a shape from representative sample\ndocuments. We then integrate the inferred shape into the F# type system using\ntype providers. We formalize the process and prove a relative type soundness\ntheorem.\n  Our library significantly reduces the amount of data access code and it\nprovides additional safety guarantees when contrasted with the widely used\nweakly typed techniques.\n", "versions": [{"version": "v1", "created": "Tue, 10 May 2016 11:09:13 GMT"}], "update_date": "2016-05-11", "authors_parsed": [["Petricek", "Tomas", ""], ["Guerra", "Gustavo", ""], ["Syme", "Don", ""]]}, {"id": "1605.03636", "submitter": "Marek Trt\\'ik", "authors": "Pavel \\v{C}adek, Jan Strej\\v{c}ek, Marek Trt\\'ik", "title": "Tighter Loop Bound Analysis (Technical report)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new algorithm for computing upper bounds on the number of\nexecutions of each program instruction during any single program run. The upper\nbounds are expressed as functions of program input values. The algorithm is\nprimarily designed to produce bounds that are relatively tight, i.e. not\nunnecessarily blown up. The upper bounds for instructions allow us to infer\nloop bounds, i.e.~upper bounds on the number of loop iterations. Experimental\nresults show that the algorithm implemented in a prototype tool Looperman often\nproduces tighter bounds than current tools for loop bound analysis.\n", "versions": [{"version": "v1", "created": "Wed, 11 May 2016 23:01:53 GMT"}], "update_date": "2016-05-13", "authors_parsed": [["\u010cadek", "Pavel", ""], ["Strej\u010dek", "Jan", ""], ["Trt\u00edk", "Marek", ""]]}, {"id": "1605.04477", "submitter": "Nils Jansen", "authors": "Nils Jansen, Christian Dehnert, Benjamin Lucien Kaminski, Joost-Pieter\n  Katoen, Lukas Westhofen", "title": "Bounded Model Checking for Probabilistic Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/publicdomain/zero/1.0/", "abstract": "  In this paper we investigate the applicability of standard model checking\napproaches to verifying properties in probabilistic programming. As the\noperational model for a standard probabilistic program is a potentially\ninfinite parametric Markov decision process, no direct adaption of existing\ntechniques is possible. Therefore, we propose an on-the-fly approach where the\noperational model is successively created and verified via a step-wise\nexecution of the program. This approach enables to take key features of many\nprobabilistic programs into account: nondeterminism and conditioning. We\ndiscuss the restrictions and demonstrate the scalability on several benchmarks.\n", "versions": [{"version": "v1", "created": "Sat, 14 May 2016 22:34:59 GMT"}, {"version": "v2", "created": "Tue, 26 Jul 2016 20:13:54 GMT"}], "update_date": "2016-07-28", "authors_parsed": [["Jansen", "Nils", ""], ["Dehnert", "Christian", ""], ["Kaminski", "Benjamin Lucien", ""], ["Katoen", "Joost-Pieter", ""], ["Westhofen", "Lukas", ""]]}, {"id": "1605.05104", "submitter": "Damiano Zanardini", "authors": "Isabella Mastroeni and Damiano Zanardini", "title": "Abstract Program Slicing: an Abstract Interpretation-based approach to\n  Program Slicing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the present paper we formally define the notion of abstract program\nslicing, a general form of program slicing where properties of data are\nconsidered instead of their exact value. This approach is applied to a language\nwith numeric and reference values, and relies on the notion of abstract\ndependencies between program components (statements).\n  The different forms of (backward) abstract slicing are added to an existing\nformal framework where traditional, non-abstract forms of slicing could be\ncompared. The extended framework allows us to appreciate that abstract slicing\nis a generalization of traditional slicing, since traditional slicing (dealing\nwith syntactic dependencies) is generalized by (semantic) non-abstract forms of\nslicing, which are actually equivalent to an abstract form where the identity\nabstraction is performed on data.\n  Sound algorithms for computing abstract dependencies and a systematic\ncharacterization of program slices are provided, which rely on the notion of\nagreement between program states.\n", "versions": [{"version": "v1", "created": "Tue, 17 May 2016 10:48:45 GMT"}], "update_date": "2016-05-20", "authors_parsed": [["Mastroeni", "Isabella", ""], ["Zanardini", "Damiano", ""]]}, {"id": "1605.05274", "submitter": "Radu Grigore", "authors": "Radu Grigore", "title": "Java Generics are Turing Complete", "comments": "POPL2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.\n", "versions": [{"version": "v1", "created": "Tue, 17 May 2016 18:13:37 GMT"}, {"version": "v2", "created": "Mon, 7 Nov 2016 14:13:28 GMT"}], "update_date": "2016-11-08", "authors_parsed": [["Grigore", "Radu", ""]]}, {"id": "1605.05296", "submitter": "Michael Bukatin", "authors": "Michael Bukatin and Steve Matthews and Andrey Radul", "title": "Dataflow matrix machines as programmable, dynamically expandable,\n  self-referential generalized recurrent neural networks", "comments": "9 pages (v2 - update references)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dataflow matrix machines are a powerful generalization of recurrent neural\nnetworks. They work with multiple types of linear streams and multiple types of\nneurons, including higher-order neurons which dynamically update the matrix\ndescribing weights and topology of the network in question while the network is\nrunning. It seems that the power of dataflow matrix machines is sufficient for\nthem to be a convenient general purpose programming platform. This paper\nexplores a number of useful programming idioms and constructions arising in\nthis context.\n", "versions": [{"version": "v1", "created": "Tue, 17 May 2016 19:29:37 GMT"}, {"version": "v2", "created": "Thu, 21 Jun 2018 02:24:27 GMT"}], "update_date": "2018-06-22", "authors_parsed": [["Bukatin", "Michael", ""], ["Matthews", "Steve", ""], ["Radul", "Andrey", ""]]}, {"id": "1605.05419", "submitter": "Cameron Mura", "authors": "Berk Ekmekci, Charles E. McAnany, Cameron Mura", "title": "An Introduction to Programming for Bioscientists: A Python-based Primer", "comments": "65 pages total, including 45 pages text, 3 figures, 4 tables,\n  numerous exercises, and 19 pages of Supporting Information; currently in\n  press at PLOS Computational Biology", "journal-ref": null, "doi": "10.1371/journal.pcbi.1004867", "report-no": null, "categories": "q-bio.OT cs.GL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computing has revolutionized the biological sciences over the past several\ndecades, such that virtually all contemporary research in the biosciences\nutilizes computer programs. The computational advances have come on many\nfronts, spurred by fundamental developments in hardware, software, and\nalgorithms. These advances have influenced, and even engendered, a phenomenal\narray of bioscience fields, including molecular evolution and bioinformatics;\ngenome-, proteome-, transcriptome- and metabolome-wide experimental studies;\nstructural genomics; and atomistic simulations of cellular-scale molecular\nassemblies as large as ribosomes and intact viruses. In short, much of\npost-genomic biology is increasingly becoming a form of computational biology.\nThe ability to design and write computer programs is among the most\nindispensable skills that a modern researcher can cultivate. Python has become\na popular programming language in the biosciences, largely because (i) its\nstraightforward semantics and clean syntax make it a readily accessible first\nlanguage; (ii) it is expressive and well-suited to object-oriented programming,\nas well as other modern paradigms; and (iii) the many available libraries and\nthird-party toolkits extend the functionality of the core language into\nvirtually every biological domain (sequence and structure analyses,\nphylogenomics, workflow management systems, etc.). This primer offers a basic\nintroduction to coding, via Python, and it includes concrete examples and\nexercises to illustrate the language's usage and capabilities; the main text\nculminates with a final project in structural bioinformatics. A suite of\nSupplemental Chapters is also provided. Starting with basic concepts, such as\nthat of a 'variable', the Chapters methodically advance the reader to the point\nof writing a graphical user interface to compute the Hamming distance between\ntwo DNA sequences.\n", "versions": [{"version": "v1", "created": "Wed, 18 May 2016 02:21:53 GMT"}], "update_date": "2018-10-01", "authors_parsed": [["Ekmekci", "Berk", ""], ["McAnany", "Charles E.", ""], ["Mura", "Cameron", ""]]}, {"id": "1605.05826", "submitter": "Matthias Boehm", "authors": "Matthias Boehm, Alexandre V. Evfimievski, Niketan Pansare, Berthold\n  Reinwald", "title": "Declarative Machine Learning - A Classification of Basic Properties and\n  Types", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.DC cs.LG cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Declarative machine learning (ML) aims at the high-level specification of ML\ntasks or algorithms, and automatic generation of optimized execution plans from\nthese specifications. The fundamental goal is to simplify the usage and/or\ndevelopment of ML algorithms, which is especially important in the context of\nlarge-scale computations. However, ML systems at different abstraction levels\nhave emerged over time and accordingly there has been a controversy about the\nmeaning of this general definition of declarative ML. Specification\nalternatives range from ML algorithms expressed in domain-specific languages\n(DSLs) with optimization for performance, to ML task (learning problem)\nspecifications with optimization for performance and accuracy. We argue that\nthese different types of declarative ML complement each other as they address\ndifferent users (data scientists and end users). This paper makes an attempt to\ncreate a taxonomy for declarative ML, including a definition of essential basic\nproperties and types of declarative ML. Along the way, we provide insights into\nimplications of these properties. We also use this taxonomy to classify\nexisting systems. Finally, we draw conclusions on defining appropriate\nbenchmarks and specification languages for declarative ML.\n", "versions": [{"version": "v1", "created": "Thu, 19 May 2016 06:39:28 GMT"}], "update_date": "2016-05-20", "authors_parsed": [["Boehm", "Matthias", ""], ["Evfimievski", "Alexandre V.", ""], ["Pansare", "Niketan", ""], ["Reinwald", "Berthold", ""]]}, {"id": "1605.05858", "submitter": "Moez AbdelGawad", "authors": "Robert Cartwright, Rebecca Parsons, Moez AbdelGawad", "title": "Domain Theory: An Introduction", "comments": "90 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This monograph is an ongoing revision of \"Lectures On A Mathematical Theory\nof Computation\" by Dana Scott. Scott's monograph uses a formulation of domains\ncalled neighborhood systems in which finite elements are selected subsets of a\nmaster set of objects called \"tokens\". Since tokens have little intuitive\nsignificance, Scott has discarded neighborhood systems in favor of an\nequivalent formulation of domains called information systems. Unfortunately, he\nhas not rewritten his monograph to reflect this change.\n  We have rewritten Scott's monograph in terms of finitary bases instead of\ninformation systems. A finitary basis is an information system that is closed\nunder least upper bounds on finite consistent subsets. This convention ensures\nthat every finite answer is represented by a single basis object instead of a\nset of objects.\n", "versions": [{"version": "v1", "created": "Thu, 19 May 2016 09:06:01 GMT"}, {"version": "v2", "created": "Mon, 23 May 2016 12:21:17 GMT"}, {"version": "v3", "created": "Thu, 26 May 2016 14:28:34 GMT"}, {"version": "v4", "created": "Tue, 14 Jun 2016 06:36:36 GMT"}], "update_date": "2016-06-15", "authors_parsed": [["Cartwright", "Robert", ""], ["Parsons", "Rebecca", ""], ["AbdelGawad", "Moez", ""]]}, {"id": "1605.06399", "submitter": "Thomas Falch", "authors": "Thomas L. Falch, Anne C. Elster", "title": "ImageCL: An Image Processing Language for Performance Portability on\n  Heterogeneous Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modern computer systems typically conbine multicore CPUs with accelerators\nlike GPUs for inproved performance and energy efficiency. However, these sys-\ntems suffer from poor performance portability, code tuned for one device must\nbe retuned to achieve high performance on another. Image processing is increas-\ning in importance , with applications ranging from seismology and medicine to\nPhotoshop. Based on our experience with medical image processing, we propose\nImageCL, a high-level domain-specific language and source-to-source compiler,\ntargeting heterogeneous hardware. ImageCL resembles OpenCL, but abstracts away\nper- formance optimization details, allowing the programmer to focus on\nalgorithm development, rather than performance tuning. The latter is left to\nour source-to- source compiler and auto-tuner. From high-level ImageCL kernels,\nour source- to-source compiler can generate multiple OpenCL implementations\nwith different optimizations applied. We rely on auto-tuning rather than\nmachine models or ex- pert programmer knowledge to determine which\noptimizations to apply, making our tuning procedure highly robust. Furthermore,\nwe can generate high perform- ing implementations for different devices from a\nsingle source code, thereby im- proving performance portability. We evaluate\nour approach on three image processing benchmarks, on different GPU and CPU\ndevices, and are able to outperform other state of the art solutions in several\ncases, achieving speedups of up to 4.57x.\n", "versions": [{"version": "v1", "created": "Fri, 20 May 2016 15:19:23 GMT"}], "update_date": "2016-05-23", "authors_parsed": [["Falch", "Thomas L.", ""], ["Elster", "Anne C.", ""]]}, {"id": "1605.06938", "submitter": "Matija Pretnar", "authors": "Ohad Kammar and Matija Pretnar", "title": "No value restriction is needed for algebraic effects and handlers", "comments": null, "journal-ref": "Journal of Functional Programming, 27, 2017", "doi": "10.1017/S0956796816000320.", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a straightforward, sound Hindley-Milner polymorphic type system\nfor algebraic effects and handlers in a call-by-value calculus, which allows\ntype variable generalisation of arbitrary computations, not just values. This\nresult is surprising. On the one hand, the soundness of unrestricted\ncall-by-value Hindley-Milner polymorphism is known to fail in the presence of\ncomputational effects such as reference cells and continuations. On the other\nhand, many programming examples can be recast to use effect handlers instead of\nthese effects. Analysing the expressive power of effect handlers with respect\nto state effects, we claim handlers cannot express reference cells, and show\nthey can simulate dynamically scoped state.\n", "versions": [{"version": "v1", "created": "Mon, 23 May 2016 08:51:36 GMT"}], "update_date": "2017-04-20", "authors_parsed": [["Kammar", "Ohad", ""], ["Pretnar", "Matija", ""]]}, {"id": "1605.08475", "submitter": "Jayson Lynch", "authors": "Nirvan Tyagi, Jayson Lynch, Erik D. Demaine", "title": "Toward an Energy Efficient Language and Compiler for (Partially)\n  Reversible Algorithms", "comments": "17 pages, 0 additional figures, pre-print to be published in The 8th\n  Conference on Reversible Computing (RC2016)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new programming language for expressing reversibility,\nEnergy-Efficient Language (Eel), geared toward algorithm design and\nimplementation. Eel is the first language to take advantage of a partially\nreversible computation model, where programs can be composed of both reversible\nand irreversible operations. In this model, irreversible operations cost energy\nfor every bit of information created or destroyed. To handle programs of\nvarying degrees of reversibility, Eel supports a log stack to automatically\ntrade energy costs for space costs, and introduces many powerful control logic\noperators including protected conditional, general conditional, protected\nloops, and general loops. In this paper, we present the design and compiler for\nthe three language levels of Eel along with an interpreter to simulate and\nannotate incurred energy costs of a program.\n", "versions": [{"version": "v1", "created": "Thu, 26 May 2016 23:25:24 GMT"}], "update_date": "2016-05-30", "authors_parsed": [["Tyagi", "Nirvan", ""], ["Lynch", "Jayson", ""], ["Demaine", "Erik D.", ""]]}, {"id": "1605.09177", "submitter": "Danko Ilik", "authors": "Danko Ilik", "title": "Perspectives for proof unwinding by programming languages techniques", "comments": null, "journal-ref": "IfColog Journal of Logics and their Applications (FLAP), College\n  Publications, 2017, 4 (10), pp.3487-3508", "doi": null, "report-no": null, "categories": "math.LO cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this chapter, we propose some future directions of work, potentially\nbeneficial to Mathematics and its foundations, based on the recent import of\nmethodology from the theory of programming languages into proof theory. This\nscientific essay, written for the audience of proof theorists as well as the\nworking mathematician, is not a survey of the field, but rather a personal view\nof the author who hopes that it may inspire future and fellow researchers.\n", "versions": [{"version": "v1", "created": "Mon, 30 May 2016 11:18:59 GMT"}], "update_date": "2019-05-21", "authors_parsed": [["Ilik", "Danko", ""]]}]