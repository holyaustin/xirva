[{"id": "1411.0352", "submitter": "Maxime Chevalier-Boisvert", "authors": "Maxime Chevalier-Boisvert, Marc Feeley", "title": "Simple and Effective Type Check Removal through Lazy Basic Block\n  Versioning", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dynamically typed programming languages such as JavaScript and Python defer\ntype checking to run time. In order to maximize performance, dynamic language\nVM implementations must attempt to eliminate redundant dynamic type checks.\nHowever, type inference analyses are often costly and involve tradeoffs between\ncompilation time and resulting precision. This has lead to the creation of\nincreasingly complex multi-tiered VM architectures.\n  This paper introduces lazy basic block versioning, a simple JIT compilation\ntechnique which effectively removes redundant type checks from critical code\npaths. This novel approach lazily generates type-specialized versions of basic\nblocks on-the-fly while propagating context-dependent type information. This\ndoes not require the use of costly program analyses, is not restricted by the\nprecision limitations of traditional type analyses and avoids the\nimplementation complexity of speculative optimization techniques.\n  We have implemented intraprocedural lazy basic block versioning in a\nJavaScript JIT compiler. This approach is compared with a classical flow-based\ntype analysis. Lazy basic block versioning performs as well or better on all\nbenchmarks. On average, 71% of type tests are eliminated, yielding speedups of\nup to 50%. We also show that our implementation generates more efficient\nmachine code than TraceMonkey, a tracing JIT compiler for JavaScript, on\nseveral benchmarks. The combination of implementation simplicity, low\nalgorithmic complexity and good run time performance makes basic block\nversioning attractive for baseline JIT compilers.\n", "versions": [{"version": "v1", "created": "Mon, 3 Nov 2014 03:46:18 GMT"}, {"version": "v2", "created": "Fri, 29 May 2015 18:06:07 GMT"}], "update_date": "2015-06-01", "authors_parsed": [["Chevalier-Boisvert", "Maxime", ""], ["Feeley", "Marc", ""]]}, {"id": "1411.3015", "submitter": "Wlodzimierz Drabent", "authors": "Wlodzimierz Drabent", "title": "On completeness of logic programs", "comments": "20 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program correctness (in imperative and functional programming) splits in\nlogic programming into correctness and completeness. Completeness means that a\nprogram produces all the answers required by its specification. Little work has\nbeen devoted to reasoning about completeness. This paper presents a few\nsufficient conditions for completeness of definite programs. We also study\npreserving completeness under some cases of pruning of SLD-trees (e.g. due to\nusing the cut).\n  We treat logic programming as a declarative paradigm, abstracting from any\noperational semantics as far as possible. We argue that the proposed methods\nare simple enough to be applied, possibly at an informal level, in practical\nProlog programming. We point out importance of approximate specifications.\n", "versions": [{"version": "v1", "created": "Tue, 11 Nov 2014 23:15:48 GMT"}], "update_date": "2014-11-13", "authors_parsed": [["Drabent", "Wlodzimierz", ""]]}, {"id": "1411.3793", "submitter": "EPTCS", "authors": "Masaya Suzuki (Department of Computer Science, Tokyo Institute of\n  Technology), Takuo Watanabe (Department of Computer Science, Tokyo Institute\n  of Technology)", "title": "A Language Support for Exhaustive Fault-Injection in Message-Passing\n  System Models", "comments": "In Proceedings MOD* 2014, arXiv:1411.3453", "journal-ref": "EPTCS 168, 2014, pp. 45-58", "doi": "10.4204/EPTCS.168.4", "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents an approach towards specifying and verifying adaptive\ndistributed systems. We here take fault-handling as an example of adaptive\nbehavior and propose a modeling language Sandal for describing fault-prone\nmessage-passing systems. One of the unique mechanisms of the language is a\nlinguistic support for abstracting typical faults such as unexpected\ntermination of processes and random loss of messages. The Sandal compiler\ntranslates a model into a set of NuSMV modules. During the compilation process,\nfaults specified in the model will be woven into the output. One can thus enjoy\nfull-automatic exhaustive fault-injection without writing faulty behaviors\nexplicitly. We demonstrate the advantage of the language by verifying a model\nof the two-phase commit protocol under faulty environment.\n", "versions": [{"version": "v1", "created": "Fri, 14 Nov 2014 04:39:19 GMT"}], "update_date": "2014-11-17", "authors_parsed": [["Suzuki", "Masaya", "", "Department of Computer Science, Tokyo Institute of\n  Technology"], ["Watanabe", "Takuo", "", "Department of Computer Science, Tokyo Institute\n  of Technology"]]}, {"id": "1411.3962", "submitter": "David Darais", "authors": "David Darais, Matthew Might, David Van Horn", "title": "Galois Transformers and Modular Abstract Interpreters", "comments": "OOPSLA '15, October 25-30, 2015, Pittsburgh, PA, USA", "journal-ref": null, "doi": "10.1145/2814270.2814308", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The design and implementation of static analyzers has become increasingly\nsystematic. Yet for a given language or analysis feature, it often requires\ntedious and error prone work to implement an analyzer and prove it sound. In\nshort, static analysis features and their proofs of soundness do not compose\nwell, causing a dearth of reuse in both implementation and metatheory.\n  We solve the problem of systematically constructing static analyzers by\nintroducing Galois transformers: monad transformers that transport Galois\nconnection properties. In concert with a monadic interpreter, we define a\nlibrary of monad transformers that implement building blocks for classic\nanalysis parameters like context, path, and heap (in)sensitivity. Moreover,\nthese can be composed together independent of the language being analyzed.\n  Significantly, a Galois transformer can be proved sound once and for all,\nmaking it a reusable analysis component. As new analysis features and\nabstractions are developed and mixed in, soundness proofs need not be\nreconstructed, as the composition of a monad transformer stack is sound by\nvirtue of its constituents. Galois transformers provide a viable foundation for\nreusable and composable metatheory for program analysis.\n  Finally, these Galois transformers shift the level of abstraction in analysis\ndesign and implementation to a level where non-specialists have the ability to\nsynthesize sound analyzers over a number of parameters.\n", "versions": [{"version": "v1", "created": "Fri, 14 Nov 2014 16:33:11 GMT"}, {"version": "v2", "created": "Fri, 27 Mar 2015 21:05:45 GMT"}, {"version": "v3", "created": "Sun, 23 Aug 2015 17:04:07 GMT"}, {"version": "v4", "created": "Wed, 26 Aug 2015 05:57:29 GMT"}, {"version": "v5", "created": "Mon, 5 Oct 2015 13:04:01 GMT"}], "update_date": "2015-10-06", "authors_parsed": [["Darais", "David", ""], ["Might", "Matthew", ""], ["Van Horn", "David", ""]]}, {"id": "1411.3967", "submitter": "David Van Horn", "authors": "Phuc C. Nguyen, David Van Horn", "title": "Relatively Complete Counterexamples for Higher-Order Programs", "comments": "In Proceedings of the 36th annual ACM SIGPLAN conference on\n  Programming Language Design and Implementation, Portland, Oregon, June 2015", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we study the problem of generating inputs to a higher-order\nprogram causing it to error. We first study the problem in the setting of PCF,\na typed, core functional language and contribute the first relatively complete\nmethod for constructing counterexamples for PCF programs. The method is\nrelatively complete in the sense of Hoare logic; completeness is reduced to the\ncompleteness of a first-order solver over the base types of PCF. In practice,\nthis means an SMT solver can be used for the effective, automated generation of\nhigher-order counterexamples for a large class of programs.\n  We achieve this result by employing a novel form of symbolic execution for\nhigher-order programs. The remarkable aspect of this symbolic execution is that\neven though symbolic higher-order inputs and values are considered, the path\ncondition remains a first-order formula. Our handling of symbolic function\napplication enables the reconstruction of higher-order counterexamples from\nthis first-order formula.\n  After establishing our main theoretical results, we sketch how to apply the\napproach to untyped, higher-order, stateful languages with first-class\ncontracts and show how counterexample generation can be used to detect contract\nviolations in this setting. To validate our approach, we implement a tool\ngenerating counterexamples for erroneous modules written in Racket.\n", "versions": [{"version": "v1", "created": "Fri, 14 Nov 2014 16:44:31 GMT"}, {"version": "v2", "created": "Tue, 21 Apr 2015 17:18:17 GMT"}], "update_date": "2015-04-22", "authors_parsed": [["Nguyen", "Phuc C.", ""], ["Van Horn", "David", ""]]}, {"id": "1411.3970", "submitter": "Andrew Reynolds", "authors": "Andrew Reynolds", "title": "Approaches for Synthesis Conjectures in an SMT Solver", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This report describes several approaches for handling synthesis conjectures\nwithin an Satisfiability Modulo Theories (SMT) solver. We describe approaches\nthat primarily focus on determining the unsatisfiability of the negated form of\nsynthesis conjectures using new techniques for quantifier instantiation.\n", "versions": [{"version": "v1", "created": "Fri, 14 Nov 2014 16:46:12 GMT"}, {"version": "v2", "created": "Fri, 9 Oct 2015 13:03:04 GMT"}], "update_date": "2015-10-12", "authors_parsed": [["Reynolds", "Andrew", ""]]}, {"id": "1411.5110", "submitter": "Keehang Kwon", "authors": "Keehang Kwon", "title": "Mutually Exclusive Procedures in Imperative Languages", "comments": "3 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  To represent mutually exclusive procedures, we propose a choice-conjunctive\ndeclaration statement of the form $uchoo(S,R)$ where $S, R$ are the procedure\ndeclaration statements within a module. This statement has the following\nsemantics: request the machine to choose a successful one between $S$ and $R$.\nThis statement is useful for representing objects with mutually exclusive\nprocedures. We illustrate our idea via C^uchoo, an extension of the core C with\na new statement.\n", "versions": [{"version": "v1", "created": "Wed, 19 Nov 2014 04:34:35 GMT"}], "update_date": "2014-11-20", "authors_parsed": [["Kwon", "Keehang", ""]]}, {"id": "1411.5166", "submitter": "Moez AbdelGawad", "authors": "Moez A. AbdelGawad", "title": "Subtyping in Java is a Fractal", "comments": "18 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL math.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While developing their software, professional object-oriented (OO) software\ndevelopers keep in their minds an image of the subtyping relation between types\nin their software. The goal of this paper is to present an observation about\nthe graph of the subtyping relation in Java, namely the observation that, after\nthe addition of generics---and of wildcards, in particular---to Java, the graph\nof the subtyping relation is no longer a simple directed-acyclic graph (DAG),\nas in pre-generics Java, but is rather a fractal. Further, this observation\nequally applies to other mainstream nominally-typed OO languages (such as C#,\nC++ and Scala) where generics and wildcards (or some other form of 'variance\nannotations') are standard features. Accordingly, the shape of the subtyping\nrelation in these OO languages is more complex than a tree or a simple DAG, and\nindeed is also a fractal. Given the popularity of fractals, the fractal\nobservation may help OO software developers keep a useful and intuitive mental\nimage of their software's subtyping relation, even if it is a little more\nfrightening, and more amazing one than before. With proper support from IDEs,\nthe fractal observation can help OO developers in resolving type errors they\nmay find in their code in lesser time, and with more confidence.\n", "versions": [{"version": "v1", "created": "Wed, 19 Nov 2014 10:20:54 GMT"}, {"version": "v2", "created": "Mon, 8 Dec 2014 13:17:31 GMT"}, {"version": "v3", "created": "Tue, 23 Aug 2016 06:32:20 GMT"}, {"version": "v4", "created": "Mon, 29 Aug 2016 14:39:00 GMT"}, {"version": "v5", "created": "Fri, 29 Dec 2017 17:37:12 GMT"}], "update_date": "2018-01-01", "authors_parsed": [["AbdelGawad", "Moez A.", ""]]}, {"id": "1411.5289", "submitter": "Uday Khedker", "authors": "Uday P. Khedker and Vini Kanvar", "title": "Generalizing the Liveness Based Points-to Analysis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The original liveness based flow and context sensitive points-to analysis\n(LFCPA) is restricted to scalar pointer variables and scalar pointees on stack\nand static memory. In this paper, we extend it to support heap memory and\npointer expressions involving structures, unions, arrays, and pointer\narithmetic. The key idea behind these extensions involves constructing bounded\nnames for locations in terms of compile time constants (names and fixed\noffsets), and introducing sound approximations when it is not possible to do\nso. We achieve this by defining a grammar for pointer expressions, suitable\nmemory models and location naming conventions, and some key evaluations of\npointer expressions that compute the named locations. These extensions preserve\nthe spirit of the original LFCPA which is evidenced by the fact that although\nthe lattices and flow functions change, the overall data flow equations remain\nunchanged.\n", "versions": [{"version": "v1", "created": "Wed, 19 Nov 2014 16:58:18 GMT"}, {"version": "v2", "created": "Fri, 21 Nov 2014 10:07:47 GMT"}], "update_date": "2014-11-24", "authors_parsed": [["Khedker", "Uday P.", ""], ["Kanvar", "Vini", ""]]}, {"id": "1411.5573", "submitter": "Jose F. Morales Ph.D.", "authors": "Jose F. Morales, Manuel Carro, Manuel Hermenegildo", "title": "Description and Optimization of Abstract Machines in a Dialect of Prolog", "comments": "56 pages, 46 figures, 5 tables, To appear in Theory and Practice of\n  Logic Programming (TPLP)", "journal-ref": "Theory and Practice of Logic Programming 16 (2016) 1-58", "doi": "10.1017/S1471068414000672", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In order to achieve competitive performance, abstract machines for Prolog and\nrelated languages end up being large and intricate, and incorporate\nsophisticated optimizations, both at the design and at the implementation\nlevels. At the same time, efficiency considerations make it necessary to use\nlow-level languages in their implementation. This makes them laborious to code,\noptimize, and, especially, maintain and extend. Writing the abstract machine\n(and ancillary code) in a higher-level language can help tame this inherent\ncomplexity. We show how the semantics of most basic components of an efficient\nvirtual machine for Prolog can be described using (a variant of) Prolog. These\ndescriptions are then compiled to C and assembled to build a complete bytecode\nemulator. Thanks to the high level of the language used and its closeness to\nProlog, the abstract machine description can be manipulated using standard\nProlog compilation and optimization techniques with relative ease. We also show\nhow, by applying program transformations selectively, we obtain abstract\nmachine implementations whose performance can match and even exceed that of\nstate-of-the-art, highly-tuned, hand-crafted emulators.\n", "versions": [{"version": "v1", "created": "Thu, 20 Nov 2014 15:22:52 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Morales", "Jose F.", ""], ["Carro", "Manuel", ""], ["Hermenegildo", "Manuel", ""]]}, {"id": "1411.6361", "submitter": "Baptiste Wicht", "authors": "Baptiste Wicht, Roberto A. Vitillo, Dehao Chen, David Levinthal", "title": "Hardware Counted Profile-Guided Optimization", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Profile-Guided Optimization (PGO) is an excellent means to improve the\nperformance of a compiled program. Indeed, the execution path data it provides\nhelps the compiler to generate better code and better cacheline packing.\n  At the time of this writing, compilers only support instrumentation-based\nPGO. This proved effective for optimizing programs. However, few projects use\nit, due to its complicated dual-compilation model and its high overhead. Our\nsolution of sampling Hardware Performance Counters overcome these drawbacks. In\nthis paper, we propose a PGO solution for GCC by sampling Last Branch Record\n(LBR) events and using debug symbols to recreate source locations of binary\ninstructions.\n  By using LBR-Sampling, the generated profiles are very accurate. This\nsolution achieved an average of 83% of the gains obtained with\ninstrumentation-based PGO and 93% on C++ benchmarks only. The profiling\noverhead is only 1.06% on average whereas instrumentation incurs a 16% overhead\non average.\n", "versions": [{"version": "v1", "created": "Mon, 24 Nov 2014 07:01:31 GMT"}], "update_date": "2014-11-25", "authors_parsed": [["Wicht", "Baptiste", ""], ["Vitillo", "Roberto A.", ""], ["Chen", "Dehao", ""], ["Levinthal", "David", ""]]}, {"id": "1411.7839", "submitter": "Francesco Ranzato", "authors": "Stefano Dissegna and Francesco Logozzo and Francesco Ranzato", "title": "An Abstract Interpretation-based Model of Tracing Just-In-Time\n  Compilation", "comments": "To appear in ACM Transactions on Programming Languages and Systems", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Tracing just-in-time compilation is a popular compilation technique for the\nefficient implementation of dynamic languages, which is commonly used for\nJavaScript, Python and PHP. We provide a formal model of tracing JIT\ncompilation of programs using abstract interpretation. Hot path detection\ncorresponds to an abstraction of the trace semantics of the program. The\noptimization phase corresponds to a transform of the original program that\npreserves its trace semantics up to an observation modeled by some abstraction.\nWe provide a generic framework to express dynamic optimizations and prove them\ncorrect. We instantiate it to prove the correctness of dynamic type\nspecialization and constant variable folding. We show that our framework is\nmore general than the model of tracing compilation introduced by Guo and\nPalsberg [2011] based on operational bisimulations.\n", "versions": [{"version": "v1", "created": "Fri, 28 Nov 2014 12:32:39 GMT"}, {"version": "v2", "created": "Wed, 28 Oct 2015 10:38:02 GMT"}], "update_date": "2015-10-29", "authors_parsed": [["Dissegna", "Stefano", ""], ["Logozzo", "Francesco", ""], ["Ranzato", "Francesco", ""]]}]