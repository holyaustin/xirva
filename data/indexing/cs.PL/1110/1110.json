[{"id": "1110.0021", "submitter": "Dirk Beyer", "authors": "Sven Apel and Hendrik Speidel and Philipp Wendler and Alexander von\n  Rhein and Dirk Beyer", "title": "Feature-Aware Verification", "comments": "12 pages, 9 figures, 1 table", "journal-ref": null, "doi": null, "report-no": "Technical Report, Number MIP-1105, University of Passau, Germany", "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A software product line is a set of software products that are distinguished\nin terms of features (i.e., end-user--visible units of behavior). Feature\ninteractions ---situations in which the combination of features leads to\nemergent and possibly critical behavior--- are a major source of failures in\nsoftware product lines. We explore how feature-aware verification can improve\nthe automatic detection of feature interactions in software product lines.\nFeature-aware verification uses product-line verification techniques and\nsupports the specification of feature properties along with the features in\nseparate and composable units. It integrates the technique of variability\nencoding to verify a product line without generating and checking a possibly\nexponential number of feature combinations. We developed the tool suite\nSPLverifier for feature-aware verification, which is based on standard\nmodel-checking technology. We applied it to an e-mail system that incorporates\ndomain knowledge of AT&T. We found that feature interactions can be detected\nautomatically based on specifications that have only feature-local knowledge,\nand that variability encoding significantly improves the verification\nperformance when proving the absence of interactions.\n", "versions": [{"version": "v1", "created": "Fri, 30 Sep 2011 20:46:35 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Apel", "Sven", ""], ["Speidel", "Hendrik", ""], ["Wendler", "Philipp", ""], ["von Rhein", "Alexander", ""], ["Beyer", "Dirk", ""]]}, {"id": "1110.0404", "submitter": "Daniel S. Katz", "authors": "Daniel S. Katz and Matei Ripeanu and Michael Wilde", "title": "Many-Task Computing Tools for Multiscale Modeling", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  This paper discusses the use of many-task computing tools for multiscale\nmodeling. It defines multiscale modeling and places different examples of it on\na coupling spectrum, discusses the Swift parallel scripting language, describes\nthree multiscale modeling applications that could use Swift, and then talks\nabout how the Swift model is being extended to cover more of the multiscale\nmodeling coupling spectrum.\n", "versions": [{"version": "v1", "created": "Mon, 3 Oct 2011 16:26:50 GMT"}], "update_date": "2011-10-04", "authors_parsed": [["Katz", "Daniel S.", ""], ["Ripeanu", "Matei", ""], ["Wilde", "Michael", ""]]}, {"id": "1110.0624", "submitter": "Agostino Dovier", "authors": "Agostino Dovier and Andrea Formisano and Enrico Pontelli", "title": "Autonomous Agents Coordination: Action Languages meet CLP(FD) and Linda", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper presents a knowledge representation formalism, in the form of a\nhigh-level Action Description Language for multi-agent systems, where\nautonomous agents reason and act in a shared environment. Agents are\nautonomously pursuing individual goals, but are capable of interacting through\na shared knowledge repository. In their interactions through shared portions of\nthe world, the agents deal with problems of synchronization and concurrency;\nthe action language allows the description of strategies to ensure a consistent\nglobal execution of the agents' autonomously derived plans. A distributed\nplanning problem is formalized by providing the declarative specifications of\nthe portion of the problem pertaining a single agent. Each of these\nspecifications is executable by a stand-alone CLP-based planner. The\ncoordination among agents exploits a Linda infrastructure. The proposal is\nvalidated in a prototype implementation developed in SICStus Prolog.\n  To appear in Theory and Practice of Logic Programming (TPLP).\n", "versions": [{"version": "v1", "created": "Tue, 4 Oct 2011 09:55:41 GMT"}], "update_date": "2011-10-05", "authors_parsed": [["Dovier", "Agostino", ""], ["Formisano", "Andrea", ""], ["Pontelli", "Enrico", ""]]}, {"id": "1110.0631", "submitter": "Fabrizio Riguzzi PhD", "authors": "Fabrizio Riguzzi and Terrance Swift", "title": "Well-Definedness and Efficient Inference for Probabilistic Logic\n  Programming under the Distribution Semantics", "comments": "31 pages, 8 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The distribution semantics is one of the most prominent approaches for the\ncombination of logic programming and probability theory. Many languages follow\nthis semantics, such as Independent Choice Logic, PRISM, pD, Logic Programs\nwith Annotated Disjunctions (LPADs) and ProbLog. When a program contains\nfunctions symbols, the distribution semantics is well-defined only if the set\nof explanations for a query is finite and so is each explanation.\nWell-definedness is usually either explicitly imposed or is achieved by\nseverely limiting the class of allowed programs. In this paper we identify a\nlarger class of programs for which the semantics is well-defined together with\nan efficient procedure for computing the probability of queries. Since LPADs\noffer the most general syntax, we present our results for them, but our results\nare applicable to all languages under the distribution semantics. We present\nthe algorithm \"Probabilistic Inference with Tabling and Answer subsumption\"\n(PITA) that computes the probability of queries by transforming a probabilistic\nprogram into a normal program and then applying SLG resolution with answer\nsubsumption. PITA has been implemented in XSB and tested on six domains: two\nwith function symbols and four without. The execution times are compared with\nthose of ProbLog, cplint and CVE, PITA was almost always able to solve larger\nproblems in a shorter time, on domains with and without function symbols.\n", "versions": [{"version": "v1", "created": "Tue, 4 Oct 2011 10:29:32 GMT"}], "update_date": "2011-10-05", "authors_parsed": [["Riguzzi", "Fabrizio", ""], ["Swift", "Terrance", ""]]}, {"id": "1110.1015", "submitter": "Marco Sirianni Dr.", "authors": "Simona Perri, Francesco Ricca, Marco Sirianni", "title": "Parallel Instantiation of ASP Programs: Techniques and Experiments", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Answer Set Programming (ASP) is a powerful logic-based programming language,\nwhich is enjoying increasing interest within the scientific community and (very\nrecently) in industry. The evaluation of ASP programs is traditionally carried\nout in two steps. At the first step an input program P undergoes the so-called\ninstantiation (or grounding) process, which produces a program P' semantically\nequivalent to P, but not containing any variable; in turn, P' is evaluated by\nusing a backtracking search algorithm in the second step. It is well-known that\ninstantiation is important for the efficiency of the whole evaluation, might\nbecome a bottleneck in common situations, is crucial in several realworld\napplications, and is particularly relevant when huge input data has to be dealt\nwith. At the time of this writing, the available instantiator modules are not\nable to exploit satisfactorily the latest hardware, featuring\nmulti-core/multi-processor SMP (Symmetric MultiProcessing) technologies. This\npaper presents some parallel instantiation techniques, including load-balancing\nand granularity control heuristics, which allow for the effective exploitation\nof the processing power offered by modern SMP machines. This is confirmed by an\nextensive experimental analysis herein reported.\n  To appear in Theory and Practice of Logic Programming (TPLP).\n  KEYWORDS: Answer Set Programming, Instantiation, Parallelism, Heuristics\n", "versions": [{"version": "v1", "created": "Wed, 5 Oct 2011 15:06:42 GMT"}, {"version": "v2", "created": "Thu, 13 Oct 2011 09:51:24 GMT"}], "update_date": "2011-10-14", "authors_parsed": [["Perri", "Simona", ""], ["Ricca", "Francesco", ""], ["Sirianni", "Marco", ""]]}, {"id": "1110.1029", "submitter": "Benedikt Meurer", "authors": "Marcell Fischbach, Benedikt Meurer", "title": "Towards a native toplevel for the OCaml language", "comments": "10 pages, 5 figures, technical report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents the current state of our work on an interactive toplevel\nfor the OCaml language based on the optimizing native code compiler and\nruntime. Our native toplevel is up to 100 times faster than the default OCaml\ntoplevel, which is based on the byte code compiler and interpreter. It uses\nJust-In-Time techniques to compile toplevel phrases to native code at runtime,\nand currently works with various Unix-like systems running on x86 or x86-64\nprocessors.\n", "versions": [{"version": "v1", "created": "Wed, 5 Oct 2011 16:05:41 GMT"}, {"version": "v2", "created": "Thu, 27 Oct 2011 16:09:44 GMT"}], "update_date": "2011-10-28", "authors_parsed": [["Fischbach", "Marcell", ""], ["Meurer", "Benedikt", ""]]}, {"id": "1110.1866", "submitter": "Jan Bergstra", "authors": "Jan A. Bergstra", "title": "Putting Instruction Sequences into Effect", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An attempt is made to define the concept of execution of an instruction\nsequence. It is found to be a special case of directly putting into effect of\nan instruction sequence. Directly putting into effect of an instruction\nsequences comprises interpretation as well as execution. Directly putting into\neffect is a special case of putting into effect with other special cases\nclassified as indirectly putting into effect.\n", "versions": [{"version": "v1", "created": "Sun, 9 Oct 2011 18:46:04 GMT"}], "update_date": "2011-10-11", "authors_parsed": [["Bergstra", "Jan A.", ""]]}, {"id": "1110.2350", "submitter": "Yann Regis-Gianas", "authors": "Roberto M. Amadio (PPS), Yann Regis-Gianas (PPS, INRIA Paris -\n  Rocquencourt)", "title": "Certifying and reasoning about cost annotations of functional programs", "comments": "Higher-Order and Symbolic Computation (2013)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a so-called labelling method to insert cost annotations in a\nhigher-order functional program, to certify their correctness with respect to a\nstandard compilation chain to assembly code including safe memory management,\nand to reason on them in a higher-order Hoare logic.\n", "versions": [{"version": "v1", "created": "Tue, 11 Oct 2011 12:35:00 GMT"}, {"version": "v2", "created": "Wed, 16 Jan 2013 13:40:51 GMT"}], "update_date": "2013-01-17", "authors_parsed": [["Amadio", "Roberto M.", "", "PPS"], ["Regis-Gianas", "Yann", "", "PPS, INRIA Paris -\n  Rocquencourt"]]}, {"id": "1110.3470", "submitter": "David Lievens", "authors": "David Lievens and Bill Harrison", "title": "Symmetric Encapsulated Multi-Methods", "comments": "This paper is a variant of David Lievens, William Harrison: Symmetric\n  encapsulated multi-methods to abstract over application structure. SAC 2009:\n  1873-1880 that includes full details of the proof of the type soundness\n  result stated in the original", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In object systems, classes take the role of modules, and interfaces consist\nof methods. Because methods are encapsulated in objects, interfaces in object\nsystems do not allow abstracting over \\emph{where} methods are implemented.\nThis implies that any change to the implementation structure may cause a\nrippling effect. Sometimes this unduly restricts the scope of software\nevolution, in particular for methods with multiple parameters where there is no\nclear owner. We propose a simple scheme where symmetric methods may be defined\nin the classes of any of their parameters. This allows client code to be\noblivious of what class contains a method implementation, and therefore immune\nagainst it changing. When combined with multiple dynamic dispatch, this scheme\nallows for modular extensibility where a method defined in one class is\noverridden by a method defined in a class that is not its subtype. In this\npaper, we illustrate the scheme by extending a core calculus of class-based\nlanguages with these symmetric encapsulated multi-methods, and prove the result\nsound.\n", "versions": [{"version": "v1", "created": "Sun, 16 Oct 2011 10:52:53 GMT"}], "update_date": "2011-10-18", "authors_parsed": [["Lievens", "David", ""], ["Harrison", "Bill", ""]]}, {"id": "1110.3853", "submitter": "EPTCS", "authors": "Kohei Honda, Alan Mycroft", "title": "Proceedings Third Workshop on Programming Language Approaches to\n  Concurrency and communication-cEntric Software", "comments": "EPTCS 69, 2011", "journal-ref": null, "doi": "10.4204/EPTCS.69", "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is the proceedings of PLACES'10, the 3rd Workshop on Programming\nLanguage Approaches to Concurrency and Communication-cEntric Software, held in\nPathos, Cyprus, on 21st Mach, 2010, co-located with the ETAPS federated\nconferences. PLACES aims to offer a forum where researchers from different\nfields exchange new ideas on one of the central challenges in programming in\nnear future, the development of programming methodologies and infrastructures\nwhere concurrency and distribution are a norm rather than a marginal concern.\nThe Program Committee, after a careful and thorough reviewing process, selected\nfor presentation in the programme 10 papers out of 14 submissions. Each\nsubmission was evaluated by at least two referees, and the accepted papers were\nselected during two weeks' electronic discussions. This post-proceedings\ncontain the papers which are based on these submissions, incorporating the\nresult of these and further reviews, resulting in strengthened technical\nresults and presentations.\n", "versions": [{"version": "v1", "created": "Tue, 18 Oct 2011 00:04:09 GMT"}], "update_date": "2011-10-19", "authors_parsed": [["Honda", "Kohei", ""], ["Mycroft", "Alan", ""]]}, {"id": "1110.4156", "submitter": "EPTCS", "authors": "Nuno Alves, Raymond Hu (Imperial College London), Nobuko Yoshida\n  (Imperial College London), Pierre-Malo Deni\\'elou (Imperial College London)", "title": "Secure Execution of Distributed Session Programs", "comments": "In Proceedings PLACES 2010, arXiv:1110.3853", "journal-ref": "EPTCS 69, 2011, pp. 1-11", "doi": "10.4204/EPTCS.69.1", "report-no": null, "categories": "cs.DC cs.CR cs.NI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The development of the SJ Framework for session-based distributed programming\nis part of recent and ongoing research into integrating session types and\npractical, real-world programming languages. SJ programs featuring session\ntypes (protocols) are statically checked by the SJ compiler to verify the key\nproperty of communication safety, meaning that parties engaged in a session\nonly communicate messages, including higher-order communications via session\ndelegation, that are compatible with the message types expected by the\nrecipient.\n  This paper presents current work on security aspects of the SJ Framework.\nFirstly, we discuss our implementation experience from improving the SJ Runtime\nplatform with security measures to protect and augment communication safety at\nruntime. We implement a transport component for secure session execution that\nuses a modified TLS connection with authentication based on the Secure Remote\nPassword (SRP) protocol. The key technical point is the delicate treatment of\nsecure session delegation to counter a previous vulnerability. We find that the\nmodular design of the SJ Runtime, based on the notion of an Abstract Transport\nfor session communication, supports rapid extension to utilise additional\ntransports whilst separating this concern from the application-level session\nprogramming task. In the second part of this abstract, we formally prove the\ntarget security properties by modelling the extended SJ delegation protocols in\nthe pi-calculus.\n", "versions": [{"version": "v1", "created": "Wed, 19 Oct 2011 02:11:41 GMT"}], "update_date": "2011-10-20", "authors_parsed": [["Alves", "Nuno", "", "Imperial College London"], ["Hu", "Raymond", "", "Imperial College London"], ["Yoshida", "Nobuko", "", "Imperial College London"], ["Deni\u00e9lou", "Pierre-Malo", "", "Imperial College London"]]}, {"id": "1110.4157", "submitter": "EPTCS", "authors": "Joana Campos (University of Lisbon), Vasco T. Vasconcelos (University\n  of Lisbon)", "title": "Channels as Objects in Concurrent Object-Oriented Programming", "comments": "In Proceedings PLACES 2010, arXiv:1110.3853", "journal-ref": "EPTCS 69, 2011, pp. 12-28", "doi": "10.4204/EPTCS.69.2", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There is often a sort of a protocol associated to each class, stating when\nand how certain methods should be called. Given that this protocol is, if at\nall, described in the documentation accompanying the class, current mainstream\nobject-oriented languages cannot provide for the verification of client code\nadherence against the sought class behaviour. We have defined a class-based\nconcurrent object-oriented language that formalises such protocols in the form\nof usage types. Usage types are attached to class definitions, allowing for the\nspecification of (1) the available methods, (2) the tests clients must perform\non the result of methods, and (3) the object status - linear or shared - all of\nwhich depend on the object's state. Our work extends the recent approach on\nmodular session types by eliminating channel operations, and defining the\nmethod call as the single communication primitive in both sequential and\nconcurrent settings. In contrast to previous works, we define a single category\nfor objects, instead of distinct categories for linear and for shared objects,\nand let linear objects evolve into shared ones. We introduce a standard sync\nqualifier to prevent thread interference in certain operations on shared\nobjects. We formalise the language syntax, the operational semantics, and a\ntype system that enforces by static typing that methods are called only when\navailable, and by a single client if so specified in the usage type. We\nillustrate the language via a complete example.\n", "versions": [{"version": "v1", "created": "Wed, 19 Oct 2011 02:18:07 GMT"}], "update_date": "2011-10-20", "authors_parsed": [["Campos", "Joana", "", "University of Lisbon"], ["Vasconcelos", "Vasco T.", "", "University\n  of Lisbon"]]}, {"id": "1110.4159", "submitter": "EPTCS", "authors": "Marco Carbone (IT University of Copenhagen), Davide Grohmann (IT\n  University of Copenhagen), Thomas T. Hildebrandt (IT University of\n  Copenhagen), Hugo A. L\\'opez (IT University of Copenhagen)", "title": "A Logic for Choreographies", "comments": "In Proceedings PLACES 2010, arXiv:1110.3853", "journal-ref": "EPTCS 69, 2011, pp. 29-43", "doi": "10.4204/EPTCS.69.3", "report-no": null, "categories": "cs.PL cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We explore logical reasoning for the global calculus, a coordination model\nbased on the notion of choreography, with the aim to provide a methodology for\nspecification and verification of structured communications. Starting with an\nextension of Hennessy-Milner logic, we present the global logic (GL), a modal\nlogic describing possible interactions among participants in a choreography. We\nillustrate its use by giving examples of properties on service specifications.\nFinally, we show that, despite GL is undecidable, there is a significant\ndecidable fragment which we provide with a sound and complete proof system for\nchecking validity of formulae.\n", "versions": [{"version": "v1", "created": "Wed, 19 Oct 2011 02:25:48 GMT"}], "update_date": "2011-10-20", "authors_parsed": [["Carbone", "Marco", "", "IT University of Copenhagen"], ["Grohmann", "Davide", "", "IT\n  University of Copenhagen"], ["Hildebrandt", "Thomas T.", "", "IT University of\n  Copenhagen"], ["L\u00f3pez", "Hugo A.", "", "IT University of Copenhagen"]]}, {"id": "1110.4160", "submitter": "EPTCS", "authors": "Prodromos Gerakios (National Technical University of Athens), Nikolaos\n  Papaspyrou (National Technical University of Athens), Konstantinos Sagonas\n  (National Technical University of Athens)", "title": "A Type System for Unstructured Locking that Guarantees Deadlock Freedom\n  without Imposing a Lock Ordering", "comments": "In Proceedings PLACES 2010, arXiv:1110.3853", "journal-ref": "EPTCS 69, 2011, pp. 44-58", "doi": "10.4204/EPTCS.69.4", "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deadlocks occur in concurrent programs as a consequence of cyclic resource\nacquisition between threads. In this paper we present a novel type system that\nguarantees deadlock freedom for a language with references, unstructured\nlocking primitives, and locks which are implicitly associated with references.\nThe proposed type system does not impose a strict lock acquisition order and\nthus increases programming language expressiveness.\n", "versions": [{"version": "v1", "created": "Wed, 19 Oct 2011 02:29:14 GMT"}], "update_date": "2011-10-20", "authors_parsed": [["Gerakios", "Prodromos", "", "National Technical University of Athens"], ["Papaspyrou", "Nikolaos", "", "National Technical University of Athens"], ["Sagonas", "Konstantinos", "", "National Technical University of Athens"]]}, {"id": "1110.4161", "submitter": "EPTCS", "authors": "Thomas T. Hildebrandt (IT University of Copenhagen), Raghava Rao\n  Mukkamala (IT University of Copenhagen)", "title": "Declarative Event-Based Workflow as Distributed Dynamic Condition\n  Response Graphs", "comments": "In Proceedings PLACES 2010, arXiv:1110.3853", "journal-ref": "EPTCS 69, 2011, pp. 59-73", "doi": "10.4204/EPTCS.69.5", "report-no": null, "categories": "cs.LO cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present Dynamic Condition Response Graphs (DCR Graphs) as a declarative,\nevent-based process model inspired by the workflow language employed by our\nindustrial partner and conservatively generalizing prime event structures. A\ndynamic condition response graph is a directed graph with nodes representing\nthe events that can happen and arrows representing four relations between\nevents: condition, response, include, and exclude. Distributed DCR Graphs is\nthen obtained by assigning roles to events and principals. We give a graphical\nnotation inspired by related work by van der Aalst et al. We exemplify the use\nof distributed DCR Graphs on a simple workflow taken from a field study at a\nDanish hospital, pointing out their flexibility compared to imperative workflow\nmodels. Finally we provide a mapping from DCR Graphs to Buchi-automata.\n", "versions": [{"version": "v1", "created": "Wed, 19 Oct 2011 02:31:40 GMT"}], "update_date": "2011-10-20", "authors_parsed": [["Hildebrandt", "Thomas T.", "", "IT University of Copenhagen"], ["Mukkamala", "Raghava Rao", "", "IT University of Copenhagen"]]}, {"id": "1110.4163", "submitter": "EPTCS", "authors": "Keigo Imai (IT Planning Inc., Japan), Shoji Yuen (Graduate School of\n  Information Science, Nagoya University, Japan), Kiyoshi Agusa (Graduate\n  School of Information Science, Nagoya University, Japan)", "title": "Session Type Inference in Haskell", "comments": "In Proceedings PLACES 2010, arXiv:1110.3853", "journal-ref": "EPTCS 69, 2011, pp. 74-91", "doi": "10.4204/EPTCS.69.6", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an inference system for a version of the Pi-calculus in Haskell\nfor the session type proposed by Honda et al. The session type is very useful\nin checking if the communications are well-behaved. The full session type\nimplementation in Haskell was first presented by Pucella and Tov, which is\n'semi-automatic' in that the manual operations for the type representation was\nnecessary. We give an automatic type inference for the session type by using a\nmore abstract representation for the session type based on the 'de Bruijn\nlevels'. We show an example of the session type inference for a simple SMTP\nclient.\n", "versions": [{"version": "v1", "created": "Wed, 19 Oct 2011 02:38:21 GMT"}], "update_date": "2011-10-20", "authors_parsed": [["Imai", "Keigo", "", "IT Planning Inc., Japan"], ["Yuen", "Shoji", "", "Graduate School of\n  Information Science, Nagoya University, Japan"], ["Agusa", "Kiyoshi", "", "Graduate\n  School of Information Science, Nagoya University, Japan"]]}, {"id": "1110.4164", "submitter": "EPTCS", "authors": "Julien Lange (Department of Computer Science, University of\n  Leicester), Emilio Tuosto (Department of Computer Science, University of\n  Leicester)", "title": "A Modular Toolkit for Distributed Interactions", "comments": "In Proceedings PLACES 2010, arXiv:1110.3853", "journal-ref": "EPTCS 69, 2011, pp. 92-110", "doi": "10.4204/EPTCS.69.7", "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We discuss the design, architecture, and implementation of a toolkit which\nsupports some theories for distributed interactions. The main design principles\nof our architecture are flexibility and modularity. Our main goal is to provide\nan easily extensible workbench to encompass current algorithms and incorporate\nfuture developments of the theories. With the help of some examples, we\nillustrate the main features of our toolkit.\n", "versions": [{"version": "v1", "created": "Wed, 19 Oct 2011 02:38:29 GMT"}], "update_date": "2011-10-20", "authors_parsed": [["Lange", "Julien", "", "Department of Computer Science, University of\n  Leicester"], ["Tuosto", "Emilio", "", "Department of Computer Science, University of\n  Leicester"]]}, {"id": "1110.4165", "submitter": "EPTCS", "authors": "Francisco Martins (LaSIGE and University of Lisbon, Portugal), Vasco\n  T. Vasconcelos (LaSIGE and University of Lisbon, Portugal), Tiago Cogumbreiro\n  (LaSIGE and University of Lisbon, Portugal)", "title": "Types for X10 Clocks", "comments": "In Proceedings PLACES 2010, arXiv:1110.3853", "journal-ref": "EPTCS 69, 2011, pp. 111-129", "doi": "10.4204/EPTCS.69.8", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  X10 is a modern language built from the ground up to handle future parallel\nsystems, from multicore machines to cluster configurations. We take a closer\nlook at a pair of synchronisation mechanisms: finish and clocks. The former\nwaits for the termination of parallel computations, the latter allow multiple\nconcurrent activities to wait for each other at certain points in time. In\norder to better understand these concepts we study a type system for a stripped\ndown version of X10. The main result assures that well typed programs do not\nrun into the errors identified in the X10 language reference, namely the\nClockUseException. The study will open, we hope, doors to a more flexible\nutilisation of clocks in the X10 language.\n", "versions": [{"version": "v1", "created": "Wed, 19 Oct 2011 02:38:38 GMT"}], "update_date": "2011-10-20", "authors_parsed": [["Martins", "Francisco", "", "LaSIGE and University of Lisbon, Portugal"], ["Vasconcelos", "Vasco T.", "", "LaSIGE and University of Lisbon, Portugal"], ["Cogumbreiro", "Tiago", "", "LaSIGE and University of Lisbon, Portugal"]]}, {"id": "1110.4802", "submitter": "Vincent Tariel", "authors": "O. Cugnon de Sevricourt and V. Tariel", "title": "Cameleon language Part 1: Processor", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Emergence is the way complex systems arise out of a multiplicity of\nrelatively simple interactions between primitives. Since programming problems\nbecome more and more complexes and transverses, our vision is that application\ndevelopment should be process at two scales: micro- and macro-programming where\nat the micro-level the paradigm is step-by-step and at macro-level the paradigm\nis emergence. For micro-programming, which focuses on how things happen,\npopular languages, Java, C++, Python, are imperative writing languages where\nthe code is a sequence of sentences executed by the computer. For\nmacro-programming, which focuses on how things connect, popular languages,\nlabVIEW, Blender, Simulink, are graphical data flow languages such that the\nprogram is a composition of operators, a unit-process consuming input data and\nproducing output data, and connectors, a data-flow between an output data and\nan input data of two operators. However, despite their fruitful applications,\nthese macro-languages are not transversal since different data-structures of\nnative data-structures cannot be integrated in their framework easily. Cameleon\nlanguage is a graphical data flow language following a two-scale paradigm. It\nallows an easy up-scale that is the integration of any library writing in C++\nin the data flow language. Cameleon language aims to democratize\nmacro-programming by an intuitive interaction between the human and the\ncomputer where building an application based on a data-process and a GUI is a\nsimple task to learn and to do. Cameleon language allows conditional execution\nand repetition to solve complex macro-problems. In this paper we introduce a\nnew model based on the extension of the petri net model for the description of\nhow the Cameleon language executes a composition.\n", "versions": [{"version": "v1", "created": "Tue, 27 Sep 2011 15:28:38 GMT"}], "update_date": "2011-10-24", "authors_parsed": [["de Sevricourt", "O. Cugnon", ""], ["Tariel", "V.", ""]]}, {"id": "1110.4978", "submitter": "W{\\l}odzimierz Drabent", "authors": "W{\\l}odzimierz Drabent", "title": "Logic + control: On program construction and verification", "comments": "29 pages. Version 3 substantially reworked, in particular all\n  informal reasoning replaced by proofs, part of the content moved to 1412.8739\n  and 1411.3015. Versions 4, 5 and this one -- various modifications and\n  extensions. Under consideration in Theory and Practice of Logic Programming\n  (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents an example of formal reasoning about the semantics of a\nProlog program of practical importance (the SAT solver of Howe and King). The\nprogram is treated as a definite clause logic program with added control. The\nlogic program is constructed by means of stepwise refinement, hand in hand with\nits correctness and completeness proofs. The proofs are declarative - they do\nnot refer to any operational semantics. Each step of the logic program\nconstruction follows a systematic approach to constructing programs which are\nprovably correct and complete. We also prove that correctness and completeness\nof the logic program is preserved in the final Prolog program. Additionally, we\nprove termination, occur-check freedom and non-floundering.\n  Our example shows how dealing with \"logic\" and with \"control\" can be\nseparated. Most of the proofs can be done at the \"logic\" level, abstracting\nfrom any operational semantics.\n  The example employs approximate specifications; they are crucial in\nsimplifying reasoning about logic programs. It also shows that the paradigm of\nsemantics-preserving program transformations may be not sufficient. We suggest\nconsidering transformations which preserve correctness and completeness with\nrespect to an approximate specification.\n", "versions": [{"version": "v1", "created": "Sat, 22 Oct 2011 15:29:28 GMT"}, {"version": "v2", "created": "Sat, 26 May 2012 15:19:39 GMT"}, {"version": "v3", "created": "Wed, 30 Dec 2015 23:16:26 GMT"}, {"version": "v4", "created": "Wed, 28 Dec 2016 21:36:40 GMT"}, {"version": "v5", "created": "Fri, 13 Jan 2017 14:04:45 GMT"}, {"version": "v6", "created": "Fri, 12 May 2017 16:54:29 GMT"}], "update_date": "2017-05-15", "authors_parsed": [["Drabent", "W\u0142odzimierz", ""]]}, {"id": "1110.6685", "submitter": "EPTCS", "authors": "Herman Geuvers, Gopalan Nadathur", "title": "Proceedings Sixth International Workshop on Logical Frameworks and\n  Meta-languages: Theory and Practice", "comments": null, "journal-ref": "EPTCS 71, 2011", "doi": "10.4204/EPTCS.71", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume constitutes the proceedings of LFMTP 2011, the Sixth\nInternational Workshop on Logical Frameworks and Meta-languages: Theory and\nPractice. The LFMTP workshop series brings together designers, implementors,\nand practitioners to discuss varied aspects of the structure of logical\nframeworks and meta-languages that impinge on their use in representing,\nimplementing, and reasoning about a wide variety of deductive systems of\ninterest in logic and computer science. LFMTP 2011 was held on August 26, 2011\nin Nijmegen, Netherlands, as a workshop associated with ITP 2011, the Second\nInternational Conference on Interactive Theorem Proving. Its program consisted\nof contributed and invited presentations and was integrated with that of MLPA\n11, the Third Workshop on Modules and Libraries for Proof Assistants. This\nproceedings contains only the contributed papers that were accepted for\npresentation at the workshop. Each of these papers was accepted based on the\nreviews of three members of the program committee. Authors were subsequently\ngiven the opportunity to revise their submissions based on the comments\nprovided by the reviewers and the feedback obtained during their presentations\nat the workshop.\n", "versions": [{"version": "v1", "created": "Mon, 31 Oct 2011 03:38:41 GMT"}], "update_date": "2011-11-01", "authors_parsed": [["Geuvers", "Herman", ""], ["Nadathur", "Gopalan", ""]]}]