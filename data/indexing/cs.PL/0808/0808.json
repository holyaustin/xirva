[{"id": "0808.0556", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "Logic Engines as Interactors", "comments": "unpublished draft", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new programming language construct, Interactors, supporting\nthe agent-oriented view that programming is a dialog between simple,\nself-contained, autonomous building blocks.\n  We define Interactors as an abstraction of answer generation and refinement\nin Logic Engines resulting in expressive language extension and metaprogramming\npatterns, including emulation of Prolog's dynamic database.\n  A mapping between backtracking based answer generation in the callee and\n\"forward\" recursion in the caller enables interaction between different\nbranches of the callee's search process and provides simplified design patterns\nfor algorithms involving combinatorial generation and infinite answer streams.\n  Interactors extend language constructs like Ruby, Python and C#'s multiple\ncoroutining block returns through yield statements and they can emulate the\naction of monadic constructs and catamorphisms in functional languages.\n  Keywords: generalized iterators, logic engines, agent oriented programming\nlanguage constructs, interoperation with stateful objects, metaprogramming\n", "versions": [{"version": "v1", "created": "Tue, 5 Aug 2008 05:48:32 GMT"}], "update_date": "2008-08-07", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "0808.0586", "submitter": "Xavier Leroy", "authors": "Xavier Leroy (INRIA Rocquencourt), Herv\\'e Grall (INRIA Rennes, LINA)", "title": "Coinductive big-step operational semantics", "comments": null, "journal-ref": "Information and Computation (2007)", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Using a call-by-value functional language as an example, this article\nillustrates the use of coinductive definitions and proofs in big-step\noperational semantics, enabling it to describe diverging evaluations in\naddition to terminating evaluations. We formalize the connections between the\ncoinductive big-step semantics and the standard small-step semantics, proving\nthat both semantics are equivalent. We then study the use of coinductive\nbig-step semantics in proofs of type soundness and proofs of semantic\npreservation for compilers. A methodological originality of this paper is that\nall results have been proved using the Coq proof assistant. We explain the\nproof-theoretic presentation of coinductive definitions and proofs offered by\nCoq, and show that it facilitates the discovery and the presentation of the\nresults.\n", "versions": [{"version": "v1", "created": "Tue, 5 Aug 2008 14:47:32 GMT"}], "update_date": "2008-08-06", "authors_parsed": [["Leroy", "Xavier", "", "INRIA Rocquencourt"], ["Grall", "Herv\u00e9", "", "INRIA Rennes, LINA"]]}, {"id": "0808.2953", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "Declarative Combinatorics: Isomorphisms, Hylomorphisms and Hereditarily\n  Finite Data Types in Haskell", "comments": "unpublished draft, revision 3, added various new encodings, with\n  focus on primes and multisets, now 104 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper is an exploration in a functional programming framework of {\\em\nisomorphisms} between elementary data types (natural numbers, sets, multisets,\nfinite functions, permutations binary decision diagrams, graphs, hypergraphs,\nparenthesis languages, dyadic rationals, primes, DNA sequences etc.) and their\nextension to hereditarily finite universes through {\\em hylomorphisms} derived\nfrom {\\em ranking/unranking} and {\\em pairing/unpairing} operations.\n  An embedded higher order {\\em combinator language} provides any-to-any\nencodings automatically.\n  Besides applications to experimental mathematics, a few examples of ``free\nalgorithms'' obtained by transferring operations between data types are shown.\nOther applications range from stream iterators on combinatorial objects to\nself-delimiting codes, succinct data representations and generation of random\ninstances.\n  The paper covers 59 data types and, through the use of the embedded\ncombinator language, provides 3540 distinct bijective transformations between\nthem.\n  The self-contained source code of the paper, as generated from a literate\nHaskell program, is available at\n\\url{http://logic.csci.unt.edu/tarau/research/2008/fISO.zip}.\n  {\\bf Keywords}: Haskell data representations, data type isomorphisms,\ndeclarative combinatorics, computational mathematics, Ackermann encoding,\nG\\\"{o}del numberings, arithmetization, ranking/unranking, hereditarily finite\nsets, functions and permutations, encodings of binary decision diagrams, dyadic\nrationals, DNA encodings\n", "versions": [{"version": "v1", "created": "Thu, 21 Aug 2008 16:47:38 GMT"}, {"version": "v2", "created": "Mon, 20 Oct 2008 18:47:59 GMT"}, {"version": "v3", "created": "Tue, 9 Dec 2008 01:28:15 GMT"}, {"version": "v4", "created": "Mon, 19 Jan 2009 19:39:51 GMT"}], "update_date": "2009-01-19", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "0808.3307", "submitter": "Naokata Shikuma", "authors": "Naokata Shikuma, Atsushi Igarashi", "title": "Proving Noninterference by a Fully Complete Translation to the Simply\n  Typed lambda-calculus", "comments": "31 pages", "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 3 (September\n  20, 2008) lmcs:683", "doi": "10.2168/LMCS-4(3:10)2008", "report-no": null, "categories": "cs.PL cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Tse and Zdancewic have formalized the notion of noninterference for Abadi et\nal.'s DCC in terms of logical relations and given a proof of noninterference by\nreduction to parametricity of System F. Unfortunately, their proof contains\nerrors in a key lemma that their translation from DCC to System F preserves the\nlogical relations defined for both calculi. In fact, we have found a\ncounterexample for it. In this article, instead of DCC, we prove\nnoninterference for sealing calculus, a new variant of DCC, by reduction to the\nbasic lemma of a logical relation for the simply typed lambda-calculus, using a\nfully complete translation to the simply typed lambda-calculus. Full\ncompleteness plays an important role in showing preservation of the two logical\nrelations through the translation. Also, we investigate relationship among\nsealing calculus, DCC, and an extension of DCC by Tse and Zdancewic and show\nthat the first and the last of the three are equivalent.\n", "versions": [{"version": "v1", "created": "Mon, 25 Aug 2008 06:56:05 GMT"}, {"version": "v2", "created": "Sat, 20 Sep 2008 21:35:24 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Shikuma", "Naokata", ""], ["Igarashi", "Atsushi", ""]]}, {"id": "0808.3548", "submitter": "Ioan Raicu", "authors": "Yong Zhao, Ioan Raicu, Ian Foster, Mihael Hategan, Veronika Nefedova,\n  Mike Wilde", "title": "Realizing Fast, Scalable and Reliable Scientific Computations in Grid\n  Environments", "comments": "Book chapter in Grid Computing Research Progress, ISBN:\n  978-1-60456-404-4, Nova Publisher 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The practical realization of managing and executing large scale scientific\ncomputations efficiently and reliably is quite challenging. Scientific\ncomputations often involve thousands or even millions of tasks operating on\nlarge quantities of data, such data are often diversely structured and stored\nin heterogeneous physical formats, and scientists must specify and run such\ncomputations over extended periods on collections of compute, storage and\nnetwork resources that are heterogeneous, distributed and may change\nconstantly. We present the integration of several advanced systems: Swift,\nKarajan, and Falkon, to address the challenges in running various large scale\nscientific applications in Grid environments. Swift is a parallel programming\ntool for rapid and reliable specification, execution, and management of\nlarge-scale science and engineering workflows. Swift consists of a simple\nscripting language called SwiftScript and a powerful runtime system that is\nbased on the CoG Karajan workflow engine and integrates the Falkon light-weight\ntask execution service that uses multi-level scheduling and a streamlined\ndispatcher. We showcase the scalability, performance and reliability of the\nintegrated system using application examples drawn from astronomy, cognitive\nneuroscience and molecular dynamics, which all comprise large number of\nfine-grained jobs. We show that Swift is able to represent dynamic workflows\nwhose structures can only be determined during runtime and reduce largely the\ncode size of various workflow representations using SwiftScript; schedule the\nexecution of hundreds of thousands of parallel computations via the Karajan\nengine; and achieve up to 90% reduction in execution time when compared to\ntraditional batch schedulers.\n", "versions": [{"version": "v1", "created": "Tue, 26 Aug 2008 16:15:42 GMT"}], "update_date": "2008-08-27", "authors_parsed": [["Zhao", "Yong", ""], ["Raicu", "Ioan", ""], ["Foster", "Ian", ""], ["Hategan", "Mihael", ""], ["Nefedova", "Veronika", ""], ["Wilde", "Mike", ""]]}]