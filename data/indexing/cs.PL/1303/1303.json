[{"id": "1303.0276", "submitter": "Wei-Lun Hung Wei-Lun Hung", "authors": "Wei-Lun Hung and Vijay K. Garg", "title": "AutoSynch: An Automatic-Signal Monitor Based on Predicate Tagging", "comments": "10 pages, 15 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most programming languages use monitors with explicit signals for\nsynchronization in shared-memory programs. Requiring program- mers to signal\nthreads explicitly results in many concurrency bugs due to missed\nnotifications, or notifications on wrong condition variables. In this paper, we\ndescribe an implementation of an au- tomatic signaling monitor in Java called\nAutoSynch that eliminates such concurrency bugs by removing the burden of\nsignaling from the programmer. We show that the belief that automatic signaling\nmonitors are prohibitively expensive is wrong. For most problems, programs\nbased on AutoSynch are almost as fast as those based on explicit signaling. For\nsome, AutoSynch is even faster than explicit signaling because it never uses\nsignalAll, whereas the programmers end up using signalAll with the explicit\nsignal mechanism. AutoSynch achieves efficiency in synchronization based on\nthree novel ideas. We introduce an operation called globalization that enables\nthe predicate evaluation in every thread, thereby reducing context switches\nduring the execution of the program. Secondly, AutoSynch avoids signalAll by\nusing a property called relay invari- ance that guarantees that whenever\npossible there is always at least one thread whose condition is true which has\nbeen signaled. Finally, AutoSynch uses a technique called predicate tagging to\nefficiently determine a thread that should be signaled. To evaluate the effi-\nciency of AutoSynch, we have implemented many different well- known\nsynchronization problems such as the producers/consumers problem, the\nreaders/writers problems, and the dining philosophers problem. The results show\nthat AutoSynch is almost as efficient as the explicit-signal monitor and even\nmore efficient for some cases.\n", "versions": [{"version": "v1", "created": "Fri, 1 Mar 2013 20:49:44 GMT"}], "update_date": "2013-03-04", "authors_parsed": [["Hung", "Wei-Lun", ""], ["Garg", "Vijay K.", ""]]}, {"id": "1303.0427", "submitter": "Andrew Black", "authors": "Andrew P. Black", "title": "Object-oriented programming: some history, and challenges for the next\n  fifty years", "comments": "42 pages; author's version of a paper submitted to Information and\n  Control", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Object-oriented programming is inextricably linked to the pioneering work of\nOle-Johan Dahl and Kristen Nygaard on the design of the Simula language, which\nstarted at the Norwegian Computing Centre in the Spring of 1961. However,\nobject-orientation, as we think of it today---fifty years later---is the result\nof a complex interplay of ideas, constraints and people. Dahl and Nygaard would\ncertainly recognise it as their progeny, but might also be amazed at how much\nit has grown up.\n  This article is based on a lecture given on 22nd August 2011, on the occasion\nof the scientific opening of the Ole-Johan Dahl hus at the University of Oslo.\nIt looks at the foundational ideas from Simula that stand behind\nobject-orientation, how those ideas have evolved to become the dominant\nprogramming paradigm, and what they have to offer as we approach the challenges\nof the next fifty years of informatics.\n", "versions": [{"version": "v1", "created": "Sat, 2 Mar 2013 20:38:33 GMT"}], "update_date": "2013-03-05", "authors_parsed": [["Black", "Andrew P.", ""]]}, {"id": "1303.0722", "submitter": "Iztok Fister", "authors": "Iztok Fister Jr., Toma\\v{z} Kosar, Iztok Fister, Marjan Mernik", "title": "EasyTime++: A case study of incremental domain-specific language\n  development", "comments": null, "journal-ref": "Information technology and control, 42(1), 77--85, 2013", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  EasyTime is a domain-specific language (DSL) for measuring time during sports\ncompetitions. A distinguishing feature of DSLs is that they are much more\namenable to change, and EasyTime is no exception in this regard. This paper\nintroduces two new EasyTime features: classifications of competitors into\ncategories, and the inclusion of competitions where the number of laps must be\ndynamically determined. It shows how such extensions can be incrementally added\ninto the base-language reusing most of the language specifications. Two case\nstudies are presented showing the suitability of this approach.\n", "versions": [{"version": "v1", "created": "Mon, 4 Mar 2013 15:11:38 GMT"}], "update_date": "2013-03-05", "authors_parsed": [["Fister", "Iztok", "Jr."], ["Kosar", "Toma\u017e", ""], ["Fister", "Iztok", ""], ["Mernik", "Marjan", ""]]}, {"id": "1303.0908", "submitter": "George Abraham", "authors": "Rajasekhara Babu, Krishnakumar V., George Abraham, Kiransinh Borasia", "title": "KRAB Algorithm - A Revised Algorithm for Incremental Call Graph\n  Generation", "comments": "6 pages, 7 figures, 1 Table, Conference", "journal-ref": "World Applied Programming, Vol (2), Issue (5), May 2012. 294-299,\n  Special section for proceeding of International E-Conference on Information\n  Technology and Applications (IECITA), ISSN: 2222-2510", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper is aimed to present the importance and implementation of an\nincremental call graph plugin. An algorithm is proposed for the call graph\nimplementation which has better overall performance than the algorithm that has\nbeen proposed previously. In addition to this, the algorithm has been\nempirically proved to have excellent performance on recursive codes. The\nalgorithm also readily checks for function skip and returns exceptions.\n", "versions": [{"version": "v1", "created": "Tue, 5 Mar 2013 02:13:28 GMT"}], "update_date": "2013-03-06", "authors_parsed": [["Babu", "Rajasekhara", ""], ["V.", "Krishnakumar", ""], ["Abraham", "George", ""], ["Borasia", "Kiransinh", ""]]}, {"id": "1303.1716", "submitter": "Kim Nguyen", "authors": "V\\'eronique Benzaken (LRI), Giuseppe Castagna (PPS), Kim Nguy\\~\\^en\n  (LRI), J\\'er\\^ome Sim\\'eon", "title": "Static and dynamic semantics of NoSQL languages", "comments": null, "journal-ref": "POPL, Rome : Italy (2013)", "doi": "10.1145/2429069.2429083", "report-no": null, "categories": "cs.PL cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a calculus for processing semistructured data that spans\ndifferences of application area among several novel query languages, broadly\ncategorized as \"NoSQL\". This calculus lets users define their own operators,\ncapturing a wider range of data processing capabilities, whilst providing a\ntyping precision so far typical only of primitive hard-coded operators. The\ntype inference algorithm is based on semantic type checking, resulting in type\ninformation that is both precise, and flexible enough to handle structured and\nsemistructured data. We illustrate the use of this calculus by encoding a large\nfragment of Jaql, including operations and iterators over JSON, embedded SQL\nexpressions, and co-grouping, and show how the encoding directly yields a\ntyping discipline for Jaql as it is, namely without the addition of any type\ndefinition or type annotation in the code.\n", "versions": [{"version": "v1", "created": "Thu, 7 Mar 2013 15:19:21 GMT"}], "update_date": "2013-03-08", "authors_parsed": [["Benzaken", "V\u00e9ronique", "", "LRI"], ["Castagna", "Giuseppe", "", "PPS"], ["Nguy\\~\u00ean", "Kim", "", "LRI"], ["Sim\u00e9on", "J\u00e9r\u00f4me", ""]]}, {"id": "1303.1880", "submitter": "Nabizath Saleena", "authors": "Nabizath Saleena, Vineeth Paleri", "title": "A Simple Algorithm for Global Value Numbering", "comments": "7 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Global Value Numbering(GVN) is a method for detecting redundant computations\nin programs. Here, we introduce the problem of Global Value Numbering in its\noriginal form, as conceived by Kildall(1973), and present an algorithm which is\na simpler variant of Kildall's. The algorithm uses the concept of value\nexpression - an abstraction of a set of expressions - enabling a representation\nof the equivalence information which is compact and simple to manipulate.\n", "versions": [{"version": "v1", "created": "Fri, 8 Mar 2013 04:02:33 GMT"}, {"version": "v2", "created": "Tue, 16 Sep 2014 06:59:03 GMT"}], "update_date": "2014-09-17", "authors_parsed": [["Saleena", "Nabizath", ""], ["Paleri", "Vineeth", ""]]}, {"id": "1303.2201", "submitter": "Emanuele D'Osualdo", "authors": "Emanuele D'Osualdo, Jonathan Kochems, C.-H. Luke Ong", "title": "Automatic Verification of Erlang-Style Concurrency", "comments": "12 pages plus appendix, 4 figures, 1 table. The tool is available at\n  http://mjolnir.cs.ox.ac.uk/soter/", "journal-ref": null, "doi": "10.1007/978-3-642-38856-9_24", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents an approach to verify safety properties of Erlang-style,\nhigher-order concurrent programs automatically. Inspired by Core Erlang, we\nintroduce Lambda-Actor, a prototypical functional language with\npattern-matching algebraic data types, augmented with process creation and\nasynchronous message-passing primitives. We formalise an abstract model of\nLambda-Actor programs called Actor Communicating System (ACS) which has a\nnatural interpretation as a vector addition system, for which some verification\nproblems are decidable. We give a parametric abstract interpretation framework\nfor Lambda-Actor and use it to build a polytime computable, flow-based,\nabstract semantics of Lambda-Actor programs, which we then use to bootstrap the\nACS construction, thus deriving a more accurate abstract model of the input\nprogram. We have constructed Soter, a tool implementation of the verification\nmethod, thereby obtaining the first fully-automatic, infinite-state model\nchecker for a core fragment of Erlang. We find that in practice our abstraction\ntechnique is accurate enough to verify an interesting range of safety\nproperties. Though the ACS coverability problem is Expspace-complete, Soter can\nanalyse these verification problems surprisingly efficiently.\n", "versions": [{"version": "v1", "created": "Sat, 9 Mar 2013 12:10:01 GMT"}], "update_date": "2016-01-11", "authors_parsed": [["D'Osualdo", "Emanuele", ""], ["Kochems", "Jonathan", ""], ["Ong", "C. -H. Luke", ""]]}, {"id": "1303.5768", "submitter": "Henning Thielemann", "authors": "Henning Thielemann", "title": "Live music programming in Haskell", "comments": "10 pages, 2 figures, Linux Audio Conference 2013. This is a\n  translation and update of the ATPS-2012 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SD", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We aim for composing algorithmic music in an interactive way with multiple\nparticipants. To this end we have developed an interpreter for a sub-language\nof the non-strict functional programming language Haskell that allows the\nmodification of a program during its execution. Our system can be used both for\nmusical live-coding and for demonstration and education of functional\nprogramming.\n", "versions": [{"version": "v1", "created": "Fri, 22 Mar 2013 20:02:38 GMT"}], "update_date": "2013-03-26", "authors_parsed": [["Thielemann", "Henning", ""]]}, {"id": "1303.6777", "submitter": "Andreas Angerer", "authors": "Andreas Angerer, Remi Smirra, Alwin Hoffmann, Andreas Schierl, Michael\n  Vistein and Wolfgang Reif", "title": "A Graphical Language for Real-Time Critical Robot Commands", "comments": "Presented at DSLRob 2012 (arXiv:cs/1302.5082)", "journal-ref": null, "doi": null, "report-no": "DSLRob/2012/02", "categories": "cs.RO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Industrial robotics is characterized by sophisticated mechanical components\nand highly-developed real-time control algorithms. However, the efficient use\nof robotic systems is very much limited by existing proprietary programming\nmethods. In the research project SoftRobot, a software architecture was\ndeveloped that enables the programming of complex real-time critical robot\ntasks with an object-oriented general purpose language. On top of this\narchitecture, a graphical language was developed to ease the specification of\ncomplex robot commands, which can then be used as part of robot application\nworkflows. This paper gives an overview about the design and implementation of\nthis graphical language and illustrates its usefulness with some examples.\n", "versions": [{"version": "v1", "created": "Wed, 27 Mar 2013 10:14:44 GMT"}], "update_date": "2013-03-28", "authors_parsed": [["Angerer", "Andreas", ""], ["Smirra", "Remi", ""], ["Hoffmann", "Alwin", ""], ["Schierl", "Andreas", ""], ["Vistein", "Michael", ""], ["Reif", "Wolfgang", ""]]}, {"id": "1303.7136", "submitter": "EPTCS", "authors": "Delia Kesner (Universit\\'e Paris-Diderot), Petrucio Viana\n  (Universidade Federal Fluminense)", "title": "Proceedings Seventh Workshop on Logical and Semantic Frameworks, with\n  Applications", "comments": null, "journal-ref": "EPTCS 113, 2013", "doi": "10.4204/EPTCS.113", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This document contains the proceedings of the Seventh International Workshop\non Logical and Semantic Frameworks, with Applications, which was held on\nSeptember 29 and 30, 2012, in Rio de Janeiro, Brazil. It contains 11 regular\npapers (9 long and 2 short) accepted for presentation at the meeting, as well\nas extended abstracts of invited talks by Torben Bra\\\"uner (Roskilde\nUniversity, Denmark), Maribel Fern\\'andez (King's College London, United\nKingdom), Edward Hermann Haeusler (PUC-Rio, Brazil) and Alexandre Miquel\n(\\'Ecole Normale Sup\\'erieure de Lyon, France).\n", "versions": [{"version": "v1", "created": "Thu, 28 Mar 2013 14:45:17 GMT"}], "update_date": "2013-03-29", "authors_parsed": [["Kesner", "Delia", "", "Universit\u00e9 Paris-Diderot"], ["Viana", "Petrucio", "", "Universidade Federal Fluminense"]]}, {"id": "1303.7326", "submitter": "EPTCS", "authors": "Beniamino Accattoli (INRIA & Ecole Polytechnique)", "title": "Proof nets and the call-by-value lambda-calculus", "comments": "In Proceedings LSFA 2012, arXiv:1303.7136", "journal-ref": "EPTCS 113, 2013, pp. 11-26", "doi": "10.4204/EPTCS.113.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper gives a detailed account of the relationship between (a variant\nof) the call-by-value lambda calculus and linear logic proof nets. The\npresentation is carefully tuned in order to realize a strong bisimulation\nbetween the two systems: every single rewriting step on the calculus maps to a\nsingle step on the nets, and viceversa. In this way, we obtain an algebraic\nreformulation of proof nets. Moreover, we provide a simple correctness\ncriterion for our proof nets, which employ boxes in an unusual way.\n", "versions": [{"version": "v1", "created": "Fri, 29 Mar 2013 09:01:43 GMT"}], "update_date": "2013-04-01", "authors_parsed": [["Accattoli", "Beniamino", "", "INRIA & Ecole Polytechnique"]]}, {"id": "1303.7332", "submitter": "EPTCS", "authors": "Alberto Ciaffaglione (Dipartimento di Matematica e Informatica,\n  Universit\\`a di Udine, Italia), Ivan Scagnetto (Dipartimento di Matematica e\n  Informatica, Universit\\`a di Udine, Italia)", "title": "A weak HOAS approach to the POPLmark Challenge", "comments": "In Proceedings LSFA 2012, arXiv:1303.7136", "journal-ref": "EPTCS 113, 2013, pp. 109-124", "doi": "10.4204/EPTCS.113.11", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Capitalizing on previous encodings and formal developments about nominal\ncalculi and type systems, we propose a weak Higher-Order Abstract Syntax\nformalization of the type language of pure System F<: within Coq, a proof\nassistant based on the Calculus of Inductive Constructions.\n  Our encoding allows us to accomplish the proof of the transitivity property\nof algorithmic subtyping, which is in fact the first of the three tasks stated\nby the POPLmark Challenge, a set of problems that capture the most critical\nissues in formalizing programming language metatheory.\n", "versions": [{"version": "v1", "created": "Fri, 29 Mar 2013 09:02:20 GMT"}], "update_date": "2013-04-01", "authors_parsed": [["Ciaffaglione", "Alberto", "", "Dipartimento di Matematica e Informatica,\n  Universit\u00e0 di Udine, Italia"], ["Scagnetto", "Ivan", "", "Dipartimento di Matematica e\n  Informatica, Universit\u00e0 di Udine, Italia"]]}, {"id": "1303.7335", "submitter": "EPTCS", "authors": "Ana Cristina Rocha Oliveira (Universidade de Brasilia), Mauricio\n  Ayala-Rinc\\'on (Universidade de Brasilia)", "title": "Formalizing the Confluence of Orthogonal Rewriting Systems", "comments": "In Proceedings LSFA 2012, arXiv:1303.7136", "journal-ref": "EPTCS 113, 2013, pp. 145-152", "doi": "10.4204/EPTCS.113.14", "report-no": null, "categories": "cs.LO cs.AI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Orthogonality is a discipline of programming that in a syntactic manner\nguarantees determinism of functional specifications. Essentially, orthogonality\navoids, on the one side, the inherent ambiguity of non determinism, prohibiting\nthe existence of different rules that specify the same function and that may\napply simultaneously (non-ambiguity), and, on the other side, it eliminates the\npossibility of occurrence of repetitions of variables in the left-hand side of\nthese rules (left linearity). In the theory of term rewriting systems (TRSs)\ndeterminism is captured by the well-known property of confluence, that\nbasically states that whenever different computations or simplifications from a\nterm are possible, the computed answers should coincide. Although the proofs\nare technically elaborated, confluence is well-known to be a consequence of\northogonality. Thus, orthogonality is an important mathematical discipline\nintrinsic to the specification of recursive functions that is naturally applied\nin functional programming and specification. Starting from a formalization of\nthe theory of TRSs in the proof assistant PVS, this work describes how\nconfluence of orthogonal TRSs has been formalized, based on axiomatizations of\nproperties of rules, positions and substitutions involved in parallel steps of\nreduction, in this proof assistant. Proofs for some similar but restricted\nproperties such as the property of confluence of non-ambiguous and (left and\nright) linear TRSs have been fully formalized.\n", "versions": [{"version": "v1", "created": "Fri, 29 Mar 2013 09:02:42 GMT"}], "update_date": "2013-04-01", "authors_parsed": [["Oliveira", "Ana Cristina Rocha", "", "Universidade de Brasilia"], ["Ayala-Rinc\u00f3n", "Mauricio", "", "Universidade de Brasilia"]]}]