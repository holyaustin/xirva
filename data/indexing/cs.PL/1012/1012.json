[{"id": "1012.1641", "submitter": "Yibing Wang", "authors": "Yibing Wang", "title": "A Generalized Streaming Model for Concurrent Computing", "comments": "12 pages, 7 figures. unpublished draft for a high-level discussion of\n  an abstract, parallel computing model", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  Multicore parallel programming has some very difficult problems such as\ndeadlocks during synchronizations and race conditions brought by concurrency.\nAdded to the difficulty is the lack of a simple, well-accepted computing model\nfor multicore architectures--because of that it is hard to develop powerful\nprogramming environments and debugging tools. To tackle the challenges, we\npromote a generalized stream computing model, inspired by previous researches\non stream computing, that unifies parallelization strategies for programming\nlanguage design, compiler design and operating system design. Our model\nprovides a high-level abstraction in designing language constructs to convey\nconcepts of concurrent operations, in organizing a program's runtime layout for\nparallel execution, and in scheduling concurrent instruction blocks through\nruntime and/or operating systems. In this paper, we give a high-level\ndescription of the proposed model: we define the foundation of the model, show\nits simplicity through algebraic/computational operation analysis, illustrate a\nprogramming framework enabled by the model, and demonstrate its potential\nthrough powerful design options for programming languages, compilers and\noperating systems.\n", "versions": [{"version": "v1", "created": "Tue, 7 Dec 2010 23:43:09 GMT"}], "update_date": "2010-12-09", "authors_parsed": [["Wang", "Yibing", ""]]}, {"id": "1012.1802", "submitter": "Michael Stepp", "authors": "Ross Tate (University of California, San Diego), Michael Stepp\n  (University of California, San Diego), Zachary Tatlock (University of\n  California, San Diego), Sorin Lerner (University of California, San Diego)", "title": "Equality Saturation: A New Approach to Optimization", "comments": "80 pages, 39 figures", "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 1 (March 28,\n  2011) lmcs:1016", "doi": "10.2168/LMCS-7(1:10)2011", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Optimizations in a traditional compiler are applied sequentially, with each\noptimization destructively modifying the program to produce a transformed\nprogram that is then passed to the next optimization. We present a new approach\nfor structuring the optimization phase of a compiler. In our approach,\noptimizations take the form of equality analyses that add equality information\nto a common intermediate representation. The optimizer works by repeatedly\napplying these analyses to infer equivalences between program fragments, thus\nsaturating the intermediate representation with equalities. Once saturated, the\nintermediate representation encodes multiple optimized versions of the input\nprogram. At this point, a profitability heuristic picks the final optimized\nprogram from the various programs represented in the saturated representation.\nOur proposed way of structuring optimizers has a variety of benefits over\nprevious approaches: our approach obviates the need to worry about optimization\nordering, enables the use of a global optimization heuristic that selects among\nfully optimized programs, and can be used to perform translation validation,\neven on compilers other than our own. We present our approach, formalize it,\nand describe our choice of intermediate representation. We also present\nexperimental results showing that our approach is practical in terms of time\nand space overhead, is effective at discovering intricate optimization\nopportunities, and is effective at performing translation validation for a\nrealistic optimizer.\n", "versions": [{"version": "v1", "created": "Thu, 2 Dec 2010 15:47:02 GMT"}, {"version": "v2", "created": "Thu, 16 Dec 2010 01:31:40 GMT"}, {"version": "v3", "created": "Fri, 25 Mar 2011 10:18:43 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Tate", "Ross", "", "University of California, San Diego"], ["Stepp", "Michael", "", "University of California, San Diego"], ["Tatlock", "Zachary", "", "University of\n  California, San Diego"], ["Lerner", "Sorin", "", "University of California, San Diego"]]}, {"id": "1012.2294", "submitter": "Steven Obua", "authors": "Steven Obua", "title": "Syntax and Semantics of Babel-17", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present Babel-17, the first programming language for purely functional\nstructured programming (PFSP). Earlier work illustrated PFSP in the framework\nof a toy research language. Babel-17 takes this earlier work to a new level by\nshowing how PFSP can be combined with pattern matching, object oriented\nprogramming, and features like concurrency, lazy evaluation, memoization and\nsupport for lenses.\n", "versions": [{"version": "v1", "created": "Fri, 10 Dec 2010 15:37:06 GMT"}, {"version": "v2", "created": "Thu, 30 Jun 2011 07:34:05 GMT"}, {"version": "v3", "created": "Thu, 21 Jul 2011 15:38:50 GMT"}, {"version": "v4", "created": "Mon, 15 Aug 2011 09:21:52 GMT"}], "update_date": "2011-08-16", "authors_parsed": [["Obua", "Steven", ""]]}, {"id": "1012.2299", "submitter": "Wlodzimierz Drabent", "authors": "Wlodzimierz Drabent", "title": "A Simple Correctness Proof for Magic Transformation", "comments": "Submitted to \"Theory and Practice of Logic Programming\"", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper presents a simple and concise proof of correctness of the magic\ntransformation. We believe it may provide a useful example of formal reasoning\nabout logic programs.\n  The correctness property concerns the declarative semantics. The proof,\nhowever, refers to the operational semantics (LD-resolution) of the source\nprograms. Its conciseness is due to applying a suitable proof method.\n", "versions": [{"version": "v1", "created": "Fri, 10 Dec 2010 15:50:36 GMT"}], "update_date": "2010-12-13", "authors_parsed": [["Drabent", "Wlodzimierz", ""]]}, {"id": "1012.2496", "submitter": "Salvador Abreu", "authors": "Daniel Diaz, Salvador Abreu and Philippe Codognet", "title": "On the Implementation of GNU Prolog", "comments": "30 pages, 3 figures, To appear in Theory and Practice of Logic\n  Programming (TPLP); Keywords: Prolog, logic programming system, GNU, ISO,\n  WAM, native code compilation, Finite Domain constraints", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  GNU Prolog is a general-purpose implementation of the Prolog language, which\ndistinguishes itself from most other systems by being, above all else, a\nnative-code compiler which produces standalone executables which don't rely on\nany byte-code emulator or meta-interpreter. Other aspects which stand out\ninclude the explicit organization of the Prolog system as a multipass compiler,\nwhere intermediate representations are materialized, in Unix compiler\ntradition. GNU Prolog also includes an extensible and high-performance finite\ndomain constraint solver, integrated with the Prolog language but implemented\nusing independent lower-level mechanisms. This article discusses the main\nissues involved in designing and implementing GNU Prolog: requirements, system\norganization, performance and portability issues as well as its position with\nrespect to other Prolog system implementations and the ISO standardization\ninitiative.\n", "versions": [{"version": "v1", "created": "Sat, 11 Dec 2010 23:23:11 GMT"}, {"version": "v2", "created": "Wed, 15 Dec 2010 15:07:58 GMT"}], "update_date": "2010-12-16", "authors_parsed": [["Diaz", "Daniel", ""], ["Abreu", "Salvador", ""], ["Codognet", "Philippe", ""]]}, {"id": "1012.4240", "submitter": "Joachim Schimpf", "authors": "Joachim Schimpf and Kish Shen", "title": "ECLiPSe - from LP to CLP", "comments": "To appear in Theory and Practice of Logic Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  ECLiPSe is a Prolog-based programming system, aimed at the development and\ndeployment of constraint programming applications. It is also used for teaching\nmost aspects of combinatorial problem solving, e.g. problem modelling,\nconstraint programming, mathematical programming, and search techniques. It\nuses an extended Prolog as its high-level modelling and control language,\ncomplemented by several constraint solver libraries, interfaces to third-party\nsolvers, an integrated development environment and interfaces for embedding\ninto host environments. This paper discusses language extensions,\nimplementation aspects, components and tools that we consider relevant on the\nway from Logic Programming to Constraint Logic Programming.\n", "versions": [{"version": "v1", "created": "Mon, 20 Dec 2010 05:11:57 GMT"}], "update_date": "2010-12-21", "authors_parsed": [["Schimpf", "Joachim", ""], ["Shen", "Kish", ""]]}, {"id": "1012.4554", "submitter": "EPTCS", "authors": "Maribel Fernandez (King's College London)", "title": "Proceedings 24th International Workshop on Unification", "comments": null, "journal-ref": "EPTCS 42, 2010", "doi": "10.4204/EPTCS.42", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains selected papers presented at the 24th International\nWorkshop on Unification, UNIF2010, which was held in Edinburgh on the 14th July\n2010, as part of FLoC 2010 (Federated Logic Conferences).\n", "versions": [{"version": "v1", "created": "Tue, 21 Dec 2010 07:05:14 GMT"}], "update_date": "2010-12-22", "authors_parsed": [["Fernandez", "Maribel", "", "King's College London"]]}, {"id": "1012.4890", "submitter": "EPTCS", "authors": "Christian Urban (TU Munich, Germany)", "title": "Nominal Unification Revisited", "comments": "In Proceedings UNIF 2010, arXiv:1012.4554", "journal-ref": "EPTCS 42, 2010, pp. 1-11", "doi": "10.4204/EPTCS.42.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Nominal unification calculates substitutions that make terms involving\nbinders equal modulo alpha-equivalence. Although nominal unification can be\nseen as equivalent to Miller's higher-order pattern unification, it has\nproperties, such as the use of first-order terms with names (as opposed to\nalpha-equivalence classes) and that no new names need to be generated during\nunification, which set it clearly apart from higher-order pattern unification.\nThe purpose of this paper is to simplify a clunky proof from the original paper\non nominal unification and to give an overview over some results about nominal\nunification.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:07:38 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Urban", "Christian", "", "TU Munich, Germany"]]}, {"id": "1012.4893", "submitter": "EPTCS", "authors": "Conrad Rau, Manfred Schmidt-Schau{\\ss}", "title": "Towards Correctness of Program Transformations Through Unification and\n  Critical Pair Computation", "comments": "In Proceedings UNIF 2010, arXiv:1012.4554", "journal-ref": "EPTCS 42, 2010, pp. 39-53", "doi": "10.4204/EPTCS.42.4", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Correctness of program transformations in extended lambda calculi with a\ncontextual semantics is usually based on reasoning about the operational\nsemantics which is a rewrite semantics. A successful approach to proving\ncorrectness is the combination of a context lemma with the computation of\noverlaps between program transformations and the reduction rules, and then of\nso-called complete sets of diagrams. The method is similar to the computation\nof critical pairs for the completion of term rewriting systems. We explore\ncases where the computation of these overlaps can be done in a first order way\nby variants of critical pair computation that use unification algorithms. As a\ncase study we apply the method to a lambda calculus with recursive\nlet-expressions and describe an effective unification algorithm to determine\nall overlaps of a set of transformations with all reduction rules. The\nunification algorithm employs many-sorted terms, the equational theory of\nleft-commutativity modelling multi-sets, context variables of different kinds\nand a mechanism for compactly representing binding chains in recursive\nlet-expressions.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:07:59 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Rau", "Conrad", ""], ["Schmidt-Schau\u00df", "Manfred", ""]]}, {"id": "1012.4896", "submitter": "EPTCS", "authors": "Andreas Abel (Ludwig-Maximilians-University Munich)", "title": "MiniAgda: Integrating Sized and Dependent Types", "comments": "In Proceedings PAR 2010, arXiv:1012.4555", "journal-ref": "EPTCS 43, 2010, pp. 14-28", "doi": "10.4204/EPTCS.43.2", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Sized types are a modular and theoretically well-understood tool for checking\ntermination of recursive and productivity of corecursive definitions. The\nessential idea is to track structural descent and guardedness in the type\nsystem to make termination checking robust and suitable for strong abstractions\nlike higher-order functions and polymorphism. To study the application of sized\ntypes to proof assistants and programming languages based on dependent type\ntheory, we have implemented a core language, MiniAgda, with explicit handling\nof sizes. New considerations were necessary to soundly integrate sized types\nwith dependencies and pattern matching, which was made possible by concepts\nsuch as inaccessible patterns and parametric function spaces. This paper\nprovides an introduction to MiniAgda by example and informal explanations of\nthe underlying principles.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:09:10 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Abel", "Andreas", "", "Ludwig-Maximilians-University Munich"]]}, {"id": "1012.4898", "submitter": "EPTCS", "authors": "Nils Anders Danielsson (University of Nottingham)", "title": "Beating the Productivity Checker Using Embedded Languages", "comments": "In Proceedings PAR 2010, arXiv:1012.4555", "journal-ref": "EPTCS 43, 2010, pp. 29-48", "doi": "10.4204/EPTCS.43.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Some total languages, like Agda and Coq, allow the use of guarded corecursion\nto construct infinite values and proofs. Guarded corecursion is a form of\nrecursion in which arbitrary recursive calls are allowed, as long as they are\nguarded by a coinductive constructor. Guardedness ensures that programs are\nproductive, i.e. that every finite prefix of an infinite value can be computed\nin finite time. However, many productive programs are not guarded, and it can\nbe nontrivial to put them in guarded form.\n  This paper gives a method for turning a productive program into a guarded\nprogram. The method amounts to defining a problem-specific language as a data\ntype, writing the program in the problem-specific language, and writing a\nguarded interpreter for this language.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:09:30 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Danielsson", "Nils Anders", "", "University of Nottingham"]]}, {"id": "1012.4900", "submitter": "EPTCS", "authors": "Aaron Stump (The University of Iowa), Vilhelm Sj\\\"oberg (University of\n  Pennsylvania), Stephanie Weirich (University of Pennsylvania)", "title": "Termination Casts: A Flexible Approach to Termination with General\n  Recursion", "comments": "In Proceedings PAR 2010, arXiv:1012.4555", "journal-ref": "EPTCS 43, 2010, pp. 76-93", "doi": "10.4204/EPTCS.43.6", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes a type-and-effect system called Teqt, which distinguishes\nterminating terms and total functions from possibly diverging terms and partial\nfunctions, for a lambda calculus with general recursion and equality types. The\ncentral idea is to include a primitive type-form \"Terminates t\", expressing\nthat term t is terminating; and then allow terms t to be coerced from possibly\ndiverging to total, using a proof of Terminates t. We call such coercions\ntermination casts, and show how to implement terminating recursion using them.\nFor the meta-theory of the system, we describe a translation from Teqt to a\nlogical theory of termination for general recursive, simply typed functions.\nEvery typing judgment of Teqt is translated to a theorem expressing the\nappropriate termination property of the computational part of the Teqt term.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:09:39 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Stump", "Aaron", "", "The University of Iowa"], ["Sj\u00f6berg", "Vilhelm", "", "University of\n  Pennsylvania"], ["Weirich", "Stephanie", "", "University of Pennsylvania"]]}, {"id": "1012.5123", "submitter": "Terrance Swift", "authors": "Terrance Swift and David S. Warren", "title": "XSB: Extending Prolog with Tabled Logic Programming", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paradigm of Tabled Logic Programming (TLP) is now supported by a number\nof Prolog systems, including XSB, YAP Prolog, B-Prolog, Mercury, ALS, and Ciao.\nThe reasons for this are partly theoretical: tabling ensures termination and\noptimal known complexity for queries to a large class of programs. However the\noverriding reasons are practical. TLP allows sophisticated programs to be\nwritten concisely and efficiently, especially when mechanisms such as tabled\nnegation and call and answer subsumption are supported. As a result TLP has now\nbeen used in a variety of applications from program analysis to querying over\nthe semantic web. This paper provides a survey of TLP and its applications as\nimplemented in XSB Prolog, along with discussion of how XSB supports tabling\nwith dynamically changing code, and in a multi-threaded environment.\n", "versions": [{"version": "v1", "created": "Thu, 23 Dec 2010 00:23:16 GMT"}], "update_date": "2010-12-24", "authors_parsed": [["Swift", "Terrance", ""], ["Warren", "David S.", ""]]}, {"id": "1012.5494", "submitter": "Serguei Mokhov", "authors": "Serguei A. Mokhov", "title": "Contents of COMP6411 Summer 2010 Final Reports on Comparative Studies of\n  Programming Languages", "comments": "an index", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  This index covers the lecture notes and the final course project reports for\nCOMP6411 Summer 2010 at Concordia University, Montreal, Canada, Comparative\nStudy of Programming Languages by 4 teams trying compare a set of common\ncriteria and their applicability to about 10 distinct programming languages,\nwhere 5 language choices were provided by the instructor and five were picked\nby each team and each student individually compared two of the 10 and then the\nteam did a summary synthesis across all 10 languages. Their findings are posted\nhere for further reference, comparative studies, and analysis.\n", "versions": [{"version": "v1", "created": "Sun, 26 Dec 2010 03:33:09 GMT"}, {"version": "v2", "created": "Sat, 19 Apr 2014 20:28:54 GMT"}], "update_date": "2014-04-22", "authors_parsed": [["Mokhov", "Serguei A.", ""]]}, {"id": "1012.5560", "submitter": "EPTCS", "authors": "Maribel Fern\\'andez (King's College London), Olivier Namet (King's\n  College London)", "title": "Strategic programming on graph rewriting systems", "comments": "In Proceedings IWS 2010, arXiv:1012.5337", "journal-ref": "EPTCS 44, 2010, pp. 1-20", "doi": "10.4204/EPTCS.44.1", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a strategy language to control the application of graph rewriting\nrules, and show how this language can be used to write high-level declarative\nprograms in several application areas. This language is part of a graph-based\nprogramming tool built within the port-graph transformation and visualisation\nenvironment PORGY.\n", "versions": [{"version": "v1", "created": "Mon, 27 Dec 2010 06:30:03 GMT"}], "update_date": "2010-12-30", "authors_parsed": [["Fern\u00e1ndez", "Maribel", "", "King's College London"], ["Namet", "Olivier", "", "King's\n  College London"]]}, {"id": "1012.6035", "submitter": "Jaros{\\l}aw Miszczak", "authors": "J. A. Miszczak", "title": "Models of quantum computation and quantum programming languages", "comments": "23 pages, 10 figures, 9 listings", "journal-ref": "Bull. Pol. Acad. Sci.-Tech. Sci., Vol. 59, No. 3 (2011), pp.\n  305-324", "doi": "10.2478/v10175-011-0039-5", "report-no": null, "categories": "cs.PL quant-ph", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  The goal of the presented paper is to provide an introduction to the basic\ncomputational models used in quantum information theory. We review various\nmodels of quantum Turing machine, quantum circuits and quantum random access\nmachine (QRAM) along with their classical counterparts. We also provide an\nintroduction to quantum programming languages, which are developed using the\nQRAM model. We review the syntax of several existing quantum programming\nlanguages and discuss their features and limitations.\n", "versions": [{"version": "v1", "created": "Wed, 29 Dec 2010 20:49:10 GMT"}, {"version": "v2", "created": "Sat, 3 Dec 2011 18:49:44 GMT"}], "update_date": "2011-12-06", "authors_parsed": [["Miszczak", "J. A.", ""]]}]