[{"id": "1207.0559", "submitter": "EPTCS", "authors": "Herbert Wiklicky, Mieke Massink", "title": "Proceedings 10th Workshop on Quantitative Aspects of Programming\n  Languages and Systems", "comments": "EPTCS 85, 2012", "journal-ref": null, "doi": "10.4204/EPTCS.85", "report-no": null, "categories": "cs.PL cs.LO cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Tenth Workshop on Quantitative\nAspects of Programming Languages (QAPL 2012), held in Tallin, Estonia, on March\n31 and April 1, 2012. QAPL 2012 is a satellite event of the European Joint\nConferences on Theory and Practice of Software (ETAPS 2012). The workshop theme\nis on quantitative aspects of computation. These aspects are related to the use\nof physical quantities (storage space, time, bandwidth, etc.) as well as\nmathematical quantities (e.g. probability and measures for reliability,\nsecurity and trust), and play an important (sometimes essential) role in\ncharacterising the behavior and determining the properties of systems. Such\nquantities are central to the definition of both the model of systems\n(architecture, language design, semantics) and the methodologies and tools for\nthe analysis and verification of the systems properties. The aim of this\nworkshop is to discuss the explicit use of quantitative information such as\ntime and probabilities either directly in the model or as a tool for the\nanalysis of systems.\n", "versions": [{"version": "v1", "created": "Tue, 3 Jul 2012 01:24:57 GMT"}], "update_date": "2012-07-04", "authors_parsed": [["Wiklicky", "Herbert", ""], ["Massink", "Mieke", ""]]}, {"id": "1207.0868", "submitter": "EPTCS", "authors": "Roopsha Samanta (UT, Austin)", "title": "Towards Algorithmic Synthesis of Synchronization for Shared-Memory\n  Concurrent Programs", "comments": "In Proceedings SYNT 2012, arXiv:1207.0554", "journal-ref": "EPTCS 84, 2012, pp. 17-32", "doi": "10.4204/EPTCS.84.2", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a framework that takes a concurrent program composed of\nunsynchronized processes, along with a temporal specification of their global\nconcurrent behaviour, and automatically generates a concurrent program with\nsynchronization ensuring correct global behaviour. Our methodology supports\nfinite-state concurrent programs composed of processes that may have local and\nshared variables, may be straight-line or branching programs, may be ongoing or\nterminating, and may have program-initialized or user-initialized variables.\nThe specification language is an extension of propositional Computation Tree\nLogic (CTL) that enables easy specification of safety and liveness properties\nover control and data variables. The framework also supports synthesis of\nsynchronization at different levels of abstraction and granularity.\n", "versions": [{"version": "v1", "created": "Wed, 4 Jul 2012 01:21:54 GMT"}], "update_date": "2012-07-05", "authors_parsed": [["Samanta", "Roopsha", "", "UT, Austin"]]}, {"id": "1207.0869", "submitter": "EPTCS", "authors": "Srinivas Nedunuri (The University of Texas at Austin), William R. Cook\n  (The University of Texas at Austin), Douglas R. Smith (Kestrel Institute)", "title": "Theory and Techniques for Synthesizing a Family of Graph Algorithms", "comments": "In Proceedings SYNT 2012, arXiv:1207.0554", "journal-ref": "EPTCS 84, 2012, pp. 33-46", "doi": "10.4204/EPTCS.84.3", "report-no": null, "categories": "cs.SE cs.AI cs.DS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Although Breadth-First Search (BFS) has several advantages over Depth-First\nSearch (DFS) its prohibitive space requirements have meant that algorithm\ndesigners often pass it over in favor of DFS. To address this shortcoming, we\nintroduce a theory of Efficient BFS (EBFS) along with a simple recursive\nprogram schema for carrying out the search. The theory is based on dominance\nrelations, a long standing technique from the field of search algorithms. We\nshow how the theory can be used to systematically derive solutions to two graph\nalgorithms, namely the Single Source Shortest Path problem and the Minimum\nSpanning Tree problem. The solutions are found by making small systematic\nchanges to the derivation, revealing the connections between the two problems\nwhich are often obscured in textbook presentations of them.\n", "versions": [{"version": "v1", "created": "Wed, 4 Jul 2012 01:22:02 GMT"}], "update_date": "2012-07-05", "authors_parsed": [["Nedunuri", "Srinivas", "", "The University of Texas at Austin"], ["Cook", "William R.", "", "The University of Texas at Austin"], ["Smith", "Douglas R.", "", "Kestrel Institute"]]}, {"id": "1207.1457", "submitter": "Deian Stefan", "authors": "Deian Stefan and Alejandro Russo and John C. Mitchell and David\n  Mazi\\`eres", "title": "Flexible Dynamic Information Flow Control in the Presence of Exceptions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a new, dynamic, floating-label approach to language-based\ninformation flow control. A labeled IO monad, LIO, keeps track of a current\nlabel and permits restricted access to IO functionality. The current label\nfloats to exceed the labels of all data observed and restricts what can be\nmodified. Unlike other language-based work, LIO also bounds the current label\nwith a current clearance that provides a form of discretionary access control.\nComputations may encapsulate and pass around the results of computations with\ndifferent labels. In addition, the LIO monad offers a simple form of labeled\nmutable references and exception handling. We give precise semantics and prove\nconfidentiality and integrity properties of a call-by-name \\lambda-calculus and\nprovide an implementation in Haskell.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2012 20:28:17 GMT"}], "update_date": "2015-03-20", "authors_parsed": [["Stefan", "Deian", ""], ["Russo", "Alejandro", ""], ["Mitchell", "John C.", ""], ["Mazi\u00e8res", "David", ""]]}, {"id": "1207.1813", "submitter": "David Van Horn", "authors": "Christopher Earl, Ilya Sergey, Matthew Might, David Van Horn", "title": "Introspective Pushdown Analysis of Higher-Order Programs", "comments": "Proceedings of the 17th ACM SIGPLAN International Conference on\n  Functional Programming, 2012, ACM", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the static analysis of functional programs, pushdown flow analysis and\nabstract garbage collection skirt just inside the boundaries of soundness and\ndecidability. Alone, each method reduces analysis times and boosts precision by\norders of magnitude. This work illuminates and conquers the theoretical\nchallenges that stand in the way of combining the power of these techniques.\nThe challenge in marrying these techniques is not subtle: computing the\nreachable control states of a pushdown system relies on limiting access during\ntransition to the top of the stack; abstract garbage collection, on the other\nhand, needs full access to the entire stack to compute a root set, just as\nconcrete collection does. \\emph{Introspective} pushdown systems resolve this\nconflict. Introspective pushdown systems provide enough access to the stack to\nallow abstract garbage collection, but they remain restricted enough to compute\ncontrol-state reachability, thereby enabling the sound and precise product of\npushdown analysis and abstract garbage collection. Experiments reveal\nsynergistic interplay between the techniques, and the fusion demonstrates\n\"better-than-both-worlds\" precision.\n", "versions": [{"version": "v1", "created": "Sat, 7 Jul 2012 16:56:04 GMT"}], "update_date": "2012-07-10", "authors_parsed": [["Earl", "Christopher", ""], ["Sergey", "Ilya", ""], ["Might", "Matthew", ""], ["Van Horn", "David", ""]]}, {"id": "1207.2017", "submitter": "Joachim Breitner", "authors": "Joachim Breitner", "title": "dup -- Explicit un-sharing in Haskell", "comments": "9 pages, 9 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose two operations to prevent sharing in Haskell that do not require\nmodifying the data generating code, demonstrate their use and usefulness, and\ncompare them to other approaches to preventing sharing. Our claims are\nsupported by a formal semantics and a prototype implementation.\n", "versions": [{"version": "v1", "created": "Mon, 9 Jul 2012 12:05:25 GMT"}], "update_date": "2012-07-10", "authors_parsed": [["Breitner", "Joachim", ""]]}, {"id": "1207.2300", "submitter": "Muhammad Taimoor Khan", "authors": "Muhammad Taimoor Khan, Wolfgang Schreiner", "title": "Towards the Formal Specification and Verification of Maple Programs", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-642-31374-5_16", "report-no": null, "categories": "cs.MS cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present our ongoing work and initial results on the formal\nspecification and verification of MiniMaple (a substantial subset of Maple with\nslight extensions) programs. The main goal of our work is to find behavioral\nerrors in such programs w.r.t. their specifications by static analysis. This\ntask is more complex for widely used computer algebra languages like Maple as\nthese are fundamentally different from classical languages: they support\nnon-standard types of objects such as symbols, unevaluated expressions and\npolynomials and require abstract computer algebraic concepts and objects such\nas rings and orderings etc. As a starting point we have defined and formalized\na syntax, semantics, type system and specification language for MiniMaple.\n", "versions": [{"version": "v1", "created": "Tue, 10 Jul 2012 10:35:17 GMT"}], "update_date": "2012-07-11", "authors_parsed": [["Khan", "Muhammad Taimoor", ""], ["Schreiner", "Wolfgang", ""]]}, {"id": "1207.2544", "submitter": "Sorav Bansal", "authors": "Sandeep Bindal, Sorav Bansal, Akash Lal", "title": "Variable and Thread Bounding for Systematic Testing of Multithreaded\n  Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Previous approaches to systematic state-space exploration for testing\nmulti-threaded programs have proposed context-bounding and depth-bounding to be\neffective ranking algorithms for testing multithreaded programs. This paper\nproposes two new metrics to rank thread schedules for systematic state-space\nexploration. Our metrics are based on characterization of a concurrency bug\nusing v (the minimum number of distinct variables that need to be involved for\nthe bug to manifest) and t (the minimum number of distinct threads among which\nscheduling constraints are required to manifest the bug). Our algorithm is\nbased on the hypothesis that in practice, most concurrency bugs have low v\n(typically 1- 2) and low t (typically 2-4) characteristics. We iteratively\nexplore the search space of schedules in increasing orders of v and t. We show\nqualitatively and empirically that our algorithm finds common bugs in fewer\nnumber of execution runs, compared with previous approaches. We also show that\nusing v and t improves the lower bounds on the probability of finding bugs\nthrough randomized algorithms.\n  Systematic exploration of schedules requires instrumenting each variable\naccess made by a program, which can be very expensive and severely limits the\napplicability of this approach. Previous work [5, 19] has avoided this problem\nby interposing only on synchronization operations (and ignoring other variable\naccesses). We demonstrate that by using variable bounding (v) and a static\nimprecise alias analysis, we can interpose on all variable accesses (and not\njust synchronization operations) at 10-100x less overhead than previous\napproaches.\n", "versions": [{"version": "v1", "created": "Wed, 11 Jul 2012 06:02:30 GMT"}, {"version": "v2", "created": "Tue, 5 Feb 2013 11:23:51 GMT"}], "update_date": "2013-02-06", "authors_parsed": [["Bindal", "Sandeep", ""], ["Bansal", "Sorav", ""], ["Lal", "Akash", ""]]}, {"id": "1207.3718", "submitter": "Serguei Mokhov", "authors": "Serguei A. Mokhov, Joey Paquet, Mourad Debbabi, Yankui Sun", "title": "MARFCAT: Transitioning to Binary and Larger Data Sets of SATE IV", "comments": "A shorter version submitted for review to 13th IEEE International\n  Working Conference on Source Code Analysis and Manipulation. 39 pages with\n  figures, tables, TOC, and index", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.PL cs.SE stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a second iteration of a machine learning approach to static code\nanalysis and fingerprinting for weaknesses related to security, software\nengineering, and others using the open-source MARF framework and the MARFCAT\napplication based on it for the NIST's SATE IV static analysis tool exposition\nworkshop's data sets that include additional test cases, including new large\nsynthetic cases. To aid detection of weak or vulnerable code, including source\nor binary on different platforms the machine learning approach proved to be\nfast and accurate to for such tasks where other tools are either much slower or\nhave much smaller recall of known vulnerabilities. We use signal and NLP\nprocessing techniques in our approach to accomplish the identification and\nclassification tasks. MARFCAT's design from the beginning in 2010 made is\nindependent of the language being analyzed, source code, bytecode, or binary.\nIn this follow up work with explore some preliminary results in this area. We\nevaluated also additional algorithms that were used to process the data.\n", "versions": [{"version": "v1", "created": "Mon, 16 Jul 2012 16:26:59 GMT"}, {"version": "v2", "created": "Fri, 10 May 2013 19:58:14 GMT"}], "update_date": "2013-05-13", "authors_parsed": [["Mokhov", "Serguei A.", ""], ["Paquet", "Joey", ""], ["Debbabi", "Mourad", ""], ["Sun", "Yankui", ""]]}, {"id": "1207.3937", "submitter": "David Monniaux", "authors": "Julien Henry (VERIMAG - IMAG), David Monniaux (VERIMAG - IMAG),\n  Matthieu Moy (VERIMAG - IMAG)", "title": "PAGAI: a path sensitive static analyzer", "comments": "Tools for Automatic Program AnalysiS (TAPAS 2012), Deauville : France\n  (2012)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe the design and the implementation of PAGAI, a new static analyzer\nworking over the LLVM compiler infrastructure, which computes inductive\ninvariants on the numerical variables of the analyzed program. PAGAI implements\nvarious state-of-the-art algorithms combining abstract interpretation and\ndecision procedures (SMT-solving), focusing on distinction of paths inside the\ncontrol flow graph while avoiding systematic exponential enumerations. It is\nparametric in the abstract domain in use, the iteration algorithm, and the\ndecision procedure. We compared the time and precision of various combinations\nof analysis algorithms and abstract domains, with extensive experiments both on\npersonal benchmarks and widely available GNU programs.\n", "versions": [{"version": "v1", "created": "Tue, 17 Jul 2012 10:35:12 GMT"}], "update_date": "2012-07-18", "authors_parsed": [["Henry", "Julien", "", "VERIMAG - IMAG"], ["Monniaux", "David", "", "VERIMAG - IMAG"], ["Moy", "Matthieu", "", "VERIMAG - IMAG"]]}, {"id": "1207.5592", "submitter": "Ugo Dal Lago", "authors": "Ugo Dal Lago, Barbara Petit", "title": "Linear Dependent Types in a Call-by-Value Scenario (Long Version)", "comments": "22 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linear dependent types allow to precisely capture both the extensional\nbehaviour and the time complexity of lambda terms, when the latter are\nevaluated by Krivine's abstract machine. In this work, we show that the same\nparadigm can be applied to call-by-value evaluation. A system of linear\ndependent types for Plotkin's PCF is introduced, called dlPCFV, whose types\nreflect the complexity of evaluating terms in the so-called CEK machine. dlPCFV\nis proved to be sound, but also relatively complete: every true statement about\nthe extensional and intentional behaviour of terms can be derived, provided all\ntrue index term inequalities can be used as assumptions.\n", "versions": [{"version": "v1", "created": "Tue, 24 Jul 2012 05:35:23 GMT"}], "update_date": "2012-07-25", "authors_parsed": [["Lago", "Ugo Dal", ""], ["Petit", "Barbara", ""]]}, {"id": "1207.6369", "submitter": "Zolt\\'an K\\'asa", "authors": "T. Gregorics", "title": "Concept of the abstract program", "comments": null, "journal-ref": "Acta Universitatis Sapientiae, Informatica, 4, 1 (2012) 7-16", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The aim of this paper is to alter the abstract definition of the program of\nthe theoretical programming model which has been developed at Eotvos Lorand\nUniversity for many years in order to investigate methods that support\ndesigning correct programs. The motivation of this modification was that the\ndynamic properties of programs appear in the model. This new definition of the\nprogram gives a hand to extend the model with the concept of subprograms while\nthe earlier results of the original programming model are preserved.\n", "versions": [{"version": "v1", "created": "Thu, 26 Jul 2012 18:56:59 GMT"}], "update_date": "2016-11-26", "authors_parsed": [["Gregorics", "T.", ""]]}, {"id": "1207.6541", "submitter": "Vadim Zaytsev", "authors": "Vadim Zaytsev", "title": "Guided Grammar Convergence. Full Case Study Report. Generated by\n  converge::Guided", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  This report is meant to be used as auxiliary material for the guided grammar\nconvergence technique proposed earlier as problem-specific improvement in the\ntopic of convergence of grammars. It contains a narrated MegaL megamodel, as\nwell as full results of the guided grammar convergence experiment on the\nFactorial Language, with details about each grammar source packaged in a\nreadable form. All formulae used within this document, are generated\nautomatically by the convergence infrastructure in order to avoid any mistakes.\nThe generator source code and the source of the introduction text can be found\npublicly available in the Software Language Processing Suite repository.\n", "versions": [{"version": "v1", "created": "Fri, 27 Jul 2012 13:40:23 GMT"}], "update_date": "2012-07-30", "authors_parsed": [["Zaytsev", "Vadim", ""]]}, {"id": "1207.6816", "submitter": "Lee Naish", "authors": "Lee Naish", "title": "Transforming floundering into success", "comments": "Number of pages: 24 Number of figures: 9 Number of tables: none", "journal-ref": "Theory and Practice of Logic Programming 14 (2014) 215-238", "doi": "10.1017/S147106841200035X", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show how logic programs with \"delays\" can be transformed to programs\nwithout delays in a way which preserves information concerning floundering\n(also known as deadlock). This allows a declarative (model-theoretic),\nbottom-up or goal independent approach to be used for analysis and debugging of\nproperties related to floundering. We rely on some previously introduced\nrestrictions on delay primitives and a key observation which allows properties\nsuch as groundness to be analysed by approximating the (ground) success set.\nThis paper is to appear in Theory and Practice of Logic Programming (TPLP).\n  Keywords: Floundering, delays, coroutining, program analysis, abstract\ninterpretation, program transformation, declarative debugging\n", "versions": [{"version": "v1", "created": "Mon, 30 Jul 2012 01:11:12 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Naish", "Lee", ""]]}, {"id": "1207.7150", "submitter": "EPTCS", "authors": "Michael Mislove (Tulane University)", "title": "Probabilistic Monads, Domains and Classical Information", "comments": "In Proceedings DCM 2011, arXiv:1207.6821", "journal-ref": "EPTCS 88, 2012, pp. 87-100", "doi": "10.4204/EPTCS.88.8", "report-no": null, "categories": "cs.PL cs.DM cs.IT math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Shannon's classical information theory uses probability theory to analyze\nchannels as mechanisms for information flow. In this paper, we generalize\nresults of Martin, Allwein and Moskowitz for binary channels to show how some\nmore modern tools - probabilistic monads and domain theory in particular - can\nbe used to model classical channels. As initiated Martin, et al., the point of\ndeparture is to consider the family of channels with fixed inputs and outputs,\nrather than trying to analyze channels one at a time. The results show that\ndomain theory has a role to play in the capacity of channels; in particular,\nthe (n x n)-stochastic matrices, which are the classical channels having the\nsame sized input as output, admit a quotient compact ordered space which is a\ndomain, and the capacity map factors through this quotient via a\nScott-continuous map that measures the quotient domain. We also comment on how\nsome of our results relate to recent discoveries about quantum channels and\nfree affine monoids.\n", "versions": [{"version": "v1", "created": "Tue, 31 Jul 2012 02:07:03 GMT"}], "update_date": "2012-08-01", "authors_parsed": [["Mislove", "Michael", "", "Tulane University"]]}]