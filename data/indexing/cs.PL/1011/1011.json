[{"id": "1011.0487", "submitter": "EPTCS", "authors": "Andrew Phillips (Microsoft Research), Matthew Lakin (Microsoft\n  Research), Lo\\\"ic Paulev\\'e (Ecole Centrale de Nantes)", "title": "Stochastic Simulation of Process Calculi for Biology", "comments": "In Proceedings MeCBIC 2010, arXiv:1011.0051", "journal-ref": "EPTCS 40, 2010, pp. 1-5", "doi": "10.4204/EPTCS.40.1", "report-no": null, "categories": "cs.PL cs.CE q-bio.QM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Biological systems typically involve large numbers of components with\ncomplex, highly parallel interactions and intrinsic stochasticity. To model\nthis complexity, numerous programming languages based on process calculi have\nbeen developed, many of which are expressive enough to generate unbounded\nnumbers of molecular species and reactions. As a result of this expressiveness,\nsuch calculi cannot rely on standard reaction-based simulation methods, which\nrequire fixed numbers of species and reactions. Rather than implementing custom\nstochastic simulation algorithms for each process calculus, we propose to use a\ngeneric abstract machine that can be instantiated to a range of process calculi\nand a range of reaction-based simulation algorithms. The abstract machine\nfunctions as a just-in-time compiler, which dynamically updates the set of\npossible reactions and chooses the next reaction in an iterative cycle. In this\nshort paper we give a brief summary of the generic abstract machine, and show\nhow it can be instantiated with the stochastic simulation algorithm known as\nGillespie's Direct Method. We also discuss the wider implications of such an\nabstract machine, and outline how it can be used to simulate multiple calculi\nsimultaneously within a common framework.\n", "versions": [{"version": "v1", "created": "Tue, 2 Nov 2010 01:29:04 GMT"}], "update_date": "2010-11-03", "authors_parsed": [["Phillips", "Andrew", "", "Microsoft Research"], ["Lakin", "Matthew", "", "Microsoft\n  Research"], ["Paulev\u00e9", "Lo\u00efc", "", "Ecole Centrale de Nantes"]]}, {"id": "1011.0494", "submitter": "EPTCS", "authors": "Mario Coppo (Dipartimento di Informatica, Universit\\`a di Torino),\n  Ferruccio Damiani (Dipartimento di Informatica, Universit\\`a di Torino),\n  Maurizio Drocco (Dipartimento di Informatica, Universit\\`a di Torino), Elena\n  Grassi (Dipartimento di Informatica, Universit\\`a di Torino), Eva Sciacca\n  (Dipartimento di Informatica, Universit\\`a di Torino), Salvatore Spinella\n  (Dipartimento di Informatica, Universit\\`a di Torino), Angelo Troina\n  (Dipartimento di Informatica, Universit\\`a di Torino)", "title": "Hybrid Calculus of Wrapped Compartments", "comments": "In Proceedings MeCBIC 2010, arXiv:1011.0051", "journal-ref": "EPTCS 40, 2010, pp. 102-120", "doi": "10.4204/EPTCS.40.8", "report-no": null, "categories": "cs.PL cs.CE q-bio.QM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The modelling and analysis of biological systems has deep roots in\nMathematics, specifically in the field of ordinary differential equations\n(ODEs). Alternative approaches based on formal calculi, often derived from\nprocess algebras or term rewriting systems, provide a quite complementary way\nto analyze the behaviour of biological systems. These calculi allow to cope in\na natural way with notions like compartments and membranes, which are not easy\n(sometimes impossible) to handle with purely numerical approaches, and are\noften based on stochastic simulation methods. Recently, it has also become\nevident that stochastic effects in regulatory networks play a crucial role in\nthe analysis of such systems. Actually, in many situations it is necessary to\nuse stochastic models. For example when the system to be described is based on\nthe interaction of few molecules, when we are at the presence of a chemical\ninstability, or when we want to simulate the functioning of a pool of entities\nwhose compartmentalised structure evolves dynamically. In contrast, stable\nmetabolic networks, involving a large number of reagents, for which the\ncomputational cost of a stochastic simulation becomes an insurmountable\nobstacle, are efficiently modelled with ODEs. In this paper we define a hybrid\nsimulation method, combining the stochastic approach with ODEs, for systems\ndescribed in CWC, a calculus on which we can express the compartmentalisation\nof a biological system whose evolution is defined by a set of rewrite rules.\n", "versions": [{"version": "v1", "created": "Tue, 2 Nov 2010 01:29:51 GMT"}], "update_date": "2010-11-03", "authors_parsed": [["Coppo", "Mario", "", "Dipartimento di Informatica, Universit\u00e0 di Torino"], ["Damiani", "Ferruccio", "", "Dipartimento di Informatica, Universit\u00e0 di Torino"], ["Drocco", "Maurizio", "", "Dipartimento di Informatica, Universit\u00e0 di Torino"], ["Grassi", "Elena", "", "Dipartimento di Informatica, Universit\u00e0 di Torino"], ["Sciacca", "Eva", "", "Dipartimento di Informatica, Universit\u00e0 di Torino"], ["Spinella", "Salvatore", "", "Dipartimento di Informatica, Universit\u00e0 di Torino"], ["Troina", "Angelo", "", "Dipartimento di Informatica, Universit\u00e0 di Torino"]]}, {"id": "1011.1589", "submitter": "Manu Jose Mr", "authors": "Manu Jose and Rupak Majumdar", "title": "Cause Clue Clauses: Error Localization using Maximum Satisfiability", "comments": "The pre-alpha version of the tool can be downloaded from\n  http://bugassist.mpi-sws.org", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Much effort is spent everyday by programmers in trying to reduce long,\nfailing execution traces to the cause of the error. We present a new algorithm\nfor error cause localization based on a reduction to the maximal satisfiability\nproblem (MAX-SAT), which asks what is the maximum number of clauses of a\nBoolean formula that can be simultaneously satisfied by an assignment. At an\nintuitive level, our algorithm takes as input a program and a failing test, and\ncomprises the following three steps. First, using symbolic execution, we encode\na trace of a program as a Boolean trace formula which is satisfiable iff the\ntrace is feasible. Second, for a failing program execution (e.g., one that\nviolates an assertion or a post-condition), we construct an unsatisfiable\nformula by taking the trace formula and additionally asserting that the input\nis the failing test and that the assertion condition does hold at the end.\nThird, using MAX-SAT, we find a maximal set of clauses in this formula that can\nbe satisfied together, and output the complement set as a potential cause of\nthe error. We have implemented our algorithm in a tool called bug-assist for C\nprograms. We demonstrate the surprising effectiveness of the tool on a set of\nbenchmark examples with injected faults, and show that in most cases,\nbug-assist can quickly and precisely isolate the exact few lines of code whose\nchange eliminates the error. We also demonstrate how our algorithm can be\nmodified to automatically suggest fixes for common classes of errors such as\noff-by-one.\n", "versions": [{"version": "v1", "created": "Sat, 6 Nov 2010 21:00:46 GMT"}, {"version": "v2", "created": "Wed, 9 Mar 2011 07:49:59 GMT"}], "update_date": "2011-03-10", "authors_parsed": [["Jose", "Manu", ""], ["Majumdar", "Rupak", ""]]}, {"id": "1011.1783", "submitter": "Benedikt Meurer", "authors": "Benedikt Meurer", "title": "OCamlJIT 2.0 - Faster Objective Caml", "comments": "23 pages, 12 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents the current state of an ongoing research project to\nimprove the performance of the OCaml byte-code interpreter using Just-In-Time\nnative code generation. Our JIT engine OCamlJIT2 currently runs on x86-64\nprocessors, mimicing precisely the behavior of the OCaml virtual machine. Its\ndesign and implementation is described, and performance measures are given.\n", "versions": [{"version": "v1", "created": "Mon, 8 Nov 2010 12:16:37 GMT"}, {"version": "v2", "created": "Wed, 11 May 2011 08:35:02 GMT"}, {"version": "v3", "created": "Tue, 27 Sep 2011 14:12:46 GMT"}], "update_date": "2011-09-28", "authors_parsed": [["Meurer", "Benedikt", ""]]}, {"id": "1011.2488", "submitter": "Luca Tesei", "authors": "Ezio Bartocci, Diletta Romana Cacciagrano, Maria Rita Di Berardini,\n  Emanuela Merelli and Luca Tesei", "title": "Shape Calculus: Timed Operational Semantics and Well-formedness", "comments": "42 pages, 4 figures, extended version of Bartocci, E.; Cacciagrano,\n  D. R.; Di Berardini, M. R.; Merelli, E. & Tesei, L. Timed Operational\n  Semantics and Well-formedness of Shape Calculus. Scientific Annals of\n  Computer Science, 20, 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CE cs.CG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Shape Calculus is a bio-inspired calculus for describing 3D shapes moving\nin a space. A shape forms a 3D process when combined with a behaviour.\nBehaviours are specified with a timed CCS-like process algebra using a notion\nof channel that models naturally binding sites on the surface of shapes.\nProcesses can represent molecules or other mobile objects and can be part of\nnetworks of processes that move simultaneously and interact in a given\ngeometrical space. The calculus embeds collision detection and response,\nbinding of compatible 3D processes and splitting of previously established\nbonds. In this work the full formal timed operational semantics of the calculus\nis provided, together with examples that illustrate the use of the calculus in\na well-known biological scenario. Moreover, a result of well-formedness about\nthe evolution of a given network of well-formed 3D processes is proved.\n", "versions": [{"version": "v1", "created": "Tue, 9 Nov 2010 11:33:59 GMT"}], "update_date": "2010-11-11", "authors_parsed": [["Bartocci", "Ezio", ""], ["Cacciagrano", "Diletta Romana", ""], ["Di Berardini", "Maria Rita", ""], ["Merelli", "Emanuela", ""], ["Tesei", "Luca", ""]]}, {"id": "1011.3256", "submitter": "Zeeshan Ahmed Mr.", "authors": "Zeeshan Ahmed and Saman Majeed", "title": "Towards Increase in Quality by Preprocessed Source Code and Measurement\n  Analysis of Software Applications", "comments": "6 Pages, 9 Figures, 2 Tables", "journal-ref": "IST Transactions on Information Technology- Theory and\n  Applications, Vol. 1, No. 1 (2) ISSN 1913-8822, pp.8-13, 2010", "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  In this paper two intensive problems faced during software application's\nanalysis and development process arose by the software industry are briefly\nconversed i.e. identification of fault proneness and increase in rate of\nvariability in the source code of traditional and product line applications. To\ncontribute in the field of software application analysis and development, and\nto mitigate the aforementioned hurdles, a measurement analysis based approach\nis discussed in this paper. Furthermore, a prototype is developed based on the\nconcepts of discussed approach i.e. analyzing preprocessed source code\ncharacteristics, identifying additional level of complexities using several\nprocedural and object oriented source code measures and visualizing obtained\nresults in different diagrams e.g. bar charts, file maps and graphs etc.\nDeveloped prototype is discussed in detail in this paper and validated by means\nof an experiment as well.\n", "versions": [{"version": "v1", "created": "Sun, 14 Nov 2010 21:48:36 GMT"}], "update_date": "2010-11-16", "authors_parsed": [["Ahmed", "Zeeshan", ""], ["Majeed", "Saman", ""]]}, {"id": "1011.3407", "submitter": "Guido de Caso", "authors": "Guido de Caso, Diego Garbervetsky, Daniel Gor\\'in", "title": "Reducing the Number of Annotations in a Verification-oriented Imperative\n  Language", "comments": "15 pages, 8 figures", "journal-ref": "Symposium on Automatic Program Verification 2009, informal\n  proceedings (http://se.ethz.ch/apv/program.html)", "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automated software verification is a very active field of research which has\nmade enormous progress both in theoretical and practical aspects. Recently, an\nimportant amount of research effort has been put into applying these techniques\non top of mainstream programming languages. These languages typically provide\npowerful features such as reflection, aliasing and polymorphism which are handy\nfor practitioners but, in contrast, make verification a real challenge. In this\nwork we present Pest, a simple experimental, while-style, multiprocedural,\nimperative programming language which was conceived with verifiability as one\nof its main goals. This language forces developers to concurrently think about\nboth the statements needed to implement an algorithm and the assertions\nrequired to prove its correctness. In order to aid programmers, we propose\nseveral techniques to reduce the number and complexity of annotations required\nto successfully verify their programs. In particular, we show that high-level\niteration constructs may alleviate the need for providing complex loop\nannotations.\n", "versions": [{"version": "v1", "created": "Mon, 15 Nov 2010 14:44:59 GMT"}], "update_date": "2010-11-16", "authors_parsed": [["de Caso", "Guido", ""], ["Garbervetsky", "Diego", ""], ["Gor\u00edn", "Daniel", ""]]}, {"id": "1011.4330", "submitter": "Anton Salikhmetov", "authors": "Anton Salikhmetov", "title": "Uniform Memory and Serialization for Lambda Calculus", "comments": "24 pages, in Russian", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces a special type of systems, defines their properties,\nand then demonstrates that a reduction machine for pure untyped extensional\nlambda calculus can be implemented as a system of the introduced type.\nSpecifically, we discuss uniform memory as a special kind of graphs and real\ntime operation of state machines that use the uniform memory as their state.\nAlso, we consider a special case of serialization, the latter being useful for\nthe mechanism that compares results during computation, not after the\ncomputation is done. However, we start with detailed explanation of our\nmotivation for this work.\n", "versions": [{"version": "v1", "created": "Tue, 16 Nov 2010 21:48:40 GMT"}], "update_date": "2010-11-22", "authors_parsed": [["Salikhmetov", "Anton", ""]]}, {"id": "1011.4558", "submitter": "Gabriel Kerneis", "authors": "Gabriel Kerneis (PPS), Juliusz Chroboczek (PPS)", "title": "Continuation-Passing C: compiling threads to events through\n  continuations", "comments": "Higher-Order and Symbolic Computation (2012). arXiv admin note:\n  substantial text overlap with arXiv:1202.3247", "journal-ref": "Higher-Order and Symbolic Computation 24(3): 239-279 (2011)", "doi": "10.1007/s10990-012-9084-5", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we introduce Continuation Passing C (CPC), a programming\nlanguage for concurrent systems in which native and cooperative threads are\nunified and presented to the programmer as a single abstraction. The CPC\ncompiler uses a compilation technique, based on the CPS transform, that yields\nefficient code and an extremely lightweight representation for contexts. We\nprovide a proof of the correctness of our compilation scheme. We show in\nparticular that lambda-lifting, a common compilation technique for functional\nlanguages, is also correct in an imperative language like C, under some\nconditions enforced by the CPC compiler. The current CPC compiler is mature\nenough to write substantial programs such as Hekate, a highly concurrent\nBitTorrent seeder. Our benchmark results show that CPC is as efficient, while\nusing significantly less space, as the most efficient thread libraries\navailable.\n", "versions": [{"version": "v1", "created": "Sat, 20 Nov 2010 07:35:14 GMT"}, {"version": "v2", "created": "Mon, 20 Feb 2012 08:11:11 GMT"}, {"version": "v3", "created": "Thu, 5 Jul 2012 19:40:57 GMT"}], "update_date": "2012-11-15", "authors_parsed": [["Kerneis", "Gabriel", "", "PPS"], ["Chroboczek", "Juliusz", "", "PPS"]]}, {"id": "1011.5332", "submitter": "Jan Wielemaker", "authors": "Jan Wielemaker and Tom Schrijvers and Markus Triska and Torbj\\\"orn\n  Lager", "title": "SWI-Prolog", "comments": "30 pages, 6 figures, 1 table. To appear in Theory and Practice of\n  Logic Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  SWI-Prolog is neither a commercial Prolog system nor a purely academic\nenterprise, but increasingly a community project. The core system has been\nshaped to its current form while being used as a tool for building research\nprototypes, primarily for \\textit{knowledge-intensive} and \\textit{interactive}\nsystems. Community contributions have added several interfaces and the\nconstraint (CLP) libraries. Commercial involvement has created the initial\ngarbage collector, added several interfaces and two development tools: PlDoc (a\nliterate programming documentation system) and PlUnit (a unit testing\nenvironment).\n  In this article we present SWI-Prolog as an integrating tool, supporting a\nwide range of ideas developed in the Prolog community and acting as glue\nbetween \\textit{foreign} resources. This article itself is the glue between\ntechnical articles on SWI-Prolog, providing context and experience in applying\nthem over a longer period.\n", "versions": [{"version": "v1", "created": "Wed, 24 Nov 2010 10:28:56 GMT"}], "update_date": "2010-11-26", "authors_parsed": [["Wielemaker", "Jan", ""], ["Schrijvers", "Tom", ""], ["Triska", "Markus", ""], ["Lager", "Torbj\u00f6rn", ""]]}, {"id": "1011.5640", "submitter": "Mats Carlsson", "authors": "Mats Carlsson and Per Mildner", "title": "SICStus Prolog -- the first 25 years", "comments": "To appear in Theory and Practice of Logic Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  SICStus Prolog has evolved for nearly 25 years. This is an appropriate point\nin time for revisiting the main language and design decisions, and try to\ndistill some lessons. SICStus Prolog was conceived in a context of multiple,\nconflicting Prolog dialect camps and a fledgling standardization effort. We\nreflect on the impact of this effort and role model implementations on our\ndevelopment. After summarizing the development history, we give a guided tour\nof the system anatomy, exposing some designs that were not published before. We\ngive an overview of our new interactive development environment, and describe a\nsample of key applications. Finally, we try to identify key good and not so\ngood design decisions.\n", "versions": [{"version": "v1", "created": "Thu, 25 Nov 2010 15:11:42 GMT"}], "update_date": "2010-11-29", "authors_parsed": [["Carlsson", "Mats", ""], ["Mildner", "Per", ""]]}, {"id": "1011.6047", "submitter": "Sebastian Nanz", "authors": "Sebastian Nanz, Faraz Torshizi, Michela Pedroni, Bertrand Meyer", "title": "A Comparative Study of the Usability of Two Object-oriented Concurrent\n  Programming Languages", "comments": null, "journal-ref": "Information and Software Technology, 55(7):1304-1315, Elsevier,\n  2013", "doi": "10.1016/j.infsof.2012.08.013", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Concurrency has been rapidly gaining importance in general-purpose computing,\ncaused by the recent turn towards multicore processing architectures. As a\nresult, an increasing number of developers have to learn to write concurrent\nprograms, a task that is known to be hard even for the expert. Language\ndesigners are therefore working on languages that promise to make concurrent\nprogramming \"easier\" than using traditional thread libraries. However, the\nclaim that a new language is more usable than another cannot be supported by\npurely theoretical considerations, but calls for empirical studies. In this\npaper, we present the design of a study to compare concurrent programming\nlanguages with respect to comprehending and debugging existing programs and\nwriting correct new programs. A critical challenge for such a study is avoiding\nthe bias that might be introduced during the training phase and when\ninterpreting participants' solutions. We address these issues by the use of\nself-study material and an evaluation scheme that exposes any subjective\ndecisions of the corrector, or eliminates them altogether. We apply our design\nto a comparison of two object-oriented languages for concurrency, multithreaded\nJava and SCOOP (Simple Concurrent Object-Oriented Programming), in an academic\nsetting. We obtain results in favor of SCOOP even though the study participants\nhad previous training in Java Threads.\n", "versions": [{"version": "v1", "created": "Sun, 28 Nov 2010 14:49:14 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Nanz", "Sebastian", ""], ["Torshizi", "Faraz", ""], ["Pedroni", "Michela", ""], ["Meyer", "Bertrand", ""]]}, {"id": "1011.6223", "submitter": "Benedikt Meurer", "authors": "Benedikt Meurer", "title": "Just-In-Time compilation of OCaml byte-code", "comments": "15 pages, 6 figures, 3 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents various improvements that were applied to OCamlJIT2, a\nJust-In-Time compiler for the OCaml byte-code virtual machine. OCamlJIT2\ncurrently runs on various Unix-like systems with x86 or x86-64 processors. The\nimprovements, including the new x86 port, are described in detail, and\nperformance measures are given, including a direct comparison of OCamlJIT2 to\nOCamlJIT.\n", "versions": [{"version": "v1", "created": "Mon, 29 Nov 2010 13:24:11 GMT"}, {"version": "v2", "created": "Wed, 11 May 2011 08:37:18 GMT"}, {"version": "v3", "created": "Tue, 27 Sep 2011 14:14:21 GMT"}], "update_date": "2011-09-28", "authors_parsed": [["Meurer", "Benedikt", ""]]}, {"id": "1011.6431", "submitter": "EPTCS", "authors": "Ugo Dal Lago (INRIA and University of Bologna), Simone Martini (INRIA\n  and University of Bologna), Davide Sangiorgi (INRIA and University of\n  Bologna)", "title": "Light Logics and Higher-Order Processes", "comments": "In Proceedings EXPRESS'10, arXiv:1011.6012", "journal-ref": "Math. Struct. Comp. Sci. 26 (2016) 969-992", "doi": "10.1017/S0960129514000310", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that the techniques for resource control that have been developed in\nthe so-called \"light logics\" can be fruitfully applied also to process\nalgebras. In particular, we present a restriction of Higher-Order pi-calculus\ninspired by Soft Linear Logic. We prove that any soft process terminates in\npolynomial time. We argue that the class of soft processes may be naturally\nenlarged so that interesting processes are expressible, still maintaining the\npolynomial bound on executions.\n", "versions": [{"version": "v1", "created": "Tue, 30 Nov 2010 01:37:44 GMT"}], "update_date": "2019-02-20", "authors_parsed": [["Lago", "Ugo Dal", "", "INRIA and University of Bologna"], ["Martini", "Simone", "", "INRIA\n  and University of Bologna"], ["Sangiorgi", "Davide", "", "INRIA and University of\n  Bologna"]]}, {"id": "1011.6436", "submitter": "EPTCS", "authors": "Lasse Nielsen (DIKU, University of Copenhagen), Nobuko Yoshida\n  (Imperial College London), Kohei Honda (Queen Mary, University of London)", "title": "Multiparty Symmetric Sum Types", "comments": "In Proceedings EXPRESS'10, arXiv:1011.6012", "journal-ref": "EPTCS 41, 2010, pp. 121-135", "doi": "10.4204/EPTCS.41.9", "report-no": null, "categories": "cs.DC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces a new theory of multiparty session types based on\nsymmetric sum types, by which we can type non-deterministic orchestration\nchoice behaviours. While the original branching type in session types can\nrepresent a choice made by a single participant and accepted by others\ndetermining how the session proceeds, the symmetric sum type represents a\nchoice made by agreement among all the participants of a session. Such\nbehaviour can be found in many practical systems, including collaborative\nworkflow in healthcare systems for clinical practice guidelines (CPGs).\nProcesses using the symmetric sums can be embedded into the original branching\ntypes using conductor processes. We show that this type-driven embedding\npreserves typability, satisfies semantic soundness and completeness, and meets\nthe encodability criteria adapted to the typed setting. The theory leads to an\nefficient implementation of a prototypical tool for CPGs which automatically\ntranslates the original CPG specifications from a representation called the\nProcess Matrix to symmetric sum types, type checks programs and executes them.\n", "versions": [{"version": "v1", "created": "Tue, 30 Nov 2010 01:38:11 GMT"}], "update_date": "2010-12-01", "authors_parsed": [["Nielsen", "Lasse", "", "DIKU, University of Copenhagen"], ["Yoshida", "Nobuko", "", "Imperial College London"], ["Honda", "Kohei", "", "Queen Mary, University of London"]]}]