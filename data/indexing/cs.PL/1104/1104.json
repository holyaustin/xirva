[{"id": "1104.0193", "submitter": "Ugo Dal Lago", "authors": "Ugo Dal Lago (Universit\\`a di Bologna), Marco Gaboardi (Universit\\`a\n  di Bologna and University of Pennsylvania)", "title": "Linear Dependent Types and Relative Completeness", "comments": "44 pages, 1 figure", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 4 (October\n  23, 2012) lmcs:974", "doi": "10.2168/LMCS-8(4:11)2012", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A system of linear dependent types for the lambda calculus with full\nhigher-order recursion, called dlPCF, is introduced and proved sound and\nrelatively complete. Completeness holds in a strong sense: dlPCF is not only\nable to precisely capture the functional behaviour of PCF programs (i.e. how\nthe output relates to the input) but also some of their intensional properties,\nnamely the complexity of evaluating them with Krivine's Machine. dlPCF is\ndesigned around dependent types and linear logic and is parametrized on the\nunderlying language of index terms, which can be tuned so as to sacrifice\ncompleteness for tractability.\n", "versions": [{"version": "v1", "created": "Fri, 1 Apr 2011 15:07:28 GMT"}, {"version": "v2", "created": "Tue, 3 Jan 2012 09:24:17 GMT"}, {"version": "v3", "created": "Thu, 4 Oct 2012 09:19:50 GMT"}, {"version": "v4", "created": "Wed, 10 Oct 2012 07:08:26 GMT"}, {"version": "v5", "created": "Fri, 19 Oct 2012 23:55:13 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Lago", "Ugo Dal", "", "Universit\u00e0 di Bologna"], ["Gaboardi", "Marco", "", "Universit\u00e0\n  di Bologna and University of Pennsylvania"]]}, {"id": "1104.0195", "submitter": "Ugo Dal Lago", "authors": "Ugo Dal Lago, Margherita Zorzi", "title": "Probabilistic Operational Semantics for the Lambda Calculus", "comments": "35 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Probabilistic operational semantics for a nondeterministic extension of pure\nlambda calculus is studied. In this semantics, a term evaluates to a (finite or\ninfinite) distribution of values. Small-step and big-step semantics are both\ninductively and coinductively defined. Moreover, small-step and big-step\nsemantics are shown to produce identical outcomes, both in call-by- value and\nin call-by-name. Plotkin's CPS translation is extended to accommodate the\nchoice operator and shown correct with respect to the operational semantics.\nFinally, the expressive power of the obtained system is studied: the calculus\nis shown to be sound and complete with respect to computable probability\ndistributions.\n", "versions": [{"version": "v1", "created": "Fri, 1 Apr 2011 15:14:18 GMT"}, {"version": "v2", "created": "Mon, 27 Jun 2011 18:47:46 GMT"}], "update_date": "2011-06-28", "authors_parsed": [["Lago", "Ugo Dal", ""], ["Zorzi", "Margherita", ""]]}, {"id": "1104.0497", "submitter": "Arnab Charaborty", "authors": "Arnab Chakraborty", "title": "QuECT: A New Quantum Programming Paradigm", "comments": "18 pages, 14 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Quantum computation constitutes a rapidly expanding subfield of computer\nscience. Development quantum algorithms is facilitated by the availability of\nefficient quantum programming languages, and a plethora of approaches has been\nalready suggested in the literature, ranging from GUI-based simple tools to\nelaborate standalone programming languages. In this paper we propose a novel\nparadigm called Quantum Embeddable Circuit Technique (QuECT) that allows a\nprogrammer to embed a circuit diagram in a classical \"host\" language. The\nparadigm can be implemented in any modern classical language. A prototype has\nbeen developed by the author using Java.\n", "versions": [{"version": "v1", "created": "Mon, 4 Apr 2011 08:49:18 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Chakraborty", "Arnab", ""]]}, {"id": "1104.0644", "submitter": "Mohamed El-Zawawy", "authors": "Mohamed A. El-Zawawy", "title": "Program Optimization Based Pointer Analysis and Live Stack-Heap Analysis", "comments": "10 pages, 7 figures", "journal-ref": "International Journal of Computer Science Issues, Volume 8, Issue\n  2, pages 98-107, March 2011", "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present type systems for flow-sensitive pointer analysis,\nlive stack-heap (variables) analysis, and program optimization. The type system\nfor live stack-heap analysis is an enrichment of that for pointer analysis; the\nenrichment has the form of a second component being added to types of the\nlatter system. Results of pointer analysis are proved useful via their use in\nthe type system for live stack-heap analysis. The type system for program\noptimization is also an augmentation of that for live stack-heap analysis, but\nthe augmentation takes the form of a transformation component being added to\ninference rules of the latter system. The form of program optimization being\nachieved is that of dead-code elimination. A form of program correction may\nresult indirectly from eliminating faulty code (causing the program to abort)\nthat is dead. Therefore program optimization can result in program correction.\nOur type systems have the advantage of being compositional and\nrelatively-simply structured.\n  The novelty of our work comes from the fact that our type system for program\noptimization associates the optimized version of a program with a justification\n(in the form of a type derivation) for the optimization. This justification is\npretty much appreciated in many research areas like certified code\n(proof-carrying code) which is the motivation of this work\n", "versions": [{"version": "v1", "created": "Mon, 4 Apr 2011 18:14:52 GMT"}], "update_date": "2011-04-05", "authors_parsed": [["El-Zawawy", "Mohamed A.", ""]]}, {"id": "1104.1351", "submitter": "Guido Salvaneschi", "authors": "Guido Salvaneschi, Carlo Ghezzi and Matteo Pradella", "title": "JavaCtx: Seamless Toolchain Integration for Context-Oriented Programming", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Context-oriented programming is an emerging paradigm addressing at the\nlanguage level the issue of dynamic software adaptation and modularization of\ncontext-specific concerns. In this paper we propose JavaCtx, a tool which\nemploys coding conventions to generate the context-aware semantics for Java\nprograms and subsequently weave it into the application. The contribution of\nJavaCtx is twofold: the design of a set of coding conventions which allow to\nwrite context-oriented software in plain Java and the concept of\ncontext-oriented semantics injection, which allows to introduce the\ncontext-aware semantics without a source-to-source compilations process which\ndisrupts the structure of the code. Both these points allow to seamless\nintegrate JavaCtx in the existing industrial-strength appliances and by far\nease the development of context-oriented software.\n", "versions": [{"version": "v1", "created": "Thu, 7 Apr 2011 15:12:56 GMT"}], "update_date": "2011-04-08", "authors_parsed": [["Salvaneschi", "Guido", ""], ["Ghezzi", "Carlo", ""], ["Pradella", "Matteo", ""]]}, {"id": "1104.1729", "submitter": "Georg Hager", "authors": "Klaus Iglberger, Georg Hager, Jan Treibig, Ulrich Ruede", "title": "Expression Templates Revisited: A Performance Analysis of the Current ET\n  Methodology", "comments": "16 pages, 7 figures", "journal-ref": "SIAM Journal on Scientific Computing 34(2), C42-C69 (2012)", "doi": "10.1137/110830125", "report-no": null, "categories": "cs.PF cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the last decade, Expression Templates (ET) have gained a reputation as an\nefficient performance optimization tool for C++ codes. This reputation builds\non several ET-based linear algebra frameworks focused on combining both elegant\nand high-performance C++ code. However, on closer examination the assumption\nthat ETs are a performance optimization technique cannot be maintained. In this\npaper we demonstrate and explain the inability of current ET-based frameworks\nto deliver high performance for dense and sparse linear algebra operations, and\nintroduce a new \"smart\" ET implementation that truly allows the combination of\nhigh performance code with the elegance and maintainability of a\ndomain-specific language.\n", "versions": [{"version": "v1", "created": "Sat, 9 Apr 2011 17:50:30 GMT"}], "update_date": "2012-08-15", "authors_parsed": [["Iglberger", "Klaus", ""], ["Hager", "Georg", ""], ["Treibig", "Jan", ""], ["Ruede", "Ulrich", ""]]}, {"id": "1104.2293", "submitter": "Camil Demetrescu", "authors": "Camil Demetrescu, Irene Finocchi, Andrea Ribichini", "title": "Reactive Imperative Programming with Dataflow Constraints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dataflow languages provide natural support for specifying constraints between\nobjects in dynamic applications, where programs need to react efficiently to\nchanges of their environment. Researchers have long investigated how to take\nadvantage of dataflow constraints by embedding them into procedural languages.\nPrevious mixed imperative/dataflow systems, however, require syntactic\nextensions or libraries of ad hoc data types for binding the imperative program\nto the dataflow solver. In this paper we propose a novel approach that smoothly\ncombines the two paradigms without placing undue burden on the programmer. In\nour framework, programmers can define ordinary commands of the host imperative\nlanguage that enforce constraints between objects stored in \"reactive\" memory\nlocations. Reactive objects can be of any legal type in the host language,\nincluding primitive data types, pointers, arrays, and structures. Constraints\nare automatically re-executed every time their input memory locations change,\nletting a program behave like a spreadsheet where the values of some variables\ndepend upon the values of other variables. The constraint solving mechanism is\nhandled transparently by altering the semantics of elementary operations of the\nhost language for reading and modifying objects. We provide a formal semantics\nand describe a concrete embodiment of our technique into C/C++, showing how to\nimplement it efficiently in conventional platforms using off-the-shelf\ncompilers. We discuss relevant applications to reactive scenarios, including\nincremental computation, observer design pattern, and data structure repair.\nThe performance of our implementation is compared to ad hoc problem-specific\nchange propagation algorithms and to language-centric approaches such as\nself-adjusting computation and subject/observer communication mechanisms,\nshowing that the proposed approach is efficient in practice.\n", "versions": [{"version": "v1", "created": "Tue, 12 Apr 2011 18:31:17 GMT"}], "update_date": "2011-04-13", "authors_parsed": [["Demetrescu", "Camil", ""], ["Finocchi", "Irene", ""], ["Ribichini", "Andrea", ""]]}, {"id": "1104.2681", "submitter": "Samuel Mimram", "authors": "David Baelde (LIX), Romain Beauxis (LIX, INRIA Saclay - Ile de\n  France), Samuel Mimram (CEA LIST)", "title": "Liquidsoap: a High-Level Programming Language for Multimedia Streaming", "comments": null, "journal-ref": "SOFSEM 2011: Theory and Practice of Computer Science 6543 (2011)\n  99-110", "doi": "10.1007/978-3-642-18381-2_8", "report-no": null, "categories": "cs.PL cs.MM cs.SD", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Generating multimedia streams, such as in a netradio, is a task which is\ncomplex and difficult to adapt to every users' needs. We introduce a novel\napproach in order to achieve it, based on a dedicated high-level functional\nprogramming language, called Liquidsoap, for generating, manipulating and\nbroadcasting multimedia streams. Unlike traditional approaches, which are based\non configuration files or static graphical interfaces, it also allows the user\nto build complex and highly customized systems. This language is based on a\nmodel for streams and contains operators and constructions, which make it\nadapted to the generation of streams. The interpreter of the language also\nensures many properties concerning the good execution of the stream generation.\n", "versions": [{"version": "v1", "created": "Thu, 14 Apr 2011 07:01:54 GMT"}], "update_date": "2011-04-15", "authors_parsed": [["Baelde", "David", "", "LIX"], ["Beauxis", "Romain", "", "LIX, INRIA Saclay - Ile de\n  France"], ["Mimram", "Samuel", "", "CEA LIST"]]}, {"id": "1104.3116", "submitter": "Eli Sennesh", "authors": "Eli Gottlieb", "title": "Simple, Decidable Type Inference with Subtyping", "comments": "This paper has been withdrawn, due to abundant errors in this version\n  of the paper, and due to ongoing efforts to improve the paper and bring it to\n  real publication", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We demonstrate a method to infer polymorphically principal and\nsubtyping-minimal types for an ML-like core language by assigning ranges within\na lattice to type variables. We demonstrate the termination and completeness of\nthis algorithm, and proceed to show that it solves a broad special-case of the\ngenerally-undecidable semi-unification problem. Our procedure requires no type\nannotations, leaves no subtyping constraints in the inferred types, and\nproduces no proof obligations. We demonstrate the practical utility of our\ntechnique by showing a type-preserving encoding of Featherweight Java into the\nexpression calculus over which we infer types.\n", "versions": [{"version": "v1", "created": "Fri, 15 Apr 2011 17:27:30 GMT"}, {"version": "v2", "created": "Thu, 24 Jan 2013 14:35:59 GMT"}, {"version": "v3", "created": "Tue, 13 Aug 2013 00:38:33 GMT"}], "update_date": "2013-08-14", "authors_parsed": [["Gottlieb", "Eli", ""]]}, {"id": "1104.4306", "submitter": "Pavol Cerny", "authors": "Pavol Cerny and Krishnendu Chatterjee and Thomas Henzinger and Arjun\n  Radhakrishna and Rohit Singh", "title": "Quantitative Synthesis for Concurrent Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an algorithmic method for the quantitative, performance-aware\nsynthesis of concurrent programs. The input consists of a nondeterministic\npartial program and of a parametric performance model. The nondeterminism\nallows the programmer to omit which (if any) synchronization construct is used\nat a particular program location. The performance model, specified as a\nweighted automaton, can capture system architectures by assigning different\ncosts to actions such as locking, context switching, and memory and cache\naccesses. The quantitative synthesis problem is to automatically resolve the\nnondeterminism of the partial program so that both correctness is guaranteed\nand performance is optimal. As is standard for shared memory concurrency,\ncorrectness is formalized \"specification free\", in particular as race freedom\nor deadlock freedom. For worst-case (average-case) performance, we show that\nthe problem can be reduced to 2-player graph games (with probabilistic\ntransitions) with quantitative objectives. While we show, using game-theoretic\nmethods, that the synthesis problem is NEXP-complete, we present an algorithmic\nmethod and an implementation that works efficiently for concurrent programs and\nperformance models of practical interest. We have implemented a prototype tool\nand used it to synthesize finite-state concurrent programs that exhibit\ndifferent programming patterns, for several performance models representing\ndifferent architectures.\n", "versions": [{"version": "v1", "created": "Thu, 21 Apr 2011 16:30:11 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Cerny", "Pavol", ""], ["Chatterjee", "Krishnendu", ""], ["Henzinger", "Thomas", ""], ["Radhakrishna", "Arjun", ""], ["Singh", "Rohit", ""]]}, {"id": "1104.5133", "submitter": "Jeroen Janssen", "authors": "Jeroen Janssen, Steven Schockaert, Dirk Vermeir and Martine De Cock", "title": "Reducing Fuzzy Answer Set Programming to Model Finding in Fuzzy Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In recent years answer set programming has been extended to deal with\nmulti-valued predicates. The resulting formalisms allows for the modeling of\ncontinuous problems as elegantly as ASP allows for the modeling of discrete\nproblems, by combining the stable model semantics underlying ASP with fuzzy\nlogics. However, contrary to the case of classical ASP where many efficient\nsolvers have been constructed, to date there is no efficient fuzzy answer set\nprogramming solver. A well-known technique for classical ASP consists of\ntranslating an ASP program $P$ to a propositional theory whose models exactly\ncorrespond to the answer sets of $P$. In this paper, we show how this idea can\nbe extended to fuzzy ASP, paving the way to implement efficient fuzzy ASP\nsolvers that can take advantage of existing fuzzy logic reasoners. To appear in\nTheory and Practice of Logic Programming (TPLP).\n", "versions": [{"version": "v1", "created": "Wed, 27 Apr 2011 13:04:09 GMT"}], "update_date": "2011-04-28", "authors_parsed": [["Janssen", "Jeroen", ""], ["Schockaert", "Steven", ""], ["Vermeir", "Dirk", ""], ["De Cock", "Martine", ""]]}]