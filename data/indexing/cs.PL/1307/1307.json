[{"id": "1307.0679", "submitter": "Maurizio Gabbrielli", "authors": "Maurizio Gabbrielli, Maria Chiara Meo, Paolo Tacchella and Herbert\n  Wiklicky", "title": "Unfolding for CHR programs", "comments": "49 pages", "journal-ref": "Theory and Practice of Logic Programming 15 (2015) 264-311", "doi": "10.1017/S1471068413000288", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program transformation is an appealing technique which allows to improve\nrun-time efficiency, space-consumption, and more generally to optimize a given\nprogram. Essentially, it consists of a sequence of syntactic program\nmanipulations which preserves some kind of semantic equivalence. Unfolding is\none of the basic operations which is used by most program transformation\nsystems and which consists in the replacement of a procedure call by its\ndefinition. While there is a large body of literature on transformation and\nunfolding of sequential programs, very few papers have addressed this issue for\nconcurrent languages.\n  This paper defines an unfolding system for CHR programs. We define an\nunfolding rule, show its correctness and discuss some conditions which can be\nused to delete an unfolded rule while preserving the program meaning. We also\nprove that, under some suitable conditions, confluence and termination are\npreserved by the above transformation.\n  To appear in Theory and Practice of Logic Programming (TPLP)\n", "versions": [{"version": "v1", "created": "Tue, 2 Jul 2013 10:55:24 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Gabbrielli", "Maurizio", ""], ["Meo", "Maria Chiara", ""], ["Tacchella", "Paolo", ""], ["Wiklicky", "Herbert", ""]]}, {"id": "1307.1088", "submitter": "Mohammed Faris natheer", "authors": "Mohammed F. Nather, Dr. Nada N. Saleem", "title": "Suggest an Aspect-Oriented Design Approach for UML Communication Diagram", "comments": "6 pager,7 figures,journal", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  More and more works are done on the design of the Unified Modeling Language\n(UML) which is designed to help us for modeling effective object oriented\nsoftware, Existing Object-Oriented design methods are not mature enough to\ncapture non-functional requirement such as concurrency, fault tolerance,\ndistribution and persistence of a software approach. Our approach proposed to\nuse aspect-oriented software development (AOSD) mechanisms to solve the issues\nfor interactions of the communication diagram in UML that support only the\nObject-Oriented mechanisms,thus AOSD allow to design programs that are out of\nreach of strict Object-Orientation and could possibly improve the structures\nand implementations.\n", "versions": [{"version": "v1", "created": "Wed, 3 Jul 2013 17:37:40 GMT"}], "update_date": "2013-07-04", "authors_parsed": [["Nather", "Mohammed F.", ""], ["Saleem", "Dr. Nada N.", ""]]}, {"id": "1307.1738", "submitter": "Yuting Wang", "authors": "Yuting Wang, Gopalan Nadathur", "title": "Towards Extracting Explicit Proofs from Totality Checking in Twelf", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Edinburgh Logical Framework (LF) is a dependently type lambda calculus\nthat can be used to encode formal systems. The versatility of LF allows\nspecifications to be constructed also about the encoded systems. The Twelf\nsystem exploits the correspondence between formulas and types to give\nspecifications in LF a logic programming interpretation. By interpreting\nparticular arguments as input and others as output, specifications can be seen\nas describing non-deterministic functions. If particular such functions can be\nshown to be total, they represent constructive proofs of meta-theorems of the\nencoded systems. Twelf provides a suite of tools for establishing totality.\nHowever, all the resulting proofs of meta-theorems are implicit: Twelf's\ntotality checking does not yield a certificate that can be given to a proof\nchecker. We begin the process here of making these proofs explicit. We treat\nthe restricted situation in Twelf where context definitions (regular worlds)\nand lemmas are not used. In this setting we describe and prove correct a\ntranslation of the steps in totality checking into an actual proof in the\ncompanion logic M2. We intend in the long term to extend our translation to all\nof Twelf and to use this work as the basis for producing proofs in the related\nAbella system.\n", "versions": [{"version": "v1", "created": "Fri, 5 Jul 2013 23:30:42 GMT"}], "update_date": "2013-07-09", "authors_parsed": [["Wang", "Yuting", ""], ["Nadathur", "Gopalan", ""]]}, {"id": "1307.2328", "submitter": "Christian Sternagel", "authors": "Bertram Felgenhauer and Martin Avanzini and Christian Sternagel", "title": "A Haskell Library for Term Rewriting", "comments": "1st International Workshop on Haskell And Rewriting Techniques, HART\n  2013, 6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a Haskell library for first-order term rewriting covering basic\noperations on positions, terms, contexts, substitutions and rewrite rules. This\neffort is motivated by the increasing number of term rewriting tools that are\nwritten in Haskell.\n", "versions": [{"version": "v1", "created": "Tue, 9 Jul 2013 03:45:41 GMT"}], "update_date": "2013-07-10", "authors_parsed": [["Felgenhauer", "Bertram", ""], ["Avanzini", "Martin", ""], ["Sternagel", "Christian", ""]]}, {"id": "1307.2473", "submitter": "Dan Ghica", "authors": "Dan R. Ghica and Alex Smith", "title": "From bounded affine types to automatic timing analysis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bounded linear types have proved to be useful for automated resource analysis\nand control in functional programming languages. In this paper we introduce an\naffine bounded linear typing discipline on a general notion of resource which\ncan be modeled in a semiring. For this type system we provide both a general\ntype-inference procedure, parameterized by the decision procedure of the\nsemiring equational theory, and a (coherent) categorical semantics. This is a\nvery useful type-theoretic and denotational framework for many applications to\nresource-sensitive compilation, and it represents a generalization of several\nexisting type systems. As a non-trivial instance, motivated by our ongoing work\non hardware compilation, we present a complex new application to calculating\nand controlling timing of execution in a (recursion-free) higher-order\nfunctional programming language with local store.\n", "versions": [{"version": "v1", "created": "Tue, 9 Jul 2013 14:29:24 GMT"}], "update_date": "2013-07-10", "authors_parsed": [["Ghica", "Dan R.", ""], ["Smith", "Alex", ""]]}, {"id": "1307.2964", "submitter": "Xin Li", "authors": "Xin Li, Hua Vy Le Thanh", "title": "Generating Stack-based Access Control Policies", "comments": "18 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The stack-based access control mechanism plays a fundamental role in the\nsecurity architecture of Java and Microsoft CLR (common language runtime). It\nis enforced at runtime by inspecting methods in the current call stack for\ngranted permissions before the program performs safety-critical operations.\nAlthough stack inspection is well studied, there is relatively little work on\nautomated generation of access control policies, and most existing work on\ninferring security policies assume the permissions to be checked at stack\ninspection points are known beforehand. Practiced approaches to generating\naccess control policies are still manually done by developers based on\ndomain-specific knowledges and trial-and-error testing. In this paper, we\npresent a systematic approach to automated generation of access control\npolicies for Java programs that necessarily ensure the program to pass stack\ninspection. The techniques are abstract interpretation based context-sensitive\nstatic program analyses. Our analysis models the program by combining a\ncontext-sensitive call graph with a dependency graph. We are hereby able to\nprecisely identify permission requirements at stack inspection points, which\nare usually ignored in previous study.\n", "versions": [{"version": "v1", "created": "Thu, 11 Jul 2013 03:21:25 GMT"}, {"version": "v2", "created": "Sun, 13 Oct 2013 03:47:41 GMT"}], "update_date": "2013-10-15", "authors_parsed": [["Li", "Xin", ""], ["Thanh", "Hua Vy Le", ""]]}, {"id": "1307.3189", "submitter": "Bertrand Meyer", "authors": "Alexander Kogtenkov, Bertrand Meyer and Sergey Velder", "title": "Alias and Change Calculi, Applied to Frame Inference", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Alias analysis, which determines whether two expressions in a program may\nreference to the same object, has many potential applications in program\nconstruction and verification. We have developed a theory for alias analysis,\nthe \"alias calculus\", implemented its application to an object-oriented\nlanguage, and integrated the result into a modern IDE. The calculus has a\nhigher level of precision than many existing alias analysis techniques.\n  One of the principal applications is to allow automatic change analysis,\nwhich leads to inferring \"modifies clauses\", providing a significant advance\ntowards addressing the Frame Problem. Experiments were able to infer the\n\"modifies\" clauses of an existing formally specified library. Other\napplications, in particular to concurrent programming, also appear possible.\n  The article presents the calculus, the application to frame analysis\nincluding ex-perimental results, and other projected applications. The ongoing\nwork includes building more efficient model capturing aliasing properties and\nsoundness proof for its essential elements.\n", "versions": [{"version": "v1", "created": "Thu, 11 Jul 2013 17:19:11 GMT"}], "update_date": "2013-07-12", "authors_parsed": [["Kogtenkov", "Alexander", ""], ["Meyer", "Bertrand", ""], ["Velder", "Sergey", ""]]}, {"id": "1307.4474", "submitter": "EPTCS", "authors": "Alessandra Di Pierro (University of Verona), Herbert Wiklicky\n  (Imperial College London)", "title": "Probabilistic data flow analysis: a linear equational approach", "comments": "In Proceedings GandALF 2013, arXiv:1307.4162", "journal-ref": "EPTCS 119, 2013, pp. 150-165", "doi": "10.4204/EPTCS.119.14", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Speculative optimisation relies on the estimation of the probabilities that\ncertain properties of the control flow are fulfilled. Concrete or estimated\nbranch probabilities can be used for searching and constructing advantageous\nspeculative and bookkeeping transformations.\n  We present a probabilistic extension of the classical equational approach to\ndata-flow analysis that can be used to this purpose. More precisely, we show\nhow the probabilistic information introduced in a control flow graph by branch\nprediction can be used to extract a system of linear equations from a program\nand present a method for calculating correct (numerical) solutions.\n", "versions": [{"version": "v1", "created": "Wed, 17 Jul 2013 01:42:29 GMT"}], "update_date": "2013-07-18", "authors_parsed": [["Di Pierro", "Alessandra", "", "University of Verona"], ["Wiklicky", "Herbert", "", "Imperial College London"]]}, {"id": "1307.4475", "submitter": "EPTCS", "authors": "Aleksandar S. Dimovski", "title": "Slot Games for Detecting Timing Leaks of Programs", "comments": "In Proceedings GandALF 2013, arXiv:1307.4162", "journal-ref": "EPTCS 119, 2013, pp. 166-179", "doi": "10.4204/EPTCS.119.15", "report-no": null, "categories": "cs.PL cs.CR cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we describe a method for verifying secure information flow of\nprograms, where apart from direct and indirect flows a secret information can\nbe leaked through covert timing channels. That is, no two computations of a\nprogram that differ only on high-security inputs can be distinguished by\nlow-security outputs and timing differences. We attack this problem by using\nslot-game semantics for a quantitative analysis of programs. We show how\nslot-games model can be used for performing a precise security analysis of\nprograms, that takes into account both extensional and intensional properties\nof programs. The practicality of this approach for automated verification is\nalso shown.\n", "versions": [{"version": "v1", "created": "Wed, 17 Jul 2013 01:42:37 GMT"}], "update_date": "2013-07-18", "authors_parsed": [["Dimovski", "Aleksandar S.", ""]]}, {"id": "1307.4585", "submitter": "Michal Terepeta", "authors": "Michal Terepeta and Hanne Riis Nielson and Flemming Nielson", "title": "Pushdown Systems for Monotone Frameworks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Monotone frameworks is one of the most successful frameworks for\nintraprocedural data flow analysis extending the traditional class of bitvector\nframeworks (like live variables and available expressions). Weighted pushdown\nsystems is similarly one of the most general frameworks for interprocedural\nanalysis of programs. However, it makes use of idempotent semirings to\nrepresent the sets of properties and unfortunately they do not admit analyses\nwhose transfer functions are not strict (e.g., classical bitvector frameworks).\nThis motivates the development of algorithms for backward and forward\nreachability of pushdown systems using sets of properties forming so-called\nflow algebras that weaken some of the assumptions of idempotent semirings. In\nparticular they do admit the bitvector frameworks, monotone frameworks, as well\nas idempotent semirings. We show that the algorithms are sound under mild\nassumptions on the flow algebras, mainly that the set of properties constitutes\na join semi-lattice, and complete provided that the transfer functions are\nsuitably distributive (but not necessarily strict).\n", "versions": [{"version": "v1", "created": "Wed, 17 Jul 2013 11:36:15 GMT"}], "update_date": "2013-07-18", "authors_parsed": [["Terepeta", "Michal", ""], ["Nielson", "Hanne Riis", ""], ["Nielson", "Flemming", ""]]}, {"id": "1307.4635", "submitter": "Ricardo Rocha", "authors": "Benoit Desouter and Tom Schrijvers", "title": "Integrating Datalog and Constraint Solving", "comments": "Proceedings of the 13th International Colloquium on Implementation of\n  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August\n  25, 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  LP is a common formalism for the field of databases and CSP, both at the\ntheoretical level and the implementation level in the form of Datalog and CLP.\nIn the past, close correspondences have been made between both fields at the\ntheoretical level. Yet correspondence at the implementation level has been much\nless explored. In this article we work towards relating them at the\nimplementation level. Concretely, we show how to derive the efficient Leapfrog\nTriejoin execution algorithm of Datalog from a generic CP execution scheme.\n", "versions": [{"version": "v1", "created": "Wed, 17 Jul 2013 13:58:38 GMT"}], "update_date": "2013-07-19", "authors_parsed": [["Desouter", "Benoit", ""], ["Schrijvers", "Tom", ""]]}, {"id": "1307.4641", "submitter": "Ricardo Rocha", "authors": "Danny Munera and Daniel Diaz and Salvador Abreu", "title": "Experimenting with X10 for Parallel Constraint-Based Local Search", "comments": "Proceedings of the 13th International Colloquium on Implementation of\n  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August\n  25, 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this study, we have investigated the adequacy of the PGAS parallel\nlanguage X10 to implement a Constraint-Based Local Search solver. We decided to\ncode in this language to benefit from the ease of use and architectural\nindependence from parallel resources which it offers. We present the\nimplementation strategy, in search of different sources of parallelism in the\ncontext of an implementation of the Adaptive Search algorithm. We extensively\ndiscuss the algorithm and its implementation. The performance evaluation on a\nrepresentative set of benchmarks shows close to linear speed-ups, in all the\nproblems treated.\n", "versions": [{"version": "v1", "created": "Wed, 17 Jul 2013 14:13:50 GMT"}], "update_date": "2013-07-18", "authors_parsed": [["Munera", "Danny", ""], ["Diaz", "Daniel", ""], ["Abreu", "Salvador", ""]]}, {"id": "1307.4642", "submitter": "Ricardo Rocha", "authors": "Paul Tarau", "title": "A Prolog Specification of Giant Number Arithmetic", "comments": "Proceedings of the 13th International Colloquium on Implementation of\n  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August\n  25, 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The tree based representation described in this paper, hereditarily binary\nnumbers, applies recursively a run-length compression mechanism that enables\ncomputations limited by the structural complexity of their operands rather than\nby their bitsizes. While within constant factors from their traditional\ncounterparts for their worst case behavior, our arithmetic operations open the\ndoors for interesting numerical computations, impossible with traditional\nnumber representations. We provide a complete specification of our algorithms\nin the form of a purely declarative Prolog program.\n", "versions": [{"version": "v1", "created": "Wed, 17 Jul 2013 14:14:08 GMT"}], "update_date": "2013-07-18", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1307.4644", "submitter": "Ricardo Rocha", "authors": "David S. Warren", "title": "Interning Ground Terms in XSB", "comments": "Proceedings of the 13th International Colloquium on Implementation of\n  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August\n  25, 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents an implementation of interning of ground terms in the XSB\nTabled Prolog system. This is related to the idea of hash-consing. I describe\nthe concept of interning atoms and discuss the issues around interning ground\nstructured terms, motivating why tabling Prolog systems may change the\ncost-benefit tradeoffs from those of traditional Prolog systems. I describe the\ndetails of the implementation of interning ground terms in the XSB Tabled\nProlog System and show some of its performance properties. This implementation\nachieves the effects of that of Zhou and Have but is tuned for XSB's\nrepresentations and is arguably simpler.\n", "versions": [{"version": "v1", "created": "Wed, 17 Jul 2013 14:20:15 GMT"}], "update_date": "2013-07-18", "authors_parsed": [["Warren", "David S.", ""]]}, {"id": "1307.4648", "submitter": "Ricardo Rocha", "authors": "Michael Hanus and Fabian Reck", "title": "A Generic Analysis Server System for Functional Logic Programs", "comments": "Proceedings of the 13th International Colloquium on Implementation of\n  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August\n  25, 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a system, called CASS, for the analysis of functional logic\nprograms. The system is generic so that various kinds of analyses (e.g.,\ngroundness, non-determinism, demanded arguments) can be easily integrated. In\norder to analyze larger applications consisting of dozens or hundreds of\nmodules, CASS supports a modular and incremental analysis of programs.\nMoreover, it can be used by different programming tools, like documentation\ngenerators, analysis environments, program optimizers, as well as Eclipse-based\ndevelopment environments. For this purpose, CASS can also be invoked as a\nserver system to get a language-independent access to its functionality. CASS\nis completely implemented in the functional logic language Curry as a\nmaster/worker architecture to exploit parallel or distributed execution\nenvironments.\n", "versions": [{"version": "v1", "created": "Wed, 17 Jul 2013 14:30:17 GMT"}], "update_date": "2013-07-18", "authors_parsed": [["Hanus", "Michael", ""], ["Reck", "Fabian", ""]]}, {"id": "1307.4655", "submitter": "Ricardo Rocha", "authors": "Igor St\\'ephan", "title": "Compilation for QCSP", "comments": "Proceedings of the 13th International Colloquium on Implementation of\n  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August\n  25, 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose in this article a framework for compilation of quantified\nconstraint satisfaction problems (QCSP). We establish the semantics of this\nformalism by an interpretation to a QCSP. We specify an algorithm to compile a\nQCSP embedded into a search algorithm and based on the inductive semantics of\nQCSP. We introduce an optimality property and demonstrate the optimality of the\ninterpretation of the compiled QCSP.\n", "versions": [{"version": "v1", "created": "Wed, 17 Jul 2013 14:42:55 GMT"}], "update_date": "2013-07-18", "authors_parsed": [["St\u00e9phan", "Igor", ""]]}, {"id": "1307.4827", "submitter": "Raphael kena Poss", "authors": "Raphael 'kena' Poss", "title": "Characterizing traits of coordination", "comments": "11 pages, 3 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  How can one recognize coordination languages and technologies? As this report\nshows, the common approach that contrasts coordination with computation is\nintellectually unsound: depending on the selected understanding of the word\n\"computation\", it either captures too many or too few programming languages.\nInstead, we argue for objective criteria that can be used to evaluate how well\nprogramming technologies offer coordination services. Of the various criteria\ncommonly used in this community, we are able to isolate three that are strongly\ncharacterizing: black-box componentization, which we had identified previously,\nbut also interface extensibility and customizability of run-time optimization\ngoals. These criteria are well matched by Intel's Concurrent Collections and\nAstraKahn, and also by OpenCL, POSIX and VMWare ESX.\n", "versions": [{"version": "v1", "created": "Thu, 18 Jul 2013 04:06:49 GMT"}], "update_date": "2013-07-19", "authors_parsed": [["Poss", "Raphael 'kena'", ""]]}, {"id": "1307.5277", "submitter": "Neal Glew", "authors": "Neal Glew, Tim Sweeney, Leaf Petersen", "title": "Formalisation of the lambda aleph Runtime", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In previous work we describe a novel approach to dependent typing based on a\nmultivalued term language. In this technical report we formalise the runtime, a\nkind of operational semantics, for that language. We describe a fairly\ncomprehensive core language, and then give a small-step operational semantics\nbased on an abstract machine. Errors are explicit in the semantics. We also\nprove several simple properties: that every non-terminated machine state steps\nto something and that reduction is deterministic once input is fixed.\n", "versions": [{"version": "v1", "created": "Fri, 19 Jul 2013 16:38:25 GMT"}], "update_date": "2013-07-22", "authors_parsed": [["Glew", "Neal", ""], ["Sweeney", "Tim", ""], ["Petersen", "Leaf", ""]]}, {"id": "1307.6239", "submitter": "David Van Horn", "authors": "Phuc C. Nguyen, Sam Tobin-Hochstadt, David Van Horn", "title": "Soft Contract Verification", "comments": "ICFP '14, September 1-6, 2014, Gothenburg, Sweden", "journal-ref": null, "doi": "10.1145/2628136.2628156", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Behavioral software contracts are a widely used mechanism for governing the\nflow of values between components. However, run-time monitoring and enforcement\nof contracts imposes significant overhead and delays discovery of faulty\ncomponents to run-time.\n  To overcome these issues, we present soft contract verification, which aims\nto statically prove either complete or partial contract correctness of\ncomponents, written in an untyped, higher-order language with first-class\ncontracts. Our approach uses higher-order symbolic execution, leveraging\ncontracts as a source of symbolic values including unknown behavioral values,\nand employs an updatable heap of contract invariants to reason about\nflow-sensitive facts. We prove the symbolic execution soundly approximates the\ndynamic semantics and that verified programs can't be blamed.\n  The approach is able to analyze first-class contracts, recursive data\nstructures, unknown functions, and control-flow-sensitive refinements of\nvalues, which are all idiomatic in dynamic languages. It makes effective use of\nan off-the-shelf solver to decide problems without heavy encodings. The\napproach is competitive with a wide range of existing tools---including type\nsystems, flow analyzers, and model checkers---on their own benchmarks.\n", "versions": [{"version": "v1", "created": "Tue, 23 Jul 2013 20:30:46 GMT"}, {"version": "v2", "created": "Sun, 17 Nov 2013 19:55:36 GMT"}, {"version": "v3", "created": "Mon, 3 Mar 2014 21:40:18 GMT"}, {"version": "v4", "created": "Mon, 16 Jun 2014 18:57:38 GMT"}], "update_date": "2014-06-17", "authors_parsed": [["Nguyen", "Phuc C.", ""], ["Tobin-Hochstadt", "Sam", ""], ["Van Horn", "David", ""]]}, {"id": "1307.6318", "submitter": "Tom Hirschowitz", "authors": "Tom Hirschowitz (CNRS, Universit\\'e de Savoie)", "title": "Cartesian closed 2-categories and permutation equivalence in\n  higher-order rewriting", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 3 (September\n  4, 2013) lmcs:1132", "doi": "10.2168/LMCS-9(3:10)2013", "report-no": null, "categories": "cs.LO cs.PL math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a semantics for permutation equivalence in higher-order rewriting.\nThis semantics takes place in cartesian closed 2-categories, and is proved\nsound and complete.\n", "versions": [{"version": "v1", "created": "Wed, 24 Jul 2013 07:57:09 GMT"}, {"version": "v2", "created": "Mon, 2 Sep 2013 22:54:21 GMT"}, {"version": "v3", "created": "Fri, 20 Sep 2013 18:58:44 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Hirschowitz", "Tom", "", "CNRS, Universit\u00e9 de Savoie"]]}, {"id": "1307.6894", "submitter": "David Spivak", "authors": "Dylan Rupel and David I. Spivak", "title": "The operad of temporal wiring diagrams: formalizing a graphical language\n  for discrete-time processes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.PL q-bio.NC", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  We investigate the hierarchical structure of processes using the mathematical\ntheory of operads. Information or material enters a given process as a stream\nof inputs, and the process converts it to a stream of outputs. Output streams\ncan then be supplied to other processes in an organized manner, and the\nresulting system of interconnected processes can itself be considered a macro\nprocess. To model the inherent structure in this kind of system, we define an\noperad $\\mathcal{W}$ of black boxes and directed wiring diagrams, and we define\na $\\mathcal{W}$-algebra $\\mathcal{P}$ of processes (which we call propagators,\nafter Radul and Sussman). Previous operadic models of wiring diagrams use\nundirected wires without length, useful for modeling static systems of\nconstraints, whereas we use directed wires with length, useful for modeling\ndynamic flows of information. We give multiple examples throughout to ground\nthe ideas.\n", "versions": [{"version": "v1", "created": "Thu, 25 Jul 2013 23:33:24 GMT"}], "update_date": "2013-07-29", "authors_parsed": [["Rupel", "Dylan", ""], ["Spivak", "David I.", ""]]}, {"id": "1307.6903", "submitter": "EPTCS", "authors": "Johannes Borgstr\\\"om (Uppsala University), Bas Luttik (Eindhoven\n  University of Technology)", "title": "Proceedings Combined 20th International Workshop on Expressiveness in\n  Concurrency and 10th Workshop on Structural Operational Semantics", "comments": null, "journal-ref": "EPTCS 120, 2013", "doi": "10.4204/EPTCS.120", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Combined 20th International\nWorkshop on Expressiveness in Concurrency and the 10th Workshop on Structural\nOperational Semantics (EXPRESS/SOS 2013) which was held on 26th August, 2013 in\nBuenos Aires, Argentina, as an affiliated workshop of CONCUR 2013, the 24th\nInternational Conference on Concurrency Theory.\n  The EXPRESS workshops aim at bringing together researchers interested in the\nexpressiveness of various formal systems and semantic notions, particularly in\nthe field of concurrency. Their focus has traditionally been on the comparison\nbetween programming concepts (such as concurrent, functional, imperative, logic\nand object-oriented programming) and between mathematical models of computation\n(such as process algebras, Petri nets, event structures, modal logics, and\nrewrite systems) on the basis of their relative expressive power. The EXPRESS\nworkshop series has run successfully since 1994 and over the years this focus\nhas become broadly construed.\n  The SOS workshops aim at being a forum for researchers, students and\npractitioners interested in new developments, and directions for future\ninvestigation, in the field of structural operational semantics. One of the\nspecific goals of the SOS workshop series is to establish synergies between the\nconcurrency and programming language communities working on the theory and\npractice of SOS. Reports on applications of SOS to other fields are also most\nwelcome, including: modelling and analysis of biological systems, security of\ncomputer systems programming, modelling and analysis of embedded systems,\nspecification of middle-ware and coordination languages, programming language\nsemantics and implementation, static analysis software and hardware\nverification, and semantics for domain-specific languages and model-based\nengineering.\n", "versions": [{"version": "v1", "created": "Fri, 26 Jul 2013 01:27:31 GMT"}], "update_date": "2013-07-29", "authors_parsed": [["Borgstr\u00f6m", "Johannes", "", "Uppsala University"], ["Luttik", "Bas", "", "Eindhoven\n  University of Technology"]]}, {"id": "1307.7261", "submitter": "Jerzy Tyszkiewicz", "authors": "Jerzy Tyszkiewicz", "title": "The Power of Spreadsheet Computations", "comments": "36 pages. Electronic appendices in Excel's xlsx format available from\n  author's Web page", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the expressive power of spreadsheets. We consider spreadsheets\nwhich contain only formulas, and assume that they are small templates, which\ncan be filled to a larger area of the grid to process input data of variable\nsize. Therefore we can compare them to well-known machine models of\ncomputation. We consider a number of classes of spreadsheets defined by\nrestrictions on their reference structure. Two of the classes correspond\nclosely to parallel complexity classes: we prove a direct correspondence\nbetween the dimensions of the spreadsheet and amount of hardware and time used\nby a parallel computer to compute the same function. As a tool, we produce\nspreadsheets which are universal in these classes, i.e. can emulate any other\nspreadsheet from them. In other cases we implement in the spreadsheets in\nquestion instances of a polynomial-time complete problem, which indicates that\nthe the spreadsheets are unlikely to have efficient parallel evaluation\nalgorithms. Thus we get a picture how the computational power of spreadsheets\ndepends on their dimensions and structure of references.\n", "versions": [{"version": "v1", "created": "Sat, 27 Jul 2013 14:10:33 GMT"}], "update_date": "2013-07-30", "authors_parsed": [["Tyszkiewicz", "Jerzy", ""]]}, {"id": "1307.7281", "submitter": "Roopsha Samanta", "authors": "Roopsha Samanta, Oswaldo Olivo and E. Allen Emerson", "title": "Cost-Aware Automatic Program Repair", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a formal framework for repairing infinite-state, imperative,\nsequential programs, with (possibly recursive) procedures and multiple\nassertions; the framework can generate repaired programs by modifying the\noriginal erroneous program in multiple program locations, and can ensure the\nreadability of the repaired program using user-defined expression templates;\nthe framework also generates a set of inductive assertions that serve as a\nproof of correctness of the repaired program. As a step toward integrating\nprogrammer intent and intuition in automated program repair, we present a \"\ncost-aware\" formulation - given a cost function associated with permissible\nstatement modifications, the goal is to ensure that the total program\nmodification cost does not exceed a given repair budget. As part of our\npredicate abstraction-based solution framework, we present a sound and complete\nalgorithm for repair of Boolean programs. We have developed a prototype tool\nbased on SMT solving and used it successfully to repair diverse errors in\nbenchmark C programs.\n", "versions": [{"version": "v1", "created": "Sat, 27 Jul 2013 16:57:03 GMT"}, {"version": "v2", "created": "Mon, 31 Mar 2014 12:19:40 GMT"}], "update_date": "2014-04-01", "authors_parsed": [["Samanta", "Roopsha", ""], ["Olivo", "Oswaldo", ""], ["Emerson", "E. Allen", ""]]}, {"id": "1307.7444", "submitter": "EPTCS", "authors": "Daniel Gebler (Department of Computer Science, VU University Amsterdam\n  (VU)), Eugen-Ioan Goriac (ICE-TCS, School of Computer Science, Reykjavik\n  University, Iceland), Mohammad Reza Mousavi (Center for Research on Embedded\n  Systems (CERES), Halmstad University)", "title": "Algebraic Meta-Theory of Processes with Data", "comments": "In Proceedings EXPRESS/SOS 2013, arXiv:1307.6903", "journal-ref": "EPTCS 120, 2013, pp. 63-77", "doi": "10.4204/EPTCS.120.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There exists a rich literature of rule formats guaranteeing different\nalgebraic properties for formalisms with a Structural Operational Semantics.\nMoreover, there exist a few approaches for automatically deriving\naxiomatizations characterizing strong bisimilarity of processes. To our\nknowledge, this literature has never been extended to the setting with data\n(e.g. to model storage and memory). We show how the rule formats for algebraic\nproperties can be exploited in a generic manner in the setting with data.\nMoreover, we introduce a new approach for deriving sound and ground-complete\naxiom schemata for a notion of bisimilarity with data, called stateless\nbisimilarity, based on intuitive auxiliary function symbols for handling the\nstore component. We do restrict, however, the axiomatization to the setting\nwhere the store component is only given in terms of constants.\n", "versions": [{"version": "v1", "created": "Mon, 29 Jul 2013 02:10:44 GMT"}], "update_date": "2013-07-30", "authors_parsed": [["Gebler", "Daniel", "", "Department of Computer Science, VU University Amsterdam"], ["Goriac", "Eugen-Ioan", "", "ICE-TCS, School of Computer Science, Reykjavik\n  University, Iceland"], ["Mousavi", "Mohammad Reza", "", "Center for Research on Embedded\n  Systems"]]}, {"id": "1307.7446", "submitter": "EPTCS", "authors": "Luca Aceto (ICE-TCS, School of Computer Science, Reykjavik University,\n  Iceland), Eugen-Ioan Goriac (ICE-TCS, School of Computer Science, Reykjavik\n  University, Iceland), Anna Ingolfsdottir (ICE-TCS, School of Computer\n  Science, Reykjavik University, Iceland)", "title": "Meta SOS - A Maude Based SOS Meta-Theory Framework", "comments": "In Proceedings EXPRESS/SOS 2013, arXiv:1307.6903", "journal-ref": "EPTCS 120, 2013, pp. 93-107", "doi": "10.4204/EPTCS.120.8", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Meta SOS is a software framework designed to integrate the results from the\nmeta-theory of structural operational semantics (SOS). These results include\nderiving semantic properties of language constructs just by syntactically\nanalyzing their rule-based definition, as well as automatically deriving sound\nand ground-complete axiomatizations for languages, when considering a notion of\nbehavioural equivalence. This paper describes the Meta SOS framework by\nblending aspects from the meta-theory of SOS, details on their implementation\nin Maude, and running examples.\n", "versions": [{"version": "v1", "created": "Mon, 29 Jul 2013 02:11:01 GMT"}], "update_date": "2013-07-30", "authors_parsed": [["Aceto", "Luca", "", "ICE-TCS, School of Computer Science, Reykjavik University,\n  Iceland"], ["Goriac", "Eugen-Ioan", "", "ICE-TCS, School of Computer Science, Reykjavik\n  University, Iceland"], ["Ingolfsdottir", "Anna", "", "ICE-TCS, School of Computer\n  Science, Reykjavik University, Iceland"]]}, {"id": "1307.7849", "submitter": "EPTCS", "authors": "St\\'ephane Graham-Lengrand (CNRS - \\'Ecole Polytechnique), Luca\n  Paolini (Universit\\`a di Torino)", "title": "Proceedings Sixth Workshop on Intersection Types and Related Systems", "comments": null, "journal-ref": "EPTCS 121, 2013", "doi": "10.4204/EPTCS.121", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Sixth Workshop on Intersection\nTypes and Related Systems (ITRS 2012). The workshop was held in Dubrovnik\n(Croatia) on June 29th, 2012, affiliated to Twenty-Seventh Annual ACM/IEEE\nSymposium on Logic in Computer Science (LICS 2012). The ITRS workshop aims to\nbring together researchers working on both the theory and practical\napplications of systems based on intersection types and related approaches\n(e.g., union types, refinement types, behavioural types, recursive types, and\nso on).\n", "versions": [{"version": "v1", "created": "Tue, 30 Jul 2013 07:23:59 GMT"}], "update_date": "2013-07-31", "authors_parsed": [["Graham-Lengrand", "St\u00e9phane", "", "CNRS - \u00c9cole Polytechnique"], ["Paolini", "Luca", "", "Universit\u00e0 di Torino"]]}, {"id": "1307.8204", "submitter": "EPTCS", "authors": "Jana Dunfield", "title": "Annotations for Intersection Typechecking", "comments": "In Proceedings ITRS 2012, arXiv:1307.7849", "journal-ref": "EPTCS 121, 2013, pp. 35-47", "doi": "10.4204/EPTCS.121.3", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In functional programming languages, the classic form of annotation is a\nsingle type constraint on a term. Intersection types add complications: a\nsingle term may have to be checked several times against different types, in\ndifferent contexts, requiring annotation with several types. Moreover, it is\nuseful (in some systems, necessary) to indicate the context in which each such\ntype is to be used.\n  This paper explores the technical design space of annotations in systems with\nintersection types. Earlier work (Dunfield and Pfenning 2004) introduced\ncontextual typing annotations, which we now tease apart into more elementary\nmechanisms: a \"right hand\" annotation (the standard form), a \"left hand\"\nannotation (the context in which a right-hand annotation is to be used), a\nmerge that allows for multiple annotations, and an existential binder for index\nvariables. The most novel element is the left-hand annotation, which guards\nterms (and right-hand annotations) with a judgment that must follow from the\ncurrent context.\n", "versions": [{"version": "v1", "created": "Wed, 31 Jul 2013 03:24:25 GMT"}], "update_date": "2021-03-24", "authors_parsed": [["Dunfield", "Jana", ""]]}, {"id": "1307.8207", "submitter": "EPTCS", "authors": "Davide Ancona, Paola Giannini, Elena Zucca", "title": "Reconciling positional and nominal binding", "comments": "In Proceedings ITRS 2012, arXiv:1307.7849", "journal-ref": "EPTCS 121, 2013, pp. 81-93", "doi": "10.4204/EPTCS.121.6", "report-no": null, "categories": "cs.PL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define an extension of the simply-typed lambda calculus where two\ndifferent binding mechanisms, by position and by name, nicely coexist. In the\nformer, as in standard lambda calculus, the matching between parameter and\nargument is done on a positional basis, hence alpha-equivalence holds, whereas\nin the latter it is done on a nominal basis. The two mechanisms also\nrespectively correspond to static binding, where the existence and type\ncompatibility of the argument are checked at compile-time, and dynamic binding,\nwhere they are checked at run-time.\n", "versions": [{"version": "v1", "created": "Wed, 31 Jul 2013 03:24:46 GMT"}], "update_date": "2013-08-01", "authors_parsed": [["Ancona", "Davide", ""], ["Giannini", "Paola", ""], ["Zucca", "Elena", ""]]}, {"id": "1307.8212", "submitter": "EPTCS", "authors": "Razika Lounas (University of Boumerdes, Algeria), Mohamed Mezghiche\n  (University of Boumerdes, Algeria), Jean-Louis Lanet (Universityof Limoges,\n  France)", "title": "Towards a General Framework for Formal Reasoning about Java Bytecode\n  Transformation", "comments": "In Proceedings SCSS 2012, arXiv:1307.8029", "journal-ref": "EPTCS 122, 2013, pp. 63-73", "doi": "10.4204/EPTCS.122.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program transformation has gained a wide interest since it is used for\nseveral purposes: altering semantics of a program, adding features to a program\nor performing optimizations. In this paper we focus on program transformations\nat the bytecode level. Because these transformations may introduce errors, our\ngoal is to provide a formal way to verify the update and establish its\ncorrectness. The formal framework presented includes a definition of a formal\nsemantics of updates which is the base of a static verification and a scheme\nbased on Hoare triples and weakest precondition calculus to reason about\nbehavioral aspects in bytecode transformation\n", "versions": [{"version": "v1", "created": "Wed, 31 Jul 2013 03:28:54 GMT"}], "update_date": "2013-08-01", "authors_parsed": [["Lounas", "Razika", "", "University of Boumerdes, Algeria"], ["Mezghiche", "Mohamed", "", "University of Boumerdes, Algeria"], ["Lanet", "Jean-Louis", "", "Universityof Limoges,\n  France"]]}, {"id": "1307.8389", "submitter": "Ricardo Rocha", "authors": "Ricardo Rocha and Christian Theil Have", "title": "Proceedings of the 13th International Colloquium on Implementation of\n  Constraint and LOgic Programming Systems", "comments": "Proceedings of the 13th International Colloquium on Implementation of\n  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August\n  25, 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the 13th International Colloquium on\nImplementation of Constraint and LOgic Programming Systems (CICLOPS 2013), held\nin Istanbul, Turkey during August 25, 2013. CICLOPS is a well established line\nof workshops, traditionally co-located with ICLP, that aims at discussing and\nexchanging experience on the design, implementation, and optimization of\nconstraint and logic programming systems, and other systems based on logic as a\nmeans of expressing computations. This year, CICLOPS received 8 paper\nsubmissions. Each submission was reviewed by at least 3 Program Committee\nmembers and, at the end, 6 papers were accepted for presentation at the\nworkshop. We would like to thank the ICLP organizers for their support, the\nEasyChair conference management system for making the life of the program\nchairs easier and arxiv.org for providing permanent hosting. Thanks should go\nalso to the authors of all submitted papers for their contribution to make\nCICLOPS alive and to the participants for making the event a meeting point for\na fruitful exchange of ideas and feedback on recent developments. Finally, we\nwant to express our gratitude to the Program Committee members, as the\nsymposium would not have been possible without their dedicated work.\n", "versions": [{"version": "v1", "created": "Wed, 31 Jul 2013 17:03:11 GMT"}], "update_date": "2013-08-01", "authors_parsed": [["Rocha", "Ricardo", ""], ["Have", "Christian Theil", ""]]}]