[{"id": "1005.0518", "submitter": "EPTCS", "authors": "Amir M. Ben-Amram", "title": "On Decidable Growth-Rate Properties of Imperative Programs", "comments": null, "journal-ref": "EPTCS 23, 2010, pp. 1-14", "doi": "10.4204/EPTCS.23.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In 2008, Ben-Amram, Jones and Kristiansen showed that for a simple \"core\"\nprogramming language - an imperative language with bounded loops, and\narithmetics limited to addition and multiplication - it was possible to decide\nprecisely whether a program had certain growth-rate properties, namely\npolynomial (or linear) bounds on computed values, or on the running time.\n  This work emphasized the role of the core language in mitigating the\nnotorious undecidability of program properties, so that one deals with\ndecidable problems.\n  A natural and intriguing problem was whether more elements can be added to\nthe core language, improving its utility, while keeping the growth-rate\nproperties decidable. In particular, the method presented could not handle a\ncommand that resets a variable to zero. This paper shows how to handle resets.\nThe analysis is given in a logical style (proof rules), and its complexity is\nshown to be PSPACE-complete (in contrast, without resets, the problem was\nPTIME). The analysis algorithm evolved from the previous solution in an\ninteresting way: focus was shifted from proving a bound to disproving it, and\nthe algorithm works top-down rather than bottom-up.\n", "versions": [{"version": "v1", "created": "Tue, 4 May 2010 13:28:22 GMT"}], "update_date": "2010-05-20", "authors_parsed": [["Ben-Amram", "Amir M.", ""]]}, {"id": "1005.0519", "submitter": "EPTCS", "authors": "Guillaume Bonfante", "title": "Observation of implicit complexity by non confluence", "comments": null, "journal-ref": "EPTCS 23, 2010, pp. 15-29", "doi": "10.4204/EPTCS.23.2", "report-no": null, "categories": "cs.CC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose to consider non confluence with respect to implicit complexity. We\ncome back to some well known classes of first-order functional program, for\nwhich we have a characterization of their intentional properties, namely the\nclass of cons-free programs, the class of programs with an interpretation, and\nthe class of programs with a quasi-interpretation together with a termination\nproof by the product path ordering. They all correspond to PTIME. We prove that\nadding non confluence to the rules leads to respectively PTIME, NPTIME and\nPSPACE. Our thesis is that the separation of the classes is actually a witness\nof the intentional properties of the initial classes of programs.\n", "versions": [{"version": "v1", "created": "Tue, 4 May 2010 13:28:34 GMT"}], "update_date": "2010-05-20", "authors_parsed": [["Bonfante", "Guillaume", ""]]}, {"id": "1005.0653", "submitter": "EPTCS", "authors": "Patrick Baillot (ENS Lyon)", "title": "Proceedings International Workshop on Developments in Implicit\n  Computational complExity", "comments": null, "journal-ref": "EPTCS 23, 2010", "doi": "10.4204/EPTCS.23", "report-no": null, "categories": "cs.LO cs.CC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the International Workshop on\nDevelopments in Implicit Computational complExity (DICE 2010), which took place\non March 27-28 2010 in Paphos, Cyprus, as a satellite event of the Joint\nEuropean Conference on Theory and Practice of Software, ETAPS 2010.\n  Implicit Computational Complexity aims at studying computational complexity\nwithout referring to external measuring conditions or particular machine\nmodels, but instead by considering restrictions on programming languages or\nlogical principles implying complexity properties. The aim of this workshop was\nto bring together researchers working on implicit computational complexity,\nfrom its logical and semantical aspects to those related to the static analysis\nof programs, so as to foster their interaction and to give newcomers an\noverview of the current trends in this area.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2010 00:20:40 GMT"}], "update_date": "2010-05-20", "authors_parsed": [["Baillot", "Patrick", "", "ENS Lyon"]]}, {"id": "1005.1034", "submitter": "Hermann von Issendorff", "authors": "Hermann von Issendorff", "title": "Programming Discrete Physical Systems", "comments": "Comments: 24 pages, 18 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL physics.class-ph q-bio.MN", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Every algorithm which can be executed on a computer can at least in principle\nbe realized in hardware, i.e. by a discrete physical system. The problem is\nthat up to now there is no programming language by which physical systems can\nconstructively be described. Such tool, however, is essential for the compact\ndescription and automatic production of complex systems. This paper introduces\na programming language, called Akton-Algebra, which provides the foundation for\nthe complete description of discrete physical systems. The approach originates\nfrom the finding that every discrete physical system reduces to a\nspatiotemporal topological network of nodes, if the functional and metric\nproperties are deleted. A next finding is that there exists a homeomorphism\nbetween the topological network and a sequence of symbols representing a\nprogram by which the original nodal network can be reconstructed. Providing\nAkton-Algebra with functionality turns it into a flow-controlled general data\nprocessing language, which by introducing clock control and addressing can be\nfurther transformed into a classical programming language. Providing\nAkton-Algebra with metrics, i.e. the shape and size of the components, turns it\ninto a novel hardware system construction language.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2010 16:32:34 GMT"}], "update_date": "2010-05-07", "authors_parsed": [["von Issendorff", "Hermann", ""]]}, {"id": "1005.1213", "submitter": "Julien Cohen", "authors": "Julien Cohen (LINA), R\\'emi Douence (LINA, INRIA - EMN)", "title": "Views, Program Transformations, and the Evolutivity Problem in a\n  Functional Language", "comments": "19 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We report on an experience to support multiple views of programs to solve the\ntyranny of the dominant decomposition in a functional setting. We consider two\npossible architectures in Haskell for the classical example of the expression\nproblem. We show how the Haskell Refactorer can be used to transform one view\ninto the other, and the other way back. That transformation is automated and we\ndiscuss how the Haskell Refactorer has been adapted to be able to support this\nautomated transformation. Finally, we compare our implementation of views with\nsome of the literature.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2010 14:17:34 GMT"}, {"version": "v2", "created": "Mon, 31 Jan 2011 07:22:02 GMT"}], "update_date": "2011-02-01", "authors_parsed": [["Cohen", "Julien", "", "LINA"], ["Douence", "R\u00e9mi", "", "LINA, INRIA - EMN"]]}, {"id": "1005.1466", "submitter": "Julien Cohen", "authors": "Julien Cohen (LINA), Jean-Louis Giavitto (IBISC), Olivier Michel\n  (LACL)", "title": "Variable elimination for building interpreters", "comments": "33 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we build an interpreter by reusing host language functions\ninstead of recoding mechanisms of function application that are already\navailable in the host language (the language which is used to build the\ninterpreter). In order to transform user-defined functions into host language\nfunctions we use combinatory logic : lambda-abstractions are transformed into a\ncomposition of combinators. We provide a mechanically checked proof that this\nstep is correct for the call-by-value strategy with imperative features.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2010 07:57:14 GMT"}], "update_date": "2010-05-11", "authors_parsed": [["Cohen", "Julien", "", "LINA"], ["Giavitto", "Jean-Louis", "", "IBISC"], ["Michel", "Olivier", "", "LACL"]]}, {"id": "1005.4022", "submitter": "William Jackson", "authors": "Manas Ranjan Pradhan and E.G. Rajan", "title": "Molecular Programming Pseudo-code Representation to Molecular\n  Electronics", "comments": "http://www.journalofcomputing.org", "journal-ref": "Journal of Computing, Volume 2, Issue 5, May 2010", "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This research paper is proposing the idea of pseudo code representation to\nmolecular programming used in designing molecular electronics devices. Already\nthe schematic representation of logical gates like AND, OR, NOT etc.from\nmolecular diodes or resonant tunneling diode are available. This paper is\nsetting a generic pseudo code model so that various logic gates can be\nformulated. These molecular diodes have designed from organic molecules or\nBio-molecules. Our focus is on to give a scenario of molecular computation\nthrough molecular programming. We have restricted our study to molecular\nrectifying diode and logic device as AND gate from organic molecules only.\n", "versions": [{"version": "v1", "created": "Fri, 21 May 2010 17:35:59 GMT"}], "update_date": "2010-05-24", "authors_parsed": [["Pradhan", "Manas Ranjan", ""], ["Rajan", "E. G.", ""]]}, {"id": "1005.4616", "submitter": "Lunjin Lu", "authors": "Lunjin Lu", "title": "Parametrizing Program Analysis by Lifting to Cardinal Power Domains", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A parametric analysis is an analysis whose input and output are parametrized\nwith a number of parameters which can be instantiated to abstract properties\nafter analysis is completed. This paper proposes to use Cousot and Cousot's\nCardinal power domain to capture functional dependencies of analysis output on\nits input and obtain a parametric analysis by parametrizing a non-parametric\nbase analysis. We illustrate the method by parametrizing a $\\pos$ based\ngroundness analysis of logic programs to a parametric groundness analysis. In\naddition, a prototype implementation shows that generality of the parametric\ngroundness analysis comes with a negligible extra cost.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2010 16:07:06 GMT"}], "update_date": "2010-05-26", "authors_parsed": [["Lu", "Lunjin", ""]]}, {"id": "1005.4798", "submitter": "Alex Berka Mr", "authors": "Alexander Victor Berka", "title": "Introduction to the Report \"Interlanguages and Synchronic Models of\n  Computation.\"", "comments": "Introduction to preprint report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A novel language system has given rise to promising alternatives to standard\nformal and processor network models of computation. An interstring linked with\na abstract machine environment, shares sub-expressions, transfers data, and\nspatially allocates resources for the parallel evaluation of dataflow. Formal\nmodels called the a-Ram family are introduced, designed to support interstring\nprogramming languages (interlanguages). Distinct from dataflow, graph\nrewriting, and FPGA models, a-Ram instructions are bit level and execute in\nsitu. They support sequential and parallel languages without the space/time\noverheads associated with the Turing Machine and lambda-calculus, enabling\nmassive programs to be simulated. The devices of one a-Ram model, called the\nSynchronic A-Ram, are fully connected and simpler than FPGA LUT's. A compiler\nfor an interlanguage called Space, has been developed for the Synchronic A-Ram.\nSpace is MIMD. strictly typed, and deterministic. Barring memory allocation and\ncompilation, modules are referentially transparent. At a high level of\nabstraction, modules exhibit a state transition system, aiding verification.\nData structures and parallel iteration are straightforward to implement, and\nallocations of sub-processes and data transfers to resources are implicit.\nSpace points towards highly connected architectures called Synchronic Engines,\nthat are more general purpose than systolic arrays and GPUs, and bypass\nprogrammability and conflict issues associated with multicores.\n", "versions": [{"version": "v1", "created": "Wed, 26 May 2010 12:34:37 GMT"}, {"version": "v2", "created": "Thu, 29 Jul 2010 14:27:21 GMT"}], "update_date": "2010-07-30", "authors_parsed": [["Berka", "Alexander Victor", ""]]}, {"id": "1005.4844", "submitter": "David Monniaux", "authors": "David Monniaux", "title": "Automatic Modular Abstractions for Template Numerical Constraints", "comments": "final version submitted to LMCS", "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (July 20,\n  2010) lmcs:1015", "doi": "10.2168/LMCS-6(3:4)2010", "report-no": "LMCS-2009-385", "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a method for automatically generating abstract transformers for\nstatic analysis by abstract interpretation. The method focuses on linear\nconstraints on programs operating on rational, real or floating-point variables\nand containing linear assignments and tests. Given the specification of an\nabstract domain, and a program block, our method automatically outputs an\nimplementation of the corresponding abstract transformer. It is thus a form of\nprogram transformation. In addition to loop-free code, the same method also\napplies for obtaining least fixed points as functions of the precondition,\nwhich permits the analysis of loops and recursive functions. The motivation of\nour work is data-flow synchronous programming languages, used for building\ncontrol-command embedded systems, but it also applies to imperative and\nfunctional programming. Our algorithms are based on quantifier elimination and\nsymbolic manipulation techniques over linear arithmetic formulas. We also give\nless general results for nonlinear constraints and nonlinear program\nconstructs.\n", "versions": [{"version": "v1", "created": "Wed, 26 May 2010 15:25:52 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Monniaux", "David", ""]]}, {"id": "1005.5183", "submitter": "Alex Berka Mr", "authors": "Alexander Victor Berka", "title": "Interlanguages and synchronic models of computation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A novel language system has given rise to promising alternatives to standard\nformal and processor network models of computation. An interstring linked with\na abstract machine environment, shares sub-expressions, transfers data, and\nspatially allocates resources for the parallel evaluation of dataflow. Formal\nmodels called the a-Ram family are introduced, designed to support interstring\nprogramming languages (interlanguages). Distinct from dataflow, graph\nrewriting, and FPGA models, a-Ram instructions are bit level and execute in\nsitu. They support sequential and parallel languages without the space/time\noverheads associated with the Turing Machine and l-calculus, enabling massive\nprograms to be simulated. The devices of one a-Ram model, called the Synchronic\nA-Ram, are fully connected and simpler than FPGA LUT's. A compiler for an\ninterlanguage called Space, has been developed for the Synchronic A-Ram. Space\nis MIMD. strictly typed, and deterministic. Barring memory allocation and\ncompilation, modules are referentially transparent. At a high level of\nabstraction, modules exhibit a state transition system, aiding verification.\nData structures and parallel iteration are straightforward to implement, and\nallocations of sub-processes and data transfers to resources are implicit.\nSpace points towards highly connected architectures called Synchronic Engines,\nthat scale in a GALS manner. Synchronic Engines are more general purpose than\nsystolic arrays and GPUs, and bypass programmability and conflict issues\nassociated with multicores.\n", "versions": [{"version": "v1", "created": "Thu, 27 May 2010 21:42:27 GMT"}], "update_date": "2010-05-31", "authors_parsed": [["Berka", "Alexander Victor", ""]]}, {"id": "1005.5278", "submitter": "Peter A Jonsson", "authors": "Peter A. Jonsson and Johan Nordlander", "title": "Positive Supercompilation for a Higher-Order Call-By-Value Language", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (August 18,\n  2010) lmcs:1038", "doi": "10.2168/LMCS-6(3:5)2010", "report-no": null, "categories": "cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Previous deforestation and supercompilation algorithms may introduce\naccidental termination when applied to call-by-value programs. This hides\nlooping bugs from the programmer, and changes the behavior of a program\ndepending on whether it is optimized or not. We present a supercompilation\nalgorithm for a higher-order call-by-value language and prove that the\nalgorithm both terminates and preserves termination properties. This algorithm\nutilizes strictness information to decide whether to substitute or not and\ncompares favorably with previous call-by-name transformations.\n", "versions": [{"version": "v1", "created": "Fri, 28 May 2010 12:33:37 GMT"}, {"version": "v2", "created": "Wed, 18 Aug 2010 08:05:55 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Jonsson", "Peter A.", ""], ["Nordlander", "Johan", ""]]}]