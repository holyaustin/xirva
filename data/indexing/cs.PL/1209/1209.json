[{"id": "1209.0643", "submitter": "Thomas Martin Gawlitza", "authors": "Thomas Martin Gawlitza (The University of Sydney), David Monniaux\n  (CNRS/VERIMAG)", "title": "Invariant Generation through Strategy Iteration in Succinctly\n  Represented Control Flow Graphs", "comments": "35 pages, conference version published at ESOP 2011, this version is\n  a CoRR version of our submission to Logical Methods in Computer Science", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 3 (September\n  30, 2012) lmcs:689", "doi": "10.2168/LMCS-8(3:29)2012", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problem of computing numerical invariants of programs, for\ninstance bounds on the values of numerical program variables. More\nspecifically, we study the problem of performing static analysis by abstract\ninterpretation using template linear constraint domains. Such invariants can be\nobtained by Kleene iterations that are, in order to guarantee termination,\naccelerated by widening operators. In many cases, however, applying this form\nof extrapolation leads to invariants that are weaker than the strongest\ninductive invariant that can be expressed within the abstract domain in use.\nAnother well-known source of imprecision of traditional abstract interpretation\ntechniques stems from their use of join operators at merge nodes in the control\nflow graph. The mentioned weaknesses may prevent these methods from proving\nsafety properties. The technique we develop in this article addresses both of\nthese issues: contrary to Kleene iterations accelerated by widening operators,\nit is guaranteed to yield the strongest inductive invariant that can be\nexpressed within the template linear constraint domain in use. It also eschews\njoin operators by distinguishing all paths of loop-free code segments. Formally\nspeaking, our technique computes the least fixpoint within a given template\nlinear constraint domain of a transition relation that is succinctly expressed\nas an existentially quantified linear real arithmetic formula. In contrast to\npreviously published techniques that rely on quantifier elimination, our\nalgorithm is proved to have optimal complexity: we prove that the decision\nproblem associated with our fixpoint problem is in the second level of the\npolynomial-time hierarchy.\n", "versions": [{"version": "v1", "created": "Tue, 4 Sep 2012 13:52:34 GMT"}, {"version": "v2", "created": "Fri, 28 Sep 2012 21:25:57 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Gawlitza", "Thomas Martin", "", "The University of Sydney"], ["Monniaux", "David", "", "CNRS/VERIMAG"]]}, {"id": "1209.0680", "submitter": "Radu Grigore", "authors": "Radu Grigore (University of Oxford), Nikos Tzevelekos (Queen Mary\n  University of London)", "title": "History-Register Automata", "comments": "LMCS (improved version of FoSSaCS)", "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 1 (March 29,\n  2016) lmcs:1630", "doi": "10.2168/LMCS-12(1:7)2016", "report-no": null, "categories": "cs.PL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Programs with dynamic allocation are able to create and use an unbounded\nnumber of fresh resources, such as references, objects, files, etc. We propose\nHistory-Register Automata (HRA), a new automata-theoretic formalism for\nmodelling such programs. HRAs extend the expressiveness of previous approaches\nand bring us to the limits of decidability for reachability checks. The\ndistinctive feature of our machines is their use of unbounded memory sets\n(histories) where input symbols can be selectively stored and compared with\nsymbols to follow. In addition, stored symbols can be consumed or deleted by\nreset. We show that the combination of consumption and reset capabilities\nrenders the automata powerful enough to imitate counter machines, and yields\nclosure under all regular operations apart from complementation. We moreover\nexamine weaker notions of HRAs which strike different balances between\nexpressiveness and effectiveness.\n", "versions": [{"version": "v1", "created": "Tue, 4 Sep 2012 15:54:29 GMT"}, {"version": "v2", "created": "Thu, 18 Feb 2016 06:02:57 GMT"}, {"version": "v3", "created": "Wed, 16 Mar 2016 14:13:40 GMT"}, {"version": "v4", "created": "Tue, 29 Mar 2016 20:35:31 GMT"}], "update_date": "2017-01-11", "authors_parsed": [["Grigore", "Radu", "", "University of Oxford"], ["Tzevelekos", "Nikos", "", "Queen Mary\n  University of London"]]}, {"id": "1209.1422", "submitter": "EPTCS", "authors": "Sung-Shik T. Q. Jongmans, Dave Clarke, Jos\\'e Proen\\c{c}a", "title": "A Procedure for Splitting Processes and its Application to Coordination", "comments": "In Proceedings FOCLASA 2012, arXiv:1208.4327", "journal-ref": "EPTCS 91, 2012, pp. 79-96", "doi": "10.4204/EPTCS.91.6", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a procedure for splitting processes in a process algebra with\nmulti-actions (a subset of the specification language mCRL2). This splitting\nprocedure cuts a process into two processes along a set of actions A: roughly,\none of these processes contains no actions from A, while the other process\ncontains only actions from A. We state and prove a theorem asserting that the\nparallel composition of these two processes equals the original process under\nappropriate synchronization.\n  We apply our splitting procedure to the process algebraic semantics of the\ncoordination language Reo: using this procedure and its related theorem, we\nformally establish the soundness of splitting Reo connectors along the\nboundaries of their (a)synchronous regions in implementations of Reo. Such\nsplitting can significantly improve the performance of connectors.\n", "versions": [{"version": "v1", "created": "Thu, 6 Sep 2012 22:52:39 GMT"}], "update_date": "2012-09-10", "authors_parsed": [["Jongmans", "Sung-Shik T. Q.", ""], ["Clarke", "Dave", ""], ["Proen\u00e7a", "Jos\u00e9", ""]]}, {"id": "1209.1711", "submitter": "Matthew Knepley", "authors": "Matthew G. Knepley", "title": "Programming Languages for Scientific Computing", "comments": "21 pages", "journal-ref": "Encyclopedia of Applied and Computational Mathematics, Springer,\n  2012", "doi": "10.1007/978-3-540-70529-1", "report-no": null, "categories": "cs.PL cs.CE cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Scientific computation is a discipline that combines numerical analysis,\nphysical understanding, algorithm development, and structured programming.\nSeveral yottacycles per year on the world's largest computers are spent\nsimulating problems as diverse as weather prediction, the properties of\nmaterial composites, the behavior of biomolecules in solution, and the quantum\nnature of chemical compounds. This article is intended to review specfic\nlanguages features and their use in computational science. We will review the\nstrengths and weaknesses of different programming styles, with examples taken\nfrom widely used scientific codes.\n", "versions": [{"version": "v1", "created": "Sat, 8 Sep 2012 12:31:50 GMT"}, {"version": "v2", "created": "Tue, 9 Jan 2018 15:22:10 GMT"}], "update_date": "2018-01-10", "authors_parsed": [["Knepley", "Matthew G.", ""]]}, {"id": "1209.2012", "submitter": "Stephan van Staden", "authors": "Stephan van Staden", "title": "A Framework for Concurrent Imperative Programming", "comments": "20 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The proposed framework provides a general model of concurrent imperative\nprogramming. Programs are modeled as formal languages and concurrency as an\ninterleaving (or shuffle) operator. This yields a simple and elegant algebra of\nprograms. The framework supports the views program logic by Dinsdale-Young and\nothers, which generalizes various type systems and separation logic approaches\nto program correctness. It also validates familiar operational calculi in\nsmall-step and big-step flavours. The consistency of the program logic with\nrespect to the operational rules is established directly and does not use\ninduction on derivations. In fact the whole framework uses only straightforward\nmathematics. Parametric in states, views and basic commands, it can be\ninstantiated to a variety of concrete languages and settings.\n", "versions": [{"version": "v1", "created": "Mon, 10 Sep 2012 14:36:20 GMT"}], "update_date": "2012-09-11", "authors_parsed": [["van Staden", "Stephan", ""]]}, {"id": "1209.2617", "submitter": "Enrique Martin-Martin", "authors": "Francisco J. L\\'opez-Fraguas, Enrique Martin-Martin, Juan\n  Rodr\\'iguez-Hortal\\'a, Jaime S\\'anchez-Hern\\'andez", "title": "Rewriting and narrowing for constructor systems with call-time choice\n  semantics", "comments": "89 pages, 6 figures. To appear in Theory and Practice of Logic\n  Programming (TPLP). Corrected typos", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Non-confluent and non-terminating constructor-based term rewrite systems are\nuseful for the purpose of specification and programming. In particular,\nexisting functional logic languages use such kind of rewrite systems to define\npossibly non-strict non-deterministic functions. The semantics adopted for\nnon-determinism is call-time choice, whose combination with non-strictness is a\nnon trivial issue, addressed years ago from a semantic point of view with the\nConstructor-based Rewriting Logic (CRWL), a well-known semantic framework\ncommonly accepted as suitable semantic basis of modern functional logic\nlanguages. A drawback of CRWL is that it does not come with a proper notion of\none-step reduction, which would be very useful to understand and reason about\nhow computations proceed. In this paper we develop thoroughly the theory for\nthe first order version of let-rewriting, a simple reduction notion close to\nthat of classical term rewriting, but extended with a let-binding construction\nto adequately express the combination of call-time choice with non-strict\nsemantics. Let-rewriting can be seen as a particular textual presentation of\nterm graph rewriting. We investigate the properties of let-rewriting, most\nremarkably their equivalence with respect to a conservative extension of the\nCRWL-semantics coping with let-bindings, and we show by some case studies that\nhaving two interchangeable formal views (reduction/semantics) of the same\nlanguage is a powerful reasoning tool. After that, we provide a notion of\nlet-narrowing which is adequate for call-time choice as proved by soundness and\ncompleteness results of let-narrowing with respect to let-rewriting. Moreover,\nwe relate those let-rewriting and let-narrowing relations (and hence CRWL) with\nordinary term rewriting and narrowing (..)\n  To appear in Theory and Practice of Logic Programming (TPLP).\n", "versions": [{"version": "v1", "created": "Wed, 12 Sep 2012 14:01:05 GMT"}, {"version": "v2", "created": "Wed, 10 Oct 2012 12:52:33 GMT"}], "update_date": "2012-10-11", "authors_parsed": [["L\u00f3pez-Fraguas", "Francisco J.", ""], ["Martin-Martin", "Enrique", ""], ["Rodr\u00edguez-Hortal\u00e1", "Juan", ""], ["S\u00e1nchez-Hern\u00e1ndez", "Jaime", ""]]}, {"id": "1209.4379", "submitter": "Mingsheng Ying", "authors": "Mingsheng Ying, Nengkun Yu and Yuan Feng", "title": "Defining Quantum Control Flow", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A remarkable difference between quantum and classical programs is that the\ncontrol flow of the former can be either classical or quantum. One of the key\nissues in the theory of quantum programming languages is defining and\nunderstanding quantum control flow. A functional language with quantum control\nflow was defined by Altenkirch and Grattage [\\textit{Proc. LICS'05}, pp.\n249-258]. This paper extends their work, and we introduce a general quantum\ncontrol structure by defining three new quantum program constructs, namely\nquantum guarded command, quantum choice and quantum recursion. We clarify the\nrelation between quantum choices and probabilistic choices. An interesting\ndifference between quantum recursions with classical control flows and with\nquantum control flows is revealed.\n", "versions": [{"version": "v1", "created": "Wed, 19 Sep 2012 21:56:39 GMT"}], "update_date": "2012-09-21", "authors_parsed": [["Ying", "Mingsheng", ""], ["Yu", "Nengkun", ""], ["Feng", "Yuan", ""]]}, {"id": "1209.5145", "submitter": "Viral Shah", "authors": "Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman", "title": "Julia: A Fast Dynamic Language for Technical Computing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dynamic languages have become popular for scientific computing. They are\ngenerally considered highly productive, but lacking in performance. This paper\npresents Julia, a new dynamic language for technical computing, designed for\nperformance from the beginning by adapting and extending modern programming\nlanguage techniques. A design based on generic functions and a rich type system\nsimultaneously enables an expressive programming model and successful type\ninference, leading to good performance for a wide range of programs. This makes\nit possible for much of the Julia library to be written in Julia itself, while\nalso incorporating best-of-breed C and Fortran libraries.\n", "versions": [{"version": "v1", "created": "Mon, 24 Sep 2012 03:55:45 GMT"}], "update_date": "2012-09-25", "authors_parsed": [["Bezanson", "Jeff", ""], ["Karpinski", "Stefan", ""], ["Shah", "Viral B.", ""], ["Edelman", "Alan", ""]]}, {"id": "1209.5152", "submitter": "Aditya Kanade", "authors": "Aditya Kanade, Amitabha Sanyal, Uday P. Khedker", "title": "A Logic for Correlating Temporal Properties across Program\n  Transformations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program transformations are widely used in synthesis, optimization, and\nmaintenance of software. Correctness of program transformations depends on\npreservation of some important properties of the input program. By regarding\nprograms as Kripke structures, many interesting properties of programs can be\nexpressed in temporal logics. In temporal logic, a formula is interpreted on a\nsingle program. However, to prove correctness of transformations, we encounter\nformulae which contain some subformulae interpreted on the input program and\nsome on the transformed program. An example where such a situation arises is\nverification of optimizing program transformations applied by compilers.\n  In this paper, we present a logic called Temporal Transformation Logic (TTL)\nto reason about such formulae. We consider different types of primitive\ntransformations and present TTL inference rules for them. Our definitions of\nprogram transformations and temporal logic operators are novel in their use of\nthe boolean matrix algebra. This results in specifications that are succinct\nand constructive. Further, we use the boolean matrix algebra in a uniform\nmanner to prove soundness of the TTL inference rules.\n", "versions": [{"version": "v1", "created": "Mon, 24 Sep 2012 05:28:35 GMT"}], "update_date": "2012-09-25", "authors_parsed": [["Kanade", "Aditya", ""], ["Sanyal", "Amitabha", ""], ["Khedker", "Uday P.", ""]]}, {"id": "1209.5407", "submitter": "Alexei Lisitsa", "authors": "Alexei Lisitsa and Andrei P. Nemytykh", "title": "A Note on Program Specialization. What Can Syntactical Properties of\n  Residual Programs Reveal?", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper presents two examples of non-traditional using of program\nspecialization by Turchin's supercompilation method. In both cases we are\ninterested in syntactical properties of residual programs produced by\nsupercompilation. In the first example we apply supercompilation to a program\nencoding a word equation and as a result we obtain a program representing a\ngraph describing the solution set of the word equation. The idea of the second\nexample belongs to Alexandr V. Korlyukov. He considered an interpreter\nsimulating the dynamic of the well known missionaries-cannibals puzzle.\nSupercompilation of the interpreter allows us to solve the puzzle. The\ninterpreter may also be seen as an encoding of a non-deterministic protocol.\n", "versions": [{"version": "v1", "created": "Mon, 24 Sep 2012 20:14:27 GMT"}], "update_date": "2012-09-26", "authors_parsed": [["Lisitsa", "Alexei", ""], ["Nemytykh", "Andrei P.", ""]]}, {"id": "1209.5851", "submitter": "Antoine Madet", "authors": "Antoine Madet (PPS)", "title": "A polynomial time {\\lambda}-calculus with multithreading and side\n  effects", "comments": "PPDP, Leuven : Belgique (2012)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The framework of Light Logics has been extensively studied to control the\ncomplexity of higher-order functional programs. We propose an extension of this\nframework to multithreaded programs with side effects, focusing on the case of\npolynomial time. After introducing a modal \\lambda-calculus with parallel\ncomposition and regions, we prove that a realistic call-by-value evaluation\nstrategy can be computed in polynomial time for a class of well-formed\nprograms. The result relies on the simulation of call-by-value by a polynomial\nshallow-first strategy which preserves the evaluation order of side effects.\nThen, we provide a polynomial type system that guarantees that well-typed\nprograms do not go wrong. Finally, we illustrate the expressivity of the type\nsystem by giving a programming example of concurrent iteration producing side\neffects over an inductive data structure.\n", "versions": [{"version": "v1", "created": "Wed, 26 Sep 2012 07:33:43 GMT"}], "update_date": "2012-09-27", "authors_parsed": [["Madet", "Antoine", "", "PPS"]]}]