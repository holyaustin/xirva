[{"id": "1003.0554", "submitter": "Thierry Gautier", "authors": "L. Besnard, T. Gautier, J. Ouy, J.-P. Talpin, J.-P. Bodeveix, A.\n  Cortier, M. Pantel, M. Strecker, G. Garcia, A. Rugina, J. Buisson, F. Dagnat", "title": "Polychronous Interpretation of Synoptic, a Domain Specific Modeling\n  Language for Embedded Flight-Software", "comments": "Workshop on Formal Methods for Aerospace (FMA 2009)", "journal-ref": "EPTCS 20, 2010, pp. 80-87", "doi": "10.4204/EPTCS.20.9", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The SPaCIFY project, which aims at bringing advances in MDE to the satellite\nflight software industry, advocates a top-down approach built on a\ndomain-specific modeling language named Synoptic. In line with previous\napproaches to real-time modeling such as Statecharts and Simulink, Synoptic\nfeatures hierarchical decomposition of application and control modules in\nsynchronous block diagrams and state machines. Its semantics is described in\nthe polychronous model of computation, which is that of the synchronous\nlanguage Signal.\n", "versions": [{"version": "v1", "created": "Tue, 2 Mar 2010 10:49:04 GMT"}], "update_date": "2010-03-26", "authors_parsed": [["Besnard", "L.", ""], ["Gautier", "T.", ""], ["Ouy", "J.", ""], ["Talpin", "J. -P.", ""], ["Bodeveix", "J. -P.", ""], ["Cortier", "A.", ""], ["Pantel", "M.", ""], ["Strecker", "M.", ""], ["Garcia", "G.", ""], ["Rugina", "A.", ""], ["Buisson", "J.", ""], ["Dagnat", "F.", ""]]}, {"id": "1003.0773", "submitter": "Aleksandar Kupusinac MSc", "authors": "Aleksandar Kupusinac and Dusan Malbaski", "title": "S-Program Calculus", "comments": "24 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a special subset of the first-order predicate logic named\nS-program calculus (briefly S-calculus). The S-calculus is a calculus\nconsisting of so-called S-formulas that are defined over the abstract state\nspace of a virtual machine. We show that S-formulas are a highly general tool\nfor analyzing program semantics inasmuch as Hoare triplets of total and partial\ncorrectness are not more than two S-formulas. Moreover, all the rules of Hoare\nlogic can be derived using S-formulas and axioms/theorems of first-order\npredicate calculus. The S-calculus is a powerful mechanism for proving program\ncorrectness as well as for building additional proving tools using theorems of\nthe predicate logic. Every proof is based on deriving the validity of some\nS-formula, so the procedure may be automated using automatic theorem provers\n(we will use Coq in this paper). As an example of the use of S-calculus, we\nwill prove the four basic properties of Dijsktra's operator wp. The proofs\ngiven by Dijkstra are not completely formalized and we will show that a full\nformalization can be achieved using S-calculus. Finally, we add one more\ntheorem to the above-mentioned four, namely the law of negation.\n", "versions": [{"version": "v1", "created": "Wed, 3 Mar 2010 10:36:52 GMT"}], "update_date": "2010-03-04", "authors_parsed": [["Kupusinac", "Aleksandar", ""], ["Malbaski", "Dusan", ""]]}, {"id": "1003.1160", "submitter": "Lunjin Lu", "authors": "Lunjin Lu and Dae-kyoo Kim", "title": "Required Behavior of Sequence Diagrams: Semantics and Conformance", "comments": "16 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Sequence diagrams are a widely used design notation for describing software\nbehaviors. Many reusable software artifacts such as design patterns and design\naspects make use of sequence diagrams to describe interaction behaviors. When a\npattern or an aspect is reused in an application, it is important to ensure\nthat the sequence diagrams for the application conform to the corresponding\nsequence diagrams for the pattern or aspect. Reasoning about conformance\nrelationship between sequence diagrams has not been addressed adequately in\nliterature. In this paper, we focus on required behavior specified by a UML\nsequence diagram. A novel trace semantics is given that captures precisely\nrequired behavior specified by a sequence diagram and a conformance relation\nbetween sequence diagrams is formalized based on the semantics. Properties of\nthe trace semantics and the conformance relation are studied.\n", "versions": [{"version": "v1", "created": "Thu, 4 Mar 2010 23:19:01 GMT"}, {"version": "v2", "created": "Sat, 6 Mar 2010 23:27:36 GMT"}, {"version": "v3", "created": "Thu, 19 Aug 2010 19:57:28 GMT"}, {"version": "v4", "created": "Tue, 14 Dec 2010 21:10:27 GMT"}, {"version": "v5", "created": "Thu, 21 Jul 2011 12:30:54 GMT"}], "update_date": "2011-07-22", "authors_parsed": [["Lu", "Lunjin", ""], ["Kim", "Dae-kyoo", ""]]}, {"id": "1003.1572", "submitter": "Stephan Schroevers", "authors": "Stephan Schroevers", "title": "Expressiveness and Extensions of an Instruction Sequence Semigroup", "comments": "Master's thesis - Master of Logic - University of Amsterdam", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  PGA, short for ProGram Algebra, describes sequential programs as finite or\ninfinite (repeating) sequences of instructions. The semigroup C of finite\ninstruction sequences was introduced as an equally expressive alternative to\nPGA. PGA instructions are executed from left to right; most C instructions come\nin a left-to-right as well as a right-to-left flavor. This thesis builds on C\nby introducing an alternative semigroup Cg which employs label and goto\ninstructions instead of relative jump instructions as control structures. Cg\ncan be translated to C and vice versa (and is thus equally expressive). It is\nshown that restricting the instruction sets of C and Cg to contain only\nfinitely many distinct jump, goto or label instructions in either or both\ndirections reduces their expressiveness. Instruction sets with an infinite\nnumber of these instructions in both directions (not necessarily all such\ninstructions) do not suffer a loss of expressiveness.\n", "versions": [{"version": "v1", "created": "Mon, 8 Mar 2010 08:56:17 GMT"}], "update_date": "2010-03-09", "authors_parsed": [["Schroevers", "Stephan", ""]]}, {"id": "1003.2547", "submitter": "Laurent Deniau", "authors": "Laurent Deniau", "title": "The C Object System: Using C as a High-Level Object-Oriented Language", "comments": "18p", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The C Object System (Cos) is a small C library which implements high-level\nconcepts available in Clos, Objc and other object-oriented programming\nlanguages: uniform object model (class, meta-class and property-metaclass),\ngeneric functions, multi-methods, delegation, properties, exceptions, contracts\nand closures. Cos relies on the programmable capabilities of the C programming\nlanguage to extend its syntax and to implement the aforementioned concepts as\nfirst-class objects. Cos aims at satisfying several general principles like\nsimplicity, extensibility, reusability, efficiency and portability which are\nrarely met in a single programming language. Its design is tuned to provide\nefficient and portable implementation of message multi-dispatch and message\nmulti-forwarding which are the heart of code extensibility and reusability.\nWith COS features in hand, software should become as flexible and extensible as\nwith scripting languages and as efficient and portable as expected with C\nprogramming. Likewise, Cos concepts should significantly simplify adaptive and\naspect-oriented programming as well as distributed and service-oriented\ncomputing\n", "versions": [{"version": "v1", "created": "Fri, 12 Mar 2010 14:31:23 GMT"}], "update_date": "2010-03-15", "authors_parsed": [["Deniau", "Laurent", ""]]}, {"id": "1003.2871", "submitter": "Julien Forget", "authors": "Julien Forget (1) and Fr\\'ed\\'eric Boniol (1) and David Lesens (2) and\n  Claire Pagetti (1) ((1) ONERA, Toulouse, France and (2) EADS Astrium Space\n  Transportation, Les Mureaux, France)", "title": "Implementing Multi-Periodic Critical Systems: from Design to Code\n  Generation", "comments": "15 pages, published in Workshop on Formal Methods for Aerospace\n  (FMA'09), part of Formal Methods Week 2009.", "journal-ref": "EPTCS 20, 2010, pp. 34-48", "doi": "10.4204/EPTCS.20.4", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article presents a complete scheme for the development of Critical\nEmbedded Systems with Multiple Real-Time Constraints. The system is programmed\nwith a language that extends the synchronous approach with high-level real-time\nprimitives. It enables to assemble in a modular and hierarchical manner several\nlocally mono-periodic synchronous systems into a globally multi-periodic\nsynchronous system. It also allows to specify flow latency constraints. A\nprogram is translated into a set of real-time tasks. The generated code (\\C\\\ncode) can be executed on a simple real-time platform with a dynamic-priority\nscheduler (EDF). The compilation process (each algorithm of the process, not\nthe compiler itself) is formally proved correct, meaning that the generated\ncode respects the real-time semantics of the original program (respect of\nperiods, deadlines, release dates and precedences) as well as its functional\nsemantics (respect of variable consumption).\n", "versions": [{"version": "v1", "created": "Mon, 15 Mar 2010 09:59:16 GMT"}], "update_date": "2010-04-01", "authors_parsed": [["Forget", "Julien", ""], ["Boniol", "Fr\u00e9d\u00e9ric", ""], ["Lesens", "David", ""], ["Pagetti", "Claire", ""]]}, {"id": "1003.4090", "submitter": "Rodrigo Machado", "authors": "Rodrigo Machado (Universidade Federal do Rio Grande do Sul), Reiko\n  Heckel (University of Leicester), Leila Ribeiro (Universidade Federal do Rio\n  Grande do Sul)", "title": "Modeling and Reasoning over Distributed Systems using Aspect-Oriented\n  Graph Grammars", "comments": null, "journal-ref": "EPTCS 21, 2010, pp. 39-50", "doi": "10.4204/EPTCS.21.4", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Aspect-orientation is a relatively new paradigm that introduces abstractions\nto modularize the implementation of system-wide policies. It is based on a\ncomposition operation, called aspect weaving, that implicitly modifies a base\nsystem by performing related changes within the system modules. Aspect-oriented\ngraph grammars (AOGG) extend the classic graph grammar formalism by defining\naspects as sets of rule-based modifications over a base graph grammar. Despite\nthe advantages of aspect-oriented concepts regarding modularity, the implicit\nnature of the aspect weaving operation may also introduce issues when reasoning\nabout the system behavior. Since in AOGGs aspect weaving is characterized by\nmeans of rule-based rewriting, we can overcome these problems by using known\nanalysis techniques from the graph transformation literature to study aspect\ncomposition. In this paper, we present a case study of a distributed\nclient-server system with global policies, modeled as an aspect-oriented graph\ngrammar, and discuss how to use the AGG tool to identify potential conflicts in\naspect weaving.\n", "versions": [{"version": "v1", "created": "Mon, 22 Mar 2010 07:18:30 GMT"}], "update_date": "2010-04-01", "authors_parsed": [["Machado", "Rodrigo", "", "Universidade Federal do Rio Grande do Sul"], ["Heckel", "Reiko", "", "University of Leicester"], ["Ribeiro", "Leila", "", "Universidade Federal do Rio\n  Grande do Sul"]]}, {"id": "1003.4326", "submitter": "Maribel Fern\\'andez", "authors": "Maribel Fern\\'andez, Olivier Namet (King's College London)", "title": "Graph Creation, Visualisation and Transformation", "comments": null, "journal-ref": "EPTCS 21, 2010, pp. 1-11", "doi": "10.4204/EPTCS.21.1", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a tool to create, edit, visualise and compute with interaction\nnets - a form of graph rewriting systems. The editor, called GraphPaper, allows\nusers to create and edit graphs and their transformation rules using an\nintuitive user interface. The editor uses the functionalities of the TULIP\nsystem, which gives us access to a wealth of visualisation algorithms.\nInteraction nets are not only a formalism for the specification of graphs, but\nalso a rewrite-based computation model. We discuss graph rewriting strategies\nand a language to express them in order to perform strategic interaction net\nrewriting.\n", "versions": [{"version": "v1", "created": "Tue, 23 Mar 2010 02:20:44 GMT"}], "update_date": "2010-03-24", "authors_parsed": [["Fern\u00e1ndez", "Maribel", "", "King's College London"], ["Namet", "Olivier", "", "King's College London"]]}, {"id": "1003.4369", "submitter": "Rachid Echahed", "authors": "Ph. Balbiani, R. Echahed, A. Herzig", "title": "A Modal Logic for Termgraph Rewriting", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a modal logic tailored to describe graph transformations and\ndiscuss some of its properties. We focus on a particular class of graphs called\ntermgraphs. They are first-order terms augmented with sharing and cycles.\nTermgraphs allow one to describe classical data-structures (possibly with\npointers) such as doubly-linked lists, circular lists etc. We show how the\nproposed logic can faithfully describe (i) termgraphs as well as (ii) the\napplication of a termgraph rewrite rule (i.e. matching and replacement) and\n(iii) the computation of normal forms with respect to a given rewrite system.\nWe also show how the proposed logic, which is more expressive than\npropositional dynamic logic, can be used to specify shapes of classical\ndata-structures (e.g. binary trees, circular lists etc.).\n", "versions": [{"version": "v1", "created": "Tue, 23 Mar 2010 10:34:14 GMT"}], "update_date": "2010-03-24", "authors_parsed": [["Balbiani", "Ph.", ""], ["Echahed", "R.", ""], ["Herzig", "A.", ""]]}, {"id": "1003.4562", "submitter": "Abubakar Hassan", "authors": "Abubakar Hassan (University of Sussex), Eugen Jiresch (Vienna\n  University of Technology), Shinya Sato (Himeji Dokkyo University)", "title": "An Implementation of Nested Pattern Matching in Interaction Nets", "comments": null, "journal-ref": "EPTCS 21, 2010, pp. 13-25", "doi": "10.4204/EPTCS.21.2", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reduction rules in interaction nets are constrained to pattern match exactly\none argument at a time. Consequently, a programmer has to introduce auxiliary\nrules to perform more sophisticated matches. In this paper, we describe the\ndesign and implementation of a system for interaction nets which allows nested\npattern matching on interaction rules. We achieve a system that provides\nconvenient ways to express interaction net programs without defining auxiliary\nrules.\n", "versions": [{"version": "v1", "created": "Wed, 24 Mar 2010 00:52:58 GMT"}], "update_date": "2010-04-08", "authors_parsed": [["Hassan", "Abubakar", "", "University of Sussex"], ["Jiresch", "Eugen", "", "Vienna\n  University of Technology"], ["Sato", "Shinya", "", "Himeji Dokkyo University"]]}, {"id": "1003.4563", "submitter": "Detlef Plump", "authors": "Detlef Plump (The University of York), Sandra Steinert (The University\n  of York)", "title": "The Semantics of Graph Programs", "comments": null, "journal-ref": "EPTCS 21, 2010, pp. 27-38", "doi": "10.4204/EPTCS.21.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  GP (for Graph Programs) is a rule-based, nondeterministic programming\nlanguage for solving graph problems at a high level of abstraction, freeing\nprogrammers from handling low-level data structures. The core of GP consists of\nfour constructs: single-step application of a set of conditional\ngraph-transformation rules, sequential composition, branching and iteration. We\npresent a formal semantics for GP in the style of structural operational\nsemantics. A special feature of our semantics is the use of finitely failing\nprograms to define GP's powerful branching and iteration commands.\n", "versions": [{"version": "v1", "created": "Wed, 24 Mar 2010 00:54:29 GMT"}], "update_date": "2010-04-08", "authors_parsed": [["Plump", "Detlef", "", "The University of York"], ["Steinert", "Sandra", "", "The University\n  of York"]]}, {"id": "1003.4799", "submitter": "Claude Kirchner", "authors": "Claude Kirchner, Pierre-Etienne Moreau, Cl\\'audia Tavares", "title": "A Type System for Tom", "comments": null, "journal-ref": "EPTCS 21, 2010, pp. 51-63", "doi": "10.4204/EPTCS.21.5", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Extending a given language with new dedicated features is a general and quite\nused approach to make the programming language more adapted to problems. Being\ncloser to the application, this leads to less programming flaws and easier\nmaintenance. But of course one would still like to perform program analysis on\nthese kinds of extended languages, in particular type checking and inference.\nIn this case one has to make the typing of the extended features compatible\nwith the ones in the starting language.\n  The Tom programming language is a typical example of such a situation as it\nconsists of an extension of Java that adds pattern matching, more particularly\nassociative pattern matching, and reduction strategies.\n  This paper presents a type system with subtyping for Tom, that is compatible\nwith Java's type system, and that performs both type checking and type\ninference. We propose an algorithm that checks if all patterns of a Tom program\nare well-typed. In addition, we propose an algorithm based on equality and\nsubtyping constraints that infers types of variables occurring in a pattern.\nBoth algorithms are exemplified and the proposed type system is showed to be\nsound and complete.\n", "versions": [{"version": "v1", "created": "Thu, 25 Mar 2010 04:37:27 GMT"}], "update_date": "2010-03-26", "authors_parsed": [["Kirchner", "Claude", ""], ["Moreau", "Pierre-Etienne", ""], ["Tavares", "Cl\u00e1udia", ""]]}, {"id": "1003.4800", "submitter": "Gabriel Falconieri Freitas", "authors": "Gabriel Falconieri Freitas, M\\'arcio Corn\\'elio, Tiago Massoni, Rohit\n  Gheyi", "title": "Object-oriented Programming Laws for Annotated Java Programs", "comments": null, "journal-ref": "EPTCS 21, 2010, pp. 65-76", "doi": "10.4204/EPTCS.21.6", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Object-oriented programming laws have been proposed in the context of\nlanguages that are not combined with a behavioral interface specification\nlanguage (BISL). The strong dependence between source-code and interface\nspecifications may cause a number of difficulties when transforming programs.\nIn this paper we introduce a set of programming laws for object-oriented\nlanguages like Java combined with the Java Modeling Language (JML). The set of\nlaws deals with object-oriented features taking into account their\nspecifications. Some laws deal only with features of the specification\nlanguage. These laws constitute a set of small transformations for the\ndevelopment of more elaborate ones like refactorings.\n", "versions": [{"version": "v1", "created": "Thu, 25 Mar 2010 04:40:43 GMT"}], "update_date": "2010-04-08", "authors_parsed": [["Freitas", "Gabriel Falconieri", ""], ["Corn\u00e9lio", "M\u00e1rcio", ""], ["Massoni", "Tiago", ""], ["Gheyi", "Rohit", ""]]}, {"id": "1003.5197", "submitter": "Ronald Garcia", "authors": "Ronald Garcia (Carnegie Mellon University), Andrew Lumsdaine (Indiana\n  University), Amr Sabry (Indiana University)", "title": "Lazy Evaluation and Delimited Control", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (July 11,\n  2010) lmcs:1013", "doi": "10.2168/LMCS-6(3:1)2010", "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The call-by-need lambda calculus provides an equational framework for\nreasoning syntactically about lazy evaluation. This paper examines its\noperational characteristics. By a series of reasoning steps, we systematically\nunpack the standard-order reduction relation of the calculus and discover a\nnovel abstract machine definition which, like the calculus, goes \"under\nlambdas.\" We prove that machine evaluation is equivalent to standard-order\nevaluation. Unlike traditional abstract machines, delimited control plays a\nsignificant role in the machine's behavior. In particular, the machine replaces\nthe manipulation of a heap using store-based effects with disciplined\nmanagement of the evaluation stack using control-based effects. In short, state\nis replaced with control. To further articulate this observation, we present a\nsimulation of call-by-need in a call-by-value language using delimited control\noperations.\n", "versions": [{"version": "v1", "created": "Fri, 26 Mar 2010 18:23:35 GMT"}, {"version": "v2", "created": "Mon, 29 Mar 2010 22:02:11 GMT"}, {"version": "v3", "created": "Sun, 11 Jul 2010 14:31:58 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Garcia", "Ronald", "", "Carnegie Mellon University"], ["Lumsdaine", "Andrew", "", "Indiana\n  University"], ["Sabry", "Amr", "", "Indiana University"]]}, {"id": "1003.5350", "submitter": "Ian Mackie", "authors": "Daniel J. Dougherty", "title": "An Improved Algorithm for Generating Database Transactions from\n  Relational Algebra Specifications", "comments": null, "journal-ref": "EPTCS 21, 2010, pp. 77-89", "doi": "10.4204/EPTCS.21.7", "report-no": null, "categories": "cs.DB cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Alloy is a lightweight modeling formalism based on relational algebra. In\nprior work with Fisler, Giannakopoulos, Krishnamurthi, and Yoo, we have\npresented a tool, Alchemy, that compiles Alloy specifications into\nimplementations that execute against persistent databases. The foundation of\nAlchemy is an algorithm for rewriting relational algebra formulas into code for\ndatabase transactions. In this paper we report on recent progress in improving\nthe robustness and efficiency of this transformation.\n", "versions": [{"version": "v1", "created": "Sun, 28 Mar 2010 08:11:05 GMT"}], "update_date": "2010-03-31", "authors_parsed": [["Dougherty", "Daniel J.", ""]]}, {"id": "1003.5513", "submitter": "EPTCS", "authors": "Edsko de Vries, Adrian Francalanza, Matthew Hennessy", "title": "Uniqueness Typing for Resource Management in Message-Passing Concurrency", "comments": null, "journal-ref": "EPTCS 22, 2010, pp. 26-37", "doi": "10.4204/EPTCS.22.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We view channels as the main form of resources in a message-passing\nprogramming paradigm. These channels need to be carefully managed in settings\nwhere resources are scarce. To study this problem, we extend the pi-calculus\nwith primitives for channel allocation and deallocation and allow channels to\nbe reused to communicate values of different types. Inevitably, the added\nexpressiveness increases the possibilities for runtime errors. We define a\nsubstructural type system which combines uniqueness typing and affine typing to\nreject these ill-behaved programs.\n", "versions": [{"version": "v1", "created": "Mon, 29 Mar 2010 12:01:45 GMT"}], "update_date": "2010-04-08", "authors_parsed": [["de Vries", "Edsko", ""], ["Francalanza", "Adrian", ""], ["Hennessy", "Matthew", ""]]}, {"id": "1003.5518", "submitter": "EPTCS", "authors": "A. Bucciarelli, A. Carraro, T. Ehrhard, A. Salibra", "title": "On Linear Information Systems", "comments": null, "journal-ref": "EPTCS 22, 2010, pp. 38-48", "doi": "10.4204/EPTCS.22.4", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Scott's information systems provide a categorically equivalent, intensional\ndescription of Scott domains and continuous functions. Following a well\nestablished pattern in denotational semantics, we define a linear version of\ninformation systems, providing a model of intuitionistic linear logic (a\nnew-Seely category), with a \"set-theoretic\" interpretation of exponentials that\nrecovers Scott continuous functions via the co-Kleisli construction. From a\ndomain theoretic point of view, linear information systems are equivalent to\nprime algebraic Scott domains, which in turn generalize prime algebraic\nlattices, already known to provide a model of classical linear logic.\n", "versions": [{"version": "v1", "created": "Mon, 29 Mar 2010 12:13:18 GMT"}], "update_date": "2010-04-08", "authors_parsed": [["Bucciarelli", "A.", ""], ["Carraro", "A.", ""], ["Ehrhard", "T.", ""], ["Salibra", "A.", ""]]}, {"id": "1003.5758", "submitter": "EPTCS", "authors": "Ian Mackie, Anamaria Martins Moreira", "title": "Proceedings Tenth International Workshop on Rule-Based Programming", "comments": null, "journal-ref": "EPTCS 21, 2010", "doi": "10.4204/EPTCS.21", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of RULE 2009: the tenth International\nWorkshop on Rule-Based Programming. It took place in June 28th 2009, Brasilia,\nBrazil, as a satellite event of RDP 2009. The first Rule workshop was held in\nMontreal in 2000, and subsequent editions took place in Firenze, Pittsburgh,\nValencia, Aachen, Nara, Seattle, Paris, and Hagenberg.\n", "versions": [{"version": "v1", "created": "Tue, 30 Mar 2010 08:11:40 GMT"}], "update_date": "2010-04-08", "authors_parsed": [["Mackie", "Ian", ""], ["Moreira", "Anamaria Martins", ""]]}, {"id": "1003.5954", "submitter": "Adam  Megacz", "authors": "Adam Megacz", "title": "Multi-Stage Programs are Generalized Arrows", "comments": "This paper is obsolete and has been superceded by {\\it Multi-Level\n  Programs are Generalized Arrows} available here:\n  http://arxiv.org/pdf/1007.2885", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The lambda calculus, subject to typing restrictions, provides a syntax for\nthe internal language of cartesian closed categories. This paper establishes a\nparallel result: staging annotations, subject to named level restrictions,\nprovide a syntax for the internal language of Freyd categories, which are known\nto be in bijective correspondence with Arrows. The connection is made by\ninterpreting multi-stage type systems as indexed functors from polynomial\ncategories to their reindexings. This result applies only to multi-stage\nlanguages which are (1) homogeneous, (2) allow cross-stage persistence and (3)\nplace no restrictions on the use of structural rules in typing derivations.\nRemoving these restrictions and repeating the construction yields generalized\narrows, of which Arrows are a particular case. A translation from well-typed\nmulti-stage programs to single-stage GArrow terms is provided. The translation\nis defined by induction on the structure of the proof that the multi-stage\nprogram is well-typed, relying on information encoded in the proof's use of\nstructural rules. Metalanguage designers can now factor out the syntactic\nmachinery of metaprogramming by providing a single translation from staging\nsyntax into expressions of generalized arrow type. Object language providers\nneed only implement the functions of the generalized arrow type class in\npoint-free style. Object language users may write metaprograms over these\nobject languages in a point-ful style, using the same binding, scoping,\nabstraction, and application mechanisms in both the object language and\nmetalanguage. This paper's principal contributions are the GArrow definition of\nFigures 2 and 3, the translation in Figure 5 and the category-theoretic\nsemantics of Definition 16. An accompanying Coq proof formalizes the type\nsystem, translation procedure, and key theorems.\n", "versions": [{"version": "v1", "created": "Wed, 31 Mar 2010 00:42:30 GMT"}, {"version": "v2", "created": "Sat, 3 Apr 2010 06:27:38 GMT"}, {"version": "v3", "created": "Thu, 30 Sep 2010 20:40:44 GMT"}], "update_date": "2015-03-13", "authors_parsed": [["Megacz", "Adam", ""]]}]