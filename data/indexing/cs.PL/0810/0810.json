[{"id": "0810.0372", "submitter": "Luis Veiga", "authors": "Filipe Cabecinhas and Nuno Lopes and Renato Crisostomo and Luis Veiga", "title": "Optimizing Binary Code Produced by Valgrind (Project Report on Virtual\n  Execution Environments Course - AVExe)", "comments": "Technical report from INESC-ID Lisboa describing optimizations to\n  code generation of the Valgring execution environment. Work developed in the\n  context of a Virtual Execution Environments course (AVExe) at IST/Technical\n  university of Lisbon", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Valgrind is a widely used framework for dynamic binary instrumentation and\nits mostly known by its memcheck tool. Valgrind's code generation module is far\nfrom producing optimal code. In addition it has many backends for different CPU\narchitectures, which difficults code optimization in an architecture\nindependent way. Our work focused on identifying sub-optimal code produced by\nValgrind and optimizing it.\n", "versions": [{"version": "v1", "created": "Thu, 2 Oct 2008 09:41:52 GMT"}], "update_date": "2008-10-03", "authors_parsed": [["Cabecinhas", "Filipe", ""], ["Lopes", "Nuno", ""], ["Crisostomo", "Renato", ""], ["Veiga", "Luis", ""]]}, {"id": "0810.0753", "submitter": "Stefano Soffia", "authors": "Stefano Soffia", "title": "Definition and Implementation of a Points-To Analysis for C-like\n  Languages", "comments": "135 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The points-to problem is the problem of determining the possible run-time\ntargets of pointer variables and is usually considered part of the more general\naliasing problem, which consists in establishing whether and when different\nexpressions can refer to the same memory address. Aliasing information is\nessential to every tool that needs to reason about the semantics of programs.\nHowever, due to well-known undecidability results, for all interesting\nlanguages that admit aliasing, the exact solution of nontrivial aliasing\nproblems is not generally computable. This work focuses on approximated\nsolutions to this problem by presenting a store-based, flow-sensitive points-to\nanalysis, for applications in the field of automated software verification. In\ncontrast to software testing procedures, which heuristically check the program\nagainst a finite set of executions, the methods considered in this work are\nstatic analyses, where the computed results are valid for all the possible\nexecutions of the analyzed program. We present a simplified programming\nlanguage and its execution model; then an approximated execution model is\ndeveloped using the ideas of abstract interpretation theory. Finally, the\nsoundness of the approximation is formally proved. The aim of developing a\nrealistic points-to analysis is pursued by presenting some extensions to the\ninitial simplified model and discussing the correctness of their formulation.\nThis work contains original contributions to the issue of points-to analysis,\nas it provides a formulation of a filter operation on the points-to abstract\ndomain and a formal proof of the soundness of the defined abstract operations:\nthese, as far as we now, are lacking from the previous literature.\n", "versions": [{"version": "v1", "created": "Sat, 4 Oct 2008 10:34:09 GMT"}], "update_date": "2008-10-07", "authors_parsed": [["Soffia", "Stefano", ""]]}, {"id": "0810.1106", "submitter": "Kees Middelburg", "authors": "J.A. Bergstra, C.A. Middelburg", "title": "On the expressiveness of single-pass instruction sequences", "comments": "14 pages; error corrected, acknowledgement added; another error\n  corrected, another acknowledgement added", "journal-ref": "Theory of Computing Systems, 50(2):313--328, 2012", "doi": "10.1007/s00224-010-9301-8", "report-no": "PRG0813", "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We perceive programs as single-pass instruction sequences. A single-pass\ninstruction sequence under execution is considered to produce a behaviour to be\ncontrolled by some execution environment. Threads as considered in basic thread\nalgebra model such behaviours. We show that all regular threads, i.e. threads\nthat can only be in a finite number of states, can be produced by single-pass\ninstruction sequences without jump instructions if use can be made of Boolean\nregisters. We also show that, in the case where goto instructions are used\ninstead of jump instructions, a bound to the number of labels restricts the\nexpressiveness.\n", "versions": [{"version": "v1", "created": "Tue, 7 Oct 2008 06:51:53 GMT"}, {"version": "v2", "created": "Fri, 19 Dec 2008 08:28:59 GMT"}, {"version": "v3", "created": "Tue, 13 Jan 2009 08:14:05 GMT"}], "update_date": "2012-01-12", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0810.1151", "submitter": "Alban Ponse", "authors": "Jan A. Bergstra and Alban Ponse", "title": "Periodic Single-Pass Instruction Sequences", "comments": "16 pages, 3 tables, New title", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A program is a finite piece of data that produces a (possibly infinite)\nsequence of primitive instructions. From scratch we develop a linear notation\nfor sequential, imperative programs, using a familiar class of primitive\ninstructions and so-called repeat instructions, a particular type of control\ninstructions. The resulting mathematical structure is a semigroup. We relate\nthis set of programs to program algebra (PGA) and show that a particular\nsubsemigroup is a carrier for PGA by providing axioms for single-pass\ncongruence, structural congruence, and thread extraction. This subsemigroup\ncharacterizes periodic single-pass instruction sequences and provides a direct\nbasis for PGA's toolset.\n", "versions": [{"version": "v1", "created": "Tue, 7 Oct 2008 13:55:21 GMT"}, {"version": "v2", "created": "Tue, 16 Apr 2013 12:11:12 GMT"}], "update_date": "2013-04-17", "authors_parsed": [["Bergstra", "Jan A.", ""], ["Ponse", "Alban", ""]]}, {"id": "0810.3332", "submitter": "Gheorghe Stefanescu", "authors": "Cezara Dragoi and Gheorghe Stefanescu", "title": "A sound spatio-temporal Hoare logic for the verification of structured\n  interactive programs with registers and voices", "comments": "21 pages, 8 figures, Invited submission for WADT'08 LNCS Proceedings", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Interactive systems with registers and voices (shortly, \"rv-systems\") are a\nmodel for interactive computing obtained closing register machines with respect\nto a space-time duality transformation (\"voices\" are the time-dual counterparts\nof \"registers\"). In the same vain, AGAPIA v0.1, a structured programming\nlanguage for rv-systems, is the space-time dual closure of classical while\nprograms (over a specific type of data). Typical AGAPIA programs describe open\nprocesses located at various sites and having their temporal windows of\nadequate reaction to the environment. The language naturally supports process\nmigration, structured interaction, and deployment of components on\nheterogeneous machines.\n  In this paper a sound Hoare-like spatio-temporal logic for the verification\nof AGAPIA v0.1 programs is introduced. As a case study, a formal verification\nproof of a popular distributed termination detection protocol is presented.\n", "versions": [{"version": "v1", "created": "Sun, 19 Oct 2008 00:05:20 GMT"}], "update_date": "2008-10-21", "authors_parsed": [["Dragoi", "Cezara", ""], ["Stefanescu", "Gheorghe", ""]]}, {"id": "0810.3468", "submitter": "Muthiah Annamalai", "authors": "Muthiah Annamalai, Leela Velusamy", "title": "A Call-Graph Profiler for GNU Octave", "comments": "6 pages, 2 figures, 1 table. Fix typos", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PF cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We report the design and implementation of a call-graph profiler for GNU\nOctave, a numerical computing platform. GNU Octave simplifies matrix\ncomputation for use in modeling or simulation. Our work provides a call-graph\nprofiler, which is an improvement on the flat profiler. We elaborate design\nconstraints of building a profiler for numerical computation, and benchmark the\nprofiler by comparing it to the rudimentary timer start-stop (tic-toc)\nmeasurements, for a similar set of programs. The profiler code provides clean\ninterfaces to internals of GNU Octave, for other (newer) profiling tools on GNU\nOctave.\n", "versions": [{"version": "v1", "created": "Mon, 20 Oct 2008 08:29:21 GMT"}], "update_date": "2008-10-21", "authors_parsed": [["Annamalai", "Muthiah", ""], ["Velusamy", "Leela", ""]]}, {"id": "0810.4419", "submitter": "Tom Hirschowitz", "authors": "Tom Hirschowitz (LAMA), Aur\\'elien Pardon (LIP)", "title": "Binding bigraphs as symmetric monoidal closed theories", "comments": "17 pages, uses Paul Taylor's diagrams", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Milner's bigraphs are a general framework for reasoning about distributed and\nconcurrent programming languages. Notably, it has been designed to encompass\nboth the pi-calculus and the Ambient calculus. This paper is only concerned\nwith bigraphical syntax: given what we here call a bigraphical signature K,\nMilner constructs a (pre-) category of bigraphs BBig(K), whose main features\nare (1) the presence of relative pushouts (RPOs), which makes them well-behaved\nw.r.t. bisimulations, and that (2) the so-called structural equations become\nequalities. Examples of the latter include, e.g., in pi and Ambient, renaming\nof bound variables, associativity and commutativity of parallel composition, or\nscope extrusion for restricted names. Also, bigraphs follow a scoping\ndiscipline ensuring that, roughly, bound variables never escape their scope.\nHere, we reconstruct bigraphs using a standard categorical tool: symmetric\nmonoidal closed (SMC) theories. Our theory enforces the same scoping discipline\nas bigraphs, as a direct property of SMC structure. Furthermore, it elucidates\nthe slightly mysterious status of so-called links in bigraphs. Finally, our\ncategory is also considerably larger than the category of bigraphs, notably\nencompassing in the same framework terms and a flexible form of higher-order\ncontexts.\n", "versions": [{"version": "v1", "created": "Fri, 24 Oct 2008 09:33:08 GMT"}, {"version": "v2", "created": "Mon, 8 Jun 2009 11:56:55 GMT"}], "update_date": "2009-06-08", "authors_parsed": [["Hirschowitz", "Tom", "", "LAMA"], ["Pardon", "Aur\u00e9lien", "", "LIP"]]}, {"id": "0810.4451", "submitter": "Herv\\'e Paulino", "authors": "Herve Paulino and Luis Lopes", "title": "The Mob core language and abstract machine (rev 0.2)", "comments": "33 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most current mobile agent systems are based on programming languages whose\nsemantics are difficult to prove correct as they lack an adequate underlying\nformal theory. In recent years, the development of the theory of concurrent\nsystems, namely of process calculi, has allowed for the first time the modeling\nof mobile agent systems.Languages directly based on process calculi are,\nhowever, very low-level and it is desirable to provide the programmer with\nhigher level abstractions, while keeping the semantics of the base calculus.\n  In this technical report we present the syntax and the semantics of a\nscripting language for programming mobile agents called Mob. We describe the\nlanguage's syntax and semantics. Mob is service-oriented, meaning that agents\nact both as servers and as clients of services and that this coupling is done\ndynamically at run-time. The language is implemented on top of a process\ncalculus which allows us to prove that the framework is sound by encoding its\nsemantics into the underlying calculus. This provides a form of language\nsecurity not available to other mobile agent languages developed using a more\nah-doc approach.\n", "versions": [{"version": "v1", "created": "Fri, 24 Oct 2008 15:02:09 GMT"}], "update_date": "2008-10-27", "authors_parsed": [["Paulino", "Herve", ""], ["Lopes", "Luis", ""]]}, {"id": "0810.4460", "submitter": "Pierre Genev\\`es", "authors": "Pierre Geneves", "title": "Logics for XML", "comments": "Ph.D. dissertation, defended on December 4th, 2006", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DB cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This thesis describes the theoretical and practical foundations of a system\nfor the static analysis of XML processing languages. The system relies on a\nfixpoint temporal logic with converse, derived from the mu-calculus, where\nmodels are finite trees. This calculus is expressive enough to capture regular\ntree types along with multi-directional navigation in trees, while having a\nsingle exponential time complexity. Specifically the decidability of the logic\nis proved in time 2^O(n) where n is the size of the input formula.\n  Major XML concepts are linearly translated into the logic: XPath navigation\nand node selection semantics, and regular tree languages (which include DTDs\nand XML Schemas). Based on these embeddings, several problems of major\nimportance in XML applications are reduced to satisfiability of the logic.\nThese problems include XPath containment, emptiness, equivalence, overlap,\ncoverage, in the presence or absence of regular tree type constraints, and the\nstatic type-checking of an annotated query.\n  The focus is then given to a sound and complete algorithm for deciding the\nlogic, along with a detailed complexity analysis, and crucial implementation\ntechniques for building an effective solver. Practical experiments using a full\nimplementation of the system are presented. The system appears to be efficient\nin practice for several realistic scenarios.\n  The main application of this work is a new class of static analyzers for\nprogramming languages using both XPath expressions and XML type annotations\n(input and output). Such analyzers allow to ensure at compile-time valuable\nproperties such as type-safety and optimizations, for safer and more efficient\nXML processing.\n", "versions": [{"version": "v1", "created": "Fri, 24 Oct 2008 13:40:11 GMT"}, {"version": "v2", "created": "Sat, 24 May 2014 06:02:29 GMT"}], "update_date": "2014-05-27", "authors_parsed": [["Geneves", "Pierre", ""]]}, {"id": "0810.5575", "submitter": "Renat Nuriyev", "authors": "R. Nuriyev", "title": "Detection of parallel steps in programs with arrays", "comments": "13 pages, 5 figurers", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of detecting of information and logically independent (DILD)\nsteps in programs is a key for equivalent program transformations. Here we are\nconsidering the problem of independence of loop iterations, the concentration\nof massive data processing and hence the most challenge construction for\nparallelizing. We introduced a separated form of loops when loop's body is a\nsequence of procedures each of them are used array's elements selected in a\nprevious procedure. We prove that any loop may be algorithmically represented\nin this form and number of such procedures is invariant. We show that for this\nform of loop the steps connections are determined with some integer equations\nand hence the independence problem is algorithmically unsolvable if index\nexpressions are more complex than cubical. We suggest a modification of index\nsemantics that made connection equations trivial and loops iterations can be\nexecuted in parallel.\n", "versions": [{"version": "v1", "created": "Thu, 30 Oct 2008 20:48:49 GMT"}], "update_date": "2008-11-03", "authors_parsed": [["Nuriyev", "R.", ""]]}]