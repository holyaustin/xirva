[{"id": "0707.0926", "submitter": "Yves Bertot", "authors": "Yves Bertot (INRIA Sophia Antipolis)", "title": "Theorem proving support in programming language semantics", "comments": "Propos\\'e pour publication dans l'ouvrage \\`a la m\\'emoire de Gilles\n  Kahn", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": null, "abstract": "  We describe several views of the semantics of a simple programming language\nas formal documents in the calculus of inductive constructions that can be\nverified by the Coq proof system. Covered aspects are natural semantics,\ndenotational semantics, axiomatic semantics, and abstract interpretation.\nDescriptions as recursive functions are also provided whenever suitable, thus\nyielding a a verification condition generator and a static analyser that can be\nrun inside the theorem prover for use in reflective proofs. Extraction of an\ninterpreter from the denotational semantics is also described. All different\naspects are formally proved sound with respect to the natural semantics\nspecification.\n", "versions": [{"version": "v1", "created": "Fri, 6 Jul 2007 08:55:26 GMT"}, {"version": "v2", "created": "Tue, 10 Jul 2007 08:09:49 GMT"}], "update_date": "2007-07-10", "authors_parsed": [["Bertot", "Yves", "", "INRIA Sophia Antipolis"]]}, {"id": "0707.1059", "submitter": "Alban Ponse", "authors": "Jan A. Bergstra and Alban Ponse", "title": "Projection semantics for rigid loops", "comments": "20 pages", "journal-ref": null, "doi": null, "report-no": "PRG0604", "categories": "cs.PL", "license": null, "abstract": "  A rigid loop is a for-loop with a counter not accessible to the loop body or\nany other part of a program. Special instructions for rigid loops are\nintroduced on top of the syntax of the program algebra PGA. Two different\nsemantic projections are provided and proven equivalent. One of these is taken\nto have definitional status on the basis of two criteria: `normative semantic\nadequacy' and `indicative algorithmic adequacy'.\n", "versions": [{"version": "v1", "created": "Fri, 6 Jul 2007 23:58:45 GMT"}], "update_date": "2007-07-10", "authors_parsed": [["Bergstra", "Jan A.", ""], ["Ponse", "Alban", ""]]}, {"id": "0707.1432", "submitter": "Jean-Guillaume Dumas", "authors": "Jean-Guillaume Dumas (LJK), Dominique Duval (LJK), Jean-Claude Reynaud\n  (RC)", "title": "Sequential products in effect categories", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.PL", "license": null, "abstract": "  A new categorical framework is provided for dealing with multiple arguments\nin a programming language with effects, for example in a language with\nimperative features. Like related frameworks (Monads, Arrows, Freyd\ncategories), we distinguish two kinds of functions. In addition, we also\ndistinguish two kinds of equations. Then, we are able to define a kind of\nproduct, that generalizes the usual categorical product. This yields a powerful\ntool for deriving many results about languages with effects.\n", "versions": [{"version": "v1", "created": "Tue, 10 Jul 2007 12:50:35 GMT"}], "update_date": "2007-07-11", "authors_parsed": [["Dumas", "Jean-Guillaume", "", "LJK"], ["Duval", "Dominique", "", "LJK"], ["Reynaud", "Jean-Claude", "", "RC"]]}, {"id": "0707.1527", "submitter": "Anya Tafliovich", "authors": "Anya Tafliovich, Eric C.R. Hehner", "title": "Programming Telepathy: Implementing Quantum Non-Locality Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Quantum pseudo-telepathy is an intriguing phenomenon which results from the\napplication of quantum information theory to communication complexity. To\ndemonstrate this phenomenon researchers in the field of quantum communication\ncomplexity devised a number of quantum non-locality games. The setting of these\ngames is as follows: the players are separated so that no communication between\nthem is possible and are given a certain computational task. When the players\nhave access to a quantum resource called entanglement, they can accomplish the\ntask: something that is impossible in a classical setting. To an observer who\nis unfamiliar with the laws of quantum mechanics it seems that the players\nemploy some sort of telepathy; that is, they somehow exchange information\nwithout sharing a communication channel. This paper provides a formal framework\nfor specifying, implementing, and analysing quantum non-locality games.\n", "versions": [{"version": "v1", "created": "Wed, 11 Jul 2007 19:50:25 GMT"}, {"version": "v2", "created": "Wed, 29 Jul 2009 15:25:07 GMT"}], "update_date": "2009-07-29", "authors_parsed": [["Tafliovich", "Anya", ""], ["Hehner", "Eric C. R.", ""]]}, {"id": "0707.3807", "submitter": "Catherine Recanati", "authors": "Catherine Recanati (LIPN)", "title": "How to be correct, lazy and efficient ?", "comments": "21 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL", "license": null, "abstract": "  This paper is an introduction to Lambdix, a lazy Lisp interpreter implemented\nat the Research Laboratory of Paris XI University (Laboratoire de Recherche en\nInformatique, Orsay). Lambdix was devised in the course of an investigation\ninto the relationship between the semantics of programming languages and their\nimplementation; it was used to demonstrate that in the Lisp domain, semantic\ncorrectness is consistent with efficiency, contrary to what has often been\nclaimed. The first part of the paper is an overview of well-known semantic\ndifficulties encountered by Lisp as well as an informal presentation of\nLambdix; it is shown that the difficulties which Lisp encouters do not arise in\nLambdix. The second part is about efficiency in implementation models. It\nexplains why Lambdix is better suited for lazy evaluation than previous models.\nThe section ends by giving comparative execution time tables.\n", "versions": [{"version": "v1", "created": "Wed, 25 Jul 2007 19:33:07 GMT"}], "update_date": "2007-07-26", "authors_parsed": [["Recanati", "Catherine", "", "LIPN"]]}, {"id": "0707.4389", "submitter": "Sandrine Blazy", "authors": "Andrew W. Appel (INRIA Rocquencourt), Sandrine Blazy (CEDRIC, INRIA\n  Rocquencourt)", "title": "Separation Logic for Small-step Cminor", "comments": "Version courte du rapport de recherche RR-6138", "journal-ref": "Dans 20th Int. Conference on Theorem Proving in Higher Order\n  Logics (TPHOLs 2007) 4732 (2007) 5-21", "doi": null, "report-no": null, "categories": "cs.PL", "license": null, "abstract": "  Cminor is a mid-level imperative programming language; there are\nproved-correct optimizing compilers from C to Cminor and from Cminor to machine\nlanguage. We have redesigned Cminor so that it is suitable for Hoare Logic\nreasoning and we have designed a Separation Logic for Cminor. In this paper, we\ngive a small-step semantics (instead of the big-step of the proved-correct\ncompiler) that is motivated by the need to support future concurrent\nextensions. We detail a machine-checked proof of soundness of our Separation\nLogic. This is the first large-scale machine-checked proof of a Separation\nLogic w.r.t. a small-step semantics. The work presented in this paper has been\ncarried out in the Coq proof assistant. It is a first step towards an\nenvironment in which concurrent Cminor programs can be verified using\nSeparation Logic and also compiled by a proved-correct compiler with formal\nend-to-end correctness guarantees.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jul 2007 12:09:16 GMT"}], "update_date": "2007-07-31", "authors_parsed": [["Appel", "Andrew W.", "", "INRIA Rocquencourt"], ["Blazy", "Sandrine", "", "CEDRIC, INRIA\n  Rocquencourt"]]}]