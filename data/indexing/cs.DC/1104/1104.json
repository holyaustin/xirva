[{"id": "1104.0043", "submitter": "Guanfeng Liang", "authors": "Guanfeng Liang and Nitin Vaidya", "title": "Capacity of Byzantine Consensus with Capacity-Limited Point-to-Point\n  Links", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problem of maximizing the throughput of Byzantine consensus,\nwhen communication links have finite capacity. Byzantine consensus is a\nclassical problem in distributed computing. In existing literature, the\ncommunication links are implicitly assumed to have infinite capacity. The\nproblem changes significantly when the capacity of links is finite. We define\nthe throughput and capacity of consensus, and identify upper bound of\nachievable consensus throughput. We propose an algorithm that achieves\nconsensus capacity in complete four-node networks with at most 1 failure with\narbitrary distribution of link capacities.\n", "versions": [{"version": "v1", "created": "Thu, 31 Mar 2011 22:00:06 GMT"}], "update_date": "2011-04-04", "authors_parsed": [["Liang", "Guanfeng", ""], ["Vaidya", "Nitin", ""]]}, {"id": "1104.0198", "submitter": "Boris D. Lubachevsky", "authors": "Boris D. Lubachevsky", "title": "Why The Results of Parallel and Serial Monte Carlo Simulations May\n  Differ", "comments": "2 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parallel Monte Carlo simulations often expose faults in random number\ngenerators\n", "versions": [{"version": "v1", "created": "Fri, 1 Apr 2011 15:26:43 GMT"}], "update_date": "2011-04-04", "authors_parsed": [["Lubachevsky", "Boris D.", ""]]}, {"id": "1104.0882", "submitter": "Amitabh Trehan", "authors": "Gopal Pandurangan and Amitabh Trehan", "title": "Xheal: Localized Self-healing using Expanders", "comments": "A shorter version of this to be presented at PODC, 2011, San Jose, CA", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DC cs.NI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problem of self-healing in reconfigurable networks (e.g.\npeer-to-peer and wireless mesh networks) that are under repeated attack by an\nomniscient adversary and propose a fully distributed algorithm, Xheal that\nmaintains good expansion and spectral properties of the network, also keeping\nthe network connected. Moreover, Xheal does this while allowing only low\nstretch and degree increase per node. Thus, the algorithm heals global\nproperties while only doing local changes and using only local information.\n  Our work improves over the self-healing algorithms 'Forgiving tree'[PODC\n2008] and 'Forgiving graph'[PODC 2009] (using a similar model) in that we are\nable to give guarantees on degree and stretch, while at the same time\npreserving the expansion and spectral properties of the network. These repairs\npreserve the invariants in the following sense. At any point in the algorithm,\nthe expansion of the graph will be either `better' than the expansion of the\ngraph formed by considering only the adversarial insertions (not the\nadversarial deletions) or the expansion will be, at least, a constant. Also,\nthe stretch i.e. the distance between any pair of nodes in the healed graph is\nno more than a $O(\\log n)$ factor. Similarly, at any point, a node $v$ whose\ndegree would have been $d$ in the graph with adversarial insertions only, will\nhave degree at most $O(\\kappa d)$ in the actual graph, for a small parameter\n$\\kappa$. We also provide bounds on the second smallest eigenvalue of the\nLaplacian which captures key properties such as mixing time, conductance,\ncongestion in routing etc. Our distributed data structure has low amortized\nlatency and bandwidth requirements.\n", "versions": [{"version": "v1", "created": "Tue, 5 Apr 2011 16:24:16 GMT"}], "update_date": "2011-04-06", "authors_parsed": [["Pandurangan", "Gopal", ""], ["Trehan", "Amitabh", ""]]}, {"id": "1104.1824", "submitter": "Francis Cabarle", "authors": "Francis Cabarle, Henry Adorna, Miguel A. Martinez-del-Amor", "title": "Simulating Spiking Neural P systems without delays using GPUs", "comments": "19 pages in total, 4 figures, listings/algorithms, submitted at the\n  9th Brainstorming Week in Membrane Computing, University of Seville, Spain", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.ET cs.FL cs.NE q-bio.NC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present in this paper our work regarding simulating a type of P system\nknown as a spiking neural P system (SNP system) using graphics processing units\n(GPUs). GPUs, because of their architectural optimization for parallel\ncomputations, are well-suited for highly parallelizable problems. Due to the\nadvent of general purpose GPU computing in recent years, GPUs are not limited\nto graphics and video processing alone, but include computationally intensive\nscientific and mathematical applications as well. Moreover P systems, including\nSNP systems, are inherently and maximally parallel computing models whose\ninspirations are taken from the functioning and dynamics of a living cell. In\nparticular, SNP systems try to give a modest but formal representation of a\nspecial type of cell known as the neuron and their interactions with one\nanother. The nature of SNP systems allowed their representation as matrices,\nwhich is a crucial step in simulating them on highly parallel devices such as\nGPUs. The highly parallel nature of SNP systems necessitate the use of hardware\nintended for parallel computations. The simulation algorithms, design\nconsiderations, and implementation are presented. Finally, simulation results,\nobservations, and analyses using an SNP system that generates all numbers in\n$\\mathbb N$ - {1} are discussed, as well as recommendations for future work.\n", "versions": [{"version": "v1", "created": "Mon, 11 Apr 2011 01:17:01 GMT"}], "update_date": "2011-04-13", "authors_parsed": [["Cabarle", "Francis", ""], ["Adorna", "Henry", ""], ["Martinez-del-Amor", "Miguel A.", ""]]}, {"id": "1104.2527", "submitter": "Bernhard Haeupler", "authors": "Bernhard Haeupler, David Karger", "title": "Faster Information Dissemination in Dynamic Networks via Network Coding", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We use network coding to improve the speed of distributed computation in the\ndynamic network model of Kuhn, Lynch and Oshman [STOC '10]. In this model an\nadversary adaptively chooses a new network topology in every round, making even\nbasic distributed computations challenging.\n  Kuhn et al. show that n nodes, each starting with a d-bit token, can\nbroadcast them to all nodes in time O(n^2) using b-bit messages, where b > d +\nlog n. Their algorithms take the natural approach of {token forwarding}: in\nevery round each node broadcasts some particular token it knows. They prove\nmatching Omega(n^2) lower bounds for a natural class of token forwarding\nalgorithms and an Omega(n log n) lower bound that applies to all\ntoken-forwarding algorithms.\n  We use network coding, transmitting random linear combinations of tokens, to\nbreak both lower bounds. Our algorithm's performance is quadratic in the\nmessage size b, broadcasting the n tokens in roughly d/b^2 * n^2 rounds. For b\n= d = O(log n) our algorithms use O(n^2/log n) rounds, breaking the first lower\nbound, while for larger message sizes we obtain linear-time algorithms. We also\nconsider networks that change only every T rounds, and achieve an additional\nfactor T^2 speedup. This contrasts with related lower and upper bounds of Kuhn\net al. implying that for natural token-forwarding algorithms a speedup of T,\nbut not more, can be obtained. Lastly, we give a general way to derandomize\nrandom linear network coding, that also leads to new deterministic information\ndissemination algorithms.\n", "versions": [{"version": "v1", "created": "Wed, 13 Apr 2011 15:16:16 GMT"}], "update_date": "2011-04-14", "authors_parsed": [["Haeupler", "Bernhard", ""], ["Karger", "David", ""]]}, {"id": "1104.2566", "submitter": "Erik Saule", "authors": "Erik Saule and Erdeniz \\\"O. Ba\\c{s} and \\\"Umit V. \\c{C}ataly\\\"urek", "title": "Load-Balancing Spatially Located Computations using Rectangular\n  Partitions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Distributing spatially located heterogeneous workloads is an important\nproblem in parallel scientific computing. We investigate the problem of\npartitioning such workloads (represented as a matrix of non-negative integers)\ninto rectangles, such that the load of the most loaded rectangle (processor) is\nminimized. Since finding the optimal arbitrary rectangle-based partition is an\nNP-hard problem, we investigate particular classes of solutions: rectilinear,\njagged and hierarchical. We present a new class of solutions called m-way\njagged partitions, propose new optimal algorithms for m-way jagged partitions\nand hierarchical partitions, propose new heuristic algorithms, and provide\nworst case performance analyses for some existing and new heuristics. Moreover,\nthe algorithms are tested in simulation on a wide set of instances. Results\nshow that two of the algorithms we introduce lead to a much better load balance\nthan the state-of-the-art algorithms. We also show how to design a two-phase\nalgorithm that reaches different time/quality tradeoff.\n", "versions": [{"version": "v1", "created": "Wed, 13 Apr 2011 18:08:57 GMT"}], "update_date": "2011-04-14", "authors_parsed": [["Saule", "Erik", ""], ["Ba\u015f", "Erdeniz \u00d6.", ""], ["\u00c7ataly\u00fcrek", "\u00dcmit V.", ""]]}, {"id": "1104.2732", "submitter": "Gleb Beliakov", "authors": "Gleb Beliakov", "title": "Parallel calculation of the median and order statistics on GPUs with\n  application to robust regression", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.DS math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present and compare various approaches to a classical selection problem on\nGraphics Processing Units (GPUs). The selection problem consists in selecting\nthe $k$-th smallest element from an array of size $n$, called $k$-th order\nstatistic. We focus on calculating the median of a sample, the $n/2$-th order\nstatistic. We introduce a new method based on minimization of a convex\nfunction, and show its numerical superiority when calculating the order\nstatistics of very large arrays on GPUs. We outline an application of this\napproach to efficient estimation of model parameters in high breakdown robust\nregression.\n", "versions": [{"version": "v1", "created": "Thu, 14 Apr 2011 11:44:39 GMT"}], "update_date": "2011-04-15", "authors_parsed": [["Beliakov", "Gleb", ""]]}, {"id": "1104.2944", "submitter": "Petar Maymounkov", "authors": "Keren Censor-Hillel, Bernhard Haeupler, Jonathan A. Kelner and Petar\n  Maymounkov", "title": "Global Computation in a Poorly Connected World: Fast Rumor Spreading\n  with No Dependence on Conductance", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.DC cs.SI physics.soc-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we study the question of how efficiently a collection of\ninterconnected nodes can perform a global computation in the widely studied\nGOSSIP model of communication. In this model, nodes do not know the global\ntopology of the network, and they may only initiate contact with a single\nneighbor in each round. This model contrasts with the much less restrictive\nLOCAL model, where a node may simultaneously communicate with all of its\nneighbors in a single round. A basic question in this setting is how many\nrounds of communication are required for the information dissemination problem,\nin which each node has some piece of information and is required to collect all\nothers. In this paper, we give an algorithm that solves the information\ndissemination problem in at most $O(D+\\text{polylog}{(n)})$ rounds in a network\nof diameter $D$, withno dependence on the conductance. This is at most an\nadditive polylogarithmic factor from the trivial lower bound of $D$, which\napplies even in the LOCAL model. In fact, we prove that something stronger is\ntrue: any algorithm that requires $T$ rounds in the LOCAL model can be\nsimulated in $O(T +\\mathrm{polylog}(n))$ rounds in the GOSSIP model. We thus\nprove that these two models of distributed computation are essentially\nequivalent.\n", "versions": [{"version": "v1", "created": "Thu, 14 Apr 2011 23:39:22 GMT"}], "update_date": "2011-04-18", "authors_parsed": [["Censor-Hillel", "Keren", ""], ["Haeupler", "Bernhard", ""], ["Kelner", "Jonathan A.", ""], ["Maymounkov", "Petar", ""]]}, {"id": "1104.3217", "submitter": "Michael Cafarella", "authors": "Eaman Jahani (University of Michigan), Michael J. Cafarella\n  (University of Michigan), Christopher R\\'e (University of Wisconsin-Madison)", "title": "Automatic Optimization for MapReduce Programs", "comments": "VLDB2011", "journal-ref": "Proceedings of the VLDB Endowment (PVLDB), Vol. 4, No. 6, pp.\n  385-396 (2011)", "doi": null, "report-no": null, "categories": "cs.DB cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The MapReduce distributed programming framework has become popular, despite\nevidence that current implementations are inefficient, requiring far more\nhardware than a traditional relational databases to complete similar tasks.\nMapReduce jobs are amenable to many traditional database query optimizations\n(B+Trees for selections, column-store- style techniques for projections, etc),\nbut existing systems do not apply them, substantially because free-form user\ncode obscures the true data operation being performed. For example, a selection\nin SQL is easily detected, but a selection in a MapReduce program is embedded\nin Java code along with lots of other program logic. We could ask the\nprogrammer to provide explicit hints about the program's data semantics, but\none of MapReduce's attractions is precisely that it does not ask the user for\nsuch information. This paper covers Manimal, which automatically analyzes\nMapReduce programs and applies appropriate data- aware optimizations, thereby\nrequiring no additional help at all from the programmer. We show that Manimal\nsuccessfully detects optimization opportunities across a range of data\noperations, and that it yields speedups of up to 1,121% on previously-written\nMapReduce programs.\n", "versions": [{"version": "v1", "created": "Sat, 16 Apr 2011 08:53:59 GMT"}], "update_date": "2011-04-19", "authors_parsed": [["Jahani", "Eaman", "", "University of Michigan"], ["Cafarella", "Michael J.", "", "University of Michigan"], ["R\u00e9", "Christopher", "", "University of Wisconsin-Madison"]]}, {"id": "1104.3876", "submitter": "Michiel W. van Tol", "authors": "Michiel W. van Tol and Juha Koivisto", "title": "Extending and Implementing the Self-adaptive Virtual Processor for\n  Distributed Memory Architectures", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many-core architectures of the future are likely to have distributed memory\norganizations and need fine grained concurrency management to be used\neffectively. The Self-adaptive Virtual Processor (SVP) is an abstract\nconcurrent programming model which can provide this, but the model and its\ncurrent implementations assume a single address space shared memory. We\ninvestigate and extend SVP to handle distributed environments, and discuss a\nprototype SVP implementation which transparently supports execution on\nheterogeneous distributed memory clusters over TCP/IP connections, while\nretaining the original SVP programming model.\n", "versions": [{"version": "v1", "created": "Tue, 19 Apr 2011 20:44:19 GMT"}], "update_date": "2011-04-21", "authors_parsed": [["van Tol", "Michiel W.", ""], ["Koivisto", "Juha", ""]]}, {"id": "1104.3947", "submitter": "Swan Dubois", "authors": "Shlomi Dolev, Swan Dubois (LIP6, INRIA Rocquencourt), Maria\n  Potop-Butucaru (LIP6, INRIA Rocquencourt), S\\'ebastien Tixeuil (LIP6, INRIA\n  Saclay - Ile de France)", "title": "Communication Optimalement Stabilisante sur Canaux non Fiables et non\n  FIFO", "comments": null, "journal-ref": "13es Rencontres Francophones sur les Aspects Algorithmiques de\n  T\\'el\\'ecommunications (AlgoTel) (2011)", "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A self-stabilizing protocol has the capacity to recover a legitimate behavior\nwhatever is its initial state. The majority of works in self-stabilization\nassume a shared memory model or a communication using reliable and FIFO\nchannels. In this article, we interest in self-stabilizing systems using\nbounded but non reliable and non FIFO channels. We propose a stabilizing\ncommunication protocol with optimal fault resilience. In more details, this\nprotocol simulates a reliable and FIFO channel and ensures a minimal number of\nlooses, duplications, creations, and re-ordering of messages.\n", "versions": [{"version": "v1", "created": "Wed, 20 Apr 2011 06:08:34 GMT"}], "update_date": "2011-04-21", "authors_parsed": [["Dolev", "Shlomi", "", "LIP6, INRIA Rocquencourt"], ["Dubois", "Swan", "", "LIP6, INRIA Rocquencourt"], ["Potop-Butucaru", "Maria", "", "LIP6, INRIA Rocquencourt"], ["Tixeuil", "S\u00e9bastien", "", "LIP6, INRIA\n  Saclay - Ile de France"]]}, {"id": "1104.4022", "submitter": "Swan Dubois", "authors": "Swan Dubois (LIP6, INRIA Rocquencourt), Toshimitsu Masuzawa\n  (Department of Information and Computer sciences Osaka University),\n  S\\'ebastien Tixeuil (LIP6, INRIA Saclay - Ile de France)", "title": "Auto-Stabilisation et Confinement de Fautes Malicieuses : Optimalit\\'e\n  du Protocole min+1", "comments": "13es Rencontres Francophones sur les Aspects Algorithmiques de\n  T\\'el\\'ecommunications (AlgoTel) (2011)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A self-stabilizing is naturally resilient to transients faults (that is,\nfaults of finite duration). Recently, a new class of protocol appears. These\nprotocols are self-stabilizing and are moreover resilient to a limited number\nof permanent faults. In this article, we interest in self-stabilizing protocols\nthat tolerate very hard permanent faults: Byzantine faults. We introduce two\nnew scheme of Byzantine containment in self-stabilizing systems. We show that,\nfor the problem of BFS spanning tree construction, the well known\nself-stabilizing protocol min+1 provides without significant modification the\nbest Byzantine containment with respect to these new schemes.\n", "versions": [{"version": "v1", "created": "Wed, 20 Apr 2011 13:45:26 GMT"}], "update_date": "2011-04-21", "authors_parsed": [["Dubois", "Swan", "", "LIP6, INRIA Rocquencourt"], ["Masuzawa", "Toshimitsu", "", "Department of Information and Computer sciences Osaka University"], ["Tixeuil", "S\u00e9bastien", "", "LIP6, INRIA Saclay - Ile de France"]]}, {"id": "1104.4078", "submitter": "Neil J. Gunther", "authors": "Neil J. Gunther", "title": "A Note on Parallel Algorithmic Speedup Bounds", "comments": "5 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A parallel program can be represented as a directed acyclic graph. An\nimportant performance bound is the time to execute the critical path through\nthe graph. We show how this performance metric is related to Amdahl speedup and\nthe degree of average parallelism. These bounds formally exclude superlinear\nperformance.\n", "versions": [{"version": "v1", "created": "Wed, 20 Apr 2011 17:22:34 GMT"}], "update_date": "2011-04-21", "authors_parsed": [["Gunther", "Neil J.", ""]]}, {"id": "1104.4379", "submitter": "Rajkumar Buyya", "authors": "Rajkumar Buyya and Karthik Sukumar", "title": "Platforms for Building and Deploying Applications for Cloud Computing", "comments": "6 pages, 4 figures", "journal-ref": "CSI Communications, Vol.35, No. 1, Pages: 6-11, 2011", "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cloud computing is rapidly emerging as a new paradigm for delivering IT\nservices as utlity-oriented services on subscription-basis. The rapid\ndevelopment of applications and their deployment in Cloud computing\nenvironments in efficient manner is a complex task. In this article, we give a\nbrief introduction to Cloud computing technology and Platform as a Service, we\nexamine the offerings in this category, and provide the basis for helping\nreaders to understand basic application platform opportunities in Cloud by\ntechnologies such as Microsoft Azure, Sales Force, Google App, and Aneka for\nCloud computing. We demonstrate that Manjrasoft Aneka is a Cloud Application\nPlatform (CAP) leveraging these concepts and allowing an easy development of\nCloud ready applications on a Private/Public/Hybrid Cloud. Aneka CAP offers\nfacilities for quickly developing Cloud applications and a modular platform\nwhere additional services can be easily integrated to extend the system\ncapabilities, thus being at pace with the rapidly evolution of Cloud computing.\n", "versions": [{"version": "v1", "created": "Fri, 22 Apr 2011 02:51:54 GMT"}], "update_date": "2011-04-25", "authors_parsed": [["Buyya", "Rajkumar", ""], ["Sukumar", "Karthik", ""]]}, {"id": "1104.4475", "submitter": "Julien Langou", "authors": "Henricus Bouwmeester, Mathias Jacquelin, Julien Langou and Yves Robert", "title": "Tiled QR factorization algorithms", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work revisits existing algorithms for the QR factorization of\nrectangular matrices composed of p-by-q tiles, where p >= q. Within this\nframework, we study the critical paths and performance of algorithms such as\nSameh and Kuck, Modi and Clarke, Greedy, and those found within PLASMA.\nAlthough neither Modi and Clarke nor Greedy is optimal, both are shown to be\nasymptotically optimal for all matrices of size p = q^2 f(q), where f is any\nfunction such that \\lim_{+\\infty} f= 0. This novel and important complexity\nresult applies to all matrices where p and q are proportional, p = \\lambda q,\nwith \\lambda >= 1, thereby encompassing many important situations in practice\n(least squares). We provide an extensive set of experiments that show the\nsuperiority of the new algorithms for tall matrices.\n", "versions": [{"version": "v1", "created": "Fri, 22 Apr 2011 16:45:02 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Bouwmeester", "Henricus", ""], ["Jacquelin", "Mathias", ""], ["Langou", "Julien", ""], ["Robert", "Yves", ""]]}, {"id": "1104.4518", "submitter": "Aydin Buluc", "authors": "Aydin Buluc, Kamesh Madduri", "title": "Parallel Breadth-First Search on Distributed Memory Systems", "comments": null, "journal-ref": "Proceedings of The International Conference for High Performance\n  Computing, Networking, Storage, and Analysis (SC 2011)", "doi": null, "report-no": null, "categories": "cs.DC cs.MS cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Data-intensive, graph-based computations are pervasive in several scientific\napplications, and are known to to be quite challenging to implement on\ndistributed memory systems. In this work, we explore the design space of\nparallel algorithms for Breadth-First Search (BFS), a key subroutine in several\ngraph algorithms. We present two highly-tuned parallel approaches for BFS on\nlarge parallel systems: a level-synchronous strategy that relies on a simple\nvertex-based partitioning of the graph, and a two-dimensional sparse\nmatrix-partitioning-based approach that mitigates parallel communication\noverhead. For both approaches, we also present hybrid versions with intra-node\nmultithreading. Our novel hybrid two-dimensional algorithm reduces\ncommunication times by up to a factor of 3.5, relative to a common vertex based\napproach. Our experimental study identifies execution regimes in which these\napproaches will be competitive, and we demonstrate extremely high performance\non leading distributed-memory parallel systems. For instance, for a 40,000-core\nparallel execution on Hopper, an AMD Magny-Cours based system, we achieve a BFS\nperformance rate of 17.8 billion edge visits per second on an undirected graph\nof 4.3 billion vertices and 68.7 billion edges with skewed degree distribution.\n", "versions": [{"version": "v1", "created": "Fri, 22 Apr 2011 23:42:40 GMT"}, {"version": "v2", "created": "Fri, 14 Oct 2011 03:36:03 GMT"}], "update_date": "2011-10-17", "authors_parsed": [["Buluc", "Aydin", ""], ["Madduri", "Kamesh", ""]]}, {"id": "1104.4874", "submitter": "Jan Treibig", "authors": "Jan Treibig, Georg Hager, and Gerhard Wellein", "title": "LIKWID: Lightweight Performance Tools", "comments": "12 pages", "journal-ref": null, "doi": "10.1109/ICPPW.2010.38", "report-no": null, "categories": "cs.DC cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Exploiting the performance of today's microprocessors requires intimate\nknowledge of the microarchitecture as well as an awareness of the ever-growing\ncomplexity in thread and cache topology. LIKWID is a set of command line\nutilities that addresses four key problems: Probing the thread and cache\ntopology of a shared-memory node, enforcing thread-core affinity on a program,\nmeasuring performance counter metrics, and microbenchmarking for reliable upper\nperformance bounds. Moreover, it includes a mpirun wrapper allowing for\nportable thread-core affinity in MPI and hybrid MPI/threaded applications. To\ndemonstrate the capabilities of the tool set we show the influence of thread\naffinity on performance using the well-known OpenMP STREAM triad benchmark, use\nhardware counter tools to study the performance of a stencil code, and finally\nshow how to detect bandwidth problems on ccNUMA-based compute nodes.\n", "versions": [{"version": "v1", "created": "Tue, 26 Apr 2011 09:43:46 GMT"}, {"version": "v2", "created": "Mon, 7 Jan 2013 09:03:29 GMT"}], "update_date": "2013-01-08", "authors_parsed": [["Treibig", "Jan", ""], ["Hager", "Georg", ""], ["Wellein", "Gerhard", ""]]}, {"id": "1104.5243", "submitter": "Georg Hager", "authors": "Jan Treibig, Georg Hager, Hannes G. Hofmann, Joachim Hornegger,\n  Gerhard Wellein", "title": "Pushing the limits for medical image reconstruction on recent standard\n  multicore processors", "comments": "13 pages, 9 figures. Revised and extended version", "journal-ref": null, "doi": "10.1177/1094342012442424", "report-no": null, "categories": "cs.PF cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Volume reconstruction by backprojection is the computational bottleneck in\nmany interventional clinical computed tomography (CT) applications. Today\nvendors in this field replace special purpose hardware accelerators by standard\nhardware like multicore chips and GPGPUs. Medical imaging algorithms are on the\nverge of employing High Performance Computing (HPC) technology, and are\ntherefore an interesting new candidate for optimization. This paper presents\nlow-level optimizations for the backprojection algorithm, guided by a thorough\nperformance analysis on four generations of Intel multicore processors\n(Harpertown, Westmere, Westmere EX, and Sandy Bridge).\n  We choose the RabbitCT benchmark, a standardized testcase well supported in\nindustry, to ensure transparent and comparable results. Our aim is to provide\nnot only the fastest possible implementation but also compare to performance\nmodels and hardware counter data in order to fully understand the results. We\nseparate the influence of algorithmic optimizations, parallelization, SIMD\nvectorization, and microarchitectural issues and pinpoint problems with current\nSIMD instruction set extensions on standard CPUs (SSE, AVX). The use of\nassembly language is mandatory for best performance. Finally we compare our\nresults to the best GPGPU implementations available for this open competition\nbenchmark.\n", "versions": [{"version": "v1", "created": "Wed, 27 Apr 2011 20:31:11 GMT"}, {"version": "v2", "created": "Tue, 20 Sep 2011 15:41:17 GMT"}], "update_date": "2013-03-08", "authors_parsed": [["Treibig", "Jan", ""], ["Hager", "Georg", ""], ["Hofmann", "Hannes G.", ""], ["Hornegger", "Joachim", ""], ["Wellein", "Gerhard", ""]]}, {"id": "1104.5368", "submitter": "Swan Dubois", "authors": "Swan Dubois (LIP6, INRIA Rocquencourt), Toshimitsu Masuzawa\n  (Department of Information and Computer sciences Osaka University),\n  S\\'ebastien Tixeuil (LIP6, IUF)", "title": "Maximum Metric Spanning Tree made Byzantine Tolerant", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Self-stabilization is a versatile approach to fault-tolerance since it\npermits a distributed system to recover from any transient fault that\narbitrarily corrupts the contents of all memories in the system. Byzantine\ntolerance is an attractive feature of distributed systems that permits to cope\nwith arbitrary malicious behaviors. This paper focus on systems that are both\nself-stabilizing and Byzantine tolerant. We consider the well known problem of\nconstructing a maximum metric tree in this context. Combining these two\nproperties is known to induce many impossibility results. In this paper, we\nprovide first two impossibility results about the construction of maximum\nmetric tree in presence of transients and (permanent) Byzantine faults. Then,\nwe provide a new self-stabilizing protocol that provides optimal containment of\nan arbitrary number of Byzantine faults.\n", "versions": [{"version": "v1", "created": "Thu, 28 Apr 2011 12:14:53 GMT"}], "update_date": "2011-04-29", "authors_parsed": [["Dubois", "Swan", "", "LIP6, INRIA Rocquencourt"], ["Masuzawa", "Toshimitsu", "", "Department of Information and Computer sciences Osaka University"], ["Tixeuil", "S\u00e9bastien", "", "LIP6, IUF"]]}, {"id": "1104.5392", "submitter": "Moreno Marzolla", "authors": "Moreno Marzolla, Raffaela Mirandola", "title": "A Framework for QoS-aware Execution of Workflows over the Cloud", "comments": null, "journal-ref": "Proc. 2nd International Conference on Cloud Computing and Services\n  Science (CLOSER 2012), Frank Leymann, Ivan Ivanov, Marten Von Sideren, Tony\n  Shan (Editors), April 18-21 2012, Porto, Portugal, ISBN 978-989-8565-05-1,\n  pp. 216--221", "doi": null, "report-no": null, "categories": "cs.DC cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Cloud Computing paradigm is providing system architects with a new\npowerful tool for building scalable applications. Clouds allow allocation of\nresources on a \"pay-as-you-go\" model, so that additional resources can be\nrequested during peak loads and released after that. However, this flexibility\nasks for appropriate dynamic reconfiguration strategies. In this paper we\ndescribe SAVER (qoS-Aware workflows oVER the Cloud), a QoS-aware algorithm for\nexecuting workflows involving Web Services hosted in a Cloud environment. SAVER\nallows execution of arbitrary workflows subject to response time constraints.\nSAVER uses a passive monitor to identify workload fluctuations based on the\nobserved system response time. The information collected by the monitor is used\nby a planner component to identify the minimum number of instances of each Web\nService which should be allocated in order to satisfy the response time\nconstraint. SAVER uses a simple Queueing Network (QN) model to identify the\noptimal resource allocation. Specifically, the QN model is used to identify\nbottlenecks, and predict the system performance as Cloud resources are\nallocated or released. The parameters used to evaluate the model are those\ncollected by the monitor, which means that SAVER does not require any\nparticular knowledge of the Web Services and workflows being executed. Our\napproach has been validated through numerical simulations, whose results are\nreported in this paper.\n", "versions": [{"version": "v1", "created": "Thu, 28 Apr 2011 13:55:30 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Marzolla", "Moreno", ""], ["Mirandola", "Raffaela", ""]]}, {"id": "1104.5422", "submitter": "Choon Yik Tang", "authors": "Jie Lu and Choon Yik Tang", "title": "Zero-Gradient-Sum Algorithms for Distributed Convex Optimization: The\n  Continuous-Time Case", "comments": "15 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.DC math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a set of continuous-time distributed algorithms that\nsolve unconstrained, separable, convex optimization problems over undirected\nnetworks with fixed topologies. The algorithms are developed using a Lyapunov\nfunction candidate that exploits convexity, and are called Zero-Gradient-Sum\n(ZGS) algorithms as they yield nonlinear networked dynamical systems that\nevolve invariantly on a zero-gradient-sum manifold and converge asymptotically\nto the unknown optimizer. We also describe a systematic way to construct ZGS\nalgorithms, show that a subset of them actually converge exponentially, and\nobtain lower and upper bounds on their convergence rates in terms of the\nnetwork topologies, problem characteristics, and algorithm parameters,\nincluding the algebraic connectivity, Laplacian spectral radius, and function\ncurvatures. The findings of this paper may be regarded as a natural\ngeneralization of several well-known algorithms and results for distributed\nconsensus, to distributed convex optimization.\n", "versions": [{"version": "v1", "created": "Thu, 28 Apr 2011 15:22:24 GMT"}, {"version": "v2", "created": "Sun, 18 Sep 2011 19:16:08 GMT"}, {"version": "v3", "created": "Mon, 26 Sep 2011 15:54:40 GMT"}], "update_date": "2011-09-27", "authors_parsed": [["Lu", "Jie", ""], ["Tang", "Choon Yik", ""]]}, {"id": "1104.5642", "submitter": "Luca Moscardelli", "authors": "Angelo Fanelli, Luca Moscardelli and Alexander Skopalik", "title": "On the Impact of Fair Best Response Dynamics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.CC cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work we completely characterize how the frequency with which each\nplayer participates in the game dynamics affects the possibility of reaching\nefficient states, i.e., states with an approximation ratio within a constant\nfactor from the price of anarchy, within a polynomially bounded number of best\nresponses. We focus on the well known class of congestion games and we show\nthat, if each player is allowed to play at least once and at most $\\beta$ times\nany $T$ best responses, states with approximation ratio $O(\\beta)$ times the\nprice of anarchy are reached after $T \\lceil \\log \\log n \\rceil$ best\nresponses, and that such a bound is essentially tight also after exponentially\nmany ones. One important consequence of our result is that the fairness among\nplayers is a necessary and sufficient condition for guaranteeing a fast\nconvergence to efficient states. This answers the important question of the\nmaximum order of $\\beta$ needed to fast obtain efficient states, left open by\n[9,10] and [3], in which fast convergence for constant $\\beta$ and very slow\nconvergence for $\\beta=O(n)$ have been shown, respectively. Finally, we show\nthat the structure of the game implicitly affects its performances. In\nparticular, we show that in the symmetric setting, in which all players share\nthe same set of strategies, the game always converges to an efficient state\nafter a polynomial number of best responses, regardless of the frequency each\nplayer moves with.\n", "versions": [{"version": "v1", "created": "Fri, 29 Apr 2011 14:59:17 GMT"}], "update_date": "2011-05-02", "authors_parsed": [["Fanelli", "Angelo", ""], ["Moscardelli", "Luca", ""], ["Skopalik", "Alexander", ""]]}, {"id": "1104.5643", "submitter": "Lucas Gerin", "authors": "Marie Albenque (LIX), Lucas Gerin (MODAL'X)", "title": "On the algebraic numbers computable by some generalized Ehrenfest urns", "comments": null, "journal-ref": "Discrete Mathematics and Theoretical Computer Science 14, 2 (2012)\n  271-284", "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article deals with some stochastic population protocols, motivated by\ntheoretical aspects of distributed computing. We modelize the problem by a\nlarge urn of black and white balls from which at every time unit a fixed number\nof balls are drawn and their colors are changed according to the number of\nblack balls among them. When the time and the number of balls both tend to\ninfinity the proportion of black balls converges to an algebraic number. We\nprove that, surprisingly enough, not every algebraic number can be \"computed\"\nthis way.\n", "versions": [{"version": "v1", "created": "Fri, 29 Apr 2011 15:00:08 GMT"}, {"version": "v2", "created": "Thu, 6 Dec 2012 08:50:18 GMT"}], "update_date": "2012-12-07", "authors_parsed": [["Albenque", "Marie", "", "LIX"], ["Gerin", "Lucas", "", "MODAL'X"]]}, {"id": "1104.5660", "submitter": "Anissa Lamani", "authors": "Sayaka Kamei, Anissa Lamani (MIS), Fukuhito Ooshita, S\\'ebastien\n  Tixeuil (LIP6)", "title": "Asynchronous mobile robot gathering from symmetric configurations\n  without global multiplicity detection", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider a set of k autonomous robots that are endowed with visibility\nsensors (but that are otherwise unable to communicate) and motion actuators.\nThose robots must collaborate to reach a sin- gle vertex that is unknown\nbeforehand, and to remain there hereafter. Previous works on gathering in\nring-shaped networks suggest that there exists a tradeoff between the size of\nthe set of potential initial configurations, and the power of the sensing\ncapabilities of the robots (i.e. the larger the initial configuration set, the\nmost powerful the sensor needs to be). We prove that there is no such trade\noff. We propose a gathering protocol for an odd number of robots in a\nring-shaped network that allows symmetric but not periodic configurations as\ninitial configurations, yet uses only local weak multiplicity detection. Robots\nare assumed to be anonymous and oblivious, and the execution model is the\nnon-atomic CORDA model with asynchronous fair scheduling. Our protocol allows\nthe largest set of initial configurations (with respect to impossibility\nresults) yet uses the weakest multiplicity detector to date. The time\ncomplexity of our protocol is O(n2), where n denotes the size of the ring.\nCompared to previous work that also uses local weak multiplicity detection, we\ndo not have the constraint that k < n/2 (here, we simply have 2 < k < n - 3).\n", "versions": [{"version": "v1", "created": "Fri, 29 Apr 2011 15:20:45 GMT"}], "update_date": "2011-05-02", "authors_parsed": [["Kamei", "Sayaka", "", "MIS"], ["Lamani", "Anissa", "", "MIS"], ["Ooshita", "Fukuhito", "", "LIP6"], ["Tixeuil", "S\u00e9bastien", "", "LIP6"]]}]