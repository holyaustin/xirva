[{"id": "0902.1834", "submitter": "Sebastien Tixeuil", "authors": "St\\'ephane Devismes (VERIMAG - IMAG), Franck Petit (LIP, INRIA\n  Rh\\^one-Alpes / LIP Laboratoire de l'Informatique du Parall\\'elisme),\n  S\\'ebastien Tixeuil (LIP6)", "title": "Optimal Probabilistic Ring Exploration by Asynchronous Oblivious Robots", "comments": null, "journal-ref": null, "doi": null, "report-no": "RR-6838", "categories": "cs.DS cs.CC cs.DC cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider a team of $k$ identical, oblivious, asynchronous mobile robots\nthat are able to sense (\\emph{i.e.}, view) their environment, yet are unable to\ncommunicate, and evolve on a constrained path. Previous results in this weak\nscenario show that initial symmetry yields high lower bounds when problems are\nto be solved by \\emph{deterministic} robots. In this paper, we initiate\nresearch on probabilistic bounds and solutions in this context, and focus on\nthe \\emph{exploration} problem of anonymous unoriented rings of any size. It is\nknown that $\\Theta(\\log n)$ robots are necessary and sufficient to solve the\nproblem with $k$ deterministic robots, provided that $k$ and $n$ are coprime.\nBy contrast, we show that \\emph{four} identical probabilistic robots are\nnecessary and sufficient to solve the same problem, also removing the coprime\nconstraint. Our positive results are constructive.\n", "versions": [{"version": "v1", "created": "Wed, 11 Feb 2009 10:18:32 GMT"}], "update_date": "2009-09-30", "authors_parsed": [["Devismes", "St\u00e9phane", "", "VERIMAG - IMAG"], ["Petit", "Franck", "", "LIP, INRIA\n  Rh\u00f4ne-Alpes / LIP Laboratoire de l'Informatique du Parall\u00e9lisme"], ["Tixeuil", "S\u00e9bastien", "", "LIP6"]]}, {"id": "0902.1884", "submitter": "Georg Hager", "authors": "Markus Wittmann and Georg Hager", "title": "A Proof of Concept for Optimizing Task Parallelism by Locality Queues", "comments": "8 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PF cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Task parallelism as employed by the OpenMP task construct, although ideal for\ntackling irregular problems or typical producer/consumer schemes, bears some\npotential for performance bottlenecks if locality of data access is important,\nwhich is typically the case for memory-bound code on ccNUMA systems. We present\na programming technique which ameliorates adverse effects of dynamic task\ndistribution by sorting tasks into locality queues, each of which is preferably\nprocessed by threads that belong to the same locality domain. Dynamic\nscheduling is fully preserved inside each domain, and is preferred over\npossible load imbalance even if non-local access is required. The effectiveness\nof the approach is demonstrated using a blocked six-point stencil solver as a\ntoy model.\n", "versions": [{"version": "v1", "created": "Wed, 11 Feb 2009 13:51:27 GMT"}], "update_date": "2009-02-12", "authors_parsed": [["Wittmann", "Markus", ""], ["Hager", "Georg", ""]]}, {"id": "0902.2420", "submitter": "Aaron Sterling", "authors": "Aaron Sterling", "title": "Self-Assembly as Graph Grammar as Distributed System", "comments": "Withdrawn as I would like to polish it before making it public again.\n  A two-page announcement of these results will appear in the proceedings of\n  PODC 2009", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.NE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In 2004, Klavins et al. introduced the use of graph grammars to describe --\nand to program -- systems of self-assembly. It turns out that these graph\ngrammars are a \"dual notion\" of a graph rewriting characterization of\ndistributed systems that was proposed by Degano and Montanari over twenty years\nago. By applying techniques obtained from this observation, we prove a\ngeneralized version of Soloveichik and Winfree's theorem on local determinism,\nand we also present a canonical method to simulate asynchronous\nconstant-size-message-passing models of distributed computing with systems of\nself-assembly.\n", "versions": [{"version": "v1", "created": "Sat, 14 Feb 2009 01:17:03 GMT"}, {"version": "v2", "created": "Thu, 9 Jul 2009 14:02:39 GMT"}, {"version": "v3", "created": "Wed, 20 Jul 2011 13:59:03 GMT"}], "update_date": "2011-07-21", "authors_parsed": [["Sterling", "Aaron", ""]]}, {"id": "0902.2422", "submitter": "Aaron Sterling", "authors": "Aaron Sterling", "title": "A Time Lower Bound for Multiple Nucleation on a Surface", "comments": "This is a major revision -- thanks to comments from two very helpful\n  anonymous reviewers -- of \"A Limit to the Power of Multiple Nucleation,\"\n  which appeared in DISC 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Majumder, Reif and Sahu have presented a stochastic model of reversible,\nerror-permitting, two-dimensional tile self-assembly, and showed that\nrestricted classes of tile assembly systems achieved equilibrium in (expected)\npolynomial time. One open question they asked was how much computational power\nwould be added if the model permitted multiple nucleation, i.e., independent\ngroups of tiles growing before attaching to the original seed assembly. This\npaper provides a partial answer, by proving that if a tile assembly model uses\nonly local binding rules, then it cannot use multiple nucleation on a surface\nto solve certain \"simple\" problems in constant time (time independent of the\nsize of the surface). Moreover, this time bound applies to macroscale robotic\nsystems that assemble in a three-dimensional grid, not just to tile assembly\nsystems on a two-dimensional surface. The proof technique defines a new model\nof distributed computing that simulates tile (and robotic) self-assembly.\nKeywords: self-assembly, multiple nucleation, locally checkable labeling.\n", "versions": [{"version": "v1", "created": "Sat, 14 Feb 2009 01:39:00 GMT"}, {"version": "v2", "created": "Tue, 4 Aug 2009 12:20:28 GMT"}], "update_date": "2009-08-04", "authors_parsed": [["Sterling", "Aaron", ""]]}, {"id": "0902.2501", "submitter": "Amitabh Trehan", "authors": "Tom Hayes and Jared Saia and Amitabh Trehan", "title": "The Forgiving Graph: A distributed data structure for low stretch under\n  adversarial attack", "comments": "Submitted to Principles of Distributed Computing (PODC) 2009", "journal-ref": "Distributed Computing, 2012, Volume 25, Number 4, Pages 261-278", "doi": null, "report-no": null, "categories": "cs.DS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problem of self-healing in peer-to-peer networks that are\nunder repeated attack by an omniscient adversary. We assume that, over a\nsequence of rounds, an adversary either inserts a node with arbitrary\nconnections or deletes an arbitrary node from the network. The network responds\nto each such change by quick \"repairs,\" which consist of adding or deleting a\nsmall number of edges.\n  These repairs essentially preserve closeness of nodes after adversarial\ndeletions, without increasing node degrees by too much, in the following sense.\nAt any point in the algorithm, nodes $v$ and $w$ whose distance would have been\n$\\ell$ in the graph formed by considering only the adversarial insertions (not\nthe adversarial deletions), will be at distance at most $\\ell \\log n$ in the\nactual graph, where $n$ is the total number of vertices seen so far. Similarly,\nat any point, a node $v$ whose degree would have been $d$ in the graph with\nadversarial insertions only, will have degree at most 3d in the actual graph.\nOur algorithm is completely distributed and has low latency and bandwidth\nrequirements.\n", "versions": [{"version": "v1", "created": "Sat, 14 Feb 2009 22:35:35 GMT"}], "update_date": "2012-08-08", "authors_parsed": [["Hayes", "Tom", ""], ["Saia", "Jared", ""], ["Trehan", "Amitabh", ""]]}, {"id": "0902.2685", "submitter": "Jakub Mo\\'scicki", "authors": "J.T.Mo\\'scicki, F.Brochu, J.Ebke, U.Egede, J.Elmsheuser, K.Harrison,\n  R.W.L.Jones, H.C.Lee, D.Liko, A.Maier, A.Muraru, G.N.Patrick, K.Pajchel,\n  W.Reece, B.H.Samset, M.W.Slater, A.Soroko, C.L.Tan, D.C.Vanderster,\n  M.Williams", "title": "Ganga: a tool for computational-task management and easy access to Grid\n  resources", "comments": "Extended and clarified information on the Grid computing context for\n  Ganga, supported job model etc. Additional minor corrections and\n  clarifications. Updated the author list as agreed with the Ganga team", "journal-ref": null, "doi": "10.1016/j.cpc.2009.06.016", "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present the computational task-management tool Ganga, which\nallows for the specification, submission, bookkeeping and post-processing of\ncomputational tasks on a wide set of distributed resources. Ganga has been\ndeveloped to solve a problem increasingly common in scientific projects, which\nis that researchers must regularly switch between different processing systems,\neach with its own command set, to complete their computational tasks. Ganga\nprovides a homogeneous environment for processing data on heterogeneous\nresources. We give examples from High Energy Physics, demonstrating how an\nanalysis can be developed on a local system and then transparently moved to a\nGrid system for processing of all available data. Ganga has an API that can be\nused via an interactive interface, in scripts, or through a GUI. Specific\nknowledge about types of tasks or computational resources is provided at\nrun-time through a plugin system, making new developments easy to integrate. We\ngive an overview of the Ganga architecture, give examples of current use, and\ndemonstrate how Ganga can be used in many different areas of science.\n", "versions": [{"version": "v1", "created": "Mon, 16 Feb 2009 13:31:44 GMT"}, {"version": "v2", "created": "Tue, 9 Jun 2009 08:14:08 GMT"}], "update_date": "2015-05-13", "authors_parsed": [["Mo\u015bcicki", "J. T.", ""], ["Brochu", "F.", ""], ["Ebke", "J.", ""], ["Egede", "U.", ""], ["Elmsheuser", "J.", ""], ["Harrison", "K.", ""], ["Jones", "R. W. L.", ""], ["Lee", "H. C.", ""], ["Liko", "D.", ""], ["Maier", "A.", ""], ["Muraru", "A.", ""], ["Patrick", "G. N.", ""], ["Pajchel", "K.", ""], ["Reece", "W.", ""], ["Samset", "B. H.", ""], ["Slater", "M. W.", ""], ["Soroko", "A.", ""], ["Tan", "C. L.", ""], ["Vanderster", "D. C.", ""], ["Williams", "M.", ""]]}, {"id": "0902.2851", "submitter": "Yoann Dieudonn\\'e", "authors": "Yoann Dieudonn\\'e (MIS), Franck Petit (LIP6), Vincent Villain (MIS)", "title": "Leader Election Problem Versus Pattern Formation Problem", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Leader election and arbitrary pattern formation are funda- mental tasks for a\nset of autonomous mobile robots. The former consists in distinguishing a unique\nrobot, called the leader. The latter aims in arranging the robots in the plane\nto form any given pattern. The solv- ability of both these tasks turns out to\nbe necessary in order to achieve more complex tasks. In this paper, we study\nthe relationship between these two tasks in a model, called CORDA, wherein the\nrobots are weak in several aspects. In particular, they are fully asynchronous\nand they have no direct means of communication. They cannot remember any\nprevious observation nor computation performed in any previous step. Such\nrobots are said to be oblivious. The robots are also uniform and anonymous,\ni.e, they all have the same program using no global parameter (such as an\nidentity) allowing to differentiate any of them. Moreover, we assume that none\nof them share any kind of common coordinate mechanism or common sense of\ndirection and we discuss the influence of a common handedness (i.e.,\nchirality). In such a system, Flochini et al. proved in [11] that it is\npossible to elect a leader for n \\geq 3 robots if it is possible to form any\npattern for n \\geq 3. In this paper, we show that the converse is true for n\n\\geq 4 when the robots share a common handedness and for n \\geq 5 when they do\nnot. Thus, we deduce that with chirality (resp. without chirality) both\nproblems are equivalent for n \\geq 4 (resp. n \\geq 5) in CORDA.\n", "versions": [{"version": "v1", "created": "Tue, 17 Feb 2009 08:02:25 GMT"}, {"version": "v2", "created": "Tue, 20 Oct 2009 15:28:09 GMT"}, {"version": "v3", "created": "Wed, 29 Feb 2012 21:19:59 GMT"}], "update_date": "2012-03-02", "authors_parsed": [["Dieudonn\u00e9", "Yoann", "", "MIS"], ["Petit", "Franck", "", "LIP6"], ["Villain", "Vincent", "", "MIS"]]}, {"id": "0902.2859", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Transmission protocols for instruction streams", "comments": "13 pages", "journal-ref": "In ICTAC 2009, pages 127--139. Springer-Verlag, LNCS 5684, 2009", "doi": "10.1007/978-3-642-03466-4_8", "report-no": "PRG0903", "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Threads as considered in thread algebra model behaviours to be controlled by\nsome execution environment: upon each action performed by a thread, a reply\nfrom its execution environment -- which takes the action as an instruction to\nbe processed -- determines how the thread proceeds. In this paper, we are\nconcerned with the case where the execution environment is remote: we describe\nand analyse some transmission protocols for passing instructions from a thread\nto a remote execution environment.\n", "versions": [{"version": "v1", "created": "Tue, 17 Feb 2009 08:41:22 GMT"}], "update_date": "2009-09-02", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0902.3056", "submitter": "Rahul Jain", "authors": "Rahul Jain, Hartmut Klauck", "title": "New Results in the Simultaneous Message Passing Model", "comments": "16 pages, version 1", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.CC cs.IT math.IT quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Consider the following Simultaneous Message Passing (SMP) model for computing\na relation f subset of X x Y x Z. In this model Alice, on input x in X and Bob,\non input y in Y, send one message each to a third party Referee who then\noutputs a z in Z such that (x,y,z) in f. We first show optimal 'Direct sum'\nresults for all relations f in this model, both in the quantum and classical\nsettings, in the situation where we allow shared resources (shared entanglement\nin quantum protocols and public coins in classical protocols) between Alice and\nReferee and Bob and Referee and no shared resource between Alice and Bob. This\nimplies that, in this model, the communication required to compute k\nsimultaneous instances of f, with constant success overall, is at least k-times\nthe communication required to compute one instance with constant success.\n  This in particular implies an earlier Direct sum result, shown by\nChakrabarti, Shi, Wirth and Yao, 2001, for the Equality function (and a class\nof other so-called robust functions), in the classical smp model with no shared\nresources between any parties.\n  Furthermore we investigate the gap between the smp model and the one-way\nmodel in communication complexity and exhibit a partial function that is\nexponentially more expensive in the former if quantum communication with\nentanglement is allowed, compared to the latter even in the deterministic case.\n", "versions": [{"version": "v1", "created": "Wed, 18 Feb 2009 06:38:51 GMT"}], "update_date": "2009-02-26", "authors_parsed": [["Jain", "Rahul", ""], ["Klauck", "Hartmut", ""]]}, {"id": "0902.3081", "submitter": "Pierre Fraigniaud", "authors": "Pierre Fraigniaud and Amos Korman", "title": "Compact Ancestry Labeling Schemes for Trees of Small Depth", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DC cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An {\\em ancestry labeling scheme} labels the nodes of any tree in such a way\nthat ancestry queries between any two nodes in a tree can be answered just by\nlooking at their corresponding labels. The common measure to evaluate the\nquality of an ancestry labeling scheme is by its {\\em label size}, that is the\nmaximal number of bits stored in a label, taken over all $n$-node trees. The\ndesign of ancestry labeling schemes finds applications in XML search engines.\nIn the context of these applications, even small improvements in the label size\nare important. In fact, the literature about this topic is interested in the\nexact label size rather than just its order of magnitude. As a result,\nfollowing the proposal of an original scheme of size $2\\log n$ bits, a\nconsiderable amount of work was devoted to improve the bound on the label size.\nThe current state of the art upper bound is $\\log n + O(\\sqrt{\\log n})$ bits\nwhich is still far from the known $\\log n + \\Omega(\\log\\log n)$ lower bound.\nMoreover, the hidden constant factor in the additive $O(\\sqrt{\\log n})$ term is\nlarge, which makes this term dominate the label size for typical current XML\ntrees.\n  In attempt to provide good performances for real XML data, we rely on the\nobservation that the depth of a typical XML tree is bounded from above by a\nsmall constant. Having this in mind, we present an ancestry labeling scheme of\nsize $\\log n+2\\log d +O(1)$, for the family of trees with at most $n$ nodes and\ndepth at most $d$. In addition to our main result, we prove a result that may\nbe of independent interest concerning the existence of a linear {\\em universal\ngraph} for the family of forests with trees of bounded depth.\n", "versions": [{"version": "v1", "created": "Wed, 18 Feb 2009 09:49:42 GMT"}], "update_date": "2009-02-19", "authors_parsed": [["Fraigniaud", "Pierre", ""], ["Korman", "Amos", ""]]}, {"id": "0902.3517", "submitter": "John Augustine", "authors": "John Augustine, Qi Han, Philip Loden, Sachin Lodha and Sasanka Roy", "title": "Energy-Efficient Shortest Path Algorithms for Convergecast in Sensor\n  Networks", "comments": "15 pages, 7 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DC cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a variant of the capacitated vehicle routing problem that is\nencountered in sensor networks for scientific data collection. Consider an\nundirected graph $G=(V \\cup \\{\\mathbf{sink}\\},E)$. Each vertex $v \\in V$ holds\na constant-sized reading normalized to 1 byte that needs to be communicated to\nthe $\\mathbf{sink}$. The communication protocol is defined such that readings\ntravel in packets. The packets have a capacity of $k$ bytes. We define a {\\em\npacket hop} to be the communication of a packet from a vertex to its neighbor.\nEach packet hop drains one unit of energy and therefore, we need to communicate\nthe readings to the $\\mathbf{sink}$ with the fewest number of hops.\n  We show this problem to be NP-hard and counter it with a simple distributed\n$(2-\\frac{3}{2k})$-approximation algorithm called {\\tt SPT} that uses the\nshortest path tree rooted at the $\\mathbf{sink}$. We also show that {\\tt SPT}\nis absolutely optimal when $G$ is a tree and asymptotically optimal when $G$ is\na grid. Furthermore, {\\tt SPT} has two nice properties. Firstly, the readings\nalways travel along a shortest path toward the $\\mathbf{sink}$, which makes it\nan appealing solution to the convergecast problem as it fits the natural\nintuition. Secondly, each node employs a very elementary packing strategy.\nGiven all the readings that enter into the node, it sends out as many fully\npacked packets as possible followed by at most 1 partial packet. We show that\nany solution that has either one of the two properties cannot be a\n$(2-\\epsilon)$-approximation, for any fixed $\\epsilon > 0$. This makes \\spt\noptimal for the class of algorithms that obey either one of those properties.\n", "versions": [{"version": "v1", "created": "Fri, 20 Feb 2009 06:42:45 GMT"}], "update_date": "2009-02-23", "authors_parsed": [["Augustine", "John", ""], ["Han", "Qi", ""], ["Loden", "Philip", ""], ["Lodha", "Sachin", ""], ["Roy", "Sasanka", ""]]}, {"id": "0902.3528", "submitter": "Stephane Rovedakis", "authors": "L\\'elia Blin (IBISC), Maria Gradinariu Potop-Butucaru (LIP6), Stephane\n  Rovedakis (IBISC)", "title": "A Superstabilizing $\\log(n)$-Approximation Algorithm for Dynamic Steiner\n  Trees", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-642-05118-0_10", "report-no": null, "categories": "cs.DC cs.DS cs.NI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we design and prove correct a fully dynamic distributed\nalgorithm for maintaining an approximate Steiner tree that connects via a\nminimum-weight spanning tree a subset of nodes of a network (referred as\nSteiner members or Steiner group) . Steiner trees are good candidates to\nefficiently implement communication primitives such as publish/subscribe or\nmulticast, essential building blocks for the new emergent networks (e.g. P2P,\nsensor or adhoc networks). The cost of the solution returned by our algorithm\nis at most $\\log |S|$ times the cost of an optimal solution, where $S$ is the\ngroup of members. Our algorithm improves over existing solutions in several\nways. First, it tolerates the dynamism of both the group members and the\nnetwork. Next, our algorithm is self-stabilizing, that is, it copes with nodes\nmemory corruption. Last but not least, our algorithm is\n\\emph{superstabilizing}. That is, while converging to a correct configuration\n(i.e., a Steiner tree) after a modification of the network, it keeps offering\nthe Steiner tree service during the stabilization time to all members that have\nnot been affected by this modification.\n", "versions": [{"version": "v1", "created": "Fri, 20 Feb 2009 07:40:44 GMT"}], "update_date": "2015-05-13", "authors_parsed": [["Blin", "L\u00e9lia", "", "IBISC"], ["Potop-Butucaru", "Maria Gradinariu", "", "LIP6"], ["Rovedakis", "Stephane", "", "IBISC"]]}, {"id": "0902.3631", "submitter": "Aaron Sterling", "authors": "Aaron Sterling", "title": "Distributed Agreement in Tile Self-Assembly", "comments": "The extended abstract of this paper won the Best Student Paper Award\n  at DNA 15. The current version has been accepted for publication in Natural\n  Computing", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.NE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Laboratory investigations have shown that a formal theory of fault-tolerance\nwill be essential to harness nanoscale self-assembly as a medium of\ncomputation. Several researchers have voiced an intuition that self-assembly\nphenomena are related to the field of distributed computing. This paper\nformalizes some of that intuition. We construct tile assembly systems that are\nable to simulate the solution of the wait-free consensus problem in some\ndistributed systems. (For potential future work, this may allow binding errors\nin tile assembly to be analyzed, and managed, with positive results in\ndistributed computing, as a \"blockage\" in our tile assembly model is analogous\nto a crash failure in a distributed computing model.) We also define a\nstrengthening of the \"traditional\" consensus problem, to make explicit an\nexpectation about consensus algorithms that is often implicit in distributed\ncomputing literature. We show that solution of this strengthened consensus\nproblem can be simulated by a two-dimensional tile assembly model only for two\nprocesses, whereas a three-dimensional tile assembly model can simulate its\nsolution in a distributed system with any number of processes.\n", "versions": [{"version": "v1", "created": "Fri, 20 Feb 2009 20:43:58 GMT"}, {"version": "v2", "created": "Thu, 28 May 2009 21:14:11 GMT"}, {"version": "v3", "created": "Fri, 16 Jul 2010 21:08:29 GMT"}], "update_date": "2010-07-20", "authors_parsed": [["Sterling", "Aaron", ""]]}, {"id": "0902.4463", "submitter": "Evghenii Gaburov", "authors": "Evghenii Gaburov, Stefan Harfst and Simon Portegies Zwart", "title": "SAPPORO: A way to turn your graphics cards into a GRAPE-6", "comments": "13 pages, 9 figures, accepted to New Astronomy", "journal-ref": null, "doi": "10.1016/j.newast.2009.03.002", "report-no": null, "categories": "astro-ph.IM cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present Sapporo, a library for performing high-precision gravitational\nN-body simulations on NVIDIA Graphical Processing Units (GPUs). Our library\nmimics the GRAPE-6 library, and N-body codes currently running on GRAPE-6 can\nswitch to Sapporo by a simple relinking of the library. The precision of our\nlibrary is comparable to that of GRAPE-6, even though internally the GPU\nhardware is limited to single precision arithmetics. This limitation is\neffectively overcome by emulating double precision for calculating the distance\nbetween particles. The performance loss of this operation is small (< 20%)\ncompared to the advantage of being able to run at high precision. We tested the\nlibrary using several GRAPE-6-enabled N-body codes, in particular with Starlab\nand phiGRAPE. We measured peak performance of 800 Gflop/s for running with 10^6\nparticles on a PC with four commercial G92 architecture GPUs (two GeForce\n9800GX2). As a production test, we simulated a 32k Plummer model with equal\nmass stars well beyond core collapse. The simulation took 41 days, during which\nthe mean performance was 113 Gflop/s. The GPU did not show any problems from\nrunning in a production environment for such an extended period of time.\n", "versions": [{"version": "v1", "created": "Wed, 25 Feb 2009 21:00:05 GMT"}, {"version": "v2", "created": "Thu, 5 Mar 2009 07:39:34 GMT"}], "update_date": "2015-05-13", "authors_parsed": [["Gaburov", "Evghenii", ""], ["Harfst", "Stefan", ""], ["Zwart", "Simon Portegies", ""]]}, {"id": "0902.4730", "submitter": "Saul Youssef", "authors": "Saul Youssef, John Brunelle, John Huth, David C. Parkes, Margo Seltzer\n  and Jim Shank", "title": "Minimal Economic Distributed Computing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In an ideal distributed computing infrastructure, users would be able to use\ndiverse distributed computing resources in a simple coherent way, with\nguaranteed security and efficient use of shared resources in accordance with\nthe wishes of the owners of the resources. Our strategy for approaching this\nideal is to first find the simplest structure within which these goals can\nplausibly be achieved. This structure, we find, is given by a particular\nrecursive distributive lattice freely constructed from a presumed partially\nordered set of all data in the infrastructure. Minor syntactic adjustments to\nthe resulting algebra yields a simple language resembling a UNIX shell, a\nconcept of execution and an interprocess protocol. Persons, organizations and\nservers within the system express their interests explicitly via a hierarchical\ncurrency. The currency provides a common framework for treating authentication,\naccess control and resource sharing as economic problems while also introducing\na new dimension for improving the infrastructure over time by designing system\ncomponents which compete with each other to earn the currency. We explain these\nresults, discuss experience with an implementation called egg and point out\nareas where more research is needed.\n", "versions": [{"version": "v1", "created": "Fri, 27 Feb 2009 00:00:55 GMT"}], "update_date": "2009-03-02", "authors_parsed": [["Youssef", "Saul", ""], ["Brunelle", "John", ""], ["Huth", "John", ""], ["Parkes", "David C.", ""], ["Seltzer", "Margo", ""], ["Shank", "Jim", ""]]}, {"id": "0902.4822", "submitter": "Xavier Grehant", "authors": "Xavier Grehant and Sverre Jarp", "title": "Lightweight Task Analysis for Cache-Aware Scheduling on Heterogeneous\n  Clusters", "comments": "The paper was originally published in: ISBN #: 1-60132-084-1 (a\n  two-volume set) Proceedings of the 2008 International Conference on Parallel\n  and Distributed Processing Techniques and Applications (PDPTA'08) Editors:\n  Hamid R. Arabnia and Youngsong Mun", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a novel characterization of how a program stresses cache. This\ncharacterization permits fast performance prediction in order to simulate and\nassist task scheduling on heterogeneous clusters. It is based on the estimation\nof stack distance probability distributions. The analysis requires the\nobservation of a very small subset of memory accesses, and yields a reasonable\nto very accurate prediction in constant time.\n", "versions": [{"version": "v1", "created": "Fri, 27 Feb 2009 12:47:22 GMT"}], "update_date": "2009-03-02", "authors_parsed": [["Grehant", "Xavier", ""], ["Jarp", "Sverre", ""]]}]