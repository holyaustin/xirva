[{"id": "0905.1113", "submitter": "Bogdan Nicolae", "authors": "Bogdan Nicolae (INRIA - IRISA), Gabriel Antoniu (INRIA - IRISA, INRIA\n  Rh\\^one-Alpes / LIP Laboratoire de l'Informatique du Parall\\'elisme), Luc\n  Boug\\'e (INRIA - IRISA, INRIA Rh\\^one-Alpes / LIP Laboratoire de\n  l'Informatique du Parall\\'elisme)", "title": "BlobSeer: How to Enable Efficient Versioning for Large Object Storage\n  under Heavy Access Concurrency", "comments": null, "journal-ref": "DAMAP 2009 (2009)", "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  To accommodate the needs of large-scale distributed P2P systems, scalable\ndata management strategies are required, allowing applications to efficiently\ncope with continuously growing, highly dis tributed data. This paper addresses\nthe problem of efficiently stor ing and accessing very large binary data\nobjects (blobs). It proposesan efficient versioning scheme allowing a large\nnumber of clients to concurrently read, write and append data to huge blobs\nthat are fragmented and distributed at a very large scale. Scalability under\nheavy concurrency is achieved thanks to an original metadata scheme, based on a\ndistributed segment tree built on top of a Distributed Hash Table (DHT). Our\napproach has been implemented and experimented within our BlobSeer prototype on\nthe Grid'5000 testbed, using up to 175 nodes.\n", "versions": [{"version": "v1", "created": "Thu, 7 May 2009 19:37:48 GMT"}], "update_date": "2009-09-30", "authors_parsed": [["Nicolae", "Bogdan", "", "INRIA - IRISA"], ["Antoniu", "Gabriel", "", "INRIA - IRISA, INRIA\n  Rh\u00f4ne-Alpes / LIP Laboratoire de l'Informatique du Parall\u00e9lisme"], ["Boug\u00e9", "Luc", "", "INRIA - IRISA, INRIA Rh\u00f4ne-Alpes / LIP Laboratoire de\n  l'Informatique du Parall\u00e9lisme"]]}, {"id": "0905.1744", "submitter": "Fahad Saeed", "authors": "Fahad Saeed and Ashfaq Khokhar", "title": "A Domain Decomposition Strategy for Alignment of Multiple Biological\n  Sequences on Multiprocessor Platforms", "comments": "36 pages, 17 figures, Accepted manuscript in Journal of Parallel and\n  Distributed Computing(JPDC)", "journal-ref": "as: F. Saeed, A. Khokhar, A domain decomposition strategy for\n  alignment of multiple biological sequences on multiprocessor platforms, J.\n  Parallel Distrib. Comput. (2009)", "doi": "10.1016/j.jpdc.2009.03.006", "report-no": null, "categories": "cs.DC q-bio.QM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multiple Sequences Alignment (MSA) of biological sequences is a fundamental\nproblem in computational biology due to its critical significance in wide\nranging applications including haplotype reconstruction, sequence homology,\nphylogenetic analysis, and prediction of evolutionary origins. The MSA problem\nis considered NP-hard and known heuristics for the problem do not scale well\nwith increasing number of sequences. On the other hand, with the advent of new\nbreed of fast sequencing techniques it is now possible to generate thousands of\nsequences very quickly. For rapid sequence analysis, it is therefore desirable\nto develop fast MSA algorithms that scale well with the increase in the dataset\nsize. In this paper, we present a novel domain decomposition based technique to\nsolve the MSA problem on multiprocessing platforms. The domain decomposition\nbased technique, in addition to yielding better quality, gives enormous\nadvantage in terms of execution time and memory requirements. The proposed\nstrategy allows to decrease the time complexity of any known heuristic of\nO(N)^x complexity by a factor of O(1/p)^x, where N is the number of sequences,\nx depends on the underlying heuristic approach, and p is the number of\nprocessing nodes. In particular, we propose a highly scalable algorithm,\nSample-Align-D, for aligning biological sequences using Muscle system as the\nunderlying heuristic. The proposed algorithm has been implemented on a cluster\nof workstations using MPI library. Experimental results for different problem\nsizes are analyzed in terms of quality of alignment, execution time and\nspeed-up.\n", "versions": [{"version": "v1", "created": "Tue, 12 May 2009 01:04:40 GMT"}], "update_date": "2009-05-13", "authors_parsed": [["Saeed", "Fahad", ""], ["Khokhar", "Ashfaq", ""]]}, {"id": "0905.1786", "submitter": "Swan Dubois", "authors": "Alain Cournier (MIS), Swan Dubois (LIP6, INRIA Rocquencourt), Vincent\n  Villain (MIS)", "title": "Une CNS pour l'acheminement de messages instantan\\'ement stabilisant", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A snap-stabilizing algorithm ensures that it always behaves according to its\nspecifications whenever it starts from an arbitrary configuration. In this\npaper, we interest in the message forwarding problem in a message-switched\nnetwork. We must manage network ressources in order to deliver messages to any\nprocessor of the network. In this goal, we need information given by a routing\nalgorithm. But, due to the context of stabilization, this information can be\ninitially corrupted. It is why the existence of snap-stabilizing algorithms for\nthis task (proved in [CDV09]) implies that we can ask the system to begin\nforwarding messages even if routing tables are initially corrupted. In this\npaper, we generalize the previous result given a necessary and sufficient\ncondition to solve the forwarding problem in a snap-stabilizing way.\n", "versions": [{"version": "v1", "created": "Tue, 12 May 2009 08:28:47 GMT"}], "update_date": "2009-05-13", "authors_parsed": [["Cournier", "Alain", "", "MIS"], ["Dubois", "Swan", "", "LIP6, INRIA Rocquencourt"], ["Villain", "Vincent", "", "MIS"]]}, {"id": "0905.2200", "submitter": "Debprakash Patnaik", "authors": "Yong Cao, Debprakash Patnaik, Sean Ponce, Jeremy Archuleta, Patrick\n  Butler, Wu-chun Feng, and Naren Ramakrishnan", "title": "Towards Chip-on-Chip Neuroscience: Fast Mining of Frequent Episodes\n  Using Graphics Processors", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computational neuroscience is being revolutionized with the advent of\nmulti-electrode arrays that provide real-time, dynamic, perspectives into brain\nfunction. Mining event streams from these chips is critical to understanding\nthe firing patterns of neurons and to gaining insight into the underlying\ncellular activity. We present a GPGPU solution to mining spike trains. We focus\non mining frequent episodes which captures coordinated events across time even\nin the presence of intervening background/\"junk\" events. Our algorithmic\ncontributions are two-fold: MapConcatenate, a new computation-to-core mapping\nscheme, and a two-pass elimination approach to quickly find supported episodes\nfrom a large number of candidates. Together, they help realize a real-time\n\"chip-on-chip\" solution to neuroscience data mining, where one chip (the\nmulti-electrode array) supplies the spike train data and another (the GPGPU)\nmines it at a scale unachievable previously. Evaluation on both synthetic and\nreal datasets demonstrate the potential of our approach.\n", "versions": [{"version": "v1", "created": "Wed, 13 May 2009 21:04:03 GMT"}], "update_date": "2009-05-15", "authors_parsed": [["Cao", "Yong", ""], ["Patnaik", "Debprakash", ""], ["Ponce", "Sean", ""], ["Archuleta", "Jeremy", ""], ["Butler", "Patrick", ""], ["Feng", "Wu-chun", ""], ["Ramakrishnan", "Naren", ""]]}, {"id": "0905.2203", "submitter": "Debprakash Patnaik", "authors": "Debprakash Patnaik, Sean P. Ponce, Yong Cao, Naren Ramakrishnan", "title": "Accelerator-Oriented Algorithm Transformation for Temporal Data Mining", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Temporal data mining algorithms are becoming increasingly important in many\napplication domains including computational neuroscience, especially the\nanalysis of spike train data. While application scientists have been able to\nreadily gather multi-neuronal datasets, analysis capabilities have lagged\nbehind, due to both lack of powerful algorithms and inaccessibility to powerful\nhardware platforms. The advent of GPU architectures such as Nvidia's GTX 280\noffers a cost-effective option to bring these capabilities to the\nneuroscientist's desktop. Rather than port existing algorithms onto this\narchitecture, we advocate the need for algorithm transformation, i.e.,\nrethinking the design of the algorithm in a way that need not necessarily\nmirror its serial implementation strictly. We present a novel implementation of\na frequent episode discovery algorithm by revisiting \"in-the-large\" issues such\nas problem decomposition as well as \"in-the-small\" issues such as data layouts\nand memory access patterns. This is non-trivial because frequent episode\ndiscovery does not lend itself to GPU-friendly data-parallel mapping\nstrategies. Applications to many datasets and comparisons to CPU as well as\nprior GPU implementations showcase the advantages of our approach.\n", "versions": [{"version": "v1", "created": "Wed, 13 May 2009 21:18:31 GMT"}], "update_date": "2009-05-15", "authors_parsed": [["Patnaik", "Debprakash", ""], ["Ponce", "Sean P.", ""], ["Cao", "Yong", ""], ["Ramakrishnan", "Naren", ""]]}, {"id": "0905.2257", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "A protocol for instruction stream processing", "comments": "15pages", "journal-ref": null, "doi": null, "report-no": "PRG0905", "categories": "cs.PL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The behaviour produced by an instruction sequence under execution is a\nbehaviour to be controlled by some execution environment: each step performed\nactuates the processing of an instruction by the execution environment and a\nreply returned at completion of the processing determines how the behaviour\nproceeds. In this paper, we are concerned with the case where the processing\ntakes place remotely. We describe a protocol to deal with the case where the\nbehaviour produced by an instruction sequence under execution leads to the\ngeneration of a stream of instructions to be processed and a remote execution\nunit handles the processing of that stream of instructions.\n", "versions": [{"version": "v1", "created": "Thu, 14 May 2009 06:23:18 GMT"}], "update_date": "2009-05-15", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0905.2287", "submitter": "Lelia Blin", "authors": "L\\'elia Blin (IBISC), Maria Gradinariu Potop-Butucaru (INRIA\n  Rocquencourt), Stephane Rovedakis (IBISC), S\\'ebastien Tixeuil (INRIA Futurs,\n  LIP6)", "title": "A New Self-Stabilizing Minimum Spanning Tree Construction with Loop-free\n  Property", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DC cs.NI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The minimum spanning tree (MST) construction is a classical problem in\nDistributed Computing for creating a globally minimized structure\ndistributedly. Self-stabilization is versatile technique for forward recovery\nthat permits to handle any kind of transient faults in a unified manner. The\nloop-free property provides interesting safety assurance in dynamic networks\nwhere edge-cost changes during operation of the protocol. We present a new\nself-stabilizing MST protocol that improves on previous known ap- proaches in\nseveral ways. First, it makes fewer system hypotheses as the size of the\nnetwork (or an upper bound on the size) need not be known to the participants.\nSecond, it is loop-free in the sense that it guarantees that a spanning tree\nstructure is always preserved while edge costs change dynamically and the\nprotocol adjusts to a new MST. Finally, time complexity matches the best known\nresults, while space complexity results show that this protocol is the most\nefficient to date.\n", "versions": [{"version": "v1", "created": "Thu, 14 May 2009 09:23:06 GMT"}], "update_date": "2016-11-25", "authors_parsed": [["Blin", "L\u00e9lia", "", "IBISC"], ["Potop-Butucaru", "Maria Gradinariu", "", "INRIA\n  Rocquencourt"], ["Rovedakis", "Stephane", "", "IBISC"], ["Tixeuil", "S\u00e9bastien", "", "INRIA Futurs,\n  LIP6"]]}, {"id": "0905.2459", "submitter": "Serguei Mokhov", "authors": "Serguei A. Mokhov", "title": "On Design and Implementation of the Distributed Modular Audio\n  Recognition Framework: Requirements and Specification Design Document", "comments": "53 pages, 8 figures, 2 tables. A 2006 report on software design and\n  implementation of Distributed MARF, which is a distributed extension of\n  classical MARF documented at arXiv:0905.1235 . Parts are to appear at the\n  CISSE'08 conference (Springer). The content of the document and code are\n  open-source and released at http://marf.sf.net ; v2 adds missing .ind file", "journal-ref": null, "doi": "10.1007/978-90-481-3662-9_72", "report-no": null, "categories": "cs.CV cs.DC cs.MM cs.NE cs.SD", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  We present the requirements and design specification of the open-source\nDistributed Modular Audio Recognition Framework (DMARF), a distributed\nextension of MARF. The distributed version aggregates a number of distributed\ntechnologies (e.g. Java RMI, CORBA, Web Services) in a pluggable and modular\nmodel along with the provision of advanced distributed systems algorithms. We\noutline the associated challenges incurred during the design and implementation\nas well as overall specification of the project and its advantages and\nlimitations.\n", "versions": [{"version": "v1", "created": "Fri, 15 May 2009 02:52:28 GMT"}, {"version": "v2", "created": "Sun, 26 Jul 2009 23:16:29 GMT"}], "update_date": "2010-01-31", "authors_parsed": [["Mokhov", "Serguei A.", ""]]}, {"id": "0905.2540", "submitter": "Swan Dubois", "authors": "Alain Cournier (MIS), Swan Dubois (LIP6, INRIA Rocquencourt), Vincent\n  Villain (MIS)", "title": "Two snap-stabilizing point-to-point communication protocols in\n  message-switched networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A snap-stabilizing protocol, starting from any configuration, always behaves\naccording to its specification. In this paper, we present a snap-stabilizing\nprotocol to solve the message forwarding problem in a message-switched network.\nIn this problem, we must manage resources of the system to deliver messages to\nany processor of the network. In this purpose, we use information given by a\nrouting algorithm. By the context of stabilization (in particular, the system\nstarts in an arbitrary configuration), this information can be corrupted. So,\nthe existence of a snap-stabilizing protocol for the message forwarding problem\nimplies that we can ask the system to begin forwarding messages even if routing\ninformation are initially corrupted. In this paper, we propose two\nsnap-stabilizing algorithms (in the state model) for the following\nspecification of the problem: - Any message can be generated in a finite time.\n- Any emitted message is delivered to its destination once and only once in a\nfinite time. This implies that our protocol can deliver any emitted message\nregardless of the state of routing tables in the initial configuration. These\ntwo algorithms are based on the previous work of [MS78]. Each algorithm needs a\nparticular method to be transform into a snap-stabilizing one but both of them\ndo not introduce a significant overcost in memory or in time with respect to\nalgorithms of [MS78].\n", "versions": [{"version": "v1", "created": "Fri, 15 May 2009 12:41:01 GMT"}], "update_date": "2009-05-18", "authors_parsed": [["Cournier", "Alain", "", "MIS"], ["Dubois", "Swan", "", "LIP6, INRIA Rocquencourt"], ["Villain", "Vincent", "", "MIS"]]}, {"id": "0905.2637", "submitter": "Felipe Cruz", "authors": "Felipe A. Cruz, Matthew G. Knepley, L. A. Barba", "title": "PetFMM--A dynamically load-balancing parallel fast multipole library", "comments": "28 pages, 9 figures", "journal-ref": "Int. J. Num. Meth. Eng., 85(4): 403-428 (Jan. 2011)", "doi": "10.1002/nme.2972", "report-no": null, "categories": "cs.DC cs.DS", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Fast algorithms for the computation of $N$-body problems can be broadly\nclassified into mesh-based interpolation methods, and hierarchical or\nmultiresolution methods. To this last class belongs the well-known fast\nmultipole method (FMM), which offers O(N) complexity. This paper presents an\nextensible parallel library for $N$-body interactions utilizing the FMM\nalgorithm, built on the framework of PETSc. A prominent feature of this library\nis that it is designed to be extensible, with a view to unifying efforts\ninvolving many algorithms based on the same principles as the FMM and enabling\neasy development of scientific application codes. The paper also details an\nexhaustive model for the computation of tree-based $N$-body algorithms in\nparallel, including both work estimates and communications estimates. With this\nmodel, we are able to implement a method to provide automatic, a priori load\nbalancing of the parallel execution, achieving optimal distribution of the\ncomputational work among processors and minimal inter-processor communications.\nUsing a client application that performs the calculation of velocity induced by\n$N$ vortex particles, ample verification and testing of the library was\nperformed. Strong scaling results are presented with close to a million\nparticles in up to 64 processors, including both speedup and parallel\nefficiency. The library is currently able to achieve over 85% parallel\nefficiency for 64 processors. The software library is open source under the\nPETSc license; this guarantees the maximum impact to the scientific community\nand encourages peer-based collaboration for the extensions and applications.\n", "versions": [{"version": "v1", "created": "Fri, 15 May 2009 23:46:14 GMT"}], "update_date": "2011-09-21", "authors_parsed": [["Cruz", "Felipe A.", ""], ["Knepley", "Matthew G.", ""], ["Barba", "L. A.", ""]]}, {"id": "0905.3454", "submitter": "Fabian Kuhn", "authors": "Fabian Kuhn and Rotem Oshman", "title": "Gradient Clock Synchronization using Reference Broadcasts", "comments": "21 page, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we suggest a method by which reference broadcast\nsynchronization (RBS), and other methods of estimating clock values, can be\nincorporated in standard clock synchronization algorithms to improve\nsynchronization quality. We advocate a logical separation of the task of\nestimating the clock values of other nodes in the network from the task of\nusing these estimates to output a logical clock value.\n  The separation is achieved by means of a virtual estimate graph, overlaid on\ntop of the real network graph, which represents the information various nodes\ncan obtain about each other. RBS estimates are represented in the estimate\ngraph as edges between nodes at distance 2 from each other in the original\nnetwork graph. A clock synchronization algorithm then operates on the estimate\ngraph as though it were the original network.\n  To illustrate the merits of this approach, we modify a recent optimal\ngradient clock synchronization algorithm to work in this setting. The modified\nalgorithm transparently takes advantage of RBS estimates and any other means by\nwhich nodes can estimate each others' clock values.\n", "versions": [{"version": "v1", "created": "Thu, 21 May 2009 19:52:01 GMT"}], "update_date": "2009-09-30", "authors_parsed": [["Kuhn", "Fabian", ""], ["Oshman", "Rotem", ""]]}, {"id": "0905.3584", "submitter": "Pat Morin", "authors": "Luc Devroye, Joachim Gudmundsson, Pat Morin", "title": "On the Expected Maximum Degree of Gabriel and Yao Graphs", "comments": "20 pages, 10 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CG cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Motivated by applications of Gabriel graphs and Yao graphs in wireless ad-hoc\nnetworks, we show that the maximal degree of a random Gabriel graph or Yao\ngraph defined on $n$ points drawn uniformly at random from a unit square grows\nas $\\Theta (\\log n / \\log \\log n)$ in probability.\n", "versions": [{"version": "v1", "created": "Thu, 21 May 2009 23:56:40 GMT"}], "update_date": "2009-05-25", "authors_parsed": [["Devroye", "Luc", ""], ["Gudmundsson", "Joachim", ""], ["Morin", "Pat", ""]]}, {"id": "0905.3946", "submitter": "Chih-Hong Cheng", "authors": "Chih-Hong Cheng, Christian Buckl, Javier Esparza, Alois Knoll", "title": "FTOS-Verify: Analysis and Verification of Non-Functional Properties for\n  Fault-Tolerant Systems", "comments": "(bibliography update)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The focus of the tool FTOS is to alleviate designers' burden by offering code\ngeneration for non-functional aspects including fault-tolerance mechanisms. One\ncrucial aspect in this context is to ensure that user-selected mechanisms for\nthe system model are sufficient to resist faults as specified in the underlying\nfault hypothesis. In this paper, formal approaches in verification are proposed\nto assist the claim. We first raise the precision of FTOS into pure\nmathematical constructs, and formulate the deterministic assumption, which is\nnecessary as an extension of Giotto-like systems (e.g., FTOS) to equip with\nfault-tolerance abilities. We show that local properties of a system with the\ndeterministic assumption will be preserved in a modified synchronous system\nused as the verification model. This enables the use of techniques known from\nhardware verification. As for implementation, we develop a prototype tool\ncalled FTOS-Verify, deploy it as an Eclipse add-on for FTOS, and conduct\nseveral case studies.\n", "versions": [{"version": "v1", "created": "Mon, 25 May 2009 06:11:42 GMT"}], "update_date": "2009-05-26", "authors_parsed": [["Cheng", "Chih-Hong", ""], ["Buckl", "Christian", ""], ["Esparza", "Javier", ""], ["Knoll", "Alois", ""]]}, {"id": "0905.3951", "submitter": "Chih-Hong Cheng", "authors": "Chih-Hong Cheng, Christian Buckl, Javier Esparza, Alois Knoll", "title": "Modeling and Verification for Timing Satisfaction of Fault-Tolerant\n  Systems with Finiteness", "comments": "1. Appear in the 13-th IEEE/ACM International Symposium on\n  Distributed Simulation and Real Time Applications (DS-RT'09). 2. Compared to\n  the DS-RT version, we add motivations for editing automata, and footnote that\n  the sketch of editing algo is only applicable in our job-processing element\n  to avoid ambiguity (because actions are chained)", "journal-ref": null, "doi": "10.1109/DS-RT.2009.20", "report-no": null, "categories": "cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The increasing use of model-based tools enables further use of formal\nverification techniques in the context of distributed real-time systems. To\navoid state explosion, it is necessary to construct verification models that\nfocus on the aspects under consideration.\n  In this paper, we discuss how we construct a verification model for timing\nanalysis in distributed real-time systems. We (1) give observations concerning\nrestrictions of timed automata to model these systems, (2) formulate\nmathematical representations on how to perform model-to-model transformation to\nderive verification models from system models, and (3) propose some theoretical\ncriteria how to reduce the model size. The latter is in particular important,\nas for the verification of complex systems, an efficient model reflecting the\nproperties of the system under consideration is equally important to the\nverification algorithm itself. Finally, we present an extension of the\nmodel-based development tool FTOS, designed to develop fault-tolerant systems,\nto demonstrate %the benefits of our approach.\n", "versions": [{"version": "v1", "created": "Mon, 25 May 2009 05:58:03 GMT"}, {"version": "v2", "created": "Wed, 3 Jun 2009 09:21:10 GMT"}, {"version": "v3", "created": "Wed, 21 Oct 2009 09:24:30 GMT"}], "update_date": "2016-11-18", "authors_parsed": [["Cheng", "Chih-Hong", ""], ["Buckl", "Christian", ""], ["Esparza", "Javier", ""], ["Knoll", "Alois", ""]]}, {"id": "0905.3967", "submitter": "Maria Potop-Butucaru", "authors": "Zohir Bouzid (LIP6), Maria Potop-Butucaru (LIP6, INRIA Rocquencourt),\n  S\\'ebastien Tixeuil (LIP6, INRIA Futurs)", "title": "Optimal byzantine resilient convergence in oblivious robot networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a set of robots with arbitrary initial location and no agreement on a\nglobal coordinate system, convergence requires that all robots asymptotically\napproach the exact same, but unknown beforehand, location. Robots are\noblivious-- they do not recall the past computations -- and are allowed to move\nin a one-dimensional space. Additionally, robots cannot communicate directly,\ninstead they obtain system related information only via visual sensors. We draw\na connection between the convergence problem in robot networks, and the\ndistributed \\emph{approximate agreement} problem (that requires correct\nprocesses to decide, for some constant $\\epsilon$, values distance $\\epsilon$\napart and within the range of initial proposed values). Surprisingly, even\nthough specifications are similar, the convergence implementation in robot\nnetworks requires specific assumptions about synchrony and Byzantine\nresilience. In more details, we prove necessary and sufficient conditions for\nthe convergence of mobile robots despite a subset of them being Byzantine (i.e.\nthey can exhibit arbitrary behavior). Additionally, we propose a deterministic\nconvergence algorithm for robot networks and analyze its correctness and\ncomplexity in various synchrony settings. The proposed algorithm tolerates f\nByzantine robots for (2f+1)-sized robot networks in fully synchronous networks,\n(3f+1)-sized in semi-synchronous networks. These bounds are optimal for the\nclass of cautious algorithms, which guarantee that correct robots always move\ninside the range of positions of the correct robots.\n", "versions": [{"version": "v1", "created": "Mon, 25 May 2009 19:17:06 GMT"}], "update_date": "2009-05-26", "authors_parsed": [["Bouzid", "Zohir", "", "LIP6"], ["Potop-Butucaru", "Maria", "", "LIP6, INRIA Rocquencourt"], ["Tixeuil", "S\u00e9bastien", "", "LIP6, INRIA Futurs"]]}, {"id": "0905.4147", "submitter": "Zvika Brakerski", "authors": "Zvika Brakerski and Boaz Patt-Shamir", "title": "Distributed Discovery of Large Near-Cliques", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given an undirected graph and $0\\le\\epsilon\\le1$, a set of nodes is called\n$\\epsilon$-near clique if all but an $\\epsilon$ fraction of the pairs of nodes\nin the set have a link between them. In this paper we present a fast\nsynchronous network algorithm that uses small messages and finds a near-clique.\nSpecifically, we present a constant-time algorithm that finds, with constant\nprobability of success, a linear size $\\epsilon$-near clique if there exists an\n$\\epsilon^3$-near clique of linear size in the graph. The algorithm uses\nmessages of $O(\\log n)$ bits. The failure probability can be reduced to\n$n^{-\\Omega(1)}$ in $O(\\log n)$ time, and the algorithm also works if the graph\ncontains a clique of size $\\Omega(n/\\log^{\\alpha}\\log n)$ for some $\\alpha \\in\n(0,1)$.\n", "versions": [{"version": "v1", "created": "Tue, 26 May 2009 09:51:35 GMT"}], "update_date": "2009-05-27", "authors_parsed": [["Brakerski", "Zvika", ""], ["Patt-Shamir", "Boaz", ""]]}, {"id": "0905.4918", "submitter": "Josep M. Pujol", "authors": "Josep M. Pujol, Vijay Erramilli and Pablo Rodriguez", "title": "Divide and Conquer: Partitioning Online Social Networks", "comments": "7 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.AI cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Online Social Networks (OSNs) have exploded in terms of scale and scope over\nthe last few years. The unprecedented growth of these networks present\nchallenges in terms of system design and maintenance. One way to cope with this\nis by partitioning such large networks and assigning these partitions to\ndifferent machines. However, social networks possess unique properties that\nmake the partitioning problem non-trivial. The main contribution of this paper\nis to understand different properties of social networks and how these\nproperties can guide the choice of a partitioning algorithm. Using large scale\nmeasurements representing real OSNs, we first characterize different properties\nof social networks, and then we evaluate qualitatively different partitioning\nmethods that cover the design space. We expose different trade-offs involved\nand understand them in light of properties of social networks. We show that a\njudicious choice of a partitioning scheme can help improve performance.\n", "versions": [{"version": "v1", "created": "Fri, 29 May 2009 16:29:40 GMT"}], "update_date": "2009-06-01", "authors_parsed": [["Pujol", "Josep M.", ""], ["Erramilli", "Vijay", ""], ["Rodriguez", "Pablo", ""]]}]