[{"id": "0708.0600", "submitter": "Michael Lee", "authors": "Michael J. Lee", "title": "Complementary algorithms for graphs and percolation", "comments": "5 pages, 3 figures, poster version presented at statphys23 (2007)", "journal-ref": null, "doi": "10.1103/PhysRevE.76.027702", "report-no": null, "categories": "cs.DS", "license": null, "abstract": "  A pair of complementary algorithms are presented. One of the pair is a fast\nmethod for connecting graphs with an edge. The other is a fast method for\nremoving edges from a graph. Both algorithms employ the same tree based graph\nrepresentation and so, in concert, can arbitrarily modify any graph. Since the\nclusters of a percolation model may be described as simple connected graphs, an\nefficient Monte Carlo scheme can be constructed that uses the algorithms to\nsweep the occupation probability back and forth between two turning points.\nThis approach concentrates computational sampling time within a region of\ninterest. A high precision value of pc = 0.59274603(9) was thus obtained, by\nMersenne twister, for the two dimensional square site percolation threshold.\n", "versions": [{"version": "v1", "created": "Sat, 4 Aug 2007 02:56:13 GMT"}], "update_date": "2009-11-13", "authors_parsed": [["Lee", "Michael J.", ""]]}, {"id": "0708.0909", "submitter": "Sebastien Tixeuil", "authors": "L\\'elia Blin (IBISC), Maria Gradinariu Potop-Butucaru (INRIA\n  Rocquencourt, LIP6), S\\'ebastien Tixeuil (INRIA Futurs, LRI)", "title": "On the Self-stabilization of Mobile Robots in Graphs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DC", "license": null, "abstract": "  Self-stabilization is a versatile technique to withstand any transient fault\nin a distributed system. Mobile robots (or agents) are one of the emerging\ntrends in distributed computing as they mimic autonomous biologic entities. The\ncontribution of this paper is threefold. First, we present a new model for\nstudying mobile entities in networks subject to transient faults. Our model\ndiffers from the classical robot model because robots have constraints about\nthe paths they are allowed to follow, and from the classical agent model\nbecause the number of agents remains fixed throughout the execution of the\nprotocol. Second, in this model, we study the possibility of designing\nself-stabilizing algorithms when those algorithms are run by mobile robots (or\nagents) evolving on a graph. We concentrate on the core building blocks of\nrobot and agents problems: naming and leader election. Not surprisingly, when\nno constraints are given on the network graph topology and local execution\nmodel, both problems are impossible to solve. Finally, using minimal hypothesis\nwith respect to impossibility results, we provide deterministic and\nprobabilistic solutions to both problems, and show equivalence of these\nproblems by an algorithmic reduction mechanism.\n", "versions": [{"version": "v1", "created": "Tue, 7 Aug 2007 09:34:14 GMT"}, {"version": "v2", "created": "Wed, 8 Aug 2007 09:11:22 GMT"}], "update_date": "2009-09-29", "authors_parsed": [["Blin", "L\u00e9lia", "", "IBISC"], ["Potop-Butucaru", "Maria Gradinariu", "", "INRIA\n  Rocquencourt, LIP6"], ["Tixeuil", "S\u00e9bastien", "", "INRIA Futurs, LRI"]]}, {"id": "0708.2351", "submitter": "Judit Nagy-Gy\\\"orgy", "authors": "Judit Nagy-Gy\\\"orgy", "title": "Randomized algorithm for the k-server problem on decomposable spaces", "comments": "11 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DM", "license": null, "abstract": "  We study the randomized k-server problem on metric spaces consisting of\nwidely separated subspaces. We give a method which extends existing algorithms\nto larger spaces with the growth rate of the competitive quotients being at\nmost O(log k). This method yields o(k)-competitive algorithms solving the\nrandomized k-server problem, for some special underlying metric spaces, e.g.\nHSTs of \"small\" height (but unbounded degree). HSTs are important tools for\nprobabilistic approximation of metric spaces.\n", "versions": [{"version": "v1", "created": "Fri, 17 Aug 2007 11:54:44 GMT"}], "update_date": "2007-08-20", "authors_parsed": [["Nagy-Gy\u00f6rgy", "Judit", ""]]}, {"id": "0708.2544", "submitter": "Gregory Gutin", "authors": "G. Gutin and E.J. Kim", "title": "On the Complexity of the Minimum Cost Homomorphism Problem for Reflexive\n  Multipartite Tournaments", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.DS", "license": null, "abstract": "  For digraphs $D$ and $H$, a mapping $f: V(D)\\dom V(H)$ is a homomorphism of\n$D$ to $H$ if $uv\\in A(D)$ implies $f(u)f(v)\\in A(H).$ For a fixed digraph $H$,\nthe homomorphism problem is to decide whether an input digraph $D$ admits a\nhomomorphism to $H$ or not, and is denoted as HOMP($H$). Digraphs are allowed\nto have loops, but not allowed to have parallel arcs.\n  A natural optimization version of the homomorphism problem is defined as\nfollows. If each vertex $u \\in V(D)$ is associated with costs $c_i(u), i \\in\nV(H)$, then the cost of the homomorphism $f$ is $\\sum_{u\\in V(D)}c_{f(u)}(u)$.\nFor each fixed digraph $H$, we have the {\\em minimum cost homomorphism problem\nfor} $H$ and denote it as MinHOMP($H$). The problem is to decide, for an input\ngraph $D$ with costs $c_i(u),$ $u \\in V(D), i\\in V(H)$, whether there exists a\nhomomorphism of $D$ to $H$ and, if one exists, to find one of minimum cost.\n  In a recent paper, we posed a problem of characterizing polynomial time\nsolvable and NP-hard cases of the minimum cost homomorphism problem for acyclic\nmultipartite tournaments with possible loops (w.p.l.). In this paper, we solve\nthe problem for reflexive multipartite tournaments and demonstrate a\nconsiderate difficulty of the problem for the whole class of multipartite\ntournaments w.p.l. using, as an example, acyclic 3-partite tournaments of order\n4 w.p.l.\\footnote{This paper was submitted to Discrete Mathematics on April 6,\n2007}\n", "versions": [{"version": "v1", "created": "Sun, 19 Aug 2007 13:00:59 GMT"}], "update_date": "2007-08-21", "authors_parsed": [["Gutin", "G.", ""], ["Kim", "E. J.", ""]]}, {"id": "0708.2545", "submitter": "Gregory Gutin", "authors": "E.J. Kim and G. Gutin", "title": "Complexity of the Minimum Cost Homomorphism Problem for Semicomplete\n  Digraphs with Possible Loops", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.DS", "license": null, "abstract": "  For digraphs $D$ and $H$, a mapping $f: V(D)\\dom V(H)$ is a homomorphism of\n$D$ to $H$ if $uv\\in A(D)$ implies $f(u)f(v)\\in A(H).$ For a fixed digraph $H$,\nthe homomorphism problem is to decide whether an input digraph $D$ admits a\nhomomorphism to $H$ or not, and is denoted as HOM($H$).\n  An optimization version of the homomorphism problem was motivated by a\nreal-world problem in defence logistics and was introduced in\n\\cite{gutinDAM154a}. If each vertex $u \\in V(D)$ is associated with costs\n$c_i(u), i \\in V(H)$, then the cost of the homomorphism $f$ is $\\sum_{u\\in\nV(D)}c_{f(u)}(u)$. For each fixed digraph $H$, we have the {\\em minimum cost\nhomomorphism problem for} $H$ and denote it as MinHOM($H$). The problem is to\ndecide, for an input graph $D$ with costs $c_i(u),$ $u \\in V(D), i\\in V(H)$,\nwhether there exists a homomorphism of $D$ to $H$ and, if one exists, to find\none of minimum cost.\n  Although a complete dichotomy classification of the complexity of MinHOM($H$)\nfor a digraph $H$ remains an unsolved problem, complete dichotomy\nclassifications for MinHOM($H$) were proved when $H$ is a semicomplete digraph\n\\cite{gutinDAM154b}, and a semicomplete multipartite digraph \\cite{gutinDAM}.\nIn these studies, it is assumed that the digraph $H$ is loopless. In this\npaper, we present a full dichotomy classification for semicomplete digraphs\nwith possible loops, which solves a problem in \\cite{gutinRMS}.\\footnote{This\npaper was submitted to SIAM J. Discrete Math. on October 27, 2006}\n", "versions": [{"version": "v1", "created": "Sun, 19 Aug 2007 13:47:00 GMT"}], "update_date": "2007-08-21", "authors_parsed": [["Kim", "E. J.", ""], ["Gutin", "G.", ""]]}, {"id": "0708.2936", "submitter": "David P{\\l}aneta S", "authors": "David S. Planeta", "title": "Priority Queue Based on Multilevel Prefix Tree", "comments": null, "journal-ref": null, "doi": null, "report-no": "TR2006-2023", "categories": "cs.DS", "license": null, "abstract": "  Tree structures are very often used data structures. Among ordered types of\ntrees there are many variants whose basic operations such as insert, delete,\nsearch, delete-min are characterized by logarithmic time complexity. In the\narticle I am going to present the structure whose time complexity for each of\nthe above operations is $O(\\frac{M}{K} + K)$, where M is the size of data type\nand K is constant properly matching the size of data type. Properly matched K\nwill make the structure function as a very effective Priority Queue. The\nstructure size linearly depends on the number and size of elements. PTrie is a\nclever combination of the idea of prefix tree -- Trie, structure of logarithmic\ntime complexity for insert and remove operations, doubly linked list and\nqueues.\n", "versions": [{"version": "v1", "created": "Tue, 21 Aug 2007 22:59:49 GMT"}], "update_date": "2007-08-23", "authors_parsed": [["Planeta", "David S.", ""]]}, {"id": "0708.3259", "submitter": "Rasmus Pagh", "authors": "Philip Bille, Anna Pagh, Rasmus Pagh", "title": "Fast evaluation of union-intersection expressions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DB cs.IR", "license": null, "abstract": "  We show how to represent sets in a linear space data structure such that\nexpressions involving unions and intersections of sets can be computed in a\nworst-case efficient way. This problem has applications in e.g. information\nretrieval and database systems. We mainly consider the RAM model of\ncomputation, and sets of machine words, but also state our results in the I/O\nmodel. On a RAM with word size $w$, a special case of our result is that the\nintersection of $m$ (preprocessed) sets, containing $n$ elements in total, can\nbe computed in expected time $O(n (\\log w)^2 / w + km)$, where $k$ is the\nnumber of elements in the intersection. If the first of the two terms\ndominates, this is a factor $w^{1-o(1)}$ faster than the standard solution of\nmerging sorted lists. We show a cell probe lower bound of time $\\Omega(n/(w m\n\\log m)+ (1-\\tfrac{\\log k}{w}) k)$, meaning that our upper bound is nearly\noptimal for small $m$. Our algorithm uses a novel combination of approximate\nset representations and word-level parallelism.\n", "versions": [{"version": "v1", "created": "Thu, 23 Aug 2007 22:23:04 GMT"}], "update_date": "2007-08-27", "authors_parsed": [["Bille", "Philip", ""], ["Pagh", "Anna", ""], ["Pagh", "Rasmus", ""]]}, {"id": "0708.3408", "submitter": "David P{\\l}aneta S", "authors": "David S. Planeta", "title": "Linear Time Algorithms Based on Multilevel Prefix Tree for Finding\n  Shortest Path with Positive Weights and Minimum Spanning Tree in a Networks", "comments": null, "journal-ref": null, "doi": null, "report-no": "Cornell University TR2006-2043", "categories": "cs.DS", "license": null, "abstract": "  In this paper I present general outlook on questions relevant to the basic\ngraph algorithms; Finding the Shortest Path with Positive Weights and Minimum\nSpanning Tree. I will show so far known solution set of basic graph problems\nand present my own. My solutions to graph problems are characterized by their\nlinear worst-case time complexity. It should be noticed that the algorithms\nwhich compute the Shortest Path and Minimum Spanning Tree problems not only\nanalyze the weight of arcs (which is the main and often the only criterion of\nsolution hitherto known algorithms) but also in case of identical path weights\nthey select this path which walks through as few vertices as possible. I have\npresented algorithms which use priority queue based on multilevel prefix tree\n-- PTrie. PTrie is a clever combination of the idea of prefix tree -- Trie, the\nstructure of logarithmic time complexity for insert and remove operations,\ndoubly linked list and queues. In C++ I will implement linear worst-case time\nalgorithm computing the Single-Destination Shortest-Paths problem and I will\nexplain its usage.\n", "versions": [{"version": "v1", "created": "Fri, 24 Aug 2007 21:58:29 GMT"}], "update_date": "2007-08-28", "authors_parsed": [["Planeta", "David S.", ""]]}, {"id": "0708.3696", "submitter": "Michael Mahoney", "authors": "Petros Drineas, Michael W. Mahoney and S. Muthukrishnan", "title": "Relative-Error CUR Matrix Decompositions", "comments": "40 pages, 10 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS", "license": null, "abstract": "  Many data analysis applications deal with large matrices and involve\napproximating the matrix using a small number of ``components.'' Typically,\nthese components are linear combinations of the rows and columns of the matrix,\nand are thus difficult to interpret in terms of the original features of the\ninput data. In this paper, we propose and study matrix approximations that are\nexplicitly expressed in terms of a small number of columns and/or rows of the\ndata matrix, and thereby more amenable to interpretation in terms of the\noriginal data. Our main algorithmic results are two randomized algorithms which\ntake as input an $m \\times n$ matrix $A$ and a rank parameter $k$. In our first\nalgorithm, $C$ is chosen, and we let $A'=CC^+A$, where $C^+$ is the\nMoore-Penrose generalized inverse of $C$. In our second algorithm $C$, $U$, $R$\nare chosen, and we let $A'=CUR$. ($C$ and $R$ are matrices that consist of\nactual columns and rows, respectively, of $A$, and $U$ is a generalized inverse\nof their intersection.) For each algorithm, we show that with probability at\nleast $1-\\delta$: $$ ||A-A'||_F \\leq (1+\\epsilon) ||A-A_k||_F, $$ where $A_k$\nis the ``best'' rank-$k$ approximation provided by truncating the singular\nvalue decomposition (SVD) of $A$. The number of columns of $C$ and rows of $R$\nis a low-degree polynomial in $k$, $1/\\epsilon$, and $\\log(1/\\delta)$. Our two\nalgorithms are the first polynomial time algorithms for such low-rank matrix\napproximations that come with relative-error guarantees; previously, in some\ncases, it was not even known whether such matrix decompositions exist. Both of\nour algorithms are simple, they take time of the order needed to approximately\ncompute the top $k$ singular vectors of $A$, and they use a novel, intuitive\nsampling method called ``subspace sampling.''\n", "versions": [{"version": "v1", "created": "Mon, 27 Aug 2007 23:34:50 GMT"}], "update_date": "2007-08-29", "authors_parsed": [["Drineas", "Petros", ""], ["Mahoney", "Michael W.", ""], ["Muthukrishnan", "S.", ""]]}, {"id": "0708.4284", "submitter": "Mariano Zelke", "authors": "Mariano Zelke", "title": "Optimal Per-Edge Processing Times in the Semi-Streaming Model", "comments": "8 pages, 1 table", "journal-ref": "Information Processing Letters, Volume 104, Issue 3, 2007, Pages\n  106-112", "doi": null, "report-no": null, "categories": "cs.DM cs.DS", "license": null, "abstract": "  We present semi-streaming algorithms for basic graph problems that have\noptimal per-edge processing times and therefore surpass all previous\nsemi-streaming algorithms for these tasks. The semi-streaming model, which is\nappropriate when dealing with massive graphs, forbids random access to the\ninput and restricts the memory to O(n*polylog n) bits.\n  Particularly, the formerly best per-edge processing times for finding the\nconnected components and a bipartition are O(alpha(n)), for determining\nk-vertex and k-edge connectivity O(k^2n) and O(n*log n) respectively for any\nconstant k and for computing a minimum spanning forest O(log n). All these time\nbounds we reduce to O(1).\n  Every presented algorithm determines a solution asymptotically as fast as the\nbest corresponding algorithm up to date in the classical RAM model, which\ntherefore cannot convert the advantage of unlimited memory and random access\ninto superior computing times for these problems.\n", "versions": [{"version": "v1", "created": "Fri, 31 Aug 2007 07:19:27 GMT"}], "update_date": "2007-09-03", "authors_parsed": [["Zelke", "Mariano", ""]]}, {"id": "0708.4288", "submitter": "Philip Bille", "authors": "Philip Bille", "title": "Pattern Matching in Trees and Strings", "comments": "PhD dissertation, 140 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS", "license": null, "abstract": "  We study the design of efficient algorithms for combinatorial pattern\nmatching. More concretely, we study algorithms for tree matching, string\nmatching, and string matching in compressed texts.\n", "versions": [{"version": "v1", "created": "Fri, 31 Aug 2007 08:07:32 GMT"}], "update_date": "2007-09-03", "authors_parsed": [["Bille", "Philip", ""]]}, {"id": "0708.4399", "submitter": "Steven G. Johnson", "authors": "Xuancheng Shao and Steven G. Johnson", "title": "Type-IV DCT, DST, and MDCT algorithms with reduced numbers of arithmetic\n  operations", "comments": "11 pages", "journal-ref": "Signal Processing vol. 88, issue 6, p. 1313-1326 (2008)", "doi": "10.1016/j.sigpro.2007.11.024", "report-no": null, "categories": "cs.DS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present algorithms for the type-IV discrete cosine transform (DCT-IV) and\ndiscrete sine transform (DST-IV), as well as for the modified discrete cosine\ntransform (MDCT) and its inverse, that achieve a lower count of real\nmultiplications and additions than previously published algorithms, without\nsacrificing numerical accuracy. Asymptotically, the operation count is reduced\nfrom ~2NlogN to ~(17/9)NlogN for a power-of-two transform size N, and the exact\ncount is strictly lowered for all N > 4. These results are derived by\nconsidering the DCT to be a special case of a DFT of length 8N, with certain\nsymmetries, and then pruning redundant operations from a recent improved fast\nFourier transform algorithm (based on a recursive rescaling of the\nconjugate-pair split radix algorithm). The improved algorithms for DST-IV and\nMDCT follow immediately from the improved count for the DCT-IV.\n", "versions": [{"version": "v1", "created": "Fri, 31 Aug 2007 18:00:33 GMT"}, {"version": "v2", "created": "Thu, 29 Jan 2009 19:18:21 GMT"}], "update_date": "2009-01-29", "authors_parsed": [["Shao", "Xuancheng", ""], ["Johnson", "Steven G.", ""]]}]