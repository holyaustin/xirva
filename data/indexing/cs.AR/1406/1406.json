[{"id": "1406.0309", "submitter": "Christoforos Kachris", "authors": "Christoforos Kachris, Georgios Sirakoulis, Dimitrios Soudris", "title": "Network Function Virtualization based on FPGAs:A Framework for\n  all-Programmable network devices", "comments": "Network function virtualizations, FPGA, dynamic reconfiguration", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Network Function Virtualization (NFV) refers to the use of commodity hardware\nresources as the basic platform to perform specialized network functions as\nopposed to specialized hardware devices. Currently, NFV is mainly implemented\nbased on general purpose processors, or general purpose network processors. In\nthis paper we propose the use of FPGAs as an ideal platform for NFV that can be\nused to provide both the flexibility of virtualizations and the high\nperformance of the specialized hardware. We present the early attempts of using\nFPGAs dynamic reconfiguration in network processing applications to provide\nflexible network functions and we present the opportunities for an FPGA-based\nNFV platform.\n", "versions": [{"version": "v1", "created": "Mon, 2 Jun 2014 09:45:59 GMT"}], "update_date": "2014-06-03", "authors_parsed": [["Kachris", "Christoforos", ""], ["Sirakoulis", "Georgios", ""], ["Soudris", "Dimitrios", ""]]}, {"id": "1406.1565", "submitter": "EPTCS", "authors": "John W. O'Leary (Intel Corp.), David M. Russinoff (Intel Corp)", "title": "Modeling Algorithms in SystemC and ACL2", "comments": "In Proceedings ACL2 2014, arXiv:1406.1238", "journal-ref": "EPTCS 152, 2014, pp. 145-162", "doi": "10.4204/EPTCS.152.12", "report-no": null, "categories": "cs.AR cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe the formal language MASC, based on a subset of SystemC and\nintended for modeling algorithms to be implemented in hardware. By means of a\nspecial-purpose parser, an algorithm coded in SystemC is converted to a MASC\nmodel for the purpose of documentation, which in turn is translated to ACL2 for\nformal verification. The parser also generates a SystemC variant that is\nsuitable as input to a high-level synthesis tool. As an illustration of this\nmethodology, we describe a proof of correctness of a simple 32-bit radix-4\nmultiplier.\n", "versions": [{"version": "v1", "created": "Fri, 6 Jun 2014 01:48:45 GMT"}], "update_date": "2014-06-09", "authors_parsed": [["O'Leary", "John W.", "", "Intel Corp."], ["Russinoff", "David M.", "", "Intel Corp"]]}, {"id": "1406.1886", "submitter": "Raul Rojas Prof.", "authors": "Raul Rojas", "title": "The Z1: Architecture and Algorithms of Konrad Zuse's First Computer", "comments": "24 pages, 20 figures", "journal-ref": null, "doi": null, "report-no": "DCIS-14-1", "categories": "cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper provides the first comprehensive description of the Z1, the\nmechanical computer built by the German inventor Konrad Zuse in Berlin from\n1936 to 1938. The paper describes the main structural elements of the machine,\nthe high-level architecture, and the dataflow between components. The computer\ncould perform the four basic arithmetic operations using floating-point\nnumbers. Instructions were read from punched tape. A program consisted of a\nsequence of arithmetical operations, intermixed with memory store and load\ninstructions, interrupted possibly by input and output operations. Numbers were\nstored in a mechanical memory. The machine did not include conditional\nbranching in the instruction set. While the architecture of the Z1 is similar\nto the relay computer Zuse finished in 1941 (the Z3) there are some significant\ndifferences. The Z1 implements operations as sequences of microinstructions, as\nin the Z3, but does not use rotary switches as micro-steppers. The Z1 uses a\ndigital incrementer and a set of conditions which are translated into\nmicroinstructions for the exponent and mantissa units, as well as for the\nmemory blocks. Microinstructions select one out of 12 layers in a machine with\na 3D mechanical structure of binary mechanical elements. The exception circuits\nfor mantissa zero, necessary for normalized floating-point, were lacking; they\nwere first implemented in the Z3. The information for this article was\nextracted from careful study of the blueprints drawn by Zuse for the\nreconstruction of the Z1 for the German Technology Museum in Berlin, from some\nletters, and from sketches in notebooks. Although the machine has been in\nexhibition since 1989 (non-operational), no detailed high-level description of\nthe machine's architecture had been available. This paper fills that gap.\n", "versions": [{"version": "v1", "created": "Sat, 7 Jun 2014 11:23:31 GMT"}], "update_date": "2014-06-10", "authors_parsed": [["Rojas", "Raul", ""]]}, {"id": "1406.3568", "submitter": "Alessandro Lonardo", "authors": "A. Lonardo, F. Ameli, R. Ammendola, A. Biagioni, O. Frezza, G.\n  Lamanna, F. Lo Cicero, M. Martinelli, P. S. Paolucci, E. Pastorelli, L.\n  Pontisso, D. Rossetti, F. Simeone, F. Simula, M. Sozzi, L. Tosoratto and P.\n  Vicini", "title": "NaNet: a Low-Latency, Real-Time, Multi-Standard Network Interface Card\n  with GPUDirect Features", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "physics.ins-det cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While the GPGPU paradigm is widely recognized as an effective approach to\nhigh performance computing, its adoption in low-latency, real-time systems is\nstill in its early stages.\n  Although GPUs typically show deterministic behaviour in terms of latency in\nexecuting computational kernels as soon as data is available in their internal\nmemories, assessment of real-time features of a standard GPGPU system needs\ncareful characterization of all subsystems along data stream path.\n  The networking subsystem results in being the most critical one in terms of\nabsolute value and fluctuations of its response latency.\n  Our envisioned solution to this issue is NaNet, a FPGA-based PCIe Network\nInterface Card (NIC) design featuring a configurable and extensible set of\nnetwork channels with direct access through GPUDirect to NVIDIA Fermi/Kepler\nGPU memories.\n  NaNet design currently supports both standard - GbE (1000BASE-T) and 10GbE\n(10Base-R) - and custom - 34~Gbps APElink and 2.5~Gbps deterministic latency\nKM3link - channels, but its modularity allows for a straightforward inclusion\nof other link technologies.\n  To avoid host OS intervention on data stream and remove a possible source of\njitter, the design includes a network/transport layer offload module with\ncycle-accurate, upper-bound latency, supporting UDP, KM3link Time Division\nMultiplexing and APElink protocols.\n  After NaNet architecture description and its latency/bandwidth\ncharacterization for all supported links, two real world use cases will be\npresented: the GPU-based low level trigger for the RICH detector in the NA62\nexperiment at CERN and the on-/off-shore data link for KM3 underwater neutrino\ntelescope.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jun 2014 15:27:05 GMT"}], "update_date": "2014-06-16", "authors_parsed": [["Lonardo", "A.", ""], ["Ameli", "F.", ""], ["Ammendola", "R.", ""], ["Biagioni", "A.", ""], ["Frezza", "O.", ""], ["Lamanna", "G.", ""], ["Cicero", "F. Lo", ""], ["Martinelli", "M.", ""], ["Paolucci", "P. S.", ""], ["Pastorelli", "E.", ""], ["Pontisso", "L.", ""], ["Rossetti", "D.", ""], ["Simeone", "F.", ""], ["Simula", "F.", ""], ["Sozzi", "M.", ""], ["Tosoratto", "L.", ""], ["Vicini", "P.", ""]]}, {"id": "1406.4628", "submitter": "Ravi Khatwal", "authors": "Ravi Khatwal, Manoj Kumar Jain", "title": "An Efficient Synchronous Static Memory design for Embedded System", "comments": "Embeddded system, International Journal of Computer\n  Applications(2013)", "journal-ref": null, "doi": "10.5120/11187-6411 10.5120/11187-6411", "report-no": null, "categories": "cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Custom memory organization are challenging task in the area of VLSI design.\nThis study aims to design high speed and low power consumption memory for\nembedded system. Synchronous SRAM has been proposed and analyzed using various\nsimulators. Xilinx simulator simulates the Synchronous SRAM memories which can\nperform efficient read/write capability for embedded systems. Xinix tool also\nprovide the access time that required selecting a word and reading it.\nSynchronous Static RAM which has easily read /writes capability and performs\nscheduled read /writes operation in efficient manner.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jun 2014 07:50:50 GMT"}], "update_date": "2014-06-19", "authors_parsed": [["Khatwal", "Ravi", ""], ["Jain", "Manoj Kumar", ""]]}, {"id": "1406.5000", "submitter": "Ravi Khatwal", "authors": "Ravi Khatwal, Manoj Kumar Jain", "title": "Application Specific Cache Simulation Analysis for Application Specific\n  Instruction set Processor", "comments": "ASIP simulation", "journal-ref": null, "doi": "10.5120/15782-4526", "report-no": null, "categories": "cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An Efficient Simulation of application specific instruction-set processors\n(ASIP) is a challenging onus in the area of VLSI design. This paper\nreconnoiters the possibility of use of ASIP simulators for ASIP Simulation.\nThis proposed study allow as the simulation of the cache memory design with\nvarious ASIP simulators like Simple scalar and VEX. In this paper we have\nimplemented the memory configuration according to desire application. These\nsimulators performs the cache related results such as cache name, sets, cache\nassociativity, cache block size, cache replacement policy according to specific\napplication.\n", "versions": [{"version": "v1", "created": "Thu, 19 Jun 2014 10:40:23 GMT"}], "update_date": "2014-06-20", "authors_parsed": [["Khatwal", "Ravi", ""], ["Jain", "Manoj Kumar", ""]]}, {"id": "1406.6037", "submitter": "Sreepathi Pai", "authors": "Sreepathi Pai, R. Govindarajan, Matthew J. Thazhuthaveetil", "title": "Preemptive Thread Block Scheduling with Online Structural Runtime\n  Prediction for Concurrent GPGPU Kernels", "comments": "14 pages, full pre-review version of PACT 2014 poster", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent NVIDIA Graphics Processing Units (GPUs) can execute multiple kernels\nconcurrently. On these GPUs, the thread block scheduler (TBS) uses the FIFO\npolicy to schedule their thread blocks. We show that FIFO leaves performance to\nchance, resulting in significant loss of performance and fairness. To improve\nperformance and fairness, we propose use of the preemptive Shortest Remaining\nTime First (SRTF) policy instead. Although SRTF requires an estimate of runtime\nof GPU kernels, we show that such an estimate of the runtime can be easily\nobtained using online profiling and exploiting a simple observation on GPU\nkernels' grid structure. Specifically, we propose a novel Structural Runtime\nPredictor. Using a simple Staircase model of GPU kernel execution, we show that\nthe runtime of a kernel can be predicted by profiling only the first few thread\nblocks. We evaluate an online predictor based on this model on benchmarks from\nERCBench, and find that it can estimate the actual runtime reasonably well\nafter the execution of only a single thread block. Next, we design a thread\nblock scheduler that is both concurrent kernel-aware and uses this predictor.\nWe implement the SRTF policy and evaluate it on two-program workloads from\nERCBench. SRTF improves STP by 1.18x and ANTT by 2.25x over FIFO. When compared\nto MPMax, a state-of-the-art resource allocation policy for concurrent kernels,\nSRTF improves STP by 1.16x and ANTT by 1.3x. To improve fairness, we also\npropose SRTF/Adaptive which controls resource usage of concurrently executing\nkernels to maximize fairness. SRTF/Adaptive improves STP by 1.12x, ANTT by\n2.23x and Fairness by 2.95x compared to FIFO. Overall, our implementation of\nSRTF achieves system throughput to within 12.64% of Shortest Job First (SJF, an\noracle optimal scheduling policy), bridging 49% of the gap between FIFO and\nSJF.\n", "versions": [{"version": "v1", "created": "Mon, 23 Jun 2014 19:44:03 GMT"}], "update_date": "2014-06-25", "authors_parsed": [["Pai", "Sreepathi", ""], ["Govindarajan", "R.", ""], ["Thazhuthaveetil", "Matthew J.", ""]]}, {"id": "1406.7662", "submitter": "Harish M Kittur", "authors": "Mohammed Zackriya. V, Harish M Kittur", "title": "Selective Match-Line Energizer Content Addressable Memory(SMLE -CAM)", "comments": "6 pages, 12 figures. Accepted for publication, International Journal\n  of applied Engineering Research,Vol. 8 No. 19, 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A Content Addressable Memory (CAM) is a memory primarily designed for high\nspeed search operation. Parallel search scheme forms the basis of CAM, thus\npower reduction is the challenge associated with a large amount of parallel\nactive circuits. We are presenting a novel algorithm and architecture described\nas Selective Match-Line Energizer Content Addressable Memory (SMLE-CAM) which\nenergizes only those MLs (Match-Line) whose first three bits are conditionally\nmatched with corresponding first three search bit using special architecture\nwhich comprises of novel XNOR-CAM cell and novel XOR-CAM cell. The rest of the\nCAM chain is followed by NOR-CAM cell. The 256 X 144 bit SMLE-CAM is\nimplemented in TSMC 90 nm technology and its robustness across PVT variation is\nverified. The post-layout simulation result shows, it has energy metric of\n0.115 fJ/bit/search with search time 361.6 ps, the best reported so far. The\nmaximum operating frequency is 1GHz.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jun 2014 10:46:50 GMT"}], "update_date": "2014-07-01", "authors_parsed": [["Zackriya.", "Mohammed", "V"], ["Kittur", "Harish M", ""]]}]