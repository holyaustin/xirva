[{"id": "1209.3099", "submitter": "Jalil Boukhobza", "authors": "Jalil Boukhobza (Lab-STICC), Pierre Olivier (Lab-STICC), St\\'ephane\n  Rubini (LISYC)", "title": "A Cache Management Strategy to Replace Wear Leveling Techniques for\n  Embedded Flash Memory", "comments": "Ce papier a obtenu le \"Best Paper Award\" dans le \"Computer System\n  track\" nombre de page: 8; International Symposium on Performance Evaluation\n  of Computer & Telecommunication Systems, La Haye : Netherlands (2011)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Prices of NAND flash memories are falling drastically due to market growth\nand fabrication process mastering while research efforts from a technological\npoint of view in terms of endurance and density are very active. NAND flash\nmemories are becoming the most important storage media in mobile computing and\ntend to be less confined to this area. The major constraint of such a\ntechnology is the limited number of possible erase operations per block which\ntend to quickly provoke memory wear out. To cope with this issue,\nstate-of-the-art solutions implement wear leveling policies to level the wear\nout of the memory and so increase its lifetime. These policies are integrated\ninto the Flash Translation Layer (FTL) and greatly contribute in decreasing the\nwrite performance. In this paper, we propose to reduce the flash memory wear\nout problem and improve its performance by absorbing the erase operations\nthroughout a dual cache system replacing FTL wear leveling and garbage\ncollection services. We justify this idea by proposing a first performance\nevaluation of an exclusively cache based system for embedded flash memories.\nUnlike wear leveling schemes, the proposed cache solution reduces the total\nnumber of erase operations reported on the media by absorbing them in the cache\nfor workloads expressing a minimal global sequential rate.\n", "versions": [{"version": "v1", "created": "Fri, 14 Sep 2012 06:09:10 GMT"}], "update_date": "2012-09-17", "authors_parsed": [["Boukhobza", "Jalil", "", "Lab-STICC"], ["Olivier", "Pierre", "", "Lab-STICC"], ["Rubini", "St\u00e9phane", "", "LISYC"]]}, {"id": "1209.3564", "submitter": "Saeid Sharifian nia", "authors": "Saeid Sharifian Nia, Abbas Vafaei, Hamid Shahimohamadi", "title": "Deadlock Recovery Technique in Bus Enhanced NoC Architecture", "comments": "10 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Increase in the speed of processors has led to crucial role of communication\nin the performance of systems. As a result, routing is taken into consideration\nas one of the most important subjects of the Network on Chip architecture.\nRouting algorithms to deadlock avoidance prevent packets route completely based\non network traffic condition by means of restricting the route of packets. This\naction leads to less performance especially in non-uniform traffic patterns. On\nthe other hand True Fully Adoptive Routing algorithm provides routing of\npackets completely based on traffic condition. However, deadlock detection and\nrecovery mechanisms are needed to handle deadlocks. Use of global bus beside\nNoC as a parallel supportive environment, provide platform to offer advantages\nof both features of bus and NoC. This bus is useful for broadcast and multicast\noperations, sending delay sensitive signals, system management and other\nservices. In this research, we use this bus as an escaping path for deadlock\nrecovery technique. According to simulation results, this bus is suitable\nplatform for deadlock recovery technique.\n", "versions": [{"version": "v1", "created": "Mon, 17 Sep 2012 07:14:15 GMT"}], "update_date": "2012-09-18", "authors_parsed": [["Nia", "Saeid Sharifian", ""], ["Vafaei", "Abbas", ""], ["Shahimohamadi", "Hamid", ""]]}, {"id": "1209.4818", "submitter": "Noam Presman", "authors": "Noam Presman and Simon Litsyn", "title": "Recursive Descriptions of Polar Codes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.IT cs.AR math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Polar codes are recursive general concatenated codes. This property motivates\na recursive formalization of the known decoding algorithms: Successive\nCancellation, Successive Cancellation with Lists and Belief Propagation. Using\nsuch description allows an easy development of these algorithms for arbitrary\npolarizing kernels. Hardware architectures for these decoding algorithms are\nalso described in a recursive way, both for Arikan's standard polar codes and\nfor arbitrary polarizing kernels.\n", "versions": [{"version": "v1", "created": "Fri, 21 Sep 2012 13:46:26 GMT"}, {"version": "v2", "created": "Sun, 1 Feb 2015 17:33:30 GMT"}, {"version": "v3", "created": "Thu, 18 Jun 2015 17:22:42 GMT"}], "update_date": "2015-06-19", "authors_parsed": [["Presman", "Noam", ""], ["Litsyn", "Simon", ""]]}]