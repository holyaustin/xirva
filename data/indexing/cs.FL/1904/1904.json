[{"id": "1904.00833", "submitter": "Peter Chini", "authors": "Peter Chini, Roland Meyer, Prakash Saivasan", "title": "Liveness in Broadcast Networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study liveness and model checking problems for broadcast networks, a\nsystem model of identical clients communicating via message passing. The first\nproblem that we consider is Liveness Verification. It asks whether there is a\ncomputation such that one of the clients visits a final state infinitely often.\nThe complexity of the problem has been open since 2010 when it was shown to be\nP-hard and solvable in EXPSPACE. We close the gap by a polynomial-time\nalgorithm. The algorithm relies on a characterization of live computations in\nterms of paths in a suitable graph, combined with a fixed-point iteration to\nefficiently check the existence of such paths. The second problem is Fair\nLiveness Verification. It asks for a computation where all participating\nclients visit a final state infinitely often. We adjust the algorithm to also\nsolve fair liveness in polynomial time.\n  Both problems can be instrumented to answer model checking questions for\nbroadcast networks against linear time temporal logic specifications. The first\nproblem in this context is Fair Model Checking. It demands that for all\ncomputations of a broadcast network, all participating clients satisfy the\nspecification. We solve the problem via the Vardi-Wolper construction and a\nreduction to Liveness Verification. The second problem is Sparse Model\nChecking. It asks whether each computation has a participating client that\nsatisfies the specification. We reduce the problem to Fair Liveness\nVerification.\n", "versions": [{"version": "v1", "created": "Mon, 1 Apr 2019 13:22:24 GMT"}, {"version": "v2", "created": "Fri, 31 May 2019 09:52:15 GMT"}, {"version": "v3", "created": "Tue, 21 Jul 2020 08:59:20 GMT"}], "update_date": "2020-07-22", "authors_parsed": [["Chini", "Peter", ""], ["Meyer", "Roland", ""], ["Saivasan", "Prakash", ""]]}, {"id": "1904.00850", "submitter": "Miguel Romero", "authors": "Pablo Barcel\\'o, Diego Figueira, Miguel Romero", "title": "Boundedness of Conjunctive Regular Path Queries", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.DM cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the boundedness problem for unions of conjunctive regular path\nqueries with inverses (UC2RPQs). This is the problem of, given a UC2RPQ,\nchecking whether it is equivalent to a union of conjunctive queries (UCQ). We\nshow the problem to be ExpSpace-complete, thus coinciding with the complexity\nof containment for UC2RPQs. As a corollary, when a UC2RPQ is bounded, it is\nequivalent to a UCQ of at most triple-exponential size, and in fact we show\nthat this bound is optimal. We also study better behaved classes of UC2RPQs,\nnamely acyclic UC2RPQs of bounded thickness, and strongly connected UCRPQs,\nwhose boundedness problem are, respectively, PSpace-complete and\n$\\Pi^p_2$-complete. Most upper bounds exploit results on limitedness for\ndistance automata, in particular extending the model with alternation and\ntwo-wayness, which may be of independent interest.\n", "versions": [{"version": "v1", "created": "Mon, 1 Apr 2019 13:47:58 GMT"}], "update_date": "2019-04-02", "authors_parsed": [["Barcel\u00f3", "Pablo", ""], ["Figueira", "Diego", ""], ["Romero", "Miguel", ""]]}, {"id": "1904.00976", "submitter": "Florence Clerc", "authors": "Linan Chen, Florence Clerc and Prakash Panangaden", "title": "Bisimulation for Feller-Dynkin Processes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bisimulation is a concept that captures behavioural equivalence. It has been\nstudied extensively on nonprobabilistic systems and on discrete-time Markov\nprocesses and on so-called continuous-time Markov chains. In the latter time is\ncontinuous but the evolution still proceeds in jumps. We propose two\ndefinitions of bisimulation on continuous-time stochastic processes where the\nevolution is a \\emph{flow} through time. We show that they are equivalent and\nwe show that when restricted to discrete-time, our concept of bisimulation\nencompasses the standard discrete-time concept. The concept we introduce is not\na straightforward generalization of discrete-time concepts.\n", "versions": [{"version": "v1", "created": "Mon, 1 Apr 2019 17:27:17 GMT"}], "update_date": "2019-04-02", "authors_parsed": [["Chen", "Linan", ""], ["Clerc", "Florence", ""], ["Panangaden", "Prakash", ""]]}, {"id": "1904.01381", "submitter": "Abuzer Yakaryilmaz", "authors": "Aleksejs Naumovs, Maksims Dimitrijevs, and Abuzer Yakary{\\i}lmaz", "title": "The minimal probabilistic and quantum finite automata recognizing\n  uncountably many languages with fixed cutpoints", "comments": "12 pages, minor revisions, changing the format to \"dmtcs-episciences\"\n  style", "journal-ref": "Discrete Mathematics & Theoretical Computer Science, vol. 22 no.\n  1, Automata, Logic and Semantics (April 30, 2020) dmtcs:6440", "doi": "10.23638/DMTCS-22-1-13", "report-no": null, "categories": "cs.FL cs.CC quant-ph", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  It is known that 2-state binary and 3-state unary probabilistic finite\nautomata and 2-state unary quantum finite automata recognize uncountably many\nlanguages with cutpoints. These results have been obtained by associating each\nrecognized language with a cutpoint and then by using the fact that there are\nuncountably many cutpoints. In this note, we prove the same results for fixed\ncutpoints: each recognized language is associated with an automaton (i.e.,\nalgorithm), and the proofs use the fact that there are uncountably many\nautomata. For each case, we present a new construction.\n", "versions": [{"version": "v1", "created": "Tue, 2 Apr 2019 12:52:20 GMT"}, {"version": "v2", "created": "Fri, 10 May 2019 10:52:53 GMT"}, {"version": "v3", "created": "Thu, 2 Apr 2020 16:22:43 GMT"}, {"version": "v4", "created": "Tue, 28 Apr 2020 12:36:57 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Naumovs", "Aleksejs", ""], ["Dimitrijevs", "Maksims", ""], ["Yakary\u0131lmaz", "Abuzer", ""]]}, {"id": "1904.01388", "submitter": "Pierre Ganty", "authors": "Pierre Ganty, Francesco Ranzato, Pedro Valero", "title": "Complete Abstractions for Checking Language Inclusion", "comments": "39 pages, 4 figures, 6 algorithms, revised and extended version of\n  our SAS 2019 paper (https://doi.org/10.1007/978-3-030-32304-2_8). arXiv admin\n  note: text overlap with arXiv:2008.08828", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the language inclusion problem $L_1 \\subseteq L_2$ where $L_1$ is\nregular or context-free. Our approach relies on abstract interpretation and\nchecks whether an overapproximating abstraction of $L_1$, obtained by\noverapproximating the Kleene iterates of its least fixpoint characterization,\nis included in $L_2$. We show that a language inclusion problem is decidable\nwhenever this overapproximating abstraction satisfies a completeness condition\n(i.e., its loss of precision causes no false alarm) and prevents infinite\nascending chains (i.e., it guarantees termination of least fixpoint\ncomputations). This overapproximating abstraction of languages can be defined\nusing quasiorder relations on words, where the abstraction gives the language\nof all the words \"greater than or equal to\" a given input word for that\nquasiorder. We put forward a range of such quasiorders that allow us to\nsystematically design decision procedures for different language inclusion\nproblems such as regular languages into regular languages or into trace sets of\none-counter nets, and context-free languages into regular languages. In the\ncase of inclusion between regular languages, some of the induced inclusion\nchecking procedures correspond to well-known state-of-the-art algorithms like\nthe so-called antichain algorithms. Finally, we provide an equivalent language\ninclusion checking algorithm based on a greatest fixpoint computation that\nrelies on quotients of languages and, to the best of our knowledge, was not\npreviously known.\n", "versions": [{"version": "v1", "created": "Tue, 2 Apr 2019 13:07:23 GMT"}, {"version": "v2", "created": "Wed, 13 Jan 2021 11:44:22 GMT"}], "update_date": "2021-01-14", "authors_parsed": [["Ganty", "Pierre", ""], ["Ranzato", "Francesco", ""], ["Valero", "Pedro", ""]]}, {"id": "1904.01605", "submitter": "Waqar Ahmed", "authors": "Waqar Ahmed, Shahid Ali Murtza, Osman Hasan and Sofiene Tahar", "title": "On the Formalization of Importance Measures using HOL Theorem Proving", "comments": "10 pages, 2 figures, International Conference on Formal Methods in\n  Software Engineering (FormaliSE'19). arXiv admin note: text overlap with\n  arXiv:1608.06392", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Importance measures provide a systematic approach to scrutinize critical\nsystem components, which are extremely beneficial in making important\ndecisions, such as prioritizing reliability improvement activities, identifying\nweak-links and effective usage of given resources. The importance measures are\nthen in turn used to obtain a criticality value for each system component and\nto rank the components in descending manner. Simulations tools are generally\nused to perform importance measure based analysis, but they require expensive\ncomputations and thus they are not suitable for large systems. A more scalable\napproach is to utilize the importance measures to obtain all the necessary\nconditions by proving a generic relationship describing the relative importance\nbetween any pair of components in a system. In this paper, we propose to use\nhigher-order-logic (HOL) theorem proving to verify such relationships and thus\nmaking sure that all the essential conditions are accompanied by the proven\nproperty. In particular, we formalize the commonly used importance measures,\nsuch as Birnbaum and Fussell-Vesely, and conduct a formal importance measure\nanalysis of a railway signaling system at a Moroccan level crossing as an\napplication for illustration purpose.\n", "versions": [{"version": "v1", "created": "Tue, 2 Apr 2019 18:16:10 GMT"}], "update_date": "2019-04-04", "authors_parsed": [["Ahmed", "Waqar", ""], ["Murtza", "Shahid Ali", ""], ["Hasan", "Osman", ""], ["Tahar", "Sofiene", ""]]}, {"id": "1904.02428", "submitter": "Etienne Moutot", "authors": "Mika Hirvensalo, Etienne Moutot, Abuzer Yakary{\\i}lmaz", "title": "Computational Limitations of Affine Automata", "comments": "Accepted in Unconventional Computation and Natural Computation (UCNC)\n  2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present two new results on the computational limitations of affine\nautomata. First, we show that the computation of bounded-error rational-values\naffine automata is simulated in logarithmic space. Second, we give an\nimpossibility result for algebraic-valued affine automata. As a result, we\nidentify some unary languages (in logarithmic space) that are not recognized by\nalgebraic-valued affine automata with cutpoints.\n", "versions": [{"version": "v1", "created": "Thu, 4 Apr 2019 09:33:41 GMT"}], "update_date": "2019-04-05", "authors_parsed": [["Hirvensalo", "Mika", ""], ["Moutot", "Etienne", ""], ["Yakary\u0131lmaz", "Abuzer", ""]]}, {"id": "1904.03264", "submitter": "Yu Wang", "authors": "Yu Wang, Alper Kamil Bozkurt and Miroslav Pajic", "title": "Attack-Resilient Supervisory Control of Discrete-Event Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we study the problem of supervisory control of discrete-event\nsystems (DES) in the presence of attacks that tamper with inputs and outputs of\nthe plant. We consider a very general system setup as we focus on both\ndeterministic and nondeterministic plants that we model as finite state\ntransducers (FSTs); this also covers the conventional approach to modeling DES\nas deterministic finite automata. Furthermore, we cover a wide class of attacks\nthat can nondeterministically add, remove, or rewrite a sensing and/or\nactuation word to any word from predefined regular languages, and show how such\nattacks can be modeled by nondeterministic FSTs; we also present how the use of\nFSTs facilitates modeling realistic (and very complex) attacks, as well as\nprovides the foundation for design of attack-resilient supervisory controllers.\nSpecifically, we first consider the supervisory control problem for\ndeterministic plants with attacks (i) only on their sensors, (ii) only on their\nactuators, and (iii) both on their sensors and actuators. For each case, we\ndevelop new conditions for controllability in the presence of attacks, as well\nas synthesizing algorithms to obtain FST-based description of such\nattack-resilient supervisors. A derived resilient controller provides a set of\nall safe control words that can keep the plant work desirably even in the\npresence of corrupted observation and/or if the control words are subjected to\nactuation attacks. Then, we extend the controllability theorems and the\nsupervisor synthesizing algorithms to nondeterministic plants that satisfy a\nnonblocking condition. Finally, we illustrate applicability of our methodology\non several examples and numerical case-studies.\n", "versions": [{"version": "v1", "created": "Fri, 5 Apr 2019 20:23:03 GMT"}, {"version": "v2", "created": "Wed, 20 May 2020 02:45:35 GMT"}], "update_date": "2020-05-21", "authors_parsed": [["Wang", "Yu", ""], ["Bozkurt", "Alper Kamil", ""], ["Pajic", "Miroslav", ""]]}, {"id": "1904.04090", "submitter": "Thorsten Wissmann", "authors": "J. Leroux and M. Praveen and Ph. Schnoebelen and G. Sutre", "title": "On Functions Weakly Computable by Pushdown Petri Nets and Related\n  Systems", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 4 (December\n  18, 2019) lmcs:5984", "doi": "10.23638/LMCS-15(4:15)2019", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We consider numerical functions weakly computable by grammar-controlled\nvector addition systems (GVASes, a variant of pushdown Petri nets). GVASes can\nweakly compute all fast growing functions $F_\\alpha$ for\n$\\alpha<\\omega^\\omega$, hence they are computationally more powerful than\nstandard vector addition systems. On the other hand they cannot weakly compute\nthe inverses $F_\\alpha^{-1}$ or indeed any sublinear function. The proof relies\non a pumping lemma for runs of GVASes that is of independent interest.\n", "versions": [{"version": "v1", "created": "Mon, 8 Apr 2019 14:27:18 GMT"}, {"version": "v2", "created": "Mon, 25 Nov 2019 17:09:00 GMT"}, {"version": "v3", "created": "Tue, 17 Dec 2019 09:51:33 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Leroux", "J.", ""], ["Praveen", "M.", ""], ["Schnoebelen", "Ph.", ""], ["Sutre", "G.", ""]]}, {"id": "1904.06242", "submitter": "Sahar Mohajerani", "authors": "Sahar Mohajerani, Stephane Lafortune", "title": "Transforming opacity verification to nonblocking verification in modular\n  systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the verification of current-state and K-step opacity for systems\nmodeled as interacting non-deterministic finite-state automata. We describe a\nnew methodology for compositional opacity verification that employs\nabstraction, in the form of a notion called opaque observation equivalence, and\nthat leverages existing compositional nonblocking verification algorithms. The\ncompositional approach is based on a transformation of the system, where the\ntransformed system is nonblocking if and only if the original one is\ncurrent-state opaque. Furthermore, we prove that $K$-step opacity can also be\ninferred if the transformed system is nonblocking. We provide experimental\nresults where current-state opacity is verified efficiently for a large\nscaled-up system.\n", "versions": [{"version": "v1", "created": "Fri, 12 Apr 2019 14:08:15 GMT"}, {"version": "v2", "created": "Mon, 13 May 2019 14:35:55 GMT"}], "update_date": "2019-05-14", "authors_parsed": [["Mohajerani", "Sahar", ""], ["Lafortune", "Stephane", ""]]}, {"id": "1904.06942", "submitter": "Benedikt Bollig", "authors": "Benedikt Bollig and Paul Gastin", "title": "Non-Sequential Theory of Distributed Systems", "comments": "lecture notes, 74 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  These lecture notes cover basic automata-theoretic concepts and logical\nformalisms for the modeling and verification of concurrent and distributed\nsystems. Many of these concepts naturally extend the classical automata and\nlogics over words, which provide a framework for modeling sequential systems. A\ndistributed system, on the other hand, combines several (finite or recursive)\nprocesses, and will therefore be modeled as a collection of (finite or\npushdown, respectively) automata. A crucial parameter of a distributed system\nis the kind of interaction that is allowed between processes. In this lecture,\nwe focus on the message-passing paradigm. In general, communication in a\ndistributed system creates complex dependencies between events, which are\nhidden when using a sequential, operational semantics. The approach taken here\nis based on a faithful preservation of the dependencies of concurrent events.\nThat is, an execution of a system is modeled as a partial order, or graph,\nrather than a sequence of events.\n", "versions": [{"version": "v1", "created": "Mon, 15 Apr 2019 10:11:35 GMT"}], "update_date": "2019-04-16", "authors_parsed": [["Bollig", "Benedikt", ""], ["Gastin", "Paul", ""]]}, {"id": "1904.07445", "submitter": "Antonio E. Porreca", "authors": "Claudio Ferretti, Alberto Leporati, Luca Manzoni, Antonio E. Porreca", "title": "The many roads to the simulation of reaction systems", "comments": "Postprint, to appear in Fundamenta Informaticae", "journal-ref": "Fundamenta Informaticae, vol. 171, no. 1-4, pp. 175-188, 2020", "doi": "10.3233/FI-2020-1878", "report-no": null, "categories": "cs.FL cs.CE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reaction systems are a computational model inspired by the bio-chemical\nreactions that happen inside biological cells. They have been and currently are\nstudied for their many nice theoretical properties. They are also a useful\nmodeling tool for biochemical systems, but in order to be able to employ them\neffectively in the field the presence of efficient and widely available\nsimulators is essential. Here we explore three different algorithms and\nimplementations of the simulation, comparing them to the current state of the\nart. We also show that we can obtain performances comparable to GPU-based\nsimulations on real-world systems by using a carefully tuned CPU-based\nsimulator.\n", "versions": [{"version": "v1", "created": "Mon, 15 Apr 2019 13:08:44 GMT"}], "update_date": "2020-08-05", "authors_parsed": [["Ferretti", "Claudio", ""], ["Leporati", "Alberto", ""], ["Manzoni", "Luca", ""], ["Porreca", "Antonio E.", ""]]}, {"id": "1904.07694", "submitter": "Avraham Trahtman N", "authors": "A.N. Trahtman", "title": "Matrix approach to synchronizing automata", "comments": "19-pages.3 figures An error removed. arXiv admin note: text overlap\n  with arXiv:1405.2435, arXiv:1202.4626", "journal-ref": null, "doi": "10.13140/RG.2.2.12464.66566", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A word $w$ of letters on edges of underlying graph $\\Gamma$ of deterministic\nfinite automaton (DFA) is called synchronizing if $w$ sends all states of the\nautomaton to a unique state. J. \\v{C}erny discovered in 1964 a sequence of\n$n$-state complete DFA possessing a minimal synchronizing word of length\n$(n-1)^2$. The hypothesis, well known today as \\v{C}erny conjecture, claims\nthat $(n-1)^2$ is a precise upper bound on the length of such a word over\nalphabet $\\Sigma$ of letters on edges of $\\Gamma$ for every complete $n$-state\nDFA. The hypothesis was formulated distinctly in 1966 by Starke. A special\nclasses of matrices induced by words in the alphabet of labels on edges of the\nunderlying graph of DFA are used for the study of synchronizing automata.\n", "versions": [{"version": "v1", "created": "Sat, 13 Apr 2019 10:43:47 GMT"}, {"version": "v2", "created": "Mon, 22 Jul 2019 13:16:43 GMT"}, {"version": "v3", "created": "Sat, 2 Nov 2019 07:26:09 GMT"}, {"version": "v4", "created": "Mon, 11 Nov 2019 13:48:31 GMT"}], "update_date": "2019-11-12", "authors_parsed": [["Trahtman", "A. N.", ""]]}, {"id": "1904.08187", "submitter": "Jeffrey Shallit", "authors": "Trevor Clokie, Daniel Gabric, Jeffrey Shallit", "title": "Circularly squarefree words and unbordered conjugates: a new approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Using a new approach based on automatic sequences, logic, and a decision\nprocedure, we reprove some old theorems about circularly squarefree words and\nunbordered conjugates in a new and simpler way. Furthermore, we prove three new\nresults about unbordered conjugates: we complete the classification, due to\nHarju and Nowotka, of binary words with the maximum number of unbordered\nconjugates; we prove that for every possible number, up to the maximum, there\nexists a word having that number of unbordered conjugates, and finally, we\ndetermine the expected number of unbordered conjugates in a random word.\n", "versions": [{"version": "v1", "created": "Wed, 17 Apr 2019 11:15:13 GMT"}], "update_date": "2019-04-18", "authors_parsed": [["Clokie", "Trevor", ""], ["Gabric", "Daniel", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1904.08402", "submitter": "Dmitry Chistikov", "authors": "Dmitry Chistikov and Mikhail Vyalyi", "title": "Re-pairing brackets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Consider the following one-player game. Take a well-formed sequence of\nopening and closing brackets. As a move, the player can pair any opening\nbracket with any closing bracket to its right, erasing them. The goal is to\nre-pair (erase) the entire sequence, and the complexity of a strategy is\nmeasured by its width: the maximum number of nonempty segments of symbols\n(separated by blank space) seen during the play.\n  For various initial sequences, we prove upper and lower bounds on the minimum\nwidth sufficient for re-pairing. (In particular, the sequence associated with\nthe complete binary tree of height $n$ admits a strategy of width\nsub-exponential in $\\log n$.) Our two key contributions are (1) lower bounds on\nthe width and (2) their application in automata theory: quasi-polynomial lower\nbounds on the translation from one-counter automata to Parikh-equivalent\nnondeterministic finite automata. The latter result answers a question by Atig\net al. (2016).\n", "versions": [{"version": "v1", "created": "Wed, 17 Apr 2019 17:57:41 GMT"}], "update_date": "2019-04-18", "authors_parsed": [["Chistikov", "Dmitry", ""], ["Vyalyi", "Mikhail", ""]]}, {"id": "1904.08590", "submitter": "Sayan Mukherjee", "authors": "Paul Gastin, Sayan Mukherjee, B Srivathsan", "title": "Fast algorithms for handling diagonal constraints in timed automata", "comments": "Shorter version of this article to appear in CAV 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A popular method for solving reachability in timed automata proceeds by\nenumerating reachable sets of valuations represented as zones. A na\\\"ive\nenumeration of zones does not terminate. Various termination mechanisms have\nbeen studied over the years. Coming up with efficient termination mechanisms\nhas been remarkably more challenging when the automaton has diagonal\nconstraints in guards.\n  In this paper, we propose a new termination mechanism for timed automata with\ndiagonal constraints based on a new simulation relation between zones.\nExperiments with an implementation of this simulation show significant gains\nover existing methods.\n", "versions": [{"version": "v1", "created": "Thu, 18 Apr 2019 04:37:59 GMT"}], "update_date": "2019-04-19", "authors_parsed": [["Gastin", "Paul", ""], ["Mukherjee", "Sayan", ""], ["Srivathsan", "B", ""]]}, {"id": "1904.08802", "submitter": "Tobias Kapp\\'e", "authors": "Gerco van Heerdt, Tobias Kapp\\'e, Jurriaan Rot, Matteo Sammartino,\n  Alexandra Silva", "title": "Tree Automata as Algebras: Minimisation and Determinisation", "comments": null, "journal-ref": null, "doi": "10.4230/LIPIcs.CALCO.2019.6", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study a categorical generalisation of tree automata, as $\\Sigma$-algebras\nfor a fixed endofunctor $\\Sigma$ endowed with initial and final states. Under\nmild assumptions about the base category, we present a general minimisation\nalgorithm for these automata. We then build upon and extend an existing\ngeneralisation of the Nerode equivalence to a categorical setting and relate it\nto the existence of minimal automata. Finally, we show that generalised types\nof side-effects, such as non-determinism, can be captured by this categorical\nframework, leading to a general determinisation procedure.\n", "versions": [{"version": "v1", "created": "Thu, 18 Apr 2019 14:23:34 GMT"}, {"version": "v2", "created": "Tue, 16 Jul 2019 10:09:01 GMT"}], "update_date": "2019-12-11", "authors_parsed": [["van Heerdt", "Gerco", ""], ["Kapp\u00e9", "Tobias", ""], ["Rot", "Jurriaan", ""], ["Sammartino", "Matteo", ""], ["Silva", "Alexandra", ""]]}, {"id": "1904.08824", "submitter": "Mathias Ramparison", "authors": "\\'Etienne Andr\\'e, Didier Lime, Mathias Ramparison", "title": "Parametric updates in parametric timed automata", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 17, Issue 2 (May 10,\n  2021) lmcs:7470", "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce a new class of Parametric Timed Automata (PTAs) where we allow\nclocks to be compared to parameters in guards, as in classic PTAs, but also to\nbe updated to parameters. We focus here on the EF-emptiness problem: \"is the\nset of parameter valuations for which some given location is reachable in the\ninstantiated timed automaton empty?\". This problem is well-known to be\nundecidable for PTAs, and so it is for our extension. Nonetheless, if we update\nall clocks each time we compare a clock with a parameter and each time we\nupdate a clock to a parameter, we obtain a syntactic subclass for which we can\ndecide the EF-emptiness problem and even perform the exact synthesis of the set\nof rational valuations such that a given location is reachable. To the best of\nour knowledge, this is the first non-trivial subclass of PTAs, actually even\nextended with parametric updates, for which this is possible.\n", "versions": [{"version": "v1", "created": "Thu, 18 Apr 2019 14:57:46 GMT"}, {"version": "v2", "created": "Sun, 29 Sep 2019 15:41:34 GMT"}, {"version": "v3", "created": "Fri, 1 May 2020 12:38:17 GMT"}, {"version": "v4", "created": "Mon, 28 Dec 2020 23:25:33 GMT"}, {"version": "v5", "created": "Tue, 30 Mar 2021 13:04:39 GMT"}, {"version": "v6", "created": "Fri, 7 May 2021 13:52:06 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Andr\u00e9", "\u00c9tienne", ""], ["Lime", "Didier", ""], ["Ramparison", "Mathias", ""]]}, {"id": "1904.09125", "submitter": "Pamela Fleischmann", "authors": "Joel D. Day, Pamela Fleischmann, Florin Manea, Dirk Nowotka", "title": "k-Spectra of weakly-c-Balanced Words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A word $u$ is a scattered factor of $w$ if $u$ can be obtained from $w$ by\ndeleting some of its letters. That is, there exist the (potentially empty)\nwords $u_1,u_2,..., u_n$, and $v_0,v_1,..,v_n$ such that $u = u_1u_2...u_n$ and\n$w = v_0u_1v_1u_2v_2...u_nv_n$. We consider the set of length-$k$ scattered\nfactors of a given word w, called here $k$-spectrum and denoted\n$\\ScatFact_k(w)$. We prove a series of properties of the sets $\\ScatFact_k(w)$\nfor binary strictly balanced and, respectively, $c$-balanced words $w$, i.e.,\nwords over a two-letter alphabet where the number of occurrences of each letter\nis the same, or, respectively, one letter has $c$-more occurrences than the\nother. In particular, we consider the question which cardinalities $n=\n|\\ScatFact_k(w)|$ are obtainable, for a positive integer $k$, when $w$ is\neither a strictly balanced binary word of length $2k$, or a $c$-balanced binary\nword of length $2k-c$. We also consider the problem of reconstructing words\nfrom their $k$-spectra.\n", "versions": [{"version": "v1", "created": "Fri, 19 Apr 2019 09:09:49 GMT"}, {"version": "v2", "created": "Fri, 24 May 2019 08:57:45 GMT"}], "update_date": "2019-05-27", "authors_parsed": [["Day", "Joel D.", ""], ["Fleischmann", "Pamela", ""], ["Manea", "Florin", ""], ["Nowotka", "Dirk", ""]]}, {"id": "1904.09133", "submitter": "Olivier Carton", "authors": "Olivier Carton and Elisa Orduna", "title": "Preservation of normality by transducers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider input-deterministic finite state transducers with infinite inputs\nand infinite outputs, and we consider the property of Borel normality on\ninfinite words. When these transducers are given by a strongly connected set of\nstates, and when the input is a Borel normal sequence, the output is an\ninfinite word such that every word has a frequency given by a weighted\nautomaton over the rationals. We prove that there is an algorithm that decides\nin cubic time whether an input-deterministic transducer preserves normality.\n", "versions": [{"version": "v1", "created": "Fri, 19 Apr 2019 09:50:28 GMT"}], "update_date": "2019-04-22", "authors_parsed": [["Carton", "Olivier", ""], ["Orduna", "Elisa", ""]]}, {"id": "1904.09157", "submitter": "Jeffrey Shallit", "authors": "Tim Ng, Pascal Ochem, Narad Rampersad, Jeffrey Shallit", "title": "New results on pseudosquare avoidance", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We start by considering binary words containing the minimum possible numbers\nof squares and antisquares (where an antisquare is a word of the form $x\n\\overline{x}$), and we completely classify which possibilities can occur. We\nconsider avoiding $x p(x)$, where $p$ is any permutation of the underlying\nalphabet, and $x t(x)$, where $t$ is any transformation of the underlying\nalphabet. Finally, we prove the existence of an infinite binary word\nsimultaneously avoiding all occurrences of $x h(x)$ for every nonerasing\nmorphism $h$ and all sufficiently large words $x$.\n", "versions": [{"version": "v1", "created": "Fri, 19 Apr 2019 11:53:45 GMT"}], "update_date": "2019-04-22", "authors_parsed": [["Ng", "Tim", ""], ["Ochem", "Pascal", ""], ["Rampersad", "Narad", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1904.09184", "submitter": "Adriano Peron", "authors": "Laura Bozzelli, Alberto Molinari, Angelo Montanari, Adriano Peron", "title": "Undecidability of future timeline-based planning over dense temporal\n  domains", "comments": "arXiv admin note: text overlap with arXiv:1809.03103", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Planning is one of the most studied problems in computer science. In this\npaper, we consider the timeline-based approach, where the domain is modeled by\na set of independent, but interacting, components, identified by a set of state\nvariables, whose behavior over time (timelines) is governed by a set of\ntemporal constraints (synchronization rules). Timeline-based planning in the\ndense-time setting has been recently shown to be undecidable in the general\ncase, and undecidability relies on the high expressiveness of the trigger\nsynchronization rules. In this paper, we strengthen the previous negative\nresult by showing that undecidability already holds under the future semantics\nof the trigger rules which limits the comparison to temporal contexts in the\nfuture with respect to the trigger.\n", "versions": [{"version": "v1", "created": "Thu, 18 Apr 2019 07:59:44 GMT"}], "update_date": "2019-04-22", "authors_parsed": [["Bozzelli", "Laura", ""], ["Molinari", "Alberto", ""], ["Montanari", "Angelo", ""], ["Peron", "Adriano", ""]]}, {"id": "1904.09203", "submitter": "Sebastian Maneth", "authors": "Joost Engelfriet, Kazuhiro Inaba, Sebastian Maneth", "title": "Linear Bounded Composition of Tree-Walking Tree Transducers: Linear Size\n  Increase and Complexity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compositions of tree-walking tree transducers form a hierarchy with respect\nto the number of transducers in the composition. As main technical result it is\nproved that any such composition can be realized as a linear bounded\ncomposition, which means that the sizes of the intermediate results can be\nchosen to be at most linear in the size of the output tree. This has\nconsequences for the expressiveness and complexity of the translations in the\nhierarchy. First, if the computed translation is a function of linear size\nincrease, i.e., the size of the output tree is at most linear in the size of\nthe input tree, then it can be realized by just one, deterministic,\ntree-walking tree transducer. For compositions of deterministic transducers it\nis decidable whether or not the translation is of linear size increase. Second,\nevery composition of deterministic transducers can be computed in deterministic\nlinear time on a RAM and in deterministic linear space on a Turing machine,\nmeasured in the sum of the sizes of the input and output tree. Similarly, every\ncomposition of nondeterministic transducers can be computed in simultaneous\npolynomial time and linear space on a nondeterministic Turing machine. Their\noutput tree languages are deterministic context-sensitive, i.e., can be\nrecognized in deterministic linear space on a Turing machine. The membership\nproblem for compositions of nondeterministic translations is nondeterministic\npolynomial time and deterministic linear space. The membership problem for the\ncomposition of a nondeterministic and a deterministic tree-walking tree\ntranslation (for a nondeterministic IO macro tree translation) is log-space\nreducible to a context-free language, whereas the membership problem for the\ncomposition of a deterministic and a nondeterministic tree-walking tree\ntranslation (for a nondeterministic OI macro tree translation) is possibly\nNP-complete.\n", "versions": [{"version": "v1", "created": "Fri, 19 Apr 2019 14:20:03 GMT"}, {"version": "v2", "created": "Mon, 29 Apr 2019 12:53:20 GMT"}, {"version": "v3", "created": "Thu, 12 Dec 2019 14:53:57 GMT"}], "update_date": "2019-12-13", "authors_parsed": [["Engelfriet", "Joost", ""], ["Inaba", "Kazuhiro", ""], ["Maneth", "Sebastian", ""]]}, {"id": "1904.09875", "submitter": "Bill Roscoe", "authors": "David Mestel, A.W. Roscoe", "title": "Translating between models of concurrency", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hoare's Communicating Sequential Processes (CSP) admits a rich universe of\nsemantic models closely related to the van Glabbeek spectrum. In this paper we\nstudy finite observational models, of which at least six have been identified\nfor CSP, namely traces, stable failures, revivals, acceptances, refusal testing\nand finite linear observations. We show how to use the recently-introduced\n\\emph{priority} operator to transform refinement questions in these models into\ntrace refinement (language inclusion) tests. Furthermore, we are able to\ngeneralise this to any (rational) finite observational model. As well as being\nof theoretical interest, this is of practical significance since the\nstate-of-the-art refinement checking tool FDR4 currently only supports two such\nmodels. In particular we study how it is possible to check refinement in a\ndiscrete version of the Timed Failures model that supports Timed CSP.\n", "versions": [{"version": "v1", "created": "Mon, 22 Apr 2019 13:49:39 GMT"}], "update_date": "2019-04-23", "authors_parsed": [["Mestel", "David", ""], ["Roscoe", "A. W.", ""]]}, {"id": "1904.10028", "submitter": "Aseem Raj Baranwal", "authors": "Aseem Raj Baranwal and Jeffrey Shallit", "title": "Repetitions in infinite palindrome-rich words", "comments": "12 pages", "journal-ref": null, "doi": "10.1007/978-3-030-28796-2_7", "report-no": null, "categories": "math.CO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Rich words are characterized by containing the maximum possible number of\ndistinct palindromes. Several characteristic properties of rich words have been\nstudied; yet the analysis of repetitions in rich words still involves some\ninteresting open problems. We address lower bounds on the repetition threshold\nof infinite rich words over 2 and 3-letter alphabets, and construct a candidate\ninfinite rich word over the alphabet $\\Sigma_2=\\{0,1\\}$ with a small critical\nexponent of $2+\\sqrt{2}/2$. This represents the first progress on an open\nproblem of Vesti from 2017.\n", "versions": [{"version": "v1", "created": "Mon, 22 Apr 2019 18:52:01 GMT"}], "update_date": "2019-11-15", "authors_parsed": [["Baranwal", "Aseem Raj", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1904.10029", "submitter": "Lucas Mol", "authors": "James D. Currie and Lucas Mol", "title": "The undirected repetition threshold", "comments": "16 pages. Accepted to the WORDS 2019 conference. This version\n  includes minor changes suggested by the anonymous referees", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For rational $1<r\\leq 2$, an undirected $r$-power is a word of the form\n$xyx'$, where $x$ is nonempty, $x'\\in\\{x,x^\\mathrm{R}\\}$, and $|xyx'|/|xy|=r$.\nThe undirected repetition threshold for $k$ letters, denoted $\\mathrm{URT}(k)$,\nis the infimum of the set of all $r$ such that undirected $r$-powers are\navoidable on $k$ letters. We first demonstrate that\n$\\mathrm{URT}(3)=\\tfrac{7}{4}$. Then we show that $\\mathrm{URT}(k)\\geq\n\\tfrac{k-1}{k-2}$ for all $k\\geq 4$. We conjecture that\n$\\mathrm{URT}(k)=\\tfrac{k-1}{k-2}$ for all $k\\geq 4$, and we confirm this\nconjecture for $k\\in\\{4,8,12\\}.$\n", "versions": [{"version": "v1", "created": "Mon, 22 Apr 2019 18:53:14 GMT"}, {"version": "v2", "created": "Mon, 3 Jun 2019 17:06:56 GMT"}], "update_date": "2019-06-04", "authors_parsed": [["Currie", "James D.", ""], ["Mol", "Lucas", ""]]}, {"id": "1904.10174", "submitter": "Shinnosuke Seki", "authors": "Yo-Sub Han, Hwee Kim, Yusei Masuda, Shinnosuke Seki", "title": "A general architecture of oritatami systems for simulating arbitrary\n  finite automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we propose an architecture of oritatami systems with which one\ncan simulate an arbitrary nondeterministic finite automaton (NFA) in a unified\nmanner. The oritatami system is known to be Turing-universal but the simulation\navailable so far requires 542 bead types and $O(t^4 \\log^2 t)$ steps in order\nto simulate $t$ steps of a Turing machine. The architecture we propose employs\nonly 329 bead types and requires just $O(t |Q|^4 |\\Sigma|^2)$ steps to simulate\nan NFA over an input alphabet $\\Sigma$ with a state set $Q$ working on a word\nof length $t$.\n", "versions": [{"version": "v1", "created": "Tue, 23 Apr 2019 06:48:28 GMT"}], "update_date": "2019-04-24", "authors_parsed": [["Han", "Yo-Sub", ""], ["Kim", "Hwee", ""], ["Masuda", "Yusei", ""], ["Seki", "Shinnosuke", ""]]}, {"id": "1904.10226", "submitter": "Filip Mazowiecki sheriff", "authors": "Filip Mazowiecki and Micha{\\l} Pilipczuk", "title": "Reachability for Bounded Branching VASS", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we consider the reachability problem for bounded branching\nVASS. Bounded VASS are a variant of the classic VASS model where all values in\nall configurations are upper bounded by a fixed natural number, encoded in\nbinary in the input. This model gained a lot of attention in 2012 when Haase et\nal. showed its connections with timed automata. Later in 2013 Fearnley and\nJurdzi\\'{n}ski proved that the reachability problem in this model is\nPSPACE-complete even in dimension 1. Here, we investigate the complexity of the\nreachability problem when the model is extended with branching transitions, and\nwe prove that the problem is EXPTIME-complete when the dimension is 2 or\nlarger.\n", "versions": [{"version": "v1", "created": "Tue, 23 Apr 2019 09:53:51 GMT"}, {"version": "v2", "created": "Mon, 19 Aug 2019 08:50:08 GMT"}], "update_date": "2019-08-20", "authors_parsed": [["Mazowiecki", "Filip", ""], ["Pilipczuk", "Micha\u0142", ""]]}, {"id": "1904.10703", "submitter": "Philippe Schnoebelen", "authors": "Jean Goubault-Larrecq and Simon Halfon and Prateek Karandikar and K.\n  Narayan Kumar and Philippe Schnoebelen", "title": "The Ideal Approach to Computing Closed Subsets in Well-Quasi-Ordering", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Elegant and general algorithms for handling upwards-closed and\ndownwards-closed subsets of WQOs can be developed using the filter-based and\nideal-based representation for these sets. These algorithms can be built in a\ngeneric or parameterized way, in parallel with the way complex WQOs are\nobtained by combining or modifying simpler WQOs.\n", "versions": [{"version": "v1", "created": "Wed, 24 Apr 2019 09:06:15 GMT"}], "update_date": "2019-04-25", "authors_parsed": [["Goubault-Larrecq", "Jean", ""], ["Halfon", "Simon", ""], ["Karandikar", "Prateek", ""], ["Kumar", "K. Narayan", ""], ["Schnoebelen", "Philippe", ""]]}, {"id": "1904.10786", "submitter": "Ond\\v{r}ej Leng\\'al", "authors": "Milan \\v{C}e\\v{s}ka, Vojt\\v{e}ch Havlena, Luk\\'a\\v{s} Hol\\'ik, Jan\n  Ko\\v{r}enek, Ond\\v{r}ej Leng\\'al, Denis Matou\\v{s}ek, Ji\\v{r}\\'i\n  Matou\\v{s}ek, Jakub Semri\\v{c}, Tom\\'a\\v{s} Vojnar", "title": "Deep Packet Inspection in FPGAs via Approximate Nondeterministic\n  Automata", "comments": "In Proceedings of FCCM'19", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.NI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deep packet inspection via regular expression (RE) matching is a crucial task\nof network intrusion detection systems (IDSes), which secure Internet\nconnection against attacks and suspicious network traffic. Monitoring\nhigh-speed computer networks (100 Gbps and faster) in a single-box solution\ndemands that the RE matching, traditionally based on finite automata (FAs), is\naccelerated in hardware. In this paper, we describe a novel FPGA architecture\nfor RE matching that is able to process network traffic beyond 100 Gbps. The\nkey idea is to reduce the required FPGA resources by leveraging approximate\nnondeterministic FAs (NFAs). The NFAs are compiled into a multi-stage\narchitecture starting with the least precise stage with a high throughput and\nending with the most precise stage with a low throughput. To obtain the reduced\nNFAs, we propose new approximate reduction techniques that take into account\nthe profile of the network traffic. Our experiments showed that using our\napproach, we were able to perform matching of large sets of REs from SNORT, a\npopular IDS, on unprecedented network speeds.\n", "versions": [{"version": "v1", "created": "Wed, 24 Apr 2019 13:13:07 GMT"}], "update_date": "2019-04-25", "authors_parsed": [["\u010ce\u0161ka", "Milan", ""], ["Havlena", "Vojt\u011bch", ""], ["Hol\u00edk", "Luk\u00e1\u0161", ""], ["Ko\u0159enek", "Jan", ""], ["Leng\u00e1l", "Ond\u0159ej", ""], ["Matou\u0161ek", "Denis", ""], ["Matou\u0161ek", "Ji\u0159\u00ed", ""], ["Semri\u010d", "Jakub", ""], ["Vojnar", "Tom\u00e1\u0161", ""]]}, {"id": "1904.11007", "submitter": "Shili Sheng", "authors": "Shili Sheng, Erfan Pakdamanian, Kyungtae Han, BaekGyu Kim, Prashant\n  Tiwari, Inki Kim, Lu Feng", "title": "A Case Study of Trust on Autonomous Driving", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.HC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As autonomous vehicles have benefited the society, understanding the dynamic\nchange of humans' trust during human-autonomous vehicle interaction can help to\nimprove the safety and performance of autonomous driving. We designed and\nconducted a human subjects study involving 19 participants. Each participant\nwas asked to enter their trust level in a Likert scale in real-time during\nexperiments on a driving simulator. We also collected physiological data (e.g.,\nheart rate, pupil size) of participants as complementary indicators of trust.\nWe used analysis of variance (ANOVA) and Signal Temporal Logic (STL) to analyze\nthe experimental data. Our results show the influence of different factors\n(e.g., automation alarms, weather conditions) on trust, and the individual\nvariability in human reaction time and trust change.\n", "versions": [{"version": "v1", "created": "Tue, 16 Apr 2019 15:15:44 GMT"}, {"version": "v2", "created": "Thu, 18 Jul 2019 16:30:26 GMT"}], "update_date": "2019-07-19", "authors_parsed": [["Sheng", "Shili", ""], ["Pakdamanian", "Erfan", ""], ["Han", "Kyungtae", ""], ["Kim", "BaekGyu", ""], ["Tiwari", "Prashant", ""], ["Kim", "Inki", ""], ["Feng", "Lu", ""]]}, {"id": "1904.11100", "submitter": "Taylor J. Smith", "authors": "Taylor J. Smith, Kai Salomaa", "title": "Decision Problems for Restricted Variants of Two-Dimensional Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A two-dimensional finite automaton has a read-only input head that moves in\nfour directions on a finite array of cells labelled by symbols of the input\nalphabet. A three-way two-dimensional automaton is prohibited from making\nupward moves, while a two-way two-dimensional automaton can only move downward\nand rightward.\n  We show that the language emptiness problem for unary three-way\nnondeterministic two-dimensional automata is NP-complete, and is in P for\ngeneral-alphabet two-way nondeterministic two-dimensional automata. We show\nthat the language equivalence problem for two-way deterministic two-dimensional\nautomata is decidable, while both the equivalence and universality problems for\ntwo-way nondeterministic two-dimensional automata are undecidable. The\ndeterministic case is the first known positive decidability result for the\nequivalence problem on two-dimensional automata over a general alphabet. We\nshow that there exists a unary three-way deterministic two-dimensional\nautomaton with a nonregular column projection, and we show that the row\nprojection of a unary three-way nondeterministic two-dimensional automaton is\nalways regular.\n", "versions": [{"version": "v1", "created": "Wed, 24 Apr 2019 23:55:44 GMT"}], "update_date": "2019-04-26", "authors_parsed": [["Smith", "Taylor J.", ""], ["Salomaa", "Kai", ""]]}, {"id": "1904.11573", "submitter": "Stefan Kiefer", "authors": "Stefan Kiefer and Richard Mayr and Mahsa Shirmohammadi and Patrick\n  Totzke", "title": "B\\\"uchi Objectives in Countable MDPs", "comments": "full version of an ICALP'19 paper. This update only fixes some\n  typesetting issues", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.PR cs.FL math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study countably infinite Markov decision processes with B\\\"uchi\nobjectives, which ask to visit a given subset of states infinitely often. A\nquestion left open by T.P. Hill in 1979 is whether there always exist\n$\\varepsilon$-optimal Markov strategies, i.e., strategies that base decisions\nonly on the current state and the number of steps taken so far. We provide a\nnegative answer to this question by constructing a non-trivial counterexample.\nOn the other hand, we show that Markov strategies with only 1 bit of extra\nmemory are sufficient.\n", "versions": [{"version": "v1", "created": "Thu, 25 Apr 2019 20:29:11 GMT"}, {"version": "v2", "created": "Tue, 30 Apr 2019 12:40:19 GMT"}], "update_date": "2019-05-01", "authors_parsed": [["Kiefer", "Stefan", ""], ["Mayr", "Richard", ""], ["Shirmohammadi", "Mahsa", ""], ["Totzke", "Patrick", ""]]}, {"id": "1904.11863", "submitter": "Marc  Zeitoun", "authors": "Thomas Place and Marc Zeitoun", "title": "On all things star-free", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the star-free closure, which associates to a class of\nlanguages its closure under Boolean operations and marked concatenation. We\nprove that the star-free closure of any finite class and of any class of groups\nlanguages with decidable separation (plus mild additional properties) has\ndecidable separation. We actually show decidability of a stronger property,\ncalled covering. This generalizes many results on the subject in a unified\nframework. A key ingredient is that star-free closure coincides with another\nclosure operator where Kleene stars are also allowed in restricted contexts.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2019 14:20:45 GMT"}], "update_date": "2019-04-29", "authors_parsed": [["Place", "Thomas", ""], ["Zeitoun", "Marc", ""]]}, {"id": "1904.12135", "submitter": "Maurice Margenstern", "authors": "Maurice Margenstern", "title": "About Fibonacci trees. I", "comments": "17 pages, 9 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this first paper, we look at the following question: are the properties of\nthe Fibonacci tree still true if we consider a finitely generated tree by the\nsame rules but rooted at a black node? The direct answer is no, but new\nproperties arise, a bit more complex than in the case of a tree rooted at a\nwhite node, but still of interest.\n", "versions": [{"version": "v1", "created": "Sat, 27 Apr 2019 09:31:32 GMT"}], "update_date": "2019-04-30", "authors_parsed": [["Margenstern", "Maurice", ""]]}, {"id": "1904.12446", "submitter": "Pawe{\\l} Parys", "authors": "Pawe{\\l} Parys", "title": "Parity Games: Zielonka's Algorithm in Quasi-Polynomial Time", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Calude, Jain, Khoussainov, Li, and Stephan (2017) proposed a\nquasi-polynomial-time algorithm solving parity games. After this breakthrough\nresult, a few other quasi-polynomial-time algorithms were introduced; none of\nthem is easy to understand. Moreover, it turns out that in practice they\noperate very slowly. On the other side there is the Zielonka's recursive\nalgorithm, which is very simple, exponential in the worst case, and the fastest\nin practice. We combine these two approaches: we propose a small modification\nof the Zielonka's algorithm, which ensures that the running time is at most\nquasi-polynomial. In effect, we obtain a simple algorithm that solves parity\ngames in quasi-polynomial time. We also hope that our algorithm, after further\noptimizations, can lead to an algorithm that shares the good performance of the\nZielonka's algorithm on typical inputs, while reducing the worst-case\ncomplexity on difficult inputs.\n", "versions": [{"version": "v1", "created": "Mon, 29 Apr 2019 04:47:47 GMT"}], "update_date": "2019-04-30", "authors_parsed": [["Parys", "Pawe\u0142", ""]]}, {"id": "1904.12501", "submitter": "Mohammad Riyaz Belgaum", "authors": "Safeeullah Soomro, Mohammad Riyaz Belgaum, Zainab Alansari, Mahdi H\n  Miraz", "title": "A Framework for Debugging Java Programs in a Bytecode", "comments": "6 pages, 2018 International Conference on Computing, Electronics &\n  Communications Engineering (iCCECE)", "journal-ref": null, "doi": "10.1109/iCCECOME.2018.8658589", "report-no": "18494083", "categories": "cs.SE cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the domain of Software Engineering, program analysis and understanding has\nbeen considered to be a very challenging task since decade, as it demands\ndedicated time and efforts. The analysis of source code may occasionally be\ncomparatively easier due to its static nature, however, the back end code\n(Bytecode), especially in terms of Java programming, is complicated to be\nanalysed. In this paper, we present a methodological approach towards\nunderstanding the Bytecode of Java programs. We put forward a framework for the\ndebugging process of Java Bytecode. Furthermore, we discuss the debugging\nprocess of Bytecode understanding from simple to multiple statements with\nregards to data flow analysis. Finally, we present a comparative analysis of\nBytecode along with the simulation of the proposed framework for the debugging\nprocess\n", "versions": [{"version": "v1", "created": "Mon, 29 Apr 2019 08:51:01 GMT"}], "update_date": "2019-05-01", "authors_parsed": [["Soomro", "Safeeullah", ""], ["Belgaum", "Mohammad Riyaz", ""], ["Alansari", "Zainab", ""], ["Miraz", "Mahdi H", ""]]}, {"id": "1904.13215", "submitter": "Corina P\\u{a}s\\u{a}reanu", "authors": "Divya Gopinath, Hayes Converse, Corina S. Pasareanu and Ankur Taly", "title": "Property Inference for Deep Neural Networks", "comments": "Errata: This version updates the ASE'19 conference version by\n  correcting the definition of the three properties that were checked for\n  ACASXU", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.AI cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present techniques for automatically inferring formal properties of\nfeed-forward neural networks. We observe that a significant part (if not all)\nof the logic of feed forward networks is captured in the activation status\n('on' or 'off') of its neurons. We propose to extract patterns based on neuron\ndecisions as preconditions that imply certain desirable output property e.g.,\nthe prediction being a certain class. We present techniques to extract input\nproperties, encoding convex predicates on the input space that imply given\noutput properties and layer properties, representing network properties\ncaptured in the hidden layers that imply the desired output behavior. We apply\nour techniques on networks for the MNIST and ACASXU applications. Our\nexperiments highlight the use of the inferred properties in a variety of tasks,\nsuch as explaining predictions, providing robustness guarantees, simplifying\nproofs, and network distillation.\n", "versions": [{"version": "v1", "created": "Mon, 29 Apr 2019 16:37:21 GMT"}, {"version": "v2", "created": "Fri, 13 Sep 2019 21:25:04 GMT"}, {"version": "v3", "created": "Thu, 10 Sep 2020 22:32:54 GMT"}], "update_date": "2020-09-14", "authors_parsed": [["Gopinath", "Divya", ""], ["Converse", "Hayes", ""], ["Pasareanu", "Corina S.", ""], ["Taly", "Ankur", ""]]}]