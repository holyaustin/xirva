[{"id": "1911.00474", "submitter": "Thomas Hujsa", "authors": "Raymond Devillers, Evgeny Erofeev, Thomas Hujsa", "title": "Synthesis of Weighted Marked Graphs from Constrained Labelled Transition\n  Systems: A Geometric Approach", "comments": "22 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent studies investigated the problems of analysing Petri nets and\nsynthesising them from labelled transition systems (LTS) with two labels\n(transitions) only. In this paper, we extend these works by providing new\nconditions for the synthesis of Weighted Marked Graphs (WMGs), a well-known and\nuseful class of weighted Petri nets in which each place has at most one input\nand one output. Some of these new conditions do not restrict the number of\nlabels; the other ones consider up to 3 labels. Additional constraints are\ninvestigated: when the LTS is either finite or infinite, and either cyclic or\nacyclic. We show that one of these conditions, developed for 3 labels, does not\nextend to 4 nor to 5 labels. Also, we tackle geometrically the WMG-solvability\nof finite, acyclic LTS with any number of labels.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 12:01:33 GMT"}], "update_date": "2019-11-04", "authors_parsed": [["Devillers", "Raymond", ""], ["Erofeev", "Evgeny", ""], ["Hujsa", "Thomas", ""]]}, {"id": "1911.00608", "submitter": "Hussein Sibai", "authors": "Hussein Sibai and Navid Mokhlesi and Chuchu Fan and Sayan Mitra", "title": "Multi-Agent Safety Verification using Symmetry Transformations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.SC cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that symmetry transformations and caching can enable scalable, and\npossibly unbounded, verification of multi-agent systems. Symmetry\ntransformations map solutions and to other solutions. We show that this\nproperty can be used to transform cached reachsets to compute new reachsets,\nfor hybrid and multi-agent models. We develop a notion of virtual system which\ndefine symmetry transformations for a broad class of agent models that visit\nwaypoint sequences. Using this notion of virtual system, we present a prototype\ntool CacheReach that builds a cache of reachtubes for this system, in a way\nthat is agnostic of the representation of the reachsets and the reachability\nanalysis subroutine used. Our experimental evaluation of CacheReach shows up to\n66% savings in safety verification computation time on multi-agent systems with\n3-dimensional linear and 4-dimensional nonlinear fixed-wing aircraft models\nfollowing sequences of waypoints. These savings and our theoretical results\nillustrate the potential benefits of using symmetry-based caching in the safety\nverification of multi-agent systems.\n", "versions": [{"version": "v1", "created": "Fri, 1 Nov 2019 22:51:34 GMT"}], "update_date": "2019-11-05", "authors_parsed": [["Sibai", "Hussein", ""], ["Mokhlesi", "Navid", ""], ["Fan", "Chuchu", ""], ["Mitra", "Sayan", ""]]}, {"id": "1911.00874", "submitter": "Henning Urbat", "authors": "Henning Urbat and Lutz Schr\\\"oder", "title": "Automata Learning: An Algebraic Approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We propose a generic categorical framework for learning unknown formal\nlanguages of various types (e.g. finite or infinite words, weighted and nominal\nlanguages). Our approach is parametric in a monad T that represents the given\ntype of languages and their recognizing algebraic structures. Using the concept\nof anautomata presentation of T-algebras, we demonstrate that the task of\nlearning a T-recognizable language can be reduced to learning an abstract form\nof algebraic automaton whose transitions are modeled by a functor. For the\nimportant case of adjoint automata, we devise a learning algorithm generalizing\nAngluin's L*. The algorithm is phrased in terms of categorically described\nextension steps; we provide for a termination and complexity analysis based on\na dedicated notion of finiteness. Our framework applies to structures like\nomega-regular languages that were not within the scope of existing categorical\naccounts of automata learning. In addition, it yields new learning algorithms\nfor several types of languages for which no such algorithms were previously\nknown at all, including sorted languages, nominal languages with name binding,\nand cost functions.\n", "versions": [{"version": "v1", "created": "Sun, 3 Nov 2019 11:42:50 GMT"}, {"version": "v2", "created": "Tue, 5 May 2020 15:44:53 GMT"}, {"version": "v3", "created": "Fri, 28 Aug 2020 13:35:41 GMT"}], "update_date": "2020-08-31", "authors_parsed": [["Urbat", "Henning", ""], ["Schr\u00f6der", "Lutz", ""]]}, {"id": "1911.01195", "submitter": "Pierre Ohlmann", "authors": "Thomas Colcombet, Nathana\\\"el Fijalkow, Pierre Ohlmann", "title": "Controlling a random population", "comments": "20 pages, 6 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DC cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bertrand et al. introduced a model of parameterised systems, where each agent\nis represented by a finite state system, and studied the following control\nproblem: for any number of agents, does there exist a controller able to bring\nall agents to a target state? They showed that the problem is decidable and\nEXPTIME-complete in the adversarial setting, and posed as an open problem the\nstochastic setting, where the agent is represented by a Markov decision\nprocess. In this paper, we show that the stochastic control problem is\ndecidable. Our solution makes significant uses of well quasi orders, of the\nmax-flow min-cut theorem, and of the theory of regular cost functions. We\nintroduce an intermediate problem of independent interest called the sequential\nflow problem, and study the complexity of solving it.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 13:32:18 GMT"}, {"version": "v2", "created": "Tue, 29 Dec 2020 14:53:34 GMT"}, {"version": "v3", "created": "Mon, 26 Jul 2021 13:59:55 GMT"}], "update_date": "2021-07-27", "authors_parsed": [["Colcombet", "Thomas", ""], ["Fijalkow", "Nathana\u00ebl", ""], ["Ohlmann", "Pierre", ""]]}, {"id": "1911.01537", "submitter": "Negin Musavi", "authors": "Negin Musavi, Dawei Sun, Sayan Mitra, Geir Dullerud, Sanjay Shakkottai", "title": "Verification and Parameter Synthesis for Stochastic Systems using\n  Optimistic Optimization", "comments": "24 pages, 7 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an algorithm for formal verification and parameter synthesis of\ncontinuous state-space Markov chains. This class of problems captures the\ndesign and analysis of a wide variety of autonomous and cyber-physical systems\ndefined by nonlinear and black-box modules. In order to solve these problems,\none has to maximize certain probabilistic objective functions overall choices\nof initial states and parameters. In this paper, we identify the assumptions\nthat make it possible to view this problem as a multi-armed bandit problem.\nBased on this fresh perspective, we propose an algorithm (HOO-MB) for solving\nthe problem that carefully instantiates an existing bandit algorithm --\nHierarchical Optimistic Optimization -- with appropriate parameters. As a\nconsequence, we obtain theoretical regret bounds on sample efficiency of our\nsolution that depends on key problem parameters like smoothness,\nnear-optimality dimension, and batch size. The batch size parameter enables us\nto strike a balance between the sample efficiency and the memory usage of the\nalgorithm. Our experiments, using the tool HooVer, suggest that the approach\nscales to realistic-sized problems and is often more sample-efficient compared\nto PlasmaLab -- a leading tool for verification of stochastic systems.\nSpecifically, HooVer has distinct advantages in analyzing models in which the\nobjective function has sharp slopes. In addition, HooVer shows promising\nbehavior in parameter synthesis for a linear quadratic regulator (LQR) example.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 23:46:52 GMT"}, {"version": "v2", "created": "Thu, 3 Dec 2020 18:29:50 GMT"}], "update_date": "2020-12-04", "authors_parsed": [["Musavi", "Negin", ""], ["Sun", "Dawei", ""], ["Mitra", "Sayan", ""], ["Dullerud", "Geir", ""], ["Shakkottai", "Sanjay", ""]]}, {"id": "1911.01759", "submitter": "Anton Pirogov", "authors": "Christof L\\\"oding, Anton Pirogov", "title": "New Optimizations and Heuristics for Determinization of B\\\"uchi Automata", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-31784-3_18", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we present multiple new optimizations and heuristics for the\ndeterminization of B\\\"uchi automata that exploit a number of semantic and\nstructural properties, most of which may be applied together with any\ndeterminization procedure. We built a prototype implementation where all the\npresented heuristics can be freely combined and evaluated them, comparing our\nimplementation with the state-of-the-art tool spot on multiple data sets with\ndifferent characteristics. Our results show that the proposed optimizations and\nheuristics can in some cases significantly decrease the size of the resulting\ndeterministic automaton.\n", "versions": [{"version": "v1", "created": "Tue, 5 Nov 2019 13:15:30 GMT"}], "update_date": "2020-04-30", "authors_parsed": [["L\u00f6ding", "Christof", ""], ["Pirogov", "Anton", ""]]}, {"id": "1911.01851", "submitter": "Clelia De Felice", "authors": "Paola Bonizzoni, Clelia De Felice, Rocco Zaccagnino, Rosalba Zizza", "title": "Lyndon words versus inverse Lyndon words: queries on suffixes and\n  bordered words", "comments": "arXiv admin note: text overlap with arXiv:1705.10277", "journal-ref": "Theoretical Computer Science, 2020", "doi": "10.1016/j.tcs.2020.10.034", "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Lyndon words have been largely investigated and showned to be a useful tool\nto prove interesting combinatorial properties of words. In this paper we state\nnew properties of both Lyndon and inverse Lyndon factorizations of a word $w$,\nwith the aim of exploring their use in some classical queries on $w$.\n  The main property we prove is related to a classical query on words. We prove\nthat there are relations between the length of the longest common extension (or\nlongest common prefix) $lcp(x,y)$ of two different suffixes $x,y$ of a word $w$\nand the maximum length $\\mathcal{M}$ of two consecutive factors of the inverse\nLyndon factorization of $w$. More precisely, $\\mathcal{M}$ is an upper bound on\nthe length of $lcp(x,y)$. This result is in some sense stronger than the\ncompatibility property, proved by Mantaci, Restivo, Rosone and Sciortino for\nthe Lyndon factorization and here for the inverse Lyndon factorization.\nRoughly, the compatibility property allows us to extend the mutual order\nbetween local suffixes of (inverse) Lyndon factors to the suffixes of the whole\nword.\n  A main tool used in the proof of the above results is a property that we\nstate for factors $m_i$ with nonempty borders in an inverse Lyndon\nfactorization: a nonempty border of $m_i$ cannot be a prefix of the next factor\n$m_{i+1}$. The last property we prove shows that if two words share a common\noverlap, then their Lyndon factorizations can be used to capture the common\noverlap of the two words.\n  The above results open to the study of new applications of Lyndon words and\ninverse Lyndon words in the field of string comparison.\n", "versions": [{"version": "v1", "created": "Sat, 2 Nov 2019 14:56:53 GMT"}], "update_date": "2020-11-24", "authors_parsed": [["Bonizzoni", "Paola", ""], ["De Felice", "Clelia", ""], ["Zaccagnino", "Rocco", ""], ["Zizza", "Rosalba", ""]]}, {"id": "1911.02564", "submitter": "Bertrand Meyer", "authors": "Jean-Michel Bruel, Sophie Ebersold, Florian Galinier, Alexandr\n  Naumchev, Manuel Mazzara, Bertrand Meyer", "title": "The role of formalism in system requirements (full version)", "comments": "Fourth version (15 April 2020). This is the full version, including\n  some sections and 2 appendices not appearing in the short version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A major determinant of the quality of software systems is the quality of\ntheir requirements, which should be both understandable and precise. Most\nrequirements are written in natural language, good for understandability but\nlacking in precision. To make requirements precise, researchers have for years\nadvocated the use of mathematics-based notations and methods, known as\n\"formal\". Many exist, differing in their style, scope and applicability. The\npresent survey discusses some of the main formal approaches and compares them\nto informal methods. The analysis uses a set of 9 complementary criteria, such\nas level of abstraction, tool availability, traceability support. It classifies\nthe approaches into five categories: general-purpose, natural-language,\ngraph/automata, other mathematical notations, seamless\n(programming-language-based). It presents approaches in all of these\ncategories, altogether 22 different ones, including for example SysML, Relax,\nEiffel, Event-B, Alloy. The review discusses a number of open questions,\nincluding seamlessness, the role of tools and education, and how to make\nindustrial applications benefit more from the contributions of formal\napproaches.\n  (This is the full version of the survey, including some sections and two\nappendices which, because of length restrictions, do not appear in the\nsubmitted version.)\n", "versions": [{"version": "v1", "created": "Wed, 6 Nov 2019 14:40:16 GMT"}, {"version": "v2", "created": "Sat, 4 Apr 2020 14:03:04 GMT"}, {"version": "v3", "created": "Tue, 7 Apr 2020 07:35:39 GMT"}, {"version": "v4", "created": "Sun, 12 Apr 2020 09:26:44 GMT"}, {"version": "v5", "created": "Wed, 15 Apr 2020 17:02:44 GMT"}, {"version": "v6", "created": "Thu, 16 Apr 2020 12:42:18 GMT"}], "update_date": "2020-04-17", "authors_parsed": [["Bruel", "Jean-Michel", ""], ["Ebersold", "Sophie", ""], ["Galinier", "Florian", ""], ["Naumchev", "Alexandr", ""], ["Mazzara", "Manuel", ""], ["Meyer", "Bertrand", ""]]}, {"id": "1911.03122", "submitter": "Swen Jacobs", "authors": "Swen Jacobs, Mouhammad Sakr, Martin Zimmermann", "title": "Promptness and Bounded Fairness in Concurrent and Parameterized Systems", "comments": "Accepted for publication in VMCAI 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the satisfaction of specifications in Prompt Linear Temporal\nLogic (Prompt-LTL) by concurrent systems. Prompt-LTL is an extension of LTL\nthat allows to specify parametric bounds on the satisfaction of eventualities,\nthus adding a quantitative aspect to the specification language. We establish a\nconnection between bounded fairness, bounded stutter equivalence, and the\nsatisfaction of Prompt-LTL\\X formulas. Based on this connection, we prove the\nfirst cutoff results for different classes of systems with a parametric number\nof components and quantitative specifications, thereby identifying previously\nunknown decidable fragments of the parameterized model checking problem.\n", "versions": [{"version": "v1", "created": "Fri, 8 Nov 2019 08:38:57 GMT"}, {"version": "v2", "created": "Fri, 15 Nov 2019 13:38:57 GMT"}], "update_date": "2019-11-18", "authors_parsed": [["Jacobs", "Swen", ""], ["Sakr", "Mouhammad", ""], ["Zimmermann", "Martin", ""]]}, {"id": "1911.03493", "submitter": "Michael Hahn", "authors": "Michael Hahn, Andreas Krebs, Howard Straubing", "title": "Wreath Products of Distributive Forest Algebras", "comments": "Appeared in: LICS '18 Proceedings of the 33rd Annual ACM/IEEE\n  Symposium on Logic in Computer Science, pages 512-520", "journal-ref": null, "doi": "10.1145/3209108.3209158", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is an open problem whether definability in Propositional Dynamic Logic\n(PDL) on forests is decidable. Based on an algebraic characterization by\nBoja\\'nczyk, et. al.,(2012) in terms of forest algebras, Straubing (2013)\ndescribed an approach to PDL based on a k-fold iterated distributive law. A\nproof that all languages satisfying such a k-fold iterated distributive law are\nin PDL would settle decidability of PDL. We solve this problem in the case k=2:\nAll languages recognized by forest algebras satisfying a 2-fold iterated\ndistributive law are in PDL. Furthermore, we show that this class is decidable.\nThis provides a novel nontrivial decidable subclass of PDL, and demonstrates\nthe viability of the proposed approach to deciding PDL in general.\n", "versions": [{"version": "v1", "created": "Fri, 8 Nov 2019 19:02:21 GMT"}], "update_date": "2019-11-12", "authors_parsed": [["Hahn", "Michael", ""], ["Krebs", "Andreas", ""], ["Straubing", "Howard", ""]]}, {"id": "1911.03609", "submitter": "Kamalika Bhattacharjee", "authors": "Kamalika Bhattacharjee", "title": "Cellular Automata: Reversibility, Semi-reversibility and Randomness", "comments": "This is my Ph.D thesis defended under the guidance of Dr. Sukanta\n  Das, Associate Professor, Department of Information Technology, Indian\n  Institute of Engineering Science and Technology, Shibpur, Howrah, West\n  Bengal, India - 711103", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this dissertation, we study two of the global properties of 1-dimensional\ncellular automata (CAs) under periodic boundary condition, namely,\nreversibility and randomness. To address reversibility of finite CAs, we\ndevelop a mathematical tool, named reachability tree, which can efficiently\ncharacterize those CAs. A decision algorithm is proposed using minimized\nreachability tree which takes a CA rule and size n as input and verifies\nwhether the CA is reversible for that n. To decide reversibility of a finite\nCA, we need to know both the rule and the CA size. However, for infinite CAs,\nreversibility is decided based on the local rule only. Therefore, apparently,\nthese two cases seem to be divergent. This dissertation targets to construct a\nbridge between these two cases. To do so, reversibility of CAs is redefined and\nthe notion of semi-reversible CAs is introduced. Hence, we propose a new\nclassification of finite CAs -(1) reversible CAs, (2) semi-reversible CAs and\n(3) strictly irreversible CAs. Finally, relation between reversibility of\nfinite and infinite CAs is established. This dissertation also explores CAs as\nsource of randomness and build pseudo-random number generators (PRNGs) based on\nCAs. We identify a list of properties for a CA to be a good source of\nrandomness. Two heuristic algorithms are proposed to synthesize candidate\n(decimal) CAs which have great potentiality as PRNGs. Two schemes tare\ndeveloped o use these CAs as window-based PRNGs - (1) as decimal number\ngenerators and as (2) binary number generators. We empirically observe that in\ncomparison to the best PRNG SFMT19937-64, average performance of our proposed\nPRNGs are slightly better. Hence, our decimal CAs based PRNGs are one of the\nbest PRNGs today.\n", "versions": [{"version": "v1", "created": "Sat, 9 Nov 2019 04:51:29 GMT"}], "update_date": "2019-11-12", "authors_parsed": [["Bhattacharjee", "Kamalika", ""]]}, {"id": "1911.03807", "submitter": "Suguman Bansal", "authors": "Suguman Bansal, Kedar S. Namjoshi, Yaniv Sa'ar", "title": "Synthesis of coordination programs from linear temporal logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper presents a method for synthesizing a reactive program which\ncoordinates the actions of a group of other reactive programs, so that the\ncombined system satisfies a temporal specification of its desired long-term\nbehavior. Traditionally, reactive synthesis has been applied to the\nconstruction of a stateful hardware circuit. This work is motivated by\napplications to other domains, such as the IoT (the Internet of Things) and\nrobotics, where it is necessary to coordinate the actions of multiple sensors,\ndevices, and robots. The mathematical model represents such entities as\nindividual processes in Hoare's CSP model. Given a network of interacting\nentities, called an \\emph{environment}, and a temporal specification of\nlong-term behavior, the synthesis method constructs a \\emph{coordinator}\nprocess (if one exists) that guides the actions of the environment entities so\nthat the combined system is deadlock-free and satisfies the given\nspecification. The main technical challenge is that a coordinator may have only\n\\emph{partial knowledge} of the environment state, due to non-determinism\nwithin the environment, and environment actions that are hidden from the\ncoordinator. This is the first method to handle both sources of partial\nknowledge, and to do so for arbitrary linear temporal logic specifications. It\nis shown that the coordination synthesis problem is \\PSPACE-hard in the size of\nthe environment. A prototype implementation is able to synthesize compact\nsolutions for a number of coordination problems.\n", "versions": [{"version": "v1", "created": "Sun, 10 Nov 2019 00:07:54 GMT"}], "update_date": "2019-11-12", "authors_parsed": [["Bansal", "Suguman", ""], ["Namjoshi", "Kedar S.", ""], ["Sa'ar", "Yaniv", ""]]}, {"id": "1911.04404", "submitter": "Gerco van Heerdt", "authors": "Gerco van Heerdt, Clemens Kupke, Jurriaan Rot, Alexandra Silva", "title": "Learning Weighted Automata over Principal Ideal Domains", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper, we study active learning algorithms for weighted automata over\na semiring. We show that a variant of Angluin's seminal L* algorithm works when\nthe semiring is a principal ideal domain, but not for general semirings such as\nthe natural numbers.\n", "versions": [{"version": "v1", "created": "Mon, 11 Nov 2019 17:24:36 GMT"}], "update_date": "2019-11-12", "authors_parsed": [["van Heerdt", "Gerco", ""], ["Kupke", "Clemens", ""], ["Rot", "Jurriaan", ""], ["Silva", "Alexandra", ""]]}, {"id": "1911.05430", "submitter": "Emanuele D'Osualdo", "authors": "Emanuele D'Osualdo and Felix Stutz", "title": "Decidable Inductive Invariants for Verification of Cryptographic\n  Protocols with Unbounded Sessions", "comments": "16 pages + 23 pages appendix, 5 figures To appear in CONCUR 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a theory of decidable inductive invariants for an infinite-state\nvariant of the Applied pi-calculus, with applications to automatic verification\nof stateful cryptographic protocols with unbounded sessions/nonces. Since the\nproblem is undecidable in general, we introduce depth-bounded protocols, a\nstrict generalisation of a class from the literature, for which our decidable\nanalysis is sound and complete. Our core contribution is a procedure to check\nthat an invariant is inductive, which implies that every reachable\nconfiguration satisfies it. Our invariants can capture security properties like\nsecrecy, can be inferred automatically, and represent an independently\ncheckable certificate of correctness.\n  We provide a prototype implementation and we report on its performance on\nsome textbook examples.\n", "versions": [{"version": "v1", "created": "Wed, 13 Nov 2019 12:45:28 GMT"}, {"version": "v2", "created": "Sun, 19 Jul 2020 09:15:53 GMT"}], "update_date": "2020-07-21", "authors_parsed": [["D'Osualdo", "Emanuele", ""], ["Stutz", "Felix", ""]]}, {"id": "1911.05672", "submitter": "Viktor Palmkvist", "authors": "Viktor Palmkvist, Elias Castegren, Philipp Haller, David Broman", "title": "Resolvable Ambiguity", "comments": "25 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A common standpoint when designing the syntax of programming languages is\nthat the grammar definition has to be unambiguous. However, requiring up front\nunambiguous grammars can force language designers to make more or less\narbitrary choices to disambiguate the language. In this paper, we depart from\nthe traditional view of unambiguous grammar design, and enable the detection of\nambiguities to be delayed until parse time, allowing the user of the language\nto perform the disambiguation. A natural decision problem follows: given a\nlanguage definition, can a user always disambiguate an ambiguous program? We\nintroduce and formalize this fundamental problem - called the resolvable\nambiguity problem - and divide it into separate static and dynamic\nresolvability problems. We provide solutions to the static problem for a\nrestricted language class and sketch proofs of soundness and completeness. We\nalso provide a sound and complete solution to the dynamic problem for a much\nless restricted class of languages. The approach is evaluated through two\nseparate case studies, covering both a large existing programming language, and\nthe composability of domain-specific languages.\n", "versions": [{"version": "v1", "created": "Wed, 13 Nov 2019 17:51:58 GMT"}, {"version": "v2", "created": "Tue, 4 Feb 2020 13:29:59 GMT"}], "update_date": "2020-02-05", "authors_parsed": [["Palmkvist", "Viktor", ""], ["Castegren", "Elias", ""], ["Haller", "Philipp", ""], ["Broman", "David", ""]]}, {"id": "1911.05801", "submitter": "{\\L}ukasz Culer", "authors": "Olgierd Unold, Agnieszka Kaczmarek, {\\L}ukasz Culer", "title": "Iterative method of generating artificial context-free grammars", "comments": "28 pages, 10 figures, generator available at\n  http://lukasz.culer.staff.iiar.pwr.edu.pl/gencreator.php", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Grammatical inference is a machine learning area, whose fundamentals are\nbuilt around learning sets. At present, real-life data and examples from\nmanually crafted grammars are used to test their learning performance. This\npaper aims to present a method of generating artificial context-free grammars\nwith their optimal learning sets, which could be successfully applied as a\nbenchmarking tool for empirical grammar inference methods.\n", "versions": [{"version": "v1", "created": "Wed, 13 Nov 2019 20:32:59 GMT"}], "update_date": "2019-11-15", "authors_parsed": [["Unold", "Olgierd", ""], ["Kaczmarek", "Agnieszka", ""], ["Culer", "\u0141ukasz", ""]]}, {"id": "1911.05866", "submitter": "Lucas Martinelli Tabajara", "authors": "Kedar S. Namjoshi, Lucas M. Tabajara", "title": "Witnessing Secure Compilation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compiler optimizations are designed to improve run-time performance while\npreserving input-output behavior. Correctness in this sense does not\nnecessarily preserve security: it is known that standard optimizations may\nbreak or weaken security properties that hold of the source program. This work\ndevelops a translation validation method for secure compilation. Security\n(hyper-)properties are expressed using automata operating over a bundle of\nprogram traces. A flexible, automaton-based refinement scheme, generalizing\nexisting refinement methods, guarantees that the associated security property\nis preserved by a program transformation. In practice, the refinement relations\n(\"security witnesses\") can be generated during compilation and validated\nindependently with a refinement checker. This process is illustrated for common\noptimizations. Crucially, it is not necessary to verify the compiler\nimplementation itself, which is infeasible in practice for production\ncompilers.\n", "versions": [{"version": "v1", "created": "Thu, 14 Nov 2019 00:10:52 GMT"}], "update_date": "2019-11-15", "authors_parsed": [["Namjoshi", "Kedar S.", ""], ["Tabajara", "Lucas M.", ""]]}, {"id": "1911.06355", "submitter": "Andreas Fellner", "authors": "Andreas Fellner, Thorsten Tarrach, Georg Weissenbacher", "title": "Language Inclusion for Finite Prime Event Structures", "comments": "20 pages main text, 35 pages total", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the problem of language inclusion between finite, labeled prime\nevent structures. Prime event structures are a formalism to compactly represent\nconcurrent behavior of discrete systems. A labeled prime event structure\ninduces a language of sequences of labels produced by the represented system.\nWe study the problem of deciding inclusion and membership for languages encoded\nby finite prime event structures and provide complexity results for both\nproblems. We provide a family of examples where prime event structures are\nexponentially more succinct than formalisms that do not take concurrency into\naccount. We provide a decision algorithm for language inclusion that exploits\nthis succinctness. Furthermore, we provide an implementation of the algorithm\nand an evaluation on a series of benchmarks. Finally, we demonstrate how our\nresults can be applied to mutation-based test case generation.\n", "versions": [{"version": "v1", "created": "Thu, 14 Nov 2019 19:50:18 GMT"}], "update_date": "2019-11-18", "authors_parsed": [["Fellner", "Andreas", ""], ["Tarrach", "Thorsten", ""], ["Weissenbacher", "Georg", ""]]}, {"id": "1911.06585", "submitter": "Richard M\\\"orbitz", "authors": "Richard M\\\"orbitz and Heiko Vogler", "title": "Weighted Parsing for Grammar-Based Language Models over Multioperator\n  Monoids", "comments": "59 pages (89 with appendix)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a general framework for weighted parsing which is built on top of\ngrammar-based language models and employs multioperator monoids as weight\nalgebras. It generalizes previous work in that area (semiring parsing, weighted\ndeductive parsing) and also covers applications outside the classical scope of\nparsing, e.g., algebraic dynamic programming. We show an algorithm for weighted\nparsing and, for a large class of weighted grammar-based language models, we\nprove formally that it terminates and is correct.\n", "versions": [{"version": "v1", "created": "Fri, 15 Nov 2019 12:19:10 GMT"}], "update_date": "2019-11-18", "authors_parsed": [["M\u00f6rbitz", "Richard", ""], ["Vogler", "Heiko", ""]]}, {"id": "1911.08145", "submitter": "Suguman Bansal", "authors": "Suguman Bansal, Yong Li, Lucas M. Tabajara, Moshe Y. Vardi", "title": "Hybrid Compositional Reasoning for Reactive Synthesis from\n  Finite-Horizon Specifications", "comments": "Accepted by AAAI 2020. Tool Lisa for (a). LTLf to DFA conversion, and\n  (b). LTLf synthesis can be found here: https://github.com/vardigroup/lisa", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  LTLf synthesis is the automated construction of a reactive system from a\nhigh-level description, expressed in LTLf, of its finite-horizon behavior. So\nfar, the conversion of LTLf formulas to deterministic finite-state automata\n(DFAs) has been identified as the primary bottleneck to the scalabity of\nsynthesis. Recent investigations have also shown that the size of the DFA state\nspace plays a critical role in synthesis as well.\n  Therefore, effective resolution of the bottleneck for synthesis requires the\nconversion to be time and memory performant, and prevent state-space explosion.\nCurrent conversion approaches, however, which are based either on\nexplicit-state representation or symbolic-state representation, fail to address\nthese necessities adequately at scale: Explicit-state approaches generate\nminimal DFA but are slow due to expensive DFA minimization. Symbolic-state\nrepresentations can be succinct, but due to the lack of DFA minimization they\ngenerate such large state spaces that even their symbolic representations\ncannot compensate for the blow-up.\n  This work proposes a hybrid representation approach for the conversion. Our\napproach utilizes both explicit and symbolic representations of the\nstate-space, and effectively leverages their complementary strengths. In doing\nso, we offer an LTLf to DFA conversion technique that addresses all three\nnecessities, hence resolving the bottleneck. A comprehensive empirical\nevaluation on conversion and synthesis benchmarks supports the merits of our\nhybrid approach.\n", "versions": [{"version": "v1", "created": "Tue, 19 Nov 2019 08:05:24 GMT"}, {"version": "v2", "created": "Mon, 9 Dec 2019 04:48:40 GMT"}, {"version": "v3", "created": "Mon, 17 Feb 2020 20:16:37 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Bansal", "Suguman", ""], ["Li", "Yong", ""], ["Tabajara", "Lucas M.", ""], ["Vardi", "Moshe Y.", ""]]}, {"id": "1911.08405", "submitter": "EPTCS", "authors": "Anastasia Mavridou (Vanderbilt University), Joseph Sifakis (Verimag),\n  Janos Sztipanovits (Vanderbilt University)", "title": "DesignBIP: A Design Studio for Modeling and Generating Systems with BIP", "comments": "In Proceedings MeTRiD 2018, arXiv:1806.09330. A technical report with\n  full details is available at arXiv:1805.09919", "journal-ref": "EPTCS 272, 2018, pp. 93-106", "doi": "10.4204/EPTCS.272.8", "report-no": null, "categories": "cs.SE cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Behavior-Interaction-Priority (BIP) framework, rooted in rigorous\nsemantics, allows the construction of systems that are correct-by-design. BIP\nhas been effectively used for the construction and analysis of large systems\nsuch as robot controllers and satellite on-board software. Nevertheless, the\nspecification of BIP models is done in a purely textual manner without any code\neditor support. To facilitate the specification of BIP models, we present\nDesignBIP, a web-based, collaborative, version-controlled design studio. To\npromote model scaling and reusability of BIP models, we use a graphical\nlanguage for modeling parameterized BIP models with rigorous semantics. We\npresent the various services provided by the design studio, including model\neditors, code editors, consistency checking mechanisms, code generators, and\nintegration with the JavaBIP tool-set.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2018 07:06:57 GMT"}], "update_date": "2019-11-20", "authors_parsed": [["Mavridou", "Anastasia", "", "Vanderbilt University"], ["Sifakis", "Joseph", "", "Verimag"], ["Sztipanovits", "Janos", "", "Vanderbilt University"]]}, {"id": "1911.09133", "submitter": "Harro Wimmel", "authors": "Harro Wimmel", "title": "Synthesis of Reduced Asymmetric Choice Petri Nets", "comments": "27 pages, 10 figures, V2 due to font problem with ulsy.sty (one font\n  symbol had been erroneously replaced with a greek Psi by LiveTeX)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A Petri net is choice-free if any place has at most one transition in its\npostset (consuming its tokens) and it is (extended) free-choice (EFC) if the\npostsets of any two places are either equal or disjoint. Asymmetric choice (AC)\nextends EFC such that two places may also have postsets where one is contained\nin the other. In reduced AC nets this containment is limited: If the postsets\nare neither disjoint nor equal, one is a singleton and the other has exactly\ntwo transitions. The aim of Petri net synthesis is to find an unlabelled Petri\nnet in some target class with a reachability graph isomorphic to a given finite\nlabelled transition system (lts). Choice-free nets have strong properties,\nallowing to often easily detect when synthesis will fail or at least to quicken\nthe synthesis. With EFC as the target class, only few properties can be checked\nahead and there seem to be no short cuts lowering the complexity of the\nsynthesis (compared to arbitrary Petri nets). For AC nets no synthesis\nprocedure is known at all. We show here how synthesis to a superclass of\nreduced AC nets (not containing the full AC net class) can be done.\n", "versions": [{"version": "v1", "created": "Wed, 20 Nov 2019 19:07:10 GMT"}, {"version": "v2", "created": "Fri, 22 Nov 2019 10:28:05 GMT"}], "update_date": "2019-11-25", "authors_parsed": [["Wimmel", "Harro", ""]]}, {"id": "1911.10478", "submitter": "Shiraj Arora", "authors": "Shiraj Arora and M. V. Panduranga Rao", "title": "The Bouquet Algorithm for Model Checking Unbounded Until", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of verifying the \"Unbounded Until\" fragment in temporal logic\nformulas has been studied extensively in the past, especially in the context of\nstatistical model checking. Statistical model checking, a computationally\ninexpensive sampling based alternative to the more expensive numerical model\nchecking technique, presents the following decision dilemma -- what length of\nthe sample is enough in general? In this paper, we discuss an algorithm for\nthis problem that combines ideas from graph theory, statistical model checking\nand numerical model checking. We analyze the algorithm and show through\nexperiments that this approach outperforms the standard statistical model\nchecking algorithm for verifying unbounded until for low density Discrete Time\nMarkov Chains.\n", "versions": [{"version": "v1", "created": "Sun, 24 Nov 2019 09:07:15 GMT"}], "update_date": "2019-11-26", "authors_parsed": [["Arora", "Shiraj", ""], ["Rao", "M. V. Panduranga", ""]]}, {"id": "1911.11529", "submitter": "Magnus Steinby", "authors": "Eija Jurvanen and Magnus Steinby", "title": "Fuzzy Deterministic Top-down Tree Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we introduce and study fuzzy deterministic top-down (DT) tree\nautomata over a lattice L. The L-fuzzy tree languages recognized by these\nautomata are said to be DT-recognizable, and they form a proper subfamily\n$DRec_L$ of the family of $Rec_L$ of all regular L-fuzzy tree languages. We\nprove a Pumping Lemma for $DRec_L$ from which several decidability results\nfollow. The closure properties of $DRec_L$ under various operations are\nestablished. We also characterize DT-recognizability in terms of L-fuzzy path\nlanguages, and prove that the path closure of any regular L-fuzzy tree language\nis DT-recognizable, and that it is decidable whether a regular L-fuzzy tree\nlanguage is DT-recognizable. In most of the paper, L is just any nontrivial\nbounded lattice, but sometimes it is assumed to be distributive or even a\nbounded chain.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 13:46:03 GMT"}], "update_date": "2019-11-27", "authors_parsed": [["Jurvanen", "Eija", ""], ["Steinby", "Magnus", ""]]}, {"id": "1911.11704", "submitter": "Jeffrey Shallit", "authors": "Lukas Fleischer and Jeffrey Shallit", "title": "Words Avoiding Reversed Factors, Revisited", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In 2005, Rampersad and the second author proved a number of theorems about\ninfinite words x with the property that if w is any sufficiently long finite\nfactor of x, then its reversal w^R is not a factor of x. In this note we\nrevisit these results, reproving them in more generality, using machine\ncomputations only. Two different techniques are presented.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 17:14:56 GMT"}, {"version": "v2", "created": "Mon, 9 Dec 2019 15:41:13 GMT"}], "update_date": "2019-12-10", "authors_parsed": [["Fleischer", "Lukas", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1911.11870", "submitter": "Yu Wang", "authors": "Yu Wang, Siddhartha Nalluri, and Miroslav Pajic", "title": "Hyperproperties for Robotics: Planning via HyperLTL", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.RO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There is a growing interest on formal methods-based robotic planning for\ntemporal logic objectives. In this work, we extend the scope of existing\nsynthesis methods to hyper-temporal logics. We are motivated by the fact that\nimportant planning objectives, such as optimality, robustness, and privacy,\n(maybe implicitly) involve the interrelation between multiple paths. Such\nobjectives are thus hyperproperties, and cannot be expressed with usual\ntemporal logics like the linear temporal logic (LTL). We show that such\nhyperproperties can be expressed by HyperLTL, an extension of LTL to multiple\npaths. To handle the complexity of planning with HyperLTL specifications, we\nintroduce a symbolic approach for synthesizing planning strategies on discrete\ntransition systems. Our planning method is evaluated on several case studies.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 22:35:05 GMT"}, {"version": "v2", "created": "Thu, 27 Feb 2020 19:34:55 GMT"}, {"version": "v3", "created": "Tue, 28 Apr 2020 23:13:10 GMT"}], "update_date": "2020-04-30", "authors_parsed": [["Wang", "Yu", ""], ["Nalluri", "Siddhartha", ""], ["Pajic", "Miroslav", ""]]}, {"id": "1911.12464", "submitter": "Jeffrey Shallit", "authors": "Lukas Fleischer and Jeffrey Shallit", "title": "Words With Few Palindromes, Revisited", "comments": "Minor typo corrections", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In 2013, Fici and Zamboni proved a number of theorems about finite and\ninfinite words having only a small number of factors that are palindromes. In\nthis paper we rederive some of their results, and obtain some new ones, by a\ndifferent method based on finite automata.\n", "versions": [{"version": "v1", "created": "Wed, 27 Nov 2019 23:40:26 GMT"}, {"version": "v2", "created": "Mon, 2 Dec 2019 17:30:20 GMT"}, {"version": "v3", "created": "Sat, 4 Jan 2020 12:44:38 GMT"}], "update_date": "2020-01-07", "authors_parsed": [["Fleischer", "Lukas", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1911.12737", "submitter": "Romain Edelmann", "authors": "Romain Edelmann, Jad Hamza, Viktor Kun\\v{c}ak", "title": "LL(1) Parsing with Derivatives and Zippers", "comments": "Appeared at PLDI'20 under the title \"Zippy LL(1) Parsing with\n  Derivatives\"", "journal-ref": null, "doi": "10.1145/3385412.3385992", "report-no": null, "categories": "cs.FL cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present an efficient, functional, and formally verified\nparsing algorithm for LL(1) context-free expressions based on the concept of\nderivatives of formal languages. Parsing with derivatives is an elegant parsing\ntechnique, which, in the general case, suffers from cubic worst-case time\ncomplexity and slow performance in practice. We specialise the parsing with\nderivatives algorithm to LL(1) context-free expressions, where alternatives can\nbe chosen given a single token of lookahead. We formalise the notion of LL(1)\nexpressions and show how to efficiently check the LL(1) property. Next, we\npresent a novel linear-time parsing with derivatives algorithm for LL(1)\nexpressions operating on a zipper-inspired data structure. We prove the\nalgorithm correct in Coq and present an implementation as a parser combinators\nframework in Scala, with enumeration and pretty printing capabilities.\n", "versions": [{"version": "v1", "created": "Thu, 28 Nov 2019 14:57:03 GMT"}, {"version": "v2", "created": "Thu, 21 Jan 2021 12:54:49 GMT"}], "update_date": "2021-01-22", "authors_parsed": [["Edelmann", "Romain", ""], ["Hamza", "Jad", ""], ["Kun\u010dak", "Viktor", ""]]}, {"id": "1911.13054", "submitter": "Raphaela L\\\"obel", "authors": "Raphaela L\\\"obel, Michael Luttenberger, Helmut Seidl", "title": "On the Balancedness of Tree-to-word Transducers", "comments": "Major changes in Section 3 Balancedness of 2-TWs: instead of proving\n  equivalence of LTWs over the involutive monoid we use the result that\n  equivalence of LTWs over the free group is decidable in polynomial time\n  (arXiv:2001.03480). A short version will be published in the conference\n  proceedings of DLT 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A language over an alphabet $B = A \\cup \\overline{A}$ of opening ($A$) and\nclosing ($\\overline{A}$) brackets, is balanced if it is a subset of the Dyck\nlanguage $D_B$ over $B$, and it is well-formed if all words are prefixes of\nwords in $D_B$. We show that well-formedness of a context-free language is\ndecidable in polynomial time, and that the longest common reduced suffix can be\ncomputed in polynomial time. With this at a hand we decide for the class 2-TWs\nof non-linear tree transducers with output alphabet $B^*$ whether or not the\noutput language is balanced.\n", "versions": [{"version": "v1", "created": "Fri, 29 Nov 2019 11:05:32 GMT"}, {"version": "v2", "created": "Fri, 13 Mar 2020 09:58:26 GMT"}], "update_date": "2020-03-16", "authors_parsed": [["L\u00f6bel", "Raphaela", ""], ["Luttenberger", "Michael", ""], ["Seidl", "Helmut", ""]]}]