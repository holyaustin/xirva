[{"id": "2102.00096", "submitter": "Fabrizio Romano Genovese", "authors": "Fabrizio Genovese, Jelle Herold", "title": "A Categorical Semantics for Hierarchical Petri Nets", "comments": "14 Pages, 7 Figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.DC cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We show how a particular flavor of hierarchical nets, where the firing of a\ntransition in the parent net must correspond to an execution in some child net,\ncan be modelled utilizing a functorial semantics from a free category -\nrepresenting the parent net - to the category of sets and spans between them.\nThis semantics can be internalized via Grothendieck construction, resulting in\nthe category of executions of a Petri net representing the semantics of the\noverall hierarchical net. We conclude the paper by giving an\nengineering-oriented overview of how our model of hiearchic nets can be\nimplemented in a transaction-based smart contract environment.\n", "versions": [{"version": "v1", "created": "Fri, 29 Jan 2021 22:37:34 GMT"}], "update_date": "2021-02-02", "authors_parsed": [["Genovese", "Fabrizio", ""], ["Herold", "Jelle", ""]]}, {"id": "2102.00859", "submitter": "Vladimir Yankovskiy", "authors": "Vladimir Yankovskiy", "title": "Groups with context-free Diophantine problem", "comments": "6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We find algebraic conditions on a group equivalent to the position of its\nDiophantine problem in the Chomsky Hierarchy. In particular, it is proved that\na finitely generated group has a context-free Diophantine problem if and only\nif it is finite.\n", "versions": [{"version": "v1", "created": "Mon, 1 Feb 2021 14:13:22 GMT"}, {"version": "v2", "created": "Wed, 28 Jul 2021 17:16:53 GMT"}], "update_date": "2021-07-29", "authors_parsed": [["Yankovskiy", "Vladimir", ""]]}, {"id": "2102.00876", "submitter": "Nathana\\\"el Fijalkow", "authors": "Nathana\\\"el Fijalkow and Guillaume Lagarde", "title": "The Complexity of Learning Linear Temporal Formulas from Examples", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we initiate the study of the computational complexity of\nlearning linear temporal logic (LTL) formulas from examples. We construct\napproximation algorithms for fragments of LTL and prove hardness results; in\nparticular we obtain tight bounds for approximation of the fragment containing\nonly the next operator and conjunctions, and prove NP-completeness results for\nmany fragments.\n", "versions": [{"version": "v1", "created": "Mon, 1 Feb 2021 14:34:46 GMT"}], "update_date": "2021-02-02", "authors_parsed": [["Fijalkow", "Nathana\u00ebl", ""], ["Lagarde", "Guillaume", ""]]}, {"id": "2102.01490", "submitter": "Xinwei Fang", "authors": "Xinwei Fang and Radu Calinescu and Simos Gerasimou and Faisal Alhwikem", "title": "Fast Parametric Model Checking through Model Fragmentation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parametric model checking (PMC) computes algebraic formulae that express key\nnon-functional properties of a system (reliability, performance, etc.) as\nrational functions of the system and environment parameters. In software\nengineering, PMC formulae can be used during design, e.g., to analyse the\nsensitivity of different system architectures to parametric variability, or to\nfind optimal system configurations. They can also be used at runtime, e.g., to\ncheck if non-functional requirements are still satisfied after environmental\nchanges, or to select new configurations after such changes. However, current\nPMC techniques do not scale well to systems with complex behaviour and more\nthan a few parameters. Our paper introduces a fast PMC (fPMC) approach that\novercomes this limitation, extending the applicability of PMC to a broader\nclass of systems than previously possible. To this end, fPMC partitions the\nMarkov models that PMC operates with into \\emph{fragments} whose reachability\nproperties are analysed independently, and obtains PMC reachability formulae by\ncombining the results of these fragment analyses. To demonstrate the\neffectiveness of fPMC, we show how our fPMC tool can analyse three systems\n(taken from the research literature, and belonging to different application\ndomains) with which current PMC techniques and tools struggle.\n", "versions": [{"version": "v1", "created": "Tue, 2 Feb 2021 13:52:52 GMT"}], "update_date": "2021-02-03", "authors_parsed": [["Fang", "Xinwei", ""], ["Calinescu", "Radu", ""], ["Gerasimou", "Simos", ""], ["Alhwikem", "Faisal", ""]]}, {"id": "2102.01633", "submitter": "Ji\\v{r}\\'i \\v{S}\\'ima", "authors": "Ji\\v{r}\\'i \\v{S}\\'ima", "title": "Stronger Separation of Analog Neuron Hierarchy by Deterministic\n  Context-Free Languages", "comments": "30 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We analyze the computational power of discrete-time recurrent neural networks\n(NNs) with the saturated-linear activation function within the Chomsky\nhierarchy. This model restricted to integer weights coincides with binary-state\nNNs with the Heaviside activation function, which are equivalent to finite\nautomata (Chomsky level 3) recognizing regular languages (REG), while rational\nweights make this model Turing-complete even for three analog-state units\n(Chomsky level 0). For the intermediate model $\\alpha$ANN of a binary-state NN\nthat is extended with $\\alpha\\geq 0$ extra analog-state neurons with rational\nweights, we have established the analog neuron hierarchy 0ANNs $\\subset$ 1ANNs\n$\\subset$ 2ANNs $\\subseteq$ 3ANNs. The separation 1ANNs $\\subsetneqq$ 2ANNs has\nbeen witnessed by the non-regular deterministic context-free language (DCFL)\n$L_\\#=\\{0^n1^n\\mid n\\geq 1\\}$ which cannot be recognized by any 1ANN even with\nreal weights, while any DCFL (Chomsky level 2) is accepted by a 2ANN with\nrational weights. In this paper, we strengthen this separation by showing that\nany non-regular DCFL cannot be recognized by 1ANNs with real weights, which\nmeans (DCFLs $\\setminus$ REG) $\\subset$ (2ANNs $\\setminus$ 1ANNs), implying\n1ANNs $\\cap$ DCFLs = 0ANNs. For this purpose, we have shown that $L_\\#$ is the\nsimplest non-regular DCFL by reducing $L_\\#$ to any language in this class,\nwhich is by itself an interesting achievement in computability theory.\n", "versions": [{"version": "v1", "created": "Tue, 2 Feb 2021 17:44:19 GMT"}], "update_date": "2021-02-03", "authors_parsed": [["\u0160\u00edma", "Ji\u0159\u00ed", ""]]}, {"id": "2102.01812", "submitter": "Muslum Ozgur Ozmen", "authors": "Muslum Ozgur Ozmen, Xuansong Li, Andrew Chun-An Chu, Z. Berkay Celik,\n  Bardh Hoxha and Xiangyu Zhang", "title": "Discovering Physical Interaction Vulnerabilities in IoT Deployments", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Internet of Things (IoT) applications drive the behavior of IoT deployments\naccording to installed sensors and actuators. It has recently been shown that\nIoT deployments are vulnerable to physical interactions, caused by design flaws\nor malicious intent, that can have severe physical consequences. Yet, extant\napproaches to securing IoT do not translate the app source code into its\nphysical behavior to evaluate physical interactions. Thus, IoT consumers and\nmarkets do not possess the capability to assess the safety and security risks\nthese interactions present. In this paper, we introduce the IoTSeer security\nservice for IoT deployments, which uncovers undesired states caused by physical\ninteractions. IoTSeer operates in four phases (1) translation of each actuation\ncommand and sensor event in an app source code into a hybrid I/O automaton that\ndefines an app's physical behavior, (2) combining apps in a novel composite\nautomaton that represents the joint physical behavior of interacting apps, (3)\napplying grid-based testing and falsification to validate whether an IoT\ndeployment conforms to desired physical interaction policies, and (4)\nidentification of the root cause of policy violations and proposing patches\nthat guide users to prevent them. We use IoTSeer in an actual house with 13\nactuators and six sensors with 37 apps and demonstrate its effectiveness and\nperformance.\n", "versions": [{"version": "v1", "created": "Wed, 3 Feb 2021 00:31:59 GMT"}], "update_date": "2021-02-04", "authors_parsed": [["Ozmen", "Muslum Ozgur", ""], ["Li", "Xuansong", ""], ["Chu", "Andrew Chun-An", ""], ["Celik", "Z. Berkay", ""], ["Hoxha", "Bardh", ""], ["Zhang", "Xiangyu", ""]]}, {"id": "2102.02609", "submitter": "Lars Lindemann", "authors": "Lars Lindemann and Dimos V. Dimarogonas", "title": "Barrier Function-based Collaborative Control of Multiple Robots under\n  Signal Temporal Logic Tasks", "comments": "Journal article in the IEEE Transactions on Control of Network\n  Systems", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.RO cs.SY math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Motivated by the recent interest in cyber-physical and autonomous robotic\nsystems, we study the problem of dynamically coupled multi-agent systems under\na set of signal temporal logic tasks. In particular, the satisfaction of each\nof these signal temporal logic tasks depends on the behavior of a distinct set\nof agents. Instead of abstracting the agent dynamics and the temporal logic\ntasks into a discrete domain and solving the problem therein or using\noptimization-based methods, we derive collaborative feedback control laws.\nThese control laws are based on a decentralized control barrier function\ncondition that results in discontinuous control laws, as opposed to a\ncentralized condition resembling the single-agent case. The benefits of our\napproach are inherent robustness properties typically present in feedback\ncontrol as well as satisfaction guarantees for continuous-time multi-agent\nsystems. More specifically, time-varying control barrier functions are used\nthat account for the semantics of the signal temporal logic tasks at hand. For\na certain fragment of signal temporal logic tasks, we further propose a\nsystematic way to construct such control barrier functions. Finally, we show\nthe efficacy and robustness of our framework in an experiment including a group\nof three omnidirectional robots.\n", "versions": [{"version": "v1", "created": "Thu, 4 Feb 2021 13:43:21 GMT"}], "update_date": "2021-02-05", "authors_parsed": [["Lindemann", "Lars", ""], ["Dimarogonas", "Dimos V.", ""]]}, {"id": "2102.02777", "submitter": "Ralph Childress Jr.", "authors": "Ralph L. Childress", "title": "Recursive Prime Factorizations: Dyck Words as Numbers", "comments": "50 pages, LaTeX; made corrections and clarifications, expanded\n  research question in Section 5.9, and replaced DFA recognizing squarefree\n  semiprime Dyck naturals in Section 5.13 with DFA recognizing primes", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.NT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  I propose a class of numeral systems where numbers are represented by Dyck\nwords, with the systems arising from a generalization of prime factorization.\nAfter describing two proper subsets of the Dyck language capable of uniquely\nrepresenting all natural and rational numbers respectively, I consider\n\"Dyck-complete\" languages, in which every member of the Dyck language\nrepresents a number. I conclude by suggesting possible research directions.\n", "versions": [{"version": "v1", "created": "Thu, 4 Feb 2021 17:56:44 GMT"}, {"version": "v2", "created": "Mon, 15 Feb 2021 18:23:14 GMT"}], "update_date": "2021-02-16", "authors_parsed": [["Childress", "Ralph L.", ""]]}, {"id": "2102.02850", "submitter": "George Monta\\~nez", "authors": "Sonia Sehra, David Flores, George D. Montanez", "title": "Undecidability of Underfitting in Learning Algorithms", "comments": "Accepted at The 2nd International Conference on Computing and Data\n  Science (CONF-CDS 2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.AI cs.FL cs.IT math.IT", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Using recent machine learning results that present an information-theoretic\nperspective on underfitting and overfitting, we prove that deciding whether an\nencodable learning algorithm will always underfit a dataset, even if given\nunlimited training time, is undecidable. We discuss the importance of this\nresult and potential topics for further research, including\ninformation-theoretic and probabilistic strategies for bounding learning\nalgorithm fit.\n", "versions": [{"version": "v1", "created": "Thu, 4 Feb 2021 19:35:05 GMT"}, {"version": "v2", "created": "Mon, 8 Feb 2021 17:48:49 GMT"}, {"version": "v3", "created": "Tue, 9 Feb 2021 21:52:02 GMT"}], "update_date": "2021-02-11", "authors_parsed": [["Sehra", "Sonia", ""], ["Flores", "David", ""], ["Montanez", "George D.", ""]]}, {"id": "2102.02889", "submitter": "Tom\\'a\\v{s} Masopust", "authors": "Ji\\v{r}\\'i Balun and Tom\\'a\\v{s} Masopust", "title": "Comparing the Notions of Opacity for Discrete-Event Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Opacity is an information flow property characterizing whether a system\nreveals its secret to a passive observer. Several notions of opacity have been\nintroduced in the literature. We study the notions of language-based opacity,\ncurrent-state opacity, initial-state opacity, initial-and-final-state opacity,\nK-step opacity, and infinite-step opacity. Comparing the notions is a natural\nquestion that has been investigated and summarized by Wu and Lafortune, who\nprovided transformations among current-state opacity, initial-and-final-state\nopacity, and language-based opacity, and, for prefix-closed languages, also\nbetween language-based opacity and initial-state opacity. We extend these\nresults by showing that all the discussed notions of opacity are transformable\nto each other. Besides a deeper insight into the differences among the notions,\nthe transformations have applications in complexity results. In particular, the\ntransformations are computable in polynomial time and preserve the number of\nobservable events and determinism, and hence the computational complexities of\nthe verification of the notions coincide. We provide a complete and improved\ncomplexity picture of the verification of the discussed notions of opacity, and\nimprove the algorithmic complexity of deciding language-based opacity,\ninfinite-step opacity, and K-step opacity.\n", "versions": [{"version": "v1", "created": "Thu, 4 Feb 2021 21:04:15 GMT"}, {"version": "v2", "created": "Sat, 26 Jun 2021 20:17:10 GMT"}], "update_date": "2021-06-29", "authors_parsed": [["Balun", "Ji\u0159\u00ed", ""], ["Masopust", "Tom\u00e1\u0161", ""]]}, {"id": "2102.02990", "submitter": "EPTCS", "authors": "Clemens Grabmayer (Gran Sasso Science Institute, L'Aquila)", "title": "Structure-Constrained Process Graphs for the Process Semantics of\n  Regular Expressions", "comments": "In Proceedings TERMGRAPH 2020, arXiv:2102.01804. A full version of\n  this paper, including the full proof of (P1), can be found at\n  arXiv:2012.10869", "journal-ref": "EPTCS 334, 2021, pp. 29-45", "doi": "10.4204/EPTCS.334.3", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Milner (1984) introduced a process semantics for regular expressions as\nprocess graphs. Unlike for the language semantics, where every regular (that\nis, DFA-accepted) language is the interpretation of some regular expression,\nthere are finite process graphs that are not bisimilar to the process\ninterpretation of any regular expression. For reasoning about graphs that are\nexpressible by regular expressions modulo bisimilarity it is desirable to have\nstructural representations of process graphs in the image of the\ninterpretation.\n  For '1-free' regular expressions, their process interpretations satisfy the\nstructural property LEE (loop existence and elimination). But this is not in\ngeneral the case for all regular expressions, as we show by examples. Yet as a\nremedy, we describe the possibility to recover the property LEE for a close\nvariant of the process interpretation. For this purpose we refine the process\nsemantics of regular expressions to yield process graphs with 1-transitions,\nsimilar to silent moves for finite-state automata.\n", "versions": [{"version": "v1", "created": "Fri, 5 Feb 2021 04:13:55 GMT"}], "update_date": "2021-02-08", "authors_parsed": [["Grabmayer", "Clemens", "", "Gran Sasso Science Institute, L'Aquila"]]}, {"id": "2102.03164", "submitter": "EPTCS", "authors": "Graham Campbell (School of Mathematics, Statistics and Physics,\n  Newcastle University, Newcastle upon Tyne, United Kingdom)", "title": "Parallel Hyperedge Replacement String Languages", "comments": "In Proceedings TERMGRAPH 2020, arXiv:2102.01804. arXiv admin note:\n  substantial text overlap with arXiv:2101.02310", "journal-ref": "EPTCS 334, 2021, pp. 46-61", "doi": "10.4204/EPTCS.334.4", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  There are many open questions surrounding the characterisation of groups with\ncontext-sensitive word problem. Only in 2018 was it shown that all finitely\ngenerated virtually Abelian groups have multiple context-free word problems,\nand it is a long-standing open question as to where to place the word problems\nof hyperbolic groups in the formal language hierarchy. In this paper, we\nintroduce a new language class called the parallel hyperedge replacement string\nlanguages, show that it contains all multiple context-free and ET0L languages,\nand lay down the foundations for future work that may be able to place the word\nproblems of many hyperbolic groups in this class.\n", "versions": [{"version": "v1", "created": "Thu, 4 Feb 2021 01:42:14 GMT"}], "update_date": "2021-02-23", "authors_parsed": [["Campbell", "Graham", "", "School of Mathematics, Statistics and Physics,\n  Newcastle University, Newcastle upon Tyne, United Kingdom"]]}, {"id": "2102.03821", "submitter": "Jason Bell", "authors": "Jason P. Bell and Jeffrey Shallit", "title": "Lie complexity of words", "comments": "13 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a finite alphabet $\\Sigma$ and a right-infinite word $\\bf w$ over\n$\\Sigma$, we define the Lie complexity function $L_{\\bf w}:\\mathbb{N}\\to\n\\mathbb{N}$, whose value at $n$ is the number of conjugacy classes (under\ncyclic shift) of length-$n$ factors $x$ of $\\bf w$ with the property that every\nelement of the conjugacy class appears in $\\bf w$.\n  We show that the Lie complexity function is uniformly bounded for words with\nlinear factor complexity, and as a result we show that words of linear factor\ncomplexity have at most finitely many primitive factors $y$ with the property\nthat $y^n$ is again a factor for every $n$.\n  We then look at automatic sequences and show that the Lie complexity function\nof a $k$-automatic sequence is again $k$-automatic.\n", "versions": [{"version": "v1", "created": "Sun, 7 Feb 2021 15:33:15 GMT"}], "update_date": "2021-02-09", "authors_parsed": [["Bell", "Jason P.", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "2102.04011", "submitter": "ShangBei Wang", "authors": "ShangBei Wang", "title": "From Matching Logic To Parallel Imperative Language Verification", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program verification is to develop the program's proof system, and to prove\nthe proof system soundness with respect to a trusted operational semantics of\nthe program. However, many practical program verifiers are not based on\noperational semantics and can't seriously validate the program. Matching logic\nis proposed to make program verification based on operational semantics. In\nthis paper, following Grigore Ro{\\c{s}}u 's work, we consider matching logic\nfor parallel imperative language(PIMP). According to our investigation, this\npaper is the first study on matching logic for PIMP. In our matching logic, we\nredefine \"interference-free\" to character parallel rule and prove the soundness\nof matching logic to the operational semantics of PIMP. We also link PIMP's\noperational semantics and PIMP's verification formally by constructing a\nmatching logic verifier for PIMP which executes rewriting logic semantics\nsymbolically on configuration patterns and is sound and complete to matching\nlogic for PIMP. That is our matching logic verifier for PIMP is sound to the\noperational semantics of PIMP. Finally, we also verify the matching logic\nverifier through an example which is a standard problem in parallel\nprogramming.\n", "versions": [{"version": "v1", "created": "Mon, 8 Feb 2021 06:01:28 GMT"}], "update_date": "2021-02-09", "authors_parsed": [["Wang", "ShangBei", ""]]}, {"id": "2102.04361", "submitter": "Daniel Stan", "authors": "Daniel Stan and Anthony Widjaja Lin", "title": "Regular Model Checking Approach to Knowledge Reasoning over\n  Parameterized Systems (technical report)", "comments": "Extended version, version of record accepted at the 20th\n  International Conference on Autonomous Agents and Multiagent Systems\n  (AAMAS-21)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a general framework for modelling and verifying epistemic\nproperties over parameterized multi-agent systems that communicate by truthful\npublic announcements. In our framework, the number of agents or the amount of\ncertain resources are parameterized (i.e. not known a priori), and the\ncorresponding verification problem asks whether a given epistemic property is\ntrue regardless of the instantiation of the parameters. For example, in a muddy\nchildren puzzle, one could ask whether each child will eventually find out\nwhether (s)he is muddy, regardless of the number of children.\n  Our framework is regular model checking (RMC)-based, wherein synchronous\nfinite-state automata (equivalently, monadic second-order logic over words) are\nused to specify the systems. We propose an extension of public announcement\nlogic as specification language. Of special interests is the addition of the\nso-called iterated public announcement operators, which are crucial for\nreasoning about knowledge in parameterized systems. Although the operators make\nthe model checking problem undecidable, we show that this becomes decidable\nwhen an appropriate \"disappearance relation\" is given. Further, we show how\nAngluin's L*-algorithm for learning finite automata can be applied to find a\ndisappearance relation, which is guaranteed to terminate if it is regular. We\nhave implemented the algorithm and apply this to such examples as the Muddy\nChildren Puzzle, the Russian Card Problem, and Large Number Challenge.\n", "versions": [{"version": "v1", "created": "Mon, 8 Feb 2021 17:10:24 GMT"}, {"version": "v2", "created": "Wed, 17 Feb 2021 21:50:29 GMT"}, {"version": "v3", "created": "Mon, 8 Mar 2021 19:20:12 GMT"}], "update_date": "2021-03-10", "authors_parsed": [["Stan", "Daniel", ""], ["Lin", "Anthony Widjaja", ""]]}, {"id": "2102.05968", "submitter": "Jose Ramon Gonz\\'alez De Mend\\'ivil", "authors": "Jos\\'e Ram\\'on Gonz\\'alez de Mend\\'ivil and Federico Fari\\~na", "title": "Recognizability of languages via deterministic finite automata with\n  values on a monoid: General Myhill-Nerode Theorem", "comments": "32 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  This paper deals with the problem of recognizability of functions l: Sigma*\n--> M that map words to values in the support set M of a monoid (M,.,1). These\nfunctions are called M-languages. M-languages are studied from the aspect of\ntheir recognition by deterministic finite automata whose components take values\non M (M-DFAs). The characterization of an M-language l is based on providing a\nright congruence on Sigma* that is defined through l and a factorization on the\nset of all M-languages, L(Sigma*,M) (in sort L). A factorization on L is a pair\nof functions (g,f) such that, for each l in L, g(l). f(l)= l, where g(l) in M\nand f(l) in L. In essence, a factorization is a form of common factor\nextraction. A general Myhill-Nerode theorem, which is valid for any L(Sigma*,\nM), is provided. Basically, l is recognized by an M-DFA if and only if there\nexists a factorization on L, (g,f), such that the right congruence on Sigma*\ninduced by the factorization (g,f) and f(l), has finite index. This paper shows\nthat the existence of M-DFAs guarantees the existence of natural non-trivial\nfactorizations on L without taking account any additional property on the\nmonoid.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2021 12:24:59 GMT"}], "update_date": "2021-02-12", "authors_parsed": [["de Mend\u00edvil", "Jos\u00e9 Ram\u00f3n Gonz\u00e1lez", ""], ["Fari\u00f1a", "Federico", ""]]}, {"id": "2102.06037", "submitter": "Atif Mashkoor", "authors": "Atif Mashkoor, Michael Leuschel, Alexander Egyed", "title": "Validation Obligations: A Novel Approach to Check Compliance between\n  Requirements and their Formal Specification", "comments": "ICSE 2021 - NIER", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Traditionally, practitioners use formal methods pre-dominately for one half\nof the quality-assurance process: verification (do we build the software\nright?). The other half -- validation (do we build the right software?) -- has\nbeen given comparatively little attention. While verification is the core of\nrefinement-based formal methods, where each new refinement step must preserve\nall properties of its abstract model, validation is usually postponed until the\nlatest stages of the development, when models can be automatically executed.\nThus mistakes in requirements or in their interpretation are caught too late:\nusually at the end of the development process. In this paper, we present a\nnovel approach to check compliance between requirements and their formal\nrefinement-based specification during the earlier stages of development. Our\nproposed approach -- \"validation obligations\" -- is based on the simple idea\nthat both verification and validation are an integral part of all refinement\nsteps of a system.\n", "versions": [{"version": "v1", "created": "Thu, 11 Feb 2021 14:28:32 GMT"}], "update_date": "2021-02-12", "authors_parsed": [["Mashkoor", "Atif", ""], ["Leuschel", "Michael", ""], ["Egyed", "Alexander", ""]]}, {"id": "2102.06326", "submitter": "Steve Dai", "authors": "Steve Dai, Alicia Klinefelter, Haoxing Ren, Rangharajan Venkatesan,\n  Ben Keller, Nathaniel Pinckney, Brucek Khailany", "title": "Verifying High-Level Latency-Insensitive Designs with Formal Model\n  Checking", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Latency-insensitive design mitigates increasing interconnect delay and\nenables productive component reuse in complex digital systems. This design\nstyle has been adopted in high-level design flows because untimed functional\nblocks connected through latency-insensitive interfaces provide a natural\ncommunication abstraction. However, latency-insensitive design with high-level\nlanguages also introduces a unique set of verification challenges that\njeopardize functional correctness. In particular, bugs due to invalid\nconsumption of inputs and deadlocks can be difficult to detect and debug with\ndynamic simulation methods. To tackle these two classes of bugs, we propose\nformal model checking methods to guarantee that a high-level\nlatency-insensitive design is unaffected by invalid input data and is free of\ndeadlock. We develop a well-structured verification wrapper for each property\nto automatically construct the corresponding formal model for checking. Our\nexperiments demonstrate that the formal checks are effective in realistic bug\nscenarios from high-level designs.\n", "versions": [{"version": "v1", "created": "Fri, 12 Feb 2021 01:56:23 GMT"}], "update_date": "2021-02-19", "authors_parsed": [["Dai", "Steve", ""], ["Klinefelter", "Alicia", ""], ["Ren", "Haoxing", ""], ["Venkatesan", "Rangharajan", ""], ["Keller", "Ben", ""], ["Pinckney", "Nathaniel", ""], ["Khailany", "Brucek", ""]]}, {"id": "2102.06798", "submitter": "Nicola Cotumaccio", "authors": "Nicola Cotumaccio, Giovanna D'Agostino, Alberto Policriti, Nicola\n  Prezza", "title": "Which Regular Languages can be Efficiently Indexed?", "comments": "Extended version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DS", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  In the present work, we tackle the regular language indexing problem by first\nstudying the hierarchy of $p$-sortable languages: regular languages accepted by\nautomata of width $p$. We show that the hierarchy is strict and does not\ncollapse, and provide (exponential in $p$) upper and lower bounds relating the\nminimum widths of equivalent NFAs and DFAs. Our bounds indicate the importance\nof being able to index NFAs, as they enable indexing regular languages with\nmuch faster and smaller indexes. Our second contribution solves precisely this\nproblem, optimally: we devise a polynomial-time algorithm that indexes any NFA\nwith the optimal value $p$ for its width, without explicitly computing $p$\n(NP-hard to find). In particular, this implies that we can index in polynomial\ntime the well-studied case $p=1$ (Wheeler NFAs). More in general, in polynomial\ntime we can build an index breaking the worst-case conditional lower bound of\n$\\Omega(|P| m)$, whenever the input NFA's width is $p \\in o(\\sqrt{m})$.\n", "versions": [{"version": "v1", "created": "Fri, 12 Feb 2021 22:25:30 GMT"}, {"version": "v2", "created": "Tue, 13 Jul 2021 13:51:19 GMT"}], "update_date": "2021-07-14", "authors_parsed": [["Cotumaccio", "Nicola", ""], ["D'Agostino", "Giovanna", ""], ["Policriti", "Alberto", ""], ["Prezza", "Nicola", ""]]}, {"id": "2102.06860", "submitter": "Clara Lacroce", "authors": "Borja Balle, Clara Lacroce, Prakash Panangaden, Doina Precup,\n  Guillaume Rabusseau", "title": "Optimal Spectral-Norm Approximate Minimization of Weighted Finite\n  Automata", "comments": "Full version of ICALP2021 paper, authors are listed in alphabetical\n  order", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address the approximate minimization problem for weighted finite automata\n(WFAs) with weights in $\\mathbb{R}$, over a one-letter alphabet: to compute the\nbest possible approximation of a WFA given a bound on the number of states.\nThis work is grounded in Adamyan-Arov-Krein Approximation theory, a remarkable\ncollection of results on the approximation of Hankel operators. In addition to\nits intrinsic mathematical relevance, this theory has proven to be very\neffective for model reduction. We adapt these results to the framework of\nweighted automata over a one-letter alphabet. We provide theoretical guarantees\nand bounds on the quality of the approximation in the spectral and $\\ell^2$\nnorm. We develop an algorithm that, based on the properties of Hankel\noperators, returns the optimal approximation in the spectral norm.\n", "versions": [{"version": "v1", "created": "Sat, 13 Feb 2021 04:54:46 GMT"}, {"version": "v2", "created": "Mon, 15 Mar 2021 14:38:09 GMT"}, {"version": "v3", "created": "Mon, 17 May 2021 15:01:28 GMT"}], "update_date": "2021-05-18", "authors_parsed": [["Balle", "Borja", ""], ["Lacroce", "Clara", ""], ["Panangaden", "Prakash", ""], ["Precup", "Doina", ""], ["Rabusseau", "Guillaume", ""]]}, {"id": "2102.06897", "submitter": "K. S. Thejaswini", "authors": "A. R. Balasubramanian (Technische Universit\\\"at M\\\"unchen, Munich,\n  Germany), K. S. Thejaswini (Department of Computer Science, University of\n  Warwick, UK)", "title": "Adaptive Synchronisation of Pushdown Automata", "comments": "29 pages, 5 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce the notion of adaptive synchronisation for pushdown automata, in\nwhich there is an external observer who has no knowledge about the current\nstate of the pushdown automaton, but can observe the contents of the stack. The\nobserver would then like to decide if it is possible to bring the automaton\nfrom any state into some predetermined state by giving inputs to it in an\n\\emph{adaptive} manner, i.e., the next input letter to be given can depend on\nhow the contents of the stack changed after the current input letter. We show\nthat for non-deterministic pushdown automata, this problem is\n2-EXPTIME-complete and for deterministic pushdown automata, we show\nEXPTIME-completeness.\n  To prove the lower bounds, we first introduce (different variants of)\nsubset-synchronisation and show that these problems are polynomial-time\nequivalent with the adaptive synchronisation problem. We then prove hardness\nresults for the subset-synchronisation problems. For proving the upper bounds,\nwe consider the problem of deciding if a given alternating pushdown system has\nan accepting run with at most $k$ leaves and we provide an $n^{O(k^2)}$ time\nalgorithm for this problem.\n", "versions": [{"version": "v1", "created": "Sat, 13 Feb 2021 10:47:19 GMT"}], "update_date": "2021-02-16", "authors_parsed": [["Balasubramanian", "A. R.", "", "Technische Universit\u00e4t M\u00fcnchen, Munich,\n  Germany"], ["Thejaswini", "K. S.", "", "Department of Computer Science, University of\n  Warwick, UK"]]}, {"id": "2102.07374", "submitter": "Xiang Long", "authors": "Xiang Long", "title": "MatchKAT: An Algebraic Foundation For Match-Action", "comments": "15 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.NI", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present MatchKAT, an algebraic language for modeling match-action packet\nprocessing in network switches. Although the match-action paradigm has remained\na popular low-level programming model for specifying packet forwarding\nbehavior, little has been done towards giving it formal semantics. With\nMatchKAT, we hope to embark on the first steps in exploring how network\nprograms compiled to match-action rules can be reasoned about formally in a\nreliable, algebraic way. In this paper, we give details of MatchKAT and its\nmetatheory, as well as a formal treatment of match expressions on binary\nstrings that form the basis of \"match\" in match-action. Through a\ncorrespondence with NetKAT, we show that MatchKAT's equational theory is sound\nand complete with regards to a similar packet filtering semantics. We also\ndemonstrate the complexity of deciding equivalence in MatchKAT is\nPSPACE-complete.\n", "versions": [{"version": "v1", "created": "Mon, 15 Feb 2021 07:29:08 GMT"}], "update_date": "2021-02-16", "authors_parsed": [["Long", "Xiang", ""]]}, {"id": "2102.07401", "submitter": "\\'Etienne Andr\\'e", "authors": "Masaki Waga, \\'Etienne Andr\\'e, Ichiro Hasuo", "title": "Model-bounded monitoring of hybrid systems", "comments": "This is the author (and slightly extended) version of the manuscript\n  of the same name published in the proceedings of the 12th ACM/IEEE\n  International Conference on Cyber-Physical Systems (ICCPS 2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Monitoring of hybrid systems attracts both scientific and practical\nattention. However, monitoring algorithms suffer from the methodological\ndifficulty of only observing sampled discrete-time signals, while real\nbehaviors are continuous-time signals. To mitigate this problem of sampling\nuncertainties, we introduce a model-bounded monitoring scheme, where we use\nprior knowledge about the target system to prune interpolation candidates.\nTechnically, we express such prior knowledge by linear hybrid automata (LHAs) -\nthe LHAs are called bounding models. We introduce a novel notion of monitored\nlanguage of LHAs, and we reduce the monitoring problem to the membership\nproblem of the monitored language. We present two partial algorithms - one is\nvia reduction to reachability in LHAs and the other is a direct one using\npolyhedra - and show that these methods, and thus the proposed model-bounded\nmonitoring scheme, are efficient and practically relevant.\n", "versions": [{"version": "v1", "created": "Mon, 15 Feb 2021 09:00:02 GMT"}], "update_date": "2021-02-16", "authors_parsed": [["Waga", "Masaki", ""], ["Andr\u00e9", "\u00c9tienne", ""], ["Hasuo", "Ichiro", ""]]}, {"id": "2102.07463", "submitter": "S. Akshay", "authors": "S. Akshay and Supratik Chakraborty", "title": "On synthesizing Skolem functions for first order logic formulae", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Skolem functions play a central role in logic, from eliminating quantifiers\nin first order logic formulas to providing functional implementations of\nrelational specifications. While classical results in logic are only interested\nin their existence, the question of how to effectively compute them is also\ninteresting, important and useful for several applications. In the restricted\ncase of Boolean propositional logic formula, this problem of synthesizing\nBoolean Skolem functions has been addressed in depth, with various recent work\nfocussing on both theoretical and practical aspects of the problem. However,\nthere are few existing results for the general case, and the focus has been on\nheuristical algorithms.\n  In this article, we undertake an investigation into the computational\nhardness of the problem of synthesizing Skolem functions for first order logic\nformula. We show that even under reasonable assumptions on the signature of the\nformula, it is impossible to compute or synthesize Skolem functions. Then we\ndetermine conditions on theories of first order logic which would render the\nproblem computable. Finally, we show that several natural theories satisfy\nthese conditions and hence do admit effective synthesis of Skolem functions.\n", "versions": [{"version": "v1", "created": "Mon, 15 Feb 2021 11:20:31 GMT"}], "update_date": "2021-02-16", "authors_parsed": [["Akshay", "S.", ""], ["Chakraborty", "Supratik", ""]]}, {"id": "2102.07504", "submitter": "Gerco van Heerdt", "authors": "Gerco van Heerdt, Tobias Kapp\\'e, Jurriaan Rot, Alexandra Silva", "title": "Learning Pomset Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We extend the L* algorithm to learn bimonoids recognising pomset languages.\nWe then identify a class of pomset automata that accepts precisely the class of\npomset languages recognised by bimonoids and show how to convert between\nbimonoids and automata.\n", "versions": [{"version": "v1", "created": "Mon, 15 Feb 2021 12:10:02 GMT"}], "update_date": "2021-02-16", "authors_parsed": [["van Heerdt", "Gerco", ""], ["Kapp\u00e9", "Tobias", ""], ["Rot", "Jurriaan", ""], ["Silva", "Alexandra", ""]]}, {"id": "2102.07724", "submitter": "Antoine Amarilli", "authors": "Antoine Amarilli, Charles Paperman", "title": "Locality and Centrality: The Variety ZG", "comments": "29 pages. Submitted", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study the variety ZG of monoids where the elements that belong to a group\nare central, i.e., commute with all other elements. We show that ZG is local,\nthat is, the semidirect product ZG*D of ZG by definite semigroups is equal to\nLZG, the variety of semigroups where all local monoids are in ZG. Our main\nresult is thus: ZG*D = LZG. We prove this result using Straubing's delay\ntheorem, by considering paths in the category of idempotents. In the process,\nwe obtain the characterization ZG = MNil \\vee Com, and also characterize the ZG\nlanguages, i.e., the languages whose syntactic monoid is in ZG: they are\nprecisely the languages that are finite unions of disjoint shuffles of\nsingleton languages and regular commutative languages.\n", "versions": [{"version": "v1", "created": "Mon, 15 Feb 2021 18:17:10 GMT"}], "update_date": "2021-02-16", "authors_parsed": [["Amarilli", "Antoine", ""], ["Paperman", "Charles", ""]]}, {"id": "2102.07728", "submitter": "Antoine Amarilli", "authors": "Antoine Amarilli, Louis Jachiet, Charles Paperman", "title": "Dynamic Membership for Regular Languages", "comments": "34 pages. This is the full version with proofs of the ICALP'21\n  article", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DS", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study the dynamic membership problem for regular languages: fix a language\nL, read a word w, build in time O(|w|) a data structure indicating if w is in\nL, and maintain this structure efficiently under letter substitutions on w. We\nconsider this problem on the unit cost RAM model with logarithmic word length,\nwhere the problem always has a solution in O(log |w| / log log |w|) per\noperation.\n  We show that the problem is in O(log log |w|) for languages in an\nalgebraically-defined, decidable class QSG, and that it is in O(1) for another\nsuch class QLZG. We show that languages not in QSG admit a reduction from the\nprefix problem for a cyclic group, so that they require {\\Omega}(log |w| / log\nlog |w|) operations in the worst case; and that QSG languages not in QLZG admit\na reduction from the prefix problem for the multiplicative monoid U 1 = {0, 1},\nwhich we conjecture cannot be maintained in O(1). This yields a conditional\ntrichotomy. We also investigate intermediate cases between O(1) and O(log log\n|w|).\n  Our results are shown via the dynamic word problem for monoids and\nsemigroups, for which we also give a classification. We thus solve open\nproblems of the paper of Skovbjerg Frandsen, Miltersen, and Skyum [30] on the\ndynamic word problem, and additionally cover regular languages.\n", "versions": [{"version": "v1", "created": "Mon, 15 Feb 2021 18:25:48 GMT"}, {"version": "v2", "created": "Fri, 4 Jun 2021 09:34:07 GMT"}], "update_date": "2021-06-07", "authors_parsed": [["Amarilli", "Antoine", ""], ["Jachiet", "Louis", ""], ["Paperman", "Charles", ""]]}, {"id": "2102.08331", "submitter": "Antoine Mottet", "authors": "Wojciech Czerwi\\'nski, Antoine Mottet, Karin Quaas", "title": "New Techniques for Universality in Unambiguous Register Automata", "comments": "arXiv admin note: text overlap with arXiv:1905.12445", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Register automata are finite automata equipped with a finite set of registers\nranging over the domain of some relational structure like $(\\mathbb N;=)$ or\n$(\\mathbb Q;<)$. Register automata process words over the domain, and along a\nrun of the automaton, the registers can store data from the input word for\nlater comparisons. It is long known that the universality problem, i.e., the\nproblem to decide whether a given register automaton accepts all words over the\ndomain, is undecidable. Recently, we proved the problem to be decidable in\n2-ExpSpace if the register automaton under study is over $(\\mathbb N;=)$ and\nunambiguous, i.e., every input word has at most one accepting run; this result\nwas shortly after improved to 2-ExpTime by Barloy and Clemente. In this paper,\nwe go one step further and prove that the problem is in ExpSpace, and in PSpace\nif the number of registers is fixed. Our proof is based on new techniques that\nadditionally allow us to show that the problem is in PSpace for single-register\nautomata over $(\\mathbb Q;<)$. As a third technical contribution we prove that\nthe problem is decidable (in ExpSpace) for a more expressive model of\nunambiguous register automata, where the registers can take values\nnondeterministically, if defined over $(\\mathbb N;=)$ and only one register is\nused.\n", "versions": [{"version": "v1", "created": "Tue, 16 Feb 2021 18:19:12 GMT"}], "update_date": "2021-02-17", "authors_parsed": [["Czerwi\u0144ski", "Wojciech", ""], ["Mottet", "Antoine", ""], ["Quaas", "Karin", ""]]}, {"id": "2102.08705", "submitter": "Janusz Schmude", "authors": "Janusz Schmude", "title": "On polynomial grammars extended with substitution", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We investigate decidability of equivalence of register transducers, also\ncalled copyful Streaming String Transducers in case of string input, extended\nwith an operation of substituting a register for all occurrences of a given\nletter in another register. We reduce to zeroness of polynomial grammars (over\nring of polynomials) extended with analogous substitution operation by encoding\nstrings into polynomials; a similar method was used successfully by Seidl et\nal. in 2018. We give two restrictions under which register transducers with\nsubstitution have decidable equivalence. They seem to be very restrictive but\non the other hand, they seem to be on the edge of the scope of this\n\"polynomial\" method, as in the third result we give a rather restricted model\nof polynomial grammars with substitution that has undecidable equivalence.\n", "versions": [{"version": "v1", "created": "Wed, 17 Feb 2021 11:40:18 GMT"}], "update_date": "2021-02-18", "authors_parsed": [["Schmude", "Janusz", ""]]}, {"id": "2102.09347", "submitter": "Valdigleis Silva Costa", "authors": "Valdigleis S. Costa, Benjam\\'in C. Bedregal and Regivan H. N. Santiago", "title": "On Typical Hesitant Fuzzy Languages and Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The idea of nondeterministic typical hesitant fuzzy automata is a\ngeneralization of the fuzzy automata presented by Costa and Bedregal. This\npaper, presents the sufficient and necessary conditions for a typical hesitant\nfuzzy language to be computed by nondeterministic typical hesitant fuzzy\nautomata. Besides, the paper introduces a new class of Typical Hesitant Fuzzy\nAutomata with crisp transitions, and we will show that this new class is\nequivalent to the original class introduced by Costa and Bedregal\n", "versions": [{"version": "v1", "created": "Thu, 18 Feb 2021 13:59:54 GMT"}], "update_date": "2021-02-19", "authors_parsed": [["Costa", "Valdigleis S.", ""], ["Bedregal", "Benjam\u00edn C.", ""], ["Santiago", "Regivan H. N.", ""]]}, {"id": "2102.09478", "submitter": "Massimiliano Goldwurm", "authors": "Massimiliano Goldwurm, Jianyi Lin, Marco Vignati", "title": "Local limit laws for symbol statistics in bicomponent rational models", "comments": "26 pages. It includes works presented at the following conferences:\n  20th DCFS (LNCS 10952, 114-125), 23rd DLT (LNCS 11647, 306-318), 20th ICTCS\n  (CEUR-WS.ORG 2504, 78-90)", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.PR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the local limit distribution of the number of occurrences of a\nsymbol in words of length $n$ generated at random in a regular language\naccording to a rational stochastic model. We present an analysis of the main\nlocal limits when the finite state automaton defining the stochastic model\nconsists of two primitive components. The limit distributions depend on several\nparameters and conditions, such as the main constants of mean value and\nvariance of our statistics associated with the two components, and the\nexistence of communications from the first to the second component. The\nconvergence rate of these results is always of order $O(n^{-1/2})$. We also\nprove an analogous $O(n^{-1/2})$ convergence rate to a Gaussian density of the\nsame statistic whenever the stochastic models only consists of one (primitive)\ncomponent.\n", "versions": [{"version": "v1", "created": "Thu, 18 Feb 2021 17:00:15 GMT"}], "update_date": "2021-02-19", "authors_parsed": [["Goldwurm", "Massimiliano", ""], ["Lin", "Jianyi", ""], ["Vignati", "Marco", ""]]}, {"id": "2102.09821", "submitter": "Lars Moormann", "authors": "R.H.J. Schouten, L. Moormann, J.M. van de Mortel-Fronczak, and J.E.\n  Rooda", "title": "Synthesis and Implementation of Distributed Supervisory Controllers with\n  Communication Delays", "comments": "14 pages, 22 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In literature, extensive research has been done with respect to synthesis of\nsupervisory controllers. Such synthesized supervisors can be distributed for\nimplementation on multiple physical controllers. This paper discusses a method\nfor distributing a synthesized supervisory controller. In this method,\ndependency structure matrices are used to distribute a system, the supervisor\nis then distributed accordingly, using existing localization theory. The\nexistence of communication delays between supervisory controllers is\nunavoidable in a distributed application. The influence of these delays on the\nbehavior of a supervisor is therefore studied using delay robustness theory.\nThis paper introduces the use of mutex algorithms to make the distributed\nsupervisor delay-robust. A case study is used to demonstrate the method and\nhardware in the loop testing is used to validate the resulting distributed\nsupervisor.\n", "versions": [{"version": "v1", "created": "Fri, 19 Feb 2021 09:17:39 GMT"}], "update_date": "2021-02-22", "authors_parsed": [["Schouten", "R. H. J.", ""], ["Moormann", "L.", ""], ["van de Mortel-Fronczak", "J. M.", ""], ["Rooda", "J. E.", ""]]}, {"id": "2102.10035", "submitter": "Georgiana Caltais", "authors": "Georgiana Caltais, Hossein Hojjat, Mohammad Mousavi, Hunkar Can Tunc", "title": "DyNetKAT: An Algebra of Dynamic Networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce a formal language for specifying dynamic updates for Software\nDefined Networks. Our language builds upon Network Kleene Algebra with Tests\n(NetKAT) and adds constructs for synchronisations and multi-packet behaviour to\ncapture the interaction between the control- and data-plane in dynamic updates.\nWe provide a sound and ground-complete axiomatisation of our language. We\nexploit the equational theory to provide an efficient reasoning method about\nsafety properties for dynamic networks. We implement our equational theory in\nDyNetiKAT -- a tool prototype, based on the Maude Rewriting Logic and the\nNetKAT tool, and apply it to a case study. We show that we can analyse the case\nstudy for networks with hundreds of switches using our initial tool prototype.\n", "versions": [{"version": "v1", "created": "Fri, 19 Feb 2021 17:08:02 GMT"}, {"version": "v2", "created": "Mon, 22 Feb 2021 14:47:48 GMT"}, {"version": "v3", "created": "Mon, 3 May 2021 10:28:31 GMT"}, {"version": "v4", "created": "Sat, 22 May 2021 08:11:16 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Caltais", "Georgiana", ""], ["Hojjat", "Hossein", ""], ["Mousavi", "Mohammad", ""], ["Tunc", "Hunkar Can", ""]]}, {"id": "2102.10104", "submitter": "Pierre Vandenhove", "authors": "Patricia Bouyer, Youssouf Oualhadj, Mickael Randour, Pierre Vandenhove", "title": "Arena-Independent Finite-Memory Determinacy in Stochastic Games", "comments": "Full version of CONCUR 2021 conference paper. 38 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study stochastic zero-sum games on graphs, which are prevalent tools to\nmodel decision-making in presence of an antagonistic opponent in a random\nenvironment. In this setting, an important question is the one of strategy\ncomplexity: what kinds of strategies are sufficient or required to play\noptimally (e.g., randomization or memory requirements)? Our contributions\nfurther the understanding of arena-independent finite-memory (AIFM)\ndeterminacy, i.e., the study of objectives for which memory is needed, but in a\nway that only depends on limited parameters of the game graphs. First, we show\nthat objectives for which pure AIFM strategies suffice to play optimally also\nadmit pure AIFM subgame perfect strategies. Second, we show that we can reduce\nthe study of objectives for which pure AIFM strategies suffice in two-player\nstochastic games to the easier study of one-player stochastic games (i.e.,\nMarkov decision processes). Third, we characterize the sufficiency of AIFM\nstrategies through two intuitive properties of objectives. This work extends a\nline of research started on deterministic games in [BLO+20] to stochastic ones.\n  [BLO+20] Patricia Bouyer, St\\'ephane Le Roux, Youssouf Oualhadj, Mickael\nRandour, and Pierre Vandenhove. Games Where You Can Play Optimally with\nArena-Independent Finite Memory. CONCUR 2020.\n", "versions": [{"version": "v1", "created": "Fri, 19 Feb 2021 18:58:36 GMT"}, {"version": "v2", "created": "Mon, 3 May 2021 13:20:03 GMT"}, {"version": "v3", "created": "Fri, 9 Jul 2021 11:14:34 GMT"}], "update_date": "2021-07-12", "authors_parsed": [["Bouyer", "Patricia", ""], ["Oualhadj", "Youssouf", ""], ["Randour", "Mickael", ""], ["Vandenhove", "Pierre", ""]]}, {"id": "2102.10182", "submitter": "Corto Mascle", "authors": "Yoan G\\'eran, Bastien Laboureix, Corto Mascle, Valentin D. Richard", "title": "Keyboards as a new model of computation", "comments": "Two versions, in French and in English", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce a new formalisation of languages, called keyboards. We consider\na set of elementary operations (writing/erasing a letter, going to the right or\nto the left,...) and we define a keyboard as a set of finite sequences of such\noperations, called keys. The corresponding language is the set of words\nobtained by applying some sequence of those keys. Unlike classical models of\ncomputation, every key can be applied anytime. We define various classes of\nlanguages based on different sets of elementary operations, and compare their\nexpressive powers. We also compare them to well-known classes of languages\n(Chomsky hierarchy). We obtain a strict hierarchy of languages, whose\nexpressivity is orthogonal to the one of the aforementionned classical models.\n  --\n  Nous introduisons une nouvelle repr\\'esentation de langages, les claviers. On\nse munit d'un ensemble d'op\\'erations \\'el\\'ementaires (ajout, effacement d'une\nlettre, d\\'eplacement \\`a droite, \\`a gauche, ...), et on d\\'efinit un clavier\ncomme un ensemble de suites finies d'op\\'erations \\'el\\'ementaires, appel\\'ees\ntouches. Son langage sera l'ensemble des mots obtenus en appliquant une suite\nquelconque de touches. Contrairement \\`a des mod\\`eles de calcul classiques,\ntoutes les touches peuvent \\^etre appliqu\\'ees \\`a tout moment. En premier lieu\nnous d\\'efinissons diff\\'erentes classes de claviers en faisant varier\nl'ensemble des op\\'erations \\'el\\'ementaires autoris\\'ees, et nous comparons\nl'expressivit\\'e des classes de langages obtenues. Nous comparons \\'egalement\nces classes \\`a la hi\\'erarchie de Chomsky. Nous obtenons que toutes les\nclasses \\'etudi\\'ees sont diff\\'erentes, et nous caract\\'erisons les classes\ninclues dans les rationnels et les alg\\'ebriques. L'expressivit\\'e des claviers\nsemble orthogonale \\`a celle des mod\\`eles \\'evoqu\\'es pr\\'ec\\'edemment.\n", "versions": [{"version": "v1", "created": "Fri, 19 Feb 2021 22:17:18 GMT"}, {"version": "v2", "created": "Tue, 2 Mar 2021 10:37:22 GMT"}, {"version": "v3", "created": "Thu, 1 Jul 2021 14:51:57 GMT"}], "update_date": "2021-07-02", "authors_parsed": [["G\u00e9ran", "Yoan", ""], ["Laboureix", "Bastien", ""], ["Mascle", "Corto", ""], ["Richard", "Valentin D.", ""]]}, {"id": "2102.10416", "submitter": "Petr Jancar", "authors": "Petr Jancar and Jiri Sima", "title": "Simplest Non-Regular Deterministic Context-Free Language", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new notion of C-simple problems for a class C of decision\nproblems (i.e. languages), w.r.t. a particular reduction. A problem is C-simple\nif it can be reduced to each problem in C. This can be viewed as a conceptual\ncounterpart to C-hard problems to which all problems in C reduce. Our concrete\nexample is the class of non-regular deterministic context-free languages\n(DCFL'), with a truth-table reduction by Mealy machines (which proves to be a\npreorder). The main technical result is a proof that the DCFL' language\n$L=\\{0^n1^n; n\\geq 1\\}$ is DCFL'-simple, which can thus be viewed as the\nsimplest problem in the class DCFL'. This result has already provided an\napplication, to the computational model of neural networks 1ANN at the first\nlevel of analog neuron hierarchy. This model was proven not to recognize $L$,\nby using a specialized technical argument that can hardly be generalized to\nother languages in DCFL'. By the result that $L$ is DCFL'-simple, w.r.t. the\nreduction that can be implemented by 1ANN, we immediately obtain that 1ANN\ncannot accept any language in DCFL'. It thus seems worthwhile to explore if\nlooking for C-simple problems in other classes C under suitable reductions\ncould provide effective tools for expanding the lower-bound results known for\nsingle problems to the whole classes of problems.\n", "versions": [{"version": "v1", "created": "Sat, 20 Feb 2021 18:38:57 GMT"}], "update_date": "2021-02-23", "authors_parsed": [["Jancar", "Petr", ""], ["Sima", "Jiri", ""]]}, {"id": "2102.10566", "submitter": "Milliam Maxime Zekeng Ndadji", "authors": "Milliam Maxime Zekeng Ndadji, Maurice Tchoup\\'e Tchendji, Cl\\'ementin\n  Tayou Djamegni, Didier Parigot", "title": "A Projection-Stable Grammatical Model for the Distributed Execution of\n  Administrative Processes with Emphasis on Actors' Views", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.DC cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  During the last two decades, the decentralized execution of business\nprocesses has been one of the main research topics in Business Process\nManagement. Several models (languages) for processes' specification in order to\nfacilitate their distributed execution, have been proposed. LSAWfP is among the\nmost recent in this area: it helps to specify administrative processes with\ngrammatical models indicating, in addition to their fundamental elements, the\npermissions (reading, writing and execution) of each actor in relation to each\nof their tasks. In this paper, we present a model for a completely\ndecentralized and artifact-centric execution of administrative processes\nspecified using LSAWfP. The presented model puts particular emphasis on actors'\nviews: it then allows the confidential execution of certain tasks by ensuring\nthat, each actor potentially has only a partial perception of the processes'\nglobal execution states. The model thus solves a very important problem in\nbusiness process execution, which is often sidelined in existing approaches. To\naccomplish this, the model rely on three projection algorithms allowing to\npartially replicate the processes' global execution states at a given moment,\nto consistently update the obtained partial states and to deduce new coherent\nglobal states. The proposal of these three algorithms, the proof of underlying\nmathematical tools' stability and a proposal of their implementation, are this\npaper's main contributions.\n", "versions": [{"version": "v1", "created": "Sun, 21 Feb 2021 09:33:31 GMT"}, {"version": "v2", "created": "Sat, 27 Mar 2021 20:40:53 GMT"}], "update_date": "2021-03-30", "authors_parsed": [["Ndadji", "Milliam Maxime Zekeng", ""], ["Tchendji", "Maurice Tchoup\u00e9", ""], ["Djamegni", "Cl\u00e9mentin Tayou", ""], ["Parigot", "Didier", ""]]}, {"id": "2102.10604", "submitter": "Hanlin Niu", "authors": "Hanlin Niu, Ze Ji, Al Savvaris, Antonios Tsourdos, and Joaquin\n  Carrasco", "title": "Model Checking for Decision Making System of Long Endurance Unmanned\n  Surface Vehicle", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work aims to develop a model checking method to verify the decision\nmaking system of Unmanned Surface Vehicle (USV) in a long range surveillance\nmission. The scenario in this work was captured from a long endurance USV\nsurveillance mission using C-Enduro, an USV manufactured by ASV Ltd. The\nC-Enduro USV may encounter multiple non-deterministic and concurrent problems\nincluding lost communication signals, collision risk and malfunction. The\nvehicle is designed to utilise multiple energy sources from solar panel, wind\nturbine and diesel generator. The energy state can be affected by the solar\nirradiance condition, wind condition, states of the diesel generator, sea\ncurrent condition and states of the USV. In this research, the states and the\ninteractive relations between environmental uncertainties, sensors, USV energy\nsystem, USV and Ground Control Station (GCS) decision making systems are\nabstracted and modelled successfully using Kripke models. The desirable\nproperties to be verified are expressed using temporal logic statement and\nfinally the safety properties and the long endurance properties are verified\nusing the model checker MCMAS, a model checker for multi-agent systems. The\nverification results are analyzed and show the feasibility of applying model\nchecking method to retrospect the desirable property of the USV decision making\nsystem. This method could assist researcher to identify potential design error\nof decision making system in advance.\n", "versions": [{"version": "v1", "created": "Sun, 21 Feb 2021 13:42:40 GMT"}, {"version": "v2", "created": "Tue, 23 Feb 2021 02:53:18 GMT"}], "update_date": "2021-02-24", "authors_parsed": [["Niu", "Hanlin", ""], ["Ji", "Ze", ""], ["Savvaris", "Al", ""], ["Tsourdos", "Antonios", ""], ["Carrasco", "Joaquin", ""]]}, {"id": "2102.10828", "submitter": "Manon Stipulanti", "authors": "Michel Rigo and Manon Stipulanti", "title": "Automatic sequences: from rational bases to trees", "comments": "25 pages, 15 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The $n$th term of an automatic sequence is the output of a deterministic\nfinite automaton fed with the representation of $n$ in a suitable numeration\nsystem. In this paper, instead of considering automatic sequences built on a\nnumeration system with a regular numeration language, we consider these built\non languages associated with trees having periodic labeled signatures and, in\nparticular, rational base numeration systems. We obtain two main\ncharacterizations of these sequences. The first one is concerned with $r$-block\nsubstitutions where $r$ morphisms are applied periodically. In particular, we\nprovide examples of such sequences that are not morphic. The second\ncharacterization involves the factors, or subtrees of finite height, of the\ntree associated with the numeration system and decorated by the terms of the\nsequence.\n", "versions": [{"version": "v1", "created": "Mon, 22 Feb 2021 08:31:41 GMT"}], "update_date": "2021-02-23", "authors_parsed": [["Rigo", "Michel", ""], ["Stipulanti", "Manon", ""]]}, {"id": "2102.11350", "submitter": "James Hsin-Yu Chiang", "authors": "Massimo Bartoletti, James Hsin-yu Chiang, Alberto Lluch-Lafuente", "title": "A theory of Automated Market Makers in DeFi", "comments": "In: COORDINATION 2021, (to appear). 18 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automated market makers (AMMs) are one of the most prominent decentralized\nfinance (DeFi) applications. They allow users to exchange units of different\ntypes of crypto-assets, without the need to find a counter-party. There are\nseveral implementations and models for AMMs, featuring a variety of\nsophisticated economic mechanisms. We present a theory of AMMs. The core of our\ntheory is an abstract operational model of the interactions between users and\nAMMs, which can be instantiated with any desired economic design mechanism. We\nexploit our theory to formally prove a set of fundamental properties of AMMs,\ncharacterizing both structural and economic aspects. We do this by abstracting\nfrom the actual economic mechanisms used in implementations, by identifying\nsufficient conditions which ensure the relevant properties. Notably, we devise\na general solution to the arbitrage problem, the main game-theoretic foundation\nbehind the economic mechanisms of AMMs.\n", "versions": [{"version": "v1", "created": "Mon, 22 Feb 2021 20:44:52 GMT"}, {"version": "v2", "created": "Sat, 24 Apr 2021 13:12:46 GMT"}], "update_date": "2021-04-27", "authors_parsed": [["Bartoletti", "Massimo", ""], ["Chiang", "James Hsin-yu", ""], ["Lluch-Lafuente", "Alberto", ""]]}, {"id": "2102.11630", "submitter": "Philipp Czerner", "authors": "Philipp Czerner, Roland Guttenberg, Martin Helfrich, Javier Esparza", "title": "Decision Power of Weak Asynchronous Models of Distributed Computing", "comments": "Various minor revisions", "journal-ref": null, "doi": "10.1145/3465084.3467918", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Esparza and Reiter have recently conducted a systematic comparative study of\nmodels of distributed computing consisting of a network of identical\nfinite-state automata that cooperate to decide if the underlying graph of the\nnetwork satisfies a given property. The study classifies models according to\nfour criteria, and shows that twenty initially possible combinations collapse\ninto seven equivalence classes with respect to their decision power, i.e. the\nproperties that the automata of each class can decide. However, Esparza and\nReiter only show (proper) inclusions between the classes, and so do not\ncharacterise their decision power. In this paper we do so for labelling\nproperties, i.e. properties that depend only on the labels of the nodes, but\nnot on the structure of the graph. In particular, majority (whether more nodes\ncarry label $a$ than $b$) is a labelling property. Our results show that only\none of the seven equivalence classes identified by Esparza and Reiter can\ndecide majority for arbitrary networks. We then study the expressive power of\nthe classes on bounded-degree networks, and show that three classes can. In\nparticular, we present an algorithm for majority that works for all\nbounded-degree networks under adversarial schedulers, i.e. even if the\nscheduler must only satisfy that every node makes a move infinitely often, and\nprove that no such algorithm can work for arbitrary networks.\n", "versions": [{"version": "v1", "created": "Tue, 23 Feb 2021 11:10:59 GMT"}, {"version": "v2", "created": "Wed, 2 Jun 2021 15:58:42 GMT"}], "update_date": "2021-06-03", "authors_parsed": [["Czerner", "Philipp", ""], ["Guttenberg", "Roland", ""], ["Helfrich", "Martin", ""], ["Esparza", "Javier", ""]]}, {"id": "2102.12448", "submitter": "Georgiana Caltais", "authors": "Georgiana Caltais, Hunkar Can Tunc", "title": "Explaining Safety Failures in NetKAT", "comments": "arXiv admin note: substantial text overlap with arXiv:1909.01745", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.NI", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This work introduces a concept of explanations with respect to the violation\nof safe behaviours within software defined networks (SDNs) expressible in\nNetKAT. The latter is a network programming language based on a well-studied\nmathematical structure, namely, Kleene Algebra with Tests (KAT). Amongst\nothers, the mathematical foundation of NetKAT gave rise to a sound and complete\nequational theory. In our setting, a safe behaviour is characterised by a\nNetKAT policy, or program, which does not enable forwarding packets from an\ningress i to an undesirable egress e. We show how explanations for safety\nviolations can be derived in an equational fashion, according to a modification\nof the existing NetKAT axiomatisation. We propose an approach based on the\nMaude system for actually computing the undesired behaviours witnessing the\nforwarding of packets from i to e as above. SDN-SafeCheck is a tool based on\nMaude equational theories satisfying important properties such as Church-Rosser\nand termination. SDN-SafeCheck automatically identifies all the undesired\nbehaviours leading to e, covering forwarding paths up to a user specified size.\n", "versions": [{"version": "v1", "created": "Wed, 24 Feb 2021 18:27:34 GMT"}], "update_date": "2021-02-25", "authors_parsed": [["Caltais", "Georgiana", ""], ["Tunc", "Hunkar Can", ""]]}, {"id": "2102.12855", "submitter": "Mingyu Cai", "authors": "Mingyu Cai, Mohammadhosein Hasanbeig, Shaoping Xiao, Alessandro Abate\n  and Zhen Kan", "title": "Modular Deep Reinforcement Learning for Continuous Motion Planning with\n  Temporal Logic", "comments": "arXiv admin note: text overlap with arXiv:2010.06797", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.AI cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper investigates the motion planning of autonomous dynamical systems\nmodeled by Markov decision processes (MDP) with unknown transition\nprobabilities over continuous state and action spaces. Linear temporal logic\n(LTL) is used to specify high-level tasks over infinite horizon, which can be\nconverted into a limit deterministic generalized B\\\"uchi automaton (LDGBA) with\nseveral accepting sets. The novelty is to design an embedded product MDP\n(EP-MDP) between the LDGBA and the MDP by incorporating a synchronous\ntracking-frontier function to record unvisited accepting sets of the automaton,\nand to facilitate the satisfaction of the accepting conditions. The proposed\nLDGBA-based reward shaping and discounting schemes for the model-free\nreinforcement learning (RL) only depend on the EP-MDP states and can overcome\nthe issues of sparse rewards. Rigorous analysis shows that any RL method that\noptimizes the expected discounted return is guaranteed to find an optimal\npolicy whose traces maximize the satisfaction probability. A modular deep\ndeterministic policy gradient (DDPG) is then developed to generate such\npolicies over continuous state and action spaces. The performance of our\nframework is evaluated via an array of OpenAI gym environments.\n", "versions": [{"version": "v1", "created": "Wed, 24 Feb 2021 01:11:25 GMT"}, {"version": "v2", "created": "Mon, 7 Jun 2021 18:52:06 GMT"}, {"version": "v3", "created": "Thu, 29 Jul 2021 16:26:14 GMT"}], "update_date": "2021-07-30", "authors_parsed": [["Cai", "Mingyu", ""], ["Hasanbeig", "Mohammadhosein", ""], ["Xiao", "Shaoping", ""], ["Abate", "Alessandro", ""], ["Kan", "Zhen", ""]]}, {"id": "2102.13095", "submitter": "Dmitry Chistikov", "authors": "Dmitry Chistikov and Rupak Majumdar and Philipp Schepper", "title": "Subcubic Certificates for CFL Reachability", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many problems in interprocedural program analysis can be modeled as the\ncontext-free language (CFL) reachability problem on graphs and can be solved in\ncubic time. Despite years of efforts, there are no known truly sub-cubic\nalgorithms for this problem. We study the related certification task: given an\ninstance of CFL reachability, are there small and efficiently checkable\ncertificates for the existence and for the non-existence of a path? We show\nthat, in both scenarios, there exist succinct certificates ($O(n^2)$ in the\nsize of the problem) and these certificates can be checked in subcubic (matrix\nmultiplication) time. The certificates are based on grammar-based compression\nof paths (for positive instances) and on invariants represented as matrix\nconstraints (for negative instances). Thus, CFL reachability lies in\nnondeterministic and co-nondeterministic subcubic time.\n  A natural question is whether faster algorithms for CFL reachability will\nlead to faster algorithms for combinatorial problems such as Boolean\nsatisfiability (SAT). As a consequence of our certification results, we show\nthat there cannot be a fine-grained reduction from SAT to CFL reachability for\na conditional lower bound stronger than $n^\\omega$, unless the nondeterministic\nstrong exponential time hypothesis (NSETH) fails.\n  Our results extend to related subcubic equivalent problems: pushdown\nreachability and two-way nondeterministic pushdown automata (2NPDA) language\nrecognition. For example, we describe succinct certificates for pushdown\nnon-reachability (inductive invariants) and observe that they can be checked in\nmatrix multiplication time. We also extract a new hardest 2NPDA language,\ncapturing the \"hard core\" of all these problems.\n", "versions": [{"version": "v1", "created": "Thu, 25 Feb 2021 18:58:29 GMT"}], "update_date": "2021-02-26", "authors_parsed": [["Chistikov", "Dmitry", ""], ["Majumdar", "Rupak", ""], ["Schepper", "Philipp", ""]]}]