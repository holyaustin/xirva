[{"id": "1505.00019", "submitter": "Boris Zolotov", "authors": "Boris Zolotov", "title": "Another Solution to the Thue Problem of Non-Repeating Words", "comments": "27 pages, 8 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  In this work we consider morphisms that preserve well-known non-repeating\nproperties: squarefreeness, cubefreeness, overlap-freeness and weak\nsquarefreeness. Up to the present moment only the morphisms preserving three\nout of four non-repeating properties have been known. The problem of the\nexistence of weakly squarefree morphisms was open.\n  The essential result of this work is the positive solution to this problem.\nAn example of the morphism preserving all four properties is provided. Also, it\nis proved that there are no morphisms with the same properties and a lower\nrank.\n", "versions": [{"version": "v1", "created": "Thu, 30 Apr 2015 20:19:11 GMT"}], "update_date": "2015-05-04", "authors_parsed": [["Zolotov", "Boris", ""]]}, {"id": "1505.00061", "submitter": "Marcus Ramos", "authors": "Marcus Vin\\'icius Midena Ramos, Ruy J. G. B. de Queiroz", "title": "Context-Free Language Theory Formalization", "comments": "52 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Proof assistants are software-based tools that are used in the mechanization\nof proof construction and validation in mathematics and computer science, and\nalso in certified program development. Different tools are being increasingly\nused in order to accelerate and simplify proof checking. Context-free language\ntheory is a well-established area of mathematics, relevant to computer science\nfoundations and technology. This proposal aims at formalizing parts of\ncontext-free language theory in the Coq proof assistant. This report presents\nthe underlying theory and general characteristics of proof assistants,\nincluding Coq itself, discusses its use in relevant formalization projects,\npresents the current status of the implementation, addresses related projects\nand the contributions of this work. The results obtained so far include the\nformalization of closure properties for context-free grammars (under union,\nconcatenation and closure) and the formalization of grammar simplification.\nGrammar simplification is a subject of high importance in computer language\nprocessing technology as well as in formal language theory, and the\nformalization refers to the fact that general context-free grammars generate\nlanguages that can be also generated by simpler and equivalent context-free\ngrammars. Namely, useless symbol elimination, inaccessible symbol elimination,\nunit rules elimination and empty rules elimination operations were described\nand proven correct with respect to the preservation of the language generated\nby the original grammar.\n", "versions": [{"version": "v1", "created": "Fri, 1 May 2015 00:27:18 GMT"}], "update_date": "2015-05-04", "authors_parsed": [["Ramos", "Marcus Vin\u00edcius Midena", ""], ["de Queiroz", "Ruy J. G. B.", ""]]}, {"id": "1505.01662", "submitter": "Lawrence C. Paulson", "authors": "Lawrence C. Paulson", "title": "A Formalisation of Finite Automata using Hereditarily Finite Sets", "comments": "Accepted to CADE-25 (International Conference on Automated\n  Deduction), Berlin, August 2015", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hereditarily finite (HF) set theory provides a standard universe of sets, but\nwith no infinite sets. Its utility is demonstrated through a formalisation of\nthe theory of regular languages and finite automata, including the\nMyhill-Nerode theorem and Brzozowski's minimisation algorithm. The states of an\nautomaton are HF sets, possibly constructed by product, sum, powerset and\nsimilar operations.\n", "versions": [{"version": "v1", "created": "Thu, 7 May 2015 10:58:02 GMT"}], "update_date": "2015-05-08", "authors_parsed": [["Paulson", "Lawrence C.", ""]]}, {"id": "1505.01695", "submitter": "Barbara K\\\"onig", "authors": "H.J. Sander Bruggink and Barbara K\\\"onig and Dennis Nolte and Hans\n  Zantema", "title": "Proving Termination of Graph Transformation Systems using Weighted Type\n  Graphs over Semirings", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce techniques for proving uniform termination of graph\ntransformation systems, based on matrix interpretations for string rewriting.\nWe generalize this technique by adapting it to graph rewriting instead of\nstring rewriting and by generalizing to ordered semirings. In this way we\nobtain a framework which includes the tropical and arctic type graphs\nintroduced in a previous paper and a new variant of arithmetic type graphs.\nThese type graphs can be used to assign weights to graphs and to show that\nthese weights decrease in every rewriting step in order to prove termination.\nWe present an example involving counters and discuss the implementation in the\ntool Grez.\n", "versions": [{"version": "v1", "created": "Thu, 7 May 2015 13:25:26 GMT"}, {"version": "v2", "created": "Fri, 8 May 2015 08:07:01 GMT"}], "update_date": "2015-05-11", "authors_parsed": [["Bruggink", "H. J. Sander", ""], ["K\u00f6nig", "Barbara", ""], ["Nolte", "Dennis", ""], ["Zantema", "Hans", ""]]}, {"id": "1505.03343", "submitter": "Ryoma Sin'ya", "authors": "Ryoma Sin'ya", "title": "Zero-One Law for Regular Languages and Semigroups with Zero", "comments": "See more recent paper arXiv:1509.07209", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A regular language has the zero-one law if its asymptotic density converges\nto either zero or one. We prove that the class of all zero-one languages is\nclosed under Boolean operations and quotients. Moreover, we prove that a\nregular language has the zero-one law if and only if its syntactic monoid has a\nzero element. Our proof gives both algebraic and automata characterisation of\nthe zero-one law for regular languages, and it leads the following two\ncorollaries: (i) There is an O(n log n) algorithm for testing whether a given\nregular language has the zero-one law. (ii) The Boolean closure of existential\nfirst-order logic over finite words has the zero-one law.\n", "versions": [{"version": "v1", "created": "Wed, 13 May 2015 11:55:03 GMT"}, {"version": "v2", "created": "Thu, 14 May 2015 20:21:00 GMT"}, {"version": "v3", "created": "Tue, 1 Dec 2015 22:47:20 GMT"}], "update_date": "2015-12-03", "authors_parsed": [["Sin'ya", "Ryoma", ""]]}, {"id": "1505.03474", "submitter": "Ludovic Mignot", "authors": "Pascal Caron, Jean-Gabriel Luque, Ludovic Mignot and Bruno Patrou", "title": "State complexity of catenation combined with a boolean operation: a\n  unified approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we study the state complexity of catenation combined with\nsymmetric difference. First, an upper bound is computed using some combinatoric\ntools. Then, this bound is shown to be tight by giving a witness for it.\nMoreover, we relate this work with the study of state complexity for two other\ncombinations: catenation with union and catenation with intersection. And we\nextract a unified approach which allows to obtain the state complexity of any\ncombination involving catenation and a binary boolean operation.\n", "versions": [{"version": "v1", "created": "Wed, 13 May 2015 17:51:36 GMT"}], "update_date": "2015-05-14", "authors_parsed": [["Caron", "Pascal", ""], ["Luque", "Jean-Gabriel", ""], ["Mignot", "Ludovic", ""], ["Patrou", "Bruno", ""]]}, {"id": "1505.03587", "submitter": "Bj{\\o}rn Kjos-Hanssen", "authors": "Malihe Alikhani, Bj{\\o}rn Kjos-Hanssen, Amirarsalan Pakravan, and\n  Babak Saadat", "title": "Pricing complexity options", "comments": null, "journal-ref": "Algorithmic Finance (2015), 4:3-4, 127-137", "doi": "10.3233/AF-150050", "report-no": null, "categories": "q-fin.PR cs.CC cs.FL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider options that pay the complexity deficiency of a sequence of up\nand down ticks of a stock upon exercise. We study the price of European and\nAmerican versions of this option numerically for automatic complexity, and\ntheoretically for Kolmogorov complexity. We also consider run complexity, which\nis a restricted form of automatic complexity.\n", "versions": [{"version": "v1", "created": "Thu, 14 May 2015 01:01:51 GMT"}, {"version": "v2", "created": "Thu, 31 Mar 2016 01:00:43 GMT"}], "update_date": "2016-04-01", "authors_parsed": [["Alikhani", "Malihe", ""], ["Kjos-Hanssen", "Bj\u00f8rn", ""], ["Pakravan", "Amirarsalan", ""], ["Saadat", "Babak", ""]]}, {"id": "1505.03852", "submitter": "Olivier Serre", "authors": "Arnaud Carayol, Axel Haddad, Olivier Serre", "title": "Counting Branches in Trees Using Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study finite automata running over infinite binary trees. A run of such an\nautomaton is usually said to be accepting if all its branches are accepting. In\nthis article, we relax the notion of accepting run by allowing a certain\nquantity of rejecting branches.\n  More precisely we study the following criteria for a run to be accepting: -\nit contains at most finitely (resp countably) many rejecting branches; - it\ncontains infinitely (resp uncountably) many accepting branches; - the set of\naccepting branches is topologically \"big\".\n  In all situations we provide a simple acceptance game that later permits to\nprove that the languages accepted by automata with cardinality constraints are\nalways $\\omega$-regular. In the case (ii) where one counts accepting branches\nit leads to new proofs (without appealing to logic) of an old result of\nBeauquier and Niwinski.\n", "versions": [{"version": "v1", "created": "Thu, 14 May 2015 19:48:57 GMT"}], "update_date": "2015-05-15", "authors_parsed": [["Carayol", "Arnaud", ""], ["Haddad", "Axel", ""], ["Serre", "Olivier", ""]]}, {"id": "1505.03931", "submitter": "James Lathrop", "authors": "Titus H. Klinge, James I. Lathrop, Jack H. Lutz", "title": "Robust Biomolecular Finite Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.ET cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a uniform method for translating an arbitrary nondeterministic\nfinite automaton (NFA) into a deterministic mass action input/output chemical\nreaction network (I/O CRN) that simulates it. The I/O CRN receives its input as\na continuous time signal consisting of concentrations of chemical species that\nvary to represent the NFA's input string in a natural way. The I/O CRN exploits\nthe inherent parallelism of chemical kinetics to simulate the NFA in real time\nwith a number of chemical species that is linear in the size of the NFA. We\nprove that the simulation is correct and that it is robust with respect to\nperturbations of the input signal, the initial concentrations of species, the\noutput (decision), and the rate constants of the reactions of the I/O CRN.\n", "versions": [{"version": "v1", "created": "Fri, 15 May 2015 00:52:08 GMT"}, {"version": "v2", "created": "Wed, 26 Dec 2018 16:16:53 GMT"}], "update_date": "2018-12-27", "authors_parsed": [["Klinge", "Titus H.", ""], ["Lathrop", "James I.", ""], ["Lutz", "Jack H.", ""]]}, {"id": "1505.03953", "submitter": "Susmit Jha", "authors": "Susmit Jha, Sanjit A. Seshia", "title": "A Theory of Formal Synthesis via Inductive Learning", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Formal synthesis is the process of generating a program satisfying a\nhigh-level formal specification. In recent times, effective formal synthesis\nmethods have been proposed based on the use of inductive learning. We refer to\nthis class of methods that learn programs from examples as formal inductive\nsynthesis. In this paper, we present a theoretical framework for formal\ninductive synthesis. We discuss how formal inductive synthesis differs from\ntraditional machine learning. We then describe oracle-guided inductive\nsynthesis (OGIS), a framework that captures a family of synthesizers that\noperate by iteratively querying an oracle. An instance of OGIS that has had\nmuch practical impact is counterexample-guided inductive synthesis (CEGIS). We\npresent a theoretical characterization of CEGIS for learning any program that\ncomputes a recursive language. In particular, we analyze the relative power of\nCEGIS variants where the types of counterexamples generated by the oracle\nvaries. We also consider the impact of bounded versus unbounded memory\navailable to the learning algorithm. In the special case where the universe of\ncandidate programs is finite, we relate the speed of convergence to the notion\nof teaching dimension studied in machine learning theory. Altogether, the\nresults of the paper take a first step towards a theoretical foundation for the\nemerging field of formal inductive synthesis.\n", "versions": [{"version": "v1", "created": "Fri, 15 May 2015 03:47:18 GMT"}, {"version": "v2", "created": "Thu, 25 Jun 2015 14:13:04 GMT"}, {"version": "v3", "created": "Sun, 8 Nov 2015 01:21:36 GMT"}, {"version": "v4", "created": "Sat, 21 May 2016 07:41:54 GMT"}], "update_date": "2016-05-24", "authors_parsed": [["Jha", "Susmit", ""], ["Seshia", "Sanjit A.", ""]]}, {"id": "1505.04409", "submitter": "Abhishek Udupa", "authors": "Rajeev Alur, Mukund Raghothaman, Christos Stergiou, Stavros Tripakis\n  and Abhishek Udupa", "title": "Automatic Completion of Distributed Protocols with Symmetry", "comments": "Full version of paper presented at CAV 2015", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A distributed protocol is typically modeled as a set of communicating\nprocesses, where each process is described as an extended state machine along\nwith fairness assumptions, and its correctness is specified using safety and\nliveness requirements. Designing correct distributed protocols is a challenging\ntask. Aimed at simplifying this task, we allow the designer to leave some of\nthe guards and updates to state variables in the description of extended state\nmachines as unknown functions. The protocol completion problem then is to find\ninterpretations for these unknown functions while guaranteeing correctness. In\nmany distributed protocols, process behaviors are naturally symmetric, and\nthus, synthesized expressions are further required to obey symmetry\nconstraints. Our counterexample-guided synthesis algorithm consists of\nrepeatedly invoking two phases. In the first phase, candidates for unknown\nexpressions are generated using the SMT solver Z3. This phase requires\ncarefully orchestrating constraints to enforce the desired symmetry in\nread/write accesses. In the second phase, the resulting completed protocol is\nchecked for correctness using a custom-built model checker that handles\nfairness assumptions, safety and liveness requirements, and exploits symmetry.\nWhen model checking fails, our tool examines a set of counterexamples to\nsafety/liveness properties to generate constraints on unknown functions that\nmust be satisfied by subsequent completions. For evaluation, we show that our\nprototype is able to automatically discover interesting missing details in\ndistributed protocols for mutual exclusion, self stabilization, and cache\ncoherence.\n", "versions": [{"version": "v1", "created": "Sun, 17 May 2015 15:47:49 GMT"}], "update_date": "2015-05-19", "authors_parsed": [["Alur", "Rajeev", ""], ["Raghothaman", "Mukund", ""], ["Stergiou", "Christos", ""], ["Tripakis", "Stavros", ""], ["Udupa", "Abhishek", ""]]}, {"id": "1505.06376", "submitter": "Olivier Hermant", "authors": "Richard Bonichon (DIMAP - UFRN), Olivier Hermant", "title": "A syntactic soundness proof for free-variable tableaux with on-the-fly\n  Skolemization", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove the syntactic soundness of classical tableaux with free variables\nand on-the-fly Skolemization. Soundness proofs are usually built from semantic\narguments, and this is to our knowledge, the first proof that appeals to\nsyntactic means. We actually prove the soundness property with respect to\ncut-free sequent calculus. This requires great care because of the additional\nliberty in freshness checking allowed by the use of Skolem terms. In contrast\nto semantic soundness, we gain the possibility to state a cut elimination\ntheorem for sequent calculus, under the proviso that completeness of the method\nholds. We believe that such techniques can be applied to tableaux in other\nlogics as well.\n", "versions": [{"version": "v1", "created": "Sat, 23 May 2015 20:24:21 GMT"}], "update_date": "2015-05-26", "authors_parsed": [["Bonichon", "Richard", "", "DIMAP - UFRN"], ["Hermant", "Olivier", ""]]}, {"id": "1505.06508", "submitter": "Scott Garrabrant", "authors": "Scott Garrabrant and Igor Pak", "title": "Pattern avoidance is not P-recursive", "comments": "19 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let $F \\subset S_k$ be a finite set of permutations and let $C_n(F)$ denote\nthe number of permutations $\\sigma$ in $S_n$ avoiding the set of patterns $F$.\nThe Noonan-Zeilberger conjecture states that the sequence ${C_n(F)}$ is\nP-recursive. We use Computability Theory to disprove this conjecture.\n", "versions": [{"version": "v1", "created": "Mon, 25 May 2015 01:11:09 GMT"}], "update_date": "2015-05-26", "authors_parsed": [["Garrabrant", "Scott", ""], ["Pak", "Igor", ""]]}, {"id": "1505.06588", "submitter": "Pierre Ganty", "authors": "Antoine Durand-Gasselin, Javier Esparza, Pierre Ganty, Rupak Majumdar", "title": "Model Checking Parameterized Asynchronous Shared-Memory Systems", "comments": "27 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We characterize the complexity of liveness verification for parameterized\nsystems consisting of a leader process and arbitrarily many anonymous and\nidentical contributor processes. Processes communicate through a shared,\nbounded-value register. While each operation on the register is atomic, there\nis no synchronization primitive to execute a sequence of operations atomically.\n  We analyze the case in which processes are modeled by finite-state machines\nor pushdown machines and the property is given by a B\\\"uchi automaton over the\nalphabet of read and write actions of the leader. We show that the problem is\ndecidable, and has a surprisingly low complexity: it is NP-complete when all\nprocesses are finite-state machines, and is PSPACE-hard and in NEXPTIME when\nthey are pushdown machines. This complexity is lower than for the\nnon-parameterized case: liveness verification of finitely many finite-state\nmachines is PSPACE-complete, and undecidable for two pushdown machines.\n  For finite-state machines, our proofs characterize infinite behaviors using\nexistential abstraction and semilinear constraints. For pushdown machines, we\nshow how contributor computations of high stack height can be simulated by\ncomputations of many contributors, each with low stack height. Together, our\nresults characterize the complexity of verification for parameterized systems\nunder the assumptions of anonymity and asynchrony.\n", "versions": [{"version": "v1", "created": "Mon, 25 May 2015 10:17:26 GMT"}], "update_date": "2015-05-26", "authors_parsed": [["Durand-Gasselin", "Antoine", ""], ["Esparza", "Javier", ""], ["Ganty", "Pierre", ""], ["Majumdar", "Rupak", ""]]}, {"id": "1505.06953", "submitter": "Martin Zimmermann", "authors": "Martin Zimmermann", "title": "Parameterized Linear Temporal Logics Meet Costs: Still not Costlier than\n  LTL (full version)", "comments": "A short version appears in Proceedings of GandALF 2015", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We continue the investigation of parameterized extensions of Linear Temporal\nLogic (LTL) that retain the attractive algorithmic properties of LTL: a\npolynomial space model checking algorithm and a doubly-exponential time\nalgorithm for solving games. Alur et al. and Kupferman et al. showed that this\nis the case for Parametric LTL (PLTL) and PROMPT-LTL respectively, which have\ntemporal operators equipped with variables that bound their scope in time.\nLater, this was also shown to be true for Parametric LDL (PLDL), which extends\nPLTL to be able to express all omega-regular properties.\n  Here, we generalize PLTL to systems with costs, i.e., we do not bound the\nscope of operators in time, but bound the scope in terms of the cost\naccumulated during time. Again, we show that model checking and solving games\nfor specifications in PLTL with costs is not harder than the corresponding\nproblems for LTL. Finally, we discuss PLDL with costs and extensions to\nmultiple cost functions.\n", "versions": [{"version": "v1", "created": "Tue, 26 May 2015 13:55:46 GMT"}, {"version": "v2", "created": "Wed, 8 Jul 2015 08:11:01 GMT"}, {"version": "v3", "created": "Tue, 14 Jul 2015 06:46:13 GMT"}, {"version": "v4", "created": "Mon, 17 Aug 2015 07:43:50 GMT"}, {"version": "v5", "created": "Thu, 14 Jan 2016 14:09:18 GMT"}], "update_date": "2016-01-15", "authors_parsed": [["Zimmermann", "Martin", ""]]}, {"id": "1505.08043", "submitter": "Arseny Shur", "authors": "Mikhail Rubinchik and Arseny M. Shur", "title": "The Number of Distinct Subpalindromes in Random Words", "comments": "14 pages, 1 figure; submitted to FI (Special issue of RuFiDiM 2014)", "journal-ref": null, "doi": "10.3233/FI-2016-1366", "report-no": null, "categories": "math.CO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that a random word of length $n$ over a $k$-ary fixed alphabet\ncontains, on expectation, $\\Theta(\\sqrt{n})$ distinct palindromic factors. We\nstudy this number of factors, $E(n,k)$, in detail, showing that the limit\n$\\lim_{n\\to\\infty}E(n,k)/\\sqrt{n}$ does not exist for any $k\\ge2$,\n$\\liminf_{n\\to\\infty}E(n,k)/\\sqrt{n}=\\Theta(1)$, and\n$\\limsup_{n\\to\\infty}E(n,k)/\\sqrt{n}=\\Theta(\\sqrt{k})$. Such a complicated\nbehaviour stems from the asymmetry between the palindromes of even and odd\nlength. We show that a similar, but much simpler, result on the expected number\nof squares in random words holds. We also provide some experimental data on the\nnumber of palindromic factors in random words.\n", "versions": [{"version": "v1", "created": "Fri, 29 May 2015 13:47:14 GMT"}], "update_date": "2016-09-13", "authors_parsed": [["Rubinchik", "Mikhail", ""], ["Shur", "Arseny M.", ""]]}]