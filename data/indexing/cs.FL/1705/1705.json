[{"id": "1705.00355", "submitter": "Sebastian Muskalla", "authors": "Matthew Hague, Roland Meyer, Sebastian Muskalla", "title": "Domains for Higher-Order Games", "comments": "Conference version accepted for presentation and publication at the\n  42nd International Symposium on Mathematical Foundations of Computer Science\n  (MFCS 2017)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study two-player inclusion games played over word-generating higher-order\nrecursion schemes. While inclusion checks are known to capture verification\nproblems, two-player games generalize this relationship to program synthesis.\nIn such games, non-terminals of the grammar are controlled by opposing players.\nThe goal of the existential player is to avoid producing a word that lies\noutside of a regular language of safe words.\n  We contribute a new domain that provides a representation of the winning\nregion of such games. Our domain is based on (functions over) potentially\ninfinite Boolean formulas with words as atomic propositions. We develop an\nabstract interpretation framework that we instantiate to abstract this domain\ninto a domain where the propositions are replaced by states of a finite\nautomaton. This second domain is therefore finite and we obtain, via standard\nfixed-point techniques, a direct algorithm for the analysis of two-player\ninclusion games. We show, via a second instantiation of the framework, that our\nfinite domain can be optimized, leading to a (k+1)EXP algorithm for order-k\nrecursion schemes. We give a matching lower bound, showing that our approach is\noptimal. Since our approach is based on standard Kleene iteration, existing\ntechniques and tools for fixed-point computations can be applied.\n", "versions": [{"version": "v1", "created": "Sun, 30 Apr 2017 18:20:19 GMT"}, {"version": "v2", "created": "Sat, 5 Aug 2017 14:17:28 GMT"}], "update_date": "2017-08-08", "authors_parsed": [["Hague", "Matthew", ""], ["Meyer", "Roland", ""], ["Muskalla", "Sebastian", ""]]}, {"id": "1705.00694", "submitter": "Stepan Kuznetsov", "authors": "Max Kanovich, Stepan Kuznetsov, Glyn Morrill, Andre Scedrov", "title": "A polynomial time algorithm for the Lambek calculus with brackets of\n  bounded order", "comments": null, "journal-ref": "Proc. FSCD 2017, LIPIcs vol. 84, 22:1-22:17", "doi": "10.4230/LIPIcs.FSCD.2017.22", "report-no": null, "categories": "cs.LO cs.CL cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Lambek calculus is a logical foundation of categorial grammar, a linguistic\nparadigm of grammar as logic and parsing as deduction. Pentus (2010) gave a\npolynomial-time algorithm for determ- ining provability of bounded depth\nformulas in the Lambek calculus with empty antecedents allowed. Pentus'\nalgorithm is based on tabularisation of proof nets. Lambek calculus with\nbrackets is a conservative extension of Lambek calculus with bracket\nmodalities, suitable for the modeling of syntactical domains. In this paper we\ngive an algorithm for provability the Lambek calculus with brackets allowing\nempty antecedents. Our algorithm runs in polynomial time when both the formula\ndepth and the bracket nesting depth are bounded. It combines a Pentus-style\ntabularisation of proof nets with an automata-theoretic treatment of\nbracketing.\n", "versions": [{"version": "v1", "created": "Mon, 1 May 2017 20:12:11 GMT"}, {"version": "v2", "created": "Mon, 18 Dec 2017 10:39:22 GMT"}], "update_date": "2017-12-19", "authors_parsed": [["Kanovich", "Max", ""], ["Kuznetsov", "Stepan", ""], ["Morrill", "Glyn", ""], ["Scedrov", "Andre", ""]]}, {"id": "1705.00984", "submitter": "Matteo Pradella", "authors": "Dino Mandrioli, Matteo Pradella", "title": "Generalizing input-driven languages: theoretical and practical benefits", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Regular languages (RL) are the simplest family in Chomsky's hierarchy. Thanks\nto their simplicity they enjoy various nice algebraic and logic properties that\nhave been successfully exploited in many application fields. Practically all of\ntheir related problems are decidable, so that they support automatic\nverification algorithms. Also, they can be recognized in real-time.\n  Context-free languages (CFL) are another major family well-suited to\nformalize programming, natural, and many other classes of languages; their\nincreased generative power w.r.t. RL, however, causes the loss of several\nclosure properties and of the decidability of important problems; furthermore\nthey need complex parsing algorithms. Thus, various subclasses thereof have\nbeen defined with different goals, spanning from efficient, deterministic\nparsing to closure properties, logic characterization and automatic\nverification techniques.\n  Among CFL subclasses, so-called structured ones, i.e., those where the\ntypical tree-structure is visible in the sentences, exhibit many of the\nalgebraic and logic properties of RL, whereas deterministic CFL have been\nthoroughly exploited in compiler construction and other application fields.\n  After surveying and comparing the main properties of those various language\nfamilies, we go back to operator precedence languages (OPL), an old family\nthrough which R. Floyd pioneered deterministic parsing, and we show that they\noffer unexpected properties in two fields so far investigated in totally\nindependent ways: they enable parsing parallelization in a more effective way\nthan traditional sequential parsers, and exhibit the same algebraic and logic\nproperties so far obtained only for less expressive language families.\n", "versions": [{"version": "v1", "created": "Tue, 2 May 2017 14:09:28 GMT"}], "update_date": "2017-05-03", "authors_parsed": [["Mandrioli", "Dino", ""], ["Pradella", "Matteo", ""]]}, {"id": "1705.01773", "submitter": "Maksims Dimitrijevs", "authors": "Maksims Dimitrijevs, Abuzer Yakary{\\i}lmaz", "title": "Uncountable realtime probabilistic classes", "comments": "12 pages. Accepted to DCFS2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the minimum cases for realtime probabilistic machines that can\ndefine uncountably many languages with bounded error. We show that logarithmic\nspace is enough for realtime PTMs on unary languages. On binary case, we follow\nthe same result for double logarithmic space, which is tight. When replacing\nthe worktape with some limited memories, we can follow uncountable results on\nunary languages for two counters.\n", "versions": [{"version": "v1", "created": "Thu, 4 May 2017 10:08:06 GMT"}], "update_date": "2017-05-05", "authors_parsed": [["Dimitrijevs", "Maksims", ""], ["Yakary\u0131lmaz", "Abuzer", ""]]}, {"id": "1705.02313", "submitter": "John Fearnley", "authors": "John Fearnley", "title": "Efficient Parallel Strategy Improvement for Parity Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study strategy improvement algorithms for solving parity games. While\nthese algorithms are known to solve parity games using a very small number of\niterations, experimental studies have found that a high step complexity causes\nthem to perform poorly in practice. In this paper we seek to address this\nsituation. Every iteration of the algorithm must compute a best response, and\nwhile the standard way of doing this uses the Bellman-Ford algorithm, we give\nexperimental results that show that one-player strategy improvement\nsignificantly outperforms this technique in practice. We then study the best\nway to implement one-player strategy improvement, and we develop an efficient\nparallel algorithm for carrying out this task, by reducing the problem to\ncomputing prefix sums on a linked list. We report experimental results for\nthese algorithms, and we find that a GPU implementation of this algorithm shows\na significant speedup over single-core and multi-core CPU implementations.\n", "versions": [{"version": "v1", "created": "Fri, 5 May 2017 17:29:25 GMT"}], "update_date": "2017-05-08", "authors_parsed": [["Fearnley", "John", ""]]}, {"id": "1705.02609", "submitter": "EPTCS", "authors": "Antti Kuusisto, Fabian Reiter", "title": "Emptiness Problems for Distributed Automata", "comments": "In Proceedings GandALF 2017, arXiv:1709.01761. 13 pages, 2 figures", "journal-ref": "EPTCS 256, 2017, pp. 210-222", "doi": "10.4204/EPTCS.256.15", "report-no": null, "categories": "cs.FL cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the decidability of the emptiness problem for three classes of\ndistributed automata. These devices operate on finite directed graphs, acting\nas networks of identical finite-state machines that communicate in an infinite\nsequence of synchronous rounds. The problem is shown to be decidable in\nLogSpace for a class of forgetful automata, where the nodes see the messages\nreceived from their neighbors but cannot remember their own state. When\nrestricted to the appropriate families of graphs, these forgetful automata are\nequivalent to classical finite word automata, but strictly more expressive than\nfinite tree automata. On the other hand, we also show that the emptiness\nproblem is undecidable in general. This already holds for two heavily\nrestricted classes of distributed automata: those that reject immediately if\nthey receive more than one message per round, and those whose state diagram\nmust be acyclic except for self-loops.\n", "versions": [{"version": "v1", "created": "Sun, 7 May 2017 12:45:27 GMT"}, {"version": "v2", "created": "Thu, 7 Sep 2017 06:58:50 GMT"}], "update_date": "2017-09-08", "authors_parsed": [["Kuusisto", "Antti", ""], ["Reiter", "Fabian", ""]]}, {"id": "1705.02809", "submitter": "Michal Ferov", "authors": "Laura Ciobanu and Murray Elder and Michal Ferov", "title": "Applications of L systems to group theory", "comments": "Revised following referees suggestions. 21 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  L systems generalise context-free grammars by incorporating parallel\nrewriting, and generate languages such as EDT0L and ET0L that are strictly\ncontained in the class of indexed languages. In this paper we show that many of\nthe languages naturally appearing in group theory, and that were known to be\nindexed or context-sensitive, are in fact ET0L and in many cases EDT0L. For\ninstance, the language of primitives in the free group on two generators, the\nBridson-Gilman normal forms for the fundamental groups of 3-manifolds or\norbifolds, and the co-word problem of Grigorchuk's group can be generated by L\nsystems. To complement the result on primitives in free groups, we show that\nthe language of primitives, and primitive sets, in free groups of rank higher\nthan two is context-sensitive. We also show the existence of EDT0L and ET0L\nlanguages of intermediate growth.\n", "versions": [{"version": "v1", "created": "Mon, 8 May 2017 10:13:45 GMT"}, {"version": "v2", "created": "Thu, 1 Feb 2018 22:56:38 GMT"}], "update_date": "2018-02-05", "authors_parsed": [["Ciobanu", "Laura", ""], ["Elder", "Murray", ""], ["Ferov", "Michal", ""]]}, {"id": "1705.02813", "submitter": "\\v{S}t\\v{e}p\\'an Holub", "authors": "\\v{S}t\\v{e}p\\'an Holub, Tom\\'a\\v{s} Masopust, Micha\\\"el Thomazo", "title": "On the Height of Towers of Subsequences and Prefixes", "comments": null, "journal-ref": "Information and Computation 265 (2019) 77-93", "doi": "10.1016/j.ic.2019.01.004", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A tower is a sequence of words alternating between two languages in such a\nway that every word is a subsequence of the following word. The height of the\ntower is the number of words in the sequence. If there is no infinite tower (a\ntower of infinite height), then the height of all towers between the languages\nis bounded. We study upper and lower bounds on the height of maximal finite\ntowers with respect to the size of the NFA (the DFA) representation of the\nlanguages. We show that the upper bound is polynomial in the number of states\nand exponential in the size of the alphabet, and that it is asymptotically\ntight if the size of the alphabet is fixed. If the alphabet may grow, then,\nusing an alphabet of size approximately the number of states of the automata,\nthe lower bound on the height of towers is exponential with respect to that\nnumber. In this case, there is a gap between the lower and upper bound, and the\nasymptotically optimal bound remains an open problem. Since, in many cases, the\nconstructed towers are sequences of prefixes, we also study towers of prefixes.\n", "versions": [{"version": "v1", "created": "Mon, 8 May 2017 10:37:10 GMT"}], "update_date": "2019-12-18", "authors_parsed": [["Holub", "\u0160t\u011bp\u00e1n", ""], ["Masopust", "Tom\u00e1\u0161", ""], ["Thomazo", "Micha\u00ebl", ""]]}, {"id": "1705.02850", "submitter": "Joshua Moerman", "authors": "Joshua Moerman", "title": "Learning Product Automata", "comments": "Submitted to LearnAut 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we give an optimization for active learning algorithms,\napplicable to learning Moore machines where the output comprises several\nobservables. These machines can be decomposed themselves by projecting on each\nobservable, resulting in smaller components. These components can then be\nlearnt with fewer queries. This is in particular interesting for learning\nsoftware, where compositional methods are important for guaranteeing\nscalability.\n", "versions": [{"version": "v1", "created": "Mon, 8 May 2017 12:56:57 GMT"}], "update_date": "2017-05-09", "authors_parsed": [["Moerman", "Joshua", ""]]}, {"id": "1705.03726", "submitter": "Nathan Lhote", "authors": "Emmanuel Filiot, Olivier Gauwin and Nathan Lhote", "title": "Logical and Algebraic Characterizations of Rational Transductions", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 4 (December\n  19, 2019) lmcs:5988", "doi": "10.23638/LMCS-15(4:16)2019", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Rational word languages can be defined by several equivalent means: finite\nstate automata, rational expressions, finite congruences, or monadic\nsecond-order (MSO) logic. The robust subclass of aperiodic languages is defined\nby: counter-free automata, star-free expressions, aperiodic (finite)\ncongruences, or first-order (FO) logic. In particular, their algebraic\ncharacterization by aperiodic congruences allows to decide whether a regular\nlanguage is aperiodic.\n  We lift this decidability result to rational transductions, i.e.,\nword-to-word functions defined by finite state transducers. In this context,\nlogical and algebraic characterizations have also been proposed. Our main\nresult is that one can decide if a rational transduction (given as a\ntransducer) is in a given decidable congruence class. We also establish a\ntransfer result from logic-algebra equivalences over languages to equivalences\nover transductions. As a consequence, it is decidable if a rational\ntransduction is first-order definable, and we show that this problem is\nPSPACE-complete.\n", "versions": [{"version": "v1", "created": "Wed, 10 May 2017 12:32:07 GMT"}, {"version": "v2", "created": "Fri, 12 May 2017 12:14:49 GMT"}, {"version": "v3", "created": "Tue, 23 Oct 2018 15:51:17 GMT"}, {"version": "v4", "created": "Mon, 14 Oct 2019 13:50:58 GMT"}, {"version": "v5", "created": "Wed, 18 Dec 2019 10:33:13 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Filiot", "Emmanuel", ""], ["Gauwin", "Olivier", ""], ["Lhote", "Nathan", ""]]}, {"id": "1705.04055", "submitter": "Jean Neraud", "authors": "Jean N\\'eraud (LITIS)", "title": "Ten Conferences WORDS: Open Problems and Conjectures", "comments": null, "journal-ref": null, "doi": "10.13140/RG.2.1.4425.1768/1", "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In connection to the development of the field of Combinatorics on Words, we\npresent a list of open problems and conjectures that were stated during the ten\nlast meetings WORDS. We wish to continually update the present document by\nadding informations concerning advances in problems solving.\n", "versions": [{"version": "v1", "created": "Thu, 11 May 2017 07:55:31 GMT"}], "update_date": "2017-05-12", "authors_parsed": [["N\u00e9raud", "Jean", "", "LITIS"]]}, {"id": "1705.05606", "submitter": "Radu Iosif", "authors": "Radu Iosif and Xiao Xu", "title": "The Impact of Alternation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Alternating automata have been widely used to model and verify systems that\nhandle data from finite domains, such as communication protocols or hardware.\nThe main advantage of the alternating model of computation is that\ncomplementation is possible in linear time, thus allowing to concisely encode\ntrace inclusion problems that occur often in verification. In this paper we\nconsider alternating automata over infinite alphabets, whose transition rules\nare formulae in a combined theory of booleans and some infinite data domain,\nthat relate past and current values of the data variables. The data theory is\nnot fixed, but rather it is a parameter of the class. We show that union,\nintersection and complementation are possible in linear time in this model and,\nthough the emptiness problem is undecidable, we provide two efficient\nsemi-algorithms, inspired by two state-of-the-art abstraction refinement model\nchecking methods: lazy predicate abstraction \\cite{HJMS02} and the \\impact~\nsemi-algorithm \\cite{mcmillan06}. We have implemented both methods and report\nthe results of an experimental comparison.\n", "versions": [{"version": "v1", "created": "Tue, 16 May 2017 09:17:56 GMT"}, {"version": "v2", "created": "Wed, 16 Aug 2017 09:29:37 GMT"}], "update_date": "2017-08-17", "authors_parsed": [["Iosif", "Radu", ""], ["Xu", "Xiao", ""]]}, {"id": "1705.05786", "submitter": "Gwena\\\"el Richomme", "authors": "Gwena\\\"el Richomme", "title": "A Characterization of Infinite LSP Words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  G. Fici proved that a finite word has a minimal suffix automaton if and only\nif all its left special factors occur as prefixes. He called LSP all finite and\ninfinite words having this latter property. We characterize here infinite LSP\nwords in terms of $S$-adicity. More precisely we provide a finite set of\nmorphisms $S$ and an automaton ${\\cal A}$ such that an infinite word is LSP if\nand only if it is $S$-adic and all its directive words are recognizable by\n${\\cal A}$.\n", "versions": [{"version": "v1", "created": "Tue, 16 May 2017 16:08:06 GMT"}], "update_date": "2017-05-17", "authors_parsed": [["Richomme", "Gwena\u00ebl", ""]]}, {"id": "1705.05832", "submitter": "Abdulrahman Elnekiti", "authors": "Abdulrhman Elnekiti", "title": "New Directions In Cellular Automata", "comments": "Pre-print submission to Complex Systems journal", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL nlin.CG", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We Propose A Novel Automaton Model which uses Arithmetic Operations as the\nEvolving Rules, each cell has the states of the Natural Numbers k = (N), a\nradius of r = 1/2 and operates on an arbitrary input size. The Automaton reads\nan Arithmetic Expression as an input and outputs another Arithmetic Expression.\nIn Addition, we simulate a variety of One Dimensional Cellular Automata\nStructures with different Dynamics including Elementary Cellular Automata.\n", "versions": [{"version": "v1", "created": "Wed, 17 May 2017 01:46:21 GMT"}], "update_date": "2017-05-18", "authors_parsed": [["Elnekiti", "Abdulrhman", ""]]}, {"id": "1705.05896", "submitter": "Michael Laurence", "authors": "Michael R Laurence, Georg Struth", "title": "Completeness Theorems for Pomset Languages and Concurrent Kleene\n  Algebras", "comments": "35 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Pomsets constitute one of the most basic models of concurrency. A pomset is a\ngeneralisation of a word over an alphabet in that letters may be partially\nordered. A term $t$ using the bi-Kleene operations $0,1, +, \\cdot\\, ,^*,\n\\parallel, ^{(*)}$ defines a language $ \\mathopen{[\\![ } t \\mathclose{]\\!] } $\nof pomsets in a natural way.\n  We prove that every valid universal equality over pomset languages using\nthese operations is a consequence of the equational theory of regular languages\n(in which parallel multiplication and iteration are undefined) plus that of the\ncommutative-regular languages (in which sequential multiplication and iteration\nare undefined). We also show that the class of $\\textit{rational}$ pomset\nlanguages (that is, those languages generated from singleton pomsets using the\nbi-Kleene operations) is closed under all Boolean operations.\n  An $ \\textit{ideal}$ of a pomset $p$ is a pomset using the letters of $p$,\nbut having an ordering at least as strict as $p$. A bi-Kleene term $t$ thus\ndefines the set $ \\textbf{Id} (\\mathopen{[\\![ } t \\mathclose{]\\!] }) $ of\nideals of pomsets in $ \\mathopen{[\\![ } t \\mathclose{]\\!] } $. We prove that if\n$t$ does not contain commutative iteration $^{(*)}$ (in our terminology, $t$ is\nbw-rational) then $\\textbf{Id} (\\mathopen{[\\![ } t \\mathclose{]\\!] }) \\cap\n\\textbf{Pom}_{sp}$, where $ \\textbf{Pom}_{sp}$ is the set of pomsets generated\nfrom singleton pomsets using sequential and parallel multiplication ($ \\cdot$\nand $ \\parallel$) is defined by a bw-rational term, and if two such terms\n$t,t'$ define the same ideal language, then $t'=t$ is provable from the Kleene\naxioms for $0,1, +, \\cdot\\, ,^*$ plus the commutative idempotent semiring\naxioms for $0,1, +, \\parallel$ plus the exchange law $ (u \\parallel v)\\cdot ( x\n\\parallel y) \\le v \\cdot y \\parallel u \\cdot x $.\n", "versions": [{"version": "v1", "created": "Tue, 16 May 2017 20:02:17 GMT"}], "update_date": "2017-05-18", "authors_parsed": [["Laurence", "Michael R", ""], ["Struth", "Georg", ""]]}, {"id": "1705.06681", "submitter": "Luisa Herrmann", "authors": "Zolt\\'an F\\\"ul\\\"op and Luisa Herrmann and Heiko Vogler", "title": "Weighted Regular Tree Grammars with Storage", "comments": "added errata", "journal-ref": "Discrete Mathematics & Theoretical Computer Science, Vol. 20 no.\n  1, Automata, Logic and Semantics (July 3, 2018) dmtcs:4660", "doi": "10.23638/DMTCS-20-1-26", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce weighted regular tree grammars with storage as combination of\n(a) regular tree grammars with storage and (b) weighted tree automata over\nmultioperator monoids. Each weighted regular tree grammar with storage\ngenerates a weighted tree language, which is a mapping from the set of trees to\nthe multioperator monoid. We prove that, for multioperator monoids canonically\nassociated to particular strong bi-monoids, the support of the generated\nweighted tree languages can be generated by (unweighted) regular tree grammars\nwith storage. We characterize the class of all generated weighted tree\nlanguages by the composition of three basic concepts. Moreover, we prove\nresults on the elimination of chain rules and of finite storage types, and we\ncharacterize weighted regular tree grammars with storage by a new weighted\nMSO-logic.\n", "versions": [{"version": "v1", "created": "Thu, 18 May 2017 16:34:49 GMT"}, {"version": "v2", "created": "Sat, 20 May 2017 03:47:37 GMT"}, {"version": "v3", "created": "Tue, 23 May 2017 07:36:22 GMT"}, {"version": "v4", "created": "Fri, 8 Jun 2018 16:28:28 GMT"}, {"version": "v5", "created": "Mon, 2 Jul 2018 16:36:22 GMT"}, {"version": "v6", "created": "Thu, 2 Jul 2020 19:39:52 GMT"}], "update_date": "2020-07-06", "authors_parsed": [["F\u00fcl\u00f6p", "Zolt\u00e1n", ""], ["Herrmann", "Luisa", ""], ["Vogler", "Heiko", ""]]}, {"id": "1705.07150", "submitter": "Sylvie Davies", "authors": "Sylvie Davies", "title": "State Complexity of Reversals of Deterministic Finite Automata with\n  Output", "comments": "18 pages, 3 tables. Added missing affiliation/funding information", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the worst-case state complexity of reversals of deterministic\nfinite automata with output (DFAOs). In these automata, each state is assigned\nsome output value, rather than simply being labelled final or non-final. This\ndirectly generalizes the well-studied problem of determining the worst-case\nstate complexity of reversals of ordinary deterministic finite automata. If a\nDFAO has $n$ states and $k$ possible output values, there is a known upper\nbound of $k^n$ for the state complexity of reversal. We show this bound can be\nreached with a ternary input alphabet. We conjecture it cannot be reached with\na binary input alphabet except when $k = 2$, and give a lower bound for the\ncase $3 \\le k < n$. We prove that the state complexity of reversal depends\nsolely on the transition monoid of the DFAO and the mapping that assigns output\nvalues to states.\n", "versions": [{"version": "v1", "created": "Fri, 19 May 2017 19:10:25 GMT"}, {"version": "v2", "created": "Tue, 17 Oct 2017 23:31:13 GMT"}], "update_date": "2017-10-19", "authors_parsed": [["Davies", "Sylvie", ""]]}, {"id": "1705.07520", "submitter": "Vladimir Zamdzhiev", "authors": "Vladimir Nikolaev Zamdzhiev", "title": "Rewriting Context-free Families of String Diagrams", "comments": "PhD Thesis. Successfully defended in August 2016. See PDF for full\n  abstract", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO quant-ph", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  String diagrams provide a convenient graphical framework which may be used\nfor equational reasoning about morphisms of monoidal categories. However,\nunlike term rewriting, rewriting string diagrams results in shorter equational\nproofs, because the string diagrammatic representation allows us to formally\nestablish equalities modulo any rewrite steps which follow from the monoidal\nstructure.\n  Manipulating string diagrams by hand is a time-consuming and error-prone\nprocess, especially for large string diagrams. This can be ameliorated by using\nsoftware proof assistants, such as Quantomatic.\n  However, reasoning about concrete string diagrams may be limiting and in some\nscenarios it is necessary to reason about entire (infinite) families of string\ndiagrams. When doing so, we face the same problems as for manipulating concrete\nstring diagrams, but in addition, we risk making further mistakes if we are not\nprecise enough about the way we represent (infinite) families of string\ndiagrams.\n  The primary goal of this thesis is to design a mathematical framework for\nequational reasoning about infinite families of string diagrams which is\namenable to computer automation. We will be working with context-free families\nof string diagrams and we will represent them using context-free graph\ngrammars. We will model equations between infinite families of diagrams using\nrewrite rules between context-free grammars. Our framework represents\nequational reasoning about concrete string diagrams and context-free families\nof string diagrams using double-pushout rewriting on graphs and context-free\ngraph grammars respectively. We will prove that our representation is sound by\nshowing that it respects the concrete semantics of string diagrammatic\nreasoning and we will show that our framework is appropriate for software\nimplementation by proving important decidability properties.\n", "versions": [{"version": "v1", "created": "Sun, 21 May 2017 22:48:54 GMT"}], "update_date": "2017-05-23", "authors_parsed": [["Zamdzhiev", "Vladimir Nikolaev", ""]]}, {"id": "1705.08747", "submitter": "Jarkko Peltom\\\"aki", "authors": "Jarkko Peltom\\\"aki and Ville Salo", "title": "On winning shifts of marked uniform substitutions", "comments": "Extended version of a paper presented at RuFiDiM IV", "journal-ref": "RAIRO - Theoretical Informatics and Applications, Vol. 53.1-2,\n  51-66 (2019)", "doi": "10.1051/ita/2018007", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The second author introduced with I. T\\\"orm\\\"a a two-player word-building\ngame [Playing with Subshifts, Fund. Inform. 132 (2014), 131--152]. The game has\na predetermined (possibly finite) choice sequence $\\alpha_1$, $\\alpha_2$,\n$\\ldots$ of integers such that on round $n$ the player $A$ chooses a subset\n$S_n$ of size $\\alpha_n$ of some fixed finite alphabet and the player $B$ picks\na letter from the set $S_n$. The outcome is determined by whether the word\nobtained by concatenating the letters $B$ picked lies in a prescribed target\nset $X$ (a win for player $A$) or not (a win for player $B$). Typically, we\nconsider $X$ to be a subshift. The winning shift $W(X)$ of a subshift $X$ is\ndefined as the set of choice sequences for which $A$ has a winning strategy\nwhen the target set is the language of $X$. The winning shift $W(X)$ mirrors\nsome properties of $X$. For instance, $W(X)$ and $X$ have the same entropy.\nVirtually nothing is known about the structure of the winning shifts of\nsubshifts common in combinatorics on words. In this paper, we study the winning\nshifts of subshifts generated by marked uniform substitutions, and show that\nthese winning shifts, viewed as subshifts, also have a substitutive structure.\nParticularly, we give an explicit description of the winning shift for the\ngeneralized Thue-Morse substitutions. It is known that $W(X)$ and $X$ have the\nsame factor complexity. As an example application, we exploit this connection\nto give a simple derivation of the first difference and factor complexity\nfunctions of subshifts generated by marked substitutions. We describe these\nfunctions in particular detail for the generalized Thue-Morse substitutions.\n", "versions": [{"version": "v1", "created": "Wed, 24 May 2017 13:23:17 GMT"}, {"version": "v2", "created": "Wed, 5 Sep 2018 13:54:26 GMT"}], "update_date": "2019-09-17", "authors_parsed": [["Peltom\u00e4ki", "Jarkko", ""], ["Salo", "Ville", ""]]}, {"id": "1705.08979", "submitter": "Jakub Byszewski", "authors": "Jakub Byszewski, Jakub Konieczny", "title": "Automatic sequences and generalised polynomials", "comments": "29 pages, upgraded presentation and references to existing\n  literature, an extended version of the second half of arxiv:1610.03900\n  [math.NT]", "journal-ref": "Can. J. Math.-J. Can. Math. 72 (2020) 392-426", "doi": "10.4153/S0008414X19000038", "report-no": null, "categories": "math.NT cs.FL math.CO math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We conjecture that bounded generalised polynomial functions cannot be\ngenerated by finite automata, except for the trivial case when they are\nultimately periodic.\n  Using methods from ergodic theory, we are able to partially resolve this\nconjecture, proving that any hypothetical counterexample is periodic away from\na very sparse and structured set.\n  In particular, we show that for a polynomial $p(n)$ with at least one\nirrational coefficient (except for the constant one) and integer $m\\geq 2$, the\nsequence $\\lfloor p(n) \\rfloor \\bmod{m}$ is never automatic.\n  We also prove that the conjecture is equivalent to the claim that the set of\npowers of an integer $k\\geq 2$ is not given by a generalised polynomial.\n", "versions": [{"version": "v1", "created": "Wed, 24 May 2017 22:09:11 GMT"}, {"version": "v2", "created": "Mon, 18 Dec 2017 12:03:14 GMT"}], "update_date": "2020-04-01", "authors_parsed": [["Byszewski", "Jakub", ""], ["Konieczny", "Jakub", ""]]}, {"id": "1705.09093", "submitter": "EPTCS", "authors": "Stefano Crespi Reghizzi (DEIB, Politecnico di Milano, and IEIIT,\n  Consiglio Nazionale delle Ricerche), Matteo Pradella (DEIB, Politecnico di\n  Milano, and IEIIT, Consiglio Nazionale delle Ricerche)", "title": "Higher-Order Operator Precedence Languages", "comments": "In Proceedings AFL 2017, arXiv:1708.06226", "journal-ref": "EPTCS 252, 2017, pp. 86-100", "doi": "10.4204/EPTCS.252.11", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Floyd's Operator Precedence (OP) languages are a deterministic context-free\nfamily having many desirable properties. They are locally and parallely\nparsable, and languages having a compatible structure are closed under Boolean\noperations, concatenation and star; they properly include the family of Visibly\nPushdown (or Input Driven) languages. OP languages are based on three relations\nbetween any two consecutive terminal symbols, which assign syntax structure to\nwords. We extend such relations to k-tuples of consecutive terminal symbols, by\nusing the model of strictly locally testable regular languages of order k at\nleast 3. The new corresponding class of Higher-order Operator Precedence\nlanguages (HOP) properly includes the OP languages, and it is still included in\nthe deterministic (also in reverse) context free family. We prove Boolean\nclosure for each subfamily of structurally compatible HOP languages. In each\nsubfamily, the top language is called max-language. We show that such languages\nare defined by a simple cancellation rule and we prove several properties, in\nparticular that max-languages make an infinite hierarchy ordered by parameter\nk. HOP languages are a candidate for replacing OP languages in the various\napplications where they have have been successful though sometimes too\nrestrictive.\n", "versions": [{"version": "v1", "created": "Thu, 25 May 2017 08:33:29 GMT"}, {"version": "v2", "created": "Tue, 22 Aug 2017 00:49:16 GMT"}], "update_date": "2017-08-23", "authors_parsed": [["Reghizzi", "Stefano Crespi", "", "DEIB, Politecnico di Milano, and IEIIT,\n  Consiglio Nazionale delle Ricerche"], ["Pradella", "Matteo", "", "DEIB, Politecnico di\n  Milano, and IEIIT, Consiglio Nazionale delle Ricerche"]]}, {"id": "1705.09354", "submitter": "Dominic Verdon", "authors": "Dominic Verdon", "title": "Coherence for braided and symmetric pseudomonoids", "comments": "Linked Globular workspace at http://globular.science/1705.001v2", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.FL math.QA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Presentations for unbraided, braided and symmetric pseudomonoids are defined.\nBiequivalences characterising the semistrict bicategories generated by these\npresentations are proven. It is shown that these biequivalences categorify\nresults in the theory of monoids and commutative monoids, and generalise\nstandard coherence theorems for braided and symmetric monoidal categories.\n", "versions": [{"version": "v1", "created": "Thu, 25 May 2017 20:45:37 GMT"}, {"version": "v2", "created": "Mon, 29 May 2017 22:20:58 GMT"}, {"version": "v3", "created": "Mon, 3 Dec 2018 17:16:55 GMT"}], "update_date": "2018-12-04", "authors_parsed": [["Verdon", "Dominic", ""]]}, {"id": "1705.09427", "submitter": "Yuliang Li", "authors": "Yuliang Li, Alin Deutsch, and Victor Vianu", "title": "SpinArt: A Spin-based Verifier for Artifact Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Data-driven workflows, of which IBM's Business Artifacts are a prime\nexponent, have been successfully deployed in practice, adopted in industrial\nstandards, and have spawned a rich body of research in academia, focused\nprimarily on static analysis. In previous work, we obtained theoretical results\non the verification of a rich model incorporating core elements of IBM's\nsuccessful Guard-Stage-Milestone (GSM) artifact model. The results showed\ndecidability of verification of temporal properties of a large class of GSM\nworkflows and established its complexity. Following up on these results, the\npresent paper reports on the implementation of SpinArt, a practical verifier\nbased on the classical model-checking tool Spin. The implementation includes\nnontrivial optimizations and achieves good performance on real-world business\nprocess examples. Our results shed light on the capabilities and limitations of\noff-the-shelf verifiers in the context of data-driven workflows.\n", "versions": [{"version": "v1", "created": "Fri, 26 May 2017 04:13:17 GMT"}, {"version": "v2", "created": "Thu, 28 Sep 2017 17:35:37 GMT"}, {"version": "v3", "created": "Mon, 19 Mar 2018 23:21:27 GMT"}], "update_date": "2018-03-21", "authors_parsed": [["Li", "Yuliang", ""], ["Deutsch", "Alin", ""], ["Vianu", "Victor", ""]]}, {"id": "1705.09525", "submitter": "Claudio Mezzina", "authors": "Claudio Antares Mezzina and Emilio Tuosto", "title": "Choreographies for Automatic Recovery", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a choreographic model of reversible computations based on a\nconservative extension of global graphs and communicating finite-state\nmachines. The main advantage of our approach is that does not require to\ninstrument models in order to control reversibility but for a minor decoration\nof branches. We show that our models are conservative extensions of existing\nones and that the reversible semantics guarantees causal consistency.\n", "versions": [{"version": "v1", "created": "Fri, 26 May 2017 10:49:22 GMT"}], "update_date": "2017-05-29", "authors_parsed": [["Mezzina", "Claudio Antares", ""], ["Tuosto", "Emilio", ""]]}, {"id": "1705.09650", "submitter": "Qin Lin", "authors": "Xiaoran Liu and Qin Lin and Sicco Verwer and Dmitri Jarnikov", "title": "Anomaly Detection in a Digital Video Broadcasting System Using Timed\n  Automata", "comments": "This paper has been accepted by the Thirty-Second Annual ACM/IEEE\n  Symposium on Logic in Computer Science (LICS) Workshop on Learning and\n  Automata (LearnAut)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.AI cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper focuses on detecting anomalies in a digital video broadcasting\n(DVB) system from providers' perspective. We learn a probabilistic\ndeterministic real timed automaton profiling benign behavior of encryption\ncontrol in the DVB control access system. This profile is used as a one-class\nclassifier. Anomalous items in a testing sequence are detected when the\nsequence is not accepted by the learned model.\n", "versions": [{"version": "v1", "created": "Wed, 24 May 2017 09:26:49 GMT"}], "update_date": "2017-05-29", "authors_parsed": [["Liu", "Xiaoran", ""], ["Lin", "Qin", ""], ["Verwer", "Sicco", ""], ["Jarnikov", "Dmitri", ""]]}, {"id": "1705.09695", "submitter": "Alberto Pettorossi", "authors": "Alberto Pettorossi, Maurizio Proietti", "title": "Regularity of languages generated by non context-free grammars over a\n  singleton terminal alphabet", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is well-known that: (i) every context-free language over a singleton\nterminal alphabet is regular, and (ii) the class of languages that satisfy the\nPumping Lemma is a proper super-class of the context-free languages. We show\nthat any language in this superclass over a singleton terminal alphabet is\nregular. Our proof is based on a transformational approach and does not rely on\nParikh's Theorem. Our result extends previously known results because there are\nlanguages that are not context-free, do satisfy the Pumping Lemma, and do not\nsatisfy the hypotheses of Parikh's Theorem.\n", "versions": [{"version": "v1", "created": "Fri, 26 May 2017 19:46:02 GMT"}, {"version": "v2", "created": "Thu, 12 Jul 2018 17:35:46 GMT"}], "update_date": "2018-07-13", "authors_parsed": [["Pettorossi", "Alberto", ""], ["Proietti", "Maurizio", ""]]}, {"id": "1705.09732", "submitter": "Ian McQuillan", "authors": "Oscar H. Ibarra and Ian McQuillan", "title": "Variations of Checking Stack Automata: Obtaining Unexpected Decidability\n  Properties", "comments": null, "journal-ref": "Theoretical Computer Science, 738, 1-12, 2018", "doi": "10.1016/j.tcs.2018.04.024", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a model of one-way language acceptors (a variant of a checking\nstack automaton) and show the following decidability properties: (1) The\ndeterministic version has a decidable membership problem but has an undecidable\nemptiness problem. (2) The nondeterministic version has an undecidable\nmembership problem and emptiness problem. There are many models of accepting\ndevices for which there is no difference with these problems between\ndeterministic and nondeterministic versions, and the same holds for the\nemptiness problem. As far as we know, the model we introduce above is the first\none-way model to exhibit properties (1) and (2). We define another family of\none-way acceptors where the nondeterministic version has an undecidable\nemptiness problem, but the deterministic version has a decidable emptiness\nproblem. We also know of no other model with this property in the literature.\nWe also investigate decidability properties of other variations of checking\nstack automata (e.g., allowing multiple stacks, two-way input, etc.).\nSurprisingly, two-way deterministic machines with multiple checking stacks and\nmultiple reversal-bounded counters are shown to have a decidable membership\nproblem, a very general model with this property.\n", "versions": [{"version": "v1", "created": "Fri, 26 May 2017 22:22:01 GMT"}, {"version": "v2", "created": "Thu, 7 Mar 2019 16:25:31 GMT"}], "update_date": "2019-03-08", "authors_parsed": [["Ibarra", "Oscar H.", ""], ["McQuillan", "Ian", ""]]}, {"id": "1705.10277", "submitter": "Clelia De Felice", "authors": "Paola Bonizzoni and Clelia De Felice and Rocco Zaccagnino and Rosalba\n  Zizza", "title": "Inverse Lyndon words and Inverse Lyndon factorizations of words", "comments": null, "journal-ref": "Advances in Applied Mathematics, Vol. 101, pp. 281-319, 2018", "doi": "10.1016/j.aam.2018.08.005", "report-no": null, "categories": "cs.FL cs.DM cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Motivated by applications to string processing, we introduce variants of the\nLyndon factorization called inverse Lyndon factorizations. Their factors, named\ninverse Lyndon words, are in a class that strictly contains anti-Lyndon words,\nthat is Lyndon words with respect to the inverse lexicographic order. The\nLyndon factorization of a nonempty word w is unique but w may have several\ninverse Lyndon factorizations. We prove that any nonempty word w admits a\ncanonical inverse Lyndon factorization, named ICFL(w), that maintains the main\nproperties of the Lyndon factorization of w: it can be computed in linear time,\nit is uniquely determined, it preserves a compatibility property for sorting\nsuffixes. In particular, the compatibility property of ICFL(w) is a consequence\nof another result: any factor in ICFL(w) is a concatenation of consecutive\nfactors of the Lyndon factorization of w with respect to the inverse\nlexicographic order.\n", "versions": [{"version": "v1", "created": "Mon, 29 May 2017 16:24:11 GMT"}, {"version": "v2", "created": "Sat, 3 Jun 2017 20:32:56 GMT"}, {"version": "v3", "created": "Wed, 23 Aug 2017 20:23:31 GMT"}, {"version": "v4", "created": "Sun, 24 Sep 2017 00:21:51 GMT"}, {"version": "v5", "created": "Sun, 19 Nov 2017 20:29:04 GMT"}, {"version": "v6", "created": "Sun, 26 Nov 2017 21:05:49 GMT"}, {"version": "v7", "created": "Sun, 17 Dec 2017 22:53:02 GMT"}], "update_date": "2018-09-06", "authors_parsed": [["Bonizzoni", "Paola", ""], ["De Felice", "Clelia", ""], ["Zaccagnino", "Rocco", ""], ["Zizza", "Rosalba", ""]]}, {"id": "1705.10427", "submitter": "Jin Dai", "authors": "Jin Dai, Alessandro Benini, Hai Lin, Panos J. Antsaklis, Matthew J.\n  Rutherford, Kimon P. Valavanis", "title": "Learning-based Formal Synthesis of Cooperative Multi-agent Systems", "comments": "16 pages, 23 figures, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a formal design framework for synthesizing coordination and\ncontrol policies for cooperative multi-agent systems to accomplish a global\nmission. The global performance requirements are specified as regular languages\nwhile dynamics of each agent as well as the shared environment are\ncharacterized by finite automata, upon on which a formal design approach is\ncarried out via divide-and-conquer. Specifically, the global mission is\ndecomposed into local tasks; and local mission supervisors are designed to\naccomplish these local tasks while maintaining the multi-agent performance by\nintegrating supervisor synthesis with compositional verification techniques;\nfinally, motion plans are automatically synthesized based on the obtained\nmission plans. We present three modifications of the L* learning algorithm such\nthat they are adapted for the synthesis of the local mission supervisors, the\ncompositional verification and the synthesis of local motion plans, to\nguarantee that the collective behavior of the agents will ensure the\nsatisfaction of the global specification. Furthermore, the effectiveness of the\nproposed framework is demonstrated by a detailed experimental study based on\nthe implementation of a multi-robot coordination scenario. The proposed\nhardware-software architecture, with each robot's communication and\nlocalization capabilities, is exploited to examine the automatic supervisor\nsynthesis with inter-robot communication.\n", "versions": [{"version": "v1", "created": "Tue, 30 May 2017 01:39:45 GMT"}], "update_date": "2017-07-19", "authors_parsed": [["Dai", "Jin", ""], ["Benini", "Alessandro", ""], ["Lin", "Hai", ""], ["Antsaklis", "Panos J.", ""], ["Rutherford", "Matthew J.", ""], ["Valavanis", "Kimon P.", ""]]}, {"id": "1705.10533", "submitter": "EPTCS", "authors": "Kitti Gelle (University of Szeged), Szabolcs Iv\\'an (University of\n  Szeged)", "title": "Reversible Languages Having Finitely Many Reduced Automata", "comments": "In Proceedings AFL 2017, arXiv:1708.06226", "journal-ref": "EPTCS 252, 2017, pp. 114-127", "doi": "10.4204/EPTCS.252.13", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reversible forms of computations are often interesting from an energy\nefficiency point of view. When the computation device in question is an\nautomaton, it is known that the minimal reversible automaton recognizing a\ngiven language is not necessarily unique, moreover, there are languages having\narbitrarily large reversible recognizers possessing no nontrivial reversible\ncongruence. However, the exact characterization of this class of languages was\nopen. In this paper we give a forbidden pattern capturing the reversible\nregular languages having only finitely many reduced reversible automata,\nallowing an efficient (NL) decision procedure.\n", "versions": [{"version": "v1", "created": "Tue, 30 May 2017 10:30:27 GMT"}, {"version": "v2", "created": "Tue, 22 Aug 2017 00:49:58 GMT"}], "update_date": "2017-08-23", "authors_parsed": [["Gelle", "Kitti", "", "University of Szeged"], ["Iv\u00e1n", "Szabolcs", "", "University of\n  Szeged"]]}, {"id": "1705.10625", "submitter": "Cl\\'ement Miklarz", "authors": "Pascal Caron, Ludovic Mignot, Cl\\'ement Miklarz", "title": "On the decidability of $k$-Block determinism", "comments": "15 pages, 13 figures, Submitted to Information and Computation,\n  Continuing arXiv:1512.05475", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Br\\\"uggemann-Klein and Wood define a one-unambiguous regular language as a\nlanguage that can be recognized by a deterministic Glushkov automaton. They\ngive a procedure performed on the minimal DFA, the BW-test, to decide whether a\nlanguage is one-unambiguous. Block determinism is an extension of\none-unambiguity while considering non-empty words as symbols and\nprefix-freeness as determinism. A block automaton is compact if it does not\nhave two equivalent states (same right language). We showed that a language is\n$k$-block deterministic if it is recognized by some deterministic $k$-block\nautomaton passing the BW-test. In this paper, we show that any $k$-block\ndeterministic language is recognized by a compact deterministic $k$-block\nautomaton passing the BW-test. We also give a procedure which enumerates, for a\ngiven language, the finite set of compact deterministic $k$-block automata. It\ngives us a decidable procedure to test whether a language is $k$-block\ndeterministic.\n", "versions": [{"version": "v1", "created": "Tue, 30 May 2017 13:37:02 GMT"}], "update_date": "2017-05-31", "authors_parsed": [["Caron", "Pascal", ""], ["Mignot", "Ludovic", ""], ["Miklarz", "Cl\u00e9ment", ""]]}, {"id": "1705.10639", "submitter": "Rick Smetsers", "authors": "Rick Smetsers", "title": "Grammatical Inference as a Satisfiability Modulo Theories Problem", "comments": "Submitted and selected for oral presentation at the LearnAut workshop\n  at LICS 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of learning a minimal consistent model from a set of labeled\nsequences of symbols is addressed from a satisfiability modulo theories\nperspective. We present two encodings for deterministic finite automata and\nextend one of these for Moore and Mealy machines. Our experimental results show\nthat these encodings improve upon the state-of-the-art, and are useful in\npractice for learning small models.\n", "versions": [{"version": "v1", "created": "Tue, 30 May 2017 13:48:15 GMT"}], "update_date": "2017-05-31", "authors_parsed": [["Smetsers", "Rick", ""]]}, {"id": "1705.10699", "submitter": "Kazuyuki Asada", "authors": "Kazuyuki Asada and Naoki Kobayashi", "title": "Pumping Lemma for Higher-order Languages", "comments": "ICALP 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study a pumping lemma for the word/tree languages generated by\nhigher-order grammars. Pumping lemmas are known up to order-2 word languages\n(i.e., for regular/context-free/indexed languages), and have been used to show\nthat a given language does not belong to the classes of\nregular/context-free/indexed languages. We prove a pumping lemma for word/tree\nlanguages of arbitrary orders, modulo a conjecture that a higher-order version\nof Kruskal's tree theorem holds. We also show that the conjecture indeed holds\nfor the order-2 case, which yields a pumping lemma for order-2 tree languages\nand order-3 word languages.\n", "versions": [{"version": "v1", "created": "Tue, 30 May 2017 15:23:19 GMT"}], "update_date": "2017-05-31", "authors_parsed": [["Asada", "Kazuyuki", ""], ["Kobayashi", "Naoki", ""]]}]