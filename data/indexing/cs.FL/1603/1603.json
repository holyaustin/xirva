[{"id": "1603.00361", "submitter": "Tom\\'a\\v{s} Masopust", "authors": "Tom\\'a\\v{s} Masopust", "title": "Piecewise Testable Languages and Nondeterministic Automata", "comments": "Corrections in section 4.1", "journal-ref": null, "doi": "10.4230/LIPIcs.MFCS.2016.67", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A regular language is $k$-piecewise testable if it is a finite boolean\ncombination of languages of the form $\\Sigma^* a_1 \\Sigma^* \\cdots \\Sigma^* a_n\n\\Sigma^*$, where $a_i\\in\\Sigma$ and $0\\le n \\le k$. Given a DFA $A$ and $k\\ge\n0$, it is an NL-complete problem to decide whether the language $L(A)$ is\npiecewise testable and, for $k\\ge 4$, it is coNP-complete to decide whether the\nlanguage $L(A)$ is $k$-piecewise testable. It is known that the depth of the\nminimal DFA serves as an upper bound on $k$. Namely, if $L(A)$ is piecewise\ntestable, then it is $k$-piecewise testable for $k$ equal to the depth of $A$.\nIn this paper, we show that some form of nondeterminism does not violate this\nupper bound result. Specifically, we define a class of NFAs, called ptNFAs,\nthat recognize piecewise testable languages and show that the depth of a ptNFA\nprovides an (up to exponentially better) upper bound on $k$ than the minimal\nDFA. We provide an application of our result, discuss the relationship between\n$k$-piecewise testability and the depth of NFAs, and study the complexity of\n$k$-piecewise testability for ptNFAs.\n", "versions": [{"version": "v1", "created": "Tue, 1 Mar 2016 17:11:05 GMT"}, {"version": "v2", "created": "Thu, 10 Mar 2016 06:54:39 GMT"}], "update_date": "2016-09-07", "authors_parsed": [["Masopust", "Tom\u00e1\u0161", ""]]}, {"id": "1603.00658", "submitter": "Manjunatha Praveen", "authors": "M. Praveen, B. Srivathsan", "title": "Nesting Depth of Operators in Graph Database Queries: Expressiveness Vs.\n  Evaluation Complexity", "comments": "Improvements from ICALP 2016 review comments", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Designing query languages for graph structured data is an active field of\nresearch, where expressiveness and efficient algorithms for query evaluation\nare conflicting goals. To better handle dynamically changing data, recent work\nhas been done on designing query languages that can compare values stored in\nthe graph database, without hard coding the values in the query. The main idea\nis to allow variables in the query and bind the variables to values when\nevaluating the query. For query languages that bind variables only once, query\nevaluation is usually NP-complete. There are query languages that allow binding\ninside the scope of Kleene star operators, which can themselves be in the scope\nof bindings and so on. Uncontrolled nesting of binding and iteration within one\nanother results in query evaluation being PSPACE-complete.\n  We define a way to syntactically control the nesting depth of iterated\nbindings, and study how this affects expressiveness and efficiency of query\nevaluation. The result is an infinite, syntactically defined hierarchy of\nexpressions. We prove that the corresponding language hierarchy is strict.\nGiven an expression in the hierarchy, we prove that it is undecidable to check\nif there is a language equivalent expression at lower levels. We prove that\nevaluating a query based on an expression at level i can be done in $\\Sigma_i$\nin the polynomial time hierarchy. Satisfiability of quantified Boolean formulas\ncan be reduced to query evaluation; we study the relationship between\nalternations in Boolean quantifiers and the depth of nesting of iterated\nbindings.\n", "versions": [{"version": "v1", "created": "Wed, 2 Mar 2016 11:16:37 GMT"}, {"version": "v2", "created": "Thu, 5 May 2016 06:50:56 GMT"}], "update_date": "2016-05-06", "authors_parsed": [["Praveen", "M.", ""], ["Srivathsan", "B.", ""]]}, {"id": "1603.00976", "submitter": "EPTCS", "authors": "Pawe{\\l} Soboci\\'nski (University of Southampton)", "title": "Compositional model checking of concurrent systems, with Petri nets", "comments": "In Proceedings DCM 2015, arXiv:1603.00536", "journal-ref": "EPTCS 204, 2016, pp. 19-30", "doi": "10.4204/EPTCS.204.3", "report-no": null, "categories": "cs.LO cs.FL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compositionality and process equivalence are both standard concepts of\nprocess algebra. Compositionality means that the behaviour of a compound system\nrelies only on the behaviour of its components, i.e. there is no emergent\nbehaviour. Process equivalence means that the explicit statespace of a system\ntakes a back seat to its interaction patterns: the information that an\nenvironment can obtain though interaction.\n  Petri nets are a classical, yet widely used and understood, model of\nconcurrency. Nevertheless, they have often been described as a\nnon-compositional model, and tools tend to deal with monolithic,\nglobally-specified models.\n  This tutorial paper concentrates on Petri Nets with Boundaries (PNB): a\ncompositional, graphical algebra of 1-safe nets, and its applications to\nreachability checking within the tool Penrose. The algorithms feature the use\nof compositionality and process equivalence, a powerful combination that can be\nharnessed to improve the performance of checking reachability and coverability\nin several common examples where Petri nets model realistic concurrent systems.\n", "versions": [{"version": "v1", "created": "Thu, 3 Mar 2016 05:33:39 GMT"}], "update_date": "2016-03-04", "authors_parsed": [["Soboci\u0144ski", "Pawe\u0142", "", "University of Southampton"]]}, {"id": "1603.01058", "submitter": "Jetro Vesti M.Si.", "authors": "Jetro Vesti", "title": "Rich square-free words", "comments": "25 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A word w is rich if it has |w|+1 many distinct palindromic factors, including\nthe empty word. A word is square-free if it does not have a factor uu, where u\nis a non-empty word.\n  Pelantov\\'a and Starosta (Discrete Math. 313 (2013)) proved that every\ninfinite rich word contains a square. We will give another proof for that\nresult. Pelantov\\'a and Starosta denoted by r(n) the length of a longest rich\nsquare-free word on an alphabet of size n. The exact value of r(n) was left as\nan open question. We will give an upper and a lower bound for r(n), and make a\nconjecture that our lower bound is exact.\n  We will also generalize the notion of repetition threshold for a limited\nclass of infinite words. The repetition thresholds for episturmian and rich\nwords are left as an open question.\n", "versions": [{"version": "v1", "created": "Thu, 3 Mar 2016 11:22:03 GMT"}], "update_date": "2016-03-04", "authors_parsed": [["Vesti", "Jetro", ""]]}, {"id": "1603.01107", "submitter": "Daniel Tischner", "authors": "Daniel Tischner", "title": "Minimization of B\\\"uchi Automata using Fair Simulation", "comments": "Bachelor's thesis, 67 pages, 12 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DS", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We present an algorithm, which reduces the size of B\\\"uchi automata using\nfair simulation. Its time complexity is $\\mathcal{O}(|Q|^4 \\cdot |\\Delta|^2)$,\nthe space complexity is $\\mathcal{O}(|Q| \\cdot |\\Delta|)$.\n  Simulation is a common approach for minimizing $\\omega$-automata such as\nB\\\"uchi automata. Direct simulation, delayed simulation and fair simulation are\ndifferent types of simulation. As we will show, minimization based on direct or\ndelayed simulation is conceptually simple. Whereas the algorithm based on fair\nsimulation is more complex. However, fair simulation allows a stronger\nminimization of the automaton.\n  Further, we illustrate the theory behind the algorithm, cover optimizations\nuseful in practice, give experimental results and compare our technique to\nother minimization strategies.\n", "versions": [{"version": "v1", "created": "Thu, 3 Mar 2016 14:24:44 GMT"}], "update_date": "2016-03-04", "authors_parsed": [["Tischner", "Daniel", ""]]}, {"id": "1603.01455", "submitter": "Thorsten Wi{\\ss}mann", "authors": "Lutz Schr\\\"oder, Dexter Kozen, Stefan Milius, Thorsten Wi{\\ss}mann", "title": "Nominal Automata with Name Binding", "comments": "Updated arguments A.26/A.27; rest unchanged", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automata models for data languages (i.e. languages over infinite alphabets)\noften feature either global or local freshness operators. We show that Bollig\net al.'s session automata, which focus on global freshness, are equivalent to\nregular nondeterministic nominal automata (RNNA), a natural nominal automaton\nmodel with explicit name binding that has appeared implicitly in the semantics\nof nominal Kleene algebra (NKA), an extension of Kleene algebra with name\nbinding. The expected Kleene theorem for NKA is known to fail in one direction,\ni.e. there are nominal languages that can be accepted by an RNNA but are not\ndefinable in NKA; via session automata, we obtain a full Kleene theorem for\nRNNAs for an expression language that extends NKA with unscoped name binding.\nBased on the equivalence with RNNAs, we then slightly rephrase the known\nequivalence checking algorithm for session automata. Reinterpreting the data\nlanguage semantics of name binding by unrestricted instead of clean\nalpha-equivalence, we obtain a local freshness semantics as a quotient of the\nglobal freshness semantics. Under local freshness semantics, RNNAs turn out to\nbe equivalent to a natural subclass of Bojanczyk et al.'s nondeterministic\norbit-finite automata. We establish decidability of inclusion under local\nfreshness by modifying the RNNA-based algorithm; in summary, we obtain a\nformalism for local freshness in data languages that is reasonably expressive\nand has a decidable inclusion problem.\n", "versions": [{"version": "v1", "created": "Fri, 4 Mar 2016 13:39:02 GMT"}, {"version": "v2", "created": "Fri, 3 Feb 2017 10:44:32 GMT"}, {"version": "v3", "created": "Tue, 21 Feb 2017 13:53:20 GMT"}, {"version": "v4", "created": "Thu, 21 Jan 2021 12:45:42 GMT"}], "update_date": "2021-01-22", "authors_parsed": [["Schr\u00f6der", "Lutz", ""], ["Kozen", "Dexter", ""], ["Milius", "Stefan", ""], ["Wi\u00dfmann", "Thorsten", ""]]}, {"id": "1603.02481", "submitter": "Jakob Lykke Andersen", "authors": "Jakob L. Andersen, Christoph Flamm, Daniel Merkle, Peter F. Stadler", "title": "A Software Package for Chemically Inspired Graph Transformation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL q-bio.BM q-bio.MN", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Chemical reaction networks can be automatically generated from graph grammar\ndescriptions, where rewrite rules model reaction patterns. Because a molecule\ngraph is connected and reactions in general involve multiple molecules, the\nrewriting must be performed on multisets of graphs. We present a general\nsoftware package for this type of graph rewriting system, which can be used for\nmodelling chemical systems. The package contains a C++ library with algorithms\nfor working with transformation rules in the Double Pushout formalism, e.g.,\ncomposition of rules and a domain specific language for programming graph\nlanguage generation. A Python interface makes these features easily accessible.\nThe package also has extensive procedures for automatically visualising not\nonly graphs and rewrite rules, but also Double Pushout diagrams and graph\nlanguages in form of directed hypergraphs. The software is available as an open\nsource package, and interactive examples can be found on the accompanying\nwebpage.\n", "versions": [{"version": "v1", "created": "Tue, 8 Mar 2016 11:20:02 GMT"}, {"version": "v2", "created": "Thu, 21 Apr 2016 06:03:44 GMT"}], "update_date": "2016-04-22", "authors_parsed": [["Andersen", "Jakob L.", ""], ["Flamm", "Christoph", ""], ["Merkle", "Daniel", ""], ["Stadler", "Peter F.", ""]]}, {"id": "1603.02597", "submitter": "Tim Smith", "authors": "Tim Smith", "title": "Prediction of Infinite Words with Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the classic problem of sequence prediction, a predictor receives a\nsequence of values from an emitter and tries to guess the next value before it\nappears. The predictor masters the emitter if there is a point after which all\nof the predictor's guesses are correct. In this paper we consider the case in\nwhich the predictor is an automaton and the emitted values are drawn from a\nfinite set; i.e., the emitted sequence is an infinite word. We examine the\npredictive capabilities of finite automata, pushdown automata, stack automata\n(a generalization of pushdown automata), and multihead finite automata. We\nrelate our predicting automata to purely periodic words, ultimately periodic\nwords, and multilinear words, describing novel prediction algorithms for\nmastering these sequences.\n", "versions": [{"version": "v1", "created": "Tue, 8 Mar 2016 17:12:09 GMT"}], "update_date": "2016-03-09", "authors_parsed": [["Smith", "Tim", ""]]}, {"id": "1603.02928", "submitter": "Jochen Burghardt", "authors": "Jochen Burghardt", "title": "Weight Computation of Regular Tree Languages", "comments": "26 pages; 3 figures. Originally published 23 Mar 2004 as \"FIRST\n  Reports 1/2004\". Section 4 essentially describes Knuth's algorithm from his\n  paper \"A Generalization of Dijkstra's Algorithm\" (Information Processing\n  Letters, Vol.6, No.1, p.1-5, 1977); I wasn't aware of its existence at that\n  time", "journal-ref": null, "doi": null, "report-no": "FIRST TR 1/2004", "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a general framework to define an application-dependent weight\nmeasure on terms that subsumes e.g. total simplification orderings, and an O(n\nlog n) algorithm for the simultaneous computation of the minimal weight of a\nterm in the language of each nonterminal of a regular tree grammar, based on\nBarzdins' liquid-flow technique.\n", "versions": [{"version": "v1", "created": "Wed, 9 Mar 2016 15:50:52 GMT"}], "update_date": "2016-03-10", "authors_parsed": [["Burghardt", "Jochen", ""]]}, {"id": "1603.02966", "submitter": "Manfred Kufleitner", "authors": "Volker Diekert and Artur Je\\.z and Manfred Kufleitner", "title": "Solutions of Word Equations over Partially Commutative Structures", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give NSPACE(n log n) algorithms solving the following decision problems.\nSatisfiability: Is the given equation over a free partially commutative monoid\nwith involution (resp. a free partially commutative group) solvable?\nFiniteness: Are there only finitely many solutions of such an equation? PSPACE\nalgorithms with worse complexities for the first problem are known, but so far,\na PSPACE algorithm for the second problem was out of reach. Our results are\nmuch stronger: Given such an equation, its solutions form an EDT0L language\neffectively representable in NSPACE(n log n). In particular, we give an\neffective description of the set of all solutions for equations with\nconstraints in free partially commutative monoids and groups.\n", "versions": [{"version": "v1", "created": "Wed, 9 Mar 2016 17:03:22 GMT"}], "update_date": "2016-03-10", "authors_parsed": [["Diekert", "Volker", ""], ["Je\u017c", "Artur", ""], ["Kufleitner", "Manfred", ""]]}, {"id": "1603.03002", "submitter": "Elizaveta Frenkel", "authors": "Elizaveta Frenkel and Vladimir N. Remeslennikov", "title": "Measuring cones and other thick subsets in free groups", "comments": "18 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we investigate the special automata over finite rank free\ngroups and estimate asymptotic characteristics of sets they accept. We show how\none can decompose an arbitrary regular subset of a finite rank free group into\ndisjoint union of sets accepted by special automata or special monoids. These\nautomata allow us to compute explicitly generating functions,\n$\\lambda-$measures and Cesaro measure of thick monoids. Also we improve the\nasymptotic classification of regular subsets in free groups.\n", "versions": [{"version": "v1", "created": "Wed, 9 Mar 2016 19:06:28 GMT"}], "update_date": "2016-03-10", "authors_parsed": [["Frenkel", "Elizaveta", ""], ["Remeslennikov", "Vladimir N.", ""]]}, {"id": "1603.03059", "submitter": "James Currie", "authors": "James D. Currie", "title": "A ternary square-free sequence avoiding factors equivalent to $abcacba$", "comments": "7 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We solve a problem of Petrova, finalizing the classification of letter\npatterns avoidable by ternary square-free words; we show that there is a\nternary square-free word avoiding letter pattern $xyzxzyx$. In fact, we: (1)\ncharacterize all the (two-way) infinite ternary square-free words avoiding\nletter pattern $xyzxzyx$ (2) characterize the lexicographically least (one-way)\ninfinite ternary square-free word avoiding letter pattern $xyzxzyx$ (3) show\nthat the number of ternary square-free words of length $n$ avoiding letter\npattern $xyzxzyx$ grows exponentially with $n$.\n", "versions": [{"version": "v1", "created": "Wed, 9 Mar 2016 21:08:08 GMT"}], "update_date": "2016-03-11", "authors_parsed": [["Currie", "James D.", ""]]}, {"id": "1603.03610", "submitter": "Mark-Jan Nederhof", "authors": "Mark-Jan Nederhof", "title": "A short proof that $O_2$ is an MCFL", "comments": "9 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new proof that $O_2$ is a multiple context-free language. It\ncontrasts with a recent proof by Salvati (2015) in its avoidance of concepts\nthat seem specific to two-dimensional geometry, such as the complex exponential\nfunction. Our simple proof creates realistic prospects of widening the results\nto higher dimensions. This finding is of central importance to the relation\nbetween extreme free word order and classes of grammars used to describe the\nsyntax of natural language.\n", "versions": [{"version": "v1", "created": "Fri, 11 Mar 2016 12:32:29 GMT"}], "update_date": "2016-03-14", "authors_parsed": [["Nederhof", "Mark-Jan", ""]]}, {"id": "1603.04541", "submitter": "Yongming Li", "authors": "Xiujuan Wei, Yongming Li", "title": "Fuzzy alternating $\\mathrm{B\\ddot{u}chi}$ automata over distributive\n  lattices", "comments": "35 pages, 8 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give a new version of fuzzy alternating $\\mathrm{B\\ddot{u}chi}$ automata\nover distributive lattices: weights are putting in every leaf node of run trees\nrather than along with edges from every node to its children. Such settings are\ngreat benefit to obtain complement just by taking dual operation and replacing\neach final weight with its complement. We prove that $L$-fuzzy nondeterministic\n$\\mathrm{B\\ddot{u}chi}$ automata have the same expressive power as $L$-fuzzy\nalternating $\\mathrm{B\\ddot{u}chi}$ ones. A direct construction (without\nrelated knowledge about $L$-fuzzy nondeterministic $\\mathrm{B\\ddot{u}chi}$ ones\nsuch as: above equivalence relation and their closure properties) is given to\nshow that the languages recognized by $L$-fuzzy alternating\nco-$\\mathrm{B\\ddot{u}chi}$ automata are also $L$-fuzzy $\\omega$-regular.\nFurthermore, the closure properties and the discussion about decision problems\nfor fuzzy alternating $\\mathrm{B\\ddot{u}chi}$ automata are illustrated in our\npaper.\n", "versions": [{"version": "v1", "created": "Tue, 15 Mar 2016 03:27:06 GMT"}], "update_date": "2016-03-16", "authors_parsed": [["Wei", "Xiujuan", ""], ["Li", "Yongming", ""]]}, {"id": "1603.05072", "submitter": "Mickael Randour", "authors": "Mickael Randour", "title": "Reconciling Rationality and Stochasticity: Rich Behavioral Models in\n  Two-Player Games", "comments": "Accepted at GAMES 2016, the 5th World Congress of the Game Theory\n  Society. High-level survey notably based on arXiv:1204.3283 and\n  arXiv:1411.0835", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two traditional paradigms are often used to describe the behavior of agents\nin multi-agent complex systems. In the first one, agents are considered to be\nfully rational and systems are seen as multi-player games. In the second one,\nagents are considered to be fully stochastic processes and the system itself is\nseen as a large stochastic process. From the standpoint of a particular agent -\nhaving to choose a strategy, the choice of the paradigm is crucial: the most\nadequate strategy depends on the assumptions made on the other agents.\n  In this paper, we focus on two-player games and their application to the\nautomated synthesis of reliable controllers for reactive systems - a field at\nthe crossroads between computer science and mathematics. In this setting, the\nreactive system to control is a player, and its environment is its opponent,\nusually assumed to be fully antagonistic or fully stochastic. We illustrate\nseveral recent developments aiming to breach this narrow taxonomy by providing\nformal concepts and mathematical frameworks to reason about richer behavioral\nmodels.\n  The interest of such models is not limited to reactive system synthesis but\nextends to other application fields of game theory. The goal of our\ncontribution is to give a high-level presentation of key concepts and\napplications, aimed at a broad audience. To achieve this goal, we illustrate\nthose rich behavioral models on a classical challenge of the everyday life:\nplanning a journey in an uncertain environment.\n", "versions": [{"version": "v1", "created": "Wed, 16 Mar 2016 12:56:24 GMT"}], "update_date": "2016-03-17", "authors_parsed": [["Randour", "Mickael", ""]]}, {"id": "1603.05376", "submitter": "Lukas Fleischer", "authors": "Lukas Fleischer and Manfred Kufleitner", "title": "Operations on Weakly Recognizing Morphisms", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Weakly recognizing morphisms from free semigroups onto finite semigroups are\na classical way for defining the class of omega-regular languages, i.e., a set\nof infinite words is weakly recognizable by such a morphism if and only if it\nis accepted by some B\\\"uchi automaton. We consider the descriptional complexity\nof various constructions for weakly recognizing morphisms. This includes the\nconversion from and to B\\\"uchi automata, the conversion into strongly\nrecognizing morphisms, and complementation. For some problems, we are able to\ngive more precise bounds in the case of binary alphabets or simple semigroups.\n", "versions": [{"version": "v1", "created": "Thu, 17 Mar 2016 07:33:07 GMT"}, {"version": "v2", "created": "Wed, 27 Apr 2016 11:31:36 GMT"}], "update_date": "2016-04-28", "authors_parsed": [["Fleischer", "Lukas", ""], ["Kufleitner", "Manfred", ""]]}, {"id": "1603.05426", "submitter": "Wanwei Liu", "authors": "Wanwei Liu", "title": "A Short Note on Infinite Union/Intersection of Omega Regular Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We in this paper show that omega regular languages are not closed under\ninfinite union and intersection. As an attempt, we propose to add step\nvariables and quantifiers to temporal logics to enhance the expressiveness of\nthe underlying logic. We also show that doing this would cause undecidability\nin satisfiability, even if for a rather limited fragment of temporal logic.\n", "versions": [{"version": "v1", "created": "Thu, 17 Mar 2016 10:57:30 GMT"}], "update_date": "2016-03-18", "authors_parsed": [["Liu", "Wanwei", ""]]}, {"id": "1603.06017", "submitter": "Hamoon Mousavi", "authors": "Hamoon Mousavi", "title": "Automatic Theorem Proving in Walnut", "comments": "Added a few more sections", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.MS math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Walnut is a software package that implements a mechanical decision procedure\nfor deciding certain combinatorial properties of some special words referred to\nas automatic words or automatic sequences. Walnut is written in Java and is\nopen source. It is licensed under GNU General Public License.\n", "versions": [{"version": "v1", "created": "Fri, 18 Mar 2016 23:53:10 GMT"}, {"version": "v2", "created": "Tue, 25 May 2021 23:20:24 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Mousavi", "Hamoon", ""]]}, {"id": "1603.06236", "submitter": "Nik Ruskuc", "authors": "Tom Bourne and Nik Ruskuc", "title": "On the star-height of factor counting languages and their relationship\n  to Rees zero-matrix semigroups", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.GR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a word $w$ over a finite alphabet, we consider, in three special cases,\nthe generalised star-height of the languages in which $w$ occurs as a\ncontiguous subword (factor) an exact number of times and of the languages in\nwhich $w$ occurs as a contiguous subword modulo a fixed number, and prove that\nin each case it is at most one. We use these combinatorial results to show that\nany language recognised by a Rees (zero-)matrix semigroup over an abelian group\nis of generalised star-height at most one.\n", "versions": [{"version": "v1", "created": "Sun, 20 Mar 2016 16:34:03 GMT"}, {"version": "v2", "created": "Tue, 27 Sep 2016 17:01:02 GMT"}], "update_date": "2016-09-28", "authors_parsed": [["Bourne", "Tom", ""], ["Ruskuc", "Nik", ""]]}, {"id": "1603.06850", "submitter": "Przemys{\\l}aw Daca", "authors": "Przemys{\\l}aw Daca, Thomas A. Henzinger, Andrey Kupriyanov", "title": "Array Folds Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an extension to the quantifier-free theory of integer arrays which\nallows us to express counting. The properties expressible in Array Folds Logic\n(AFL) include statements such as \"the first array cell contains the array\nlength,\" and \"the array contains equally many minimal and maximal elements.\"\nThese properties cannot be expressed in quantified fragments of the theory of\narrays, nor in the theory of concatenation. Using reduction to counter\nmachines, we show that the satisfiability problem of AFL is PSPACE-complete,\nand with a natural restriction the complexity decreases to NP. We also show\nthat adding either universal quantifiers or concatenation leads to\nundecidability.\n  AFL contains terms that fold a function over an array. We demonstrate that\nfolding, a well-known concept from functional languages, allows us to concisely\nsummarize loops that count over arrays, which occurs frequently in real-life\nprograms. We provide a tool that can discharge proof obligations in AFL, and we\ndemonstrate on practical examples that our decision procedure can solve a broad\nrange of problems in symbolic testing and program verification.\n", "versions": [{"version": "v1", "created": "Tue, 22 Mar 2016 16:10:47 GMT"}, {"version": "v2", "created": "Thu, 24 Mar 2016 19:49:04 GMT"}, {"version": "v3", "created": "Thu, 12 May 2016 14:41:29 GMT"}], "update_date": "2016-05-13", "authors_parsed": [["Daca", "Przemys\u0142aw", ""], ["Henzinger", "Thomas A.", ""], ["Kupriyanov", "Andrey", ""]]}, {"id": "1603.07217", "submitter": "Dietrich Kuske", "authors": "Dietrich Kuske and Olena Prianychnykova", "title": "The trace monoids in the queue monoid and in the direct product of two\n  free monoids", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that a trace monoid embeds into the queue monoid if and only if it\nembeds into the direct product of two free monoids. We also give a decidable\ncharacterization of these trace monoids.\n", "versions": [{"version": "v1", "created": "Wed, 23 Mar 2016 15:03:37 GMT"}], "update_date": "2016-03-24", "authors_parsed": [["Kuske", "Dietrich", ""], ["Prianychnykova", "Olena", ""]]}, {"id": "1603.07256", "submitter": "Sebastian Muskalla", "authors": "Luk\\'a\\v{s} Hol\\'ik and Roland Meyer and Sebastian Muskalla", "title": "Summaries for Context-Free Games", "comments": "The conference version of this paper was accepted for FSTTCS 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study two-player games played on the infinite graph of sentential forms\ninduced by a context-free grammar (that comes with an ownership partitioning of\nthe non-terminals). The winning condition is inclusion of the derived terminal\nword in the language of a finite automaton. Our contribution is a new algorithm\nto decide the winning player and to compute her strategy. It is based on a\nnovel representation of all plays starting in a non-terminal. The\nrepresentation uses the domain of Boolean formulas over the transition monoid\nof the target automaton. The elements of the monoid are essentially procedure\nsummaries, and our approach can be seen as the first summary-based algorithm\nfor the synthesis of recursive programs. We show that our algorithm has optimal\n(doubly exponential) time complexity, that it is compatible with recent\nantichain optimizations, and that it admits a lazy evaluation strategy. Our\npreliminary experiments indeed show encouraging results, indicating a speed up\nof three orders of magnitude over a competitor.\n", "versions": [{"version": "v1", "created": "Wed, 23 Mar 2016 16:20:56 GMT"}, {"version": "v2", "created": "Wed, 20 Jul 2016 10:39:17 GMT"}, {"version": "v3", "created": "Fri, 9 Sep 2016 15:52:19 GMT"}, {"version": "v4", "created": "Tue, 1 Nov 2016 13:45:24 GMT"}], "update_date": "2016-11-02", "authors_parsed": [["Hol\u00edk", "Luk\u00e1\u0161", ""], ["Meyer", "Roland", ""], ["Muskalla", "Sebastian", ""]]}, {"id": "1603.07271", "submitter": "Simon Wacker", "authors": "Simon Wacker", "title": "Cellular Automata on Group Sets and the Uniform Curtis-Hedlund-Lyndon\n  Theorem", "comments": null, "journal-ref": "22nd IFIP WG 1.5 International Workshop, AUTOMATA 2016, Zurich,\n  Switzerland, June 15-17, 2016, Proceedings (2016) 185-198", "doi": "10.1007/978-3-319-39300-1_15", "report-no": null, "categories": "math.GR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce cellular automata whose cell spaces are left homogeneous spaces\nand prove a uniform as well as a topological variant of the\nCurtis-Hedlund-Lyndon theorem. Examples of left homogeneous spaces are spheres,\nEuclidean spaces, as well as hyperbolic spaces acted on by isometries;\nvertex-transitive graphs, in particular, Cayley graphs, acted on by\nautomorphisms; groups acting on themselves by multiplication; and integer\nlattices acted on by translations.\n", "versions": [{"version": "v1", "created": "Mon, 21 Mar 2016 15:37:34 GMT"}, {"version": "v2", "created": "Mon, 13 Jun 2016 06:56:25 GMT"}], "update_date": "2016-07-15", "authors_parsed": [["Wacker", "Simon", ""]]}, {"id": "1603.07272", "submitter": "Simon Wacker", "authors": "Simon Wacker", "title": "The Garden of Eden Theorem for Cellular Automata on Group Sets", "comments": "arXiv admin note: text overlap with arXiv:1603.06460", "journal-ref": "12th International Conference on Cellular Automata for Research\n  and Industry, ACRI 2016, Fez, Morocco, September 5-8, 2016. Proceedings\n  (2016) 66-78", "doi": "10.1007/978-3-319-44365-2_7", "report-no": null, "categories": "math.GR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove the Garden of Eden theorem for cellular automata with finite set of\nstates and finite neighbourhood on right amenable left homogeneous spaces with\nfinite stabilisers. It states that the global transition function of such an\nautomaton is surjective if and only if it is pre-injective. Pre-Injectivity\nmeans that two global configurations that differ at most on a finite subset and\nhave the same image under the global transition function must be identical.\n", "versions": [{"version": "v1", "created": "Mon, 21 Mar 2016 15:37:47 GMT"}, {"version": "v2", "created": "Mon, 5 Sep 2016 09:20:02 GMT"}], "update_date": "2016-09-06", "authors_parsed": [["Wacker", "Simon", ""]]}, {"id": "1603.07786", "submitter": "Hans Raj Tiwary", "authors": "Hans Raj Tiwary", "title": "Extension Complexity of Formal Languages", "comments": "Final version for TOCS", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this article we undertake a study of extension complexity from the\nperspective of formal languages. We define a natural way to associate a family\nof polytopes with binary languages. This allows us to define the notion of\nextension complexity of formal languages. We prove several closure properties\nof languages admitting compact extended formulations. Furthermore, we give a\nsufficient machine characterization of compact languages. We demonstrate the\nutility of this machine characterization by obtaining upper bounds for\npolytopes for problems in nondeterministic logspace; lower bounds in streaming\nmodels; and upper bounds on extension complexities of several polytopes.\n", "versions": [{"version": "v1", "created": "Fri, 25 Mar 2016 00:11:56 GMT"}, {"version": "v2", "created": "Wed, 27 Apr 2016 16:22:08 GMT"}, {"version": "v3", "created": "Thu, 28 Apr 2016 10:29:07 GMT"}, {"version": "v4", "created": "Tue, 19 Jul 2016 16:21:35 GMT"}, {"version": "v5", "created": "Wed, 28 Aug 2019 15:20:36 GMT"}], "update_date": "2019-08-29", "authors_parsed": [["Tiwary", "Hans Raj", ""]]}, {"id": "1603.07790", "submitter": "J\\\"urgen Koslowski", "authors": "Yasuhiko Minamide", "title": "Weighted Pushdown Systems with Indexed Weight Domains", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 2 (June 29,\n  2016) lmcs:1641", "doi": "10.2168/LMCS-12(2:9)2016", "report-no": null, "categories": "cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The reachability analysis of weighted pushdown systems is a very powerful\ntechnique in verification and analysis of recursive programs. Each transition\nrule of a weighted pushdown system is associated with an element of a bounded\nsemiring representing the weight of the rule. However, we have realized that\nthe restriction of the boundedness is too strict and the formulation of\nweighted pushdown systems is not general enough for some applications. To\ngeneralize weighted pushdown systems, we first introduce the notion of stack\nsignatures that summarize the effect of a computation of a pushdown system and\nformulate pushdown systems as automata over the monoid of stack signatures. We\nthen generalize weighted pushdown systems by introducing semirings indexed by\nthe monoid and weaken the boundedness to local boundedness.\n", "versions": [{"version": "v1", "created": "Fri, 25 Mar 2016 00:50:25 GMT"}, {"version": "v2", "created": "Mon, 28 Mar 2016 02:40:53 GMT"}, {"version": "v3", "created": "Tue, 28 Jun 2016 16:04:30 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Minamide", "Yasuhiko", ""]]}, {"id": "1603.07924", "submitter": "Harald Lampesberger", "authors": "Harald Lampesberger", "title": "An Incremental Learner for Language-Based Anomaly Detection in XML", "comments": "15 pages, 7 figures, accepted at the Third Workshop on\n  Language-Theoretic Security (LangSec)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Extensible Markup Language (XML) is a complex language, and consequently,\nXML-based protocols are susceptible to entire classes of implicit and explicit\nsecurity problems. Message formats in XML-based protocols are usually specified\nin XML Schema, and as a first-line defense, schema validation should reject\nmalformed input. However, extension points in most protocol specifications\nbreak validation. Extension points are wildcards and considered best practice\nfor loose composition, but they also enable an attacker to add unchecked\ncontent in a document, e.g., for a signature wrapping attack.\n  This paper introduces datatyped XML visibly pushdown automata (dXVPAs) as\nlanguage representation for mixed-content XML and presents an incremental\nlearner that infers a dXVPA from example documents. The learner generalizes XML\ntypes and datatypes in terms of automaton states and transitions, and an\ninferred dXVPA converges to a good-enough approximation of the true language.\nThe automaton is free from extension points and capable of stream validation,\ne.g., as an anomaly detector for XML-based protocols. For dealing with\nadversarial training data, two scenarios of poisoning are considered: a\npoisoning attack is either uncovered at a later time or remains hidden.\nUnlearning can therefore remove an identified poisoning attack from a dXVPA,\nand sanitization trims low-frequent states and transitions to get rid of hidden\nattacks. All algorithms have been evaluated in four scenarios, including a web\nservice implemented in Apache Axis2 and Apache Rampart, where attacks have been\nsimulated. In all scenarios, the learned automaton had zero false positives and\noutperformed traditional schema validation.\n", "versions": [{"version": "v1", "created": "Fri, 25 Mar 2016 14:24:43 GMT"}], "update_date": "2016-03-28", "authors_parsed": [["Lampesberger", "Harald", ""]]}, {"id": "1603.08264", "submitter": "Luca Reggio", "authors": "Mai Gehrke, Daniela Petrisan, Luca Reggio", "title": "The Sch\\\"utzenberger product for syntactic spaces", "comments": "21 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL math.GN math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Starting from Boolean algebras of languages closed under quotients and using\nduality theoretic insights, we derive the notion of Boolean spaces with\ninternal monoids as recognisers for arbitrary formal languages of finite words\nover finite alphabets. This leads to a setting that is well-suited for applying\nexisting tools from Stone duality as applied in semantics. The main focus of\nthe paper is the development of topo-algebraic constructions pertinent to the\ntreatment of languages given by logic formulas. In particular, using the\nstandard semantic view of quantification as projection, we derive a notion of\nSch\\\"utzenberger product for Boolean spaces with internal monoids. This makes\nheavy use of the Vietoris construction, and its dual functor, which is central\nto the coalgebraic treatment of classical modal logic. We show that the unary\nSch\\\"utzenberger product for spaces, when applied to a recogniser for the\nlanguage associated to a formula with a free first-order variable, yields a\nrecogniser for the language of all models of the corresponding existentially\nquantified formula. Further, we generalise global and local versions of the\ntheorems of Sch\\\"utzenberger and Reutenauer characterising the languages\nrecognised by the binary Sch\\\"utzenberger product. Finally, we provide an\nequational characterisation of Boolean algebras obtained by local\nSch\\\"utzenberger product with the one element space based on an Egli-Milner\ntype condition on generalised factorisations of ultrafilters on words.\n", "versions": [{"version": "v1", "created": "Sun, 27 Mar 2016 22:27:49 GMT"}], "update_date": "2016-03-29", "authors_parsed": [["Gehrke", "Mai", ""], ["Petrisan", "Daniela", ""], ["Reggio", "Luca", ""]]}, {"id": "1603.08577", "submitter": "EPTCS", "authors": "Julia Rubin, Thomas Th\\\"um", "title": "Proceedings 7th International Workshop on Formal Methods and Analysis in\n  Software Product Line Engineering", "comments": null, "journal-ref": "EPTCS 206, 2016", "doi": "10.4204/EPTCS.206", "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In Software Product Line Engineering (SPLE), a portfolio of similar systems\nis developed from a shared set of software assets. Claimed benefits of SPLE\ninclude reductions in the portfolio size, cost of software development and time\nto production, as well as improvements in the quality of the delivered systems.\nYet, despite these benefits, SPLE is still in the early adoption stage. We\nbelieve that automated approaches, tools and techniques that provide better\nsupport for SPLE activities can further facilitate its adoption in practice and\nincrease its benefits.\n  To promote work in this area, the FMSPLE'16 workshop focuses on automated\nanalysis and formal methods, which can (1) lead to a further increase in\ndevelopment productivity and reduction in maintenance costs associated with\nmanagement of the SPLE artifacts, and (2) provide proven guarantees for the\ncorrectness and quality of the delivered systems.\n", "versions": [{"version": "v1", "created": "Mon, 28 Mar 2016 22:06:15 GMT"}], "update_date": "2016-03-30", "authors_parsed": [["Rubin", "Julia", ""], ["Th\u00fcm", "Thomas", ""]]}, {"id": "1603.09185", "submitter": "\\\"Ozlem Salehi", "authors": "\\\"Ozlem Salehi, A.C. Cem Say, Flavio D'Alessandro", "title": "Homing Vector Automata", "comments": "This is the extended version of our paper homing vector automata\n  arXiv:1504.04859", "journal-ref": "RAIRO-Theoretical Informatics and Applications 50.4 (2016):\n  371-386", "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce homing vector automata, which are finite automata augmented by a\nvector that is multiplied at each step by a matrix determined by the current\ntransition, and have to return the vector to its original setting in order to\naccept the input. The computational power and properties of deterministic,\nnondeterministic, blind, non-blind, real-time and one-way versions of these\nmachines are examined and compared to various related types of automata. A\ngeneralized version of the Stern-Brocot encoding method, suitable for\nrepresenting strings on arbitrary alphabets, is also developed.\n", "versions": [{"version": "v1", "created": "Wed, 30 Mar 2016 13:35:01 GMT"}, {"version": "v2", "created": "Thu, 4 Aug 2016 20:13:26 GMT"}], "update_date": "2017-08-01", "authors_parsed": [["Salehi", "\u00d6zlem", ""], ["Say", "A. C. Cem", ""], ["D'Alessandro", "Flavio", ""]]}]