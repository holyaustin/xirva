[{"id": "1810.00544", "submitter": "Thibault Godin", "authors": "J\\'er\\'emie Brieussel (IMAG), Thibault Godin (IMAG, IECL), Bijan\n  Mohammadi (IMAG)", "title": "Numerical upper bounds on growth of automata groups", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The growth of a finitely generated group is an important geometric invariant\nwhich has been studied for decades. It can be either polynomial, for a\nwell-understood class of groups, or exponential, for most groups studied by\ngeometers, or intermediate, that is between polynomial and exponential. Despite\nrecent spectacular progresses, the class of groups with intermediate growth\nremains largely mysterious. Many examples of such groups are constructed using\nMealy automata. The aim of this paper is to give an algorithmic procedure to\nstudy the growth of such automata groups, and more precisely to provide\nnumerical upper bounds on their exponents. Our functions retrieve known optimal\nbounds on the famous first Grigorchuk group. They also improve known upper\nbounds on other automata groups and permitted us to discover several new\nexamples of automata groups of intermediate growth. All the algorithms\ndescribed are implemented in GAP, a language dedicated to computational group\ntheory.\n", "versions": [{"version": "v1", "created": "Mon, 1 Oct 2018 06:27:56 GMT"}], "update_date": "2018-10-02", "authors_parsed": [["Brieussel", "J\u00e9r\u00e9mie", "", "IMAG"], ["Godin", "Thibault", "", "IMAG, IECL"], ["Mohammadi", "Bijan", "", "IMAG"]]}, {"id": "1810.01351", "submitter": "Elena Guti\\'errez Viedma", "authors": "Pierre Ganty and Elena Guti\\'errez", "title": "The Parikh Property for Weighted Context-Free Grammars", "comments": "29 pages, 2 figures, long version of FSTTCS'18 paper", "journal-ref": null, "doi": "10.4230/LIPIcs.FSTTCS.2018", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parikh's Theorem states that every context-free grammar (CFG) is equivalent\nto some regular CFG when the ordering of symbols in the words is ignored. The\nsame is not true for the so-called weighted CFGs, which additionally assign a\nweight to each grammar rule. If the result holds for a given weighted CFG $G$,\nwe say that $G$ satisfies the Parikh property. We prove constructively that the\nParikh property holds for every weighted nonexpansive CFG. We also give a\ndecision procedure for the property when the weights are over the rationals.\n", "versions": [{"version": "v1", "created": "Tue, 2 Oct 2018 16:22:27 GMT"}, {"version": "v2", "created": "Thu, 27 Dec 2018 14:49:19 GMT"}, {"version": "v3", "created": "Wed, 19 Jun 2019 01:24:47 GMT"}], "update_date": "2019-06-20", "authors_parsed": [["Ganty", "Pierre", ""], ["Guti\u00e9rrez", "Elena", ""]]}, {"id": "1810.02182", "submitter": "Gabriele Fici", "authors": "Giuseppa Castiglione, Gabriele Fici, Antonio Restivo", "title": "On Sets of Words of Rank Two", "comments": "Antonio Restivo's invited paper at WORDS 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a (finite or infinite) subset $X$ of the free monoid $A^*$ over a\nfinite alphabet $A$, the rank of $X$ is the minimal cardinality of a set $F$\nsuch that $X \\subseteq F^*$. A submonoid $M$ generated by $k$ elements of $A^*$\nis $k$-maximal if there does not exist another submonoid generated by at most\n$k$ words containing $M$. We call a set $X \\subseteq A^*$ primitive if it is\nthe basis of a $|X|$-maximal submonoid. This extends the notion of primitive\nword: indeed, $\\{w\\}$ is a primitive set if and only if $w$ is a primitive\nword.\n  By definition, for any set $X$, there exists a primitive set $Y$ such that $X\n\\subseteq Y^*$. The set $Y$ is therefore called a primitive root of $X$. As a\nmain result, we prove that if a set has rank $2$, then it has a unique\nprimitive root. This result cannot be extended to sets of rank larger than 2.\n  For a single word $w$, we say that the set $\\{x,y\\}$ is a {\\em binary root}\nof $w$ if $w$ can be written as a concatenation of copies of $x$ and $y$ and\n$\\{x,y\\}$ is a primitive set. We prove that every primitive word $w$ has at\nmost one binary root $\\{x,y\\}$ such that $|x|+|y|<\\sqrt{|w|}$. That is, the\nbinary root of a word is unique provided the length of the word is sufficiently\nlarge with respect to the size of the root.\n  Our results are also compared to previous approaches that investigate\npseudo-repetitions, where a morphic involutive function $\\theta$ is defined on\n$A^*$. In this setting, the notions of $\\theta$-power, $\\theta$-primitive and\n$\\theta$-root are defined, and it is shown that any word has a unique\n$\\theta$-primitive root. This result can be obtained with our approach by\nshowing that a word $w$ is $\\theta$-primitive if and only if $\\{w, \\theta(w)\\}$\nis a primitive set.\n", "versions": [{"version": "v1", "created": "Thu, 4 Oct 2018 12:57:26 GMT"}, {"version": "v2", "created": "Fri, 7 Jun 2019 10:06:26 GMT"}], "update_date": "2019-06-10", "authors_parsed": [["Castiglione", "Giuseppa", ""], ["Fici", "Gabriele", ""], ["Restivo", "Antonio", ""]]}, {"id": "1810.02471", "submitter": "EPTCS", "authors": "Alexandre Mansard (LIM - University of La R\\'eunion)", "title": "Unfolding of Finite Concurrent Automata", "comments": "In Proceedings ICE 2018, arXiv:1810.02053", "journal-ref": "EPTCS 279, 2018, pp. 68-84", "doi": "10.4204/EPTCS.279.8", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider recognizable trace rewriting systems with level-regular contexts\n(RTL). A trace language is level-regular if the set of Foata normal forms of\nits elements is regular. We prove that the rewriting graph of a RTL is\nword-automatic. Thus its first-order theory is decidable. Then, we prove that\nthe concurrent unfolding of a finite concurrent automaton with the reachability\nrelation is a RTL graph. It follows that the first-order theory with the\nreachability predicate (FO[Reach] theory) of such an unfolding is decidable. It\nis known that this property holds also for the ground term rewriting graphs. We\nprovide examples of finite concurrent automata of which the concurrent\nunfoldings fail to be ground term rewriting graphs. The infinite grid tree (for\neach vertex of an infinite grid, there is an edge from this vertex to the\norigin of a copy of the infinite grid) is such an unfolding. We prove that the\ninfinite grid tree is not a ground term rewriting graph. We have thus obtained\na new class of graphs for with a decidable FO[Reach] theory.\n", "versions": [{"version": "v1", "created": "Fri, 5 Oct 2018 00:35:24 GMT"}], "update_date": "2018-10-08", "authors_parsed": [["Mansard", "Alexandre", "", "LIM - University of La R\u00e9union"]]}, {"id": "1810.02953", "submitter": "Philippe Schnoebelen", "authors": "Simon Halfon and Philippe Schnoebelen", "title": "On shuffle products, acyclic automata and piecewise-testable languages", "comments": null, "journal-ref": "Information Processing Letters, 145:68-73, 2019", "doi": "10.1016/j.ipl.2019.01.012", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that the shuffle $L \\unicode{x29E2} F$ of a piecewise-testable\nlanguage $L$ and a finite language $F$ is piecewise-testable. The proof relies\non a classic but little-used automata-theoretic characterization of\npiecewise-testable languages. We also discuss some mild generalizations of the\nmain result, and provide bounds on the piecewise complexity of $L\n\\unicode{x29E2} F$.\n", "versions": [{"version": "v1", "created": "Sat, 6 Oct 2018 07:55:43 GMT"}, {"version": "v2", "created": "Fri, 1 Feb 2019 21:13:00 GMT"}], "update_date": "2019-02-05", "authors_parsed": [["Halfon", "Simon", ""], ["Schnoebelen", "Philippe", ""]]}, {"id": "1810.03395", "submitter": "J\\'er\\'emie Chalopin", "authors": "J\\'er\\'emie Chalopin and Victor Chepoi", "title": "1-Safe Petri nets and special cube complexes: equivalence and\n  applications", "comments": null, "journal-ref": null, "doi": "10.1145/3322095", "report-no": null, "categories": "cs.LO cs.DM cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Nielsen, Plotkin, and Winskel (1981) proved that every 1-safe Petri net $N$\nunfolds into an event structure $\\mathcal{E}_N$. By a result of Thiagarajan\n(1996 and 2002), these unfoldings are exactly the trace regular event\nstructures. Thiagarajan (1996 and 2002) conjectured that regular event\nstructures correspond exactly to trace regular event structures. In a recent\npaper (Chalopin and Chepoi, 2017, 2018), we disproved this conjecture, based on\nthe striking bijection between domains of event structures, median graphs, and\nCAT(0) cube complexes. On the other hand, in Chalopin and Chepoi (2018) we\nproved that Thiagarajan's conjecture is true for regular event structures whose\ndomains are principal filters of universal covers of (virtually) finite special\ncube complexes.\n  In the current paper, we prove the converse: to any finite 1-safe Petri net\n$N$ one can associate a finite special cube complex ${X}_N$ such that the\ndomain of the event structure $\\mathcal{E}_N$ (obtained as the unfolding of\n$N$) is a principal filter of the universal cover $\\widetilde{X}_N$ of $X_N$.\nThis establishes a bijection between 1-safe Petri nets and finite special cube\ncomplexes and provides a combinatorial characterization of trace regular event\nstructures.\n  Using this bijection and techniques from graph theory and geometry (MSO\ntheory of graphs, bounded treewidth, and bounded hyperbolicity) we disprove yet\nanother conjecture by Thiagarajan (from the paper with S. Yang from 2014) that\nthe monadic second order logic of a 1-safe Petri net is decidable if and only\nif its unfolding is grid-free.\n  Our counterexample is the trace regular event structure $\\mathcal{\\dot E}_Z$\nwhich arises from a virtually special square complex $\\dot Z$. The domain of\n$\\mathcal{\\dot E}_Z$ is grid-free (because it is hyperbolic), but the MSO\ntheory of the event structure $\\mathcal{\\dot E}_Z$ is undecidable.\n", "versions": [{"version": "v1", "created": "Mon, 8 Oct 2018 12:15:45 GMT"}, {"version": "v2", "created": "Wed, 24 Apr 2019 12:39:24 GMT"}], "update_date": "2019-08-12", "authors_parsed": [["Chalopin", "J\u00e9r\u00e9mie", ""], ["Chepoi", "Victor", ""]]}, {"id": "1810.03515", "submitter": "Emmanuel Filiot", "authors": "Emmanuel Filiot and Nicolas Mazzocchi and Jean-Fran\\c{c}ois Raskin", "title": "A Pattern Logic for Automata with Outputs", "comments": "Published in the proceedings of DLT'18", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a logic to express structural properties of automata with string\ninputs and, possibly, outputs in some monoid. In this logic, the set of\npredicates talking about the output values is parametric, and we provide\nsufficient conditions on the predicates under which the model-checking problem\nis decidable. We then consider three particular automata models (finite\nautomata, transducers and automata weighted by integers -- sum-automata --) and\ninstantiate the generic logic for each of them. We give tight complexity\nresults for the three logics and the model-checking problem, depending on\nwhether the formula is fixed or not. We study the expressiveness of our logics\nby expressing classical structural patterns characterising for instance finite\nambiguity and polynomial ambiguity in the case of finite automata,\ndeterminisability and finite-valuedness in the case of transducers and\nsum-automata. Consequently to our complexity results, we directly obtain that\nthese classical properties can be decided in PTIME.\n", "versions": [{"version": "v1", "created": "Mon, 8 Oct 2018 15:02:22 GMT"}], "update_date": "2018-10-09", "authors_parsed": [["Filiot", "Emmanuel", ""], ["Mazzocchi", "Nicolas", ""], ["Raskin", "Jean-Fran\u00e7ois", ""]]}, {"id": "1810.04893", "submitter": "Oliviero Riganelli", "authors": "Oliviero Riganelli, Daniela Micucci, Leonardo Mariani", "title": "Increasing the Reusability of Enforcers with Lifecycle Events", "comments": "International Symposium On Leveraging Applications of Formal Methods,\n  Verification and Validation (ISoLA'18) [Invited Talk Paper]", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Runtime enforcement can be effectively used to improve the reliability of\nsoftware applications. However, it often requires the definition of ad hoc\npolicies and enforcement strategies, which might be expensive to identify and\nimplement. This paper discusses how to exploit lifecycle events to obtain\nuseful enforcement strategies that can be easily reused across applications,\nthus reducing the cost of adoption of the runtime enforcement technology. The\npaper finally sketches how this idea can be used to define libraries that can\nautomatically overcome problems related to applications misusing them.\n", "versions": [{"version": "v1", "created": "Thu, 11 Oct 2018 08:28:45 GMT"}], "update_date": "2020-10-14", "authors_parsed": [["Riganelli", "Oliviero", ""], ["Micucci", "Daniela", ""], ["Mariani", "Leonardo", ""]]}, {"id": "1810.07285", "submitter": "Shankara Narayanan Krishna", "authors": "Paul Gastin and Shankara Narayanan Krishna", "title": "Unambiguous Forest Factorization", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we look at an unambiguous version of Simon's forest\nfactorization theorem, a very deep result which has wide connections in\nalgebra, logic and automata. Given a morphism $\\varphi$ from $\\Sigma^+$ to a\nfinite semigroup $S$, we construct a universal, unambiguous automaton A which\nis \"good\" for $\\varphi$. The goodness of $\\Aa$ gives a very easy proof for the\nforest factorization theorem, providing a Ramsey split for any word in\n$\\Sigma^{\\infty}$ such that the height of the Ramsey split is bounded by the\nnumber of states of A. An important application of synthesizing good automata\nfrom the morphim $\\varphi$ is in the construction of regular transducer\nexpressions (RTE) corresponding to deterministic two way transducers.\n", "versions": [{"version": "v1", "created": "Wed, 3 Oct 2018 15:36:34 GMT"}], "update_date": "2018-10-18", "authors_parsed": [["Gastin", "Paul", ""], ["Krishna", "Shankara Narayanan", ""]]}, {"id": "1810.08760", "submitter": "Miko{\\l}aj Boja\\'nczyk", "authors": "Miko{\\l}aj Boja\\'nczyk", "title": "Polyregular Functions", "comments": "95 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper is about certain string-to-string functions, called the\npolyregular functions. These are like the regular string-to-string functions,\nexcept that they can have polynomial (and not just linear) growth. The class\nhas four equivalent definitions: 1. deterministic two-way transducers with\npebbles; 2 the smallest class of string-to-string functions that is closed\nunder composition, contains all sequential functions as well as two extra\nfunctions called squaring and iterated reverse 3. a fragment of the\nlambda-calculus, which has a list type constructor and limited forms of\niteration such as map but not fold; 4. an imperative programming language,\nwhich has for loops that range over input positions.\n  The first definition comes from [milo2003typechecking], while the remaining\nthree are new to the author's best knowledge. The class of polyregular\nfunctions contains known classes of string-to-string transducers, such as the\nsequential, rational, or regular ones, but goes beyond them because of\nsuper-linear growth. Polyregular functions have good algorithmic properties,\nsuch as: - the output can be computed in linear time (in terms of combined\ninput and output size); - the inverse image of a regular word language is\n(effectively) regular.\n  We also identify a fragment of polyregular functions, called the first-order\npolyregular functions, which has additional good properties, e.g. the output\ncan be computed by an AC0 circuit.\n", "versions": [{"version": "v1", "created": "Sat, 20 Oct 2018 06:40:43 GMT"}], "update_date": "2018-10-23", "authors_parsed": [["Boja\u0144czyk", "Miko\u0142aj", ""]]}, {"id": "1810.09287", "submitter": "Marc  Zeitoun", "authors": "Thomas Place and Marc Zeitoun", "title": "The complexity of separation for levels in concatenation hierarchies", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the complexity of the separation problem associated to classes\nof regular languages. For a class C, C-separation takes two regular languages\nas input and asks whether there exists a third language in C which includes the\nfirst and is disjoint from the second. First, in contrast with the situation\nfor the classical membership problem, we prove that for most classes C, the\ncomplexity of C-separation does not depend on how the input languages are\nrepresented: it is the same for nondeterministic finite automata and monoid\nmorphisms. Then, we investigate specific classes belonging to finitely based\nconcatenation hierarchies. It was recently proved that the problem is always\ndecidable for levels 1/2 and 1 of any such hierarchy (with inefficient\nalgorithms). Here, we build on these results to show that when the alphabet is\nfixed, there are polynomial time algorithms for both levels. Finally, we\ninvestigate levels 3/2 and 2 of the famous Straubing-Th\\'erien hierarchy. We\nshow that separation is PSPACE-complete for level 3/2 and between PSPACE-hard\nand EXPTIME for level 2.\n", "versions": [{"version": "v1", "created": "Mon, 22 Oct 2018 13:49:34 GMT"}], "update_date": "2018-10-23", "authors_parsed": [["Place", "Thomas", ""], ["Zeitoun", "Marc", ""]]}, {"id": "1810.09351", "submitter": "Masaki Waga", "authors": "Masaki Waga, Ichiro Hasuo, Kohei Suenaga", "title": "MONAA: A Tool for Timed Pattern Matching with Automata-Based\n  Acceleration", "comments": "Published in: 2018 IEEE Workshop on Monitoring and Testing of\n  Cyber-Physical Systems (MT-CPS)", "journal-ref": null, "doi": "10.1109/MT-CPS.2018.00014", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present monaa, a monitoring tool over a real-time property specified by\neither a timed automaton or a timed regular expression. It implements a timed\npattern matching algorithm that combines 1) features suited for online\nmonitoring, and 2) acceleration by automata-based skipping. Our experiments\ndemonstrate monaa's performance advantage, especially in online usage.\n", "versions": [{"version": "v1", "created": "Mon, 22 Oct 2018 15:13:00 GMT"}], "update_date": "2018-10-23", "authors_parsed": [["Waga", "Masaki", ""], ["Hasuo", "Ichiro", ""], ["Suenaga", "Kohei", ""]]}, {"id": "1810.09633", "submitter": "Masaki Waga", "authors": "Masaki Waga and Ichiro Hasuo", "title": "Moore-Machine Filtering for Timed and Untimed Pattern Matching", "comments": "Accepted for presentation at EMSOFT 2018 and for publication in IEEE\n  Transactions on Computer-Aided Design of Integrated Circuits and Systems\n  (TCAD) as part of the ESWEEK-TCAD special issue", "journal-ref": "IEEE Transactions on Computer-Aided Design of Integrated Circuits\n  and Systems ( Volume: 37 , Issue: 11 , Nov. 2018 )", "doi": "10.1109/TCAD.2018.2857358", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Monitoring is an important body of techniques in runtime verification of\nreal-time, embedded, and cyber-physical systems. Mathematically, the monitoring\nproblem can be formalized as a pattern matching problem against a pattern\nautomaton. Motivated by the needs in embedded applications---especially the\nlimited channel capacity between a sensor unit and a processor that\nmonitors---we pursue the idea of filtering as preprocessing for monitoring.\nTechnically, for a given pattern automaton, we present a construction of a\nMoore machine that works as a filter. The construction is automata-theoretic,\nand we find the use of Moore machines particularly suited for embedded\napplications, not only because their sequential operation is relatively cheap\nbut also because they are amenable to hardware acceleration by dedicated\ncircuits. We prove soundness (i.e., absence of lost matches), too. We work in\ntwo settings: in the untimed one, a pattern is an NFA; in the timed one, a\npattern is a timed automaton. The extension of our untimed construction to the\ntimed setting is technically involved, but our experiments demonstrate its\npractical benefits.\n", "versions": [{"version": "v1", "created": "Tue, 23 Oct 2018 02:46:01 GMT"}, {"version": "v2", "created": "Thu, 11 Jul 2019 04:11:42 GMT"}], "update_date": "2019-07-12", "authors_parsed": [["Waga", "Masaki", ""], ["Hasuo", "Ichiro", ""]]}, {"id": "1810.10826", "submitter": "Thorsten Wissmann", "authors": "Andrei Stefanescu, Stefan Ciobaca, Radu Mereuta, Brandon Moore, Traian\n  Florin Serbanuta, and Grigore Rosu", "title": "All-Path Reachability Logic", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 2 (April 30,\n  2019) lmcs:5408", "doi": "10.23638/LMCS-15(2:5)2019", "report-no": null, "categories": "cs.PL cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper presents a language-independent proof system for reachability\nproperties of programs written in non-deterministic (e.g., concurrent)\nlanguages, referred to as all-path reachability logic. It derives\npartial-correctness properties with all-path semantics (a state satisfying a\ngiven precondition reaches states satisfying a given postcondition on all\nterminating execution paths). The proof system takes as axioms any\nunconditional operational semantics, and is sound (partially correct) and\n(relatively) complete, independent of the object language. The soundness has\nalso been mechanized in Coq. This approach is implemented in a tool for\nsemantics-based verification as part of the K framework (http://kframework.org)\n", "versions": [{"version": "v1", "created": "Thu, 25 Oct 2018 10:49:00 GMT"}, {"version": "v2", "created": "Mon, 29 Apr 2019 08:18:13 GMT"}], "update_date": "2019-09-04", "authors_parsed": [["Stefanescu", "Andrei", ""], ["Ciobaca", "Stefan", ""], ["Mereuta", "Radu", ""], ["Moore", "Brandon", ""], ["Serbanuta", "Traian Florin", ""], ["Rosu", "Grigore", ""]]}, {"id": "1810.11081", "submitter": "Rigo Michel", "authors": "Adeline Massuir, Jarkko Peltom\\\"aki, Michel Rigo", "title": "Automatic sequences based on Parry or Bertrand numeration systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the factor complexity and closure properties of automatic sequences\nbased on Parry or Bertrand numeration systems. These automatic sequences can be\nviewed as generalizations of the more typical $k$-automatic sequences and\nPisot-automatic sequences. We show that, like $k$-automatic sequences,\nParry-automatic sequences have sublinear factor complexity while there exist\nBertrand-automatic sequences with superlinear factor complexity. We prove that\nthe set of Parry-automatic sequences with respect to a fixed Parry numeration\nsystem is not closed under taking images by uniform substitutions or periodic\ndeletion of letters. These closure properties hold for $k$-automatic sequences\nand Pisot-automatic sequences, so our result shows that these properties are\nlost when generalizing to Parry numeration systems and beyond. Moreover, we\nshow that a multidimensional sequence is $U$-automatic with respect to a\npositional numeration system $U$ with regular language of numeration if and\nonly if its $U$-kernel is finite.\n", "versions": [{"version": "v1", "created": "Thu, 25 Oct 2018 19:36:01 GMT"}], "update_date": "2018-10-29", "authors_parsed": [["Massuir", "Adeline", ""], ["Peltom\u00e4ki", "Jarkko", ""], ["Rigo", "Michel", ""]]}, {"id": "1810.11243", "submitter": "EPTCS", "authors": "Mathias Ruggaard Pedersen (Aalborg University), Giorgio Bacci (Aalborg\n  University), Kim Guldstrand Larsen (Aalborg University)", "title": "A Faster-Than Relation for Semi-Markov Decision Processes", "comments": "In Proceedings QAPL 2019, arXiv:2001.06163", "journal-ref": "EPTCS 312, 2020, pp. 29-42", "doi": "10.4204/EPTCS.312.3", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  When modeling concurrent or cyber-physical systems, non-functional\nrequirements such as time are important to consider. In order to improve the\ntiming aspects of a model, it is necessary to have some notion of what it means\nfor a process to be faster than another, which can guide the stepwise\nrefinement of the model. To this end we study a faster-than relation for\nsemi-Markov decision processes and compare it to standard notions for relating\nsystems. We consider the compositional aspects of this relation, and show that\nthe faster-than relation is not a precongruence with respect to parallel\ncomposition, hence giving rise to so-called parallel timing anomalies. We take\nthe first steps toward understanding this problem by identifying decidable\nconditions sufficient to avoid parallel timing anomalies in the absence of\nnon-determinism.\n", "versions": [{"version": "v1", "created": "Fri, 26 Oct 2018 10:09:18 GMT"}, {"version": "v2", "created": "Mon, 20 Jan 2020 02:17:43 GMT"}], "update_date": "2020-01-22", "authors_parsed": [["Pedersen", "Mathias Ruggaard", "", "Aalborg University"], ["Bacci", "Giorgio", "", "Aalborg\n  University"], ["Larsen", "Kim Guldstrand", "", "Aalborg University"]]}, {"id": "1810.11323", "submitter": "Costanza Catalano", "authors": "Costanza Catalano and Rapha\\\"el M. Jungers", "title": "On random primitive sets, directable NDFAs and the generation of slowly\n  synchronizing DFAs", "comments": "31 pages, 9 figures. arXiv admin note: text overlap with\n  arXiv:1805.06723", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.PR", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We tackle the problem of the randomized generation of slowly synchronizing\ndeterministic automata (DFAs) by generating random primitive sets of matrices.\nWe show that when the randomized procedure is too simple the exponent of the\ngenerated sets is O(n log n) with high probability, thus the procedure fails to\nreturn DFAs with large reset threshold. We extend this result to random\nnondeterministic automata (NDFAs) by showing, in particular, that a uniformly\nsampled NDFA has both a 2-directing word and a 3-directing word of length O(n\nlog n) with high probability. We then present a more involved randomized\nalgorithm that manages to generate DFAs with large reset threshold and we\nfinally leverage this finding for exhibiting new families of DFAs with reset\nthreshold of order $ \\Omega(n^2/4) $.\n", "versions": [{"version": "v1", "created": "Wed, 24 Oct 2018 21:49:15 GMT"}], "update_date": "2018-10-29", "authors_parsed": [["Catalano", "Costanza", ""], ["Jungers", "Rapha\u00ebl M.", ""]]}, {"id": "1810.12095", "submitter": "Amandeep Bhatia", "authors": "Amandeep Singh Bhatia and Ajay Kumar", "title": "On the Power of Quantum Queue Automata in Real-time", "comments": "9 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposed a quantum analogue of classical queue automata by using\nthe definition of the quantum Turing machine and quantum finite-state automata.\nHowever, quantum automata equipped with storage medium of a stack has been\nconsidered, but the concept of quantum queue automata has not been introduced\nso far. The classical Turing machines can be simulated by classical queue\nautomata. Motivated by the efficiency of the quantum Turing machine and nature\nof classical queue automata, we have introduced the notion of quantum queue\nautomata using unitary criteria. Our contributions are as follows. We have also\nintroduced a generalization of real-time deterministic queue automata, the\nreal-time quantum queue automata which work in real-time i.e. the input head\ncan move towards the right direction only and takes exactly one step per input\nsymbol. We have shown that real-time quantum queue automata is more superior\nthan its real-time classical variants by using quantum transitions. We have\nproved the existence of the language that can be recognized by real-time\nquantum queue automata and cannot be recognized by real-time deterministic\n(reversible) queue automata. Further, we have shown that there is a language\nthat can be recognized by real-time quantum queue automata but not by real-time\nnon-deterministic queue automata.\n", "versions": [{"version": "v1", "created": "Mon, 29 Oct 2018 13:22:28 GMT"}], "update_date": "2018-10-30", "authors_parsed": [["Bhatia", "Amandeep Singh", ""], ["Kumar", "Ajay", ""]]}, {"id": "1810.12266", "submitter": "Adam Lopez", "authors": "Ieva Vasiljeva, Sorcha Gilroy, Adam Lopez", "title": "The problem with probabilistic DAG automata for semantic graphs", "comments": "To appear in NAACL-HLT 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Semantic representations in the form of directed acyclic graphs (DAGs) have\nbeen introduced in recent years, and to model them, we need probabilistic\nmodels of DAGs. One model that has attracted some attention is the DAG\nautomaton, but it has not been studied as a probabilistic model. We show that\nsome DAG automata cannot be made into useful probabilistic models by the nearly\nuniversal strategy of assigning weights to transitions. The problem affects\nsingle-rooted, multi-rooted, and unbounded-degree variants of DAG automata, and\nappears to be pervasive. It does not affect planar variants, but these are\nproblematic for other reasons.\n", "versions": [{"version": "v1", "created": "Mon, 29 Oct 2018 17:24:57 GMT"}, {"version": "v2", "created": "Sat, 6 Apr 2019 14:41:39 GMT"}], "update_date": "2019-04-09", "authors_parsed": [["Vasiljeva", "Ieva", ""], ["Gilroy", "Sorcha", ""], ["Lopez", "Adam", ""]]}, {"id": "1810.12275", "submitter": "Gabriele Fici", "authors": "Gabriele Fici and Mickael Postic and Manuel Silva", "title": "Abelian Anti-Powers in Infinite Words", "comments": "To appear in Advances in Applied Mathematics", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An abelian anti-power of order $k$ (or simply an abelian $k$-anti-power) is a\nconcatenation of $k$ consecutive words of the same length having pairwise\ndistinct Parikh vectors. This definition generalizes to the abelian setting the\nnotion of a $k$-anti-power, as introduced in [G. Fici et al., Anti-powers in\ninfinite words, J. Comb. Theory, Ser. A, 2018], that is a concatenation of $k$\npairwise distinct words of the same length. We aim to study whether a word\ncontains abelian $k$-anti-powers for arbitrarily large $k$. S. Holub proved\nthat all paperfolding words contain abelian powers of every order [Abelian\npowers in paper-folding words. J. Comb. Theory, Ser. A, 2013]. We show that\nthey also contain abelian anti-powers of every order.\n", "versions": [{"version": "v1", "created": "Mon, 29 Oct 2018 17:43:12 GMT"}, {"version": "v2", "created": "Mon, 25 Mar 2019 17:35:44 GMT"}], "update_date": "2019-03-26", "authors_parsed": [["Fici", "Gabriele", ""], ["Postic", "Mickael", ""], ["Silva", "Manuel", ""]]}, {"id": "1810.12415", "submitter": "\\\"Ozlem Salehi", "authors": "\\\"Ozlem Salehi, Flavio D'Alessandro, A. C. Cem Say", "title": "Language Classes Associated With Automata Over Matrix Groups", "comments": "Accepted to RAIRO-ITA, long version of arXiv:1609.00396", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the language classes recognized by group automata over matrix\ngroups. For the case of $2 \\times 2 $ matrices, we prove that the corresponding\ngroup automata for rational matrix groups are more powerful than the\ncorresponding group automata for integer matrix groups. Finite automata over\nsome special matrix groups, such as the discrete Heisenberg group and the\nBaumslag-Solitar group are also examined. We also introduce the notion of time\ncomplexity for group automata and demonstrate some separations among related\nclasses. The case of linear-time bounds is examined in detail throughout our\nrepertory of matrix group automata.\n", "versions": [{"version": "v1", "created": "Mon, 29 Oct 2018 21:24:14 GMT"}, {"version": "v2", "created": "Wed, 14 Nov 2018 21:00:39 GMT"}], "update_date": "2018-11-16", "authors_parsed": [["Salehi", "\u00d6zlem", ""], ["D'Alessandro", "Flavio", ""], ["Say", "A. C. Cem", ""]]}, {"id": "1810.12731", "submitter": "Silke Czarnetzki", "authors": "Silke Czarnetzki, Andreas Krebs, Klaus-J\\\"orn Lange", "title": "Visibly Pushdown Languages and Free Profinite Algebras", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We build a notion of algebraic recognition for visibly pushdown languages by\nfinite algebraic objects. These come with a typical Eilenberg relationship, now\nbetween classes of visibly pushdown languages and classes of finite algebras.\nBuilding on that algebraic foundation, we further construct a topological\nobject with one purpose being the possibility to derive a notion of equations,\nthrough which it is possible to prove that some given visibly pushdown language\nis not part of a certain class (or to even show decidability of the\nmembership-problem of the class in some cases). In particular, we obtain a\nspecial instance of Reiterman's theorem for pseudo-varieties. These findings\nare then employed on two subclasses of the visibly pushdown languages, for\nwhich we derive concrete sets of equations. For some showcase languages, these\nequations are utilised to prove non-membership to the previously described\nclasses.\n", "versions": [{"version": "v1", "created": "Tue, 30 Oct 2018 13:47:44 GMT"}], "update_date": "2018-10-31", "authors_parsed": [["Czarnetzki", "Silke", ""], ["Krebs", "Andreas", ""], ["Lange", "Klaus-J\u00f6rn", ""]]}, {"id": "1810.13087", "submitter": "Necmiye Ozay", "authors": "Yunus Emre Sahin and Petter Nilsson and Necmiye Ozay", "title": "Multirobot Coordination with Counting Temporal Logics", "comments": "Under submission for a journal", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.RO cs.FL cs.SY math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In many multirobot applications, planning trajectories in a way to guarantee\nthat the collective behavior of the robots satisfies a certain high-level\nspecification is crucial. Motivated by this problem, we introduce counting\ntemporal logics---formal languages that enable concise expression of multirobot\ntask specifications over possibly infinite horizons. We first introduce a\ngeneral logic called counting linear temporal logic plus (cLTL+), and propose\nan optimization-based method that generates individual trajectories such that\nsatisfaction of a given cLTL+ formula is guaranteed when these trajectories are\nsynchronously executed. We then introduce a fragment of cLTL+, called counting\nlinear temporal logic (cLTL), and show that a solution to planning problem with\ncLTL constraints can be obtained more efficiently if all robots have identical\ndynamics. In the second part of the paper, we relax the synchrony assumption\nand discuss how to generate trajectories that can be asynchronously executed,\nwhile preserving the satisfaction of the desired cLTL+ specification. In\nparticular, we show that when the asynchrony between robots is bounded, the\nmethod presented in this paper can be modified to generate robust trajectories.\nWe demonstrate these ideas with an experiment and provide numerical results\nthat showcase the scalability of the method.\n", "versions": [{"version": "v1", "created": "Wed, 31 Oct 2018 03:08:13 GMT"}], "update_date": "2018-11-01", "authors_parsed": [["Sahin", "Yunus Emre", ""], ["Nilsson", "Petter", ""], ["Ozay", "Necmiye", ""]]}, {"id": "1810.13153", "submitter": "Philipp Schlicht", "authors": "Sanjay Jain, Bakhadyr Khoussainov, Philipp Schlicht, Frank Stephan", "title": "The isomorphism problem for tree-automatic ordinals with addition", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies tree-automatic ordinals (or equivalently, well-founded\nlinearly ordered sets) together with the ordinal addition operation +.\nInformally, these are ordinals such that their elements are coded by finite\ntrees for which the linear order relation of the ordinal and the ordinal\naddition operation can be determined by tree automata. We describe an algorithm\nthat, given two tree-automatic ordinals with the ordinal addition operation,\ndecides if the ordinals are isomorphic.\n", "versions": [{"version": "v1", "created": "Wed, 31 Oct 2018 08:34:37 GMT"}, {"version": "v2", "created": "Wed, 20 Mar 2019 10:36:34 GMT"}], "update_date": "2019-03-21", "authors_parsed": [["Jain", "Sanjay", ""], ["Khoussainov", "Bakhadyr", ""], ["Schlicht", "Philipp", ""], ["Stephan", "Frank", ""]]}]