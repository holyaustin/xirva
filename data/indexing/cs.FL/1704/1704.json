[{"id": "1704.03275", "submitter": "Bruno Woltzenlogel Paleo", "authors": "Daniyar Itegulov, John Slaney, Bruno Woltzenlogel Paleo", "title": "Scavenger 0.1: A Theorem Prover Based on Conflict Resolution", "comments": "Published at CADE 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  This paper introduces Scavenger, the first theorem prover for pure\nfirst-order logic without equality based on the new conflict resolution\ncalculus. Conflict resolution has a restricted resolution inference rule that\nresembles (a first-order generalization of) unit propagation as well as a rule\nfor assuming decision literals and a rule for deriving new clauses by (a\nfirst-order generalization of) conflict-driven clause learning.\n", "versions": [{"version": "v1", "created": "Tue, 11 Apr 2017 13:11:57 GMT"}, {"version": "v2", "created": "Tue, 31 Oct 2017 09:09:33 GMT"}], "update_date": "2017-11-01", "authors_parsed": [["Itegulov", "Daniyar", ""], ["Slaney", "John", ""], ["Paleo", "Bruno Woltzenlogel", ""]]}, {"id": "1704.03730", "submitter": "Michael Vyalyi", "authors": "Alexander A. Rubtsov and Mikhail N. Vyalyi", "title": "On computational complexity of Set Automata", "comments": "31 pages, an extended version of the conference paper (DLT 2017),\n  includes new results and omitted proofs", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider a computational model which is known as set automata.\n  The set automata are one-way finite automata with an additional storage---the\nset. There are two kinds of set automata---the deterministic and the\nnondeterministic ones. We denote them as DSA and NSA respectively. The model\nwas introduced by M. Kutrib, A. Malcher, M. Wendlandt in 2014. It was shown\nthat DSA-languages look similar to DCFL due to their closure properties and\nNSA-languages look similar to CFL due to their undecidability properties.\n  In this paper we show that this similarity is natural: we prove that\nlanguages recognizable by NSA form a rational cone, so as CFL.\n  The main topic of this paper is computational complexity: we prove that\n  - languages recognizable by DSA belong to P and there are P-complete\nlanguages among them;\n  - languages recognizable by NSA are in NP and there are NP-complete languages\namong them;\n  - the word membership problem is P-complete for DSA without epsilon-loops and\nPSPACE-complete for general DSA;\n  - the emptiness problem is in PSPACE for NSA and, moreover, it is\nPSPACE-complete for DSA.\n", "versions": [{"version": "v1", "created": "Wed, 12 Apr 2017 12:42:06 GMT"}, {"version": "v2", "created": "Fri, 27 Oct 2017 06:41:22 GMT"}], "update_date": "2017-10-30", "authors_parsed": [["Rubtsov", "Alexander A.", ""], ["Vyalyi", "Mikhail N.", ""]]}, {"id": "1704.03972", "submitter": "Zhilin Wu", "authors": "Yu-Fang Chen, Ondrej Lengal, Tony Tan, Zhilin Wu", "title": "Register automata with linear arithmetic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a novel automata model over the alphabet of rational numbers,\nwhich we call register automata over the rationals (RA-Q). It reads a sequence\nof rational numbers and outputs another rational number. RA-Q is an extension\nof the well-known register automata (RA) over infinite alphabets, which are\nfinite automata equipped with a finite number of registers/variables for\nstoring values. Like in the standard RA, the RA-Q model allows both equality\nand ordering tests between values. It, moreover, allows to perform linear\narithmetic between certain variables. The model is quite expressive: in\naddition to the standard RA, it also generalizes other well-known models such\nas affine programs and arithmetic circuits.\n  The main feature of RA-Q is that despite the use of linear arithmetic, the\nso-called invariant problem---a generalization of the standard non-emptiness\nproblem---is decidable. We also investigate other natural decision problems,\nnamely, commutativity, equivalence, and reachability. For deterministic RA-Q,\ncommutativity and equivalence are polynomial-time inter-reducible with the\ninvariant problem.\n", "versions": [{"version": "v1", "created": "Thu, 13 Apr 2017 02:20:25 GMT"}, {"version": "v2", "created": "Wed, 17 May 2017 13:13:57 GMT"}], "update_date": "2017-05-18", "authors_parsed": [["Chen", "Yu-Fang", ""], ["Lengal", "Ondrej", ""], ["Tan", "Tony", ""], ["Wu", "Zhilin", ""]]}, {"id": "1704.04047", "submitter": "Fran\\c{c}ois Gonze FG", "authors": "Fran\\c{c}ois Gonze, Vladimir Gusev, Bal\\'azs Gerencs\\'er, Rapha\\\"el M.\n  Jungers, and Mikhail V. Volkov", "title": "On the interplay between Babai and Cerny's conjectures", "comments": "21 pages version with full proofs", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.GR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Motivated by the Babai conjecture and the Cerny conjecture, we study the\nreset thresholds of automata with the transition monoid equal to the full\nmonoid of transformations of the state set. For automata with $n$ states in\nthis class, we prove that the reset thresholds are upper-bounded by $2n^2-6n+5$\nand can attain the value $\\tfrac{n(n-1)}{2}$. In addition, we study diameters\nof the pair digraphs of permutation automata and construct $n$-state\npermutation automata with diameter $\\tfrac{n^2}{4} + o(n^2)$.\n", "versions": [{"version": "v1", "created": "Thu, 13 Apr 2017 09:31:53 GMT"}, {"version": "v2", "created": "Sun, 6 Aug 2017 20:26:45 GMT"}], "update_date": "2017-08-08", "authors_parsed": [["Gonze", "Fran\u00e7ois", ""], ["Gusev", "Vladimir", ""], ["Gerencs\u00e9r", "Bal\u00e1zs", ""], ["Jungers", "Rapha\u00ebl M.", ""], ["Volkov", "Mikhail V.", ""]]}, {"id": "1704.05263", "submitter": "Dennis Nolte", "authors": "Andrea Corradini, Barbara K\\\"onig and Dennis Nolte", "title": "Specifying Graph Languages with Type Graphs", "comments": "(v2): -Fixed some typos -Added more references", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate three formalisms to specify graph languages, i.e. sets of\ngraphs, based on type graphs. First, we are interested in (pure) type graphs,\nwhere the corresponding language consists of all graphs that can be mapped\nhomomorphically to a given type graph. In this context, we also study languages\nspecified by restriction graphs and their relation to type graphs. Second, we\nextend this basic approach to a type graph logic and, third, to type graphs\nwith annotations. We present decidability results and closure properties for\neach of the formalisms.\n", "versions": [{"version": "v1", "created": "Tue, 18 Apr 2017 10:35:46 GMT"}, {"version": "v2", "created": "Fri, 21 Apr 2017 15:57:21 GMT"}], "update_date": "2017-04-24", "authors_parsed": [["Corradini", "Andrea", ""], ["K\u00f6nig", "Barbara", ""], ["Nolte", "Dennis", ""]]}, {"id": "1704.05676", "submitter": "Gerco van Heerdt", "authors": "Gerco van Heerdt, Matteo Sammartino, Alexandra Silva", "title": "CALF: Categorical Automata Learning Framework", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automata learning is a technique that has successfully been applied in\nverification, with the automaton type varying depending on the application\ndomain. Adaptations of automata learning algorithms for increasingly complex\ntypes of automata have to be developed from scratch because there was no\nabstract theory offering guidelines. This makes it hard to devise such\nalgorithms, and it obscures their correctness proofs. We introduce a simple\ncategory-theoretic formalism that provides an appropriately abstract foundation\nfor studying automata learning. Furthermore, our framework establishes formal\nrelations between algorithms for learning, testing, and minimization. We\nillustrate its generality with two examples: deterministic and weighted\nautomata.\n", "versions": [{"version": "v1", "created": "Wed, 19 Apr 2017 10:08:41 GMT"}, {"version": "v2", "created": "Fri, 23 Jun 2017 10:15:35 GMT"}, {"version": "v3", "created": "Mon, 26 Jun 2017 07:27:56 GMT"}], "update_date": "2017-06-27", "authors_parsed": [["van Heerdt", "Gerco", ""], ["Sammartino", "Matteo", ""], ["Silva", "Alexandra", ""]]}, {"id": "1704.06319", "submitter": "Daniel Fremont", "authors": "Daniel J. Fremont, Alexandre Donz\\'e, Sanjit A. Seshia", "title": "Control Improvisation", "comments": "25 pages. Submitted to JACM. This article supersedes arXiv:1411.0698", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We formalize and analyze a new problem in formal language theory termed\ncontrol improvisation. Given a specification language, the problem is to\nproduce an improviser, a probabilistic algorithm that randomly generates words\nin the language, subject to two additional constraints: the satisfaction of a\nquantitative soft constraint, and the exhibition of a specified amount of\nrandomness. Control improvisation has many applications, including for example\nsystematically generating random test vectors satisfying format constraints or\npreconditions while being similar to a library of seed inputs. Other\napplications include robotic surveillance, machine improvisation of music, and\nrandomized variants of the supervisory control problem. We describe a general\nframework for solving the control improvisation problem, and use it to give\nefficient algorithms for several practical classes of instances with finite\nautomaton and context-free grammar specifications. We also provide a detailed\ncomplexity analysis, establishing #P-hardness of the problem in many other\ncases. For these intractable cases, we show how symbolic techniques based on\nBoolean satisfiability (SAT) solvers can be used to find approximate solutions.\nFinally, we discuss an extension of control improvisation to multiple soft\nconstraints that is useful in some applications.\n", "versions": [{"version": "v1", "created": "Thu, 20 Apr 2017 19:55:22 GMT"}], "update_date": "2017-04-24", "authors_parsed": [["Fremont", "Daniel J.", ""], ["Donz\u00e9", "Alexandre", ""], ["Seshia", "Sanjit A.", ""]]}, {"id": "1704.07199", "submitter": "Tobias Kapp\\'e", "authors": "Tobias Kapp\\'e, Paul Brunet, Bas Luttik, Alexandra Silva, Fabio Zanasi", "title": "Brzozowski Goes Concurrent - A Kleene Theorem for Pomset Languages", "comments": "Version 2 incorporates changes prompted by comments of the anonymous\n  referees at CONCUR. Besides minor corrections, this includes additions to the\n  introduction and the discussion section, as well as a proof of Lemma 2.5.\n  Version 3 corrects the accent on the first author's surname in the metadata", "journal-ref": null, "doi": "10.4230/LIPIcs.CONCUR.2017.25", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Concurrent Kleene Algebra (CKA) is a mathematical formalism to study programs\nthat exhibit concurrent behaviour. As with previous extensions of Kleene\nAlgebra, characterizing the free model is crucial in order to develop the\nfoundations of the theory and potential applications. For CKA, this has been an\nopen question for a few years and this paper makes an important step towards an\nanswer. We present a new automaton model and a Kleene-like theorem that relates\na relaxed version of CKA to series-parallel pomset languages, which are a\nnatural candidate for the free model. There are two substantial differences\nwith previous work: from expressions to automata, we use Brzozowski\nderivatives, which enable a direct construction of the automaton; from automata\nto expressions, we provide a syntactic characterization of the automata that\ndenote valid CKA behaviours.\n", "versions": [{"version": "v1", "created": "Mon, 24 Apr 2017 13:03:52 GMT"}, {"version": "v2", "created": "Thu, 31 Aug 2017 16:12:40 GMT"}, {"version": "v3", "created": "Sun, 22 Oct 2017 11:45:33 GMT"}], "update_date": "2017-10-24", "authors_parsed": [["Kapp\u00e9", "Tobias", ""], ["Brunet", "Paul", ""], ["Luttik", "Bas", ""], ["Silva", "Alexandra", ""], ["Zanasi", "Fabio", ""]]}, {"id": "1704.07856", "submitter": "Tom\\'a\\v{s} Masopust", "authors": "Tom\\'a\\v{s} Masopust", "title": "Separability by Piecewise Testable Languages is PTime-Complete", "comments": "Revised version of related results separated from arXiv:1409.3943", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Piecewise testable languages form the first level of the Straubing-Th\\'erien\nhierarchy. The membership problem for this level is decidable and testing if\nthe language of a DFA is piecewise testable is NL-complete. The question has\nnot yet been addressed for NFAs. We fill in this gap by showing that it is\nPSpace-complete. The main result is then the lower-bound complexity of\nseparability of regular languages by piecewise testable languages. Two regular\nlanguages are separable by a piecewise testable language if the piecewise\ntestable language includes one of them and is disjoint from the other. For\nlanguages represented by NFAs, separability by piecewise testable languages is\nknown to be decidable in PTime. We show that it is PTime-hard and that it\nremains PTime-hard even for minimal DFAs.\n", "versions": [{"version": "v1", "created": "Tue, 25 Apr 2017 18:24:50 GMT"}, {"version": "v2", "created": "Fri, 17 Nov 2017 11:15:52 GMT"}], "update_date": "2017-11-20", "authors_parsed": [["Masopust", "Tom\u00e1\u0161", ""]]}, {"id": "1704.07860", "submitter": "Tom\\'a\\v{s} Masopust", "authors": "Tom\\'a\\v{s} Masopust and Markus Kr\\\"otzsch", "title": "Universality of Confluent, Self-Loop Deterministic Partially Ordered\n  NFAs is Hard", "comments": "arXiv admin note: text overlap with arXiv:1609.03460", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An automaton is partially ordered if the only cycles in its transition\ndiagram are self-loops. The expressivity of partially ordered NFAs (poNFAs) can\nbe characterized by the Straubing-Th\\'erien hierarchy. Level 3/2 is recognized\nby poNFAs, level 1 by confluent, self-loop deterministic poNFAs as well as by\nconfluent poDFAs, and level 1/2 by saturated poNFAs. We study the universality\nproblem for confluent, self-loop deterministic poNFAs. It asks whether an\nautomaton accepts all words over its alphabet. Universality for both NFAs and\npoNFAs is a PSpace-complete problem. For confluent, self-loop deterministic\npoNFAs, the complexity drops to coNP-complete if the alphabet is fixed but is\nopen if the alphabet may grow. We solve this problem by showing that it is\nPSpace-complete if the alphabet may grow polynomially. Consequently, our result\nprovides a lower-bound complexity for some other problems, including inclusion,\nequivalence, and $k$-piecewise testability. Since universality for saturated\npoNFAs is easy, confluent, self-loop deterministic poNFAs are the simplest and\nnatural kind of NFAs characterizing a well-known class of languages, for which\ndeciding universality is as difficult as for general NFAs.\n", "versions": [{"version": "v1", "created": "Tue, 25 Apr 2017 18:44:13 GMT"}], "update_date": "2017-04-27", "authors_parsed": [["Masopust", "Tom\u00e1\u0161", ""], ["Kr\u00f6tzsch", "Markus", ""]]}, {"id": "1704.08055", "submitter": "Gerco van Heerdt", "authors": "Gerco van Heerdt and Matteo Sammartino and Alexandra Silva", "title": "Optimizing Automata Learning via Monads", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Automata learning has been successfully applied in the verification of\nhardware and software. The size of the automaton model learned is a bottleneck\nfor scalability, and hence optimizations that enable learning of compact\nrepresentations are important. This paper exploits monads, both as a\nmathematical structure and a programming construct, to design, prove correct,\nand implement a wide class of such optimizations. The former perspective on\nmonads allows us to develop a new algorithm and accompanying correctness\nproofs, building upon a general framework for automata learning based on\ncategory theory. The new algorithm is parametric on a monad, which provides a\nrich algebraic structure to capture non-determinism and other side-effects. We\nshow that our approach allows us to uniformly capture existing algorithms,\ndevelop new ones, and add optimizations. The latter perspective allows us to\neffortlessly translate the theory into practice: we provide a Haskell library\nimplementing our general framework, and we show experimental results for two\nspecific instances: non-deterministic and weighted automata.\n", "versions": [{"version": "v1", "created": "Wed, 26 Apr 2017 11:01:34 GMT"}, {"version": "v2", "created": "Wed, 15 Nov 2017 15:00:20 GMT"}, {"version": "v3", "created": "Fri, 10 Aug 2018 12:47:06 GMT"}, {"version": "v4", "created": "Fri, 1 Nov 2019 16:52:25 GMT"}], "update_date": "2019-11-04", "authors_parsed": [["van Heerdt", "Gerco", ""], ["Sammartino", "Matteo", ""], ["Silva", "Alexandra", ""]]}, {"id": "1704.08233", "submitter": "Marek Szyku{\\l}a", "authors": "Mikhail V. Berlinkov, Robert Ferens, Marek Szyku{\\l}a", "title": "Preimage problems for deterministic finite automata", "comments": null, "journal-ref": "Journal of Computer and System Sciences, 115:214--234, 2021", "doi": "10.1016/j.jcss.2020.08.002", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a subset of states $S$ of a deterministic finite automaton and a word\n$w$, the preimage is the subset of all states mapped to a state in $S$ by the\naction of $w$. We study three natural problems concerning words giving certain\npreimages. The first problem is whether, for a given subset, there exists a\nword \\emph{extending} the subset (giving a larger preimage). The second problem\nis whether there exists a \\emph{totally extending} word (giving the whole set\nof states as a preimage)---equivalently, whether there exists an\n\\emph{avoiding} word for the complementary subset. The third problem is whether\nthere exists a \\emph{resizing} word. We also consider variants where the length\nof the word is upper bounded, where the size of the given subset is restricted,\nand where the automaton is strongly connected, synchronizing, or binary. We\nconclude with a summary of the complexities in all combinations of the cases.\n", "versions": [{"version": "v1", "created": "Wed, 26 Apr 2017 17:38:20 GMT"}, {"version": "v2", "created": "Wed, 25 Apr 2018 09:26:56 GMT"}, {"version": "v3", "created": "Mon, 2 Jul 2018 19:42:25 GMT"}, {"version": "v4", "created": "Sat, 19 Sep 2020 12:16:40 GMT"}], "update_date": "2020-09-22", "authors_parsed": [["Berlinkov", "Mikhail V.", ""], ["Ferens", "Robert", ""], ["Szyku\u0142a", "Marek", ""]]}, {"id": "1704.08752", "submitter": "Holger Petersen", "authors": "Holger Petersen", "title": "Busy Beaver Scores and Alphabet Size", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the Busy Beaver Game introduced by Rado (1962) generalized to\nnon-binary alphabets. Harland (2016) conjectured that activity (number of\nsteps) and productivity (number of non-blank symbols) of candidate machines\ngrow as the alphabet size increases. We prove this conjecture for any alphabet\nsize under the condition that the number of states is sufficiently large. For\nthe measure activity we show that increasing the alphabet size from two to\nthree allows an increase. By a classical construction it is even possible to\nobtain a two-state machine increasing activity and productivity of any machine\nif we allow an alphabet size depending on the number of states of the original\nmachine. We also show that an increase of the alphabet by a factor of three\nadmits an increase of activity.\n", "versions": [{"version": "v1", "created": "Thu, 27 Apr 2017 21:29:44 GMT"}], "update_date": "2017-05-01", "authors_parsed": [["Petersen", "Holger", ""]]}, {"id": "1704.08820", "submitter": "Ulrik Terp Rasmussen", "authors": "Ulrik Terp Rasmussen", "title": "Stream Processing using Grammars and Regular Expressions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this dissertation we study regular expression based parsing and the use of\ngrammatical specifications for the synthesis of fast, streaming\nstring-processing programs.\n  In the first part we develop two linear-time algorithms for regular\nexpression based parsing with Perl-style greedy disambiguation. The first\nalgorithm operates in two passes in a semi-streaming fashion, using a constant\namount of working memory and an auxiliary tape storage which is written in the\nfirst pass and consumed by the second. The second algorithm is a single-pass\nand optimally streaming algorithm which outputs as much of the parse tree as is\nsemantically possible based on the input prefix read so far, and resorts to\nbuffering as many symbols as is required to resolve the next choice. Optimality\nis obtained by performing a PSPACE-complete pre-analysis on the regular\nexpression.\n  In the second part we present Kleenex, a language for expressing\nhigh-performance streaming string processing programs as regular grammars with\nembedded semantic actions, and its compilation to streaming string transducers\nwith worst-case linear-time performance. Its underlying theory is based on\ntransducer decomposition into oracle and action machines, and a finite-state\nspecialization of the streaming parsing algorithm presented in the first part.\nIn the second part we also develop a new linear-time streaming parsing\nalgorithm for parsing expression grammars (PEG) which generalizes the regular\ngrammars of Kleenex. The algorithm is based on a bottom-up tabulation algorithm\nreformulated using least fixed points and evaluated using an instance of the\nchaotic iteration scheme by Cousot and Cousot.\n", "versions": [{"version": "v1", "created": "Fri, 28 Apr 2017 06:43:15 GMT"}], "update_date": "2017-05-01", "authors_parsed": [["Rasmussen", "Ulrik Terp", ""]]}, {"id": "1704.08887", "submitter": "Martin Zimmermann", "authors": "Sarah Winter and Martin Zimmermann", "title": "Finite-state Strategies in Delay Games (full version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  What is a finite-state strategy in a delay game? We answer this surprisingly\nnon-trivial question by presenting a very general framework that allows to\nremove delay: finite-state strategies exist for all winning conditions where\nthe resulting delay-free game admits a finite-state strategy. The framework is\napplicable to games whose winning condition is recognized by an automaton with\nan acceptance condition that satisfies a certain aggregation property. Our\nframework also yields upper bounds on the complexity of determining the winner\nof such delay games and upper bounds on the necessary lookahead to win the\ngame. In particular, we cover all previous results of that kind as special\ncases of our uniform approach.\n", "versions": [{"version": "v1", "created": "Fri, 28 Apr 2017 12:00:37 GMT"}, {"version": "v2", "created": "Tue, 22 Aug 2017 00:02:43 GMT"}, {"version": "v3", "created": "Mon, 26 Feb 2018 21:13:23 GMT"}, {"version": "v4", "created": "Tue, 27 Nov 2018 10:24:44 GMT"}, {"version": "v5", "created": "Fri, 13 Dec 2019 15:14:27 GMT"}], "update_date": "2019-12-16", "authors_parsed": [["Winter", "Sarah", ""], ["Zimmermann", "Martin", ""]]}]