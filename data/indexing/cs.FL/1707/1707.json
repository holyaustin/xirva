[{"id": "1707.00101", "submitter": "Lukas Fleischer", "authors": "Volker Diekert and Lukas Fleischer", "title": "Church-Rosser Systems, Codes with Bounded Synchronization Delay and\n  Local Rees Extensions", "comments": "Extended abstract of an invited talk given at WORDS 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  What is the common link, if there is any, between Church-Rosser systems,\nprefix codes with bounded synchronization delay, and local Rees extensions? The\nfirst obvious answer is that each of these notions relates to topics of\ninterest for WORDS: Church-Rosser systems are certain rewriting systems over\nwords, codes are given by sets of words which form a basis of a free submonoid\nin the free monoid of all words (over a given alphabet) and local Rees\nextensions provide structural insight into regular languages over words. So, it\nseems to be a legitimate title for an extended abstract presented at the\nconference WORDS 2017. However, this work is more ambitious, it outlines some\nless obvious but much more interesting link between these topics. This link is\nbased on a structure theory of finite monoids with varieties of groups and the\nconcept of local divisors playing a prominent role. Parts of this work appeared\nin a similar form in conference proceedings where proofs and further material\ncan be found.\n", "versions": [{"version": "v1", "created": "Sat, 1 Jul 2017 06:40:37 GMT"}], "update_date": "2017-07-04", "authors_parsed": [["Diekert", "Volker", ""], ["Fleischer", "Lukas", ""]]}, {"id": "1707.00527", "submitter": "Pierre-Alain Reynier", "authors": "Emmanuel Filiot and Olivier Gauwin and Pierre-Alain Reynier and\n  Fr\\'ed\\'eric Servais", "title": "Streamability of nested word transductions", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 2 (April 4,\n  2019) lmcs:5348", "doi": "10.23638/LMCS-15(2:1)2019", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We consider the problem of evaluating in streaming (i.e., in a single\nleft-to-right pass) a nested word transduction with a limited amount of memory.\nA transduction T is said to be height bounded memory (HBM) if it can be\nevaluated with a memory that depends only on the size of T and on the height of\nthe input word. We show that it is decidable in coNPTime for a nested word\ntransduction defined by a visibly pushdown transducer (VPT), if it is HBM. In\nthis case, the required amount of memory may depend exponentially on the height\nof the word. We exhibit a sufficient, decidable condition for a VPT to be\nevaluated with a memory that depends quadratically on the height of the word.\nThis condition defines a class of transductions that strictly contains all\ndeterminizable VPTs.\n", "versions": [{"version": "v1", "created": "Mon, 3 Jul 2017 13:13:52 GMT"}, {"version": "v2", "created": "Wed, 19 Dec 2018 14:12:34 GMT"}, {"version": "v3", "created": "Wed, 3 Apr 2019 08:08:08 GMT"}], "update_date": "2019-09-04", "authors_parsed": [["Filiot", "Emmanuel", ""], ["Gauwin", "Olivier", ""], ["Reynier", "Pierre-Alain", ""], ["Servais", "Fr\u00e9d\u00e9ric", ""]]}, {"id": "1707.01010", "submitter": "Amit Srivastava", "authors": "Amit Kumar Srivastava and Kalpesh Kapoor", "title": "Ins-Robust Primitive Words", "comments": "12 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let Q be the set of primitive words over a finite alphabet with at least two\nsymbols. We characterize a class of primitive words, Q_I, referred to as\nins-robust primitive words, which remain primitive on insertion of any letter\nfrom the alphabet and present some properties that characterizes words in the\nset Q_I. It is shown that the language Q_I is dense. We prove that the language\nof primitive words that are not ins-robust is not context-free. We also present\na linear time algorithm to recognize ins-robust primitive words and give a\nlower bound on the number of n-length ins-robust primitive words.\n", "versions": [{"version": "v1", "created": "Tue, 4 Jul 2017 14:28:01 GMT"}, {"version": "v2", "created": "Thu, 3 Aug 2017 13:56:54 GMT"}], "update_date": "2017-08-04", "authors_parsed": [["Srivastava", "Amit Kumar", ""], ["Kapoor", "Kalpesh", ""]]}, {"id": "1707.01157", "submitter": "S. Akshay", "authors": "S. Akshay, Supratik Chakraborty, Ankush Das, Vishal Jagannath, Sai\n  Sandeep", "title": "On Petri Nets with Hierarchical Special Arcs", "comments": "Extended abstract to appear in conference CONCUR 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the decidability of termination, reachability, coverability\nand deadlock-freeness of Petri nets endowed with a hierarchy on places, and\nwith inhibitor arcs, reset arcs and transfer arcs that respect this hierarchy.\nWe also investigate what happens when we have a mix of these special arcs, some\nof which respect the hierarchy, while others do not. We settle the decidability\nstatus of the above four problems for all combinations of hierarchy, inhibitor,\nreset and transfer arcs, except the termination problem for two combinations.\nFor both these combinations, we show that the termination problem is as hard as\ndeciding positivity for linear recurrent sequences -- a long-standing open\nproblem.\n", "versions": [{"version": "v1", "created": "Tue, 4 Jul 2017 21:21:59 GMT"}], "update_date": "2017-07-06", "authors_parsed": [["Akshay", "S.", ""], ["Chakraborty", "Supratik", ""], ["Das", "Ankush", ""], ["Jagannath", "Vishal", ""], ["Sandeep", "Sai", ""]]}, {"id": "1707.01344", "submitter": "Wen Chean Teh", "authors": "Wen Chean Teh", "title": "Compositions of Functions and Permutations Specified by Minimal Reaction\n  Systems", "comments": "10 pages, preprint", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO q-bio.MN", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies mathematical properties of reaction systems that was\nintroduced by Enrenfeucht and Rozenberg as computational models inspired by\nbiochemical reaction in the living cells. In particular, we continue the study\non the generative power of functions specified by minimal reaction systems\nunder composition initiated by Salomaa. Allowing degenerate reaction systems,\nfunctions specified by minimal reaction systems over a quarternary alphabet\nthat are permutations generate the alternating group on the power set of the\nbackground set.\n", "versions": [{"version": "v1", "created": "Tue, 4 Jul 2017 02:53:52 GMT"}], "update_date": "2017-07-06", "authors_parsed": [["Teh", "Wen Chean", ""]]}, {"id": "1707.01814", "submitter": "Nariyoshi Chida", "authors": "Nariyoshi Chida and Kimio Kuramitsu", "title": "Linear Parsing Expression Grammars", "comments": "Parsing expression grammars, Boolean finite automata, Packrat parsing", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  PEGs were formalized by Ford in 2004, and have several pragmatic operators\n(such as ordered choice and unlimited lookahead) for better expressing modern\nprogramming language syntax. Since these operators are not explicitly defined\nin the classic formal language theory, it is significant and still challenging\nto argue PEGs' expressiveness in the context of formal language theory.Since\nPEGs are relatively new, there are several unsolved problems.One of the\nproblems is revealing a subclass of PEGs that is equivalent to DFAs. This\nallows application of some techniques from the theory of regular grammar to\nPEGs. In this paper, we define Linear PEGs (LPEGs), a subclass of PEGs that is\nequivalent to DFAs. Surprisingly, LPEGs are formalized by only excluding some\npatterns of recursive nonterminal in PEGs, and include the full set of ordered\nchoice, unlimited lookahead, and greedy repetition, which are characteristic of\nPEGs. Although the conversion judgement of parsing expressions into DFAs is\nundecidable in general, the formalism of LPEGs allows for a syntactical\njudgement of parsing expressions.\n", "versions": [{"version": "v1", "created": "Thu, 6 Jul 2017 14:33:32 GMT"}, {"version": "v2", "created": "Sat, 9 Sep 2017 18:07:49 GMT"}], "update_date": "2017-09-12", "authors_parsed": [["Chida", "Nariyoshi", ""], ["Kuramitsu", "Kimio", ""]]}, {"id": "1707.02058", "submitter": "Hugo Gimbert", "authors": "Nathalie Bertrand (IRSN), Miheer Dewaskar, Blaise Genest (SUMO), Hugo\n  Gimbert (LaBRI)", "title": "Controlling a Population", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.GT cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new setting where a population of agents, each modelled by a\nfinite-state system, are controlled uniformly: the controller applies the same\naction to every agent. The framework is largely inspired by the control of a\nbiological system, namely a population of yeasts, where the controller may only\nchange the environment common to all cells. We study a synchronisation problem\nfor such populations: no matter how individual agents react to the actions of\nthe controller , the controller aims at driving all agents synchronously to a\ntarget state. The agents are naturally represented by a non-deterministic\nfinite state automaton (NFA), the same for every agent, and the whole system is\nencoded as a 2-player game. The first player (Controller) chooses actions, and\nthe second player (Agents) resolves non-determinism for each agent. The game\nwith m agents is called the m-population game. This gives rise to a\nparameterized control problem (where control refers to 2 player games), namely\nthe population control problem: can Controller control the m-population game\nfor all $m $\\in$ N$ whatever Agents does? In this paper, we prove that the\npopulation control problem is decidable, and it is a EXPTIME-complete problem.\nAs far as we know, this is one of the first results on parameterized control.\nOur algorithm, not based on cutoff techniques, produces winning strategies\nwhich are symbolic, that is, they do not need to count precisely how the\npopulation is spread between states. We also show that if there is no winning\nstrategy, then there is a population size M such that Controller wins the\nm-population game if and only if $m $\\le$ M$. Surprisingly, M can be doubly\nexponential in the number of states of the NFA, with tight upper and lower\nbounds.\n", "versions": [{"version": "v1", "created": "Fri, 7 Jul 2017 07:11:06 GMT"}], "update_date": "2017-07-10", "authors_parsed": [["Bertrand", "Nathalie", "", "IRSN"], ["Dewaskar", "Miheer", "", "SUMO"], ["Genest", "Blaise", "", "SUMO"], ["Gimbert", "Hugo", "", "LaBRI"]]}, {"id": "1707.02279", "submitter": "Ruggero Lanotte Dr", "authors": "Ruggero Lanotte and Massimo Merro and Simone Tini", "title": "A Probabilistic Calculus of Cyber-Physical Systems", "comments": "arXiv admin note: text overlap with arXiv:1612.00484", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a hybrid probabilistic process calculus for modelling and\nreasoning on cyber-physical systems (CPSs). The dynamics of the calculus is\nexpressed in terms of a probabilistic labelled transition system in the SOS\nstyle of Plotkin. This is used to define a bisimulation-based probabilistic\nbehavioural semantics which supports compositional reasonings. For a more\ncareful comparison between CPSs, we provide two compositional probabilistic\nmetrics to formalise the notion of behavioural distance between systems, also\nin the case of bounded computations. Finally, we provide a non-trivial case\nstudy, taken from an engineering application, and use it to illustrate our\ndefinitions and our compositional behavioural theory for CPSs.\n", "versions": [{"version": "v1", "created": "Fri, 7 Jul 2017 17:31:33 GMT"}, {"version": "v2", "created": "Tue, 30 Jan 2018 20:09:19 GMT"}, {"version": "v3", "created": "Thu, 1 Feb 2018 17:03:19 GMT"}, {"version": "v4", "created": "Mon, 27 Apr 2020 09:39:41 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Lanotte", "Ruggero", ""], ["Merro", "Massimo", ""], ["Tini", "Simone", ""]]}, {"id": "1707.02297", "submitter": "Shankara Narayanan Krishna", "authors": "S. Akshay, Paul Gastin, Shankara Narayanan Krishna and Ilias Sarkar", "title": "Towards an Efficient Tree Automata based technique for Timed Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The focus of this paper is the analysis of real-time systems with recursion,\nthrough the development of good theoretical techniques which are implementable.\nTime is modeled using clock variables, and recursion using stacks. Our\ntechnique consists of modeling the behaviours of the timed system as graphs,\nand interpreting these graphs on tree terms by showing a bound on their\ntree-width. We then build a tree automaton that accepts exactly those tree\nterms that describe realizable runs of the timed system. The emptiness of the\ntimed system thus boils down to emptiness of a finite tree automaton that\naccepts these tree terms. This approach helps us in obtaining an optimal\ncomplexity, not just in theory (as done in earlier work), but also in going\ntowards an efficient implementation of our technique. To do this, we make\nseveral improvements in the theory and exploit these to build a first prototype\ntool that can analyze timed systems with recursion.\n", "versions": [{"version": "v1", "created": "Sat, 8 Jul 2017 13:07:53 GMT"}], "update_date": "2017-07-11", "authors_parsed": [["Akshay", "S.", ""], ["Gastin", "Paul", ""], ["Krishna", "Shankara Narayanan", ""], ["Sarkar", "Ilias", ""]]}, {"id": "1707.02652", "submitter": "Carlos Martin", "authors": "Carlos Martin", "title": "Generation and analysis of lamplighter programs", "comments": "Added section 7 (sampling random programs) and section 8\n  (distribution of runtimes)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.FL cs.PL math.CO math.GR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider a programming language based on the lamplighter group that uses\nonly composition and iteration as control structures. We derive generating\nfunctions and counting formulas for this language and special subsets of it,\nestablishing lower and upper bounds on the growth rate of semantically distinct\nprograms. Finally, we show how to sample random programs and analyze the\ndistribution of runtimes induced by such sampling.\n", "versions": [{"version": "v1", "created": "Sun, 9 Jul 2017 22:38:22 GMT"}, {"version": "v2", "created": "Mon, 22 Oct 2018 22:02:40 GMT"}], "update_date": "2018-10-24", "authors_parsed": [["Martin", "Carlos", ""]]}, {"id": "1707.03174", "submitter": "Pascal Caron", "authors": "Pascal Caron, Jean-Gabriel Luque and Bruno Patrou", "title": "State complexity of catenation combined with boolean operations", "comments": "20 pages, 11 Figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We exhaustively investigate possible combinations of a boolean operation\ntogether with a catenation. In many cases we prove and improve some conjectures\nby Brzozowski. For each family of operation, we endeavour to provide a common\nwitness with a small size alphabet.\n", "versions": [{"version": "v1", "created": "Tue, 11 Jul 2017 08:47:15 GMT"}], "update_date": "2017-07-12", "authors_parsed": [["Caron", "Pascal", ""], ["Luque", "Jean-Gabriel", ""], ["Patrou", "Bruno", ""]]}, {"id": "1707.03295", "submitter": "Christoph Rauch", "authors": "Thomas Place", "title": "Separating regular languages with two quantifier alternations", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 14, Issue 4 (November\n  16, 2018) lmcs:4978", "doi": "10.23638/LMCS-14(4:16)2018", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We investigate a famous decision problem in automata theory: separation.\nGiven a class of language C, the separation problem for C takes as input two\nregular languages and asks whether there exists a third one which belongs to C,\nincludes the first one and is disjoint from the second. Typically, obtaining an\nalgorithm for separation yields a deep understanding of the investigated class\nC. This explains why a lot of effort has been devoted to finding algorithms for\nthe most prominent classes.\n  Here, we are interested in classes within concatenation hierarchies. Such\nhierarchies are built using a generic construction process: one starts from an\ninitial class called the basis and builds new levels by applying generic\noperations. The most famous one, the dot-depth hierarchy of Brzozowski and\nCohen, classifies the languages definable in first-order logic. Moreover, it\nwas shown by Thomas that it corresponds to the quantifier alternation hierarchy\nof first-order logic: each level in the dot-depth corresponds to the languages\nthat can be defined with a prescribed number of quantifier blocks. Finding\nseparation algorithms for all levels in this hierarchy is among the most famous\nopen problems in automata theory.\n  Our main theorem is generic: we show that separation is decidable for the\nlevel 3/2 of any concatenation hierarchy whose basis is finite. Furthermore, in\nthe special case of the dot-depth, we push this result to the level 5/2. In\nlogical terms, this solves separation for $\\Sigma_3$: first-order sentences\nhaving at most three quantifier blocks starting with an existential one.\n", "versions": [{"version": "v1", "created": "Tue, 11 Jul 2017 14:25:08 GMT"}, {"version": "v2", "created": "Sat, 15 Jul 2017 23:29:27 GMT"}, {"version": "v3", "created": "Thu, 8 Feb 2018 16:25:35 GMT"}, {"version": "v4", "created": "Sun, 12 Aug 2018 15:27:30 GMT"}, {"version": "v5", "created": "Tue, 13 Nov 2018 10:49:33 GMT"}, {"version": "v6", "created": "Thu, 15 Nov 2018 16:48:58 GMT"}], "update_date": "2018-11-27", "authors_parsed": [["Place", "Thomas", ""]]}, {"id": "1707.03457", "submitter": "Andreas Maletti", "authors": "Joost Engelfriet, Andreas Maletti, Sebastian Maneth", "title": "Multiple Context-Free Tree Grammars: Lexicalization and Characterization", "comments": "78 pages, 13 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multiple (simple) context-free tree grammars are investigated, where \"simple\"\nmeans \"linear and nondeleting\". Every multiple context-free tree grammar that\nis finitely ambiguous can be lexicalized; i.e., it can be transformed into an\nequivalent one (generating the same tree language) in which each rule of the\ngrammar contains a lexical symbol. Due to this transformation, the rank of the\nnonterminals increases at most by 1, and the multiplicity (or fan-out) of the\ngrammar increases at most by the maximal rank of the lexical symbols; in\nparticular, the multiplicity does not increase when all lexical symbols have\nrank 0. Multiple context-free tree grammars have the same tree generating power\nas multi-component tree adjoining grammars (provided the latter can use a\nroot-marker). Moreover, every multi-component tree adjoining grammar that is\nfinitely ambiguous can be lexicalized. Multiple context-free tree grammars have\nthe same string generating power as multiple context-free (string) grammars and\npolynomial time parsing algorithms. A tree language can be generated by a\nmultiple context-free tree grammar if and only if it is the image of a regular\ntree language under a deterministic finite-copying macro tree transducer.\nMultiple context-free tree grammars can be used as a synchronous translation\ndevice.\n", "versions": [{"version": "v1", "created": "Tue, 11 Jul 2017 20:48:57 GMT"}], "update_date": "2017-07-13", "authors_parsed": [["Engelfriet", "Joost", ""], ["Maletti", "Andreas", ""], ["Maneth", "Sebastian", ""]]}, {"id": "1707.03894", "submitter": "Jeffrey Shallit", "authors": "Andrew Bridy, Robert J. Lemke Oliver, Arlo Shallit, Jeffrey Shallit", "title": "The Generalized Nagell-Ljunggren Problem: Powers with Repetitive\n  Representations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NT cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider a natural generalization of the Nagell-Ljunggren equation to the\ncase where the qth power of an integer y, for q >= 2, has a base-b\nrepresentation that consists of a length-l block of digits repeated n times,\nwhere n >= 2. Assuming the abc conjecture of Masser and Oesterl\\'e, we\ncompletely characterize those triples (q, n, l) for which there are infinitely\nmany solutions b. In all cases predicted by the abc conjecture, we are able\n(without any assumptions) to prove there are indeed infinitely many solutions.\n", "versions": [{"version": "v1", "created": "Wed, 12 Jul 2017 20:25:31 GMT"}, {"version": "v2", "created": "Sat, 22 Jul 2017 22:46:23 GMT"}], "update_date": "2017-07-25", "authors_parsed": [["Bridy", "Andrew", ""], ["Oliver", "Robert J. Lemke", ""], ["Shallit", "Arlo", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1707.04083", "submitter": "Markus Schmid", "authors": "Henning Fernau, Markus L. Schmid, K. G. Subramanian", "title": "Two-Dimensional Pattern Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce several classes of array languages obtained by generalising\nAngluin's pattern languages to the two-dimensional case. These classes of\ntwo-dimensional pattern languages are compared with respect to their expressive\npower and their closure properties are investigated.\n", "versions": [{"version": "v1", "created": "Thu, 13 Jul 2017 12:17:56 GMT"}], "update_date": "2017-07-14", "authors_parsed": [["Fernau", "Henning", ""], ["Schmid", "Markus L.", ""], ["Subramanian", "K. G.", ""]]}, {"id": "1707.04097", "submitter": "Markus Schmid", "authors": "Daniel Reidenbach, Markus L. Schmid", "title": "A Polynomial Time Match Test for Large Classes of Extended Regular\n  Expressions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the present paper, we study the match test for extended regular\nexpressions. We approach this NP-complete problem by introducing a novel\nvariant of two-way multihead automata, which reveals that the complexity of the\nmatch test is determined by a hidden combinatorial property of extended regular\nexpressions, and it shows that a restriction of the corresponding parameter\nleads to rich classes with a polynomial time match test. For presentational\nreasons, we use the concept of pattern languages in order to specify extended\nregular expressions. While this decision, formally, slightly narrows the scope\nof our results, an extension of our concepts and results to more general\nnotions of extended regular expressions is straightforward.\n", "versions": [{"version": "v1", "created": "Thu, 13 Jul 2017 12:54:12 GMT"}], "update_date": "2017-07-14", "authors_parsed": [["Reidenbach", "Daniel", ""], ["Schmid", "Markus L.", ""]]}, {"id": "1707.04125", "submitter": "EPTCS", "authors": "Barbara K\\\"onig, Sebastian K\\\"upper, Christina Mika", "title": "PAWS: A Tool for the Analysis of Weighted Systems", "comments": "In Proceedings QAPL 2017, arXiv:1707.03668", "journal-ref": "EPTCS 250, 2017, pp. 75-91", "doi": "10.4204/EPTCS.250.5", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  PAWS is a tool to analyse the behaviour of weighted automata and conditional\ntransition systems. At its core PAWS is based on a generic implementation of\nalgorithms for checking language equivalence in weighted automata and\nbisimulation in conditional transition systems. This architecture allows for\nthe use of arbitrary user-defined semirings. New semirings can be generated\nduring run-time and the user can rely on numerous automatisation techniques to\ncreate new semiring structures for PAWS' algorithms. Basic semirings such as\ndistributive complete lattices and fields of fractions can be defined by\nspecifying few parameters, more exotic semirings can be generated from other\nsemirings or defined from scratch using a built-in semiring generator. In the\nmost general case, users can define new semirings by programming (in C#) the\nbase operations of the semiring and a procedure to solve linear equations and\nuse their newly generated semiring in the analysis tools that PAWS offers.\n", "versions": [{"version": "v1", "created": "Thu, 13 Jul 2017 13:52:33 GMT"}], "update_date": "2017-07-14", "authors_parsed": [["K\u00f6nig", "Barbara", ""], ["K\u00fcpper", "Sebastian", ""], ["Mika", "Christina", ""]]}, {"id": "1707.04151", "submitter": "Ashutosh Trivedi", "authors": "Shankara Narayanan Krishna and Aviral Kumar and Fabio Somenzi and\n  Behrouz Touri and Ashutosh Trivedi", "title": "The Reach-Avoid Problem for Constant-Rate Multi-Mode Systems", "comments": "26 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A constant-rate multi-mode system is a hybrid system that can switch freely\namong a finite set of modes, and whose dynamics is specified by a finite number\nof real-valued variables with mode-dependent constant rates. Alur, Wojtczak,\nand Trivedi have shown that reachability problems for constant-rate multi-mode\nsystems for open and convex safety sets can be solved in polynomial time. In\nthis paper, we study the reachability problem for non-convex state spaces and\nshow that this problem is in general undecidable. We recover decidability by\nmaking certain assumptions about the safety set. We present a new algorithm to\nsolve this problem and compare its performance with the popular sampling based\nalgorithm rapidly-exploring random tree (RRT) as implemented in the Open Motion\nPlanning Library (OMPL).\n", "versions": [{"version": "v1", "created": "Wed, 12 Jul 2017 10:06:36 GMT"}], "update_date": "2017-07-14", "authors_parsed": [["Krishna", "Shankara Narayanan", ""], ["Kumar", "Aviral", ""], ["Somenzi", "Fabio", ""], ["Touri", "Behrouz", ""], ["Trivedi", "Ashutosh", ""]]}, {"id": "1707.04160", "submitter": "Birzhan Moldagaliyev", "authors": "Birzhan Moldagaliyev", "title": "Automatic Randomness Tests", "comments": "21 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we define a notion of automatic randomness tests (ART) which\ncapture measure theoretic typicalness of infinite binary sequences within the\nframework of automata theory. An individual ART is found to be equivalent to a\ndeterministic B\\\"{u}chi automaton recognizing $\\omega$-language of (Lebesgue)\nmeasure zero. A collection of ART's induce a notion of automatic random\nsequence. We provide a purely combinatorial characterization of an automatic\nrandom sequence in the form of a disjunctive property for sequences. At last,\nwe compare two kinds of automatic randomness tests presented in this paper.\n", "versions": [{"version": "v1", "created": "Thu, 13 Jul 2017 15:02:53 GMT"}, {"version": "v2", "created": "Tue, 19 Sep 2017 08:06:56 GMT"}], "update_date": "2017-09-20", "authors_parsed": [["Moldagaliyev", "Birzhan", ""]]}, {"id": "1707.04310", "submitter": "Antoine Amarilli", "authors": "Antoine Amarilli, Charles Paperman", "title": "Topological Sorting under Regular Constraints", "comments": "45 pages, 31 references in the main text. This is the full version\n  with proofs of the ICALP'18 paper, and is the same as the ICALP proceedings\n  version up to minor publisher-dependent changes. Several important changes\n  with respect to version 1, including fixing some errors. Title changed with\n  respect to version 2", "journal-ref": null, "doi": "10.4230/LIPIcs.ICALP.2018.115", "report-no": null, "categories": "cs.DS cs.CC cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce the constrained topological sorting problem (CTS): given a\nregular language K and a directed acyclic graph G with labeled vertices,\ndetermine if G has a topological sort that forms a word in K. This natural\nproblem applies to several settings, e.g., scheduling with costs or verifying\nconcurrent programs. We consider the problem CTS[K] where the target language K\nis fixed, and study its complexity depending on K. We show that CTS[K] is\ntractable when K falls in several language families, e.g., unions of monomials,\nwhich can be used for pattern matching. However, we show that CTS[K] is NP-hard\nfor K = (ab)^* and introduce a shuffle reduction technique to show hardness for\nmore languages. We also study the special case of the constrained shuffle\nproblem (CSh), where the input graph is a disjoint union of strings, and show\nthat CSh[K] is additionally tractable when K is a group language or a union of\ndistrict group monomials. We conjecture that a dichotomy should hold on the\ncomplexity of CTS[K] or CSh[K] depending on K, and substantiate this by proving\na coarser dichotomy under a different problem phrasing which ensures that\ntractable languages are closed under common operators.\n", "versions": [{"version": "v1", "created": "Thu, 13 Jul 2017 20:35:48 GMT"}, {"version": "v2", "created": "Mon, 19 Feb 2018 10:40:29 GMT"}, {"version": "v3", "created": "Mon, 30 Apr 2018 18:57:06 GMT"}], "update_date": "2019-08-28", "authors_parsed": [["Amarilli", "Antoine", ""], ["Paperman", "Charles", ""]]}, {"id": "1707.04441", "submitter": "Jo\\~ao Daniel Moreira", "authors": "Jo\\~ao Daniel Moreira", "title": "Non-locality of the meet levels of the Trotter-Weil Hierarchy", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.GR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the meet level $m$ of the Trotter-Weil, $\\mathsf{V}_m$ is not\nlocal for all $m \\geq 1$, as conjectured in a paper by Kufleitner and Lauser.\nIn order to show this, we explicitly provide a language whose syntactic\nsemigroup is in $L \\mathsf{V}_m$ and not in $\\mathsf{V}_m*\\mathsf{D}$.\n", "versions": [{"version": "v1", "created": "Fri, 14 Jul 2017 10:10:35 GMT"}], "update_date": "2017-07-17", "authors_parsed": [["Moreira", "Jo\u00e3o Daniel", ""]]}, {"id": "1707.04450", "submitter": "Gabriele Fici", "authors": "Gabriele Fici, Antonio Restivo, Laura Rizzo", "title": "Minimal Forbidden Factors of Circular Words", "comments": "To appear in Theoretical Computer Science", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Minimal forbidden factors are a useful tool for investigating properties of\nwords and languages. Two factorial languages are distinct if and only if they\nhave different (antifactorial) sets of minimal forbidden factors. There exist\nalgorithms for computing the minimal forbidden factors of a word, as well as of\na regular factorial language. Conversely, Crochemore et al. [IPL, 1998] gave an\nalgorithm that, given the trie recognizing a finite antifactorial language $M$,\ncomputes a DFA recognizing the language whose set of minimal forbidden factors\nis $M$. In the same paper, they showed that the obtained DFA is minimal if the\ninput trie recognizes the minimal forbidden factors of a single word. We\ngeneralize this result to the case of a circular word. We discuss several\ncombinatorial properties of the minimal forbidden factors of a circular word.\nAs a byproduct, we obtain a formal definition of the factor automaton of a\ncircular word. Finally, we investigate the case of minimal forbidden factors of\nthe circular Fibonacci words.\n", "versions": [{"version": "v1", "created": "Fri, 14 Jul 2017 10:38:35 GMT"}, {"version": "v2", "created": "Fri, 19 Jan 2018 10:50:38 GMT"}, {"version": "v3", "created": "Fri, 25 May 2018 08:58:53 GMT"}], "update_date": "2018-05-28", "authors_parsed": [["Fici", "Gabriele", ""], ["Restivo", "Antonio", ""], ["Rizzo", "Laura", ""]]}, {"id": "1707.04651", "submitter": "Kai Salomaa", "authors": "Da-Jung Cho, Yo-Sub Han, Timothy Ng, Kai Salomaa", "title": "Outfix-guided insertion", "comments": null, "journal-ref": null, "doi": "10.1016/j.tcs.2017.03.040", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Motivated by work on bio-operations on DNA strings, we consider an\noutfix-guided insertion operation that can be viewed as a generalization of the\noverlap assembly operation on strings studied previously. As the main result we\nconstruct a finite language $L$ such that the outfix-guided insertion closure\nof $L$ is non-regular. We consider also the closure properties of regular and\n(deterministic) context-free languages under the outfix-guided insertion\noperation and decision problems related to outfix-guided insertion. Deciding\nwhether a language recognized by a deterministic finite automaton is closed\nunder outfix-guided insertion can be done in polynomial time. The complexity of\nthe corresponding question for nondeterministic finite automata remains open.\n", "versions": [{"version": "v1", "created": "Fri, 14 Jul 2017 22:01:36 GMT"}], "update_date": "2017-07-18", "authors_parsed": [["Cho", "Da-Jung", ""], ["Han", "Yo-Sub", ""], ["Ng", "Timothy", ""], ["Salomaa", "Kai", ""]]}, {"id": "1707.05115", "submitter": "Anssi Yli-Jyr\\\"a", "authors": "Anssi Yli-Jyr\\\"a", "title": "The Power of Constraint Grammars Revisited", "comments": "9 pages, 4 figures", "journal-ref": "Proceedings of the NoDaLiDa 2017 Workshop on Constraint Grammar -\n  Methods, Tools and Applications, 22 May 2017, Gothenburg, Sweden. Pages 23-31", "doi": null, "report-no": null, "categories": "cs.FL cs.AI cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Sequential Constraint Grammar (SCG) (Karlsson, 1990) and its extensions have\nlacked clear connections to formal language theory. The purpose of this article\nis to lay a foundation for these connections by simplifying the definition of\nstrings processed by the grammar and by showing that Nonmonotonic SCG is\nundecidable and that derivations similar to the Generative Phonology exist. The\ncurrent investigations propose resource bounds that restrict the generative\npower of SCG to a subset of context sensitive languages and present a strong\nfinite-state condition for grammars as wholes. We show that a grammar is\nequivalent to a finite-state transducer if it is implemented with a Turing\nmachine that runs in o(n log n) time. This condition opens new finite-state\nhypotheses and avenues for deeper analysis of SCG instances in the way inspired\nby Finite-State Phonology.\n", "versions": [{"version": "v1", "created": "Mon, 17 Jul 2017 12:20:15 GMT"}], "update_date": "2017-07-18", "authors_parsed": [["Yli-Jyr\u00e4", "Anssi", ""]]}, {"id": "1707.05428", "submitter": "Jin Dai", "authors": "Jin Dai and Hai Lin", "title": "Coordination and Control of Distributed Discrete Event Systems under\n  Actuator and Sensor Faults", "comments": "33 pages; 20 figures; 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the coordination and control problems of distributed discrete\nevent systems that are composed of multiple subsystems subject to potential\nactuator and/or sensor faults. We model actuator faults as local\ncontrollability loss of certain actuator events and sensor faults as\nobservability failure of certain sensor readings, respectively. Starting from\nautomata-theoretic models that characterize behaviors of the subsystems in the\npresence of faulty actuators and/or sensors, we establish necessary and\nsufficient conditions for the existence of actuator and sensor fault tolerant\nsupervisors, respectively, and synthesize appropriate local post-fault\nsupervisors to prevent the post-fault subsystems from jeopardizing local safety\nrequirements. Furthermore, we apply an assume-guarantee coordination scheme to\nthe controlled subsystems for both the nominal and faulty subsystems so as to\nachieve the desired specifications of the system. A multi-robot coordination\nexample is used to illustrate the proposed coordination and control\narchitecture.\n", "versions": [{"version": "v1", "created": "Tue, 18 Jul 2017 01:14:00 GMT"}, {"version": "v2", "created": "Wed, 5 Dec 2018 03:45:34 GMT"}], "update_date": "2018-12-06", "authors_parsed": [["Dai", "Jin", ""], ["Lin", "Hai", ""]]}, {"id": "1707.06387", "submitter": "Joohyung Lee", "authors": "Joohyung Lee, Nikhil Loney, Yunsong Meng", "title": "Representing Hybrid Automata by Action Language Modulo Theories", "comments": "Paper presented at the 33nd International Conference on Logic\n  Programming (ICLP 2017), Melbourne, Australia, August 28 to September 1, 2017\n  16 pages, LaTeX", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Both hybrid automata and action languages are formalisms for describing the\nevolution of dynamic systems. This paper establishes a formal relationship\nbetween them. We show how to succinctly represent hybrid automata in an action\nlanguage which in turn is defined as a high-level notation for answer set\nprogramming modulo theories (ASPMT) --- an extension of answer set programs to\nthe first-order level similar to the way satisfiability modulo theories (SMT)\nextends propositional satisfiability (SAT). We first show how to represent\nlinear hybrid automata with convex invariants by an action language modulo\ntheories. A further translation into SMT allows for computing them using SMT\nsolvers that support arithmetic over reals. Next, we extend the representation\nto the general class of non-linear hybrid automata allowing even non-convex\ninvariants. We represent them by an action language modulo ODE (Ordinary\nDifferential Equations), which can be compiled into satisfiability modulo ODE.\nWe developed a prototype system cplus2aspmt based on these translations, which\nallows for a succinct representation of hybrid transition systems that can be\ncomputed effectively by the state-of-the-art SMT solver dReal.\n", "versions": [{"version": "v1", "created": "Thu, 20 Jul 2017 06:37:40 GMT"}, {"version": "v2", "created": "Tue, 25 Jul 2017 20:06:36 GMT"}], "update_date": "2017-07-27", "authors_parsed": [["Lee", "Joohyung", ""], ["Loney", "Nikhil", ""], ["Meng", "Yunsong", ""]]}, {"id": "1707.07473", "submitter": "Oliviero Riganelli", "authors": "Oliviero Riganelli, Daniela Micucci, Leonardo Mariani, Yli\\`es Falcone", "title": "Verifying Policy Enforcers", "comments": "Oliviero Riganelli, Daniela Micucci, Leonardo Mariani, and Yli\\`es\n  Falcone. Verifying Policy Enforcers. Proceedings of 17th International\n  Conference on Runtime Verification (RV), 2017. (to appear)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Policy enforcers are sophisticated runtime components that can prevent\nfailures by enforcing the correct behavior of the software. While a single\nenforcer can be easily designed focusing only on the behavior of the\napplication that must be monitored, the effect of multiple enforcers that\nenforce different policies might be hard to predict. So far, mechanisms to\nresolve interferences between enforcers have been based on priority mechanisms\nand heuristics. Although these methods provide a mechanism to take decisions\nwhen multiple enforcers try to affect the execution at a same time, they do not\nguarantee the lack of interference on the global behavior of the system. In\nthis paper we present a verification strategy that can be exploited to discover\ninterferences between sets of enforcers and thus safely identify a-priori the\nenforcers that can co-exist at run-time. In our evaluation, we experimented our\nverification method with several policy enforcers for Android and discovered\nsome incompatibilities.\n", "versions": [{"version": "v1", "created": "Mon, 24 Jul 2017 10:45:06 GMT"}, {"version": "v2", "created": "Tue, 25 Jul 2017 09:36:49 GMT"}, {"version": "v3", "created": "Wed, 26 Jul 2017 09:32:35 GMT"}], "update_date": "2020-10-14", "authors_parsed": [["Riganelli", "Oliviero", ""], ["Micucci", "Daniela", ""], ["Mariani", "Leonardo", ""], ["Falcone", "Yli\u00e8s", ""]]}, {"id": "1707.07670", "submitter": "Alexander Sakharov", "authors": "Alexander Sakharov", "title": "Language Approximation With One-Counter Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a method for approximating context-free languages with one-counter\nautomata. This approximation allows the reconstruction of parse trees of the\noriginal grammar. We identify a decidable superset of regular languages whose\nelements, i.e. languages, are recognized by one-counter automata.\n", "versions": [{"version": "v1", "created": "Sun, 23 Jul 2017 13:13:15 GMT"}], "update_date": "2017-07-26", "authors_parsed": [["Sakharov", "Alexander", ""]]}, {"id": "1707.09793", "submitter": "EPTCS", "authors": "\\\"Ozlem Salehi (Bo\\u{g}azi\\c{c}i University, Department of Computer\n  Engineering), Flavio D'Alessandro (Universit\\`a di Roma \"La Sapienza\",\n  Dipartimento di Matematica), A. C. Cem Say (Bo\\u{g}azi\\c{c}i University,\n  Department of Computer Engineering)", "title": "Generalized Results on Monoids as Memory", "comments": "In Proceedings AFL 2017, arXiv:1708.06226", "journal-ref": "EPTCS 252, 2017, pp. 234-247", "doi": "10.4204/EPTCS.252.22", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that some results from the theory of group automata and monoid\nautomata still hold for more general classes of monoids and models. Extending\nprevious work for finite automata over commutative groups, we demonstrate a\ncontext-free language that can not be recognized by any rational monoid\nautomaton over a finitely generated permutable monoid. We show that the class\nof languages recognized by rational monoid automata over finitely generated\ncompletely simple or completely 0-simple permutable monoids is a semi-linear\nfull trio. Furthermore, we investigate valence pushdown automata, and prove\nthat they are only as powerful as (finite) valence automata. We observe that\ncertain results proven for monoid automata can be easily lifted to the case of\ncontext-free valence grammars.\n", "versions": [{"version": "v1", "created": "Mon, 31 Jul 2017 10:25:27 GMT"}, {"version": "v2", "created": "Tue, 22 Aug 2017 00:52:49 GMT"}], "update_date": "2017-08-23", "authors_parsed": [["Salehi", "\u00d6zlem", "", "Bo\u011fazi\u00e7i University, Department of Computer\n  Engineering"], ["D'Alessandro", "Flavio", "", "Universit\u00e0 di Roma \"La Sapienza\",\n  Dipartimento di Matematica"], ["Say", "A. C. Cem", "", "Bo\u011fazi\u00e7i University,\n  Department of Computer Engineering"]]}]