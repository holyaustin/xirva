[{"id": "1010.1234", "submitter": "Arthur Sorkin", "authors": "Arthur Sorkin and Peter Donovan", "title": "LR(1) Parser Generation System: LR(1) Error Recovery, Oracles, and\n  Generic Tokens", "comments": "6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The LR(1) Parser Generation System generates full LR(1) parsers that are\ncomparable in speed and size to those generated by LALR(1) parser generators,\nsuch as yacc [5]. LR contains a number of novel feature. This paper discusses\nthree of them in detail: an LR(1) grammar specified automatic error recovery\nalgorithm, oracles, and generic tokens.\n", "versions": [{"version": "v1", "created": "Wed, 6 Oct 2010 19:13:38 GMT"}, {"version": "v2", "created": "Fri, 1 Jun 2012 01:00:59 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Sorkin", "Arthur", ""], ["Donovan", "Peter", ""]]}, {"id": "1010.2287", "submitter": "Omar Bataineh", "authors": "Omar I. Al-Bataineh and Ron van der Meyden", "title": "Abstraction for Epistemic Model Checking of Dining Cryptographers-based\n  Protocols", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper describes an abstraction for protocols that are based on multiple\nrounds of Chaum's Dining Cryptographers protocol. It is proved that the\nabstraction preserves a rich class of specifications in the logic of knowledge,\nincluding specifications describing what an agent knows about other agents'\nknowledge. This result can be used to optimize model checking of Dining\nCryptographers-based protocols, and applied within a methodology for\nknowledge-based program implementation and verification. Some case studies of\nsuch an application are given, for a protocol that uses the Dining\nCryptographers protocol as a primitive in an anonymous broadcast system.\nPerformance results are given for model checking knowledge-based specifications\nin the concrete and abstract models of this protocol, and some new conclusions\nabout the protocol are derived.\n", "versions": [{"version": "v1", "created": "Tue, 12 Oct 2010 02:45:37 GMT"}], "update_date": "2010-10-13", "authors_parsed": [["Al-Bataineh", "Omar I.", ""], ["van der Meyden", "Ron", ""]]}, {"id": "1010.2604", "submitter": "Enrico Tassi", "authors": "Andrea Asperti, Claudio Sacerdoti Coen, Enrico Tassi", "title": "Regular Expressions, au point", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new technique for constructing a finite state deterministic\nautomaton from a regular expression, based on the idea of marking a suitable\nset of positions inside the expression, intuitively representing the possible\npoints reached after the processing of an initial prefix of the input string.\nPointed regular expressions join the elegance and the symbolic appealingness of\nBrzozowski's derivatives, with the effectiveness of McNaughton and Yamada's\nlabelling technique, essentially combining the best of the two approaches.\n", "versions": [{"version": "v1", "created": "Wed, 13 Oct 2010 09:07:13 GMT"}], "update_date": "2010-10-14", "authors_parsed": [["Asperti", "Andrea", ""], ["Coen", "Claudio Sacerdoti", ""], ["Tassi", "Enrico", ""]]}, {"id": "1010.2823", "submitter": "EPTCS", "authors": "Markus Lumpe (Swinburne University of Technology, Australia), Rajesh\n  Vasa (Swinburne University of Technology, Australia)", "title": "Partition Refinement of Component Interaction Automata: Why Structure\n  Matters More Than Size", "comments": "In Proceedings WCSI 2010, arXiv:1010.2337", "journal-ref": "EPTCS 37, 2010, pp. 12-26", "doi": "10.4204/EPTCS.37.2", "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automata-based modeling languages, like Component Interaction Automata, offer\nan attractive means to capture and analyze the behavioral aspects of\ninteracting components. At the center of these modeling languages we find\nfinite state machines that allow for a fine-grained description how and when\nspecific service requests may interact with other components or the\nenvironment. Unfortunately, automata-based approaches suffer from exponential\nstate explosion, a major obstacle to the successful application of these\nformalisms in modeling real-world scenarios. In order to cope with the\ncomplexity of individual specifications we can apply partition refinement, an\nabstraction technique to alleviate the state explosion problem. But this\ntechnique too exhibits exponential time and space complexity and, worse, does\nnot offer any guarantees for success. To better understand as to why partition\nrefinement succeeds in some cases while it fails in others, we conducted an\nempirical study on the performance of a partition refinement algorithm for\nComponent Interaction Automata specifications. As a result we have identified\nsuitable predictors for the expected effectiveness of partition refinement. It\nis the structure, not the size, of a specification that weighs heavier on the\noutcome of partition refinement. In particular, Component Interaction Automata\nspecifications for real-world systems are capable of producing scale-free\nnetworks containing structural artifacts that can assist the partition\nrefinement algorithm not only converge earlier, but also yield a significant\nstate space reduction on occasion.\n", "versions": [{"version": "v1", "created": "Thu, 14 Oct 2010 05:16:03 GMT"}], "update_date": "2010-10-15", "authors_parsed": [["Lumpe", "Markus", "", "Swinburne University of Technology, Australia"], ["Vasa", "Rajesh", "", "Swinburne University of Technology, Australia"]]}, {"id": "1010.3263", "submitter": "Janusz Brzozowski", "authors": "Janusz Brzozowski and Yuli Ye", "title": "Syntactic Complexity of Ideal and Closed Languages", "comments": "22 pages, 8 figures in .eepic format", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The state complexity of a regular language is the number of states in the\nminimal deterministic automaton accepting the language. The syntactic\ncomplexity of a regular language is the cardinality of its syntactic semigroup.\nThe syntactic complexity of a subclass of regular languages is the worst-case\nsyntactic complexity taken as a function of the state complexity $n$ of\nlanguages in that class. We study the syntactic complexity of the class of\nregular ideal languages and their complements, the closed languages. We prove\nthat $n^{n-1}$ is a tight upper bound on the complexity of right ideals and\nprefix-closed languages, and that there exist left ideals and suffix-closed\nlanguages of syntactic complexity $n^{n-1}+n-1$, and two-sided ideals and\nfactor-closed languages of syntactic complexity $n^{n-2}+(n-2)2^{n-2}+1$.\n", "versions": [{"version": "v1", "created": "Fri, 15 Oct 2010 20:06:43 GMT"}], "update_date": "2010-10-19", "authors_parsed": [["Brzozowski", "Janusz", ""], ["Ye", "Yuli", ""]]}, {"id": "1010.3640", "submitter": "Steffen Kopecki", "authors": "Steffen Kopecki", "title": "On the Iterated Hairpin Completion", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The (bounded) hairpin completion and its iterated versions are operations on\nformal lan- guages which have been inspired by the hairpin formation in\nDNA-biochemistry. The paper answers two questions asked in the literature about\nthe iterated hairpin completion.\n  The first question is whether the class of regular languages is closed under\niterated bounded hairpin completion. Here we show that this is true by\nproviding a more general result which applies to all the classes of languages\nwhich are closed under finite union, intersection with regular sets, and\nconcatenation with regular sets. In particular, all Chomsky classes and all\nstandard complexity classes are closed under iterated bounded hairpin\ncompletion.\n  In the second part of the paper we address the question whether the iterated\nhairpin completion of a singleton is always regular. In contrast to the first\nquestion, this one has a negative answer. We exhibit an example of a singleton\nlanguage whose iterated hairpin completion is not regular, actually it is not\ncontext-free, but context-sensitive.\n", "versions": [{"version": "v1", "created": "Mon, 18 Oct 2010 16:03:40 GMT"}, {"version": "v2", "created": "Tue, 25 Jan 2011 15:01:54 GMT"}, {"version": "v3", "created": "Wed, 9 Mar 2011 17:37:35 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Kopecki", "Steffen", ""]]}, {"id": "1010.4760", "submitter": "Petr Jancar", "authors": "Petr Jancar", "title": "A Short Decidability Proof for DPDA Language Equivalence via First-Order\n  Grammars", "comments": "28 pages, version 4 reworks the main proof and omits the\n  nondeterministic case where a problem was found by G. Senizergues", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The main aim of the paper is to give a short self-contained proof of the\ndecidability of language equivalence for deterministic pushdown automata, which\nis the famous problem solved by G. Senizergues, for which C. Stirling has\nderived a primitive recursive complexity upper bound. The proof here is given\nin the framework of first-order grammars, which seems to be particularly apt\nfor the aim. An appendix presents a modification of Stirling's approach,\nyielding a complexity bound of the form tetr(2,g(n)) where tetr is the\n(nonelementary) operator of iterated exponentiation (tetration) and g is an\nelementary function of the input size.\n", "versions": [{"version": "v1", "created": "Fri, 22 Oct 2010 17:20:28 GMT"}, {"version": "v2", "created": "Thu, 18 Nov 2010 18:24:35 GMT"}, {"version": "v3", "created": "Thu, 9 Dec 2010 17:35:47 GMT"}, {"version": "v4", "created": "Wed, 9 Mar 2011 11:08:23 GMT"}], "update_date": "2011-03-10", "authors_parsed": [["Jancar", "Petr", ""]]}, {"id": "1010.4953", "submitter": "Soumyadip Bandyopadhyay", "authors": "Soumyadip Bandyopadhyay", "title": "Equivalence Checking in Embedded Systems Design Verification using PRES+\n  model", "comments": "i want to replace the previous report, arXiv:1007.2131, by this\n  report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we focus on some aspects related to modeling and formal\nverification of embedded systems. Many models have been proposed to represent\nembedded systems. These models encompass a broad range of styles,\ncharacteristics, and application domains and include the extensions of finite\nstate machines, data flow graphs, communication processes and Petri nets. In\nthis report, we have used a PRES+ model (Petri net based Representation for\nEmbedded Systems) as an extension of classical Petri net model that captures\nconcurrency, timing behaviour of embedded systems; it allows systems to be\nrepresentative in different levels of abstraction and improves expressiveness\nby allowing the token to carry information. Modeling using PRES+, as discussed\nabove, may be convenient for specifying the input behaviour because it supports\nconcurrency. However, there is no equivalence checking method reported in the\nliterature for PRES+ models to the best of our knowledge. In contrast,\nequivalence checking of FSMD models exist. As a first step, therefore, we seek\nto devise an algorithm to translate PRES+ models to FSMD models and we seek to\nhand execute our algorithm on a real life example and we have to translate two\nversions of PRES+ models to FSMD models. Then using existing equivalence\nchecker we have checked the equivalence between two FSMD models.\n", "versions": [{"version": "v1", "created": "Sun, 24 Oct 2010 12:12:10 GMT"}], "update_date": "2010-10-26", "authors_parsed": [["Bandyopadhyay", "Soumyadip", ""]]}, {"id": "1010.5318", "submitter": "Jean Berstel", "authors": "Jean Berstel and Luc Boasson and Olivier Carton and Isabelle Fagnot", "title": "Minimization of Automata", "comments": "This paper is the manuscript of chapter 10 of the Handbook \"Automata:\n  from Mathematics to Applications\" to be published by the European\n  Mathematical Society", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This chapter is concerned with the design and analysis of algorithms for\nminimizing finite automata. Getting a minimal automaton is a fundamental issue\nin the use and implementation of finite automata tools in frameworks like text\nprocessing, image analysis, linguistic computer science, and many other\napplications. There are two main families of minimization algorithms. The first\nby a sequence of refinements of a partition of the set of states, the second by\na sequence of fusions or merges of states. Hopcroft's and Moore's algorithms\nbelong to the first family, the linear-time minimization of acyclic automata of\nRevuz belongs to the second family.\n  One of our studies is upon the comparison of the nature of Moore's and\nHopcroft's algorithms. This gives some new insight in both algorithms. As we\nshall see, these algorithms are quite different both in behavior and in\ncomplexity. In particular, we show that it is not possible to simulate the\ncomputations of one of the algorithm by the other. We describe the minimization\nalgorithm by fusion for so-called local automata. A special case of\nminimization is the construction o minimal automata for finite sets. We\nconsider briefly this case, and in particular describe incremental algorithms.\nFinally, we consider the case of updating a minimal automaton when a word is\nadded or removed from the set it recognizes.\n", "versions": [{"version": "v1", "created": "Tue, 26 Oct 2010 06:03:55 GMT"}, {"version": "v2", "created": "Fri, 26 Nov 2010 12:52:48 GMT"}, {"version": "v3", "created": "Thu, 30 Dec 2010 06:50:32 GMT"}], "update_date": "2011-01-04", "authors_parsed": [["Berstel", "Jean", ""], ["Boasson", "Luc", ""], ["Carton", "Olivier", ""], ["Fagnot", "Isabelle", ""]]}, {"id": "1010.5391", "submitter": "Narad Rampersad", "authors": "Emilie Charlier and Anne Lacroix and Narad Rampersad", "title": "Multi-dimensional sets recognizable in all abstract numeration systems", "comments": "11 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the subsets of N^d that are S-recognizable for all abstract\nnumeration systems S are exactly the 1-recognizable sets. This generalizes a\nresult of Lecomte and Rigo in the one-dimensional setting.\n", "versions": [{"version": "v1", "created": "Tue, 26 Oct 2010 13:29:20 GMT"}], "update_date": "2010-10-27", "authors_parsed": [["Charlier", "Emilie", ""], ["Lacroix", "Anne", ""], ["Rampersad", "Narad", ""]]}, {"id": "1010.5456", "submitter": "Arseny Shur", "authors": "Arseny M. Shur", "title": "Combinatorial Characterization of Formal Languages", "comments": "41 page 1 figure, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper is an extended abstract of the dissertation presented by the\nauthor for the doctoral degree in physics and mathematics (in Russia). The main\ncharacteristic studied in the dissertation is combinatorial complexity, which\nis a \"counting\" function associated with a language and returning the number of\nwords of given length in this language. For several classes of languages, a\nvariety of problems about combinatorial complexity and its connections to other\nparameters of languages are studied. A brief introduction to the topic and the\nformulations of results are presented. No proofs are given; instead, the papers\ncontaining the proofs are cited.\n", "versions": [{"version": "v1", "created": "Tue, 26 Oct 2010 16:45:52 GMT"}], "update_date": "2010-10-27", "authors_parsed": [["Shur", "Arseny M.", ""]]}, {"id": "1010.5545", "submitter": "James P. Crutchfield", "authors": "Ryan G. James and John R. Mahoney and Christopher J. Ellison and James\n  P. Crutchfield", "title": "Many Roads to Synchrony: Natural Time Scales and Their Algorithms", "comments": "17 pages, 16 figures:\n  http://cse.ucdavis.edu/~cmg/compmech/pubs/kro.htm. Santa Fe Institute Working\n  Paper 10-11-025", "journal-ref": "Phys. Rev. E 89, 042135 (2014)", "doi": "10.1103/PhysRevE.89.042135", "report-no": null, "categories": "nlin.CD cs.FL cs.IT math.DS math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider two important time scales---the Markov and cryptic orders---that\nmonitor how an observer synchronizes to a finitary stochastic process. We show\nhow to compute these orders exactly and that they are most efficiently\ncalculated from the epsilon-machine, a process's minimal unifilar model.\nSurprisingly, though the Markov order is a basic concept from stochastic\nprocess theory, it is not a probabilistic property of a process. Rather, it is\na topological property and, moreover, it is not computable from any\nfinite-state model other than the epsilon-machine. Via an exhaustive survey, we\nclose by demonstrating that infinite Markov and infinite cryptic orders are a\ndominant feature in the space of finite-memory processes. We draw out the roles\nplayed in statistical mechanical spin systems by these two complementary length\nscales.\n", "versions": [{"version": "v1", "created": "Wed, 27 Oct 2010 00:55:18 GMT"}, {"version": "v2", "created": "Fri, 20 Dec 2013 23:00:48 GMT"}], "update_date": "2014-04-23", "authors_parsed": [["James", "Ryan G.", ""], ["Mahoney", "John R.", ""], ["Ellison", "Christopher J.", ""], ["Crutchfield", "James P.", ""]]}, {"id": "1010.5571", "submitter": "EPTCS", "authors": "Matthieu Lemerre (CEA LIST), Vincent David (CEA LIST), Christophe\n  Aussagu\\`es (CEA LIST), Guy Vidal-Naquet (SUPELEC)", "title": "An Introduction to Time-Constrained Automata", "comments": "In Proceedings ICE 2010, arXiv:1010.5308", "journal-ref": "EPTCS 38, 2010, pp. 83-98", "doi": "10.4204/EPTCS.38.9", "report-no": null, "categories": "cs.LO cs.FL cs.OS cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present time-constrained automata (TCA), a model for hard real-time\ncomputation in which agents behaviors are modeled by automata and constrained\nby time intervals.\n  TCA actions can have multiple start time and deadlines, can be aperiodic, and\nare selected dynamically following a graph, the time-constrained automaton.\nThis allows expressing much more precise time constraints than classical\nperiodic or sporadic model, while preserving the ease of scheduling and\nanalysis.\n  We provide some properties of this model as well as their scheduling\nsemantics. We show that TCA can be automatically derived from source-code, and\noptimally scheduled on single processors using a variant of EDF. We explain how\ntime constraints can be used to guarantee communication determinism by\nconstruction, and to study when possible agent interactions happen.\n", "versions": [{"version": "v1", "created": "Wed, 27 Oct 2010 05:04:38 GMT"}], "update_date": "2010-10-28", "authors_parsed": [["Lemerre", "Matthieu", "", "CEA LIST"], ["David", "Vincent", "", "CEA LIST"], ["Aussagu\u00e8s", "Christophe", "", "CEA LIST"], ["Vidal-Naquet", "Guy", "", "SUPELEC"]]}, {"id": "1010.6112", "submitter": "EPTCS", "authors": "Yu-Fang Chen (Academia Sinica, Taiwan), Ahmed Rezine (Uppsala\n  University, Sweden)", "title": "Proceedings 12th International Workshop on Verification of\n  Infinite-State Systems", "comments": null, "journal-ref": "EPTCS 39, 2010", "doi": "10.4204/EPTCS.39", "report-no": null, "categories": "cs.FL cs.CC cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The aim of the INFINITY workshop is to provide a forum for researchers\ninterested in the development of formal methods and algorithmic techniques for\nthe analysis of systems with infinitely many states, and their application in\nautomated verification of complex software and hardware systems.\n", "versions": [{"version": "v1", "created": "Thu, 28 Oct 2010 23:39:56 GMT"}], "update_date": "2010-11-01", "authors_parsed": [["Chen", "Yu-Fang", "", "Academia Sinica, Taiwan"], ["Rezine", "Ahmed", "", "Uppsala\n  University, Sweden"]]}]