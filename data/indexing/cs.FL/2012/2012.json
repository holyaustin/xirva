[{"id": "2012.00428", "submitter": "Jure Brence", "authors": "Jure Brence and Ljup\\v{c}o Todorovski and Sa\\v{s}o D\\v{z}eroski", "title": "Probabilistic Grammars for Equation Discovery", "comments": "Submitted to Knowledge-Based Systems, Elsevier. 28 pages + 13 pages\n  appendix. 7 figures", "journal-ref": null, "doi": "10.1016/j.knosys.2021.107077", "report-no": null, "categories": "cs.LG cs.FL stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Equation discovery, also known as symbolic regression, is a type of automated\nmodeling that discovers scientific laws, expressed in the form of equations,\nfrom observed data and expert knowledge. Deterministic grammars, such as\ncontext-free grammars, have been used to limit the search spaces in equation\ndiscovery by providing hard constraints that specify which equations to\nconsider and which not. In this paper, we propose the use of probabilistic\ncontext-free grammars in equation discovery. Such grammars encode soft\nconstraints, specifying a prior probability distribution on the space of\npossible equations. We show that probabilistic grammars can be used to\nelegantly and flexibly formulate the parsimony principle, that favors simpler\nequations, through probabilities attached to the rules in the grammars. We\ndemonstrate that the use of probabilistic, rather than deterministic grammars,\nin the context of a Monte-Carlo algorithm for grammar-based equation discovery,\nleads to more efficient equation discovery. Finally, by specifying prior\nprobability distributions over equation spaces, the foundations are laid for\nBayesian approaches to equation discovery.\n", "versions": [{"version": "v1", "created": "Tue, 1 Dec 2020 11:59:19 GMT"}, {"version": "v2", "created": "Mon, 22 Mar 2021 10:53:27 GMT"}], "update_date": "2021-04-29", "authors_parsed": [["Brence", "Jure", ""], ["Todorovski", "Ljup\u010do", ""], ["D\u017eeroski", "Sa\u0161o", ""]]}, {"id": "2012.01181", "submitter": "EPTCS", "authors": "Berthold Hoffmann (Universit\\\"at Bremen), Mark Minas (Universit\\\"at\n  der Bundeswehr M\\\"unchen)", "title": "Proceedings of the Eleventh International Workshop on Graph Computation\n  Models", "comments": "This volume contains the post-proceedings of the Eleventh\n  International Workshop on Graph Computation Models (GCM 2020). The workshop\n  was originally planned as part of STAF 2020 (Software Technologies:\n  Applications and Foundations), to be held in Bergen, Norway, but then held as\n  an online-workshop on 24th June 2020, because of the COVID-19 pandemic", "journal-ref": "EPTCS 330, 2020", "doi": "10.4204/EPTCS.330", "report-no": null, "categories": "cs.FL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Graphs are common mathematical structures that are visual and intuitive. They\nconstitute a natural and seamless way for system modelling in science,\nengineering and beyond, including computer science, biology, business process\nmodelling, etc. Graph computation models constitute a class of very high-level\nmodels where graphs are first-class citizens. The aim of the International GCM\nWorkshop series is to bring together researchers interested in all aspects of\ncomputation models based on graphs and graph transformation. It promotes the\ncross-fertilizing exchange of ideas and experiences among senior and young\nresearchers from the different communities interested in the foundations,\napplications, and implementations of graph computation models and related\nareas.\n", "versions": [{"version": "v1", "created": "Wed, 2 Dec 2020 13:11:35 GMT"}], "update_date": "2020-12-03", "authors_parsed": [["Hoffmann", "Berthold", "", "Universit\u00e4t Bremen"], ["Minas", "Mark", "", "Universit\u00e4t\n  der Bundeswehr M\u00fcnchen"]]}, {"id": "2012.01309", "submitter": "Manfred Kufleitner", "authors": "Viktor Henriksson and Manfred Kufleitner", "title": "Nesting negations in FO2 over infinite words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We consider two-variable first-order logic FO2 over infinite words.\nRestricting the number of nested negations defines an infinite hierarchy; its\nlevels are often called the half-levels of the FO2 quantifier alternation\nhierarchy. For every level of this hierarchy, we give an effective\ncharacterization. For the lower levels, this characterization is a combination\nof an algebraic and a topological property. For the higher levels, algebraic\nproperties turn out to be sufficient. Within two-variable first-order logic,\neach algebraic property is a single ordered identity of omega-terms. The\ntopological properties are the same as for the lower half-levels of the\nquantifier alternation hierarchy without the two-variable restriction (i.e.,\nthe Cantor topology and the alphabetic topology).\n  Our result generalizes the corresponding result for finite words. The proof\nuses novel techniques and is based on a refinement of Mal'cev products for\nordered monoids.\n", "versions": [{"version": "v1", "created": "Wed, 2 Dec 2020 16:29:35 GMT"}], "update_date": "2020-12-03", "authors_parsed": [["Henriksson", "Viktor", ""], ["Kufleitner", "Manfred", ""]]}, {"id": "2012.01647", "submitter": "EPTCS", "authors": "Mehrnoosh Askarpour (McMaster University)", "title": "How to Formally Model Human in Collaborative Robotics", "comments": "In Proceedings FMAS 2020, arXiv:2012.01176", "journal-ref": "EPTCS 329, 2020, pp. 1-14", "doi": "10.4204/EPTCS.329.1", "report-no": null, "categories": "cs.RO cs.FL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Human-robot collaboration (HRC) is an emerging trend of robotics that\npromotes the co-presence and cooperation of humans and robots in common\nworkspaces. Physical vicinity and interaction between humans and robots,\ncombined with the uncertainty of human behaviour, could lead to undesired\nsituations where humans are injured. Thus, safety is a priority for HRC\napplications.\n  Safety analysis via formal modelling and verification techniques could\nconsiderably avoid dangerous consequences, but only if the models of HRC\nsystems are comprehensive and realistic, which requires reasonably realistic\nmodels of human behaviour. This paper explores state-of-the-art solutions for\nmodelling human and discusses which ones are suitable for HRC scenarios.\n", "versions": [{"version": "v1", "created": "Thu, 3 Dec 2020 02:21:37 GMT"}], "update_date": "2020-12-04", "authors_parsed": [["Askarpour", "Mehrnoosh", "", "McMaster University"]]}, {"id": "2012.01660", "submitter": "EPTCS", "authors": "Tikhon Pshenitsyn (Lomonosov Moscow State University, Russia)", "title": "Weak Greibach Normal Form for Hyperedge Replacement Grammars", "comments": "In Proceedings GCM 2020, arXiv:2012.01181", "journal-ref": "EPTCS 330, 2020, pp. 108-125", "doi": "10.4204/EPTCS.330.7", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is known that hyperedge replacement grammars are similar to string\ncontext-free grammars in the sense of definitions and properties. Therefore, we\nexpect that there is a generalization of the well-known Greibach normal form\nfrom string grammars to hypergraph grammars. Such generalized normal forms are\npresented in several papers; however, they do not cover a large class of\nhypergraph languages (e.g. languages consisting of star graphs). In this paper,\nwe introduce a weak Greibach normal form, whose definition corresponds to the\nlexicalized normal form for string grammars, and prove that every context-free\nhypergraph language (with nonsubstantial exceptions) can be generated by a\ngrammar in this normal form. The proof presented in this paper generalizes a\ncorresponding one for string grammars with a few more technicalities.\n", "versions": [{"version": "v1", "created": "Thu, 3 Dec 2020 02:28:54 GMT"}], "update_date": "2020-12-04", "authors_parsed": [["Pshenitsyn", "Tikhon", "", "Lomonosov Moscow State University, Russia"]]}, {"id": "2012.03395", "submitter": "Alexander Okhotin", "authors": "Alexander Okhotin, Victor L. Selivanov", "title": "Input-driven automata on well-nested infinite strings:\n  automata-theoretic and topological properties", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Automata operating on strings of nested brackets, known as input-driven\npushdown automata, and as visibly pushdown automata, have been studied since\nthe 1980s. They were extended to the case of infinite strings by Alur and\nMadhusudan (\"Visibly pushdown languages\", STOC 2004). This paper investigates\nthe properties of these automata under the assumption that a given infinite\nstring is always well-nested. This restriction enables a complete\ncharacterization of the corresponding $\\omega$-languages in terms of classical\n$\\omega$-regular languages and input-driven automata on finite strings. This\ncharacterization leads to a determinization result for these automata, as well\nas to the first results on their Wadge degrees.\n", "versions": [{"version": "v1", "created": "Sun, 6 Dec 2020 23:50:08 GMT"}], "update_date": "2020-12-08", "authors_parsed": [["Okhotin", "Alexander", ""], ["Selivanov", "Victor L.", ""]]}, {"id": "2012.03538", "submitter": "Alexander Okhotin", "authors": "Alexander Okhotin", "title": "Describing the syntax of programming languages using conjunctive and\n  Boolean grammars", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.PL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  A classical result by Floyd (\"On the non-existence of a phrase structure\ngrammar for ALGOL 60\", 1962) states that the complete syntax of any sensible\nprogramming language cannot be described by the ordinary kind of formal\ngrammars (Chomsky's ``context-free''). This paper uses grammars extended with\nconjunction and negation operators, known as conjunctive grammars and Boolean\ngrammars, to describe the set of well-formed programs in a simple typeless\nprocedural programming language. A complete Boolean grammar, which defines such\nconcepts as declaration of variables and functions before their use, is\nconstructed and explained. Using the Generalized LR parsing algorithm for\nBoolean grammars, a program can then be parsed in time $O(n^4)$ in its length,\nwhile another known algorithm allows subcubic-time parsing. Next, it is shown\nhow to transform this grammar to an unambiguous conjunctive grammar, with\nsquare-time parsing. This becomes apparently the first specification of the\nsyntax of a programming language entirely by a computationally feasible formal\ngrammar.\n", "versions": [{"version": "v1", "created": "Mon, 7 Dec 2020 09:05:48 GMT"}], "update_date": "2020-12-08", "authors_parsed": [["Okhotin", "Alexander", ""]]}, {"id": "2012.03567", "submitter": "Alexander Okhotin", "authors": "Ekaterina Shemetova, Alexander Okhotin, Semyon Grigorev", "title": "Rational index of bounded-oscillation languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  The rational index of a context-free language $L$ is a function $f(n)$, such\nthat for each regular language $R$ recognized by an automaton with $n$ states,\nthe intersection of $L$ and $R$ is either empty or contains a word shorter than\n$f(n)$. It is known that the context-free language (CFL-)reachability problem\nand Datalog query evaluation for context-free languages (queries) with the\npolynomial rational index is in NC, while these problems is P-complete in the\ngeneral case. We investigate the rational index of bounded-oscillation\nlanguages and show that it is of polynomial order. We obtain upper bounds on\nthe values of the rational index for general bounded-oscillation languages and\nfor some of its previously studied subclasses.\n", "versions": [{"version": "v1", "created": "Mon, 7 Dec 2020 10:16:40 GMT"}], "update_date": "2020-12-08", "authors_parsed": [["Shemetova", "Ekaterina", ""], ["Okhotin", "Alexander", ""], ["Grigorev", "Semyon", ""]]}, {"id": "2012.03596", "submitter": "Alexander Okhotin", "authors": "Mikhail Mrykhin, Alexander Okhotin", "title": "The hardest language for grammars with context operators", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  In 1973, Greibach (\"The hardest context-free language\", SIAM J. Comp., 1973)\nconstructed a context-free language $L_0$ with the property that every\ncontext-free language can be reduced to $L_0$ by a homomorphism, thus\nrepresenting it as an inverse homomorphic image $h^{-1}(L_0)$. In this paper, a\nsimilar characterization is established for a family of grammars equipped with\noperators for referring to the left context of any substring, recently defined\nby Barash and Okhotin (\"An extension of context-free grammars with one-sided\ncontext specifications\", Inform. Comput., 2014). An essential step of the\nargument is a new normal form for grammars with context operators, in which\nevery nonterminal symbol defines only strings of odd length in left contexts of\neven length: the even-odd normal form.\n", "versions": [{"version": "v1", "created": "Mon, 7 Dec 2020 11:32:28 GMT"}], "update_date": "2020-12-08", "authors_parsed": [["Mrykhin", "Mikhail", ""], ["Okhotin", "Alexander", ""]]}, {"id": "2012.03926", "submitter": "Vladislav Makarov", "authors": "Vladislav Makarov", "title": "Counting ternary square-free words quickly", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An efficient, when compared to exhaustive enumeration, algorithm for\ncomputing the number of square-free words of length $n$ over the alphabet $\\{a,\nb, c\\}$ is presented.\n", "versions": [{"version": "v1", "created": "Mon, 7 Dec 2020 18:55:11 GMT"}, {"version": "v2", "created": "Mon, 10 May 2021 13:31:12 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Makarov", "Vladislav", ""]]}, {"id": "2012.04874", "submitter": "Junyao Hou", "authors": "Junyao Hou, Xiang Yin, Shaoyuan Li", "title": "A Framework for Current-State Opacity under Dynamic Information Release\n  Mechanism", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Opacity is an important information-flow security property that characterizes\nthe plausible deniability of a dynamic system for its \"secret\" against\neavesdropping attacks. As an information-flow property, the underlying\nobservation model is the key in the modeling and analysis of opacity. In this\npaper, we investigate the verification of current-state opacity for\ndiscrete-event systems under Orwellian-type observations, i.e., the system is\nallowed to re-interpret the observation of an event based on its future suffix.\nFirst, we propose a new Orwellian-type observation model called the dynamic\ninformation release mechanism (DIRM). In the DIRM, when to release previous\n\"hold on\" events is state-dependent. Then we propose a new definition of\nopacity based on the notion of history-equivalence rather than the standard\nprojection-equivalence. This definition is more suitable for observations that\nare not prefix-closed. Finally, we show that by constructing a new structure\ncalled the DIRM-observer, current-state opacity can be effectively verified\nunder the DIRM. Computational complexity analysis as well as illustrative\nexamples for the proposed approach are also provided. Compared with the\nexisting Orwellian-type observation model, the proposed framework is more\ngeneral in the sense that the information-release-mechanism is state-dependent\nand the corresponding definition of opacity is more suitable for\nnon-prefix-closed observations.\n", "versions": [{"version": "v1", "created": "Wed, 9 Dec 2020 05:34:52 GMT"}], "update_date": "2020-12-10", "authors_parsed": [["Hou", "Junyao", ""], ["Yin", "Xiang", ""], ["Li", "Shaoyuan", ""]]}, {"id": "2012.04969", "submitter": "C\\'elia Cisternino", "authors": "\\'Emilie Charlier, C\\'elia Cisternino and Manon Stipulanti", "title": "Regular sequences and synchronized sequences in abstract numeration\n  systems", "comments": "38 pages, 13 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.FL math.AC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The notion of $b$-regular sequences was generalized to abstract numeration\nsystems by Maes and Rigo in 2002. Their definition is based on a notion of\n$\\mathcal{S}$-kernel that extends that of $b$-kernel. However, this definition\ndoes not allow us to generalize all of the many characterizations of\n$b$-regular sequences. In this paper, we present an alternative definition of\n$\\mathcal{S}$-kernel, and hence an alternative definition of\n$\\mathcal{S}$-regular sequences, which enables us to use recognizable formal\nseries in order to generalize most (if not all) known characterizations of\n$b$-regular sequences to abstract numeration systems. We then give two\ncharacterizations of $\\mathcal{S}$-automatic sequences as particular\n$\\mathcal{S}$-regular sequences. Next, we present a general method to obtain\nvarious families of $\\mathcal{S}$-regular sequences by enumerating\n$\\mathcal{S}$-recognizable properties of $\\mathcal{S}$-automatic sequences. As\nan example of the many possible applications of this method, we show that,\nprovided that addition is $\\mathcal{S}$-recognizable, the factor complexity of\nan $\\mathcal{S}$-automatic sequence defines an $\\mathcal{S}$-regular sequence.\nIn the last part of the paper, we study $\\mathcal{S}$-synchronized sequences.\nAlong the way, we prove that the formal series obtained as the composition of a\nsynchronized relation and a recognizable series is recognizable. As a\nconsequence, the composition of an $\\mathcal{S}$-synchronized sequence and a\n$\\mathcal{S}$-regular sequence is shown to be $\\mathcal{S}$-regular. All our\nresults are presented in an arbitrary dimension $d$ and for an arbitrary\nsemiring $\\mathbb{K}$.\n", "versions": [{"version": "v1", "created": "Wed, 9 Dec 2020 10:49:21 GMT"}], "update_date": "2020-12-10", "authors_parsed": [["Charlier", "\u00c9milie", ""], ["Cisternino", "C\u00e9lia", ""], ["Stipulanti", "Manon", ""]]}, {"id": "2012.06840", "submitter": "Jeffrey Shallit", "authors": "Luke Schaeffer and Jeffrey Shallit", "title": "String Attractors for Automatic Sequences", "comments": "revision adding significant new results due to Luke Schaeffer", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that it is decidable, given an automatic sequence $\\bf s$ and a\nconstant $c$, whether all prefixes of $\\bf s$ have a string attractor of size\n$\\leq c$. Using a decision procedure based on this result, we show that all\nprefixes of the period-doubling sequence of length $\\geq 2$ have a string\nattractor of size $2$. We also prove analogous results for other sequences,\nincluding the Thue-Morse sequence and the Tribonacci sequence.\n  We also provide general upper and lower bounds on string attractor size for\ndifferent kinds of sequences. For example, if $\\bf s$ has a finite appearance\nconstant, then there is a string attractor for ${\\bf s}[0..n-1]$ of size\n$O(\\log n)$. If further $\\bf s$ is linearly recurrent, then there is a string\nattractor for ${\\bf s}[0..n-1]$ of size $O(1)$. For automatic sequences, the\nsize of the smallest string attractor for ${\\bf s}[0..n-1]$ is either\n$\\Theta(1)$ or $\\Theta(\\log n)$, and it is decidable which case occurs.\nFinally, we close with some remarks about greedy string attractors.\n", "versions": [{"version": "v1", "created": "Sat, 12 Dec 2020 15:34:12 GMT"}, {"version": "v2", "created": "Wed, 23 Dec 2020 18:33:39 GMT"}, {"version": "v3", "created": "Thu, 24 Dec 2020 18:31:08 GMT"}, {"version": "v4", "created": "Sat, 26 Dec 2020 11:05:32 GMT"}, {"version": "v5", "created": "Thu, 7 Jan 2021 21:42:26 GMT"}], "update_date": "2021-01-11", "authors_parsed": [["Schaeffer", "Luke", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "2012.08959", "submitter": "Maximilian Schwenger", "authors": "Maximilian Schwenger", "title": "Monitoring Cyber-Physical Systems: From Design to Integration", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-60508-7\\_5", "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cyber-physical systems are inherently safety-critical. The deployment of a\nruntime monitor significantly increases confidence in their safety. The\neffectiveness of the monitor can be maximized by considering it an integral\ncomponent during its development. Thus, in this paper, I given an overview over\nrecent work regarding a development process for runtime monitors alongside a\ncyber-physical system. This process includes the transformation of desirable\nsafety properties into the formal specification language RTLola. A compiler\nthen generates an executable artifact for monitoring the specification. This\nartifact can then be integrated into the system.\n", "versions": [{"version": "v1", "created": "Tue, 15 Dec 2020 15:27:10 GMT"}], "update_date": "2020-12-17", "authors_parsed": [["Schwenger", "Maximilian", ""]]}, {"id": "2012.08961", "submitter": "Maximilian Schwenger", "authors": "Bernd Finkbeiner and Stefan Oswald and Noemi Passing and Maximilian\n  Schwenger", "title": "Verified Rust Monitors for Lola Specifications", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-60508-7\\_24", "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The safety of cyber-physical systems rests on the correctness of their\nmonitoring mechanisms. This is problematic if the specification of the monitor\nis implemented manually or interpreted by unreliable software. We present a\nverifying compiler that translates specifications given in the stream-based\nmonitoring language Lola to implementations in Rust. The generated code\ncontains verification annotations that enable the Viper toolkit to\nautomatically prove functional correctness, absence of memory faults, and\nguaranteed termination. The compiler parallelizes the evaluation of different\nstreams in the monitor based on a dependency analysis of the specification. We\npresent encouraging experimental results obtained with monitor specifications\nfound in the literature. For every specification, our approach was able to\neither produce a correctness proof or to uncover errors in the specification.\n", "versions": [{"version": "v1", "created": "Tue, 15 Dec 2020 14:43:20 GMT"}], "update_date": "2020-12-17", "authors_parsed": [["Finkbeiner", "Bernd", ""], ["Oswald", "Stefan", ""], ["Passing", "Noemi", ""], ["Schwenger", "Maximilian", ""]]}, {"id": "2012.10186", "submitter": "Ville Salo", "authors": "Ville Salo", "title": "Graph and wreath products of cellular automata", "comments": "20 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the set of subgroups of the automorphism group of a two-sided\nfull shift is closed under graph products. We introduce the notion of an\nAithful group action, and show that when A is a finite abelian group and G is a\ngroup of cellular automata whose action is Aithful, the wreath product A \\wr G\nembeds in the automorphism group of a full shift. We show that all free abelian\ngroups and free groups admit Aithful cellular automata actions. In the\none-sided case, we prove variants of these result with reasonable alphabet\nblow-ups.\n", "versions": [{"version": "v1", "created": "Fri, 18 Dec 2020 12:16:13 GMT"}], "update_date": "2020-12-21", "authors_parsed": [["Salo", "Ville", ""]]}, {"id": "2012.10188", "submitter": "Julian Bradfield", "authors": "Nargess Ghahremani and Julian Bradfield", "title": "On probabilistic stable event structures", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Concurrency and probability are both much studied extensions of sequential\ncomputation. Within concurrency theory, there is a broad divide between\ninterleaving models and logics, which model concurrency by non-determinism, and\n`truly concurrent' models, in which concurrency (and/or causality) are directly\nrepresented. True concurrency gives much richer models and logics, but is also\nharder to work with, as the interactions of causality and concurrency can\nbecome complex.\n  In probabilistic computation, we have by now many well understood\nprobabilistic models and logics on interleaving models, developed over the last\nthirty years or so. However, for true concurrency, adding probability has been\nmuch harder, owing to the interactions between probabilistic independence and\ncausal/concurrent independence, piling both conceptual and technical\ndifficulties upon an already complex model. Various notions of, e.g.,\nprobabilistic Petri net have been introduced, but for simpler cases such as\nfree-choice nets.\n  A significant contribution in the last decade was Abbes and Benveniste 2006,\nwhich gave a rigorous foundation for probabilistic concurrency in terms of\nWinskel's event structures, which can be seen as the lowest level of\nconcurrent/causal modelling. However, event structures are themselves not ideal\nfor representing richer high-level models such as (arbitrary) Petri nets, as\nthe concurrency is derived from a binary conflict relation.\n  Here we develop an extension of the theory of Abbes and Benveniste to a more\ngeneral class of models, a certain subclass of `stable event structures'. This\nclass is sufficient to give a semantics to probabilistic Petri nets (including\nthe notoriously awkward notion of confusion, which is forbidden by free-choice\nnets), and thereby allows the definition of general probabilistic logics for\nPetri nets.\n", "versions": [{"version": "v1", "created": "Fri, 18 Dec 2020 12:18:25 GMT"}], "update_date": "2020-12-21", "authors_parsed": [["Ghahremani", "Nargess", ""], ["Bradfield", "Julian", ""]]}, {"id": "2012.10431", "submitter": "Elias Gr\\\"unewald", "authors": "Elias Gr\\\"unewald and Frank Pallas", "title": "TILT: A GDPR-Aligned Transparency Information Language and Toolkit for\n  Practical Privacy Engineering", "comments": "Accepted for publication at the ACM Conference on Fairness,\n  Accountability, and Transparency 2021 (ACM FAccT'21). This is a preprint\n  manuscript (authors' own version before final copy-editing)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CY cs.CR cs.FL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present TILT, a transparency information language and\ntoolkit explicitly designed to represent and process transparency information\nin line with the requirements of the GDPR and allowing for a more automated and\nadaptive use of such information than established, legalese data protection\npolicies do.\n  We provide a detailed analysis of transparency obligations from the GDPR to\nidentify the expressiveness required for a formal transparency language\nintended to meet respective legal requirements. In addition, we identify a set\nof further, non-functional requirements that need to be met to foster practical\nadoption in real-world (web) information systems engineering. On this basis, we\nspecify our formal language and present a respective, fully implemented toolkit\naround it. We then evaluate the practical applicability of our language and\ntoolkit and demonstrate the additional prospects it unlocks through two\ndifferent use cases: a) the inter-organizational analysis of personal\ndata-related practices allowing, for instance, to uncover data sharing networks\nbased on explicitly announced transparency information and b) the presentation\nof formally represented transparency information to users through novel, more\ncomprehensible, and potentially adaptive user interfaces, heightening data\nsubjects' actual informedness about data-related practices and, thus, their\nsovereignty.\n  Altogether, our transparency information language and toolkit allow -\ndifferently from previous work - to express transparency information in line\nwith actual legal requirements and practices of modern (web) information\nsystems engineering and thereby pave the way for a multitude of novel\npossibilities to heighten transparency and user sovereignty in practice.\n", "versions": [{"version": "v1", "created": "Fri, 18 Dec 2020 18:45:04 GMT"}], "update_date": "2020-12-21", "authors_parsed": [["Gr\u00fcnewald", "Elias", ""], ["Pallas", "Frank", ""]]}, {"id": "2012.10641", "submitter": "Ludovic Mignot", "authors": "Ludovic Mignot", "title": "A unified implementation of automata and expression structures, and of\n  the associated algorithms using enriched categories", "comments": "Manuscrit d'habilitation \\`a diriger des recherches, in French", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this document, we propose a description, via a Haskell implementation, of\na generalization of the notion of regular expression allowing us to group the\ndefinitions and the methods of (tree or word) automata constructions over one\ngeneric structure, based on enriched category theory tools. We first recall\nseveral methods of conversion from expressions to automata, enlightening the\nsimilarities between the words and trees cases. We then produce an original\nstudy of the power of enriched category theory applied 1) to automata and\nexpressions implementation, and 2) to the study of associated algorithms, using\nadvanced concepts of functional programming, while simultaneously constructing\na Haskell implementation of notions of enriched category theory and associated\nautomata. More precisely, the Haskell implementation and the algebraic\ndefinition of the generic automaton structure are based on the following ideas:\n  - enriched categories, enriched functors, enriched monads, etc. can be\nimplemented in Haskell;\n  - Type level programming can be used to properly encode function arity;\n  - monoids (word structure) and operads (tree structure) can be encoded as\nmonoid objects;\n  - tree and word automata can be represented by the same algebraic structure,\nvia enriched categories.\n  This generalization leads to surprising remarks. As an example, some\nclassical algorithms (determinization, completion, conversion from alternating\nto deterministic automaton) can be regrouped in only one function. We will then\ndefine a notion of generalized expressions based on the notion of monoidal\ntensor product.\n  Haskell sources are available at:\nhttp://ludovicmignot.free.fr/HDR/src-HDR.zip\n", "versions": [{"version": "v1", "created": "Sat, 19 Dec 2020 09:45:28 GMT"}], "update_date": "2020-12-22", "authors_parsed": [["Mignot", "Ludovic", ""]]}, {"id": "2012.10949", "submitter": "Alexandros Haridis (Charidis)", "authors": "Alexandros Haridis and George Stiny", "title": "Analysis of shape grammars: continuity of rules", "comments": "23 pages, 6 Figures, 6 Tables. Research Report, 2020, MIT. Preprint\n  of Journal Article (2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The rules in a shape grammar apply in terms of embedding to take advantage of\nthe parts that emerge visually in the appearance of shapes. While the shapes\nare kept unanalyzed throughout a computation, their descriptions can be defined\nretrospectively based on how the rules are applied. An important outcome of\nthis is that continuity for rules is not built-in but it is \"fabricated\"\nretrospectively to explain a computation as a continuous process. An aspect of\ncontinuity analysis that has not been addressed in the literature is how to\ndecide which mapping forms to use to study the continuity of rule applications.\nThis is addressed in this paper in a new approach to continuity analysis, which\nuses recent results on shape topology and continuous mappings. A\ncharacterization is provided that distinguishes the suitable mapping forms from\nthose that are inherently discontinuous or practically inconsequential for\ncontinuity analysis. It is also shown that certain inherent properties of shape\ntopologies and continuous mappings provide an effective method of computing\ntopologies algorithmically.\n", "versions": [{"version": "v1", "created": "Sun, 20 Dec 2020 15:17:18 GMT"}, {"version": "v2", "created": "Fri, 9 Jul 2021 00:39:45 GMT"}], "update_date": "2021-07-12", "authors_parsed": [["Haridis", "Alexandros", ""], ["Stiny", "George", ""]]}, {"id": "2012.12100", "submitter": "Sylvain Salvati", "authors": "Kilian Gebhardt, Fr\\'ed\\'eric Meunier, Sylvain Salvati", "title": "$O_n$ is an $n$-MCFL", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Commutative properties in formal languages pose problems at the frontier of\ncomputer science, computational linguistics and computational group theory. A\nprominent problem of this kind is the position of the language $O_n$, the\nlanguage that contains the same number of letters $a_i$ and $\\bar a_i$ with\n$1\\leq i\\leq n$, in the known classes of formal languages. It has recently been\nshown that $O_n$ is a Multiple Context-Free Language (MCFL). However the more\nprecise conjecture of Nederhof that $O_n$ is an MCFL of dimension $n$ was left\nopen. We present two proofs of this conjecture, both relying on tools from\nalgebraic topology. On our way, we prove a variant of the necklace splitting\ntheorem.\n", "versions": [{"version": "v1", "created": "Tue, 22 Dec 2020 15:40:58 GMT"}], "update_date": "2020-12-23", "authors_parsed": [["Gebhardt", "Kilian", ""], ["Meunier", "Fr\u00e9d\u00e9ric", ""], ["Salvati", "Sylvain", ""]]}, {"id": "2012.12716", "submitter": "F.J Wang", "authors": "Fujun Wang, Zining Cao, Lixing Tan, Zhen Li", "title": "Formal modeling and performance evaluation for hybrid systems:a\n  probabilistic hybrid process algebra-based approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Probabilistic behavior is omnipresent in computer controlled systems, in\nparticular, so-called safety-critical hybrid systems, because of various\nreasons, like uncertain environments, or fundamental properties of nature. In\nthis paper, we extend existing hybrid process algebra $ACP_{hs}^{srt}$ with\nprobability without replacing nondeterministic choice operator. In view of some\nshortcomings in existing approximate probabilistic bisimulation, we relax the\nconstrains and propose a novel approximate probabilistic bisimulation relation.\nAfter that, we present a performance evaluation language, CTRML, to reason over\nprobabilistic systems, which extend the results to real number. Along with the\nspecification language, we present a set of algorithms for the evaluation of\nthe language. Additionally, we transfer the hybrid process algebra to\nprobabilistic transition system and show experimental results.\n", "versions": [{"version": "v1", "created": "Wed, 23 Dec 2020 14:43:02 GMT"}], "update_date": "2021-01-04", "authors_parsed": [["Wang", "Fujun", ""], ["Cao", "Zining", ""], ["Tan", "Lixing", ""], ["Li", "Zhen", ""]]}, {"id": "2012.13739", "submitter": "Mahsa Shirmohammadi", "authors": "Stefan Kiefer, Richard Mayr, Mahsa Shirmohammadi, Patrick Totzke", "title": "Transience in Countable MDPs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.PR cs.FL cs.GT math.OC", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The Transience objective is not to visit any state infinitely often. While\nthis is not possible in finite Markov Decision Process (MDP), it can be\nsatisfied in countably infinite ones, e.g., if the transition graph is acyclic.\nWe prove the following fundamental properties of Transience in countably\ninfinite MDPs.\n  1. There exist uniformly $\\epsilon$-optimal MD strategies (memoryless\ndeterministic) for Transience, even in infinitely branching MDPs.\n  2. Optimal strategies for Transience need not exist, even if the MDP is\nfinitely branching. However, if an optimal strategy exists then there is also\nan optimal MD strategy.\n  3. If an MDP is universally transient (i.e., almost surely transient under\nall strategies) then many other objectives have a lower strategy complexity\nthan in general MDPs. E.g., $\\epsilon$-optimal strategies for Safety and\nco-B\\\"uchi and optimal strategies for $\\{0,1,2\\}$-Parity (where they exist) can\nbe chosen MD, even if the MDP is infinitely branching.\n", "versions": [{"version": "v1", "created": "Sat, 26 Dec 2020 13:39:19 GMT"}, {"version": "v2", "created": "Fri, 1 Jan 2021 13:40:11 GMT"}, {"version": "v3", "created": "Sun, 4 Jul 2021 17:43:25 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["Kiefer", "Stefan", ""], ["Mayr", "Richard", ""], ["Shirmohammadi", "Mahsa", ""], ["Totzke", "Patrick", ""]]}, {"id": "2012.14235", "submitter": "Margarida Ferreira", "authors": "Margarida Ferreira and Miguel Terra-Neves and Miguel Ventura and\n  In\\^es Lynce and Ruben Martins", "title": "FOREST: An Interactive Multi-tree Synthesizer for Regular Expressions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.AI", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Form validators based on regular expressions are often used on digital forms\nto prevent users from inserting data in the wrong format. However, writing\nthese validators can pose a challenge to some users. We present FOREST, a\nregular expression synthesizer for digital form validations. FOREST produces a\nregular expression that matches the desired pattern for the input values and a\nset of conditions over capturing groups that ensure the validity of integer\nvalues in the input. Our synthesis procedure is based on enumerative search and\nuses a Satisfiability Modulo Theories (SMT) solver to explore and prune the\nsearch space. We propose a novel representation for regular expressions\nsynthesis, multi-tree, which induces patterns in the examples and uses them to\nsplit the problem through a divide-and-conquer approach. We also present a new\nSMT encoding to synthesize capture conditions for a given regular expression.\nTo increase confidence in the synthesized regular expression, we implement user\ninteraction based on distinguishing inputs. We evaluated FOREST on real-world\nform-validation instances using regular expressions. Experimental results show\nthat FOREST successfully returns the desired regular expression in 72% of the\ninstances and outperforms REGEL, a state-of-the-art regular expression\nsynthesizer.\n", "versions": [{"version": "v1", "created": "Mon, 28 Dec 2020 14:06:01 GMT"}], "update_date": "2020-12-29", "authors_parsed": [["Ferreira", "Margarida", ""], ["Terra-Neves", "Miguel", ""], ["Ventura", "Miguel", ""], ["Lynce", "In\u00eas", ""], ["Martins", "Ruben", ""]]}, {"id": "2012.14586", "submitter": "Hazem Torfah", "authors": "Bernd Finkbeiner, Lennart Haas, Hazem Torfah", "title": "Canonical Representations of k-Safety Hyperproperties", "comments": "Published in: 2019 IEEE 32nd Computer Security Foundations Symposium\n  (CSF)", "journal-ref": null, "doi": "10.1109/CSF.2019.00009", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hyperproperties elevate the traditional view of trace properties form sets of\ntraces to sets of sets of traces and provide a formalism for expressing\ninformation-flow policies. For trace properties, algorithms for verification,\nmonitoring, and synthesis are typically based on a representation of the\nproperties as omega-automata. For hyperproperties, a similar, canonical\nautomata-theoretic representation is, so far, missing. This is a serious\nobstacle for the development of algorithms, because basic constructions, such\nas learning algorithms, cannot be applied.\n  In this paper, we present a canonical representation for the widely used\nclass of regular k-safety hyperproperties, which includes important polices\nsuch as noninterference. We show that a regular k-safety hyperproperty S can be\nrepresented by a finite automaton, where each word accepted by the automaton\nrepresents a violation of S. The representation provides an automata-theoretic\napproach to regular k-safety hyperproperties and allows us to compare regular\nk-safety hyperproperties, simplify them, and learn such hyperproperties. We\ninvestigate the problem of constructing automata for regular k-safety\nhyperproperties in general and from formulas in HyperLTL, and provide\ncomplexity bounds for the different translations. We also present a learning\nalgorithm for regular k-safety hyperproperties based on the L* learning\nalgorithm for deterministic finite automata.\n", "versions": [{"version": "v1", "created": "Tue, 29 Dec 2020 03:41:19 GMT"}], "update_date": "2021-01-01", "authors_parsed": [["Finkbeiner", "Bernd", ""], ["Haas", "Lennart", ""], ["Torfah", "Hazem", ""]]}, {"id": "2012.14590", "submitter": "Hazem Torfah", "authors": "Rayna Dimitrova, Bernd Finkbeiner, Hazem Torfah", "title": "Approximate Automata for Omega-Regular Languages", "comments": "Published at ATVA 2020", "journal-ref": null, "doi": "10.1007/978-3-030-31784-3_19", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automata over infinite words, also known as omega-automata, play a key role\nin the verification and synthesis of reactive systems. The spectrum of\nomega-automata is defined by two characteristics: the acceptance condition\n(e.g. B\\\"uchi or parity) and the determinism (e.g., deterministic or\nnondeterministic) of an automaton. These characteristics play a crucial role in\napplications of automata theory. For example, certain acceptance conditions can\nbe handled more efficiently than others by dedicated tools and algorithms.\nFurthermore, some applications, such as synthesis and probabilistic model\nchecking, require that properties are represented as some type of deterministic\nomega-automata. However, properties cannot always be represented by automata\nwith the desired acceptance condition and determinism. In this paper we study\nthe problem of approximating linear-time properties by automata in a given\nclass. Our approximation is based on preserving the language up to a\nuser-defined precision given in terms of the size of the finite lasso\nrepresentation of infinite executions that are preserved. We study the state\ncomplexity of different types of approximating automata, and provide\nconstructions for the approximation within different automata classes, for\nexample, for approximating a given automaton by one with a simpler acceptance\ncondition.\n", "versions": [{"version": "v1", "created": "Tue, 29 Dec 2020 03:51:27 GMT"}], "update_date": "2021-01-01", "authors_parsed": [["Dimitrova", "Rayna", ""], ["Finkbeiner", "Bernd", ""], ["Torfah", "Hazem", ""]]}, {"id": "2012.14701", "submitter": "Markus Alan Whiteland", "authors": "Juhani Karhum\\\"aki, Svetlana Puzynina and Markus A. Whiteland", "title": "On Abelian Closures of Infinite Non-binary Words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Two finite words $u$ and $v$ are called abelian equivalent if each letter\noccurs equally many times in both $u$ and $v$. The abelian closure\n$\\mathcal{A}(\\mathbf{x})$ of an infinite word $\\mathbf{x}$ is the set of\ninfinite words $\\mathbf{y}$ such that, for each factor $u$ of $\\mathbf{y}$,\nthere exists a factor $v$ of $\\mathbf{x}$ which is abelian equivalent to $u$.\nThe notion of an abelian closure gives a characterization of Sturmian words:\namong uniformly recurrent binary words, periodic and aperiodic Sturmian words\nare exactly those words for which $\\mathcal{A}(\\mathbf{x})$ equals the shift\norbit closure $\\Omega(\\mathbf{x})$. Furthermore, for an aperiodic binary word\nthat is not Sturmian, its abelian closure contains infinitely many minimial\nsubshifts. In this paper we consider the abelian closures of well-known\nfamilies of non-binary words, such as balanced words and minimal complexity\nwords. We also consider abelian closures of general subshifts and make some\ninitial observations of their abelian closures and pose some related open\nquestions.\n", "versions": [{"version": "v1", "created": "Tue, 29 Dec 2020 10:46:33 GMT"}], "update_date": "2021-01-01", "authors_parsed": [["Karhum\u00e4ki", "Juhani", ""], ["Puzynina", "Svetlana", ""], ["Whiteland", "Markus A.", ""]]}, {"id": "2012.15291", "submitter": "Lorenzo Clemente", "authors": "Lorenzo Clemente and S{\\l}awomir Lasota", "title": "Reachability relations of timed pushdown automata", "comments": "Author's version of JCSS article", "journal-ref": "Journal of Computer and System Sciences, Volume 117, May 2021,\n  Pages 202-241", "doi": "10.1016/j.jcss.2020.11.003", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Timed pushdown automata (TPDA) are an expressive formalism combining\nrecursion with a rich logic of timing constraints. We prove that reachability\nrelations of TPDA are expressible in linear arithmetic, a rich logic\ngeneralising Presburger arithmetic and rational arithmetic. The main technical\ningredients are a novel quantifier elimination result for clock constraints\n(used to simplify the syntax of TPDA transitions), the use of clock difference\nrelations to express reachability relations of the fractional clock values, and\nan application of Parikh's theorem to reconstruct the integral clock values.\n", "versions": [{"version": "v1", "created": "Wed, 30 Dec 2020 19:09:54 GMT"}], "update_date": "2021-01-01", "authors_parsed": [["Clemente", "Lorenzo", ""], ["Lasota", "S\u0142awomir", ""]]}, {"id": "2012.15617", "submitter": "Hannes Seiwert", "authors": "Ehud Cseresnyes and Hannes Seiwert", "title": "Regular expression length via arithmetic formula complexity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove lower bounds on the length of regular expressions for finite\nlanguages by methods from arithmetic circuit complexity. First, we show a\nreduction: the length of a regular expression for a language $L\\subseteq\n\\{0,1\\}^n$ is bounded from below by the minimum size of a monotone arithmetic\nformula computing a polynomial that has $L$ as its set of exponent vectors,\nviewing words as vectors. This result yields lower bounds for the binomial\nlanguage of all words with exactly $k$ ones and $n-k$ zeros and for the\nlanguage of all Dyck words of length $2n$. We also determine the blow-up of\nlanguage operations (intersection and shuffle) of regular expressions for\nfinite languages. Second, we adapt a lower bound method for multilinear\narithmetic formulas by so-called log-product polynomials to regular\nexpressions. With this method we show almost tight lower bounds for the\nlanguage of all binary numbers with $n$ bits that are divisible by a given odd\ninteger $p$, for the language of all words of length $n$ over a $k$ letter\nalphabet with an even number of occurrences of each letter and for the language\nof all permutations of $\\{1,\\dots, n\\}$.\n", "versions": [{"version": "v1", "created": "Thu, 31 Dec 2020 14:15:29 GMT"}], "update_date": "2021-01-01", "authors_parsed": [["Cseresnyes", "Ehud", ""], ["Seiwert", "Hannes", ""]]}]