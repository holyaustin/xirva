[{"id": "2011.00453", "submitter": "Jeffrey Shallit", "authors": "Jeffrey Shallit", "title": "Abelian Complexity and Synchronization", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a general method for computing the abelian complexity $\\rho^{\\rm\nab}_{\\bf s} (n)$ of an automatic sequence $\\bf s$ in the case where (a)\n$\\rho^{\\rm ab}_{\\bf s} (n)$ is bounded by a constant and (b) the Parikh vectors\nof the length-$n$ prefixes of $\\bf s$ form a synchronized sequence.\n  We illustrate the idea in detail, using the free software Walnut to compute\nthe abelian complexity of the Tribonacci word ${\\bf TR} = 0102010\\cdots$, the\nfixed point of the morphism $0 \\rightarrow 01$, $1 \\rightarrow 02$, $2\n\\rightarrow 0$. Previously, Richomme, Saari, and Zamboni showed that the\nabelian complexity of this word lies in $\\{ 3,4,5,6,7 \\}$, and Turek gave a\nTribonacci automaton computing it. We are able to \"automatically\" rederive\nthese results, and more, using the method presented here.\n", "versions": [{"version": "v1", "created": "Sun, 1 Nov 2020 09:02:13 GMT"}, {"version": "v2", "created": "Thu, 5 Nov 2020 09:10:42 GMT"}, {"version": "v3", "created": "Mon, 16 Nov 2020 12:50:03 GMT"}], "update_date": "2020-11-17", "authors_parsed": [["Shallit", "Jeffrey", ""]]}, {"id": "2011.00584", "submitter": "Carlos G\\'omez-Rodr\\'iguez", "authors": "Carlos G\\'omez-Rodr\\'iguez, Michalina Strzyz, David Vilares", "title": "A Unifying Theory of Transition-based and Sequence Labeling Parsing", "comments": "Camera-ready version (final peer-reviewed manuscript) to appear at\n  proceedings of COLING 2020. 18 pages (incl. appendices)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CL cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We define a mapping from transition-based parsing algorithms that read\nsentences from left to right to sequence labeling encodings of syntactic trees.\nThis not only establishes a theoretical relation between transition-based\nparsing and sequence-labeling parsing, but also provides a method to obtain new\nencodings for fast and simple sequence labeling parsing from the many existing\ntransition-based parsers for different formalisms. Applying it to dependency\nparsing, we implement sequence labeling versions of four algorithms, showing\nthat they are learnable and obtain comparable performance to existing\nencodings.\n", "versions": [{"version": "v1", "created": "Sun, 1 Nov 2020 18:25:15 GMT"}], "update_date": "2020-11-03", "authors_parsed": [["G\u00f3mez-Rodr\u00edguez", "Carlos", ""], ["Strzyz", "Michalina", ""], ["Vilares", "David", ""]]}, {"id": "2011.00632", "submitter": "Krishna Chaitanya Kalagarla", "authors": "Krishna C. Kalagarla, Rahul Jain, Pierluigi Nuzzo", "title": "Synthesis of Discounted-Reward Optimal Policies for Markov Decision\n  Processes Under Linear Temporal Logic Specifications", "comments": "Accepted for ACC 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a method to find an optimal policy with respect to a reward\nfunction for a discounted Markov decision process under general linear temporal\nlogic (LTL) specifications. Previous work has either focused on maximizing a\ncumulative reward objective under finite-duration tasks, specified by\nsyntactically co-safe LTL, or maximizing an average reward for persistent\n(e.g., surveillance) tasks. This paper extends and generalizes these results by\nintroducing a pair of occupancy measures to express the LTL satisfaction\nobjective and the expected discounted reward objective, respectively. These\noccupancy measures are then connected to a single policy via a novel reduction\nresulting in a mixed integer linear program whose solution provides an optimal\npolicy. Our formulation can also be extended to include additional constraints\nwith respect to secondary reward functions. We illustrate the effectiveness of\nour approach in the context of robotic motion planning for complex missions\nunder uncertainty and performance objectives.\n", "versions": [{"version": "v1", "created": "Sun, 1 Nov 2020 21:42:57 GMT"}, {"version": "v2", "created": "Mon, 22 Mar 2021 20:09:33 GMT"}], "update_date": "2021-03-24", "authors_parsed": [["Kalagarla", "Krishna C.", ""], ["Jain", "Rahul", ""], ["Nuzzo", "Pierluigi", ""]]}, {"id": "2011.00892", "submitter": "Yuting Fu", "authors": "Yuting Fu, Andrei Terechko, Jan Friso Groote, Arash Khabbaz Saberi", "title": "A Formally Verified Fail-Operational Safety Concept for Automated\n  Driving", "comments": "11 pages, 5 figures, 3 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.RO cs.DC cs.FL cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modern Automated Driving (AD) systems rely on safety measures to handle\nfaults and to bring vehicle to a safe state. To eradicate lethal road\naccidents, car manufacturers are constantly introducing new perception as well\nas control systems. Contemporary automotive design and safety engineering best\npractices are suitable for analyzing system components in isolation, whereas\ntoday's highly complex and interdependent AD systems require novel approach to\nensure resilience to multi-point failures. We present a holistic safety concept\nunifying advanced safety measures for handling multiple-point faults. Our\nproposed approach enables designers to focus on more pressing issues such as\nhandling fault-free hazardous behavior associated with system performance\nlimitations. To verify our approach, we developed an executable model of the\nsafety concept in the formal specification language mCRL2. The model behavior\nis governed by a four-mode degradation policy controlling distributed\nprocessors, redundant communication networks, and virtual machines. To keep the\nvehicle as safe as possible our degradation policy can reduce driving comfort\nor AD system's availability using additional low-cost driving channels. We\nformalized five safety requirements in the modal mu-calculus and proved them\nagainst our mCRL2 model, which is intractable to accomplish exhaustively using\ntraditional road tests or simulation techniques. In conclusion, our formally\nproven safety concept defines a holistic design pattern for designing AD\nsystems.\n", "versions": [{"version": "v1", "created": "Mon, 2 Nov 2020 11:05:09 GMT"}, {"version": "v2", "created": "Wed, 11 Nov 2020 16:21:26 GMT"}], "update_date": "2020-11-12", "authors_parsed": [["Fu", "Yuting", ""], ["Terechko", "Andrei", ""], ["Groote", "Jan Friso", ""], ["Saberi", "Arash Khabbaz", ""]]}, {"id": "2011.03249", "submitter": "Sander Thuijsman", "authors": "Sander Thuijsman, Michel Reniers", "title": "Conversion of LSAT behavioral specifications to automata", "comments": "10 pages, 6 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The Logistics Specification and Analysis Tool (LSAT) is a model-based\nengineering tool used for manufacturing system design and analysis. Using a\ndomain specific language, a system can be specified in LSAT. In this paper, a\nconversion method is presented to obtain the system behavior of an LSAT\nspecification in automata structure.\n", "versions": [{"version": "v1", "created": "Fri, 6 Nov 2020 09:23:18 GMT"}], "update_date": "2020-11-09", "authors_parsed": [["Thuijsman", "Sander", ""], ["Reniers", "Michel", ""]]}, {"id": "2011.03925", "submitter": "Irene Guessarian", "authors": "Andre Arnold, Patrick Cegielski, Serge Grigorieff and Irene Guessarian", "title": "The algebra of binary trees is affine complete", "comments": "9 pages, 1 figure", "journal-ref": "DMTCS vol 23:2, 2021,#1", "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A function on an algebra is congruence preserving if, for any congruence, it\nmaps pairs of congruent elements onto pairs of congruent elements. We show that\non the algebra of binary trees whose leaves are labeled by letters of an\nalphabet containing at least three letters, a function is congruence preserving\nif and only if it is polynomial.\n", "versions": [{"version": "v1", "created": "Sun, 8 Nov 2020 08:48:51 GMT"}, {"version": "v2", "created": "Fri, 5 Mar 2021 18:37:49 GMT"}, {"version": "v3", "created": "Fri, 14 May 2021 21:03:26 GMT"}], "update_date": "2021-05-18", "authors_parsed": [["Arnold", "Andre", ""], ["Cegielski", "Patrick", ""], ["Grigorieff", "Serge", ""], ["Guessarian", "Irene", ""]]}, {"id": "2011.04236", "submitter": "Avraham Trahtman N", "authors": "A.N. Trahtman", "title": "Polynomial time algorithm for left [right] local testability", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A right [left] locally testable language S is a language with the property\nthat for some non negative integer k two words u and v in alphabet S are equal\nin the semi group if (1) the prefix and suffix of the words of length k\ncoincide, (2) the set of segments of length k of the words as well as 3) the\norder of the first appearance of these segments in prefixes [suffixes]\ncoincide. We present necessary and sufficient condition for graph [semi group]\nto be transition graph [semi group] of the deterministic finite automaton that\naccepts right [left] locally testable language and necessary and sufficient\ncondition for transition graph of the deterministic finite automaton with\nlocally idempotent semi group. We introduced polynomial time algorithms for the\nright [left] local testable problem for transition semi group and transition\ngraph of the deterministic finite automaton based on these conditions.\nPolynomial time algorithm verifies transition graph of automaton with locally\nidempotent transition semi group.\n", "versions": [{"version": "v1", "created": "Mon, 9 Nov 2020 07:59:29 GMT"}], "update_date": "2020-11-10", "authors_parsed": [["Trahtman", "A. N.", ""]]}, {"id": "2011.04287", "submitter": "Giuseppe Di Molfetta Prof.", "authors": "O. Duranthon and Giuseppe Di Molfetta", "title": "Coarse-grained quantum cellular automata", "comments": null, "journal-ref": "Phys. Rev. A 103, 032224 (2021)", "doi": "10.1103/PhysRevA.103.032224", "report-no": null, "categories": "quant-ph cond-mat.mes-hall cs.FL hep-lat", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One can think of some physical evolutions as being the emergent-effective\nresult of a microscopic discrete model. Inspired by classical coarse-graining\nprocedures, we provide a simple procedure to coarse-grain color-blind quantum\ncellular automata that follow Goldilocks rules. The procedure consists in (i)\nspace-time grouping the quantum cellular automaton (QCA) in cells of size $N$;\n(ii) projecting the states of a cell onto its borders, connecting them with the\nfine dynamics; (iii) describing the overall dynamics by the border states, that\nwe call signals; and (iv) constructing the coarse-grained dynamics for\ndifferent sizes $N$ of the cells. A byproduct of this simple toy-model is a\ngeneral discrete analog of the Stokes law. Moreover we prove that in the\nspacetime limit, the automaton converges to a Dirac free Hamiltonian. The QCA\nwe introduce here can be implemented by present-day quantum platforms, such as\nRydberg arrays, trapped ions, and superconducting qbits. We hope our study can\npave the way to a richer understanding of those systems with limited\nresolution.\n", "versions": [{"version": "v1", "created": "Mon, 9 Nov 2020 09:56:16 GMT"}, {"version": "v2", "created": "Mon, 8 Mar 2021 14:30:12 GMT"}, {"version": "v3", "created": "Wed, 10 Mar 2021 20:31:23 GMT"}, {"version": "v4", "created": "Thu, 1 Apr 2021 08:16:53 GMT"}], "update_date": "2021-04-07", "authors_parsed": [["Duranthon", "O.", ""], ["Di Molfetta", "Giuseppe", ""]]}, {"id": "2011.04360", "submitter": "S\\'ergio Medeiros", "authors": "S\\'ergio Medeiros and Carlos Olarte", "title": "A Semantic Framework for PEGs", "comments": null, "journal-ref": null, "doi": "10.1145/3426425.3426944", "report-no": null, "categories": "cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parsing Expression Grammars (PEGs) are a recognition-based formalism which\nallows to describe the syntactical and the lexical elements of a language. The\nmain difference between Context-Free Grammars (CFGs) and PEGs relies on the\ninterpretation of the choice operator: while the CFGs' unordered choice e | e'\nis interpreted as the union of the languages recognized by e and e, the PEGs'\nprioritized choice e/e' discards e' if e succeeds. Such subtle, but important\ndifference, changes the language recognized and yields more efficient parsing\nalgorithms. This paper proposes a rewriting logic semantics for PEGs. We start\nwith a rewrite theory giving meaning to the usual constructs in PEGs. Later, we\nshow that cuts, a mechanism for controlling backtracks in PEGs, finds also a\nnatural representation in our framework. We generalize such mechanism, allowing\nfor both local and global cuts with a precise, unified and formal semantics.\nHence, our work strives at better understanding and controlling backtracks in\nparsers for PEGs. The semantics we propose is executable and, besides being a\nparser with modest efficiency, it can be used as a playground to test different\noptimization ideas. More importantly, it is a mathematical tool that can be\nused for different analyses.\n", "versions": [{"version": "v1", "created": "Mon, 9 Nov 2020 11:49:37 GMT"}], "update_date": "2020-11-10", "authors_parsed": [["Medeiros", "S\u00e9rgio", ""], ["Olarte", "Carlos", ""]]}, {"id": "2011.04581", "submitter": "Ramanathan Srinivasan Thinniyam", "authors": "Pascal Baumann, Rupak Majumdar, Ramanathan S. Thinniyam, Georg\n  Zetzsche", "title": "Context-Bounded Verification of Liveness Properties for Multithreaded\n  Shared-Memory Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study context-bounded verification of liveness properties of\nmulti-threaded, shared-memory programs, where each thread can spawn additional\nthreads. Our main result shows that context-bounded fair termination is\ndecidable for the model; context-bounded implies that each spawned thread can\nbe context switched a fixed constant number of times. Our proof is technical,\nsince fair termination requires reasoning about the composition of unboundedly\nmany threads each with unboundedly large stacks. In fact, techniques for\nrelated problems, which depend crucially on replacing the pushdown threads with\nfinite-state threads, are not applicable. Instead, we introduce an extension of\nvector addition systems with states (VASS), called VASS with balloons (VASSB),\nas an intermediate model; it is an infinite-state model of independent\ninterest. A VASSB allows tokens that are themselves markings (balloons). We\nshow that context bounded fair termination reduces to fair termination for\nVASSB. We show the latter problem is decidable by showing a series of\nreductions: from fair termination to configuration reachability for VASSB and\nthence to the reachability problem for VASS. For a lower bound, fair\ntermination is known to be non-elementary already in the special case where\nthreads run to completion (no context switches).\n  We also show that the simpler problem of context-bounded termination is\n2EXPSPACE-complete, matching the complexity bound---and indeed the\ntechniques---for safety verification. Additionally, we show the related problem\nof fair starvation, which checks if some thread can be starved along a fair\nrun, is also decidable in the context-bounded case. The decidability employs an\nintricate reduction from fair starvation to fair termination. Like fair\ntermination, this problem is also non-elementary.\n", "versions": [{"version": "v1", "created": "Mon, 9 Nov 2020 17:26:34 GMT"}, {"version": "v2", "created": "Thu, 12 Nov 2020 12:36:28 GMT"}], "update_date": "2020-11-13", "authors_parsed": [["Baumann", "Pascal", ""], ["Majumdar", "Rupak", ""], ["Thinniyam", "Ramanathan S.", ""], ["Zetzsche", "Georg", ""]]}, {"id": "2011.05027", "submitter": "Eleni Mandrali", "authors": "Eleni Mandrali", "title": "A translation of weighted LTL formulas to weighted B\\\"uchi automata over\n  {\\omega}-valuation monoids", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we introduce a weighted LTL over product $\\omega$-valuation\nmonoids that satisfy specific properties. We also introduce weighted\ngeneralized B\\\"uchi automata with $\\varepsilon$-transitions, as well as\nweighted B\\\"uchi automata with $\\varepsilon$-transitions over product\n$\\omega$-valuation monoids and prove that these two models are expressively\nequivalent and also equivalent to weighted B\\\"uchi automata already introduced\nin the literature. We prove that every formula of a syntactic fragment of our\nlogic can be effectively translated to a weighted generalized B\\\"uchi automaton\nwith $\\varepsilon$-transitions. We prove that the number of states of the\nproduced automaton is polynomial in the size of the corresponding formula. For\nrestricted product $\\omega$-valuation monoids we define a weighted LTL,\nweighted generalized B\\\"uchi automata with $\\varepsilon$-transitions, and\nweighted B\\\"uchi automata with $\\varepsilon$-transitions, and we prove the\naforementioned results for restricted product $\\omega$-valuation monoids as\nwell. The translation of weighted LTL formulas to weighted generalized B\\\"uchi\nautomata with $\\varepsilon$-transitions is now obtained for a restricted\nsyntactical fragment of the logic.\n", "versions": [{"version": "v1", "created": "Tue, 10 Nov 2020 10:38:03 GMT"}, {"version": "v2", "created": "Sat, 23 Jan 2021 19:34:38 GMT"}, {"version": "v3", "created": "Thu, 25 Mar 2021 22:37:36 GMT"}], "update_date": "2021-03-29", "authors_parsed": [["Mandrali", "Eleni", ""]]}, {"id": "2011.05389", "submitter": "Dana Fisman", "authors": "Dana Fisman and Hadar Frenkel and Sandra Zilles", "title": "On the Complexity of Symbolic Finite-State Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We revisit the complexity of procedures on SFAs (such as intersection,\nemptiness, etc.) and analyze them according to the measures we find suitable\nfor symbolic automata: the number of states, the maximal number of transitions\nexiting a state, and the size of the most complex transition predicate. We pay\nattention to the special forms of SFAs: {normalized SFAs} and {neat SFAs}, as\nwell as to SFAs over a {monotonic} effective Boolean algebra.\n", "versions": [{"version": "v1", "created": "Tue, 10 Nov 2020 20:55:55 GMT"}, {"version": "v2", "created": "Thu, 12 Nov 2020 21:13:57 GMT"}, {"version": "v3", "created": "Fri, 2 Jul 2021 12:57:45 GMT"}], "update_date": "2021-07-05", "authors_parsed": [["Fisman", "Dana", ""], ["Frenkel", "Hadar", ""], ["Zilles", "Sandra", ""]]}, {"id": "2011.05575", "submitter": "Avraham Trahtman N", "authors": "Avraham N. Trahtman", "title": "Some new Features and Algorithms for the Study of DFA", "comments": "9 pages, 2 figures, 2 tables. arXiv admin note: substantial text\n  overlap with arXiv:0907.2755", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The work presents some new algorithms realized recently in the package\nTESTAS. They decide whether or not deterministic finite automaton (DFA) is\nsynchronizing, several procedures find relatively short synchronizing words and\na synchronizing word of the minimal length. We check the existence of a\ncoloring of directed graph that turns the graph into a synchronizing DFA. The\nalgorithm finds the coloring (better known as the road coloring) if it exists.\nOtherwise, the k-synchronizing road coloring can be found. We use a linear\nvisualization of the graph of an automaton based on its structural properties.\n", "versions": [{"version": "v1", "created": "Tue, 10 Nov 2020 08:26:31 GMT"}], "update_date": "2020-11-12", "authors_parsed": [["Trahtman", "Avraham N.", ""]]}, {"id": "2011.05710", "submitter": "Aleksander Mendoza-Drosik", "authors": "Aleksander Mendoza-Drosik", "title": "Nondeterministic functional transducer inference algorithm", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The purpose of this paper is to present an algorithm for inferring\nnondeterministic functional transducers. It has a lot in common with other well\nknown algorithms such has RPNI and OSTIA. Indeed we will argue that this\nalgorithm is a generalisation of both of them. Functional transducers are all\nthose nondeterministic transducers whose regular relation is a function.\nEpsilon transitions as well as subsequential output can be erased for such\nmachines, with the exception of output for empty string being lost. Learning\npartial functional transducers from negative examples is equivalent to learning\ntotal from positive-only data.\n", "versions": [{"version": "v1", "created": "Wed, 11 Nov 2020 11:28:07 GMT"}, {"version": "v2", "created": "Thu, 10 Dec 2020 15:31:25 GMT"}], "update_date": "2020-12-11", "authors_parsed": [["Mendoza-Drosik", "Aleksander", ""]]}, {"id": "2011.05825", "submitter": "Pascal Baumann", "authors": "Pascal Baumann and Rupak Majumdar and Ramanathan S. Thinniyam and\n  Georg Zetzsche", "title": "The complexity of bounded context switching with dynamic thread creation", "comments": null, "journal-ref": "ICALP 2020, vol. 168, pages 111:1-111:16", "doi": "10.4230/LIPIcs.ICALP.2020.111", "report-no": null, "categories": "cs.FL cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Dynamic networks of concurrent pushdown systems (DCPS) are a theoretical\nmodel for multi-threaded recursive programs with shared global state and\ndynamical creation of threads. The (global) state reachability problem for DCPS\nis undecidable in general, but Atig et al. (2009) showed that it becomes\ndecidable, and is in 2EXPSPACE, when each thread is restricted to a fixed\nnumber of context switches. The best known lower bound for the problem is\nEXPSPACE-hard and this lower bound follows already when each thread is a\nfinite-state machine and runs atomically to completion (i.e., does not switch\ncontexts). In this paper, we close the gap by showing that state reachability\nis 2EXPSPACE-hard already with only one context switch. Interestingly, state\nreachability analysis is in EXPSPACE both for pushdown threads without context\nswitches as well as for finite-state threads with arbitrary context switches.\nThus, recursive threads together with a single context switch provide an\nexponential advantage.\n  Our proof techniques are of independent interest for 2EXPSPACE-hardness\nresults. We introduce transducer-defined Petri nets, a succinct representation\nfor Petri nets, and show coverability is 2EXPSPACE-hard for this model. To show\n2EXPSPACE-hardness, we present a modified version of Lipton's simulation of\ncounter machines by Petri nets, where the net programs can make explicit\nrecursive procedure calls up to a bounded depth.\n", "versions": [{"version": "v1", "created": "Wed, 11 Nov 2020 14:42:08 GMT"}], "update_date": "2020-11-19", "authors_parsed": [["Baumann", "Pascal", ""], ["Majumdar", "Rupak", ""], ["Thinniyam", "Ramanathan S.", ""], ["Zetzsche", "Georg", ""]]}, {"id": "2011.06253", "submitter": "Avraham. Trahtman N", "authors": "A.N.Trahtman", "title": "Precise estimation on the order of local testability of deterministic\n  finite automaton", "comments": "15 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A locally testable language L is a language with the property that for some\nnon negative integer k, called the order or the level of local testable,\nwhether or not a word u in the language L depends on (1) the prefix and the\nsuffix of the word u of length k-1 and (2) the set of intermediate partial\nstrings of length k of the word u. For given k the language is called\nk-testable. We give necessary and sufficient conditions for the language of an\nautomaton to be k-testable in the terms of the length of paths of a related\ngraph. Some estimations of the upper and of the lower bound of testable order\nfollow from these results. We improve the upper bound on the testable order of\nlocally testable deterministic finite automaton with n states to n(n-2)+1 This\nbound is the best possible. We give an answer on the following conjecture of\nKim, McNaughton and Mac-CLoskey for deterministic finite locally testable\nautomaton with n states: \\Is the local testable order of no greater than n in\npower 1.5 when the alphabet size is two?\" Our answer is negative. In the case\nof size two the situation is the same as in general case.\n", "versions": [{"version": "v1", "created": "Thu, 12 Nov 2020 08:18:02 GMT"}], "update_date": "2020-11-13", "authors_parsed": [["Trahtman", "A. N.", ""]]}, {"id": "2011.06262", "submitter": "Avraham. Trahtman N", "authors": "A.N. Trahtman", "title": "Reducing the time complexity of testing for local threshold testability", "comments": "11 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A locally threshold testable language L is a language with the property that\nfor some non negative integers k and l and for some word u from L, a word v\nbelongs to L if and only if\n  (1) the prefixes [suffixes] of length k-1 of words u and v coincide,\n  (2) the numbers of occurrences of every factor of length k in both words u\nand v are either the same or greater than l-1.\n  A deterministic finite automaton is called locally threshold testable if the\nautomaton accepts a locally threshold testable language for some l and k.\n  New necessary and sufficient conditions for a deterministic finite automaton\nto be locally threshold testable are found. On the basis of these conditions,\nwe modify the algorithm to verify local threshold testability of the automaton\nand to reduce the time complexity of the algorithm. The algorithm is\nimplemented as a part of the $C/C ^{++}$ package TESTAS.\n\\texttt{http://www.cs.biu.ac.il/$\\sim$trakht/Testas.html}.\n", "versions": [{"version": "v1", "created": "Thu, 12 Nov 2020 08:49:38 GMT"}], "update_date": "2020-11-13", "authors_parsed": [["Trahtman", "A. N.", ""]]}, {"id": "2011.06951", "submitter": "Henning Urbat", "authors": "Fabian Birkmann and Stefan Milius and Henning Urbat", "title": "On Language Varieties Without Boolean Operations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Eilenberg's variety theorem marked a milestone in the algebraic theory of\nregular languages by establishing a formal correspondence between properties of\nregular languages and properties of finite monoids recognizing them. Motivated\nby classes of languages accepted by quantum finite automata, we introduce basic\nvarieties of regular languages, a weakening of Eilenberg's original concept\nthat does not require closure under any boolean operations, and prove a variety\ntheorem for them. To do so, we investigate the algebraic recognition of\nlanguages by lattice bimodules, generalizing Klima and Polak's lattice\nalgebras, and we utilize the duality between algebraic completely distributive\nlattices and posets.\n", "versions": [{"version": "v1", "created": "Fri, 13 Nov 2020 14:54:28 GMT"}], "update_date": "2020-11-16", "authors_parsed": [["Birkmann", "Fabian", ""], ["Milius", "Stefan", ""], ["Urbat", "Henning", ""]]}, {"id": "2011.06954", "submitter": "Ernst-Erich Doberkat", "authors": "Ernst-Erich Doberkat", "title": "Congruences for Stochastic Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Congruences for stochastic automata are defined, the correspondin factor\nautomata are constructed and investigated for automata ove analytic spaces. We\nstudy the behavior under finite and infinite streams. Congruences consist of\nmultiple parts, it is shown that factoring can be done in multiple steps,\nguided by these parts.\n", "versions": [{"version": "v1", "created": "Fri, 13 Nov 2020 14:59:27 GMT"}], "update_date": "2020-11-16", "authors_parsed": [["Doberkat", "Ernst-Erich", ""]]}, {"id": "2011.07091", "submitter": "Stefan G\\\"oller", "authors": "Stefan G\\\"oller and Mathieu Hilaire", "title": "Reachability in two-parametric timed automata with one parameter is\n  EXPSPACE-complete", "comments": "71 pages , 29 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parametric timed automata (PTA) are an extension of timed automata in which\nclocks can be compared against parameters. The reachability problem asks for\nthe existence of an assignment of the parameters to the non-negative integers\nsuch that reachability holds in the underlying timed automaton. The\nreachability problem for PTA is long known to be undecidable, already over\nthree parametric clocks.\n  A few years ago, Bundala and Ouaknine proved that for PTA over two parametric\nclocks and one parameter the reachability problem is decidable and also showed\na lower bound for the complexity class PSPACE^NEXP. Our main result is that the\nreachability problem for two-parametric timed automata with one parameter is\nEXPSPACE-complete. Our contribution is two-fold.\n  For the EXPSPACE lower bound we make use of deep results from complexity\ntheory, namely a serializability characterization of EXPSPACE (based on\nBarrington's Theorem) and a logspace translation of numbers in chinese\nremainder representation to binary representation.\n  For the EXPSPACE upper bound, we give a careful exponential time reduction\nfrom PTA over two parametric clocks and one parameter to a slight subclass of\nparametric one-counter automata (POCA) over one parameter based on a minor\nadjustment of a construction due to Bundala and Ouaknine. We provide a series\nof techniques to partition a fictitious run of a POCA into several carefully\nchosen subruns that allow us to prove that it is sufficient to consider a\nparameter value of exponential magnitude only. This allows us to show a\ndoubly-exponential upper bound on the value of the only parameter of a PTA over\ntwo parametric clocks and one parameter. We hope that extensions of our\ntechniques lead to finally establishing decidability of the long-standing open\nproblem of reachability in parametric timed automata with two parametric clocks\n(and arbitrarily many parameters).\n", "versions": [{"version": "v1", "created": "Fri, 13 Nov 2020 19:10:20 GMT"}], "update_date": "2020-11-17", "authors_parsed": [["G\u00f6ller", "Stefan", ""], ["Hilaire", "Mathieu", ""]]}, {"id": "2011.07149", "submitter": "Andrea Bisoffi", "authors": "Andrea Bisoffi, Dimos V. Dimarogonas", "title": "Satisfaction of linear temporal logic specifications through recurrence\n  tools for hybrid systems", "comments": "To appear in IEEE Transactions on Automatic Control", "journal-ref": null, "doi": "10.1109/TAC.2020.2984724", "report-no": null, "categories": "eess.SY cs.FL cs.SY math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work we formulate the problem of satisfying a linear temporal logic\nformula on a linear plant with output feedback, through a recent hybrid systems\nformalism. We relate this problem to the notion of recurrence introduced for\nthe considered formalism, and we then extend Lyapunov-like conditions for\nrecurrence of an open, unbounded set. One of the proposed relaxed conditions\nallows certifying recurrence of a suitable set, and this guarantees that the\nhigh-level evolution of the plant satisfies the formula, without relying on\ndiscretizations of the plant. Simulations illustrate the proposed approach.\n", "versions": [{"version": "v1", "created": "Fri, 13 Nov 2020 22:13:02 GMT"}], "update_date": "2020-11-17", "authors_parsed": [["Bisoffi", "Andrea", ""], ["Dimarogonas", "Dimos V.", ""]]}, {"id": "2011.07472", "submitter": "Dolav Nitay", "authors": "Dolav Nitay, Dana Fisman, Michal Ziv-Ukelson", "title": "Learning of Structurally Unambiguous Probabilistic Grammars", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The problem of identifying a probabilistic context free grammar has two\naspects: the first is determining the grammar's topology (the rules of the\ngrammar) and the second is estimating probabilistic weights for each rule.\nGiven the hardness results for learning context-free grammars in general, and\nprobabilistic grammars in particular, most of the literature has concentrated\non the second problem. In this work we address the first problem. We restrict\nattention to structurally unambiguous weighted context-free grammars (SUWCFG)\nand provide a query learning algorithm for structurally unambiguous\nprobabilistic context-free grammars (SUPCFG). We show that SUWCFG can be\nrepresented using co-linear multiplicity tree automata (CMTA), and provide a\npolynomial learning algorithm that learns CMTAs. We show that the learned CMTA\ncan be converted into a probabilistic grammar, thus providing a complete\nalgorithm for learning a structurally unambiguous probabilistic context free\ngrammar (both the grammar topology and the probabilistic weights) using\nstructured membership queries and structured equivalence queries. We\ndemonstrate the usefulness of our algorithm in learning PCFGs over genomic\ndata.\n", "versions": [{"version": "v1", "created": "Sun, 15 Nov 2020 08:07:04 GMT"}, {"version": "v2", "created": "Tue, 9 Mar 2021 18:32:52 GMT"}], "update_date": "2021-03-10", "authors_parsed": [["Nitay", "Dolav", ""], ["Fisman", "Dana", ""], ["Ziv-Ukelson", "Michal", ""]]}, {"id": "2011.07630", "submitter": "Masoud Ebrahimi", "authors": "Roderick Bloem and Hana Chockler and Masoud Ebrahimi and Dana Fisman\n  and Heinz Riener", "title": "Safety Synthesis Sans Specification", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We define the problem of learning a transducer ${S}$ from a target language\n$U$ containing possibly conflicting transducers, using membership queries and\nconjecture queries. The requirement is that the language of ${S}$ be a subset\nof $U$. We argue that this is a natural question in many situations in hardware\nand software verification. We devise a learning algorithm for this problem and\nshow that its time and query complexity is polynomial with respect to the rank\nof the target language, its incompatibility measure, and the maximal length of\na given counterexample. We report on experiments conducted with a prototype\nimplementation.\n", "versions": [{"version": "v1", "created": "Sun, 15 Nov 2020 21:13:17 GMT"}, {"version": "v2", "created": "Fri, 27 Nov 2020 13:25:02 GMT"}], "update_date": "2020-11-30", "authors_parsed": [["Bloem", "Roderick", ""], ["Chockler", "Hana", ""], ["Ebrahimi", "Masoud", ""], ["Fisman", "Dana", ""], ["Riener", "Heinz", ""]]}, {"id": "2011.08108", "submitter": "S\\'ergio Maciel", "authors": "Sergio Henrique Maciel", "title": "Mathematical Approach in Automata and Automata Association", "comments": "There is an issue in Section 1", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The transition structure of an automaton can be used to create a natural\ntopology to the set of states of an automaton, generating, this way, a\ntopological space. Probabilistic automata can also be modeled in terms of\nmeasure theory. A system of many automata would be reduced to simple\nmathematical structures and analyzed by a topological point of view.\n", "versions": [{"version": "v1", "created": "Mon, 16 Nov 2020 17:21:21 GMT"}, {"version": "v2", "created": "Thu, 15 Apr 2021 20:52:20 GMT"}], "update_date": "2021-04-19", "authors_parsed": [["Maciel", "Sergio Henrique", ""]]}, {"id": "2011.08552", "submitter": "Thomas Seiller", "authors": "Thomas Seiller and Jakob Grue Simonsen", "title": "Agafonov's Theorem for finite and infinite alphabets and probability\n  distributions different from equidistribution", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.DS math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An infinite sequence over a finite alphabet {\\Sigma} of symbols is called\nnormal iff the limiting frequency of every finite string w exists and equals\n|{\\Sigma}|^{|w|}. A celebrated theorem by Agafonov states that a sequence\n{\\alpha} is normal iff every finite-state selector. Normality is generalised to\narbitrary probability maps \\mu: {\\alpha} is is \\mu-distributed if, for every\nfinite string w, the limiting frequency of w in {\\alpha} exists and equals\n\\mu(w). Unlike normality, \\mu-distributedness is not preserved by finite-state\nselectors for all probability maps \\mu. This raises the question of how to\ncharacterize the probability maps \\mu for which \\mu-distributedness is\npreserved across finite-state selection, or equivalently, by selection by\nprograms using constant space.\n  We prove the following result: for any finite or countably infinite alphabet\n{\\Sigma}, every finite-state selector over {\\Sigma} selects a \\mu-distributed\nsequence from every \\mu-distributed sequence {\\alpha} iff \\mu is induced by a\nBernoulli distribution on {\\Sigma}, that is a probability distribution on the\nalphabet extended to words by taking the product. The primary -- and remarkable\n-- consequence of our main result is a complete characterization of the set of\nprobability maps, on finite and infinite alphabets, for which Agafonov-type\nresults hold. The main positive takeaway is that (the appropriate\ngeneralization of) Agafonov's Theorem holds for Bernoulli distributions (rather\nthan just equidistributions) on both finite and countably infinite alphabets.\nAs a further consequence, we obtain a result in the area of symbolic dynamical\nsystems: the shift-invariant measures {\\nu} on {\\Sigma}^{\\omega} such that any\nfinite-state selector preserves the property of genericity for {\\mu}, are\nexactly the positive Bernoulli measures.\n", "versions": [{"version": "v1", "created": "Tue, 17 Nov 2020 10:34:50 GMT"}], "update_date": "2020-11-18", "authors_parsed": [["Seiller", "Thomas", ""], ["Simonsen", "Jakob Grue", ""]]}, {"id": "2011.08805", "submitter": "Antonio Bruto da Costa", "authors": "Sayandeep Sanyal, Antonio Anastasio Bruto da Costa, Pallab Dasgupta", "title": "Recurrence in Dense-time AMS Assertions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The notion of recurrence over continuous or dense time, as required for\nexpressing Analog and Mixed-Signal (AMS) behaviours, is fundamentally different\nfrom what is offered by the recurrence operators of SystemVerilog Assertions\n(SVA). This article introduces the formal semantics of recurrence over dense\ntime and provides a methodology for the runtime verification of such properties\nusing interval arithmetic. Our property language extends SVA with dense\nreal-time intervals and predicates containing real-valued signals. We provide a\ntool kit which interfaces with off-the-shelf EDA tools through standard VPI.\n", "versions": [{"version": "v1", "created": "Tue, 17 Nov 2020 18:04:54 GMT"}], "update_date": "2020-11-18", "authors_parsed": [["Sanyal", "Sayandeep", ""], ["da Costa", "Antonio Anastasio Bruto", ""], ["Dasgupta", "Pallab", ""]]}, {"id": "2011.09675", "submitter": "Damien Regnault M.", "authors": "Pierre-\\'Etienne Meunier and Damien Regnault", "title": "On the directed tile assembly systems at temperature 1", "comments": "arXiv admin note: text overlap with arXiv:2002.04012", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show here that a model called directed self-assembly at temperature 1 is\nunable to do complex computations like the ones of a Turing machine. Since this\nmodel can be seen as a generalization of finite automata to 2D languages, a\nlogical approach is to proceed in two steps. The first one is to develop a 2D\npumping lemma and the second one is to use this pumping lemma to classify the\ndifferent types of possible computation.\n  Previously, Meunier at al have proven a pumping lemma and Doty et al,\nassuming the existence of a pumping lemma, have classified the different types\nof terminal assembly. Thus the combination of these two papers solves the\ndirected temperature 1 conjecture ... but in an imperfect way. Indeed, since\nthe work of Doty et al is anterior to the pumping lemma of Meunier et al, the\nauthors assumed a different and stronger pumping lemma. Nevertheless, all the\ndemonstrations made in Doty et al still hold with the pumping lemma of Meunier\net al.\n  In this paper, we harmonize the notations between these two articles in order\nto clearly solve the directed temperature 1 conjecture. We are also able to\ngive an optimal description of the bi-periodic structures which may appear in\nsome tile assembly system.\n", "versions": [{"version": "v1", "created": "Wed, 18 Nov 2020 15:55:00 GMT"}], "update_date": "2020-11-20", "authors_parsed": [["Meunier", "Pierre-\u00c9tienne", ""], ["Regnault", "Damien", ""]]}, {"id": "2011.09866", "submitter": "Vanja Dosko\\v{c}", "authors": "Julian Berger, Maximilian B\\\"other, Vanja Dosko\\v{c}, Jonathan Gadea\n  Harder, Nicolas Klodt, Timo K\\\"otzing, Winfried L\\\"otzsch, Jannik Peters,\n  Leon Schiller, Lars Seifert, Armin Wells, Simon Wietheger", "title": "Learning Languages with Decidable Hypotheses", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CL cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In language learning in the limit, the most common type of hypothesis is to\ngive an enumerator for a language. This so-called $W$-index allows for naming\narbitrary computably enumerable languages, with the drawback that even the\nmembership problem is undecidable. In this paper we use a different system\nwhich allows for naming arbitrary decidable languages, namely programs for\ncharacteristic functions (called $C$-indices). These indices have the drawback\nthat it is now not decidable whether a given hypothesis is even a legal\n$C$-index.\n  In this first analysis of learning with $C$-indices, we give a structured\naccount of the learning power of various restrictions employing $C$-indices,\nalso when compared with $W$-indices. We establish a hierarchy of learning power\ndepending on whether $C$-indices are required (a) on all outputs; (b) only on\noutputs relevant for the class to be learned and (c) only in the limit as\nfinal, correct hypotheses. Furthermore, all these settings are weaker than\nlearning with $W$-indices (even when restricted to classes of computable\nlanguages). We analyze all these questions also in relation to the mode of data\npresentation.\n  Finally, we also ask about the relation of semantic versus syntactic\nconvergence and derive the map of pairwise relations for these two kinds of\nconvergence coupled with various forms of data presentation.\n", "versions": [{"version": "v1", "created": "Thu, 15 Oct 2020 09:27:47 GMT"}], "update_date": "2020-11-20", "authors_parsed": [["Berger", "Julian", ""], ["B\u00f6ther", "Maximilian", ""], ["Dosko\u010d", "Vanja", ""], ["Harder", "Jonathan Gadea", ""], ["Klodt", "Nicolas", ""], ["K\u00f6tzing", "Timo", ""], ["L\u00f6tzsch", "Winfried", ""], ["Peters", "Jannik", ""], ["Schiller", "Leon", ""], ["Seifert", "Lars", ""], ["Wells", "Armin", ""], ["Wietheger", "Simon", ""]]}, {"id": "2011.10498", "submitter": "Artem Kaznatcheev", "authors": "Artem Kaznatcheev and Prakash Panangaden", "title": "Weighted automata are compact and actively learnable", "comments": "6 pages, 3 figures, to appear in Information Processing Letters", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that weighted automata over the field of two elements can be\nexponentially more compact than non-deterministic finite state automata. To\nshow this, we combine ideas from automata theory and communication complexity.\nHowever, weighted automata are also efficiently learnable in Angluin's minimal\nadequate teacher model in a number of queries that is polynomial in the size of\nthe minimal weighted automaton.. We include an algorithm for learning WAs over\nany field based on a linear algebraic generalization of the Angluin-Schapire\nalgorithm. Together, this produces a surprising result: weighted automata over\nfields are structured enough that even though they can be very compact, they\nare still efficiently learnable.\n", "versions": [{"version": "v1", "created": "Fri, 20 Nov 2020 16:53:18 GMT"}, {"version": "v2", "created": "Wed, 17 Mar 2021 05:33:37 GMT"}, {"version": "v3", "created": "Thu, 22 Apr 2021 18:27:53 GMT"}], "update_date": "2021-04-26", "authors_parsed": [["Kaznatcheev", "Artem", ""], ["Panangaden", "Prakash", ""]]}, {"id": "2011.10534", "submitter": "Olivier Carton", "authors": "Olivier Carton", "title": "Ambiguity through the lens of measure theory", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we consider automata accepting irreducible sofic shifts, that\nis, strongly connected automata where each state is initial and final. We\nprovide a characterization of unambiguity for finite words by means of measure\nof sets of infinite sequences labelling two runs. More precisely, we show that\nsuch an automaton is unambiguous, in the sense that no finite word labels two\nruns with the same starting state and the same ending state if and only if for\neach state, the set of infinite sequences labelling two runs starting from that\nstate has measure zero.\n", "versions": [{"version": "v1", "created": "Fri, 20 Nov 2020 18:06:10 GMT"}], "update_date": "2020-11-23", "authors_parsed": [["Carton", "Olivier", ""]]}, {"id": "2011.10713", "submitter": "Hussein Sibai", "authors": "Hussein Sibai and Yangge Li and Sayan Mitra", "title": "SceneChecker: Boosting Scenario Verification using Symmetry Abstractions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.LG cs.RO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We presentSceneChecker, a tool for verifying scenarios involving vehicles\nexecuting complex plans in large cluttered workspaces. SceneChecker converts\nthe scenario verification problem to a standard hybrid system verification\nproblem, and solves it effectively by exploiting structural properties in the\nplan and the vehicle dynamics. SceneChecker uses symmetry abstractions, a novel\nrefinement algorithm, and importantly, is built to boost the performance of any\nexisting reachability analysis tool as a plug-in subroutine. We evaluated\nSceneChecker on several scenarios involving ground and aerial vehicles with\nnonlinear dynamics and neural network controllers, employing different kinds of\nsymmetries, using different reachability subroutines, and following plans with\nhundreds of way-points in complex workspaces. Compared to two leading tools,\nDryVR and Flow*, SceneChecker shows 20x speedup in verification time, even\nwhile using those very tools as reachability subroutines.\n", "versions": [{"version": "v1", "created": "Sat, 21 Nov 2020 03:18:55 GMT"}, {"version": "v2", "created": "Wed, 3 Mar 2021 01:39:28 GMT"}], "update_date": "2021-03-04", "authors_parsed": [["Sibai", "Hussein", ""], ["Li", "Yangge", ""], ["Mitra", "Sayan", ""]]}, {"id": "2011.11049", "submitter": "Hubert Garavel", "authors": "Pierre Bouvier (CONVECS), Hubert Garavel (CONVECS)", "title": "The VLSAT-1 Benchmark Suite", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This report presents VLSAT-1 (an acronym for \"Very Large Boolean\nSATisfiability problems\"), the first part of a benchmark suite to be used in\nscientificexperiments and software competitions addressing SAT-solving\nissues.VLSAT-1 contains 100~benchmarks of increasing complexity, proposed in\nDIMACSCNF format under a permissive Creative Commons license. These benchmarks\nhavebeen used by the 2020 International Competition on Model Counting.\n", "versions": [{"version": "v1", "created": "Thu, 19 Nov 2020 09:20:46 GMT"}], "update_date": "2020-11-24", "authors_parsed": [["Bouvier", "Pierre", "", "CONVECS"], ["Garavel", "Hubert", "", "CONVECS"]]}, {"id": "2011.11464", "submitter": "Andrea Bisoffi", "authors": "Andrea Bisoffi and Dimos V. Dimarogonas", "title": "A hybrid barrier certificate approach to satisfy linear temporal logic\n  specifications", "comments": null, "journal-ref": "Proceedings of the American Control Conference, 2018, p. 634-639", "doi": "10.23919/ACC.2018.8430795", "report-no": null, "categories": "eess.SY cs.FL cs.SY math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work we formulate the satisfaction of a (syntactically co-safe)\nlinear temporal logic specification on a physical plant through a recent hybrid\ndynamical systems formalism. In order to solve this problem, we introduce an\nextension to such a hybrid system framework of the so-called eventuality\nproperty, which matches suitably the condition for the satisfaction of such a\ntemporal logic specification. The eventuality property can be established\nthrough barrier certificates, which we derive for the considered hybrid system\nframework. Using a hybrid barrier certificate, we propose a solution to the\noriginal problem. Simulations illustrate the effectiveness of the proposed\nmethod.\n", "versions": [{"version": "v1", "created": "Mon, 23 Nov 2020 15:21:25 GMT"}], "update_date": "2020-11-24", "authors_parsed": [["Bisoffi", "Andrea", ""], ["Dimarogonas", "Dimos V.", ""]]}, {"id": "2011.11551", "submitter": "Johannes De Smedt", "authors": "Boudewijn van Dongen, Johannes De Smedt, Claudio Di Ciccio, Jan\n  Mendling", "title": "Conformance Checking of Mixed-paradigm Process Models", "comments": "Accepted for publication in Information Systems", "journal-ref": null, "doi": "10.1016/j.is.2020.101685", "report-no": null, "categories": "cs.FL cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Mixed-paradigm process models integrate strengths of procedural and\ndeclarative representations like Petri nets and Declare. They are specifically\ninteresting for process mining because they allow capturing complex behaviour\nin a compact way. A key research challenge for the proliferation of\nmixed-paradigm models for process mining is the lack of corresponding\nconformance checking techniques. In this paper, we address this problem by\ndevising the first approach that works with intertwined state spaces of\nmixed-paradigm models. More specifically, our approach uses an alignment-based\nreplay to explore the state space and compute trace fitness in a procedural\nway. In every state, the declarative constraints are separately updated, such\nthat violations disable the corresponding activities. Our technique provides\nfor an efficient replay towards an optimal alignment by respecting all\northogonal Declare constraints. We have implemented our technique in ProM and\ndemonstrate its performance in an evaluation with real-world event logs.\n", "versions": [{"version": "v1", "created": "Mon, 23 Nov 2020 17:04:33 GMT"}], "update_date": "2020-11-30", "authors_parsed": [["van Dongen", "Boudewijn", ""], ["De Smedt", "Johannes", ""], ["Di Ciccio", "Claudio", ""], ["Mendling", "Jan", ""]]}, {"id": "2011.12742", "submitter": "Maxime Crochemore", "authors": "Golnaz Badkobeh and Maxime Crochemore", "title": "Left Lyndon tree construction", "comments": "18 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We extend the left-to-right Lyndon factorisation of a word to the left Lyndon\ntree construction of a Lyndon word. It yields an algorithm to sort the prefixes\nof a Lyndon word according to the infinite ordering defined by Dolce et al.\n(2019). A straightforward variant computes the left Lyndon forest of a word.\nAll algorithms run in linear time on a general alphabet, that is, in the\nletter-comparison model.\n", "versions": [{"version": "v1", "created": "Wed, 25 Nov 2020 13:52:42 GMT"}], "update_date": "2020-11-26", "authors_parsed": [["Badkobeh", "Golnaz", ""], ["Crochemore", "Maxime", ""]]}, {"id": "2011.13041", "submitter": "Antonio Casares", "authors": "Antonio Casares, Thomas Colcombet and Nathana\\\"el Fijalkow", "title": "Optimal transformations of Muller conditions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper, we are interested in automata over infinite words and infinite\nduration games, that we view as general transition systems. We study\ntransformations of systems using a Muller condition into ones using a parity\ncondition, extending Zielonka's construction. We introduce the alternating\ncycle decomposition transformation, and we prove a strong optimality result:\nfor any given deterministic Muller automaton, the obtained parity automaton is\nminimal both in size and number of priorities among those automata admitting a\nmorphism into the original Muller automaton.\n  We give two applications. The first is an improvement in the process of\ndeterminisation of B\\\"uchi automata into parity automata by Piterman and\nSchewe. The second is to present characterisations on the possibility of\nrelabelling automata with different acceptance conditions.\n", "versions": [{"version": "v1", "created": "Wed, 25 Nov 2020 22:00:06 GMT"}, {"version": "v2", "created": "Mon, 18 Jan 2021 12:25:59 GMT"}, {"version": "v3", "created": "Fri, 5 Feb 2021 10:23:44 GMT"}], "update_date": "2021-02-08", "authors_parsed": [["Casares", "Antonio", ""], ["Colcombet", "Thomas", ""], ["Fijalkow", "Nathana\u00ebl", ""]]}, {"id": "2011.13344", "submitter": "Jan Baumeister", "authors": "Jan Baumeister, Bernd Finkbeiner, Matthis Kruse, Maximilian Schwenger", "title": "Automatic Optimizations for Stream-based Monitoring Languages", "comments": "20th International Conference on Runtime Verification (2020)", "journal-ref": null, "doi": "10.1007/978-3-030-60508-7", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Runtime monitors that are specified in a stream-based monitoring language\ntend to be easier to understand, maintain, and reuse than those written in a\nstandard programming language. Because of their formal semantics, such\nspecification languages are also a natural choice for safety-critical\napplications. Unlike for standard programming languages, there is, however, so\nfar very little support for automatic code optimization. In this paper, we\npresent the first collection of code transformations for the stream-based\nmonitoring language RTLola. We show that classic compiler optimizations, such\nas Sparse Conditional Constant Propagation and Common Subexpression\nElimination, can be adapted to monitoring specifications. We also develop new\ntransformations -- Pacing Type Refinement and Filter Refinement -- which\nexploit the specific modular structure of RTLola as well as the implementation\nfreedom afforded by a declarative specification language. We demonstrate the\nsignificant impact of the code transformations on benchmarks from the\nmonitoring of unmanned aircraft systems (UAS).\n", "versions": [{"version": "v1", "created": "Thu, 26 Nov 2020 15:19:26 GMT"}], "update_date": "2020-11-30", "authors_parsed": [["Baumeister", "Jan", ""], ["Finkbeiner", "Bernd", ""], ["Kruse", "Matthis", ""], ["Schwenger", "Maximilian", ""]]}, {"id": "2011.14404", "submitter": "Stefan Hoffmann", "authors": "Stefan Hoffmann", "title": "State Complexity of the Set of Synchronizing Words for Circular Automata\n  and Automata over Binary Alphabets", "comments": "Accepted at the 15th International Conference on Language and\n  Automata Theory and Applications (LATA 2021),\n  https://irdta.eu/lata2020-2021//acceptedpapers/. arXiv admin note: text\n  overlap with arXiv:2007.09104", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most slowly synchronizing automata over binary alphabets are circular, i.e.,\ncontaining a letter permuting the states in a single cycle, and their set of\nsynchronizing words has maximal state complexity, which also implies complete\nreachability.Here, we take a closer look at generalized circular and completely\nreachable automata. We derive that over a binary alphabet every completely\nreachable automaton must be circular, a consequence of a structural result\nstating that completely reachable automata over strictly less letters than\nstates always contain permutational letters. We state sufficient conditions for\nthe state complexity of the set of synchronizing words of a generalized\ncircular automaton to be maximal. We apply our main criteria to the family\n$\\mathscr K_n$ of automata that was previously only conjectured to have this\nproperty.\n", "versions": [{"version": "v1", "created": "Sun, 29 Nov 2020 17:56:38 GMT"}], "update_date": "2020-12-01", "authors_parsed": [["Hoffmann", "Stefan", ""]]}, {"id": "2011.14856", "submitter": "Alexander Okhotin", "authors": "Olga Martynova, Alexander Okhotin", "title": "State complexity of halting, returning and reversible graph-walking\n  automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Graph-walking automata (GWA) traverse graphs by moving between the nodes\nfollowing the edges, using a finite-state control to decide where to go next.\nIt is known that every GWA can be transformed to a GWA that halts on every\ninput, to a GWA returning to the initial node in order to accept, and to a\nreversible GWA. This paper establishes lower bounds on the state blow-up of\nthese transformations, as well as closely matching upper bounds. It is shown\nthat making an $n$-state GWA traversing $k$-ary graphs halt on every input\nrequires at most $2nk+1$ states and at least $2(n-1)(k-3)$ states in the worst\ncase; making a GWA return to the initial node before acceptance takes at most\n$2nk+n$ and at least $2(n-1)(k-3)$ states in the worst case; Automata\nsatisfying both properties at once have at most $4nk+1$ and at least\n$4(n-1)(k-3)$ states in the worst case. Reversible automata have at most\n$4nk+1$ and at least $4(n-1)(k-3)-1$ states in the worst case.\n", "versions": [{"version": "v1", "created": "Mon, 30 Nov 2020 14:51:37 GMT"}], "update_date": "2020-12-01", "authors_parsed": [["Martynova", "Olga", ""], ["Okhotin", "Alexander", ""]]}]