[{"id": "2105.00052", "submitter": "Wojciech Czerwi\\'nski", "authors": "Wojciech Czerwi\\'nski, Adam J\\k{e}drych", "title": "Long Runs Imply Big Separators in Vector Addition Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Despite a very recent progress which settled the complexity of the\nreachability problem for Vector Addition Systems with States (VASSes) to be\nAckermann-complete we still lack of lot of understanding for that problem. A\nstriking example is the reachability problem for three-dimensional VASSes\n(3-VASSes): it is only known to be PSpace-hard and not known to be elementary.\nOne possible approach which turned out to be successful for many VASS\nsubclasses is to prove that to check reachability it suffices to inspect only\nruns of some bounded length. This approach however has its limitations, it is\nusually hard to design an algorithm substantially faster than the possible size\nof finite reachability sets in that VASS subclass. In 2010 Leroux has proven\nthat non-reachability between two configurations implies separability of the\nsource from target by some semilinear set, which is an inductive invariant.\nThere can be a reasonable hope that it suffices to look for separators of\nbounded size, which would deliver an efficient algorithm for VASS reachability.\nIn the paper we show that in VASSes fulfilling certain conditions existence of\nonly long runs between some configurations implies existence of only big\nseparators between some other configurations (and in a slightly modified VASS).\nAdditionally we prove that a few known examples of hard VASSes fulfil the\nmentioned conditions. Therefore improving the complexity of the reachability\nproblem (for any subclass) using the separators approach can meet serious\nobstacles.\n", "versions": [{"version": "v1", "created": "Fri, 30 Apr 2021 19:27:04 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Czerwi\u0144ski", "Wojciech", ""], ["J\u0119drych", "Adam", ""]]}, {"id": "2105.00208", "submitter": "Erwan Mahe", "authors": "Erwan Mahe, Christophe Gaston, Pascale Le Gall", "title": "A structural operational semantics for interactions with a look at loops", "comments": "14 pages of contents, 9 additional pages with 1 for references and 8\n  for appendices, 5 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Message Sequence Charts & Sequence Diagrams are graphical models that\nrepresent the behavior of distributed and concurrent systems via the scheduling\nof discrete and local emission and reception events. We propose an Interaction\nLanguage (IL) to formalize such models, defined as a term algebra which\nincludes strict and weak sequencing, alternative and parallel composition and\nfour kinds of loops. This IL is equipped with a denotational-style semantics\nassociating a set of traces (sequences of observed events) to each interaction.\nWe then define a structural operational semantics in the style of process\nalgebras and formally prove the equivalence of both semantics.\n", "versions": [{"version": "v1", "created": "Sat, 1 May 2021 10:15:29 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Mahe", "Erwan", ""], ["Gaston", "Christophe", ""], ["Gall", "Pascale Le", ""]]}, {"id": "2105.00436", "submitter": "Volker Diekert", "authors": "Volker Diekert, Henning Fernau, Petra Wolf", "title": "Properties of Graphs Specified by a Regular Language", "comments": "15 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Traditionally, graph algorithms get a single graph as input, and then they\nshould decide if this graph satisfies a certain property $\\Phi$.What happens if\nthis question is modified in a way that we get a possibly infinite family of\ngraphs as an input, and the question if is there exists one graph\nsatisfying$\\Phi$? We approach this question by using formal languages for\nspecifying families of graphs. In particular, we show that certain graph\nproperties can be decided by studying the syntactic monoid of the specification\nlanguage $L$ if a certain torsion condition is satisfied. This condition holds\ntrivially if $L$ is regular.\n  In order to show our results, we split $L$ into a finite union of subsets\n$L_\\alpha$. Every $L_\\alpha$ defines in a natural way a single finite graph\n$F_\\alpha$ where some edges and vertices are marked. The marked graph in turn\ndefines a set of graphs with a geometric description using the notion of graph\nretraction and where $F_\\alpha$ appears as an induced subgraph.\n", "versions": [{"version": "v1", "created": "Sun, 2 May 2021 10:04:24 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Diekert", "Volker", ""], ["Fernau", "Henning", ""], ["Wolf", "Petra", ""]]}, {"id": "2105.00452", "submitter": "Ilkka T\\\"orm\\\"a", "authors": "Pierre Marcus and Ilkka T\\\"orm\\\"a", "title": "Winning Sets of Regular Languages: Descriptional and Computational\n  Complexity", "comments": "24 pages, 11 figures. arXiv admin note: substantial text overlap with\n  arXiv:2004.13668", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate certain word-construction games with variable turn orders. In\nthese games, Alice and Bob take turns on choosing consecutive letters of a word\nof fixed length, with Alice winning if the result lies in a predetermined\ntarget language. The turn orders that result in a win for Alice form a binary\nlanguage that is regular whenever the target language is, and we prove some\nupper and lower bounds for its state complexity based on that of the target\nlanguage. We also consider the computational complexity of membership and\nintersection problems of winning sets.\n", "versions": [{"version": "v1", "created": "Sun, 2 May 2021 12:00:41 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Marcus", "Pierre", ""], ["T\u00f6rm\u00e4", "Ilkka", ""]]}, {"id": "2105.01137", "submitter": "Micha{\\l} Skrzypczak", "authors": "Lorenzo Clemente, Micha{\\l} Skrzypczak", "title": "Deterministic and game separability for regular languages of infinite\n  trees", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We show that it is decidable whether two regular languages of infinite trees\nare separable by a deterministic language, resp., a game language. We consider\ntwo variants of separability, depending on whether the set of priorities of the\nseparator is fixed, or not. In each case, we show that separability can be\ndecided in EXPTIME, and that separating automata of exponential size suffice.\nWe obtain our results by reducing to infinite duration games with\n{\\omega}-regular winning conditions and applying the finite-memory determinacy\ntheorem of B\\\"uchi and Landweber.\n", "versions": [{"version": "v1", "created": "Mon, 3 May 2021 19:25:57 GMT"}], "update_date": "2021-05-05", "authors_parsed": [["Clemente", "Lorenzo", ""], ["Skrzypczak", "Micha\u0142", ""]]}, {"id": "2105.01179", "submitter": "Taylor J. Smith", "authors": "Taylor J. Smith and Kai Salomaa", "title": "Degrees of Restriction for Two-Dimensional Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A three-way (resp., two-way) two-dimensional automaton has a read-only input\nhead that moves in three (resp., two) directions on a finite array of cells\nlabelled by symbols of the input alphabet. Restricting the input head movement\nof a two-dimensional automaton results in a model that is weaker in terms of\nrecognition power.\n  In this paper, we introduce the notion of \"degrees of restriction\" for\ntwo-dimensional automata, and we develop sets of extended two-dimensional\nautomaton models that allow for some bounded number of restricted moves. We\nestablish recognition hierarchies for both deterministic and nondeterministic\nextended three-way two-dimensional automata, and we find similar hierarchies\nfor both deterministic and nondeterministic extended two-way two-dimensional\nautomata. We also prove incomparability results between nondeterministic and\ndeterministic extended three-way two-dimensional automata. Lastly, we consider\nclosure properties for some operations on languages recognized by extended\nthree-way two-dimensional automata.\n", "versions": [{"version": "v1", "created": "Mon, 3 May 2021 21:30:32 GMT"}], "update_date": "2021-05-05", "authors_parsed": [["Smith", "Taylor J.", ""], ["Salomaa", "Kai", ""]]}, {"id": "2105.01236", "submitter": "Zhihao Jiang", "authors": "Guangyao Chen and Zhihao Jiang", "title": "Environment Modeling During Model Checking of Cyber-Physical Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Ensuring the safety and efficacy of Cyber-Physical Systems (CPSs) is\nchallenging due to the large variability of their operating environment. Model\nchecking has been proposed for validation of CPSs, but the models of the\nenvironment are either too specific to capture the variability of the\nenvironment, or too abstract to provide counter-examples interpretable by\nexperts in the application domain. Domain-specific solutions to this problem\nrequire expertise in both formal methods and the application domain, which\nprevents effective application of model checking in CPSs validation. A\ndomain-independent framework based on timed-automata is proposed for\nabstraction and refinement of environment models during model checking. The\nframework maintains an abstraction tree of environment models, which provides\ninterpretable counter-examples while ensuring coverage of environment\nbehaviors. With the framework, experts in the application domain can\neffectively use model checking without expertise in formal methods.\n", "versions": [{"version": "v1", "created": "Tue, 4 May 2021 01:20:26 GMT"}], "update_date": "2021-05-05", "authors_parsed": [["Chen", "Guangyao", ""], ["Jiang", "Zhihao", ""]]}, {"id": "2105.01341", "submitter": "Teodor Knapik", "authors": "Teodor Knapik (ISEA)", "title": "Signal automata and hidden Markov models", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A generic method for inferring a dynamical hidden Markov model from a time\nseries is proposed. Under reasonable hypothesis, the model is updated in\nconstant time whenever a new measurement arrives.\n", "versions": [{"version": "v1", "created": "Tue, 4 May 2021 07:41:10 GMT"}], "update_date": "2021-05-05", "authors_parsed": [["Knapik", "Teodor", "", "ISEA"]]}, {"id": "2105.01512", "submitter": "Antonio Abu Nassar", "authors": "Antonio Abu Nassar and Shaull Almagor", "title": "Simulation by Rounds of Letter-to-Letter Transducers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Letter-to-letter transducers are a standard formalism for modeling reactive\nsystems. Often, two transducers that model similar systems differ locally from\none another, by behaving similarly, up to permutations of the input and output\nletters within \"rounds\". In this work, we introduce and study notions of\nsimulation by rounds and equivalence by rounds of transducers. In our setting,\nwords are partitioned to consecutive subwords of a fixed length $k$, called\nrounds. Then, a transducer $\\mathcal{T}_1$ is $k$-round simulated by transducer\n$\\mathcal{T}_2$ if, intuitively, for every input word $x$, we can permute the\nletters within each round in $x$, such that the output of $\\mathcal{T}_2$ on\nthe permuted word is itself a permutation of the output of $\\mathcal{T}_1$ on\n$x$. Finally, two transducers are $k$-round equivalent if they simulate each\nother.\n  We solve two main decision problems, namely whether $\\mathcal{T}_2$ $k$-round\nsimulates $\\mathcal{T}_1$ (1) when $k$ is given as input, and (2) for an\nexistentially quantified $k$.\n  We demonstrate the usefulness of the definitions by applying them to process\nsymmetry: a setting in which a permutation in the identities of processes in a\nmulti-process system naturally gives rise to two transducers, whose $k$-round\nequivalence corresponds to stability against such permutations.\n", "versions": [{"version": "v1", "created": "Tue, 4 May 2021 14:14:16 GMT"}], "update_date": "2021-05-05", "authors_parsed": [["Nassar", "Antonio Abu", ""], ["Almagor", "Shaull", ""]]}, {"id": "2105.01861", "submitter": "Pawe{\\l} Parys", "authors": "Pawe{\\l} Parys", "title": "Higher-Order Model Checking Step by Step", "comments": "This is an extended version of a paper published on the ICALP 2021\n  conference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show a new simple algorithm that solves the model-checking problem for\nrecursion schemes: check whether the tree generated by a given higher-order\nrecursion scheme is accepted by a given alternating parity automaton. The\nalgorithm amounts to a procedure that transforms a recursion scheme of order\n$n$ to a recursion scheme of order $n-1$, preserving acceptance, and increasing\nthe size only exponentially. After repeating the procedure $n$ times, we obtain\na recursion scheme of order $0$, for which the problem boils down to solving a\nfinite parity game. Since the size grows exponentially at each step, the\noverall complexity is $n$-EXPTIME, which is known to be optimal. More\nprecisely, the transformation is linear in the size of the recursion scheme,\nassuming that the arity of employed nonterminals and the size of the automaton\nare bounded by a constant; this results in an FPT algorithm for the\nmodel-checking problem.\n  Our transformation is a generalization of a previous transformation of the\nauthor (2020), working for reachability automata in place of parity automata.\nThe step-by-step approach can be opposed to previous algorithms solving the\nconsidered problem \"in one step\", being compulsorily more complicated.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 04:21:31 GMT"}], "update_date": "2021-05-06", "authors_parsed": [["Parys", "Pawe\u0142", ""]]}, {"id": "2105.02033", "submitter": "Anna Jonsson", "authors": "Johanna Bj\\\"orklund, Frank Drewes, and Anna Jonsson", "title": "Polynomial Graph Parsing with Non-Structural Reentrancies", "comments": "23 pages with 7 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Graph-based semantic representations are valuable in natural language\nprocessing, where it is often simple and effective to represent linguistic\nconcepts as nodes, and relations as edges between them. Several attempts has\nbeen made to find a generative device that is sufficiently powerful to\nrepresent languages of semantic graphs, while at the same allowing efficient\nparsing. We add to this line of work by introducing graph extension grammar,\nwhich consists of an algebra over graphs together with a regular tree grammar\nthat generates expressions over the operations of the algebra. Due to the\ndesign of the operations, these grammars can generate graphs with\nnon-structural reentrancies; a type of node-sharing that is excessively common\nin formalisms such as abstract meaning representation, but for which existing\ndevices offer little support. We provide a parsing algorithm for graph\nextension grammars, which is proved to be correct and run in polynomial time.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 13:05:01 GMT"}, {"version": "v2", "created": "Thu, 6 May 2021 11:20:22 GMT"}, {"version": "v3", "created": "Fri, 7 May 2021 08:11:22 GMT"}], "update_date": "2021-05-10", "authors_parsed": [["Bj\u00f6rklund", "Johanna", ""], ["Drewes", "Frank", ""], ["Jonsson", "Anna", ""]]}, {"id": "2105.02611", "submitter": "Martin Zimmermann", "authors": "Shibashis Guha, Isma\\\"el Jecker, Karoliina Lehtinen, Martin Zimmermann", "title": "A Bit of Nondeterminism Makes Pushdown Automata Expressive and Succinct", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We study the expressiveness and succinctness of good-for-games pushdown\nautomata (GFG-PDA) over finite words, that is, pushdown automata whose\nnondeterminism can be resolved based on the run constructed so far, but\nindependently of the remainder of the input word.\n  We prove that GFG-PDA recognise more languages than deterministic PDA (DPDA)\nbut not all context-free languages (CFL). This class is orthogonal to\nunambiguous CFL. We further show that GFG-PDA can be exponentially more\nsuccinct than DPDA, while PDA can be double-exponentially more succinct than\nGFG-PDA. We also study GFGness in visibly pushdown automata (VPA), which enjoy\nbetter closure properties than PDA, and for which we show GFGness to be\nEXPTIME-complete. GFG-VPA can be exponentially more succinct than deterministic\nVPA, while VPA can be exponentially more succinct than GFG-VPA. Both of these\nlower bounds are tight.\n  Finally, we study the complexity of resolving nondeterminism in GFG-PDA.\nEvery GFG-PDA has a positional resolver, a function that resolves\nnondeterminism and that is only dependant on the current configuration.\nPushdown transducers are sufficient to implement the resolvers of GFG-VPA, but\nnot those of GFG-PDA. GFG-PDA with finite-state resolvers are determinisable.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 12:36:26 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Guha", "Shibashis", ""], ["Jecker", "Isma\u00ebl", ""], ["Lehtinen", "Karoliina", ""], ["Zimmermann", "Martin", ""]]}, {"id": "2105.02750", "submitter": "Arseny Shur", "authors": "Elena A. Petrova and Arseny M. Shur", "title": "Branching Frequency and Markov Entropy of Repetition-Free Languages", "comments": "16 pages, 2 figures. Submitted to DLT 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define a new quantitative measure for an arbitrary factorial language: the\nentropy of a random walk in the prefix tree associated with the language; we\ncall it Markov entropy. We relate Markov entropy to the growth rate of the\nlanguage and to the parameters of branching of its prefix tree. We show how to\ncompute Markov entropy for a regular language. Finally, we develop a framework\nfor experimental study of Markov entropy by modelling random walks and present\nthe results of experiments with power-free and Abelian-power-free languages.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 15:19:56 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Petrova", "Elena A.", ""], ["Shur", "Arseny M.", ""]]}, {"id": "2105.03038", "submitter": "Dusko Pavlovic", "authors": "Dusko Pavlovic", "title": "Lambek pregroups are Frobenius spiders in preorders", "comments": "21 pages, 16 diagrams, submitted. v2: corrected typos and style", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.CL cs.FL cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  \"Spider\" is a nickname of *special Frobenius algebras*, a fundamental\nstructure from mathematics, physics, and computer science. *Pregroups* are a\nfundamental structure from linguistics. Pregroups and spiders have been used\ntogether in natural language processing: one for syntax, the other for\nsemantics. It turns out that pregroups themselves can be characterized as\npointed spiders in the category of preordered relations, where they naturally\narise from grammars. The other way around preordered spider algebras in general\ncan be characterized as unions of pregroups. This extends the characterization\nof relational spider algebras as disjoint unions of groups. The compositional\nframework that emerged with the results suggests new ways to understand and\napply the basis structures in machine learning and data analysis.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 02:42:03 GMT"}, {"version": "v2", "created": "Mon, 10 May 2021 20:48:50 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Pavlovic", "Dusko", ""]]}, {"id": "2105.03081", "submitter": "Ryohei Oura", "authors": "Ryohei Oura, Toshimitsu Ushio, and Ami Sakakibara", "title": "Bounded Synthesis and Reinforcement Learning of Supervisors for\n  Stochastic Discrete Event Systems with LTL Specifications", "comments": "15 pages, 4 figures, 2 tables, submitted to a journal", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.SY", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper, we consider supervisory control of stochastic discrete event\nsystems (SDESs) under linear temporal logic specifications. Applying the\nbounded synthesis, we reduce the supervisor synthesis into a problem of\nsatisfying a safety condition. First, we consider a synthesis problem of a\ndirected controller using the safety condition. We assign a negative reward to\nthe unsafe states and introduce an expected return with a state-dependent\ndiscount factor. We compute a winning region and a directed controller with the\nmaximum satisfaction probability using a dynamic programming method, where the\nexpected return is used as a value function. Next, we construct a permissive\nsupervisor via the optimal value function. We show that the supervisor\naccomplishes the maximum satisfaction probability and maximizes the reachable\nset within the winning region. Finally, for an unknown SDES, we propose a\ntwo-stage model-free reinforcement learning method for efficient learning of\nthe winning region and the directed controllers with the maximum satisfaction\nprobability. We also demonstrate the effectiveness of the proposed method by\nsimulation.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 06:31:35 GMT"}, {"version": "v2", "created": "Thu, 3 Jun 2021 14:53:35 GMT"}], "update_date": "2021-06-04", "authors_parsed": [["Oura", "Ryohei", ""], ["Ushio", "Toshimitsu", ""], ["Sakakibara", "Ami", ""]]}, {"id": "2105.03096", "submitter": "Peter Chini", "authors": "Peter Chini and Florian Furbach", "title": "Petri Net Invariant Synthesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the synthesis of inductive half spaces (IHS). These are linear\ninequalities that form inductive invariants for Petri nets, capable of\ndisproving reachability or coverability. IHS generalize classic notions of\ninvariants like traps or siphons. Their synthesis is desirable for disproving\nreachability or coverability where traditional invariants may fail.\n  We formulate a CEGAR-loop for the synthesis of IHS. The first step is to\nestablish a structure theory of IHS. We analyze the space of IHS with methods\nfrom discrete mathematics and derive a linear constraint system closely\nover-approximating the space. To discard false positives, we provide an\nalgorithm that decides whether a given half space is indeed inductive, a\nproblem that we prove to be coNP-complete. We implemented the CEGAR-loop in the\ntool INEQUALIZER and our experiments show that it is competitive against\nstate-of-the-art techniques.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 07:50:21 GMT"}], "update_date": "2021-05-10", "authors_parsed": [["Chini", "Peter", ""], ["Furbach", "Florian", ""]]}, {"id": "2105.03375", "submitter": "Stefan Kuhn", "authors": "Antonio Cau, Stefan Kuhn, James Hoey", "title": "Executable Interval Temporal Logic Specifications", "comments": "11 pages, 0 figures, 1 table, abridged version to published in\n  Reversible Computation 2021", "journal-ref": null, "doi": "10.1007/978-3-030-79837-6_13", "report-no": null, "categories": "cs.FL cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper the reversibility of executable Interval Temporal Logic (ITL)\nspecifications is investigated. ITL allows for the reasoning about systems in\nterms of behaviours which are represented as non-empty sequences of states. It\nallows for the specification of systems at different levels of abstraction. At\na high level this specification is in terms of properties, for instance safety\nand liveness properties. At concrete level one can specify a system in terms of\nprogramming constructs. One can execute these concrete specification, i.e.,\ntest and simulate the behaviour of the system. In this paper we will formalise\nthis notion of executability of ITL specifications. ITL also has a reflection\noperator which allows for the reasoning about reversed behaviours. We will\ninvestigate the reversibility of executable ITL specifications, i.e., how one\ncan use this reflection operator to reverse the concrete behaviour of a\nparticular system.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 16:36:24 GMT"}], "update_date": "2021-07-12", "authors_parsed": [["Cau", "Antonio", ""], ["Kuhn", "Stefan", ""], ["Hoey", "James", ""]]}, {"id": "2105.04165", "submitter": "Pan Lu", "authors": "Pan Lu, Ran Gong, Shibiao Jiang, Liang Qiu, Siyuan Huang, Xiaodan\n  Liang, Song-Chun Zhu", "title": "Inter-GPS: Interpretable Geometry Problem Solving with Formal Language\n  and Symbolic Reasoning", "comments": "Accepted to ACL 2021, 13 pages, 6 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CL cs.AI cs.CV cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Geometry problem solving has attracted much attention in the NLP community\nrecently. The task is challenging as it requires abstract problem understanding\nand symbolic reasoning with axiomatic knowledge. However, current datasets are\neither small in scale or not publicly available. Thus, we construct a new\nlarge-scale benchmark, Geometry3K, consisting of 3,002 geometry problems with\ndense annotation in formal language. We further propose a novel geometry\nsolving approach with formal language and symbolic reasoning, called\nInterpretable Geometry Problem Solver (Inter-GPS). Inter-GPS first parses the\nproblem text and diagram into formal language automatically via rule-based text\nparsing and neural object detecting, respectively. Unlike implicit learning in\nexisting methods, Inter-GPS incorporates theorem knowledge as conditional rules\nand performs symbolic reasoning step by step. Also, a theorem predictor is\ndesigned to infer the theorem application sequence fed to the symbolic solver\nfor the more efficient and reasonable searching path. Extensive experiments on\nthe Geometry3K and GEOS datasets demonstrate that Inter-GPS achieves\nsignificant improvements over existing methods. The project with code and data\nis available at https://lupantech.github.io/inter-gps.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 07:46:55 GMT"}, {"version": "v2", "created": "Tue, 1 Jun 2021 19:28:02 GMT"}, {"version": "v3", "created": "Tue, 20 Jul 2021 23:22:27 GMT"}], "update_date": "2021-07-22", "authors_parsed": [["Lu", "Pan", ""], ["Gong", "Ran", ""], ["Jiang", "Shibiao", ""], ["Qiu", "Liang", ""], ["Huang", "Siyuan", ""], ["Liang", "Xiaodan", ""], ["Zhu", "Song-Chun", ""]]}, {"id": "2105.04308", "submitter": "Luca Manzoni", "authors": "Gianpiero Cattaneo and Luca Manzoni", "title": "Parallel Sandpiles or Spurious Bidirectional Icepiles?", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a recent paper E. Formenti and K. Perrot (FP) introduce a global rule\nassumed to describe the discrete time dynamics associated with a sandpile model\nunder the parallel application of a suitable local rule acting on d dimensional\nlattices of cells equipped with uniform neighborhood. In this paper we submit\nthis approach to a critical analysis, in the simplest elementary particular\ncase of a one-dimensional lattice, which can be divided in two parts. In the\nfirst part we prove that the FP global rule does not describe the dynamics of\nstandard sandpiles, but rather furnishes a description of the quite different\nsituation of height difference between consecutive piles. This is a semantic\nuncorrect difference of interpretation. In the second part we investigate the\nconsequences of the uncorrect FP assumption proving that their global rule\ndescribes a bidirectional spurious dynamics of icepiles (rather than\nsandpiles), in the sense that this latter is the consequence of application of\nthree local rules: bidirectional vertical rule, bidirectional horizontal rule\n(typical of icepiles), and a granule jump from the bottom to the top (spurious\nrule of the dynamics).\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 12:40:18 GMT"}, {"version": "v2", "created": "Tue, 11 May 2021 09:11:18 GMT"}, {"version": "v3", "created": "Sun, 16 May 2021 19:53:41 GMT"}], "update_date": "2021-05-18", "authors_parsed": [["Cattaneo", "Gianpiero", ""], ["Manzoni", "Luca", ""]]}, {"id": "2105.04593", "submitter": "Lening Li", "authors": "Lening Li and Jie Fu", "title": "Policy Synthesis for Metric Interval Temporal Logic with Probabilistic\n  Distributions", "comments": "7 pages, 2 figures, submitted to The 60th IEEE conference on Decision\n  and Control", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Metric Temporal Logic can express temporally evolving properties with\ntime-critical constraints or time-triggered constraints for real-time systems.\nThis paper extends the Metric Interval Temporal Logic with a distribution\neventuality operator to express time-sensitive missions for a system\ninteracting with a dynamic, probabilistic environment. This formalism enables\nus to describe the probabilistic occurrences of random external events as part\nof the task specification and event-triggered temporal constraints for the\nintended system's behavior. The main contributions of this paper are two folds:\nFirst, we propose a procedure to translate a specification into a stochastic\ntimed automaton. Second, we develop an approximate-optimal probabilistic\nplanning problem for synthesizing the control policy that maximizes the\nprobability for the planning agent to achieve the task, provided that the\nexternal events satisfy the specification. The planning algorithm employs a\ntruncation in the clocks for the timed automaton to reduce the planning in a\ncountably infinite state space to a finite state space with a bounded error\nguarantee. We illustrate the method with a robot motion planning example.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 18:17:12 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Li", "Lening", ""], ["Fu", "Jie", ""]]}, {"id": "2105.04662", "submitter": "Kayla Boggess", "authors": "Shenghui Chen, Kayla Boggess, David Parker, and Lu Feng", "title": "Multi-Objective Controller Synthesis with Uncertain Human Preferences", "comments": "23 pages, 9 figures, 3 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Multi-objective controller synthesis concerns the problem of computing an\noptimal controller subject to multiple (possibly conflicting) objective\nproperties. The relative importance of objectives is often specified by human\ndecision-makers. However, there is inherent uncertainty in human preferences\n(e.g., due to different preference elicitation methods). In this paper, we\nformalize the notion of uncertain human preferences and present a novel\napproach that accounts for uncertain human preferences in the multi-objective\ncontroller synthesis for Markov decision processes (MDPs). Our approach is\nbased on mixed-integer linear programming (MILP) and synthesizes a sound,\noptimally permissive multi-strategy with respect to a multi-objective property\nand an uncertain set of human preferences. Experimental results on a range of\nlarge case studies show that our MILP-based approach is feasible and scalable\nto synthesize sound, optimally permissive multi-strategies with varying MDP\nmodel sizes and uncertainty levels of human preferences. Evaluation via an\nonline user study also demonstrates the quality and benefits of synthesized\n(multi-)strategies.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 20:41:05 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Chen", "Shenghui", ""], ["Boggess", "Kayla", ""], ["Parker", "David", ""], ["Feng", "Lu", ""]]}, {"id": "2105.05159", "submitter": "Yuandong Cyrus Liu", "authors": "Yuandong Cyrus Liu (1), Chengbin Pang (1), Daniel Dietsch (2) and Eric\n  Koskinen (1), Ton-Chanh Le (1), Georgios Portokalidis (1), Jun Xu (1) ((1)\n  Stevens Institute of Technology, (2) University of Freiburg)", "title": "Source-Level Bitwise Branching for Temporal Verification of Lifted\n  Binaries", "comments": "38 pages(including Appendix), 10 tables, 2 Postscript figures,\n  submitted to ATVA 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL cs.SE cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There is increasing interest in applying verification tools to programs that\nhave bitvector operations (eg., binaries). SMT solvers, which serve as a\nfoundation for these tools, have thus increased support for bitvector reasoning\nthrough bit-blasting and linear arithmetic approximations. In this paper we\nshow that similar linear arithmetic approximation of bitvector operations can\nbe done at the source level through transformations. Specifically, we introduce\nnew paths that over-approximate bitvector operations with linear\nconditions/constraints, increasing branching but allowing us to better exploit\nthe well-developed integer reasoning and interpolation of verification tools.\nWe show that, for reachability of bitvector programs, increased branching\nincurs negligible overhead yet, when combined with integer interpolation\noptimizations, enables more programs to be verified. We further show this\nexploitation of integer interpolation in the common case also enables\ncompetitive termination verification of bitvector programs and leads to the\nfirst effective technique for LTL verification of bitvector programs. Finally,\nwe provide an in-depth case study of decompiled (\"lifted\") binary programs,\nwhich emulate X86 execution through frequent use of bitvector operations. We\npresent a new tool DarkSea, the first tool capable of verifying reachability,\ntermination, and LTL of such lifted binaries.\n", "versions": [{"version": "v1", "created": "Tue, 11 May 2021 16:12:02 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Liu", "Yuandong Cyrus", ""], ["Pang", "Chengbin", ""], ["Dietsch", "Daniel", ""], ["Koskinen", "Eric", ""], ["Le", "Ton-Chanh", ""], ["Portokalidis", "Georgios", ""], ["Xu", "Jun", ""]]}, {"id": "2105.05968", "submitter": "Peter Gacs", "authors": "Peter Gacs", "title": "A new version of Toom's proof", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There are several proofs now for the stability of Toom's example of a\ntwo-dimensional stable cellular automaton and its application to fault-tolerant\ncomputation. Simon and Berman simplified and strengthened Toom's original\nproof: the present report is a simplified exposition of their proof.\n", "versions": [{"version": "v1", "created": "Wed, 12 May 2021 21:12:39 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Gacs", "Peter", ""]]}, {"id": "2105.06184", "submitter": "Abuzer Yakaryilmaz", "authors": "Utku Birkan, \\\"Ozlem Salehi, Viktor Olejar, Cem Nurlu, and Abuzer\n  Yakary{\\i}lmaz", "title": "Implementing Quantum Finite Automata Algorithms on Noisy Devices", "comments": "14 pages, accepted to \"Quantum Computing Thematic Track in\n  conjunction with the International Conference on Computational Science 2021\"", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Quantum finite automata (QFAs) literature offers an alternative mathematical\nmodel for studying quantum systems with finite memory. As a superiority of\nquantum computing, QFAs have been shown exponentially more succinct on certain\nproblems such as recognizing the language $ MOD_p = \\{a^j \\mid j \\equiv 0 \\mod\np\\} $ with bounded error, where $p$ is a prime number. In this paper we present\nimproved circuit based implementations for QFA algorithms recognizing the $\nMOD_p $ problem using the Qiskit framework. We focus on the case $p=11$ and\nprovide a 3 qubit implementation for the $MOD_{11}$ problem reducing the total\nnumber of required gates using alternative approaches. We run the circuits on\nreal IBM quantum devices but due to the limitation of the real quantum devices\nin the NISQ era, the results are heavily affected by the noise. This limitation\nreveals once again the need for algorithms using less amount of resources.\nConsequently, we consider an alternative 3 qubit implementation which works\nbetter in practice and obtain promising results even for the problem $ MOD_{31}\n$.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 10:51:28 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Birkan", "Utku", ""], ["Salehi", "\u00d6zlem", ""], ["Olejar", "Viktor", ""], ["Nurlu", "Cem", ""], ["Yakary\u0131lmaz", "Abuzer", ""]]}, {"id": "2105.06202", "submitter": "Agi Kurucz", "authors": "Agi Kurucz, Vladislav Ryzhikov, Yury Savateev, and Michael\n  Zakharyaschev", "title": "Deciding FO-definability of Regular Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that, similarly to known PSpace-completeness of recognising\nFO(<)-definability of the language L(A) of a DFA A, deciding both FO(<,C)- and\nFO(<,MOD)-definability are PSpace-complete. (Here, FO(<,C) extends the\nfirst-order logic FO(<) with the standard congruence modulo n relation, and\nFO(<,MOD) with the quantifiers checking whether the number of positions\nsatisfying a given formula is divisible by a given n>1. These FO-languages are\nknown to define regular languages that are decidable in AC0 and ACC0,\nrespectively.) We obtain these results by first showing that known algebraic\ncharacterisations of FO-definability of L(A) can be captured by `localisable'\nproperties of the transition monoid of A. Using our criterion, we then\ngeneralise the known proof of PSpace-hardness of FO(<)-definability, and\nestablish the upper bounds not only for arbitrary DFAs but also for two-way\nNFAs.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 11:45:07 GMT"}, {"version": "v2", "created": "Fri, 21 May 2021 09:43:39 GMT"}, {"version": "v3", "created": "Tue, 25 May 2021 10:38:14 GMT"}, {"version": "v4", "created": "Thu, 3 Jun 2021 12:56:27 GMT"}], "update_date": "2021-06-04", "authors_parsed": [["Kurucz", "Agi", ""], ["Ryzhikov", "Vladislav", ""], ["Savateev", "Yury", ""], ["Zakharyaschev", "Michael", ""]]}, {"id": "2105.06686", "submitter": "James C. A. Main", "authors": "James C. A. Main, Mickael Randour, Jeremy Sproston", "title": "Time Flies When Looking out of the Window: Timed Games with Window\n  Parity Objectives", "comments": "Full version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The window mechanism was introduced by Chatterjee et al. to reinforce\nmean-payoff and total-payoff objectives with time bounds in two-player\nturn-based games on graphs. It has since proved useful in a variety of\nsettings, including parity objectives in games and both mean-payoff and parity\nobjectives in Markov decision processes.\n  We study window parity objectives in timed automata and timed games: given a\nbound on the window size, a path satisfies such an objective if, in all states\nalong the path, we see a sufficiently small window in which the smallest\npriority is even. We show that checking that all time-divergent paths of a\ntimed automaton satisfy such a window parity objective can be done in\npolynomial space, and that the corresponding timed games can be solved in\nexponential time. This matches the complexity class of timed parity games,\nwhile adding the ability to reason about time bounds. We also consider\nmulti-dimensional objectives and show that the complexity class does not\nincrease. To the best of our knowledge, this is the first study of the window\nmechanism in a real-time setting.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 07:52:50 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Main", "James C. A.", ""], ["Randour", "Mickael", ""], ["Sproston", "Jeremy", ""]]}, {"id": "2105.06723", "submitter": "Amrita Suresh", "authors": "Benedikt Bollig, Alain Finkel, Amrita Suresh", "title": "Bounded Reachability Problems are Decidable in FIFO Machines", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The undecidability of basic decision problems for general FIFO machines such\nas reachability and unboundedness is well-known. In this paper, we provide an\nunderapproximation for the general model by considering only runs that are\ninput-bounded (i.e.\\ the sequence of messages sent through a particular channel\nbelongs to a given bounded language). We prove, by reducing this model to a\ncounter machine with restricted zero tests, that the rational-reachability\nproblem (and by extension, control-state reachability, unboundedness, deadlock,\netc.) is decidable. This class of machines subsumes input-letter-bounded\nmachines, flat machines, linear FIFO nets, and monogeneous machines, for which\nsome of these problems were already shown to be decidable. These theoretical\nresults can form the foundations to build a tool to verify general FIFO\nmachines based on the analysis of input-bounded machines.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 09:13:33 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Bollig", "Benedikt", ""], ["Finkel", "Alain", ""], ["Suresh", "Amrita", ""]]}, {"id": "2105.06767", "submitter": "Ville Salo", "authors": "Johan Kopra and Ville Salo", "title": "Sofically presented dynamical systems", "comments": "56+5 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.DS cs.FL math.GN", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Systems obtained by quotienting a subshift of finite type (SFT) by another\nSFT are called finitely presented in the literature. Analogously, if a sofic\nshift is quotiented by a sofic equivalence relation, we call the resulting\nsystem sofically presented. Generalizing an observation of Fried, for all\ndiscrete countable monoids M, we show that M-subshift/SFT systems are precisely\nthe expansive dynamical M-systems, where S_1/S_2 denotes the class of systems\nobtained by quotienting subshifts in S_1 by (relative) subshifts in S_2. We\nshow that for all finitely generated infinite monoids M, M-SFT \\subsetneq\nM-sofic \\subsetneq M-SFT/SFT = M-sofic/SFT \\subsetneq M-SFT/sofic =\nM-sofic/sofic, and that Ma\\~n\\'e's theorem about the dimension of expansive\nsystems characterizes the virtually cyclic groups.\n  In the case of one-dimensional actions, Ma\\~ne's theorem generalizes to\nsofically presented systems, which also have finite topological dimension. The\nbasis of this is the construction of an explicit metric for a sofically\npresented system. We show that any finite connected simplicial complex is a\nconnected component of a finitely presented system, and prove that conjugacy of\none-dimensional sofically presented dynamical systems is undecidable. A key\nidea is the introduction of so-called automatic spaces. We also study the\nautomorphism groups and periodic points of sofically presented systems.\n  We also perform two case studies. First, in the context of $\\beta$-shifts, we\ndefine the $\\beta$-kernel -- the least subshift relation that identifies $1$\nwith its orbit. We give a classification of the $\\beta$-shift/$\\beta$-kernel\npair as a function of $\\beta$. Second, we revisit the classical study of toral\nautomorphisms in our framework, and in particular for the classical \"golden\nmean\" toral automorphism we explicitly compute the kernel of the standard\npresentation.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 11:24:30 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Kopra", "Johan", ""], ["Salo", "Ville", ""]]}, {"id": "2105.07343", "submitter": "Apurva Badithela", "authors": "Apurva Badithela, Tichakorn Wongpiromsarn, Richard M. Murray", "title": "Leveraging Classification Metrics for Quantitative System-Level Analysis\n  with Temporal Logic Specifications", "comments": "This conference paper has been submitted to the 60th IEEE Conference\n  on Decision and Control (CDC 2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.RO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In many autonomy applications, performance of perception algorithms is\nimportant for effective planning and control. In this paper, we introduce a\nframework for computing the probability of satisfaction of formal system\nspecifications given a confusion matrix, a statistical average performance\nmeasure for multi-class classification. We define the probability of\nsatisfaction of a linear temporal logic formula given a specific initial state\nof the agent and true state of the environment. Then, we present an algorithm\nto construct a Markov chain that represents the system behavior under the\ncomposition of the perception and control components such that the probability\nof the temporal logic formula computed over the Markov chain is consistent with\nthe probability that the temporal logic formula is satisfied by our system. We\nillustrate this approach on a simple example of a car with pedestrian on the\nsidewalk environment, and compute the probability of satisfaction of safety\nrequirements for varying parameters of the vehicle. We also illustrate how\nsatisfaction probability changes with varied precision and recall derived from\nthe confusion matrix. Based on our results, we identify several opportunities\nfor future work in developing quantitative system-level analysis that\nincorporates perception models.\n", "versions": [{"version": "v1", "created": "Sun, 16 May 2021 03:41:32 GMT"}], "update_date": "2021-05-18", "authors_parsed": [["Badithela", "Apurva", ""], ["Wongpiromsarn", "Tichakorn", ""], ["Murray", "Richard M.", ""]]}, {"id": "2105.07470", "submitter": "Stefan Kiefer", "authors": "Emil Indzhev and Stefan Kiefer", "title": "On Complementing Unambiguous Automata and Graphs With Many Cliques and\n  Cocliques", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that for any unambiguous finite automaton with $n$ states there\nexists an unambiguous finite automaton with $\\sqrt{n+1} \\cdot 2^{n/2}$ states\nthat recognizes the complement language. This builds and improves upon a\nsimilar result by Jir\\'asek et al. [Int. J. Found. Comput. Sci. 29 (5) (2018)].\nOur improvement is based on a reduction to and an analysis of a problem from\nextremal graph theory: we show that for any graph with $n$ vertices, the\nproduct of the number of its cliques with the number of its cocliques\n(independent sets) is bounded by $(n+1) 2^n$.\n", "versions": [{"version": "v1", "created": "Sun, 16 May 2021 16:24:07 GMT"}], "update_date": "2021-05-18", "authors_parsed": [["Indzhev", "Emil", ""], ["Kiefer", "Stefan", ""]]}, {"id": "2105.08358", "submitter": "Pierre Pradic", "authors": "L\\^e Th\\`anh D\\~ung Nguy\\^en (UP13), Camille No\\^us, Pierre Pradic", "title": "Comparison-free polyregular functions", "comments": null, "journal-ref": "International Colloquium on Automata, Languages and Programming\n  2021, Jul 2021, Glasgow, United Kingdom", "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study automata-theoretic classes of string-to-string functions whose\noutput may grow faster than linearly in their input. Our central contribution\nis to introduce a new such class, with polynomial growth and three equivalent\ndefinitions: the smallest class containing regular functions and closed under a\n\"composition by substitution\" operation; a restricted variant of pebble\ntransducers; a $\\lambda$-calculus with a linear type system. As their name\nsuggests, these comparison-free polyregular functions form a subclass of\npolyregular functions; we prove that the inclusion is strict. Other properties\nof our new function class that we show are incomparability with HDT0L\ntransductions and closure under composition. Finally, we look at the recently\nintroduced layered streaming string transducers (SSTs), or equivalently\nk-marble transducers. We prove that a function can be obtained by composing\nsuch transducers together if and only if it is polyregular, and that k-layered\nSSTs (or k-marble transducers) are equivalent to a corresponding notion of\n(k+1)-layered HDT0L systems.\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 08:33:35 GMT"}], "update_date": "2021-05-19", "authors_parsed": [["Nguy\u00ean", "L\u00ea Th\u00e0nh D\u0169ng", "", "UP13"], ["No\u00fbs", "Camille", ""], ["Pradic", "Pierre", ""]]}, {"id": "2105.08496", "submitter": "Shunsuke Inenaga", "authors": "Tooru Akagi, Yuki Kuhara, Takuya Mieno, Yuto Nakashima, Shunsuke\n  Inenaga, Hideo Bannai, Masayuki Takeda", "title": "Combinatorics of minimal absent words for a sliding window", "comments": "A part of the results of this article appeared in Proc. SOFSEM 2020.\n  arXiv admin note: text overlap with arXiv:1909.02804", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A string $w$ is called a minimal absent word (MAW) for another string $T$ if\n$w$ does not occur in $T$ but the proper substrings of $w$ occur in $T$. For\nexample, let $\\Sigma = \\{\\mathtt{a, b, c}\\}$ be the alphabet. Then, the set of\nMAWs for string $w = \\mathtt{abaab}$ is $\\{\\mathtt{aaa, aaba, bab, bb, c}\\}$.\nIn this paper, we study combinatorial properties of MAWs in the sliding window\nmodel, namely, how the set of MAWs changes when a sliding window of fixed\nlength $d$ is shifted over the input string $T$ of length $n$, where $1 \\leq d\n< n$. We present \\emph{tight} upper and lower bounds on the maximum number of\nchanges in the set of MAWs for a sliding window over $T$, both in the cases of\ngeneral alphabets and binary alphabets. Our bounds improve on the previously\nknown best bounds [Crochemore et al., 2020].\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 13:15:44 GMT"}], "update_date": "2021-05-19", "authors_parsed": [["Akagi", "Tooru", ""], ["Kuhara", "Yuki", ""], ["Mieno", "Takuya", ""], ["Nakashima", "Yuto", ""], ["Inenaga", "Shunsuke", ""], ["Bannai", "Hideo", ""], ["Takeda", "Masayuki", ""]]}, {"id": "2105.08551", "submitter": "S{\\l}awomir Lasota", "authors": "S{\\l}awomir Lasota", "title": "Improved Ackermannian lower bound for the Petri nets reachability\n  problem", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Petri nets, equivalently presentable as vector addition systems with states,\nare an established model of concurrency with widespread applications. The\nreachability problem, where we ask whether from a given initial configuration\nthere exists a sequence of valid execution steps reaching a given final\nconfiguration, is the central algorithmic problem for this model. The\ncomplexity of the problem has remained, until recently, one of the hardest open\nquestions in verification of concurrent systems. A first upper bound has been\nprovided only in 2015 by Leroux and Schmitz, then refined by the same authors\nto non-primitive recursive Ackermannian upper bound in 2019. The exponential\nspace lower bound, shown by Lipton already in 1976, remained the only known for\nover 40 years until a breakthrough non-elementary lower bound by\nCzerwi{\\'n}ski, Lasota, Lazic, Leroux and Mazowiecki in 2019. Finally, a\nmatching Ackermannian lower bound announced this year by Czerwi{\\'n}ski and\nOrlikowski, and independently by Leroux, established the complexity of the\nproblem.\n  Our contribution is an improvement of the former construction, making it\nconceptually simpler and more direct. On the way we improve the lower bound for\nvector addition systems with states in fixed dimension (or, equivalently, Petri\nnets with fixed number of places): while Czerwi{\\'n}ski and Orlikowski prove\n$F_k$-hardness (hardness for $k$th level in Grzegorczyk Hierarchy) in dimension\n$6k$, and Leroux in dimension $4k+5$, our simplified construction yields\n$F_k$-hardness already in dimension $3k+2$.\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 14:36:25 GMT"}, {"version": "v2", "created": "Mon, 5 Jul 2021 08:18:02 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["Lasota", "S\u0142awomir", ""]]}, {"id": "2105.08880", "submitter": "Dmitri Piontkovski", "authors": "Andrey T. Cherkasov and Dmitri Piontkovski", "title": "Wilf classes of non-symmetric operads", "comments": "8 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL cs.SC math.AT math.RA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two operads are said to belong to the same Wilf class if they have the same\ngenerating series. We discuss possible Wilf classifications of non-symmetric\noperads with monomial relations. As a corollary, this would give the same\nclassification for the operads with a finite Groebner basis.\n  Generally, there is no algorithm to decide whether two finitely presented\noperads belong to the same Wilf class. Still, we show that if an operad has a\nfinite Groebner basis, then the monomial basis of the operad forms an\nunambiguous context-free language. Moreover, we discuss the deterministic\ngrammar which defines the language. The generating series of the operad can be\nobtained as a result of an algorithmic elimination of variables from the\nalgebraic system of equations defined by the Chomsky--Schutzenberger\nenumeration theorem. We then focus on the case of binary operads with a single\nrelation. The approach is based on the results by Rowland on pattern avoidance\nin binary trees. We improve and refine Rowland's calculations and empirically\nconfirm his conjecture. Here we use both the algebraic elimination and the\ndirect calculation of formal power series from algebraic systems of equations.\nFinally, we discuss the connection of Wilf classes with algorithms for the\nQuillen homology of operads calculation.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 01:57:12 GMT"}], "update_date": "2021-05-20", "authors_parsed": [["Cherkasov", "Andrey T.", ""], ["Piontkovski", "Dmitri", ""]]}, {"id": "2105.09105", "submitter": "Avraham N. Trahtman", "authors": "A.N. Trahtman", "title": "The \\v{C}erny Conjecture for aperiodic automata", "comments": "8 pages, DMTCS conference 2007", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A word w is called a synchronizing (recurrent, reset) word of a deterministic\nfinite automaton (DFA) if w brings all states of the automaton to some state; a\nDFA that has a synchronizing word is said to be synchronizing. Cerny\nconjectured in 1964 that every n-state synchronizing DFA possesses a\nsynchronizing word of length at most (n -1)2. We consider automaton with\naperiodic transition monoid (such automaton is called aperiodic). We show that\nevery synchronizing n-state aperiodic automaton has a synchronizing word of\nlength at most n(n-2)+1. Thus, for aperiodic automaton as well as for\nautomatons accepting only star-free languages, the Cerny conjecture holds true.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 12:56:49 GMT"}], "update_date": "2021-05-20", "authors_parsed": [["Trahtman", "A. N.", ""]]}, {"id": "2105.09291", "submitter": "Viktor Henriksson", "authors": "Viktor Henriksson, Manfred Kufleitner", "title": "Deciding FO2 Alternation for Automata over Finite and Infinite Words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We consider two-variable first-order logic $\\text{FO}^2$ and its quantifier\nalternation hierarchies over both finite and infinite words. Our main results\nare forbidden patterns for deterministic automata (finite words) and for\nCarton-Michel automata (infinite words). In order to give concise patterns, we\nallow the use of subwords on paths in finite graphs. This concept is formalized\nas subword patterns. Deciding the presence or absence of such a pattern in a\ngiven automaton is in $\\mathbf{NL}$. In particular, this leads to $\\mathbf{NL}$\nalgorithms for deciding the levels of the $\\text{FO}^2$ quantifier alternation\nhierarchies. This applies to both full and half levels, each over finite and\ninfinite words. Moreover, we show that these problems are $\\mathbf{NL}$-hard\nand, hence, $\\mathbf{NL}$-complete.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 17:51:00 GMT"}, {"version": "v2", "created": "Sat, 5 Jun 2021 09:18:24 GMT"}], "update_date": "2021-06-08", "authors_parsed": [["Henriksson", "Viktor", ""], ["Kufleitner", "Manfred", ""]]}, {"id": "2105.09346", "submitter": "Viktor Henriksson", "authors": "Viktor Henriksson, Manfred Kufleitner", "title": "Conelikes and Ranker Comparisons", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  For every fixed class of regular languages, there is a natural hierarchy of\nincreasingly more general problems: Firstly, the membership problem asks\nwhether a given language belongs to the fixed class of languages. Secondly, the\nseparation problem asks for two given languages whether they can be separated\nby a language from the fixed class. And thirdly, the covering problem is a\ngeneralization of separation problem to more than two given languages. Most\ninstances of such problems were solved by the connection of regular languages\nand finite monoids. Both the membership problem and the separation problem were\nalso extended to ordered monoids. The computation of pointlikes can be\ninterpreted as the algebraic counterpart of the covering problem. In this\npaper, we extend the computation of pointlikes to ordered monoids. This leads\nto the notion of conelikes for the corresponding algebraic framework.\n  We apply this framework to the Trotter-Weil hierarchy and both the full and\nthe half levels of the $\\text{FO}^2$ quantifier alternation hierarchy. As a\nconsequence, we solve the covering problem for the resulting subvarieties of\n$\\mathbf{DA}$. An important combinatorial tool are uniform ranker\ncharacterizations for all subvarieties under consideration; these\ncharacterizations stem from order comparisons of ranker positions.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 18:18:09 GMT"}], "update_date": "2021-05-21", "authors_parsed": [["Henriksson", "Viktor", ""], ["Kufleitner", "Manfred", ""]]}, {"id": "2105.09368", "submitter": "Dhruv Nevatia", "authors": "Amaldev Manuel and Dhruv Nevatia", "title": "An Algebraic Characterisation of First-Order Logic with Neighbour", "comments": "13 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We give an algebraic characterisation of first-order logic with the neighbour\nrelation, on finite words. For this, we consider languages of finite words over\nalphabets with an involution on them. The natural algebras for such languages\nare involution semigroups. To characterise the logic, we define a special kind\nof semidirect product of involution semigroups, called the locally hermitian\nproduct. The characterisation theorem for FO with neighbour states that a\nlanguage is definable in the logic if and only if it is recognised by a locally\nhermitian product of an aperiodic commutative involution semigroup, and a\nlocally trivial involution semigroup. We then define the notion of involution\nvarieties of languages, namely classes of languages closed under Boolean\noperations, quotients, involution, and inverse images of involutory morphisms.\nAn Eilenberg-type correspondence is established between involution varieties of\nlanguages and pseudovarieties of involution semigroups.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 19:19:35 GMT"}], "update_date": "2021-05-21", "authors_parsed": [["Manuel", "Amaldev", ""], ["Nevatia", "Dhruv", ""]]}, {"id": "2105.09970", "submitter": "Martin Beaudry", "authors": "Martin Beaudry", "title": "Forest languages defined by counting maximal paths", "comments": "The proof of the main Lemma (3.11, section 3.4) is incomplete: in the\n  middle of page 22, the fact that $\\gamma$ is weakly distributive is not\n  sufficient to justify the chain of two inclusions used to invoke Proposition\n  2.1", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  A leaf path language is a Boolean combination of sets of the form\n$\\mathsf{{}^mE}^k L$, with $k \\ge 1$ and $L$ a regular word language, which\nconsist of those forests where the node labels in at least $k$ leaf-to-root\npaths make up a word that belongs to $L$. We look at the class $\\mathsf{*D}$ of\nthe languages recognized by iterated wreath products of syntactic algebras of\nleaf path languages. We prove the existence of an algorithm that, given a\nregular forest language, returns in finite time a sequence of such algebras;\ntheir wreath product is divided by the language's syntactic algebra if, and\nonly if this language belongs to $\\mathsf{*D}$, which makes membership in this\nclass a decidable question. The result also applies to the subclasses\n$\\mathsf{PDL}$ and $\\mathsf{CTL^*}$.\n", "versions": [{"version": "v1", "created": "Thu, 20 May 2021 18:04:38 GMT"}, {"version": "v2", "created": "Sun, 13 Jun 2021 18:50:13 GMT"}], "update_date": "2021-06-15", "authors_parsed": [["Beaudry", "Martin", ""]]}, {"id": "2105.09978", "submitter": "Ayrat Khalimov", "authors": "Ayrat Khalimov, Emmanuel Filiot, L\\'eo Exibard", "title": "Transducer Synthesis from Universal Register Automata in (N,>)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper concerns the problem of reactive synthesis of systems interacting\nwith its environment via letters from an infinite data domain. Register\nautomata and transducers are popular formalisms for specifying and modeling\nsuch systems. They extend finite-state automata by introducing registers that\nare used to store data and to test incoming data against the stored one. Unlike\nthe standard automata, the expressive power of register automata depends on\nwhether they are deterministic, non-deterministic, or universal. Among these,\nuniversal register automata suit synthesis best as they can specify\nrequest-grant properties and allow for succinct conjunction. Because the\nsynthesis problem from universal register automata is undecidable, researchers\nstudied a decidable variant, called register-bounded synthesis, where\nadditionally a bound on the number of registers in a sought transducer is\ngiven. In those synthesis works, however, automata can only compare data for\nequality, which limits synthesis applications. In this paper, we extend\nregister-bounded synthesis to domains with the natural order <. To this end, we\nprove a key Pumping Lemma for a finite abstraction of behaviour of register\nautomata, which allows us to reduce synthesis to synthesis of register-free\ntransducers. As a result, we show that register-bounded synthesis from\nuniversal register automata over domain (N, <) is decidable in 2ExpTime as in\nthe equality-only case, giving the order for free.\n", "versions": [{"version": "v1", "created": "Thu, 20 May 2021 18:21:21 GMT"}], "update_date": "2021-05-24", "authors_parsed": [["Khalimov", "Ayrat", ""], ["Filiot", "Emmanuel", ""], ["Exibard", "L\u00e9o", ""]]}, {"id": "2105.10292", "submitter": "Alberto Larrauri", "authors": "Alberto Larrauri, Roderick Bloem", "title": "Minimization and Synthesis of the Tail inSequential Compositions of\n  Mealy Machines", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We consider a system consisting of a sequential composition of Mealy\nmachines, called head and tail. We study two problems related to these systems.\nFirst, models of both head and tail components are available, and the aim is to\nobtain a replacement for the tail with the minimum number of states. We\nintroduce a minimization method for this context which yields an exponential\nimprovement over the state of the art. In the second problem, only the head is\nknown and a desired model for the whole system is given. The objective is to\nconstruct a tail that causes the system to behave according to the given model.\nWe give a polynomial time algorithm that computes whether such a tail exists,\nwhereas methods developed for general unknown component equations take\nexponential time. However, we also show that there are instances of the problem\nwhere the size of the tail is bounded from bellow by an exponential function in\nthe sizes of the head and the desired system. This shows that the complexity of\nthe synthesis procedure is at least exponential, matching the upper bound in\ncomplexity provided by the existing methods.\n", "versions": [{"version": "v1", "created": "Fri, 21 May 2021 11:47:25 GMT"}], "update_date": "2021-05-24", "authors_parsed": [["Larrauri", "Alberto", ""], ["Bloem", "Roderick", ""]]}, {"id": "2105.10293", "submitter": "Paul Bell", "authors": "Paul C. Bell and Pavel Semukhin", "title": "Decision Questions for Probabilistic Automata on Small Alphabets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the emptiness and $\\lambda$-reachability problems for unary and\nbinary Probabilistic Finite Automata (PFA) and characterise the complexity of\nthese problems in terms of the degree of ambiguity of the automaton and the\nsize of its alphabet. Our main result is that emptiness and\n$\\lambda$-reachability are solvable in EXPTIME for polynomially ambiguous unary\nPFA and if, in addition, the transition matrix is over $\\{0, 1\\}$, we show they\nare in NP. In contrast to the Skolem-hardness of the $\\lambda$-reachability and\nemptiness problems for exponentially ambiguous unary PFA, we show that these\nproblems are NP-hard even for finitely ambiguous unary PFA. For binary\npolynomially ambiguous PFA with fixed and commuting transition matrices, we\nprove NP-hardness of the $\\lambda$-reachability (dimension $9$), nonstrict\nemptiness (dimension $37$) and strict emptiness (dimension $40$) problems.\n", "versions": [{"version": "v1", "created": "Fri, 21 May 2021 11:49:27 GMT"}], "update_date": "2021-05-24", "authors_parsed": [["Bell", "Paul C.", ""], ["Semukhin", "Pavel", ""]]}, {"id": "2105.10654", "submitter": "Avraham N. Trahtman", "authors": "A.N. Trahtman", "title": "An algorithm to verify local threshold testability of deterministic\n  finite automata", "comments": "8 pages, 6 figures, PTSD conference, Lecture notes of computer\n  science", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A locally threshold testable language L is a language with the property that\nfor some non negative integers k and l, whether or not a word u is in the\nlanguage L depends on (1) the prefix and suffix of the word u of length k > 1\nand (2) the set of intermediate substrings of length k of the word u where the\nsets of substrings occurring at least j times are the same, for j <= L. For\ngiven k and L the language is called l-threshold k-testable. A finite\ndeterministic automaton is called l-threshold k-testable if the automaton\naccepts a l-threshold k-testable language. In this paper, the necessary and\nsufficient conditions for an automaton to be locally threshold testable are\nfound. We introduce the first polynomial time algorithm to verify local\nthreshold testability of the automaton based on this characterization. New\nversion of polynomial time algorithm to verify the local testability will be\npresented too.\n", "versions": [{"version": "v1", "created": "Sat, 22 May 2021 07:10:52 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Trahtman", "A. N.", ""]]}, {"id": "2105.10668", "submitter": "Ruggero Lanotte Dr", "authors": "Ruggero Lanotte, Massimo Merro, Andrei Munteanu", "title": "Runtime Enforcement of Programmable Logic Controllers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  With the advent of Industry 4.0, industrial facilities and critical\ninfrastructures are transforming into an ecosystem of heterogeneous physical\nand cyber components, such as programmable logic controllers, increasingly\ninterconnected and therefore exposed to cyber-physical attacks, i.e., security\nbreaches in cyberspace that may adversely affect the physical processes\nunderlying industrial control systems. In this paper, we propose a formal\napproach} based on runtime enforcement to ensure specification compliance in\nnetworks of controllers, possibly compromised by colluding malware that may\ntamper with actuator commands, sensor readings, and inter-controller\ncommunications. Our approach relies on an ad-hoc sub-class of Ligatti et al.'s\nedit automata to enforce controllers represented in Hennessy and Regan's Timed\nProcess Language. We define a synthesis algorithm that, given an alphabet $P$\nof observable actions and a regular timed correctness property $e$, returns a\nmonitor that enforces the property $e$ during the execution of any (potentially\ncorrupted) controller with alphabet $P$, and complying with the property $e$.\nOur monitors correct and suppress incorrect actions coming from corrupted\ncontrollers and emit actions in full autonomy when the controller under\nscrutiny is not able to do so in a correct manner. Besides classical\nrequirements, such as transparency and soundness, the proposed enforcement\nenjoys deadlock- and diverge-freedom of monitored controllers, together with\nscalability when dealing with networks of controllers. Finally, we test the\nproposed enforcement mechanism on a non-trivial case study, taken from the\ncontext of industrial water treatment systems, in which the controllers are\ninjected with different malware with different malicious goals.\n", "versions": [{"version": "v1", "created": "Sat, 22 May 2021 09:03:28 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Lanotte", "Ruggero", ""], ["Merro", "Massimo", ""], ["Munteanu", "Andrei", ""]]}, {"id": "2105.10897", "submitter": "Saptarshi Sarkar", "authors": "Bharat Adsul, Paul Gastin, Saptarshi Sarkar, Pascal Weil", "title": "Asynchronous wreath product and cascade decompositions for concurrent\n  behaviours", "comments": "The results in this paper are an elaboration and an extension of our\n  CONCUR 2020 paper(doi={10.4230/LIPIcs.CONCUR.2020.19}, see\n  https://drops.dagstuhl.de/opus/volltexte/2020/12831/ ), and its extended\n  version at arxiv:2007.07940 . It includes new significant technical results\n  and is a considerable improvement and reorganization of the conference paper\n  as well as its extended version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop new algebraic tools to reason about concurrent behaviours modelled\nas languages of Mazurkiewicz traces and asynchronous automata. These tools\nreflect the distributed nature of traces and the underlying causality and\nconcurrency between events, and can be said to support true concurrency. They\ngeneralize the tools that have been so efficient in understanding, classifying\nand reasoning about word languages. In particular, we introduce an asynchronous\nversion of the wreath product operation and we describe the trace languages\nrecognized by such products (the so-called asynchronous wreath product\nprinciple). We then propose a decomposition result for recognizable trace\nlanguages, analogous to the Krohn-Rhodes theorem, and we prove this\ndecomposition result in the special case of acyclic architectures. Finally, we\nintroduce and analyze two distributed automata-theoretic operations. One, the\nlocal cascade product, is a direct implementation of the asynchronous wreath\nproduct operation. The other, global cascade sequences, although conceptually\nand operationally similar to the local cascade product, translates to a more\ncomplex asynchronous implementation which uses the gossip automaton of Mukund\nand Sohoni. This leads to interesting applications to the characterization of\ntrace languages definable in first-order logic: they are accepted by a\nrestricted local cascade product of the gossip automaton and 2-state\nasynchronous reset automata, and also by a global cascade sequence of 2-state\nasynchronous reset automata. Over distributed alphabets for which the\nasynchronous Krohn-Rhodes theorem holds, a local cascade product of such\nautomata is sufficient and this, in turn, leads to the identification of a\nsimple temporal logic which is expressively complete for such alphabets.\n", "versions": [{"version": "v1", "created": "Sun, 23 May 2021 09:47:26 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Adsul", "Bharat", ""], ["Gastin", "Paul", ""], ["Sarkar", "Saptarshi", ""], ["Weil", "Pascal", ""]]}, {"id": "2105.11115", "submitter": "Shunyu Yao", "authors": "Shunyu Yao, Binghui Peng, Christos Papadimitriou, Karthik Narasimhan", "title": "Self-Attention Networks Can Process Bounded Hierarchical Languages", "comments": "ACL 2021. 19 pages with extended appendix. Code:\n  https://github.com/princeton-nlp/dyck-transformer", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CL cs.AI cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Despite their impressive performance in NLP, self-attention networks were\nrecently proved to be limited for processing formal languages with hierarchical\nstructure, such as $\\mathsf{Dyck}_k$, the language consisting of well-nested\nparentheses of $k$ types. This suggested that natural language can be\napproximated well with models that are too weak for formal languages, or that\nthe role of hierarchy and recursion in natural language might be limited. We\nqualify this implication by proving that self-attention networks can process\n$\\mathsf{Dyck}_{k, D}$, the subset of $\\mathsf{Dyck}_{k}$ with depth bounded by\n$D$, which arguably better captures the bounded hierarchical structure of\nnatural language. Specifically, we construct a hard-attention network with\n$D+1$ layers and $O(\\log k)$ memory size (per token per layer) that recognizes\n$\\mathsf{Dyck}_{k, D}$, and a soft-attention network with two layers and\n$O(\\log k)$ memory size that generates $\\mathsf{Dyck}_{k, D}$. Experiments show\nthat self-attention networks trained on $\\mathsf{Dyck}_{k, D}$ generalize to\nlonger inputs with near-perfect accuracy, and also verify the theoretical\nmemory advantage of self-attention networks over recurrent networks.\n", "versions": [{"version": "v1", "created": "Mon, 24 May 2021 06:42:58 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Yao", "Shunyu", ""], ["Peng", "Binghui", ""], ["Papadimitriou", "Christos", ""], ["Narasimhan", "Karthik", ""]]}, {"id": "2105.11508", "submitter": "Erfan Aasi", "authors": "Erfan Aasi, Cristian Ioan Vasile, Mahroo Bahreinian, Calin Belta", "title": "Inferring Temporal Logic Properties from Data using Boosted Decision\n  Trees", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.RO cs.FL cs.LG", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Many autonomous systems, such as robots and self-driving cars, involve\nreal-time decision making in complex environments, and require prediction of\nfuture outcomes from limited data. Moreover, their decisions are increasingly\nrequired to be interpretable to humans for safe and trustworthy co-existence.\nThis paper is a first step towards interpretable learning-based robot control.\nWe introduce a novel learning problem, called incremental formula and predictor\nlearning, to generate binary classifiers with temporal logic structure from\ntime-series data. The classifiers are represented as pairs of Signal Temporal\nLogic (STL) formulae and predictors for their satisfaction. The incremental\nproperty provides prediction of labels for prefix signals that are revealed\nover time. We propose a boosted decision-tree algorithm that leverages weak,\nbut computationally inexpensive, learners to increase prediction and runtime\nperformance. The effectiveness and classification accuracy of our algorithms\nare evaluated on autonomous-driving and naval surveillance case studies.\n", "versions": [{"version": "v1", "created": "Mon, 24 May 2021 19:29:02 GMT"}], "update_date": "2021-05-26", "authors_parsed": [["Aasi", "Erfan", ""], ["Vasile", "Cristian Ioan", ""], ["Bahreinian", "Mahroo", ""], ["Belta", "Calin", ""]]}, {"id": "2105.11898", "submitter": "Jana Lep\\v{s}ov\\'a", "authors": "S\\'ebastien Labb\\'e and Jana Lep\\v{s}ov\\'a", "title": "A Numeration System for Fibonacci-like Wang Shifts", "comments": "17 pages, 5 figures, submitted to WORDS 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Motivated by the study of Fibonacci-like Wang shifts, we define a numeration\nsystem for $\\mathbb{Z}$ and $\\mathbb{Z}^2$ based on the binary alphabet\n$\\{0,1\\}$. We introduce a set of 16 Wang tiles that admits a valid tiling of\nthe plane described by a deterministic finite automaton taking as input the\nrepresentation of a position $(m,n)\\in\\mathbb{Z}^2$ and outputting a Wang tile.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2021 13:12:16 GMT"}, {"version": "v2", "created": "Tue, 6 Jul 2021 13:15:44 GMT"}], "update_date": "2021-07-07", "authors_parsed": [["Labb\u00e9", "S\u00e9bastien", ""], ["Lep\u0161ov\u00e1", "Jana", ""]]}, {"id": "2105.11911", "submitter": "Swantje Plambeck", "authors": "Swantje Plambeck and Jakob Schyga and Johannes Hinckeldeyn and Jochen\n  Kreutzfeldt and G\\\"orschwin Fey", "title": "Automata Learning for Automated Test Generation of Real Time\n  Localization Systems", "comments": "4 pages, 2 figures, included in the proceedings of the LEAC 2021\n  workshop", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Cyber Physical Systems (CPSs) are often black box systems for which no exact\nmodel exists. Automata learning allows to build abstract models of CPSs and is\nused in several scenarios, i.e. simulation, monitoring, and test case\ngeneration. Real time localization systems (RTLSs) are an example of\nparticularly complex and often safety critical CPSs. We present a procedure for\nautomatic test case generation with automata learning and apply this approach\nin a case study to a localization system.\n", "versions": [{"version": "v1", "created": "Fri, 21 May 2021 09:30:53 GMT"}], "update_date": "2021-05-26", "authors_parsed": [["Plambeck", "Swantje", ""], ["Schyga", "Jakob", ""], ["Hinckeldeyn", "Johannes", ""], ["Kreutzfeldt", "Jochen", ""], ["Fey", "G\u00f6rschwin", ""]]}, {"id": "2105.12009", "submitter": "Antonio Casares", "authors": "Antonio Casares", "title": "On the Minimisation of Transition-Based Rabin Automata and the Chromatic\n  Memory Requirements of Muller Conditions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper, we relate the problem of determining the chromatic memory\nrequirements of Muller conditions with the minimisation of transition-based\nRabin automata. Our first contribution is a proof of the NP-completeness of the\nminimisation of transition-based Rabin automata. Our second contribution\nconcerns the memory requirements of games over graphs using Muller conditions.\nA memory structure is a finite state machine that implements a strategy and is\nupdated after reading the edges of the game; the special case of chromatic\nmemories being those structures whose update function only consider the colours\nof the edges. We prove that the minimal amount of chromatic memory required in\ngames using a given Muller condition is exactly the size of a minimal Rabin\nautomaton recognising this condition. Combining these two results, we deduce\nthat finding the chromatic memory requirements of a Muller condition is\nNP-complete. This characterisation also allows us to prove that chromatic\nmemories cannot be optimal in general, disproving a conjecture by Kopczy\\'nski.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2021 15:22:51 GMT"}, {"version": "v2", "created": "Fri, 9 Jul 2021 17:12:28 GMT"}], "update_date": "2021-07-12", "authors_parsed": [["Casares", "Antonio", ""]]}, {"id": "2105.12125", "submitter": "James Mitchell", "authors": "James D. Mitchell and Maria Tsalakou", "title": "An explicit algorithm for normal forms in small overlap monoids", "comments": "17 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DS math.RA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  If $\\mathcal{P} = \\left\\langle A \\, | \\,R \\right\\rangle$ is a monoid\npresentation, then the relation words in $\\mathcal{P}$ are just the set of\nwords on the left or right hand side of any pair in $R$. A word $w\\in A ^*$ is\nsaid to be a piece of $\\mathcal{P}$ if $w$ is a factor of at least two distinct\nrelation words, or $w$ occurs more than once as a factor of a single relation\nword (possibly overlapping). A finitely presented monoid is a small overlap\nmonoid if no relation word can be written as a product of fewer than $4$\npieces. In this paper, we present a quadratic time algorithm for computing\nnormal forms of words in small overlap monoids where the coefficients are\nsufficiently small to allow for practical computation. Additionally, we show\nthat the uniform word problem for small overlap monoids can be solved in linear\ntime.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2021 13:40:14 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Mitchell", "James D.", ""], ["Tsalakou", "Maria", ""]]}, {"id": "2105.12185", "submitter": "Deacon Linkhorn", "authors": "Deacon Linkhorn", "title": "The Pseudofinite Monadic Second Order Theory of Linear Order", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Monadic second order logic is the expansion of first order logic by\nquantifiers ranging over unary relations. We study the shared monadic second\norder theory of finite linear orders, i.e. the pseudofinite monadic second\norder theory of linear order, using a first order setup . We give explicit (and\nrecursive) axioms and characterise the completions in terms of residue\nsequences. A connection with profinite algebra, in particular with the free\nprofinite monoid on one generator, is established via extended Stone duality.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2021 19:39:18 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Linkhorn", "Deacon", ""]]}, {"id": "2105.12583", "submitter": "Avraham N. Trahtman", "authors": "A.N.Trahtman", "title": "A package TESTAS for checking some kinds of testability", "comments": "5 pages, Lecture Notes in Computer Science 2608(2003), 228-232", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We implement a set of procedures for deciding whether or not a language given\nby its minimal automaton or by its syntactic semigroup is locally testable,\nright or left locally testable, threshold locally testable, strictly locally\ntestable, or piecewise testable. The bounds on order of local testability of\ntransition graph and order of local testability of transition semigroup are\nalso found. For given k, the k-testability of transition graph is verified.\nSome new effective polynomial time algorithms are used. These algorithms have\nbeen implemented as a C/C++ package.\n", "versions": [{"version": "v1", "created": "Wed, 26 May 2021 14:36:55 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Trahtman", "A. N.", ""]]}, {"id": "2105.13683", "submitter": "S. Akshay", "authors": "S. Akshay, Paul Gastin and Karthik R Prakash", "title": "Fast zone-based algorithms for reachability in pushdown timed automata", "comments": "Long version of conference paper accepted at CAV'2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Given the versatility of timed automata a huge body of work has evolved that\nconsiders extensions of timed automata. One extension that has received a lot\nof interest is timed automata with a, possibly unbounded, stack, also called\nthe pushdown timed automata (PDTA) model. While different algorithms have been\ngiven for reachability in different variants of this model, most of these\nresults are purely theoretical and do not give rise to efficient\nimplementations. One main reason for this is that none of these algorithms (and\nthe implementations that exist) use the so-called zone-based abstraction, but\nrely either on the region-abstraction or other approaches, which are\nsignificantly harder to implement.\n  In this paper, we show that a naive extension of the zone based reachability\nalgorithm for the control state reachability problem of timed automata is not\nsound in the presence of a stack. To understand this better we give an\ninductive rule based view of the zone reachability algorithm for timed\nautomata. This alternate view allows us to analyze and adapt the rules to also\nwork for pushdown timed automata. We obtain the first zone-based algorithm for\nPDTA which is terminating, sound and complete. We implement our algorithm in\nthe tool TChecker and perform experiments to show its efficacy, thus leading\nthe way for more practical approaches to the verification of pushdown timed\nsystems.\n", "versions": [{"version": "v1", "created": "Fri, 28 May 2021 09:07:12 GMT"}, {"version": "v2", "created": "Mon, 19 Jul 2021 09:46:48 GMT"}], "update_date": "2021-07-20", "authors_parsed": [["Akshay", "S.", ""], ["Gastin", "Paul", ""], ["Prakash", "Karthik R", ""]]}, {"id": "2105.13837", "submitter": "Dror Fried", "authors": "Gal Amram and Suguman Bansal and Dror Fried and Lucas M. Tabajara and\n  Moshe Y. Vardi and Gera Weiss", "title": "Adapting Behaviors via Reactive Synthesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In the \\emph{Adapter Design Pattern}, a programmer implements a \\emph{Target}\ninterface by constructing an \\emph{Adapter} that accesses an existing\n\\emph{Adaptee} code. In this work, we present a reactive synthesis\ninterpretation to the adapter design pattern, wherein an algorithm takes an\n\\emph{Adaptee} and a \\emph{Target} transducers, and the aim is to synthesize an\n\\emph{Adapter} transducer that, when composed with the {\\em Adaptee}, generates\na behavior that is equivalent to the behavior of the {\\em Target}. One use of\nsuch an algorithm is to synthesize controllers that achieve similar goals on\ndifferent hardware platforms. While this problem can be solved with existing\nsynthesis algorithms, current state-of-the-art tools fail to scale. To cope\nwith the computational complexity of the problem, we introduce a special form\nof specification format, called {\\em Separated GR($k$)}, which can be solved\nwith a scalable synthesis algorithm but still allows for a large set of\nrealistic specifications. We solve the realizability and the synthesis problems\nfor Separated GR($k$), and show how to exploit the separated nature of our\nspecification to construct better algorithms, in terms of time complexity, than\nknown algorithms for GR($k$) synthesis. We then describe a tool, called\nSGR($k$), that we have implemented based on the above approach and show, by\nexperimental evaluation, how our tool outperforms current state-of-the-art\ntools on various benchmarks and test-cases.\n", "versions": [{"version": "v1", "created": "Fri, 28 May 2021 13:50:55 GMT"}], "update_date": "2021-05-31", "authors_parsed": [["Amram", "Gal", ""], ["Bansal", "Suguman", ""], ["Fried", "Dror", ""], ["Tabajara", "Lucas M.", ""], ["Vardi", "Moshe Y.", ""], ["Weiss", "Gera", ""]]}, {"id": "2105.14579", "submitter": "Francesco Ranzato", "authors": "Paolo Baldan and Francesco Ranzato and Linpeng Zhang", "title": "A Rice's Theorem for Abstract Semantics", "comments": "Full version of a conference paper presented at the 48th\n  International Colloquium on Automata, Languages, and Programming (ICALP 2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Classical results in computability theory, notably Rice's theorem, focus on\nthe extensional content of programs, namely, on the partial recursive functions\nthat programs compute. Later and more recent work investigated intensional\ngeneralisations of such results that take into account the way in which\nfunctions are computed, thus affected by the specific programs computing them.\nIn this paper, we single out a novel class of program semantics based on\nabstract domains of program properties that are able to capture nonextensional\naspects of program computations, such as their asymptotic complexity or logical\ninvariants, and allow us to generalise some foundational computability results\nsuch as Rice's Theorem and Kleene's Second Recursion Theorem to these\nsemantics. In particular, it turns out that for this class of abstract program\nsemantics, any nontrivial abstract property is undecidable and every decidable\noverapproximation necessarily includes an infinite set of false positives which\ncovers all values of the semantic abstract domain.\n", "versions": [{"version": "v1", "created": "Sun, 30 May 2021 16:39:55 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Baldan", "Paolo", ""], ["Ranzato", "Francesco", ""], ["Zhang", "Linpeng", ""]]}, {"id": "2105.14707", "submitter": "Felipe S. Abrah\\~ao", "authors": "Felipe S. Abrah\\~ao, Hector Zenil", "title": "Emergence and algorithmic information dynamics of systems and observers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.IT cs.FL cs.MA cs.SY eess.SY math.DS math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Previous work has shown that perturbation analysis in software space can\nproduce candidate computable generative models and uncover possible causal\nproperties from the finite description of an object or system quantifying the\nalgorithmic contribution of each of its elements relative to the whole. One of\nthe challenges for defining emergence is that one observer's prior knowledge\nmay cause a phenomenon to present itself to such observer as emergent while for\nanother as reducible. When attempting to quantify emergence, we demonstrate\nthat the methods of Algorithmic Information Dynamics can deal with the richness\nof such observer-object dependencies both in theory and practice. By\nformalising the act of observing as mutual algorithmic perturbation, the\nemergence of algorithmic information is rendered invariant, minimal, and robust\nin the face of information cost and distortion, while still observer-dependent.\nWe demonstrate that the unbounded increase of emergent algorithmic information\nimplies asymptotically observer-independent emergence, which eventually\novercomes any formal theory that an observer might devise to finitely\ncharacterise a phenomenon. We discuss observer-dependent emergence and\nasymptotically observer-independent emergence solving some previous suggestions\nindicating a hard distinction between strong and weak emergence.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 04:59:59 GMT"}, {"version": "v2", "created": "Mon, 21 Jun 2021 22:55:04 GMT"}], "update_date": "2021-06-23", "authors_parsed": [["Abrah\u00e3o", "Felipe S.", ""], ["Zenil", "Hector", ""]]}, {"id": "2105.14860", "submitter": "Martin Vu", "authors": "Sebastian Maneth, Helmut Seidl, Martin Vu", "title": "Definability Results for Top-Down Tree Transducers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We prove that for a given deterministic top-down transducer with look-ahead\nit is decidable whether or not its translation is definable (1)~by a linear\ntop-down tree transducer or (2)~by a tree homomorphism. We present algorithms\nthat construct equivalent such transducers if they exist.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 10:27:59 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Maneth", "Sebastian", ""], ["Seidl", "Helmut", ""], ["Vu", "Martin", ""]]}, {"id": "2105.14903", "submitter": "Pawe{\\l} Gawrychowski", "authors": "Pawe{\\l} Gawrychowski, Samah Ghazawi, Gad M. Landau", "title": "Lower Bounds for the Number of Repetitions in 2D Strings", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A two-dimensional string is simply a two-dimensional array. We continue the\nstudy of the combinatorial properties of repetitions in such strings over the\nbinary alphabet, namely the number of distinct tandems, distinct quartics, and\nruns. First, we construct an infinite family of $n\\times n$ 2D strings with\n$\\Omega(n^{3})$ distinct tandems. Second, we construct an infinite family of\n$n\\times n$ 2D strings with $\\Omega(n^{2}\\log n)$ distinct quartics. Third, we\nconstruct an infinite family of $n\\times n$ 2D strings with $\\Omega(n^{2}\\log\nn)$ runs. This resolves an open question of Charalampopoulos, Radoszewski,\nRytter, Wale\\'n, and Zuba [ESA 2020], who asked if the number of distinct\nquartics and runs in an $n\\times n$ 2D string is $\\mathcal{O}(n^{2})$.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 12:06:09 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Gawrychowski", "Pawe\u0142", ""], ["Ghazawi", "Samah", ""], ["Landau", "Gad M.", ""]]}, {"id": "2105.14990", "submitter": "Giuseppa Castiglione", "authors": "Giuseppa Castiglione, Jia Gao, Sabrina Mantaci, Antonio Restivo", "title": "A new distance based on minimal absent words and applications to\n  biological sequences", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A minimal absent word of a sequence x, is a sequence yt hat is not a factorof\nx, but all of its proper factors are factors of x as well. The set of minimal\nabsent words uniquely defines the sequence itself. In recent times minimal\nabsent words have been used in order to compare sequences. In fact, to do this,\none can compare the sets of their minimal absent words. Chairungasee and\nCrochemorein [2] define a distance between pairs of sequences x and y, where\nthe symmetric difference of the sets of minimal absent words of x and y is\ninvolved. Here, weconsider a different distance, introduced in [1], based on a\nspecific subset of such symmetric difference that, in our opinion, better\ncapture the different features ofthe considered sequences. We show the result\nof some experiments where the distance is tested on a dataset of genetic\nsequences by 11 living species, in order to compare the new distance with the\nones existing in literature.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 14:22:20 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Castiglione", "Giuseppa", ""], ["Gao", "Jia", ""], ["Mantaci", "Sabrina", ""], ["Restivo", "Antonio", ""]]}]