[{"id": "1807.00048", "submitter": "Matt Luckcuck", "authors": "Matt Luckcuck, Marie Farrell, Louise Dennis, Clare Dixon, and Michael\n  Fisher", "title": "Formal Specification and Verification of Autonomous Robotic Systems: A\n  Survey", "comments": "32 pages (in this format) resubmitted to ACM CSUR", "journal-ref": null, "doi": "10.1145/3342355", "report-no": null, "categories": "cs.FL cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Autonomous robotic systems are complex, hybrid, and often safety-critical;\nthis makes their formal specification and verification uniquely challenging.\nThough commonly used, testing and simulation alone are insufficient to ensure\nthe correctness of, or provide sufficient evidence for the certification of,\nautonomous robotics. Formal methods for autonomous robotics has received some\nattention in the literature, but no resource provides a current overview. This\npaper systematically surveys the state-of-the-art in formal specification and\nverification for autonomous robotics. Specially, it identifies and categorises\nthe challenges posed by, the formalisms aimed at, and the formal approaches for\nthe specification and verification of autonomous robotics.\n", "versions": [{"version": "v1", "created": "Fri, 29 Jun 2018 19:48:48 GMT"}, {"version": "v2", "created": "Mon, 3 Sep 2018 17:03:02 GMT"}, {"version": "v3", "created": "Wed, 1 May 2019 12:45:09 GMT"}], "update_date": "2021-01-28", "authors_parsed": [["Luckcuck", "Matt", ""], ["Farrell", "Marie", ""], ["Dennis", "Louise", ""], ["Dixon", "Clare", ""], ["Fisher", "Michael", ""]]}, {"id": "1807.00433", "submitter": "Rachel Skipper", "authors": "Rachel Skipper, Benjamin Steinberg", "title": "Lamplighter groups, bireversible automata and rational series over\n  finite rings", "comments": "23 pages, 2 figures, 4 tables, v2: updated to include full title in\n  posting, v3: incorporates referee suggestions, final version to appear in\n  Groups, Geometry, and Dynamics", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We realize lamplighter groups $A\\wr \\mathbb Z$, with $A$ a finite abelian\ngroup, as automaton groups via affine transformations of power series rings\nwith coefficients in a finite commutative ring. Our methods can realize $A\\wr\n\\mathbb Z$ as a bireversible automaton group if and only if the $2$-Sylow\nsubgroup of $A$ has no multiplicity one summands in its expression as a direct\nsum of cyclic groups of order a power of $2$.\n", "versions": [{"version": "v1", "created": "Mon, 2 Jul 2018 02:10:36 GMT"}, {"version": "v2", "created": "Fri, 6 Jul 2018 11:32:33 GMT"}, {"version": "v3", "created": "Fri, 29 Nov 2019 15:35:26 GMT"}], "update_date": "2019-12-02", "authors_parsed": [["Skipper", "Rachel", ""], ["Steinberg", "Benjamin", ""]]}, {"id": "1807.00663", "submitter": "Pascal Caron", "authors": "Pascal Caron, Edwin Hamel-De le court, Jean-Gabriel Luque, Bruno\n  Patrou", "title": "New tools for state complexity", "comments": "18 pages", "journal-ref": "Discrete Mathematics & Theoretical Computer Science, vol. 22 no.\n  1, Automata, Logic and Semantics (March 16, 2020) dmtcs:6179", "doi": "10.23638/DMTCS-22-1-9", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A monster is an automaton in which every function from states to states is\nrepresented by at least one letter. A modifier is a set of functions allowing\none to transform a set of automata into one automaton. We revisit some language\ntransformation algorithms in terms of modifier and monster. These new\ntheoretical concepts allow one to find easily some state complexities. We\nillustrate this by retrieving the state complexity of the Star of Intersection\nand the one of the Square root operation.\n", "versions": [{"version": "v1", "created": "Mon, 2 Jul 2018 13:54:36 GMT"}, {"version": "v2", "created": "Mon, 17 Sep 2018 13:30:15 GMT"}, {"version": "v3", "created": "Tue, 24 Sep 2019 08:25:20 GMT"}, {"version": "v4", "created": "Mon, 6 Jan 2020 15:23:42 GMT"}, {"version": "v5", "created": "Mon, 20 Jan 2020 09:13:44 GMT"}, {"version": "v6", "created": "Mon, 2 Mar 2020 09:47:17 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Caron", "Pascal", ""], ["court", "Edwin Hamel-De le", ""], ["Luque", "Jean-Gabriel", ""], ["Patrou", "Bruno", ""]]}, {"id": "1807.00893", "submitter": "Blaise Genest", "authors": "Nathalie Bertrand and Miheer Dewaskar and Blaise Genest and Hugo\n  Gimbert and Adwait Amit Godbole", "title": "Controlling a population", "comments": "This is a journal version of the extended abstract arXiv:1707.02058\n  which appeared in Concur 2017, together with proofs", "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 3 (July 29,\n  2019) lmcs:5647", "doi": "10.23638/LMCS-15(3:6)2019", "report-no": null, "categories": "cs.FL cs.SY eess.SY", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce a new setting where a population of agents, each modelled by a\nfinite-state system, are controlled uniformly: the controller applies the same\naction to every agent. The framework is largely inspired by the control of a\nbiological system, namely a population of yeasts, where the controller may only\nchange the environment common to all cells. We study a synchronisation problem\nfor such populations: no matter how individual agents react to the actions of\nthe controller, the controller aims at driving all agents synchronously to a\ntarget state. The agents are naturally represented by a non-deterministic\nfinite state automaton (NFA), the same for every agent, and the whole system is\nencoded as a 2-player game. The first player (Controller) chooses actions, and\nthe second player (Agents) resolves non-determinism for each agent. The game\nwith m agents is called the m -population game. This gives rise to a\nparameterized control problem (where control refers to 2 player games), namely\nthe population control problem: can Controller control the m-population game\nfor all m in N whatever Agents does?\n", "versions": [{"version": "v1", "created": "Mon, 2 Jul 2018 21:15:17 GMT"}, {"version": "v2", "created": "Thu, 7 Mar 2019 16:59:29 GMT"}, {"version": "v3", "created": "Fri, 26 Jul 2019 13:40:58 GMT"}], "update_date": "2019-10-23", "authors_parsed": [["Bertrand", "Nathalie", ""], ["Dewaskar", "Miheer", ""], ["Genest", "Blaise", ""], ["Gimbert", "Hugo", ""], ["Godbole", "Adwait Amit", ""]]}, {"id": "1807.01406", "submitter": "Guillaume Rabusseau", "authors": "Guillaume Rabusseau and Tianyu Li and Doina Precup", "title": "Connecting Weighted Automata and Recurrent Neural Networks through\n  Spectral Learning", "comments": "AISTATS 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we unravel a fundamental connection between weighted finite\nautomata~(WFAs) and second-order recurrent neural networks~(2-RNNs): in the\ncase of sequences of discrete symbols, WFAs and 2-RNNs with linear activation\nfunctions are expressively equivalent. Motivated by this result, we build upon\na recent extension of the spectral learning algorithm to vector-valued WFAs and\npropose the first provable learning algorithm for linear 2-RNNs defined over\nsequences of continuous input vectors. This algorithm relies on estimating low\nrank sub-blocks of the so-called Hankel tensor, from which the parameters of a\nlinear 2-RNN can be provably recovered. The performances of the proposed method\nare assessed in a simulation study.\n", "versions": [{"version": "v1", "created": "Wed, 4 Jul 2018 00:12:12 GMT"}, {"version": "v2", "created": "Mon, 8 Apr 2019 03:50:03 GMT"}], "update_date": "2019-04-09", "authors_parsed": [["Rabusseau", "Guillaume", ""], ["Li", "Tianyu", ""], ["Precup", "Doina", ""]]}, {"id": "1807.02102", "submitter": "Tobias Kapp\\'e", "authors": "Tobias Kapp\\'e and Paul Brunet and Bas Luttik and Alexandra Silva and\n  Fabio Zanasi", "title": "Equivalence checking for weak bi-Kleene algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Pomset automata are an operational model of weak bi-Kleene algebra, which\ndescribes programs that can fork an execution into parallel threads, upon\ncompletion of which execution can join to resume as a single thread. We\ncharacterize a fragment of pomset automata that admits a decision procedure for\nlanguage equivalence. Furthermore, we prove that this fragment corresponds\nprecisely to series-rational expressions, i.e., rational expressions with an\nadditional operator for bounded parallelism. As a consequence, we obtain a new\nproof that equivalence of series-rational expressions is decidable.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2018 17:42:35 GMT"}, {"version": "v2", "created": "Fri, 6 Jul 2018 14:52:33 GMT"}, {"version": "v3", "created": "Thu, 26 Mar 2020 15:07:59 GMT"}, {"version": "v4", "created": "Thu, 20 May 2021 14:23:15 GMT"}], "update_date": "2021-05-21", "authors_parsed": [["Kapp\u00e9", "Tobias", ""], ["Brunet", "Paul", ""], ["Luttik", "Bas", ""], ["Silva", "Alexandra", ""], ["Zanasi", "Fabio", ""]]}, {"id": "1807.02554", "submitter": "Serhiy Semerikov", "authors": "S. O. Semerikov, O. P. Polishchuk", "title": "Methodic of joint using the tools of automation of lexical and parsing\n  analysis in the process of teaching the programming theory of future\n  informatics teachers", "comments": "27 pages, 2 tables, in Ukrainian", "journal-ref": "Theory and methods of learning mathematics, physics, informatics\n  13, 2 (2015) 174-200", "doi": null, "report-no": null, "categories": "cs.PL cs.CY cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The place and role of parsing analysis in formation of professional\ninformatics competences of future informatics teachers is determined. Separated\nautomation tools for lexical (lex) and syntax (yacc) analysis invariant to the\nprogramming language used. The expediency of using functional programming\nlanguages Scheme and SML is shown for learning how to develop compilers in the\ncourse of programming theory. The example of the MosML dialect illustrates the\nmain components of the methodic of joint using the tools of automation of\nlexical and parsing analysis in the process of teaching the programming theory\nof future informatics teachers. The main conclusions and recommendations: 1)\nthe considered example of the expanded calculator can be refined by changing\nthe grammar, in particular - for the introduction of conditional and cyclic\nconstructions; 2) the proposed scheme can be used to implement the interpreter\nof any formal language with an arbitrary typing method - the appropriate\nexamples of study will be subsets of procedural languages Basic and C and\nfunctional languages Scheme and SML: provided the addition of the machine code\ngeneration phase, this provides an opportunity to demonstrate the full\ndevelopment cycle for programming language compiler.\n", "versions": [{"version": "v1", "created": "Wed, 4 Jul 2018 18:15:43 GMT"}], "update_date": "2018-07-10", "authors_parsed": [["Semerikov", "S. O.", ""], ["Polishchuk", "O. P.", ""]]}, {"id": "1807.02735", "submitter": "Matvey Soloviev", "authors": "Dexter Kozen and Matvey Soloviev", "title": "Coalgebraic Tools for Randomness-Conserving Protocols", "comments": "25 pages, including references. In submission to RAMiCS 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.IT math.IT math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a coalgebraic model for constructing and reasoning about\nstate-based protocols that implement efficient reductions among random\nprocesses. We provide basic tools that allow efficient protocols to be\nconstructed in a compositional way and analyzed in terms of the tradeoff\nbetween latency and loss of entropy. We show how to use these tools to\nconstruct various entropy-conserving reductions between processes.\n", "versions": [{"version": "v1", "created": "Sun, 8 Jul 2018 01:43:12 GMT"}], "update_date": "2018-07-10", "authors_parsed": [["Kozen", "Dexter", ""], ["Soloviev", "Matvey", ""]]}, {"id": "1807.03002", "submitter": "Linda Brodo", "authors": "Chiara Bodei, Linda Brodo, Roberto Bruni", "title": "A Formal Approach to Open Multiparty Interactions", "comments": "62 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a process algebra aimed at describing interactions that are\nmultiparty, i.e. that may involve more than two processes and that are open,\ni.e. the number of the processes they involve is not fixed or known a priori.\nHere we focus on the theory of a core version of a process calculus, without\nmessage passing, called Core Network Algebra (CNA). In CNA communication\nactions are given not in terms of channels but in terms of chains of links that\nrecord the source and the target ends of each hop of interactions. The\noperational semantics of our calculus mildly extends the one of CCS. The\nabstract semantics is given in the style of bisimulation but requires some\ningenuity. Remarkably, the abstract semantics is a congruence for all operators\nof CNA and also with respect to substitutions, which is not the case for strong\nbisimilarity in CCS. As a motivating and running example, we illustrate the\nmodel of a simple software defined network infrastructure.\n", "versions": [{"version": "v1", "created": "Mon, 9 Jul 2018 09:25:12 GMT"}, {"version": "v2", "created": "Mon, 21 Jan 2019 12:24:51 GMT"}], "update_date": "2019-01-23", "authors_parsed": [["Bodei", "Chiara", ""], ["Brodo", "Linda", ""], ["Bruni", "Roberto", ""]]}, {"id": "1807.03865", "submitter": "Caleb Stanford", "authors": "Rajeev Alur, Dana Fisman, Konstantinos Mamouras, Mukund Raghothaman,\n  Caleb Stanford", "title": "Streamable Regular Transductions", "comments": "53 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Motivated by real-time monitoring and data processing applications, we\ndevelop a formal theory of quantitative queries for streaming data that can be\nevaluated efficiently. We consider the model of unambiguous Cost Register\nAutomata (CRAs), which are machines that combine finite-state control (for\nidentifying regular patterns) with a finite set of data registers (for\ncomputing numerical aggregates). The definition of CRAs is parameterized by the\ncollection of numerical operations that can be applied to the registers. These\nmachines give rise to the class of streamable regular transductions (SR), and\nto the class of streamable linear regular transductions (SLR) when the register\nupdates are copyless, i.e. every register appears at most once the\nright-hand-side expressions of the updates. We give a logical characterization\nof the class SR (resp., SLR) using MSO-definable transformations from strings\nto DAGs (resp., trees) without backward edges. Additionally, we establish that\nthe two classes SR and SLR are closed under operations that are relevant for\ndesigning query languages. Finally, we study the relationship with weighted\nautomata (WA), and show that CRAs over a suitably chosen set of operations\ncorrespond to WA, thus establishing that WA are a special case of CRAs.\n", "versions": [{"version": "v1", "created": "Tue, 10 Jul 2018 21:11:24 GMT"}, {"version": "v2", "created": "Sun, 3 Nov 2019 21:13:50 GMT"}], "update_date": "2019-11-05", "authors_parsed": [["Alur", "Rajeev", ""], ["Fisman", "Dana", ""], ["Mamouras", "Konstantinos", ""], ["Raghothaman", "Mukund", ""], ["Stanford", "Caleb", ""]]}, {"id": "1807.04568", "submitter": "Achim Blumensath", "authors": "Achim Blumensath", "title": "Branch-Continuous Tree Algebras", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study a class of algebras that can be used as recognisers for regular\nlanguages of infinite trees.\n", "versions": [{"version": "v1", "created": "Thu, 12 Jul 2018 12:24:41 GMT"}], "update_date": "2018-07-13", "authors_parsed": [["Blumensath", "Achim", ""]]}, {"id": "1807.04661", "submitter": "Michiel de Bondt", "authors": "Michiel de Bondt", "title": "Subset synchronization of DFAs and PFAs, and some other results", "comments": "17 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper contains results which arose from the research which led to\narXiv:1801.10436, but which did not fit in arXiv:1801.10436. So\narXiv:1801.10436 contains the highlight results, but there are more results\nwhich are interesting enough to be shared.\n", "versions": [{"version": "v1", "created": "Sat, 7 Jul 2018 20:21:54 GMT"}], "update_date": "2018-07-13", "authors_parsed": [["de Bondt", "Michiel", ""]]}, {"id": "1807.04735", "submitter": "Maksims Dimitrijevs", "authors": "Maksims Dimitrijevs, Abuzer Yakary{\\i}lmaz", "title": "Probabilistic verification of all languages", "comments": "20 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present three protocols for verifying all languages: (i) For any unary\n(binary) language, there is a log-space (linear-space) interactive proof system\n(IPS); (ii) for any language, there is a constant-space weak-IPS (the\nnon-members may not be rejected with high probability); and, (iii) for any\nlanguage, there is a constant-space IPS with two provers where the verifier\nreads the input once. Additionally, we show that uncountably many binary\n(unary) languages can be verified in constant space and in linear (quadratic)\nexpected time.\n", "versions": [{"version": "v1", "created": "Thu, 12 Jul 2018 17:20:27 GMT"}], "update_date": "2018-07-13", "authors_parsed": [["Dimitrijevs", "Maksims", ""], ["Yakary\u0131lmaz", "Abuzer", ""]]}, {"id": "1807.04889", "submitter": "Lilian Kawakami Carvalho DSc", "authors": "Lilian Kawakami Carvalho, Yi-Chin Wu, Raymond Kwong and St\\'ephane\n  Lafortune", "title": "Detection and Mitigation of Classes of Attacks in Supervisory Control\n  Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The deployment of control systems with network-connected components has made\nfeedback control systems vulnerable to attacks over the network. This paper\nconsiders the problem of intrusion detection and mitigation in supervisory\ncontrol systems, where the attacker has the ability to enable or disable\nvulnerable actuator commands and erase or insert vulnerable sensor readings. We\npresent a mathematical model for the system under certain classes of actuator\nenablement attacks, sensor erasure attacks, or sensor insertion attacks. We\nthen propose a defense strategy that aims to detect such attacks online and\ndisables all controllable events after an attack is detected. We develop an\nalgorithmic procedure for verifying whether the system can prevent damage from\nthe attacks considered with the proposed defense strategy, where damage is\nmodeled as the reachability of a pre-defined set of unsafe system states.The\ntechnical condition of interest that is necessary and sufficient in this\ncontext, termed \"GF-safe controllability\", is characterized. We show that the\nverification of GF-safe controllability can be performed using diagnoser or\nverifier automata. Finally, we illustrate the methodology with a traffic\ncontrol system example.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jul 2018 02:13:45 GMT"}], "update_date": "2018-07-16", "authors_parsed": [["Carvalho", "Lilian Kawakami", ""], ["Wu", "Yi-Chin", ""], ["Kwong", "Raymond", ""], ["Lafortune", "St\u00e9phane", ""]]}, {"id": "1807.04920", "submitter": "Stefan Kiefer", "authors": "Nikhil Balaji, Stefan Kiefer, Petr Novotn\\'y, Guillermo A. P\\'erez,\n  and Mahsa Shirmohammadi", "title": "On the Complexity of Value Iteration", "comments": "Full version of an ICALP'19 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.AI cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Value iteration is a fundamental algorithm for solving Markov Decision\nProcesses (MDPs). It computes the maximal $n$-step payoff by iterating $n$\ntimes a recurrence equation which is naturally associated to the MDP. At the\nsame time, value iteration provides a policy for the MDP that is optimal on a\ngiven finite horizon $n$. In this paper, we settle the computational complexity\nof value iteration. We show that, given a horizon $n$ in binary and an MDP,\ncomputing an optimal policy is EXP-complete, thus resolving an open problem\nthat goes back to the seminal 1987 paper on the complexity of MDPs by\nPapadimitriou and Tsitsiklis. As a stepping stone, we show that it is\nEXP-complete to compute the $n$-fold iteration (with $n$ in binary) of a\nfunction given by a straight-line program over the integers with $\\max$ and $+$\nas operators.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jul 2018 05:28:11 GMT"}, {"version": "v2", "created": "Sat, 17 Nov 2018 13:32:27 GMT"}, {"version": "v3", "created": "Sat, 27 Apr 2019 11:03:47 GMT"}], "update_date": "2019-04-30", "authors_parsed": [["Balaji", "Nikhil", ""], ["Kiefer", "Stefan", ""], ["Novotn\u00fd", "Petr", ""], ["P\u00e9rez", "Guillermo A.", ""], ["Shirmohammadi", "Mahsa", ""]]}, {"id": "1807.05169", "submitter": "Maksims Dimitrijevs", "authors": "Maksims Dimitrijevs, Abuzer Yakary{\\i}lmaz", "title": "Postselecting probabilistic finite state recognizers and verifiers", "comments": "18 pages. Accepted to NCMA 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we investigate the computational and verification power of\nbounded-error postselecting realtime probabilistic finite state automata\n(PostPFAs). We show that PostPFAs using rational-valued transitions can do\ndifferent variants of equality checks and they can verify some nonregular unary\nlanguages. Then, we allow them to use real-valued transitions (magic-coins) and\nshow that they can recognize uncountably many binary languages by help of a\ncounter and verify uncountably many unary languages by help of a prover. We\nalso present some corollaries on probabilistic counter automata.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jul 2018 16:37:13 GMT"}], "update_date": "2018-07-16", "authors_parsed": [["Dimitrijevs", "Maksims", ""], ["Yakary\u0131lmaz", "Abuzer", ""]]}, {"id": "1807.05385", "submitter": "Alejandro D\\'iaz-Caro", "authors": "Alejandro D\\'iaz-Caro and Marcos Villagra", "title": "Classically Time-Controlled Quantum Automata: Definition and Properties", "comments": "Long revisited version of LNCS 11324:266-278, 2018 (TPNC 2018)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we introduce classically time-controlled quantum automata or\nCTQA, which is a reasonable modification of Moore-Crutchfield quantum finite\nautomata that uses time-dependent evolution and a \"scheduler\" defining how long\neach Hamiltonian will run. Surprisingly enough, time-dependent evolution\nprovides a significant change in the computational power of quantum automata\nwith respect to a discrete quantum model. Indeed, we show that if a scheduler\nis not computationally restricted, then a CTQA can decide the Halting problem.\nIn order to unearth the computational capabilities of CTQAs we study the case\nof a computationally restricted scheduler. In particular we showed that\ndepending on the type of restriction imposed on the scheduler, a CTQA can (i)\nrecognize non-regular languages with cut-point, even in the presence of\nKarp-Lipton advice, and (ii) recognize non-regular languages with\nbounded-error. Furthermore, we study the closure of concatenation and union of\nlanguages by introducing a new model of Moore-Crutchfield quantum finite\nautomata with a rotating tape head. CTQA presents itself as a new model of\ncomputation that provides a different approach to a formal study of \"classical\ncontrol, quantum data\" schemes in quantum computing.\n", "versions": [{"version": "v1", "created": "Sat, 14 Jul 2018 11:57:37 GMT"}, {"version": "v2", "created": "Thu, 13 Sep 2018 18:49:31 GMT"}, {"version": "v3", "created": "Wed, 29 Jan 2020 00:05:00 GMT"}, {"version": "v4", "created": "Sun, 3 May 2020 14:22:21 GMT"}, {"version": "v5", "created": "Thu, 1 Oct 2020 22:52:05 GMT"}, {"version": "v6", "created": "Fri, 18 Dec 2020 17:25:26 GMT"}], "update_date": "2020-12-21", "authors_parsed": [["D\u00edaz-Caro", "Alejandro", ""], ["Villagra", "Marcos", ""]]}, {"id": "1807.05516", "submitter": "\\\"Ozlem Salehi", "authors": "\\\"Ozlem Salehi and Ahmet Celal Cem Say", "title": "Extended finite automata and decision problems for matrix semigroups", "comments": "NCMA2018 Short Paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We make a connection between the subgroup membership and identity problems\nfor matrix groups and extended finite automata. We provide an alternative proof\nfor the decidability of the subgroup membership problem for $ 2 \\times 2 $\ninteger matrices. We show that the emptiness problem for extended finite\nautomata over $ 4 \\times 4 $ integer matrix semigroups is undecidable. We prove\nthat the decidability of the universe problem for extended finite automata is a\nsufficient condition for the decidability of the subgroup membership and\nidentity problems.\n", "versions": [{"version": "v1", "created": "Sun, 15 Jul 2018 09:07:22 GMT"}], "update_date": "2018-07-17", "authors_parsed": [["Salehi", "\u00d6zlem", ""], ["Say", "Ahmet Celal Cem", ""]]}, {"id": "1807.05555", "submitter": "Paola Quaglia", "authors": "Paola Quaglia", "title": "Briefly on Bottom-up", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  These short notes are meant as a quick reference for the construction of\nSLR(1), of LR(1), and of LALR(1) parsing tables.\n", "versions": [{"version": "v1", "created": "Sun, 15 Jul 2018 14:29:35 GMT"}, {"version": "v2", "created": "Thu, 22 Nov 2018 17:26:01 GMT"}], "update_date": "2018-11-26", "authors_parsed": [["Quaglia", "Paola", ""]]}, {"id": "1807.06720", "submitter": "Liyong Lin", "authors": "Liyong Lin, Sander Thuijsman, Yuting Zhu, Simon Ware, Rong Su and\n  Michel Reniers", "title": "Synthesis of Successful Actuator Attackers on Supervisors", "comments": "This work has been submitted to the journal \"Discrete Event Dynamic\n  Systems: Theory and Applications\". These two authors contribute equally to\n  this work", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we propose and develop a new discrete-event based actuator\nattack model on the closed-loop system formed by the plant and the supervisor.\nWe assume the actuator attacker partially observes the execution of the\nclosed-loop system and eavesdrops the control commands issued by the\nsupervisor. The attacker can modify each control command on a specified subset\nof attackable events. The attack principle of the actuator attacker is to\nremain covert until it can establish a successful attack and lead the attacked\nclosed-loop system into generating certain damaging strings. We present a\ncharacterization for the existence of a successful attacker, via a new notion\nof attackability, and prove the existence of the supremal successful actuator\nattacker, when both the supervisor and the attacker are normal (that is,\nunobservable events to the supervisor cannot be disabled by the supervisor and\nunobservable events to the attacker cannot be attacked by the attacker).\nFinally, we present an algorithm to synthesize the supremal successful\nattackers that are represented by Moore automata.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jul 2018 00:42:24 GMT"}, {"version": "v2", "created": "Tue, 24 Jul 2018 07:16:20 GMT"}, {"version": "v3", "created": "Fri, 22 Feb 2019 07:20:26 GMT"}, {"version": "v4", "created": "Wed, 27 Feb 2019 13:19:06 GMT"}], "update_date": "2019-02-28", "authors_parsed": [["Lin", "Liyong", ""], ["Thuijsman", "Sander", ""], ["Zhu", "Yuting", ""], ["Ware", "Simon", ""], ["Su", "Rong", ""], ["Reniers", "Michel", ""]]}, {"id": "1807.06774", "submitter": "Markus Lohrey", "authors": "Markus Lohrey", "title": "Knapsack in hyperbolic groups", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recently knapsack problems have been generalized from the integers to\narbitrary finitely generated groups. The knapsack problem for a finitely\ngenerated group $G$ is the following decision problem: given a tuple $(g, g_1,\n\\ldots, g_k)$ of elements of $G$, are there natural numbers $n_1, \\ldots, n_k\n\\in \\mathbb{N}$ such that $g = g_1^{n_1} \\cdots g_k^{n_k}$ holds in $G$?\nMyasnikov, Nikolaev, and Ushakov proved that for every (Gromov-)hyperbolic\ngroup, the knapsack problem can be solved in polynomial time. In this paper,\nthe precise complexity of the knapsack problem for hyperbolic group is\ndetermined: for every hyperbolic group $G$, the knapsack problem belongs to the\ncomplexity class $\\mathsf{LogCFL}$, and it is $\\mathsf{LogCFL}$-complete if $G$\ncontains a free group of rank two. Moreover, it is shown that for every\nhyperbolic group $G$ and every tuple $(g, g_1, \\ldots, g_k)$ of elements of $G$\nthe set of all $(n_1, \\ldots, n_k) \\in \\mathbb{N}^k$ such that $g = g_1^{n_1}\n\\cdots g_k^{n_k}$ in $G$ is semilinear and a semilinear representation where\nall integers are of size polynomial in the total geodesic length of the $g,\ng_1, \\ldots, g_k$ can be computed. Groups with this property are also called\nknapsack-tame. This enables us to show that knapsack can be solved in\n$\\mathsf{LogCFL}$ for every group that belongs to the closure of hyperbolic\ngroups under free products and direct products with $\\mathbb{Z}$.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jul 2018 05:20:56 GMT"}, {"version": "v2", "created": "Tue, 9 Apr 2019 06:28:23 GMT"}], "update_date": "2019-04-10", "authors_parsed": [["Lohrey", "Markus", ""]]}, {"id": "1807.07048", "submitter": "Mikhail Volkov", "authors": "Mikhail Volkov", "title": "Slowly Synchronizing Automata with Idempotent Letters of Low Rank", "comments": "15 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We use a semigroup-theoretic construction by Peter Higgins in order to\nproduce, for each even $n$, an $n$-state and 3-letter synchronizing automaton\nwith the following two features: 1) all its input letters act as idempotent\nselfmaps of rank $\\dfrac{n}2$; 2) its reset threshold is asymptotically equal\nto $\\dfrac{n^2}2$.\n  In the revised version a few inaccuracies (spotted by the anonymous referees\nof the previous version) have been removed and several relevant references have\nbeen added.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jul 2018 17:24:33 GMT"}, {"version": "v2", "created": "Tue, 2 Apr 2019 01:48:39 GMT"}], "update_date": "2019-04-03", "authors_parsed": [["Volkov", "Mikhail", ""]]}, {"id": "1807.07208", "submitter": "Olivier Carton", "authors": "Nicol\\'as \\'Alvarez and Olivier Carton", "title": "On normality in shifts of finite type", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we consider the notion of normality of sequences in shifts of\nfinite type. A sequence is normal if the frequency of each block exists and is\nequal to the Parry measure of the block. We give a characterization of\nnormality in terms of incompressibility by lossless transducers. The result was\nalready known in the case of the full shift.\n", "versions": [{"version": "v1", "created": "Thu, 19 Jul 2018 01:22:07 GMT"}, {"version": "v2", "created": "Tue, 26 Feb 2019 18:02:03 GMT"}], "update_date": "2019-02-27", "authors_parsed": [["\u00c1lvarez", "Nicol\u00e1s", ""], ["Carton", "Olivier", ""]]}, {"id": "1807.08053", "submitter": "Gabriele Puppis", "authors": "Sougata Bose, Anca Muscholl, Vincent Penelle, Gabriele Puppis", "title": "Origin-equivalence of two-way word transducers is in PSPACE", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider equivalence and containment problems for word transductions.\nThese problems are known to be undecidable when the transductions are relations\nbetween words realized by non-deterministic transducers, and become decidable\nwhen restricting to functions from words to words. Here we prove that\ndecidability can be equally recovered by adopting a slightly different, but\nnatural semantics, called origin semantics and introduced by Bojanczyk in 2014.\nSpecifically, we prove that the equivalence and containment problems for\ntwo-way word transducers in the origin semantics are PSPACE-complete. We also\nconsider a variant of the containment problem where two-way transducers are\ncompared under the origin semantics, but in a more relaxed way, by allowing\ndistortions of the origins. The possible distortions are described by means of\na resynchronization relation. We propose a logical formalism for describing a\nbroad class of resynchronizations, while preserving the decidability of the\nvariant of the containment problem.\n", "versions": [{"version": "v1", "created": "Fri, 20 Jul 2018 23:17:28 GMT"}, {"version": "v2", "created": "Tue, 24 Jul 2018 06:33:08 GMT"}, {"version": "v3", "created": "Fri, 5 Oct 2018 15:03:04 GMT"}], "update_date": "2018-10-08", "authors_parsed": [["Bose", "Sougata", ""], ["Muscholl", "Anca", ""], ["Penelle", "Vincent", ""], ["Puppis", "Gabriele", ""]]}, {"id": "1807.08203", "submitter": "Martin Zimmermann", "authors": "Corto Mascle, Daniel Neider, Maximilian Schwenger, Paulo Tabuada,\n  Alexander Weinert, Martin Zimmermann", "title": "From LTL to rLTL Monitoring: Improved Monitorability through Robust\n  Semantics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Runtime monitoring is commonly used to detect the violation of desired\nproperties in safety critical cyber-physical systems by observing its\nexecutions. Bauer et al. introduced an influential framework for monitoring\nLinear Temporal Logic (LTL) properties based on a three-valued semantics: the\nformula is already satisfied by the given prefix, it is already violated, or it\nis still undetermined, i.e., it can still be satisfied and violated by\nappropriate extensions. However, a wide range of formulas are not monitorable\nunder this approach, meaning that they have a prefix for which satisfaction and\nviolation will always remain undetermined no matter how it is extended. In\nparticular, Bauer et al. report that 44% of the formulas they consider in their\nexperiments fall into this category.\n  Recently, a robust semantics for LTL was introduced to capture different\ndegrees by which a property can be violated. In this paper we introduce a\nrobust semantics for finite strings and show its potential in monitoring: every\nformula considered by Bauer et al. is monitorable under our approach.\nFurthermore, we discuss which properties that come naturally in LTL monitoring\n- such as the realizability of all truth values - can be transferred to the\nrobust setting. Lastly, we show that LTL formulas with robust semantics can be\nmonitored by deterministic automata and report on a prototype implementation.\n", "versions": [{"version": "v1", "created": "Sat, 21 Jul 2018 20:23:03 GMT"}, {"version": "v2", "created": "Mon, 20 May 2019 09:03:30 GMT"}, {"version": "v3", "created": "Fri, 20 Mar 2020 16:43:56 GMT"}, {"version": "v4", "created": "Mon, 6 Apr 2020 09:02:38 GMT"}], "update_date": "2020-04-07", "authors_parsed": [["Mascle", "Corto", ""], ["Neider", "Daniel", ""], ["Schwenger", "Maximilian", ""], ["Tabuada", "Paulo", ""], ["Weinert", "Alexander", ""], ["Zimmermann", "Martin", ""]]}, {"id": "1807.08267", "submitter": "Florin Stoica", "authors": "Florin Stoica, Laura Florentina Stoica", "title": "Generating an ATL Model Checker using an Attribute Grammar", "comments": "18 pages, 7 figures, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB cs.DC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we use attribute grammars as a formal approach for model\ncheckers development. Our aim is to design an ATL (Alternating-Time Temporal\nLogic) model checker from a context-free grammar which generates the language\nof the ATL formulas. An attribute grammar may be informally defined as a\ncontext-free grammar which is extended with a set of attributes and a\ncollection of semantic rules. We use an ATL attribute grammar for specifying an\noperational semantics of the language of the ATL formulas by defining a\ntranslation into the language which describes the set of states from the ATL\nmodel where the corresponding ATL formulas are satisfied. We provide a formal\ndefinition for an attribute grammar used as input for Another Tool for Language\nRecognition (ANTLR) to generate an ATL model checker. Also, the technique of\nimplementing the semantic actions in ANTLR is presented, which is the concept\nof connection between attribute evaluation in the grammar that generates the\nlanguage of ATL formulas and algebraic compiler implementation that represents\nthe ATL model checker. The original implementation of the model checking\nalgorithm is based on Relational Databases and Web Services. Several database\nsystems and Web Services technologies were used for evaluating the system\nperformance in verification of large ATL models.\n", "versions": [{"version": "v1", "created": "Sun, 22 Jul 2018 10:18:12 GMT"}, {"version": "v2", "created": "Tue, 5 Feb 2019 15:54:54 GMT"}], "update_date": "2019-02-06", "authors_parsed": [["Stoica", "Florin", ""], ["Stoica", "Laura Florentina", ""]]}, {"id": "1807.08321", "submitter": "Anna Frid", "authors": "M\\'elodie Andrieu, Anna E. Frid", "title": "Morphic words and equidistributed sequences", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem we consider is the following: Given an infinite word $w$ on an\nordered alphabet, construct the sequence $\\nu_w=(\\nu[n])_n$, equidistributed on\n$[0,1]$ and such that $\\nu[m]<\\nu[n]$ if and only if $\\sigma^m(w)<\\sigma^n(w)$,\nwhere $\\sigma$ is the shift operation, erasing the first symbol of $w$. The\nsequence $\\nu_w$ exists and is unique for every word with well-defined positive\nuniform frequencies of every factor, or, in dynamical terms, for every element\nof a uniquely ergodic subshift. In this paper we describe the construction of\n$\\nu_w$ for the case when the subshift of $w$ is generated by a morphism of a\nspecial kind; then we overcome some technical difficulties to extend the result\nto all binary morphisms. The sequence $\\nu_w$ in this case is also constructed\nwith a morphism.\n  At last, we introduce a software tool which, given a binary morphism\n$\\varphi$, computes the morphism on extended intervals and first elements of\nthe equidistributed sequences associated with fixed points of $\\varphi$.\n", "versions": [{"version": "v1", "created": "Sun, 22 Jul 2018 17:07:30 GMT"}, {"version": "v2", "created": "Sat, 4 Aug 2018 04:48:50 GMT"}, {"version": "v3", "created": "Fri, 22 Nov 2019 14:32:51 GMT"}], "update_date": "2019-11-25", "authors_parsed": [["Andrieu", "M\u00e9lodie", ""], ["Frid", "Anna E.", ""]]}, {"id": "1807.08487", "submitter": "Ond\\v{r}ej Leng\\'al", "authors": "Luk\\'a\\v{s} Hol\\'ik, Ond\\v{r}ej Leng\\'al, Juraj S\\'i\\v{c}, Margus\n  Veanes, Tom\\'a\\v{s} Vojnar", "title": "Simulation Algorithms for Symbolic Automata (Technical Report)", "comments": "To appear in ATVA'18", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate means of efficient computation of the simulation relation over\nsymbolic finite automata (SFAs), i.e., finite automata with transitions labeled\nby predicates over alphabet symbols. In one approach, we build on the algorithm\nby Ilie, Navaro, and Yu proposed originally for classical finite automata,\nmodifying it using the so-called mintermisation of the transition predicates.\nThis solution, however, generates all Boolean combinations of the predicates,\nwhich easily causes an exponential blowup in the number of transitions.\nTherefore, we propose two more advanced solutions. The first one still applies\nmintermisation but in a local way, mitigating the size of the exponential\nblowup. The other one focuses on a novel symbolic way of dealing with\ntransitions, for which we need to sacrifice the counting technique of the\noriginal algorithm (counting is used to decrease the dependency of the running\ntime on the number of transitions from quadratic to linear). We perform a\nthorough experimental evaluation of all the algorithms, together with several\nfurther alternatives, showing that all of them have their merits in practice,\nbut with the clear indication that in most of the cases, efficient treatment of\nsymbolic transitions is more beneficial than counting.\n", "versions": [{"version": "v1", "created": "Mon, 23 Jul 2018 08:59:11 GMT"}, {"version": "v2", "created": "Fri, 27 Jul 2018 14:20:21 GMT"}], "update_date": "2018-07-30", "authors_parsed": [["Hol\u00edk", "Luk\u00e1\u0161", ""], ["Leng\u00e1l", "Ond\u0159ej", ""], ["S\u00ed\u010d", "Juraj", ""], ["Veanes", "Margus", ""], ["Vojnar", "Tom\u00e1\u0161", ""]]}, {"id": "1807.08648", "submitter": "Luca Ferrari", "authors": "Lapo Cioni, Luca Ferrari", "title": "Enumerative Results on the Schr\\\"oder Pattern Poset", "comments": "12 pages, 1 figure", "journal-ref": "In: Dennunzio A., Formenti E., Manzoni L., Porreca A. (eds)\n  Cellular Automata and Discrete Complex Systems. AUTOMATA 2017. Lecture Notes\n  in Computer Science, vol 10248. Springer, Cham", "doi": "10.1007/978-3-319-58631-1_5", "report-no": null, "categories": "math.CO cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The set of Schr\\\"oder words (Schr\\\"oder language) is endowed with a natural\npartial order, which can be conveniently described by interpreting Schr\\\"oder\nwords as lattice paths. The resulting poset is called the Schr\\\"oder pattern\nposet. We find closed formulas for the number of Schr\\\"oder words\ncovering/covered by a given Schr\\\"oder word in terms of classical parameters of\nthe associated Schr\\\"oder path. We also enumerate several classes of Schr\\\"oder\navoiding words (with respect to the length), i.e. sets of Schr\\\"oder words\nwhich do not contain a given Schr\\\"oder word.\n", "versions": [{"version": "v1", "created": "Mon, 23 Jul 2018 14:46:14 GMT"}], "update_date": "2018-07-24", "authors_parsed": [["Cioni", "Lapo", ""], ["Ferrari", "Luca", ""]]}, {"id": "1807.09047", "submitter": "Felix Klein", "authors": "Carsten Gerstacker, Felix Klein, and Bernd Finkbeiner", "title": "Bounded Synthesis of Reactive Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most algorithms for the synthesis of reactive systems focus on the\nconstruction of finite-state machines rather than actual programs. This often\nleads to badly structured, unreadable code. In this paper, we present a bounded\nsynthesis approach that automatically constructs, from a given specification in\nlinear-time temporal logic (LTL), a program in Madhusudan's simple imperative\nlanguage for reactive programs. We develop and compare two principal approaches\nfor the reduction of the synthesis problem to a Boolean constraint satisfaction\nproblem. The first reduction is based on a generalization of bounded synthesis\nto two-way alternating automata, the second reduction is based on a direct\nencoding of the program syntax in the constraint system. We report on\npreliminary experience with a prototype implementation, which indicates that\nthe direct encoding outperforms the automata approach.\n", "versions": [{"version": "v1", "created": "Tue, 24 Jul 2018 11:36:31 GMT"}], "update_date": "2018-07-25", "authors_parsed": [["Gerstacker", "Carsten", ""], ["Klein", "Felix", ""], ["Finkbeiner", "Bernd", ""]]}, {"id": "1807.10015", "submitter": "David Purser", "authors": "Dmitry Chistikov, Andrzej S. Murawski, David Purser", "title": "Bisimilarity Distances for Approximate Differential Privacy", "comments": "To appear International Symposium on Automated Technology for\n  Verification and Analysis // October 7-10, 2018", "journal-ref": null, "doi": "10.1007/978-3-030-01090-4_12", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Differential privacy is a widely studied notion of privacy for various models\nof computation. Technically, it is based on measuring differences between\nprobability distributions. We study $\\epsilon,\\delta$-differential privacy in\nthe setting of labelled Markov chains. While the exact differences relevant to\n$\\epsilon,\\delta$-differential privacy are not computable in this framework, we\npropose a computable bisimilarity distance that yields a sound technique for\nmeasuring $\\delta$, the parameter that quantifies deviation from pure\ndifferential privacy. We show this bisimilarity distance is always rational,\nthe associated threshold problem is in NP, and the distance can be computed\nexactly with polynomially many calls to an NP oracle.\n", "versions": [{"version": "v1", "created": "Thu, 26 Jul 2018 08:52:17 GMT"}, {"version": "v2", "created": "Thu, 13 Sep 2018 15:52:28 GMT"}], "update_date": "2020-07-16", "authors_parsed": [["Chistikov", "Dmitry", ""], ["Murawski", "Andrzej S.", ""], ["Purser", "David", ""]]}, {"id": "1807.10546", "submitter": "Marcin Jurdzi\\'nski", "authors": "Wojciech Czerwi\\'nski, Laure Daviaud, Nathana\\\"el Fijalkow, Marcin\n  Jurdzi\\'nski, Ranko Lazi\\'c, Pawe{\\l} Parys", "title": "Universal trees grow inside separating automata: Quasi-polynomial lower\n  bounds for parity games", "comments": "To appear in SODA 2019", "journal-ref": null, "doi": "10.1137/1.9781611975482.142", "report-no": null, "categories": "cs.FL cs.CC cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Several distinct techniques have been proposed to design quasi-polynomial\nalgorithms for solving parity games since the breakthrough result of Calude,\nJain, Khoussainov, Li, and Stephan (2017): play summaries, progress measures\nand register games. We argue that all those techniques can be viewed as\ninstances of the separation approach to solving parity games, a key technical\ncomponent of which is constructing (explicitly or implicitly) an automaton that\nseparates languages of words encoding plays that are (decisively) won by either\nof the two players. Our main technical result is a quasi-polynomial lower bound\non the size of such separating automata that nearly matches the current best\nupper bounds. This forms a barrier that all existing approaches must overcome\nin the ongoing quest for a polynomial-time algorithm for solving parity games.\nThe key and fundamental concept that we introduce and study is a universal\nordered tree. The technical highlights are a quasi-polynomial lower bound on\nthe size of universal ordered trees and a proof that every separating safety\nautomaton has a universal tree hidden in its state space.\n", "versions": [{"version": "v1", "created": "Fri, 27 Jul 2018 12:05:29 GMT"}, {"version": "v2", "created": "Fri, 2 Nov 2018 12:02:01 GMT"}], "update_date": "2020-01-15", "authors_parsed": [["Czerwi\u0144ski", "Wojciech", ""], ["Daviaud", "Laure", ""], ["Fijalkow", "Nathana\u00ebl", ""], ["Jurdzi\u0144ski", "Marcin", ""], ["Lazi\u0107", "Ranko", ""], ["Parys", "Pawe\u0142", ""]]}, {"id": "1807.11570", "submitter": "EPTCS", "authors": "Pujie Han (Northwestern Polytechnical University), Zhengjun Zhai\n  (Northwestern Polytechnical University), Brian Nielsen (Aalborg University),\n  Ulrik Nyman (Aalborg University)", "title": "A Compositional Approach for Schedulability Analysis of Distributed\n  Avionics Systems", "comments": "In Proceedings MeTRiD 2018, arXiv:1806.09330. arXiv admin note: text\n  overlap with arXiv:1803.11050", "journal-ref": "EPTCS 272, 2018, pp. 39-51", "doi": "10.4204/EPTCS.272.4", "report-no": null, "categories": "cs.LO cs.FL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work presents a compositional approach for schedulability analysis of\nDistributed Integrated Modular Avionics (DIMA) systems that consist of\nspatially distributed ARINC-653 modules connected by a unified AFDX network. We\nmodel a DIMA system as a set of stopwatch automata in UPPAAL to verify its\nschedulability by model checking. However, direct model checking is infeasible\ndue to the large state space. Therefore, we introduce the compositional\nanalysis that checks each partition including its communication environment\nindividually. Based on a notion of message interfaces, a number of message\nsender automata are built to model the environment for a partition. We define a\ntimed selection simulation relation, which supports the construction of\ncomposite message interfaces. By using assume-guarantee reasoning, we ensure\nthat each task meets the deadline and that communication constraints are also\nfulfilled globally. The approach is applied to the analysis of a concrete DIMA\nsystem.\n", "versions": [{"version": "v1", "created": "Tue, 26 Jun 2018 08:52:55 GMT"}], "update_date": "2018-08-01", "authors_parsed": [["Han", "Pujie", "", "Northwestern Polytechnical University"], ["Zhai", "Zhengjun", "", "Northwestern Polytechnical University"], ["Nielsen", "Brian", "", "Aalborg University"], ["Nyman", "Ulrik", "", "Aalborg University"]]}, {"id": "1807.11580", "submitter": "Ryo Yoshinaka", "authors": "Yuki Nozaki, Diptarama Hendrian, Ryo Yoshinaka, Takashi Horiyama,\n  Ayumi Shinohara", "title": "Enumerating Cryptarithms Using Deterministic Finite Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A cryptarithm is a mathematical puzzle where given an arithmetic equation\nwritten with letters rather than numerals, a player must discover an assignment\nof numerals on letters that makes the equation hold true. In this paper, we\npropose a method to construct a DFA that accepts cryptarithms that admit\n(unique) solutions for each base. We implemented the method and constructed a\nDFA for bases $k \\le 7$. Those DFAs can be used as complete catalogues of\ncryptarithms,whose applications include enumeration of and counting the exact\nnumbers $G_k(n)$ of cryptarithm instances with $n$ digits that admit base-$k$\nsolutions. Moreover, explicit formulas for $G_2(n)$ and $G_3(n)$ are given.\n", "versions": [{"version": "v1", "created": "Fri, 27 Jul 2018 01:37:45 GMT"}], "update_date": "2018-08-01", "authors_parsed": [["Nozaki", "Yuki", ""], ["Hendrian", "Diptarama", ""], ["Yoshinaka", "Ryo", ""], ["Horiyama", "Takashi", ""], ["Shinohara", "Ayumi", ""]]}, {"id": "1807.11899", "submitter": "Narad Rampersad", "authors": "Narad Rampersad and Manon Stipulanti", "title": "The Formal Inverse of the Period-Doubling Sequence", "comments": "20 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  If $p$ is a prime number, consider a $p$-automatic sequence $(u_n)_{n\\ge 0}$,\nand let $U(X) = \\sum_{n\\ge 0} u_n X^n \\in \\mathbb{F}_p[[X]]$ be its generating\nfunction. Assume that there exists a formal power series $V(X) = \\sum_{n\\ge 0}\nv_n X^n \\in \\mathbb{F}_p[[X]]$ which is the compositional inverse of $U$, i.e.,\n$U(V(X))=X=V(U(X))$. The problem investigated in this paper is to study the\nproperties of the sequence $(v_n)_{n\\ge 0}$. The work was first initiated for\nthe Thue-Morse sequence, and more recently the case of two variations of the\nBaum-Sweet sequence has been treated. In this paper, we deal with the case of\nthe period-doubling sequence. We first show that the sequence of indices at\nwhich the period-doubling sequence takes value $0$ (resp., $1$) is not\n$k$-regular for any $k\\ge 2$. Secondly, we give recurrence relations for its\nformal inverse, then we easily show that it is $2$-automatic, and we also\nprovide an automaton that generates it. Thirdly, we study the sequence of\nindices at which this formal inverse takes value $1$, and we show that it is\nnot $k$-regular for any $k\\ge 2$ by connecting it to the characteristic\nsequence of Fibonacci numbers. We leave as an open problem the case of the\nsequence of indices at which this formal inverse takes value $0$. We end the\npaper with a remark on the case of generalized Thue-Morse sequences.\n", "versions": [{"version": "v1", "created": "Tue, 31 Jul 2018 16:22:08 GMT"}], "update_date": "2018-08-01", "authors_parsed": [["Rampersad", "Narad", ""], ["Stipulanti", "Manon", ""]]}]