[{"id": "2005.00255", "submitter": "Olivier Carton", "authors": "Olivier Carton", "title": "A direct proof of Agafonov's theorem and an extension to shift of finite\n  type", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.NT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide a direct proof of Agafonov's theorem which states that finite\nstate selection preserves normality. We also extends this result to the more\ngeneral setting of shifts of finite type by defining selections which are\ncompatible the shift. A slightly more general statement is obtained as we show\nthat any Markov measure is preserved by finite state compatible selection.\n", "versions": [{"version": "v1", "created": "Fri, 1 May 2020 07:36:43 GMT"}, {"version": "v2", "created": "Mon, 11 May 2020 09:05:07 GMT"}, {"version": "v3", "created": "Wed, 13 May 2020 13:26:10 GMT"}], "update_date": "2020-05-14", "authors_parsed": [["Carton", "Olivier", ""]]}, {"id": "2005.00359", "submitter": "Peter beim Graben", "authors": "Peter beim Graben, Ronald R\\\"omer, Werner Meyer, Markus Huber,\n  Matthias Wolff", "title": "Reinforcement learning of minimalist grammars", "comments": "25 pages, 2 figures, 9 tables. arXiv admin note: text overlap with\n  arXiv:1906.04447", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Speech-controlled user interfaces facilitate the operation of devices and\nhousehold functions to laymen. State-of-the-art language technology scans the\nacoustically analyzed speech signal for relevant keywords that are subsequently\ninserted into semantic slots to interpret the user's intent. In order to\ndevelop proper cognitive information and communication technologies, simple\nslot-filling should be replaced by utterance meaning transducers (UMT) that are\nbased on semantic parsers and a mental lexicon, comprising syntactic, phonetic\nand semantic features of the language under consideration. This lexicon must be\nacquired by a cognitive agent during interaction with its users. We outline a\nreinforcement learning algorithm for the acquisition of syntax and semantics of\nEnglish utterances, based on minimalist grammar (MG), a recent computational\nimplementation of generative linguistics. English declarative sentences are\npresented to the agent by a teacher in form of utterance meaning pairs (UMP)\nwhere the meanings are encoded as formulas of predicate logic. Since MG\ncodifies universal linguistic competence through inference rules, thereby\nseparating innate linguistic knowledge from the contingently acquired lexicon,\nour approach unifies generative grammar and reinforcement learning, hence\npotentially resolving the still pending Chomsky-Skinner controversy.\n", "versions": [{"version": "v1", "created": "Thu, 30 Apr 2020 14:25:58 GMT"}], "update_date": "2020-05-04", "authors_parsed": [["Graben", "Peter beim", ""], ["R\u00f6mer", "Ronald", ""], ["Meyer", "Werner", ""], ["Huber", "Markus", ""], ["Wolff", "Matthias", ""]]}, {"id": "2005.00373", "submitter": "Maria Elena Valcher", "authors": "Fabio A. Schreiber and Maria Elena Valcher", "title": "Formal assessment of some properties of Context-Aware Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Context-Aware systems are becoming useful components in autonomic and\nmonitoring applications and the assessment of their properties is an important\nstep towards reliable implementation, especially in safety-critical\napplications. In this paper, using an avalanche/landslide alert system as a\nrunning example, we propose a technique, based on Boolean Control Networks, to\nverify that the system dynamics has stable equilibrium states, corresponding to\nconstant inputs, and hence it does not exhibit oscillatory behaviors, and to\nestablish other useful properties in order to implement a precise and timely\nalarm system.\n", "versions": [{"version": "v1", "created": "Fri, 1 May 2020 13:35:04 GMT"}], "update_date": "2020-05-04", "authors_parsed": [["Schreiber", "Fabio A.", ""], ["Valcher", "Maria Elena", ""]]}, {"id": "2005.00472", "submitter": "Salomon Sickert", "authors": "Salomon Sickert, Javier Esparza", "title": "An Efficient Normalisation Procedure for Linear Temporal Logic and Very\n  Weak Alternating Automata", "comments": "This is the extended version of the referenced conference paper and\n  contains an appendix with additional material", "journal-ref": null, "doi": "10.1145/3373718.3394743", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the mid 80s, Lichtenstein, Pnueli, and Zuck proved a classical theorem\nstating that every formula of Past LTL (the extension of LTL with past\noperators) is equivalent to a formula of the form $\\bigwedge_{i=1}^n\n\\mathbf{G}\\mathbf{F} \\varphi_i \\vee \\mathbf{F}\\mathbf{G} \\psi_i$, where\n$\\varphi_i$ and $\\psi_i$ contain only past operators. Some years later, Chang,\nManna, and Pnueli built on this result to derive a similar normal form for LTL.\nBoth normalisation procedures have a non-elementary worst-case blow-up, and\nfollow an involved path from formulas to counter-free automata to star-free\nregular expressions and back to formulas. We improve on both points. We present\na direct and purely syntactic normalisation procedure for LTL yielding a normal\nform, comparable to the one by Chang, Manna, and Pnueli, that has only a single\nexponential blow-up. As an application, we derive a simple algorithm to\ntranslate LTL into deterministic Rabin automata. The algorithm normalises the\nformula, translates it into a special very weak alternating automaton, and\napplies a simple determinisation procedure, valid only for these special\nautomata.\n", "versions": [{"version": "v1", "created": "Fri, 1 May 2020 16:24:24 GMT"}], "update_date": "2020-05-04", "authors_parsed": [["Sickert", "Salomon", ""], ["Esparza", "Javier", ""]]}, {"id": "2005.00990", "submitter": "Philipp R\\\"ummer", "authors": "Anthony W. Lin, Philipp R\\\"ummer", "title": "Regular Model Checking Revisited (Technical Report)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this contribution we revisit regular model checking, a powerful framework\nthat has been successfully applied for the verification of infinite-state\nsystems, especially parameterized systems (concurrent systems with an arbitrary\nnumber of processes). We provide a reformulation of regular model checking with\nlength-preserving transducers in terms of existential second-order theory over\nautomatic structures. We argue that this is a natural formulation that enables\nus tap into powerful synthesis techniques that have been extensively studied in\nthe software verification community. More precisely, in this formulation the\nfirst-order part represents the verification conditions for the desired\ncorrectness property (for which we have complete solvers), whereas the\nexistentially quantified second-order variables represent the relations to be\nsynthesized. We show that many interesting correctness properties can be\nformulated in this way, examples being safety, liveness, bisimilarity, and\ngames. More importantly, we show that this new formulation allows new\ninteresting benchmarks (and old regular model checking benchmarks that were\npreviously believed to be difficult), especially in the domain of parameterized\nsystem verification, to be solved.\n", "versions": [{"version": "v1", "created": "Sun, 3 May 2020 05:29:15 GMT"}], "update_date": "2020-05-05", "authors_parsed": [["Lin", "Anthony W.", ""], ["R\u00fcmmer", "Philipp", ""]]}, {"id": "2005.01071", "submitter": "Ritam Raha", "authors": "Guillermo A. P\\'erez (1), Ritam Raha (1 and 2) ((1) University of\n  Antwerp, Antwerp, Belgium, (2) LaBRI, University of Bordeaux, Bordeaux,\n  France)", "title": "Revisiting Synthesis for One-Counter Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the (parameter) synthesis problem for one-counter automata with\nparameters. One-counter automata are obtained by extending classical\nfinite-state automata with a counter whose value can range over non-negative\nintegers and be tested for zero. The updates and tests applicable to the\ncounter can further be made parametric by introducing a set of integer-valued\nvariables called parameters. The synthesis problem for such automata asks\nwhether there exists a valuation of the parameters such that all infinite runs\nof the automaton satisfy some omega-regular property. Lechner showed that (the\ncomplement of) the problem can be encoded in a restricted one-alternation\nfragment of Presburger arithmetic with divisibility. In this work (i) we argue\nthat said fragment, called AERPADPLUS, is unfortunately undecidable.\nNevertheless, by a careful re-encoding of the problem into a decidable\nrestriction of AERPADPLUS, (ii) we prove that the synthesis problem is\ndecidable in general and in N2EXP for several fixed omega-regular properties.\nFinally, (iii) we give a polynomial-space algorithm for the special case of the\nproblem where parameters can only be used in tests, and not updates, of the\ncounter.\n", "versions": [{"version": "v1", "created": "Sun, 3 May 2020 12:30:11 GMT"}, {"version": "v2", "created": "Thu, 1 Oct 2020 10:15:25 GMT"}, {"version": "v3", "created": "Fri, 29 Jan 2021 11:16:52 GMT"}, {"version": "v4", "created": "Thu, 29 Apr 2021 17:26:28 GMT"}], "update_date": "2021-04-30", "authors_parsed": [["P\u00e9rez", "Guillermo A.", "", "1 and 2"], ["Raha", "Ritam", "", "1 and 2"]]}, {"id": "2005.01112", "submitter": "Maria Kosche", "authors": "Pawel Gawrychowski, Maria Kosche, Tore Koss, Florin Manea, Stefan\n  Siemer", "title": "Efficiently Testing Simon's Congruence", "comments": null, "journal-ref": null, "doi": "10.4230/LIPIcs.STACS.2021.34", "report-no": null, "categories": "cs.FL cs.DS", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Simon's congruence $\\sim_k$ is defined as follows: two words are\n$\\sim_k$-equivalent if they have the same set of subsequences of length at most\n$k$. We propose an algorithm which computes, given two words $s$ and $t$, the\nlargest $k$ for which $s\\sim_k t$. Our algorithm runs in linear time\n$O(|s|+|t|)$ when the input words are over the integer alphabet\n$\\{1,\\ldots,|s|+|t|\\}$ (or other alphabets which can be sorted in linear time).\nThis approach leads to an optimal algorithm in the case of general alphabets as\nwell. Our results are based on a novel combinatorial approach and a series of\nefficient data structures.\n", "versions": [{"version": "v1", "created": "Sun, 3 May 2020 15:15:47 GMT"}, {"version": "v2", "created": "Mon, 15 Mar 2021 16:31:53 GMT"}], "update_date": "2021-03-16", "authors_parsed": [["Gawrychowski", "Pawel", ""], ["Kosche", "Maria", ""], ["Koss", "Tore", ""], ["Manea", "Florin", ""], ["Siemer", "Stefan", ""]]}, {"id": "2005.01342", "submitter": "Ga\\\"etan Dou\\'eneau-Tabot", "authors": "Ga\\\"etan Dou\\'eneau-Tabot and Emmanuel Filiot and Paul Gastin", "title": "Register transducers are marble transducers", "comments": "28 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deterministic two-way transducers define the class of regular functions from\nwords to words. Alur and Cern\\'y introduced an equivalent model of transducers\nwith registers called copyless streaming string transducers. In this paper, we\ndrop the \"copyless\" restriction on these machines and show that they are\nequivalent to two-way transducers enhanced with the ability to drop marks,\nnamed \"marbles\", on the input. We relate the maximal number of marbles used\nwith the amount of register copies performed by the streaming string\ntransducer. Finally, we show that the class membership problems associated with\nthese models are decidable. Our results can be interpreted in terms of program\noptimization for simple recursive and iterative programs.\n", "versions": [{"version": "v1", "created": "Mon, 4 May 2020 09:35:19 GMT"}], "update_date": "2020-05-05", "authors_parsed": [["Dou\u00e9neau-Tabot", "Ga\u00ebtan", ""], ["Filiot", "Emmanuel", ""], ["Gastin", "Paul", ""]]}, {"id": "2005.01371", "submitter": "Josef Rukavicka", "authors": "Josef Rukavicka", "title": "Palindromic Length of Words with Many Periodic Palindromes", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-62536-8_14", "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The palindromic length $\\text{PL}(v)$ of a finite word $v$ is the minimal\nnumber of palindromes whose concatenation is equal to $v$. In 2013, Frid,\nPuzynina, and Zamboni conjectured that: If $w$ is an infinite word and $k$ is\nan integer such that $\\text{PL}(u)\\leq k$ for every factor $u$ of $w$ then $w$\nis ultimately periodic.\n  Suppose that $w$ is an infinite word and $k$ is an integer such\n$\\text{PL}(u)\\leq k$ for every factor $u$ of $w$. Let $\\Omega(w,k)$ be the set\nof all factors $u$ of $w$ that have more than $\\sqrt[k]{k^{-1}\\vert u\\vert}$\npalindromic prefixes. We show that $\\Omega(w,k)$ is an infinite set and we show\nthat for each positive integer $j$ there are palindromes $a,b$ and a word $u\\in\n\\Omega(w,k)$ such that $(ab)^j$ is a factor of $u$ and $b$ is nonempty. Note\nthat $(ab)^j$ is a periodic word and $(ab)^ia$ is a palindrome for each $i\\leq\nj$. These results justify the following question: What is the palindromic\nlength of a concatenation of a suffix of $b$ and a periodic word $(ab)^j$ with\n\"many\" periodic palindromes?\n  It is known that $\\lvert\\text{PL}(uv)-\\text{PL}(u)\\rvert\\leq \\text{PL}(v)$,\nwhere $u$ and $v$ are nonempty words. The main result of our article shows that\nif $a,b$ are palindromes, $b$ is nonempty, $u$ is a nonempty suffix of $b$,\n$\\vert ab\\vert$ is the minimal period of $aba$, and $j$ is a positive integer\nwith $j\\geq3\\text{PL}(u)$ then $\\text{PL}(u(ab)^j)-\\text{PL}(u)\\geq 0$.\n", "versions": [{"version": "v1", "created": "Mon, 4 May 2020 10:34:07 GMT"}], "update_date": "2020-11-17", "authors_parsed": [["Rukavicka", "Josef", ""]]}, {"id": "2005.01374", "submitter": "Petra Wolf", "authors": "Henning Fernau and Petra Wolf", "title": "Synchronization of Deterministic Visibly Push-Down Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We generalize the concept of synchronizing words for finite automata, which\nmap all states of the automata to the same state, to deterministic visibly\npush-down automata. Here, a synchronizing word w does not only map all states\nto the same state but also fulfills some conditions on the stack content of\neach run after reading w. We consider three types of these stack constraints:\nafter reading w, the stack (1) is empty in each run, (2) contains the same\nsequence of stack symbols in each run, or (3) contains an arbitrary sequence\nwhich is independent of the other runs. We show that in contrast to general\ndeterministic push-down automata, it is decidable for deterministic visibly\npush-down automata whether there exists a synchronizing word with each of these\nstack constraints, i.e., the problems are in EXPTIME. Under the constraint (1)\nthe problem is even in P. For the sub-classes of deterministic very visibly\npush-down automata the problem is in P for all three types of constraints. We\nfurther study variants of the synchronization problem where the number of turns\nin the stack height behavior caused by a synchronizing word is restricted, as\nwell as the problem of synchronizing a variant of a sequential transducer,\nwhich shows some visibly behavior, by a word that synchronizes the states and\nproduces the same output on all runs.\n", "versions": [{"version": "v1", "created": "Mon, 4 May 2020 10:39:00 GMT"}, {"version": "v2", "created": "Tue, 5 May 2020 11:17:21 GMT"}, {"version": "v3", "created": "Fri, 17 Jul 2020 15:41:03 GMT"}], "update_date": "2020-07-20", "authors_parsed": [["Fernau", "Henning", ""], ["Wolf", "Petra", ""]]}, {"id": "2005.01381", "submitter": "Petra Wolf", "authors": "Henning Fernau and Petra Wolf and Tomoyuki Yamakami", "title": "Synchronizing Deterministic Push-Down Automata Can Be Really Hard", "comments": "arXiv admin note: text overlap with arXiv:2005.01374", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The question if a deterministic finite automaton admits a software reset in\nthe form of a so-called synchronizing word can be answered in polynomial time.\nIn this paper, we extend this algorithmic question to deterministic automata\nbeyond finite automata. We prove that the question of synchronizability becomes\nundecidable even when looking at deterministic one-counter automata. This is\nalso true for another classical mild extension of regularity, namely that of\ndeterministic one-turn push-down automata. However, when we combine both\nrestrictions, we arrive at scenarios with a PSPACE-complete (and hence\ndecidable) synchronizability problem. Likewise, we arrive at a decidable\nsynchronizability problem for (partially) blind deterministic counter automata.\n  There are several interpretations of what synchronizability should mean for\ndeterministic push-down automata. This is depending on the role of the stack:\nshould it be empty on synchronization, should it be always the same or is it\narbitrary? For the automata classes studied in this paper, the complexity or\ndecidability status of the synchronizability problem is mostly independent of\nthis technicality, but we also discuss one class of automata where this makes a\ndifference.\n", "versions": [{"version": "v1", "created": "Mon, 4 May 2020 10:54:45 GMT"}, {"version": "v2", "created": "Tue, 5 May 2020 11:23:33 GMT"}, {"version": "v3", "created": "Tue, 22 Dec 2020 15:26:25 GMT"}], "update_date": "2020-12-23", "authors_parsed": [["Fernau", "Henning", ""], ["Wolf", "Petra", ""], ["Yamakami", "Tomoyuki", ""]]}, {"id": "2005.01419", "submitter": "Maximilian Weininger", "authors": "Loris D'Antoni, Martin Helfrich, Jan Kretinsky, Emanuel Ramneantu,\n  Maximilian Weininger", "title": "Automata Tutor v3", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-53291-8_1", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computer science class enrollments have rapidly risen in the past decade.\nWith current class sizes, standard approaches to grading and providing\npersonalized feedback are no longer possible and new techniques become both\nfeasible and necessary. In this paper, we present the third version of Automata\nTutor, a tool for helping teachers and students in large courses on automata\nand formal languages. The second version of Automata Tutor supported automatic\ngrading and feedback for finite-automata constructions and has already been\nused by thousands of users in dozens of countries. This new version of Automata\nTutor supports automated grading and feedback generation for a greatly extended\nvariety of new problems, including problems that ask students to create regular\nexpressions, context-free grammars, pushdown automata and Turing machines\ncorresponding to a given description, and problems about converting between\nequivalent models - e.g., from regular expressions to nondeterministic finite\nautomata. Moreover, for several problems, this new version also enables\nteachers and students to automatically generate new problem instances. We also\npresent the results of a survey run on a class of 950 students, which shows\nvery positive results about the usability and usefulness of the tool.\n", "versions": [{"version": "v1", "created": "Mon, 4 May 2020 12:19:19 GMT"}, {"version": "v2", "created": "Thu, 7 May 2020 16:26:34 GMT"}, {"version": "v3", "created": "Fri, 8 May 2020 07:00:39 GMT"}, {"version": "v4", "created": "Thu, 14 May 2020 14:27:35 GMT"}], "update_date": "2021-02-02", "authors_parsed": [["D'Antoni", "Loris", ""], ["Helfrich", "Martin", ""], ["Kretinsky", "Jan", ""], ["Ramneantu", "Emanuel", ""], ["Weininger", "Maximilian", ""]]}, {"id": "2005.01480", "submitter": "Genaro J. Martinez", "authors": "Genaro J. Martinez, Andrew Adamatzky, Rolf Hoffmann, Dominique\n  Deserable, Ivan Zelinka", "title": "On patterns and dynamics of Rule 22 cellular automaton", "comments": "50 pages, 28 figures, 7 tables", "journal-ref": "Complex Systems, Volume 28, Issue 2, 2019", "doi": "10.25088/ComplexSystems.28.2.125", "report-no": null, "categories": "nlin.CG cs.FL nlin.AO nlin.CD nlin.PS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Rule 22 elementary cellular automaton (ECA) has a 3--cell neighborhood,\nbinary cell states, where a cell takes state `1' if there is exactly one\nneighbor, including the cell itself, in state `1'. In Boolean terms the\ncell-state transition is a XOR function of three cell states. In\nphysico--chemical terms the rule might be seen as describing propagation of\nself-inhibiting quantities/species. Space-time dynamics of Rule 22 demonstrates\nnon-trivial patterns and quasi-chaotic behavior. We characterize the phenomena\nobserved in this rule using mean field theory, attractors, de Bruijn diagrams,\nsubset diagrams, filters, fractals and memory.\n", "versions": [{"version": "v1", "created": "Mon, 4 May 2020 13:36:48 GMT"}], "update_date": "2020-05-05", "authors_parsed": [["Martinez", "Genaro J.", ""], ["Adamatzky", "Andrew", ""], ["Hoffmann", "Rolf", ""], ["Deserable", "Dominique", ""], ["Zelinka", "Ivan", ""]]}, {"id": "2005.02596", "submitter": "M. Praveen", "authors": "M. Praveen", "title": "What You Must Remember When Transforming Datawords", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Streaming Data String Transducers (SDSTs) were introduced to model a class of\nimperative and a class of functional programs, manipulating lists of data\nitems. These can be used to write commonly used routines such as insert, delete\nand reverse. SDSTs can handle data values from a potentially infinite data\ndomain. The model of Streaming String Transducers (SSTs) is the fragment of\nSDSTs where the infinite data domain is dropped and only finite alphabets are\nconsidered. SSTs have been much studied from a language theoretical point of\nview. We introduce data back into SSTs, just like data was introduced to finite\nstate automata to get register automata. The result is Streaming String\nRegister Transducers (SSRTs), which is a subclass of SDSTs. SDSTs can compare\ndata values using a linear order on the data domain, which can not be done by\nSSRTs.\n  We give a machine independent characterization of SSRTs with origin\nsemantics, along the lines of Myhill-Nerode theorem. Machine independent\ncharacterizations for similar models have formed the basis of learning\nalgorithms and enabled us to understand fragments of the models. Origin\nsemantics of transducers track which positions of the output originate from\nwhich positions of the input. Although a restriction, using origin semantics is\nwell justified and known to simplify many problems related to transducers. We\nuse origin semantics as a technical building block, in addition to\ncharacterizations of deterministic register automata. However, we need to build\nmore on top of these to overcome some challenges unique to SSRTs.\n", "versions": [{"version": "v1", "created": "Wed, 6 May 2020 05:13:23 GMT"}, {"version": "v2", "created": "Mon, 14 Dec 2020 04:27:26 GMT"}], "update_date": "2020-12-15", "authors_parsed": [["Praveen", "M.", ""]]}, {"id": "2005.03435", "submitter": "Patrick Totzke", "authors": "Shaull Almagor, Udi Boker, Piotr Hofman, Patrick Totzke", "title": "Parametrized Universality Problems for One-Counter Nets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the language universality problem for One-Counter Nets, also known\nas 1-dimensional Vector Addition Systems with States (1-VASS), parameterized\neither with an initial counter value, or with an upper bound on the allowed\ncounter value during runs. The language accepted by an OCN (defined by reaching\na final control state) is monotone in both parameters. This yields two natural\nquestions: 1) Does there exist an initial counter value that makes the language\nuniversal? 2) Does there exist a sufficiently high ceiling so that the bounded\nlanguage is universal? Although the ordinary universality problem is decidable\n(and Ackermann-complete) and these parameterized problems seem to reduce to\nchecking basic structural properties of the underlying automaton, we show that\nin fact both problems are undecidable. We also look into the complexities of\nthe problems for several decidable subclasses, namely for unambiguous, and\ndeterministic systems, and for those over a single-letter alphabet.\n", "versions": [{"version": "v1", "created": "Thu, 7 May 2020 13:04:15 GMT"}, {"version": "v2", "created": "Sat, 4 Jul 2020 12:02:21 GMT"}], "update_date": "2020-07-07", "authors_parsed": [["Almagor", "Shaull", ""], ["Boker", "Udi", ""], ["Hofman", "Piotr", ""], ["Totzke", "Patrick", ""]]}, {"id": "2005.04042", "submitter": "Stefan Hoffmann", "authors": "Stefan Hoffmann", "title": "Computational Complexity of Synchronization under Regular Commutative\n  Constraints", "comments": "Published in COCOON 2020 (The 26th International Computing and\n  Combinatorics Conference); 2nd version is update of the published version and\n  1st version; both contain a minor error, the assumption of maximality in the\n  NP-c and PSPACE-c results (propositions 5 & 6) is missing, and of\n  incomparability of the vectors in main theorem; fixed in this version. See\n  (new) discussion after main theorem", "journal-ref": "Computing and Combinatorics, 26th International Conference, COCOON\n  2020, Proceedings, pages 460-471", "doi": "10.1007/978-3-030-58150-3_37", "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Here we study the computational complexity of the constrained synchronization\nproblem for the class of regular commutative constraint languages. Utilizing a\nvector representation of regular commutative constraint languages, we give a\nfull classification of the computational complexity of the constraint\nsynchronization problem. Depending on the constraint language, our problem\nbecomes PSPACE-complete, NP-complete or polynomial time solvable. In addition,\nwe derive a polynomial time decision procedure for the complexity of the\nconstraint synchronization problem, given some constraint automaton accepting a\ncommutative language as input.\n", "versions": [{"version": "v1", "created": "Fri, 8 May 2020 13:43:23 GMT"}, {"version": "v2", "created": "Wed, 2 Sep 2020 20:12:21 GMT"}], "update_date": "2020-09-04", "authors_parsed": [["Hoffmann", "Stefan", ""]]}, {"id": "2005.04486", "submitter": "Vladislav Makarov", "authors": "Vladislav Makarov", "title": "Playing odds and evens with finite automata", "comments": "As pointed out by an anonymous reviewer, all the main results of this\n  paper were proven before on a higher level of generality", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper is concerned with asymptotic behaviour of a repeated game of \"odds\nand evens\", with strategies of both players represented by finite automata. It\nis proved that, for every $n$, there is an automaton with $2^n \\cdot\n\\mathrm{poly}(n)$ states which defeats every $n$-state automaton, in the sense\nthat it wins all rounds except for finitely many. Moreover, every such\nautomaton has at least $2^n \\cdot (1 - o(1))$ states, meaning that the upper\nbound is tight up to polynomial factors. This is a significant improvement over\na classic result of Ben-Porath in the special case of \"odds and evens\".\nMoreover, I conjecture that the approach can be generalised to arbitrary\nzero-sum games.\n", "versions": [{"version": "v1", "created": "Sat, 9 May 2020 18:09:52 GMT"}, {"version": "v2", "created": "Mon, 29 Jun 2020 15:12:01 GMT"}], "update_date": "2020-06-30", "authors_parsed": [["Makarov", "Vladislav", ""]]}, {"id": "2005.05520", "submitter": "Hadrien Bride", "authors": "Hadrien Bride, Cheng-Hao Cai, Jin Song Dong, Rajeev Gore, Zh\\'e H\\'ou,\n  Brendan Mahony, Jim McCarthy", "title": "N-PAT: A Nested Model-Checker", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  N-PAT is a new model-checking tool that supports the verification of\nnested-models, i.e. models whose behaviour depends on the results of\nverification tasks. In this paper, we describe its operation and discuss\nmechanisms that are tailored to the efficient verification of nested-models.\nFurther, we motivate the advantages of N-PAT over traditional model-checking\ntools through a network security case study.\n", "versions": [{"version": "v1", "created": "Tue, 12 May 2020 02:06:18 GMT"}], "update_date": "2020-05-13", "authors_parsed": [["Bride", "Hadrien", ""], ["Cai", "Cheng-Hao", ""], ["Dong", "Jin Song", ""], ["Gore", "Rajeev", ""], ["H\u00f3u", "Zh\u00e9", ""], ["Mahony", "Brendan", ""], ["McCarthy", "Jim", ""]]}, {"id": "2005.05907", "submitter": "Stefan Hoffmann", "authors": "Stefan Hoffmann", "title": "Ideal Separation and General Theorems for Constrained Synchronization\n  and their Application to Small Constraint Automata", "comments": "Complete reworking of the 1st version. The classification of the 1st\n  version is achieved by identifying and utilising more general theorems, which\n  are also stated in the work", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the constrained synchronization problem we ask if a given automaton admits\na synchronizing word coming from a fixed regular constraint language. We show\nthat intersecting a given constraint language with an ideal language decreases\nthe computational complexity. Additionally, we state a theorem giving\nPSPACE-hardness that broadly generalizes previously used constructions and a\nresult on how to combine languages by concatenation to get polynomial time\nsolvable constrained synchronization problems. We use these results to give a\nclassification of the complexity landscape for small constraint automata of up\nto three states.\n", "versions": [{"version": "v1", "created": "Tue, 12 May 2020 16:35:30 GMT"}, {"version": "v2", "created": "Thu, 18 Mar 2021 17:53:00 GMT"}], "update_date": "2021-03-19", "authors_parsed": [["Hoffmann", "Stefan", ""]]}, {"id": "2005.06115", "submitter": "Borzoo Bonakdarpour", "authors": "Erika Abraham, Ezio Bartocci, Borzoo Bonakdarpour, Oyendrila Dobe", "title": "Probabilistic Hyperproperties with Nondeterminism", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the problem of formalizing and checking probabilistic\nhyperproperties for models that allow nondeterminism in actions. We extend the\ntemporal logic \\HyperPCTL, which has been previously introduced for\ndiscrete-time Markov chains, to enable the specification of hyperproperties\nalso for Markov decision processes. We generalize HyperPCTL by allowing\nexplicit and simultaneous quantification over schedulers and probabilistic\ncomputation trees and show that it can express important quantitative\nrequirements in security and privacy. We show that HyperPCTL model checking\nover MDPs is in general undecidable for quantification over probabilistic\nschedulers with memory, but restricting the domain to memoryless\nnon-probabilistic schedulers turns the model checking problem decidable.\nSubsequently, we propose an SMT-based encoding for model checking this language\nand evaluate its performance.\n", "versions": [{"version": "v1", "created": "Wed, 13 May 2020 02:00:31 GMT"}, {"version": "v2", "created": "Thu, 16 Jul 2020 03:47:39 GMT"}], "update_date": "2020-07-17", "authors_parsed": [["Abraham", "Erika", ""], ["Bartocci", "Ezio", ""], ["Bonakdarpour", "Borzoo", ""], ["Dobe", "Oyendrila", ""]]}, {"id": "2005.06285", "submitter": "Stefan G\\\"oller", "authors": "Stefan G\\\"oller and Pawe{\\l} Parys", "title": "Bisimulation Finiteness of Pushdown Systems Is Elementary", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that in case a pushdown system is bisimulation equivalent to a finite\nsystem, there is already a bisimulation equivalent finite system whose size is\nelementarily bounded in the description size of the pushdown system. As a\nconsequence we obtain that it is elementarily decidable if a given pushdown\nsystem is bisimulation equivalent to some finite system. This improves a\npreviously best-known ACKERMANN upper bound for this problem.\n", "versions": [{"version": "v1", "created": "Wed, 13 May 2020 12:26:50 GMT"}], "update_date": "2020-05-14", "authors_parsed": [["G\u00f6ller", "Stefan", ""], ["Parys", "Pawe\u0142", ""]]}, {"id": "2005.06411", "submitter": "Andrzej Murawski", "authors": "Andrzej S. Murawski, Steven J. Ramsay, Nikos Tzevelekos", "title": "Bisimilarity in fresh-register automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Register automata are a basic model of computation over infinite alphabets.\nFresh-register automata extend register automata with the capability to\ngenerate fresh symbols in order to model computational scenarios involving name\ncreation. This paper investigates the complexity of the bisimilarity problem\nfor classes of register and fresh-register automata. We examine all main\ndisciplines that have appeared in the literature: general register assignments;\nassignments where duplicate register values are disallowed; and assignments\nwithout duplicates in which registers cannot be empty. In the general case, we\nshow that the problem is EXPTIME-complete.\n  However, the absence of duplicate values in registers enables us to identify\ninherent symmetries inside the associated bisimulation relations, which can be\nused to establish a polynomial bound on the depth of Attacker-winning\nstrategies. Furthermore, they enable a highly succinct representation of the\ncorresponding bisimulations. By exploiting results from group theory and\ncomputational group theory, we can then show solvability in PSPACE and NP\nrespectively for the latter two register disciplines. In each case, we find\nthat freshness does not affect the complexity class of the problem.\n  The results allow us to close a complexity gap for language equivalence of\ndeterministic register automata. We show that deterministic language\ninequivalence for the no-duplicates fragment is NP-complete, which disproves an\nold conjecture of Sakamoto.\n  Finally, we discover that, unlike in the finite-alphabet case, the addition\nof pushdown store makes bisimilarity undecidable, even in the case of visibly\npushdown storage.\n", "versions": [{"version": "v1", "created": "Wed, 13 May 2020 16:38:19 GMT"}], "update_date": "2020-05-14", "authors_parsed": [["Murawski", "Andrzej S.", ""], ["Ramsay", "Steven J.", ""], ["Tzevelekos", "Nikos", ""]]}, {"id": "2005.06814", "submitter": "Clement Aubert", "authors": "Cl\\'ement Aubert, Ioana Cristescu (HMS)", "title": "How Reversibility Can Solve Traditional Questions: The Example of\n  Hereditary History-Preserving Bisimulation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.FL cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reversible computation opens up the possibility of overcoming some of the\nhardware's current physical limitations. It also offers theoretical insights,\nas it enriches multiple paradigms and models of computation, and sometimes\nretrospectively enlightens them. Concurrent reversible computation, for\ninstance, offered interesting extensions to the Calculus of Communicating\nSystems, but was still lacking a natural and pertinent bisimulation to study\nprocesses equivalences. Our paper formulates an equivalence exploiting the two\naspects of reversibility: backward moves and memory mechanisms. This\nbisimulation captures classical equivalences relations for denotational models\nof concurrency (History-and hereditary history-preserving bisimulation,\n(H)HPB), that were up to now only partially characterized by process algebras.\nThis result gives an insight on the expressiveness of reversibility, as both\nbackward moves and a memory mechanism-providing 'backward determinism'-are\nneeded to capture HHPB.\n", "versions": [{"version": "v1", "created": "Thu, 14 May 2020 08:55:07 GMT"}], "update_date": "2020-05-15", "authors_parsed": [["Aubert", "Cl\u00e9ment", "", "HMS"], ["Cristescu", "Ioana", "", "HMS"]]}, {"id": "2005.06818", "submitter": "Clement Aubert", "authors": "Cl\\'ement Aubert, Ioana Cristescu", "title": "Structural Equivalences for Reversible Calculi of Communicating Systems\n  (Oral communication)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The formalization of process algebras usually starts with a minimal core of\noperators and rules for its transition system, and then relax the system to\nimprove its usability and ease the proofs. In the calculus of communicating\nsystems (CCS), the structural congruence plays this role by making e.g.\nparallel composition commutative and associative: without it, the system would\nbe cumbersome to use and reason about, and it can be proven that this change is\ninnocuous in a precise technical sense. For the two reversible calculi\nextending CCS, the situation is less clear: CCS with Communication Keys (CCSK)\nwas first defined without any structural congruence, and then was endowed with\na fragment of CCS's congruence. Reversible CCS (RCCS) made the choice of\n\"backing in\" the structural equivalence, that became part of the \"minimal core\"\nof the system. In this short oral communication, we would like to re-consider\nthe status and role of the structural congruence in general, to question its\nrole in RCCS in particular, and to ask the more general question of the\nstructural equivalences legitimacy.\n", "versions": [{"version": "v1", "created": "Thu, 14 May 2020 08:57:58 GMT"}], "update_date": "2020-05-15", "authors_parsed": [["Aubert", "Cl\u00e9ment", ""], ["Cristescu", "Ioana", ""]]}, {"id": "2005.07227", "submitter": "Petr Novotn\\'y", "authors": "Franti\\v{s}ek Blahoudek and Tom\\'a\\v{s} Br\\'azdil and Petr Novotn\\'y\n  and Melkior Ornik and Pranay Thangeda and Ufuk Topcu", "title": "Qualitative Controller Synthesis for Consumption Markov Decision\n  Processes", "comments": "Full version of a paper accepted at CAV'20", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Consumption Markov Decision Processes (CMDPs) are probabilistic\ndecision-making models of resource-constrained systems. In a CMDP, the\ncontroller possesses a certain amount of a critical resource, such as electric\npower. Each action of the controller can consume some amount of the resource.\nResource replenishment is only possible in special reload states, in which the\nresource level can be reloaded up to the full capacity of the system. The task\nof the controller is to prevent resource exhaustion, i.e. ensure that the\navailable amount of the resource stays non-negative, while ensuring an\nadditional linear-time property. We study the complexity of strategy synthesis\nin consumption MDPs with almost-sure B\\\"uchi objectives. We show that the\nproblem can be solved in polynomial time. We implement our algorithm and show\nthat it can efficiently solve CMDPs modelling real-world scenarios.\n", "versions": [{"version": "v1", "created": "Thu, 14 May 2020 19:23:44 GMT"}], "update_date": "2020-05-18", "authors_parsed": [["Blahoudek", "Franti\u0161ek", ""], ["Br\u00e1zdil", "Tom\u00e1\u0161", ""], ["Novotn\u00fd", "Petr", ""], ["Ornik", "Melkior", ""], ["Thangeda", "Pranay", ""], ["Topcu", "Ufuk", ""]]}, {"id": "2005.07325", "submitter": "Christoph Adami", "authors": "Christoph Adami (Michigan State University)", "title": "On the Origin of Quantum Uncertainty", "comments": "Contribution to the FQXi Essay Contest: \"Undecidability,\n  Uncomputability, and Unpredictability\". 9 pages plus two pages of\n  Supplementary Material", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  I propose that quantum uncertainty is a manifestation of the indeterminism\ninherent in mathematical logic.\n", "versions": [{"version": "v1", "created": "Fri, 15 May 2020 02:17:13 GMT"}], "update_date": "2020-05-18", "authors_parsed": [["Adami", "Christoph", "", "Michigan State University"]]}, {"id": "2005.07569", "submitter": "Debayan Ganguly", "authors": "Debayan Ganguly, Kingshuk Chatterjee, Kumar Sankar Ray", "title": "Two-way Nanoscale automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we show the all final subclass of two-way Watson-Crick\nautomata have the same computational power as the classical two-way\nWatson-Crick automata. Here we compare the computational power of two-way\nWatson-Crick automata and two-way Quantum finite automata and we observe that\ntwo-way Watson-Crick automata can accept a language which two-way quantum\nfinite automata cannot accept.\n", "versions": [{"version": "v1", "created": "Sun, 19 Apr 2020 06:45:20 GMT"}], "update_date": "2020-05-18", "authors_parsed": [["Ganguly", "Debayan", ""], ["Chatterjee", "Kingshuk", ""], ["Ray", "Kumar Sankar", ""]]}, {"id": "2005.09125", "submitter": "EPTCS", "authors": "Yong Li (State Key Laboratory of Computer Science, Institute of\n  Software, Chinese Academy of Sciences), Moshe Y. Vardi (Rice University),\n  Lijun Zhang (State Key Laboratory of Computer Science, Institute of Software,\n  Chinese Academy of Sciences)", "title": "On the Power of Unambiguity in B\\\"uchi Complementation", "comments": "In Proceedings GandALF 2020, arXiv:2009.09360", "journal-ref": "EPTCS 326, 2020, pp. 182-198", "doi": "10.4204/EPTCS.326.12", "report-no": null, "categories": "cs.FL cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we exploit the power of \\emph{unambiguity} for the\ncomplementation problem of B\\\"uchi automata by utilizing reduced run directed\nacyclic graphs (DAGs) over infinite words, in which each vertex has at most one\npredecessor. We then show how to use this type of reduced run DAGs as a\n\\emph{unified tool} to optimize \\emph{both} rank-based and slice-based\ncomplementation constructions for B\\\"uchi automata with a finite degree of\nambiguity. As a result, given a B\\\"uchi automaton with $n$ states and a finite\ndegree of ambiguity, the number of states in the complementary B\\\"uchi\nautomaton constructed by the classical rank-based and slice-based\ncomplementation constructions can be improved, respectively, to $2^{O(n)}$ from\n$2^{O(n\\log n)}$ and to $O(4^n)$ from $O((3n)^n)$.\n", "versions": [{"version": "v1", "created": "Mon, 18 May 2020 22:51:34 GMT"}, {"version": "v2", "created": "Wed, 23 Sep 2020 01:27:07 GMT"}], "update_date": "2020-09-24", "authors_parsed": [["Li", "Yong", "", "State Key Laboratory of Computer Science, Institute of\n  Software, Chinese Academy of Sciences"], ["Vardi", "Moshe Y.", "", "Rice University"], ["Zhang", "Lijun", "", "State Key Laboratory of Computer Science, Institute of Software,\n  Chinese Academy of Sciences"]]}, {"id": "2005.09281", "submitter": "Yannik Eikmeier", "authors": "Yannik Eikmeier and Pamela Fleischmann and Mitja Kulczynski and Dirk\n  Nowotka", "title": "Weighted Prefix Normal Words: Mind the Gap", "comments": "18 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A prefix normal word is a binary word whose prefixes contain at least as many\n1s as any of its factors of the same length. Introduced by Fici and Lipt\\'ak in\n2011 the notion of prefix normality is so far only defined for words over the\nbinary alphabet. In this work we investigate a generalisation for finite words\nover arbitrary finite alphabets, namely weighted prefix normality. We prove\nthat weighted prefix normality is more expressive than binary prefix normality.\nFurthermore, we investigate the existence of a weighted prefix normal form\nsince weighted prefix normality comes with several new peculiarities that did\nnot already occur in the binary case. We characterise these issues and finally\npresent a standard technique to obtain a generalised prefix normal form for all\nwords overarbitrary, finite alphabets.\n", "versions": [{"version": "v1", "created": "Tue, 19 May 2020 08:28:03 GMT"}, {"version": "v2", "created": "Mon, 5 Oct 2020 08:24:11 GMT"}, {"version": "v3", "created": "Mon, 19 Apr 2021 10:14:19 GMT"}], "update_date": "2021-04-20", "authors_parsed": [["Eikmeier", "Yannik", ""], ["Fleischmann", "Pamela", ""], ["Kulczynski", "Mitja", ""], ["Nowotka", "Dirk", ""]]}, {"id": "2005.09489", "submitter": "Shankara Narayanan Krishna", "authors": "Parosh Aziz Abdulla, Mohamed Faouzi Atig, Vrunda Dave and Shankara\n  Narayanan Krishna", "title": "On the Separability Problem of String Constraints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address the separability problem for straight-line string constraints. The\nseparability problem for languages of a class C by a class S asks: given two\nlanguages A and B in C, does there exist a language I in S separating A and B\n(i.e., I is a superset of A and disjoint from B)? The separability of string\nconstraints is the same as the fundamental problem of interpolation for string\nconstraints. We first show that regular separability of straight line string\nconstraints is undecidable. Our second result is the decidability of the\nseparability problem for straight-line string constraints by piece-wise\ntestable languages, though the precise complexity is open. In our third result,\nwe consider the positive fragment of piece-wise testable languages as a\nseparator, and obtain an EXPSPACE algorithm for the separability of a useful\nclass of straight-line string constraints, and a PSPACE-hardness result.\n", "versions": [{"version": "v1", "created": "Mon, 18 May 2020 05:02:02 GMT"}, {"version": "v2", "created": "Wed, 20 May 2020 01:43:11 GMT"}], "update_date": "2020-05-21", "authors_parsed": [["Abdulla", "Parosh Aziz", ""], ["Atig", "Mohamed Faouzi", ""], ["Dave", "Vrunda", ""], ["Krishna", "Shankara Narayanan", ""]]}, {"id": "2005.09507", "submitter": "Daniel Krenn", "authors": "Daniel Krenn and Jeffrey Shallit", "title": "Decidability and k-Regular Sequences", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we consider a number of natural decision problems involving\nk-regular sequences. Specifically, they arise from - lower and upper bounds on\ngrowth rate; in particular boundedness, - images, - regularity (recognizability\nby a deterministic finite automaton) of preimages, and - factors, such as\nsquares and palindromes of such sequences. We show that the decision problems\nare undecidable.\n", "versions": [{"version": "v1", "created": "Tue, 19 May 2020 15:05:07 GMT"}, {"version": "v2", "created": "Mon, 10 May 2021 16:02:29 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Krenn", "Daniel", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "2005.09585", "submitter": "Jeffrey Shallit", "authors": "Craig S. Kaplan and Jeffrey Shallit", "title": "A Frameless 2-Coloring of the Plane Lattice", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A picture frame in two dimensions is a rectangular array of symbols, with at\nleast two rows and columns, where the first and last rows are identical, and\nthe first and last columns are identical. If a coloring of the plane lattice\nhas no picture frames, we call it frameless. In this note we show how to create\na simple 2-coloring of the plane lattice that is frameless.\n", "versions": [{"version": "v1", "created": "Tue, 19 May 2020 16:58:51 GMT"}], "update_date": "2020-05-20", "authors_parsed": [["Kaplan", "Craig S.", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "2005.10085", "submitter": "Tijs Slaats", "authors": "Christoffer Olling Back, Tijs Slaats, Thomas Troels Hildebrandt,\n  Morten Marquard", "title": "DisCoveR: Accurate & Efficient Discovery of Declarative Process Models", "comments": "Author's original version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL cs.SE stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Declarative process modeling formalisms - which capture high-level process\nconstraints - have seen growing interest, especially for modeling flexible\nprocesses. This paper presents DisCoveR, an extremely efficient and accurate\ndeclarative miner for learning Dynamic Condition Response (DCR) Graphs from\nevent logs. We precisely formalize the algorithm, describe a highly efficient\nbit vector implementation and rigorously evaluate performance against two other\ndeclarative miners, representing the state-of-the-art in Declare and DCR Graphs\nmining. DisCoveR outperforms each of these w.r.t. a binary classification task,\nachieving an average accuracy of 96.2% in the Process Discovery Contest 2019.\nDue to its linear time complexity, DisCoveR also achieves run-times 1-2 orders\nof magnitude below its declarative counterparts. Finally, we show how the miner\nhas been integrated in a state-of-the-art declarative process modeling\nframework as a model recommendation tool, discuss how discovery can play an\nintegral part of the modeling task and report on how the integration has\nimproved the modeling experience of end-users.\n", "versions": [{"version": "v1", "created": "Wed, 20 May 2020 14:48:33 GMT"}], "update_date": "2020-05-21", "authors_parsed": [["Back", "Christoffer Olling", ""], ["Slaats", "Tijs", ""], ["Hildebrandt", "Thomas Troels", ""], ["Marquard", "Morten", ""]]}, {"id": "2005.10126", "submitter": "Debayan Ganguly", "authors": "Kingshuk Chatterjee, Debayan Ganguly, Kumar Sankar Ray", "title": "State Complexity of Reversible Watson-Crick Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reversible Watson-Crick automata introduced by Chatterjee et.al. is a\nreversible variant of an Watson-Crick automata. It has already been shown that\nthe addition of DNA properties to reversible automata significantly increases\nthe computational power of the model. In this paper, we analyze the state\ncomplexity of Reversible Watson-Crick automata with respect to\nnon-deterministic finite automata. We show that Reversible Watson-Crick\nautomata in spite of being reversible in nature enjoy state complexity\nadvantage over non deterministic finite automata. The result is interesting\nbecause conversion from non deterministic to deterministic automata results in\nexponential blow up of the number of states and classically increase in number\nof heads of the automata cannot compensate for non-determinism in deterministic\nand reversible models.\n", "versions": [{"version": "v1", "created": "Wed, 29 Apr 2020 17:10:25 GMT"}], "update_date": "2020-05-21", "authors_parsed": [["Chatterjee", "Kingshuk", ""], ["Ganguly", "Debayan", ""], ["Ray", "Kumar Sankar", ""]]}, {"id": "2005.10127", "submitter": "Debayan Ganguly", "authors": "Debayan Ganguly, Kingshuk Chatterjee, Kumar Sankar Ray", "title": "Multi-head Watson-Crick quantum finite automata", "comments": "arXiv admin note: substantial text overlap with arXiv:1507.05282,\n  arXiv:1607.00811", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Watson-Crick quantum finite automata were introduced by Ganguly et.al. by\ncombining properties of DNA and Quantum automata. In this paper we introduce a\nmulti-head version of the above automaton. We further show that the multi-head\nvariant is computationally more powerful than one-way multi-head reversible\nfinite automata. In fact we also show that the multi-head variant accepts a\nlanguage which is not accepted by any one-way multi-head deterministic finite\nautomata.\n", "versions": [{"version": "v1", "created": "Mon, 20 Apr 2020 17:07:46 GMT"}], "update_date": "2020-05-21", "authors_parsed": [["Ganguly", "Debayan", ""], ["Chatterjee", "Kingshuk", ""], ["Ray", "Kumar Sankar", ""]]}, {"id": "2005.10372", "submitter": "Aalok Thakkar", "authors": "Aalok Thakkar", "title": "Infinitude of Primes Using Formal Language Theory", "comments": null, "journal-ref": "The American Mathematical Monthly, 125:8, 745-749 (2018)", "doi": "10.1080/00029890.2018.1496761", "report-no": null, "categories": "cs.FL math.NT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Formal languages are sets of strings of symbols described by a set of rules\nspecific to them. In this note, we discuss a certain class of formal languages,\ncalled regular languages, and put forward some elementary results. The\nproperties of these languages are then employed to prove that there are\ninfinitely many prime numbers.\n", "versions": [{"version": "v1", "created": "Wed, 20 May 2020 21:56:26 GMT"}], "update_date": "2020-05-22", "authors_parsed": [["Thakkar", "Aalok", ""]]}, {"id": "2005.10668", "submitter": "Gabriele Fici", "authors": "Giuseppa Castiglione, Gabriele Fici, Antonio Restivo", "title": "Primitive Sets of Words", "comments": "Submitted. arXiv admin note: substantial text overlap with\n  arXiv:1810.02182", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a (finite or infinite) subset $X$ of the free monoid $A^*$ over a\nfinite alphabet $A$, the rank of $X$ is the minimal cardinality of a set $F$\nsuch that $X \\subseteq F^*$. We say that a submonoid $M$ generated by $k$\nelements of $A^*$ is {\\em $k$-maximal} if there does not exist another\nsubmonoid generated by at most $k$ words containing $M$. We call a set $X\n\\subseteq A^*$ {\\em primitive} if it is the basis of a $|X|$-maximal submonoid.\nThis definition encompasses the notion of primitive word -- in fact, $\\{w\\}$ is\na primitive set if and only if $w$ is a primitive word. By definition, for any\nset $X$, there exists a primitive set $Y$ such that $X \\subseteq Y^*$. We\ntherefore call $Y$ a {\\em primitive root} of $X$. As a main result, we prove\nthat if a set has rank $2$, then it has a unique primitive root. To obtain this\nresult, we prove that the intersection of two $2$-maximal submonoids is either\nthe empty word or a submonoid generated by one single primitive word. For a\nsingle word $w$, we say that the set $\\{x,y\\}$ is a {\\em bi-root} of $w$ if $w$\ncan be written as a concatenation of copies of $x$ and $y$ and $\\{x,y\\}$ is a\nprimitive set. We prove that every primitive word $w$ has at most one bi-root\n$\\{x,y\\}$ such that $|x|+|y|<\\sqrt{|w|}$. That is, the bi-root of a word is\nunique provided the word is sufficiently long with respect to the size (sum of\nlengths) of the root. Our results are also compared to previous approaches that\ninvestigate pseudo-repetitions, where a morphic involutive function $\\theta$ is\ndefined on $A^*$. In this setting, the notions of $\\theta$-power,\n$\\theta$-primitive and $\\theta$-root are defined, and it is shown that any word\nhas a unique $\\theta$-primitive root. This result can be obtained with our\napproach by showing that a word $w$ is $\\theta$-primitive if and only if $\\{w,\n\\theta(w)\\}$ is a primitive set.\n", "versions": [{"version": "v1", "created": "Wed, 20 May 2020 16:14:00 GMT"}], "update_date": "2020-05-22", "authors_parsed": [["Castiglione", "Giuseppa", ""], ["Fici", "Gabriele", ""], ["Restivo", "Antonio", ""]]}, {"id": "2005.11551", "submitter": "Dexter Kozen", "authors": "Nick Bezhanishvili and Marcello Bonsangue and Helle Hvid Hansen and\n  Dexter Kozen and Clemens Kupke and Prakash Panangaden and Alexandra Silva", "title": "Minimisation in Logical Form", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Stone-type dualities provide a powerful mathematical framework for studying\nproperties of logical systems. They have recently been fruitfully explored in\nunderstanding minimisation of various types of automata. In Bezhanishvili et\nal. (2012), a dual equivalence between a category of coalgebras and a category\nof algebras was used to explain minimisation. The algebraic semantics is dual\nto a coalgebraic semantics in which logical equivalence coincides with trace\nequivalence. It follows that maximal quotients of coalgebras correspond to\nminimal subobjects of algebras. Examples include partially observable\ndeterministic finite automata, linear weighted automata viewed as coalgebras\nover finite-dimensional vector spaces, and belief automata, which are\ncoalgebras on compact Hausdorff spaces. In Bonchi et al. (2014), Brzozowski's\ndouble-reversal minimisation algorithm for deterministic finite automata was\ndescribed categorically and its correctness explained via the duality between\nreachability and observability. This work includes generalisations of\nBrzozowski's algorithm to Moore and weighted automata over commutative\nsemirings.\n  In this paper we propose a general categorical framework within which such\nminimisation algorithms can be understood. The goal is to provide a unifying\nperspective based on duality. Our framework consists of a stack of three\ninterconnected adjunctions: a base dual adjunction that can be lifted to a dual\nadjunction between coalgebras and algebras and also to a dual adjunction\nbetween automata. The approach provides an abstract understanding of\nreachability and observability. We illustrate the general framework on range of\nconcrete examples, including deterministic Kripke frames, weighted automata,\ntopological automata (belief automata), and alternating automata.\n", "versions": [{"version": "v1", "created": "Sat, 23 May 2020 15:19:57 GMT"}], "update_date": "2020-05-26", "authors_parsed": [["Bezhanishvili", "Nick", ""], ["Bonsangue", "Marcello", ""], ["Hansen", "Helle Hvid", ""], ["Kozen", "Dexter", ""], ["Kupke", "Clemens", ""], ["Panangaden", "Prakash", ""], ["Silva", "Alexandra", ""]]}, {"id": "2005.11718", "submitter": "Jeffrey Shallit", "authors": "Daniel Gabric, Narad Rampersad, Jeffrey Shallit", "title": "An inequality for the number of periods in a word", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove an inequality for the number of periods in a word x in terms of the\nlength of x and its initial critical exponent. Next, we characterize all\nperiods of the length-n prefix of a characteristic Sturmian word in terms of\nthe lazy Ostrowski representation of n, and use this result to show that our\ninequality is tight for infinitely many words x. We propose two related\nmeasures of periodicity for infinite words. Finally, we also consider special\ncases where x is overlap-free or squarefree.\n", "versions": [{"version": "v1", "created": "Sun, 24 May 2020 11:12:02 GMT"}, {"version": "v2", "created": "Wed, 27 May 2020 07:13:27 GMT"}], "update_date": "2020-05-28", "authors_parsed": [["Gabric", "Daniel", ""], ["Rampersad", "Narad", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "2005.11827", "submitter": "Dejan Ni\\v{c}kovi\\'c", "authors": "Dejan Nickovic and Tomoya Yamaguchi", "title": "RTAMT: Online Robustness Monitors from STL", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present RTAMT, an online monitoring library for Signal Temporal Logic\n(STL) and its interface-aware variant (IA-STL), providing both discrete- and\ndense-time interpretation of the logic. We also introduce RTAMT4ROS, a tool\nthat integrates RTAMT with Robotic Operating System (ROS), a common environment\nfor developing robotic applications. We evaluate RTAMT and RTAMT4ROS on two\nrobotic case studies.\n", "versions": [{"version": "v1", "created": "Sun, 24 May 2020 19:23:09 GMT"}], "update_date": "2020-05-26", "authors_parsed": [["Nickovic", "Dejan", ""], ["Yamaguchi", "Tomoya", ""]]}, {"id": "2005.12229", "submitter": "N. Pytheas Fogg", "authors": "N. Pytheas Fogg, C. No\\^us", "title": "Symbolic coding of linear complexity for generic translations of the\n  torus, using continued fractions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.DS cs.FL math.NT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we prove that almost every translation of $\\mathbb{T}^2$\nadmits a symbolic coding which has linear complexity $2n+1$. The partitions are\nconstructed with Rauzy fractals associated with sequences of substitutions,\nwhich are produced by a particular extended continued fraction algorithm in\nprojective dimension $2$. More generally, in dimension $d\\geq 1$, we study\nextended measured continued fraction algorithms, which associate to each\ndirection a subshift generated by substitutions, called $S$-adic subshift. We\ngive some conditions which imply the existence, for almost every direction, of\na translation of the torus $\\mathbb{T}^d$ and a nice generating partition, such\nthat the associated coding is a conjugacy with the subshift.\n", "versions": [{"version": "v1", "created": "Mon, 25 May 2020 16:58:47 GMT"}], "update_date": "2020-05-26", "authors_parsed": [["Fogg", "N. Pytheas", ""], ["No\u00fbs", "C.", ""]]}, {"id": "2005.12232", "submitter": "Camilo Rocha", "authors": "Stephen Skeirik and Jos\\'e Meseguer and Camilo Rocha", "title": "Verification of the IBOS Browser Security Properties in Reachability\n  Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a rewriting logic specification of the Illinois Browser\nOperating System (IBOS) and defines several security properties, including the\nsame-origin policy (SOP) in reachability logic. It shows how these properties\ncan be deductively verified using our constructor-based reachability logic\ntheorem prover. This paper also highlights the reasoning techniques used in the\nproof and three modularity principles that have been crucial to scale up and\ncomplete the verification effort.\n", "versions": [{"version": "v1", "created": "Mon, 25 May 2020 17:02:51 GMT"}], "update_date": "2020-05-26", "authors_parsed": [["Skeirik", "Stephen", ""], ["Meseguer", "Jos\u00e9", ""], ["Rocha", "Camilo", ""]]}, {"id": "2005.12588", "submitter": "Pierre-Loic Garoche", "authors": "Rapha\\\"el Cohen, Eric F\\'eron, Pierre-Lo\\\"ic Garoche (ENAC)", "title": "Verification and Validation of Convex Optimization Algorithms for Model\n  Predictive Control", "comments": null, "journal-ref": "Journal of Aerospace Information Systems, American Institute of\n  Aeronautics and Astronautics, 2020, 17 (5), pp.257-270", "doi": null, "report-no": null, "categories": "cs.CL cs.FL math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Advanced embedded algorithms are growing in complexity and they are an\nessential contributor to the growth of autonomy in many areas. However, the\npromise held by these algorithms cannot be kept without proper attention to the\nconsiderably stronger design constraints that arise when the applications of\ninterest, such as aerospace systems, are safety-critical. Formal verification\nis the process of proving or disproving the ''correctness'' of an algorithm\nwith respect to a certain mathematical description of it by means of a\ncomputer. This article discusses the formal verification of the Ellipsoid\nmethod, a convex optimization algorithm, and its code implementation as it\napplies to receding horizon control. Options for encoding code properties and\ntheir proofs are detailed. The applicability and limitations of those code\nproperties and proofs are presented as well. Finally, floating-point errors are\ntaken into account in a numerical analysis of the Ellipsoid algorithm.\nModifications to the algorithm are presented which can be used to control its\nnumerical stability.\n", "versions": [{"version": "v1", "created": "Tue, 26 May 2020 09:18:14 GMT"}], "update_date": "2020-05-27", "authors_parsed": [["Cohen", "Rapha\u00ebl", "", "ENAC"], ["F\u00e9ron", "Eric", "", "ENAC"], ["Garoche", "Pierre-Lo\u00efc", "", "ENAC"]]}, {"id": "2005.12911", "submitter": "Yann Thierry-Mieg", "authors": "Yann Thierry-Mieg (SU, CNRS)", "title": "Symbolic and Structural Model-Checking", "comments": "Extended Journal version of ICATPN 2020 paper (pre-print)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Brute-force model-checking consists in exhaustive exploration of the\nstate-space of a Petri net, and meets the dreaded state-space explosion\nproblem.\n  In contrast, this paper shows how to solve model-checking problems using a\ncombination of techniques that stay in complexity proportional to the size of\nthe net structure rather than to the state-space size.\n  We combine an SMT based over-approximation to prove that some behaviors are\nunfeasible, an under-approximation using memory-less sampling of runs to find\nwitness traces or counter-examples, and a set of structural reduction rules\nthat can simplify both the system and the property.\n  This approach was able to win by a clear margin the model-checking contest\n2020 for reachability queries as well as deadlock detection, thus demonstrating\nthe practical effectiveness and general applicability of the system of rules\npresented in this paper.\n", "versions": [{"version": "v1", "created": "Tue, 26 May 2020 08:44:36 GMT"}, {"version": "v2", "created": "Wed, 7 Apr 2021 08:55:49 GMT"}], "update_date": "2021-04-08", "authors_parsed": [["Thierry-Mieg", "Yann", "", "SU, CNRS"]]}, {"id": "2005.13151", "submitter": "Peter Fontana", "authors": "Peter Fontana and Rance Cleaveland", "title": "Timed Automata Benchmark Description", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This report contains the descriptions of the timed automata (models) and the\nproperties (specifications) that are used as the \"benchmark examples in Data\nstructure choices for on-the-fly model checking of real-time systems\" and \"The\npower of proofs: New algorithms for timed automata model checking.\" The four\nmodels from those sources are: CSMA, FISCHER, LEADER, and GRC. Additionally we\ninclude in this report two additional models: FDDI and PATHOS. These six models\nare often used to benchmark timed automata model checker speed throughout timed\nautomata model checking papers.\n", "versions": [{"version": "v1", "created": "Wed, 27 May 2020 04:26:02 GMT"}], "update_date": "2020-05-28", "authors_parsed": [["Fontana", "Peter", ""], ["Cleaveland", "Rance", ""]]}, {"id": "2005.13301", "submitter": "Hari Govind Vediramana Krishnan", "authors": "Hari Govind V K, YuTing Chen, Sharon Shoham, Arie Gurfinkel", "title": "Global Guidance for Local Generalization in Model Checking", "comments": "Published in CAV 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  SMT-based model checkers, especially IC3-style ones, are currently the most\neffective techniques for verification of infinite state systems. They infer\nglobal inductive invariants via local reasoning about a single step of the\ntransition relation of a system, while employing SMT-based procedures, such as\ninterpolation, to mitigate the limitations of local reasoning and allow for\nbetter generalization. Unfortunately, these mitigations intertwine model\nchecking with heuristics of the underlying SMT-solver, negatively affecting\nstability of model checking. In this paper, we propose to tackle the\nlimitations of locality in a systematic manner. We introduce explicit global\nguidance into the local reasoning performed by IC3-style algorithms. To this\nend, we extend the SMT-IC3 paradigm with three novel rules, designed to\nmitigate fundamental sources of failure that stem from locality. We instantiate\nthese rules for the theory of Linear Integer Arithmetic and implement them on\ntop of SPACER solver in Z3. Our empirical results show that GSPACER, SPACER\nextended with global guidance, is significantly more effective than both SPACER\nand sole global reasoning, and, furthermore, is insensitive to interpolation.\n", "versions": [{"version": "v1", "created": "Wed, 27 May 2020 11:58:28 GMT"}], "update_date": "2020-05-28", "authors_parsed": [["K", "Hari Govind V", ""], ["Chen", "YuTing", ""], ["Shoham", "Sharon", ""], ["Gurfinkel", "Arie", ""]]}, {"id": "2005.13710", "submitter": "Fabian Frei", "authors": "Elisabet Burjons and Fabian Frei and Martin Raszyk", "title": "From Finite-Valued Nondeterministic Transducers to Deterministic\n  Two-Tape Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The question whether P equals NP revolves around the discrepancy between\nactive production and mere verification by Turing machines. In this paper, we\nexamine the analogous problem for finite transducers and automata. Every\nnondeterministic finite transducer defines a binary relation associating each\ninput word with all output words that the transducer can successfully produce\non the given input. Finite-valued transducers are those for which there is a\nfinite upper bound on the number of output words that the relation associates\nwith every input word. We characterize finite-valued, functional, and\nunambiguous nondeterministic transducers whose relations can be verified by a\ndeterministic two-tape automaton, show how to construct such an automaton if\none exists, and prove the undecidability of the criterion.\n", "versions": [{"version": "v1", "created": "Wed, 27 May 2020 23:38:29 GMT"}, {"version": "v2", "created": "Tue, 6 Oct 2020 14:25:22 GMT"}, {"version": "v3", "created": "Fri, 30 Apr 2021 15:08:20 GMT"}], "update_date": "2021-05-03", "authors_parsed": [["Burjons", "Elisabet", ""], ["Frei", "Fabian", ""], ["Raszyk", "Martin", ""]]}, {"id": "2005.13971", "submitter": "Christian Oliva", "authors": "Christian Oliva and Luis F. Lago-Fern\\'andez", "title": "Separation of Memory and Processing in Dual Recurrent Neural Networks", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NE cs.FL cs.LG stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We explore a neural network architecture that stacks a recurrent layer and a\nfeedforward layer that is also connected to the input, and compare it to\nstandard Elman and LSTM architectures in terms of accuracy and\ninterpretability. When noise is introduced into the activation function of the\nrecurrent units, these neurons are forced into a binary activation regime that\nmakes the networks behave much as finite automata. The resulting models are\nsimpler, easier to interpret and get higher accuracy on different sample\nproblems, including the recognition of regular languages, the computation of\nadditions in different bases and the generation of arithmetic expressions.\n", "versions": [{"version": "v1", "created": "Sun, 17 May 2020 11:38:42 GMT"}], "update_date": "2020-05-29", "authors_parsed": [["Oliva", "Christian", ""], ["Lago-Fern\u00e1ndez", "Luis F.", ""]]}]