[{"id": "1909.00898", "submitter": "Noushin Mehdipour", "authors": "Noushin Mehdipour, Cristian-Ioan Vasile, Calin Belta", "title": "Average-based Robustness for Continuous-Time Signal Temporal Logic", "comments": "Accepted for publication in the proceedings of Conference on Decision\n  and Control 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a new robustness score for continuous-time Signal Temporal Logic\n(STL) specifications. Instead of considering only the most severe point along\nthe evolution of the signal, we use average scores to extract more information\nfrom the signal, emphasizing robust satisfaction of all the specifications'\nsubformulae over their entire time interval domains. We demonstrate the\nadvantages of this new score in falsification and control synthesis problems in\nsystems with complex dynamics and multi-agent systems.\n", "versions": [{"version": "v1", "created": "Tue, 3 Sep 2019 00:31:19 GMT"}], "update_date": "2019-09-04", "authors_parsed": [["Mehdipour", "Noushin", ""], ["Vasile", "Cristian-Ioan", ""], ["Belta", "Calin", ""]]}, {"id": "1909.01627", "submitter": "Cinzia Di Giusto", "authors": "Cinzia Di Giusto (C&A), Cinzia Giusto (SARDES), Laetitia Laversa\n  (C&A), Etienne Lozes", "title": "On the k-synchronizability of systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL cs.SC cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we work on the notion of k-synchronizability: a system is\nk-synchronizable if any of its executions, up to reordering causally\nindependent actions, can be divided into a succession of k-bounded interaction\nphases. We show two results (both for mailbox and peer-to-peer automata):\nfirst, the reachability problem is decidable for k-synchronizable systems;\nsecond, the membership problem (whether a given system is k-synchronizable) is\ndecidable as well. Our proofs fix several important issues in previous attempts\nto prove these two results for mailbox automata.\n", "versions": [{"version": "v1", "created": "Wed, 4 Sep 2019 08:58:53 GMT"}, {"version": "v2", "created": "Tue, 21 Jan 2020 14:24:45 GMT"}], "update_date": "2020-01-22", "authors_parsed": [["Di Giusto", "Cinzia", "", "C&A"], ["Giusto", "Cinzia", "", "SARDES"], ["Laversa", "Laetitia", "", "C&A"], ["Lozes", "Etienne", ""]]}, {"id": "1909.01745", "submitter": "EPTCS", "authors": "Georgiana Caltais", "title": "Explaining SDN Failures via Axiomatisations", "comments": "In Proceedings FROM 2019, arXiv:1909.00584", "journal-ref": "EPTCS 303, 2019, pp. 48-60", "doi": "10.4204/EPTCS.303.4", "report-no": null, "categories": "cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work introduces a concept of explanations with respect to the violation\nof safe behaviours within software defined networks (SDNs) expressible in\nNetKAT. The latter is a network programming language that is based on a\nwell-studied mathematical structure, namely, Kleene Algebra with Tests (KAT).\nAmongst others, the mathematical foundation of NetKAT gave rise to a sound and\ncomplete equational theory. In our setting, a safe behaviour is characterised\nby a NetKAT policy which does not enable forwarding packets from ingress to an\nundesirable egress. Explanations for safety violations are derived in an\nequational fashion, based on a modification of the existing NetKAT\naxiomatisation.\n", "versions": [{"version": "v1", "created": "Wed, 4 Sep 2019 12:48:54 GMT"}], "update_date": "2019-09-05", "authors_parsed": [["Caltais", "Georgiana", ""]]}, {"id": "1909.01750", "submitter": "EPTCS", "authors": "Lorenzo Capra (Dipartimento di Informatica Universit\\`a degli Studi di\n  Milano, Milan, Italy)", "title": "An Operational Semantics of Graph Transformation Systems Using Symmetric\n  Nets", "comments": "In Proceedings FROM 2019, arXiv:1909.00584", "journal-ref": "EPTCS 303, 2019, pp. 107-119", "doi": "10.4204/EPTCS.303.8", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Graph transformation systems (GTS) have been successfully proposed as a\ngeneral, theoretically sound model for concurrency. Petri nets (PN), on the\nother side, are a central and intuitive formalism for concurrent or distributed\nsystems, well supported by a number of analysis techniques/tools. Some PN\nclasses have been shown to be instances of GTS. In this paper, we change\nperspective presenting an operational semantics of GTS in terms of Symmetric\nNets, a well-known class of Coloured Petri nets featuring a structured syntax\nthat outlines model symmetries. Some practical exploitations of the proposed\noperational semantics are discussed. In particular, a recently developed\nstructural calculus for SN is used to validate graph rewriting rules in a\nsymbolic way.\n", "versions": [{"version": "v1", "created": "Wed, 4 Sep 2019 12:49:55 GMT"}], "update_date": "2019-09-05", "authors_parsed": [["Capra", "Lorenzo", "", "Dipartimento di Informatica Universit\u00e0 degli Studi di\n  Milano, Milan, Italy"]]}, {"id": "1909.02512", "submitter": "Timothy Ng", "authors": "Lila Kari and Timothy Ng", "title": "Descriptional Complexity of Semi-Simple Splicing Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Splicing systems are generative mechanisms introduced by Tom Head in 1987 to\nmodel the biological process of DNA recombination. The computational engine of\na splicing system is the \"splicing operation\", a cut-and-paste binary string\noperation defined by a set of \"splicing rules\" $r = (\\alpha_1, \\alpha_2 ;\n\\alpha_3, \\alpha_4)$ where $\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4$ are words\nover an alphabet $\\Sigma$. For two strings $x = x_1 \\alpha_1 \\alpha_2 x_2$ and\n$y = y_1 \\alpha_3 \\alpha_4 y_2$, applying the splicing rule $r$ produces the\nstring $z = x_1 \\alpha_1 \\alpha_4 y_2$.\n  In this paper we focus on a particular type of splicing systems, called $(i,\nj)$ semi-simple splicing systems, $i = 1,2$ and $j = 3, 4$, wherein all\nsplicing rules have the property that the two strings in positions $i$ and $j$\nare singleton letters, while the other two strings are empty. The language\ngenerated by such a system consists of the set of words that are obtained\nstarting from an initial set called \"axiom set\", by iteratively applying the\nsplicing rules to strings in the axiom set as well as to intermediately\nproduced strings. We consider semi-simple splicing systems where the axiom set\nis a regular language, and investigate the descriptional complexity of such\nsystems in terms of the size of the minimal deterministic finite automata that\nrecognize the languages they generate.\n", "versions": [{"version": "v1", "created": "Thu, 5 Sep 2019 16:31:40 GMT"}], "update_date": "2019-09-06", "authors_parsed": [["Kari", "Lila", ""], ["Ng", "Timothy", ""]]}, {"id": "1909.02579", "submitter": "Michael Blondin", "authors": "Michael Blondin and Mikhail Raskin", "title": "The Complexity of Reachability in Affine Vector Addition Systems with\n  States", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Vector addition systems with states (VASS) are widely used for the formal\nverification of concurrent systems. Given their tremendous computational\ncomplexity, practical approaches have relied on techniques such as reachability\nrelaxations, e.g., allowing for negative intermediate counter values. It is\nnatural to question their feasibility for VASS enriched with primitives that\ntypically translate into undecidability. Spurred by this concern, we pinpoint\nthe complexity of integer relaxations with respect to arbitrary classes of\naffine operations.\n  More specifically, we provide a trichotomy on the complexity of integer\nreachability in VASS extended with affine operations (affine VASS). Namely, we\nshow that it is NP-complete for VASS with resets, PSPACE-complete for VASS with\n(pseudo-)transfers and VASS with (pseudo-)copies, and undecidable for any other\nclass. We further present a dichotomy for standard reachability in affine VASS:\nit is decidable for VASS with permutations, and undecidable for any other\nclass. This yields a complete and unified complexity landscape of reachability\nin affine VASS. We also consider the reachability problem parameterized by a\nfixed affine VASS, rather than a class, and we show that the complexity\nlandscape is arbitrary in this setting.\n", "versions": [{"version": "v1", "created": "Thu, 5 Sep 2019 18:01:22 GMT"}, {"version": "v2", "created": "Sun, 19 Apr 2020 14:54:24 GMT"}, {"version": "v3", "created": "Tue, 27 Oct 2020 19:48:44 GMT"}, {"version": "v4", "created": "Fri, 26 Mar 2021 15:01:48 GMT"}, {"version": "v5", "created": "Mon, 19 Jul 2021 13:00:07 GMT"}], "update_date": "2021-07-20", "authors_parsed": [["Blondin", "Michael", ""], ["Raskin", "Mikhail", ""]]}, {"id": "1909.02627", "submitter": "Tyler Schrock", "authors": "Tyler Schrock and Rafael Frongillo", "title": "Computational Complexity of $k$-Block Conjugacy", "comments": "26 pages, 8 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.DS cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider several computational problems related to conjugacy between\nsubshifts of finite type, restricted to $k$-block codes: verifying a proposed\n$k$-block conjugacy, deciding if two shifts admit a $k$-block conjugacy, and\nreducing the representation size of a shift via a $k$-block conjugacy. We give\na polynomial-time algorithm for verification, and show GI and NP-hardness for\ndeciding conjugacy and reducing representation size, respectively. Our approach\nfocuses on 1-block conjugacies between vertex shifts, from which we generalize\nto $k$-block conjugacies and to edge shifts. We conclude with several open\nproblems.\n", "versions": [{"version": "v1", "created": "Thu, 5 Sep 2019 20:50:43 GMT"}], "update_date": "2019-09-09", "authors_parsed": [["Schrock", "Tyler", ""], ["Frongillo", "Rafael", ""]]}, {"id": "1909.02893", "submitter": "Fabrizio Romano Genovese", "authors": "Fabrizio Genovese, Andre Knispel, Joshua Fitzgerald", "title": "Mapping finite state machines to zk-SNARKS Using Category Theory", "comments": "18 pages total, 10 pages body, 2 pages addendum, 5 pages appendix, 36\n  figures, 6 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL math.CT", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We provide a categorical procedure to turn graphs corresponding to state\nspaces of finite state machines into boolean circuits, leveraging on the fact\nthat boolean circuits can be easily turned into zk-SNARKS. Our circuits verify\nthat a given sequence of edges and nodes is indeed a path in the graph they\nrepresent. We then generalize to circuits verifying paths in arbitrary graphs.\nWe prove that all of our correspondences are pseudofunctorial, and behave\nnicely with respect to each other.\n", "versions": [{"version": "v1", "created": "Fri, 6 Sep 2019 13:27:23 GMT"}, {"version": "v2", "created": "Sat, 14 Sep 2019 11:51:13 GMT"}], "update_date": "2019-09-17", "authors_parsed": [["Genovese", "Fabrizio", ""], ["Knispel", "Andre", ""], ["Fitzgerald", "Joshua", ""]]}, {"id": "1909.03246", "submitter": "Victor Mitrana", "authors": "Victor Mitrana, Mihaela P\\u{a}un, Jose Angel Sanchez Martin, Jose\n  Ramon Sanchez Couso", "title": "{Networks of Uniform Splicing Processors", "comments": "Short paper, conference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this note we consider a new variant of network of splicing processors\nwhich simplifies the general model such that filters remain associated with\nnodes but the input and output filters of every node coincide. This variant is\ncalled {\\it network of uniform splicing processors}. Although the communication\nin the new variant seems less powerful, being based on simpler filters, the new\nvariant is sufficiently powerful to be computationally complete. The main\nresult is that nondeterministic Turing machines can be simulated by networks of\nuniform splicing processors. Furthermore, the simulation is time efficient.\n", "versions": [{"version": "v1", "created": "Sat, 7 Sep 2019 11:18:56 GMT"}], "update_date": "2019-09-10", "authors_parsed": [["Mitrana", "Victor", ""], ["P\u0103un", "Mihaela", ""], ["Martin", "Jose Angel Sanchez", ""], ["Couso", "Jose Ramon Sanchez", ""]]}, {"id": "1909.03518", "submitter": "Fabrizio Romano Genovese", "authors": "Fabrizio Genovese", "title": "The Essence of Petri Net Gluings", "comments": "20 pages, 4 pages appendix, 24 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.DC cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Many categorical frameworks have been proposed to formalize the idea of\ngluing Petri nets with each other. Such frameworks model net gluings in terms\nof sharing of resources or synchronization of transitions. Interpretations\ngiven to these gluings are more or less satisfactory when we consider Petri\nnets with a semantics attached to them.\n  In this work, we define a framework to compose Petri nets together in such a\nway that their semantics is respected. In addition to this, we show how our\nframework generalizes the previously defined ones.\n", "versions": [{"version": "v1", "created": "Sun, 8 Sep 2019 17:33:08 GMT"}, {"version": "v2", "created": "Sat, 14 Sep 2019 11:52:24 GMT"}], "update_date": "2019-09-17", "authors_parsed": [["Genovese", "Fabrizio", ""]]}, {"id": "1909.03703", "submitter": "Lars Luthmann M.Sc.", "authors": "Lars Luthmann (1), Hendrik G\\\"ottmann (1), Malte Lochau (1) ((1)\n  Real-Time Systems Lab, TU Darmstadt)", "title": "Compositional Liveness-Preserving Conformance Testing of Timed I/O\n  Automata -- Technical Report", "comments": "22 pages, 6 figures. Author version of the paper of the same name\n  accepted for the 16th International Conference on Formal Aspects of Component\n  Software (FACS 2019). This version is slightly extended as it contains all\n  proofs", "journal-ref": null, "doi": "10.1007/978-3-030-40914-2_8", "report-no": null, "categories": "cs.LO cs.FL cs.SE", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  I/O conformance testing theories (e.g., ioco) are concerned with formally\ndefining when observable output behaviors of an implementation conform to those\npermitted by a specification. Thereupon, several real-time extensions of ioco,\nusually called tioco, have been proposed, further taking into account permitted\ndelays between actions. In this paper, we propose an improved version of tioco,\ncalled live timed ioco (ltioco), tackling various weaknesses of existing\ndefinitions. Here, a reasonable adaptation of quiescence (i.e., observable\nabsence of any outputs) to real-time behaviors has to be done with care: ltioco\ntherefore distinguishes safe outputs being allowed to happen, from live outputs\nbeing enforced to happen within a certain time period thus inducing two\ndifferent facets of quiescence. Furthermore, tioco is frequently defined on\nTimed I/O Labeled Transition Systems (TIOLTS), a semantic model of Timed I/O\nAutomata (TIOA) which is infinitely branching and thus infeasible for practical\ntesting tools. Instead, we extend the theory of zone graphs to enable ltioco\ntesting on a finite semantic model of TIOA. Finally, we investigate\ncompositionality of ltioco with respect to parallel composition including a\nproper treatment of silent transitions.\n", "versions": [{"version": "v1", "created": "Mon, 9 Sep 2019 08:46:13 GMT"}, {"version": "v2", "created": "Tue, 10 Sep 2019 11:14:39 GMT"}], "update_date": "2020-02-18", "authors_parsed": [["Luthmann", "Lars", ""], ["G\u00f6ttmann", "Hendrik", ""], ["Lochau", "Malte", ""]]}, {"id": "1909.04118", "submitter": "Eric Mjolsness", "authors": "Eric Mjolsness", "title": "Structural Commutation Relations for Stochastic Labelled Graph Grammar\n  Rule Operators", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math-ph math.MP physics.bio-ph q-bio.QM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show how to calculate the operator algebra and the operator Lie algebra of\na stochastic labelled-graph grammar. More specifically, we carry out a generic\ncalculation of the product (and therefore the commutator) of time-evolution\noperators for any two labelled-graph grammar rewrite rules, where the operator\ncorresponding to each rule is defined in terms of elementary two-state\ncreation/annihilation operators. The resulting graph grammar algebra has the\nfollowing properties: (1) The product and commutator of two such operators is a\nsum of such operators with integer coefficients. Thus, the algebra and the Lie\nalgebra occurs entirely at the structural (or graph-combinatorial) level of\ngraph grammar rules, lifted from the level of elementary creation/annihilation\noperators (an improvement over [1], Propositions 1 and 2). (2) The product of\nthe off-diagonal (state-changing) parts of two such graph rule operators is a\nsum of off-diagonal graph rule operators with non-negative integer\ncoefficients. (3) These results apply whether the semantics of a graph grammar\nrule leaves behind hanging edges (Theorem 1), or removes hanging edges (Theorem\n2). (4) The algebra is constructive in terms of elementary two-state\ncreation/annihilation operators (Corollaries 3 and 8). These results are useful\nbecause dynamical transformations of labelled graphs comprise a general\nmodeling framework, and algebraic commutators of time-evolution operators have\nmany analytic uses including designing simulation algorithms and estimating\ntheir errors.\n", "versions": [{"version": "v1", "created": "Mon, 9 Sep 2019 19:31:38 GMT"}], "update_date": "2019-09-11", "authors_parsed": [["Mjolsness", "Eric", ""]]}, {"id": "1909.04756", "submitter": "Christoph Haase", "authors": "Georgina Bumpus, Christoph Haase, Stefan Kiefer, Paul-Ioan Stoienescu,\n  Jonathan Tanner", "title": "On the Size of Finite Rational Matrix Semigroups", "comments": null, "journal-ref": null, "doi": "10.4230/LIPIcs.ICALP.2020.115", "report-no": null, "categories": "math.GR cs.FL math.RA", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Let $n$ be a positive integer and $\\mathcal M$ a set of rational $n \\times\nn$-matrices such that $\\mathcal M$ generates a finite multiplicative semigroup.\nWe show that any matrix in the semigroup is a product of matrices in $\\mathcal\nM$ whose length is at most $2^{n (2 n + 3)} g(n)^{n+1} \\in 2^{O(n^2 \\log n)}$,\nwhere $g(n)$ is the maximum order of finite groups over rational $n \\times\nn$-matrices. This result implies algorithms with an elementary running time for\ndeciding finiteness of weighted automata over the rationals and for deciding\nreachability in affine integer vector addition systems with states with the\nfinite monoid property.\n", "versions": [{"version": "v1", "created": "Mon, 9 Sep 2019 15:18:41 GMT"}, {"version": "v2", "created": "Fri, 24 Apr 2020 19:43:17 GMT"}], "update_date": "2020-04-28", "authors_parsed": [["Bumpus", "Georgina", ""], ["Haase", "Christoph", ""], ["Kiefer", "Stefan", ""], ["Stoienescu", "Paul-Ioan", ""], ["Tanner", "Jonathan", ""]]}, {"id": "1909.05081", "submitter": "Ernst Moritz Hahn", "authors": "Ernst Moritz Hahn, Mateo Perez, Fabio Somenzi, Ashutosh Trivedi, Sven\n  Schewe, Dominik Wojtczak", "title": "Good-for-MDPs Automata for Probabilistic Analysis and Reinforcement\n  Learning", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We characterize the class of nondeterministic ${\\omega}$-automata that can be\nused for the analysis of finite Markov decision processes (MDPs). We call these\nautomata `good-for-MDPs' (GFM). We show that GFM automata are closed under\nclassic simulation as well as under more powerful simulation relations that\nleverage properties of optimal control strategies for MDPs. This closure\nenables us to exploit state-space reduction techniques, such as those based on\ndirect and delayed simulation, that guarantee simulation equivalence. We\ndemonstrate the promise of GFM automata by defining a new class of automata\nwith favorable properties - they are B\\\"uchi automata with low branching degree\nobtained through a simple construction - and show that going beyond\nlimit-deterministic automata may significantly benefit reinforcement learning.\n", "versions": [{"version": "v1", "created": "Wed, 11 Sep 2019 14:33:48 GMT"}, {"version": "v2", "created": "Wed, 30 Oct 2019 11:56:12 GMT"}], "update_date": "2019-10-31", "authors_parsed": [["Hahn", "Ernst Moritz", ""], ["Perez", "Mateo", ""], ["Somenzi", "Fabio", ""], ["Trivedi", "Ashutosh", ""], ["Schewe", "Sven", ""], ["Wojtczak", "Dominik", ""]]}, {"id": "1909.05406", "submitter": "Kojiro Kobayashi", "authors": "Kojiro Kobayashi", "title": "Minimum firing times of firing squad synchronization problems for paths\n  in grid spaces", "comments": "67 pages, 40 figures, 4 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the firing squad synchronization problems for paths in the two\nand the three-dimensional grid spaces. Minimal-time solutions of these problems\nare not known and are unlikely to exist. However, at present we have no proofs\nof their nonexistence. In this paper we show one result that suggests what type\nof study is necessary in order to prove their nonexistence.\n", "versions": [{"version": "v1", "created": "Thu, 5 Sep 2019 12:55:45 GMT"}], "update_date": "2019-09-13", "authors_parsed": [["Kobayashi", "Kojiro", ""]]}, {"id": "1909.05408", "submitter": "Kojiro Kobayashi", "authors": "Kojiro Kobayashi", "title": "The firing squad synchronization problem for squares with holes", "comments": "70 pages, 52 figures, 4 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The firing squad synchronization problem (FSSP, for short) is a problem in\nautomata theory introduced in 1957 by John Myhill. Its goal is to design a\nfinite automaton A such that, if copies of A are placed in a line and connected\nand are started at time 0 with their leftmost copy in a special triggering\nstate, then at some time (the \"firing time\") all copies enter a special \"firing\nstate\" simultaneously for the first time. FSSP has many variations and for many\nof them we know minimal-time solutions (solutions having shortest firing time).\nOne of such variations is the FSSP for squares (denoted by SQ) in which copies\nare placed in a square. In this paper we introduce a variation which we call\nthe FSSP for squares with k holes and denote by SH[k] by slightly modifying SQ\n(k >= 1). In the variation, copies of a finite automaton are placed in a square\nbut there are k positions (\"holes\") in the square where no copies are placed.\nWe show that SH[1] has a minimal-time solution. Moreover, for each problem\ninstance (a placement of copies in a square) C of SH[2], we determine the\nminimum firing time of C (the minimum value of firing times of C by A where A\nranges over all solutions of SH[2]). The variation SQ was introduced and its\nminimal-time solutions were found in 1970's. However, to find minimal-time\nsolutions of SH[k], a very simple modification of SQ, seems to be a very\ndifficult and challenging problem for k >= 2.\n", "versions": [{"version": "v1", "created": "Thu, 5 Sep 2019 05:44:38 GMT"}], "update_date": "2019-09-13", "authors_parsed": [["Kobayashi", "Kojiro", ""]]}, {"id": "1909.05828", "submitter": "Augusto Modanese", "authors": "Augusto Modanese", "title": "Sublinear-Time Language Recognition and Decision by One-Dimensional\n  Cellular Automata", "comments": "16 pages, 2 figures, to appear at DLT 2020", "journal-ref": null, "doi": "10.1007/978-3-030-48516-0_19", "report-no": null, "categories": "cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  After an apparent hiatus of roughly 30 years, we revisit a seemingly\nneglected subject in the theory of (one-dimensional) cellular automata:\nsublinear-time computation. The model considered is that of ACAs, which are\nlanguage acceptors whose acceptance condition depends on the states of all\ncells in the automaton. We prove a time hierarchy theorem for sublinear-time\nACA classes, analyze their intersection with the regular languages, and,\nfinally, establish strict inclusions in the parallel computation classes\n$\\mathsf{SC}$ and (uniform) $\\mathsf{AC}$. As an addendum, we introduce and\ninvestigate the concept of a decider ACA (DACA) as a candidate for a decider\ncounterpart to (acceptor) ACAs. We show the class of languages decidable in\nconstant time by DACAs equals the locally testable languages, and we also\ndetermine $\\Omega(\\sqrt{n})$ as the (tight) time complexity threshold for DACAs\nup to which no advantage compared to constant time is possible.\n", "versions": [{"version": "v1", "created": "Thu, 12 Sep 2019 17:36:42 GMT"}, {"version": "v2", "created": "Fri, 27 Dec 2019 13:11:35 GMT"}, {"version": "v3", "created": "Fri, 13 Mar 2020 16:14:55 GMT"}], "update_date": "2020-06-11", "authors_parsed": [["Modanese", "Augusto", ""]]}, {"id": "1909.05967", "submitter": "EPTCS", "authors": "Hao Zeng, Alexander Kurz, Emilio Tuosto", "title": "Interface Automata for Choreographies", "comments": "In Proceedings ICE 2019, arXiv:1909.05242", "journal-ref": "EPTCS 304, 2019, pp. 1-19", "doi": "10.4204/EPTCS.304.1", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Choreographic approaches to message-passing applications can be regarded as\nan instance of the model-driven development principles. Choreographies specify\ninteractions among distributed participants coordinating among themselves with\nmessage-passing at two levels of abstractions. A global view of the application\nis specified with a model that abstracts away from asynchrony while a local\nview of the application specifies the communication pattern of each\nparticipant. Noteworthy, the latter view can typically be algorithmically\nobtained by projection of the global view. A crucial element of this approach\nis to verify the so-called well-formed conditions on global views so that its\nprojections realise a sound communication protocol. We introduce a novel local\nmodel, group interface automata, to represent the local view of choreographies\nand propose a new method to verify the well-formedness of global\nchoreographies. We rely on a recently proposed semantics of global views\nformalised in terms of pomsets.\n", "versions": [{"version": "v1", "created": "Thu, 12 Sep 2019 22:22:42 GMT"}], "update_date": "2019-09-16", "authors_parsed": [["Zeng", "Hao", ""], ["Kurz", "Alexander", ""], ["Tuosto", "Emilio", ""]]}, {"id": "1909.05974", "submitter": "EPTCS", "authors": "Yi Xiao, Emilio Tuosto", "title": "On Learning Nominal Automata with Binders", "comments": "In Proceedings ICE 2019, arXiv:1909.05242", "journal-ref": "EPTCS 304, 2019, pp. 137-155", "doi": "10.4204/EPTCS.304.9", "report-no": null, "categories": "cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate a learning algorithm in the context of nominal automata, an\nextension of classical automata to alphabets featuring names. This class of\nautomata captures nominal regular languages; analogously to the classical\nlanguage theory, nominal automata have been shown to characterise nominal\nregular expressions with binders. These formalisms are amenable to abstract\nmodelling resource-aware computations. We propose a learning algorithm on\nnominal regular languages with binders. Our algorithm generalises Angluin's L*\nalgorithm with respect to nominal regular languages with binders. We show the\ncorrectness and study the theoretical complexity of our algorithm.\n", "versions": [{"version": "v1", "created": "Thu, 12 Sep 2019 22:25:56 GMT"}], "update_date": "2019-09-16", "authors_parsed": [["Xiao", "Yi", ""], ["Tuosto", "Emilio", ""]]}, {"id": "1909.05979", "submitter": "EPTCS", "authors": "J\\'er\\^ome Leroux (Univ. Bordeaux, CNRS, Bordeaux-INP), Jean-Francois\n  Raskin (Universit\\'e libre de Bruxelles (ULB))", "title": "Proceedings Tenth International Symposium on Games, Automata, Logics,\n  and Formal Verification", "comments": null, "journal-ref": "EPTCS 305, 2019", "doi": "10.4204/EPTCS.305", "report-no": null, "categories": "cs.GT cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Tenth International Symposium on\nGames, Automata, Logic and Formal Verification (GandALF 2019). The symposium\ntook place in Bordeaux, France, from the 2nd to the 3rd of September 2010. The\nGandALF symposium was established by a group of Italian computer scientists\ninterested in mathematical logic, automata theory, game theory, and their\napplications to the specification, design, and verification of complex systems.\nIts aim is to provide a forum where people from different areas, and possibly\nwith different backgrounds, can fruitfully interact. GandALF has a truly\ninternational spirit, as witnessed by the composition of the program and\nsteering committee and by the country distribution of the submitted papers.\n", "versions": [{"version": "v1", "created": "Thu, 12 Sep 2019 22:46:49 GMT"}], "update_date": "2019-09-16", "authors_parsed": [["Leroux", "J\u00e9r\u00f4me", "", "Univ. Bordeaux, CNRS, Bordeaux-INP"], ["Raskin", "Jean-Francois", "", "Universit\u00e9 libre de Bruxelles"]]}, {"id": "1909.06258", "submitter": "Alexis Linard", "authors": "Alexis Linard, Doina Bucur and Marielle Stoelinga", "title": "Fault Trees from Data: Efficient Learning with an Evolutionary Algorithm", "comments": "This paper is an extended version of the SETTA 2019 paper,\n  Springer-Verlag", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cyber-physical systems come with increasingly complex architectures and\nfailure modes, which complicates the task of obtaining accurate system\nreliability models. At the same time, with the emergence of the (industrial)\nInternet-of-Things, systems are more and more often being monitored via\nadvanced sensor systems. These sensors produce large amounts of data about the\ncomponents' failure behaviour, and can, therefore, be fruitfully exploited to\nlearn reliability models automatically. This paper presents an effective\nalgorithm for learning a prominent class of reliability models, namely fault\ntrees, from observational data. Our algorithm is evolutionary in nature; i.e.,\nis an iterative, population-based, randomized search method among fault-tree\nstructures that are increasingly more consistent with the observational data.\nWe have evaluated our method on a large number of case studies, both on\nsynthetic data, and industrial data. Our experiments show that our algorithm\noutperforms other methods and provides near-optimal results.\n", "versions": [{"version": "v1", "created": "Fri, 13 Sep 2019 14:35:49 GMT"}], "update_date": "2019-09-16", "authors_parsed": [["Linard", "Alexis", ""], ["Bucur", "Doina", ""], ["Stoelinga", "Marielle", ""]]}, {"id": "1909.07663", "submitter": "EPTCS", "authors": "Pascal Caron (LITIS, Universit\\'e de Rouen), Edwin Hamel-de le Court\n  (LITIS, Universit\\'e de Rouen), Jean-Gabriel Luque (LITIS, Universit\\'e de\n  Rouen)", "title": "Algebraic and Combinatorial Tools for State Complexity : Application to\n  the Star-Xor Problem", "comments": "In Proceedings GandALF 2019, arXiv:1909.05979", "journal-ref": "EPTCS 305, 2019, pp. 154-168", "doi": "10.4204/EPTCS.305.11", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the state complexity of the star of symmetrical differences\nusing modifiers and monsters. A monster is an automaton in which every function\nfrom states to states is represented by at least one letter. A modifier is a\nset of functions allowing one to transform a set of automata into one\nautomaton. These recent theoretical concepts allow one to find easily the\ndesired state complexity. We then exhibit a witness with a constant size\nalphabet.\n", "versions": [{"version": "v1", "created": "Tue, 17 Sep 2019 09:08:29 GMT"}], "update_date": "2019-09-18", "authors_parsed": [["Caron", "Pascal", "", "LITIS, Universit\u00e9 de Rouen"], ["Court", "Edwin Hamel-de le", "", "LITIS, Universit\u00e9 de Rouen"], ["Luque", "Jean-Gabriel", "", "LITIS, Universit\u00e9 de\n  Rouen"]]}, {"id": "1909.07676", "submitter": "EPTCS", "authors": "\\'Emilie Charlier, C\\'elia Cisternino, Adeline Massuir", "title": "State Complexity of the Multiples of the Thue-Morse Set", "comments": "In Proceedings GandALF 2019, arXiv:1909.05979. Short paper. A full\n  version of this paper appears as arXiv:1903.06114", "journal-ref": "EPTCS 305, 2019, pp. 34-49", "doi": "10.4204/EPTCS.305.3", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Thue-Morse set T is the set of those non-negative integers whose binary\nexpansions have an even number of 1. The name of this set comes from the fact\nthat its characteristic sequence is given by the famous Thue-Morse word\nabbabaabbaababba..., which is the fixed point starting with a of the word\nmorphism sending a to ab and b to ba. The numbers in T are sometimes called the\nevil numbers. We obtain an exact formula for the state complexity (i.e. the\nnumber of states of its minimal automaton) of the multiplication by a constant\nof the Thue-Morse set with respect to any integer base b which is a power of 2.\nOur proof is constructive and we are able to explicitly provide the minimal\nautomaton of the language of all 2^p-expansions of the set mT for any positive\nintegers m and p. The used method is general for any b-recognizable set of\nintegers. As an application, we obtain a decision procedure running in\nquadratic time for the problem of deciding whether a given 2^p-recognizable set\nis equal to some multiple of the Thue-Morse set.\n", "versions": [{"version": "v1", "created": "Tue, 17 Sep 2019 09:37:31 GMT"}], "update_date": "2019-09-18", "authors_parsed": [["Charlier", "\u00c9milie", ""], ["Cisternino", "C\u00e9lia", ""], ["Massuir", "Adeline", ""]]}, {"id": "1909.08348", "submitter": "Julia Eisentraut", "authors": "Julia Eisentraut, Jan K\\v{r}et\\'insk\\'y, Alexej Rotar", "title": "Stopping Criteria for Value and Strategy Iteration on Concurrent\n  Stochastic Reachability Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We consider concurrent stochastic games played on graphs with reachability\nand safety objectives. These games can be solved by value iteration as well as\nstrategy iteration, each of them yielding a sequence of under-approximations of\nthe reachability value and a sequence of over-approximation of the safety\nvalue, converging to it in the limit. For both approaches, we provide the first\n(anytime) algorithms with stopping criteria. The stopping criterion for value\niteration is based on providing a convergent sequence of over-approximations,\nwhich then allows to estimate the distance to the true value. For strategy\niteration, we bound the error by complementing the strategy iteration algorithm\nfor reachability by a new strategy iteration algorithm under-approximating the\nsafety-value.\n", "versions": [{"version": "v1", "created": "Wed, 18 Sep 2019 10:52:52 GMT"}], "update_date": "2019-09-19", "authors_parsed": [["Eisentraut", "Julia", ""], ["K\u0159et\u00ednsk\u00fd", "Jan", ""], ["Rotar", "Alexej", ""]]}, {"id": "1909.08538", "submitter": "EPTCS", "authors": "Daniel Neider (Max Planck Institute for Software Systems), Alexander\n  Weinert (German Aerospace Center (DLR), Simulation and Software Technology),\n  Martin Zimmermann (University of Liverpool)", "title": "Robust, Expressive, and Quantitative Linear Temporal Logics: Pick any\n  Two for Free", "comments": "In Proceedings GandALF 2019, arXiv:1909.05979. arXiv admin note:\n  substantial text overlap with arXiv:1808.09028", "journal-ref": "EPTCS 305, 2019, pp. 1-16", "doi": "10.4204/EPTCS.305.1", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linear Temporal Logic (LTL) is the standard specification language for\nreactive systems and is successfully applied in industrial settings. However,\nmany shortcomings of LTL have been identified in the literature, among them the\nlimited expressiveness, the lack of quantitative features, and the inability to\nexpress robustness. There is work on overcoming these shortcomings, but each of\nthese is typically addressed in isolation. This is insufficient for\napplications where all shortcomings manifest themselves simultaneously. Here,\nwe tackle this issue by introducing logics that address more than one\nshortcoming. To this end, we combine the logics Linear Dynamic Logic,\nPrompt-LTL, and robust LTL, each addressing one aspect, to new logics. For all\ncombinations of two aspects, the resulting logic has the same desirable\nalgorithmic properties as plain LTL. In particular, the highly efficient\nalgorithmic backends that have been developed for LTL are also applicable to\nthese new logics. Finally, we discuss how to address all three aspects\nsimultaneously.\n", "versions": [{"version": "v1", "created": "Tue, 17 Sep 2019 08:51:09 GMT"}], "update_date": "2019-09-19", "authors_parsed": [["Neider", "Daniel", "", "Max Planck Institute for Software Systems"], ["Weinert", "Alexander", "", "German Aerospace Center"], ["Zimmermann", "Martin", "", "University of Liverpool"]]}, {"id": "1909.08541", "submitter": "EPTCS", "authors": "Paritosh K. Pandya (Tata Institute of Fundamental Research, Mumbai),\n  Amol Wakankar (Homi Bhabha National Institute, Mumbai and Bhabha Atomic\n  Research Centre, Mumbai)", "title": "Specification and Optimal Reactive Synthesis of Run-time Enforcement\n  Shields", "comments": "In Proceedings GandALF 2019, arXiv:1909.05979. arXiv admin note: text\n  overlap with arXiv:1905.11157", "journal-ref": "EPTCS 305, 2019, pp. 91-106", "doi": "10.4204/EPTCS.305.7", "report-no": null, "categories": "cs.LO cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A system with sporadic errors (SSE) is a controller which produces high\nquality output but it may occasionally violate a critical requirement REQ(I,O).\nA run-time enforcement shield is a controller which takes (I,O) (coming from\nSSE) as its input, and it produces a corrected output O' which guarantees the\ninvariance of requirement REQ(I,O'). Moreover, the output sequence O' must\ndeviate from O \"as little as possible\" to maintain the quality. In this paper,\nwe give a method for logical specification of shields using formulas of logic\nQuantified Discrete Duration Calculus (QDDC). The specification consists of a\ncorrectness requirement REQ as well as a hard deviation constraint HDC which\nmust both be mandatorily and invariantly satisfied by the shield. Moreover, we\nalso use quantitative optimization to give a shield which minimizes the\nexpected value of cumulative deviation in an H-optimal fashion. We show how\ntool DCSynth implementing soft requirement guided synthesis can be used for\nautomatic synthesis of shields from a given specification. Next, we give\nlogical formulas specifying several notions of shields including the\nk-Stabilizing shield of Bloem \"et al.\" as well as the Burst-error shield of Wu\n\"et al.\", and a new e,d-shield. Shields can be automatically synthesized for\nall these specifications using the tool DCSynth. We give experimental results\nshowing the performance of our shield synthesis tool in relation to previous\nwork. We also compare the performance of the shields synthesized under diverse\nhard deviation constraints in terms of their expected deviation and the worst\ncase burst-deviation latency.\n", "versions": [{"version": "v1", "created": "Tue, 17 Sep 2019 08:59:14 GMT"}], "update_date": "2019-09-19", "authors_parsed": [["Pandya", "Paritosh K.", "", "Tata Institute of Fundamental Research, Mumbai"], ["Wakankar", "Amol", "", "Homi Bhabha National Institute, Mumbai and Bhabha Atomic\n  Research Centre, Mumbai"]]}, {"id": "1909.08543", "submitter": "EPTCS", "authors": "Kitti Gelle (University of Szeged, Hungary), Szabolcs Iv\\'an\n  (University of Szeged, Hungary)", "title": "On the Order Type of Scattered Context-Free Orderings", "comments": "In Proceedings GandALF 2019, arXiv:1909.05979. arXiv admin note: text\n  overlap with arXiv:1907.11573", "journal-ref": "EPTCS 305, 2019, pp. 169-182", "doi": "10.4204/EPTCS.305.12", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that if a context-free grammar generates a language whose\nlexicographic ordering is well-ordered of type less than $\\omega^2$, then its\norder type is effectively computable.\n", "versions": [{"version": "v1", "created": "Tue, 17 Sep 2019 09:10:54 GMT"}], "update_date": "2019-09-19", "authors_parsed": [["Gelle", "Kitti", "", "University of Szeged, Hungary"], ["Iv\u00e1n", "Szabolcs", "", "University of Szeged, Hungary"]]}, {"id": "1909.09393", "submitter": "Ryoma Sin'ya", "authors": "Ryoma Sin'ya", "title": "Simple proof of Parikh's theorem a la Takahashi", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this report we describe a simple proof of Parikh's theorem a la Takahashi,\nbased on a decomposition of derivation trees. The idea of decomposition is\nappeared in her master's thesis written in 1970.\n", "versions": [{"version": "v1", "created": "Fri, 20 Sep 2019 09:50:37 GMT"}], "update_date": "2019-09-23", "authors_parsed": [["Sin'ya", "Ryoma", ""]]}, {"id": "1909.10125", "submitter": "Kojiro Kobayashi", "authors": "Kojiro Kobayashi", "title": "Nonexistence of minimal-time solutions for some variations of the firing\n  squad synchronization problem having simple geometric configurations", "comments": "42 pages, 18 figures, 3 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove nonexistence of minimal-time solutions for three variations of the\nfiring squad synchronization problem (FSSP, for short). Configurations of these\nvariations are paths in the two-dimensional grid space having simple geometric\nshapes. In the first variation a configuration is an L-shaped path such that\nthe ratio of the length of horizontal line to that of the vertical line is\nfixed. The general may be at any position. In the second and the third\nvariations a configuration is a rectangular wall such that the ratio of the\nlength of the two horizontal walls to that of the two vertical walls is fixed.\nThe general is at the left down corner in the second variation and may be at\nany position in the third variation. We use the idea used in the proof of\nYamashita et al's recent similar result for variations of FSSP with\nsub-generals.\n", "versions": [{"version": "v1", "created": "Mon, 23 Sep 2019 02:18:33 GMT"}], "update_date": "2019-09-24", "authors_parsed": [["Kobayashi", "Kojiro", ""]]}, {"id": "1909.10261", "submitter": "Danny Hucke", "authors": "Moses Ganardi, Danny Hucke, Markus Lohrey, Tatiana Starikovskaya", "title": "Sliding window property testing for regular languages", "comments": "A short version of this paper was accepted for presentation at ISAAC\n  2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.CL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the problem of recognizing regular languages in a variant of the\nstreaming model of computation, called the sliding window model. In this model,\nwe are given a size of the sliding window $n$ and a stream of symbols. At each\ntime instant, we must decide whether the suffix of length $n$ of the current\nstream (\"the active window\") belongs to a given regular language.\n  Recent works showed that the space complexity of an optimal deterministic\nsliding window algorithm for this problem is either constant, logarithmic or\nlinear in the window size $n$ and provided natural language theoretic\ncharacterizations of the space complexity classes. Subsequently, those results\nwere extended to randomized algorithms to show that any such algorithm admits\neither constant, double logarithmic, logarithmic or linear space complexity.\n  In this work, we make an important step forward and combine the sliding\nwindow model with the property testing setting, which results in\nultra-efficient algorithms for all regular languages. Informally, a sliding\nwindow property tester must accept the active window if it belongs to the\nlanguage and reject it if it is far from the language. We consider\ndeterministic and randomized sliding window property testers with one-sided and\ntwo-sided errors. In particular, we show that for any regular language, there\nis a deterministic sliding window property tester that uses logarithmic space\nand a randomized sliding window property tester with two-sided error that uses\nconstant space.\n", "versions": [{"version": "v1", "created": "Mon, 23 Sep 2019 10:12:13 GMT"}], "update_date": "2019-09-25", "authors_parsed": [["Ganardi", "Moses", ""], ["Hucke", "Danny", ""], ["Lohrey", "Markus", ""], ["Starikovskaya", "Tatiana", ""]]}, {"id": "1909.10489", "submitter": "Amnon  Rosenmann", "authors": "Amnon Rosenmann", "title": "On the Distance between Timed Automata", "comments": "19 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of inclusion of the language accepted by timed automaton $A$\n(e.g., the implementation) in the language accepted by $B$ (e.g., the\nspecification) is, in general, undecidable in the class of non-deterministic\ntimed automata. In order to tackle this disturbing problem we show how to\neffectively construct deterministic timed automata $A_d$ and $B_d$ that are\ndiscretizations (digitizations) of the non-deterministic timed automata $A$ and\n$B$ and differ from the original automata by at most $\\frac{1}{6}$ time units\non each occurrence of an event. Language inclusion in the discretized timed\nautomata is decidable and it is also decidable when instead of\n$\\mathfrak{L}(B)$ we consider $\\overline{\\mathfrak{L}(B)}$, the closure of\n${\\mathfrak{L}(B)}$ in the Euclidean topology: if $\\mathfrak{L}(A_d) \\nsubseteq\n\\mathfrak{L}(B_d)$ then $\\mathfrak{L}(A) \\nsubseteq \\mathfrak{L}(B)$ and if\n$\\mathfrak{L}(A_d) \\subseteq \\mathfrak{L}(B_d)$ then $\\mathfrak{L}(A) \\subseteq\n\\overline{\\mathfrak{L}(B)}$.\n  Moreover, if $\\mathfrak{L}(A_d) \\nsubseteq \\mathfrak{L}(B_d)$ we would like\nto know how far away is $\\mathfrak{L}(A_d)$ from being included in\n$\\mathfrak{L}(B_d)$. For that matter we define the distance between the\nlanguages of timed automata as the limit on how far away a timed trace of one\ntimed automaton can be from the closest timed trace of the other timed\nautomaton. We then show how one can decide under some restriction whether the\ndistance between two timed automata is finite or infinite.\n", "versions": [{"version": "v1", "created": "Mon, 23 Sep 2019 17:13:45 GMT"}], "update_date": "2019-09-24", "authors_parsed": [["Rosenmann", "Amnon", ""]]}, {"id": "1909.10493", "submitter": "Chunhui Guo", "authors": "Chunhui Guo, Zhicheng Fu, Zhenyu Zhang, Shangping Ren, Lui Sha", "title": "Formalism for Supporting the Development of Verifiably Safe Medical\n  Guidelines with Statecharts", "comments": "Technical Report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.CL cs.FL cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Improving the effectiveness and safety of patient care is the ultimate\nobjective for medical cyber-physical systems. Many medical best practice\nguidelines exist, but most of the existing guidelines in handbooks are\ndifficult for medical staff to remember and apply clinically. Furthermore,\nalthough the guidelines have gone through clinical validations, validations by\nmedical professionals alone do not provide guarantees for the safety of medical\ncyber-physical systems. Hence, formal verification is also needed. The paper\npresents the formal semantics for a framework that we developed to support the\ndevelopment of verifiably safe medical guidelines.\n  The framework allows computer scientists to work together with medical\nprofessionals to transform medical best practice guidelines into executable\nstatechart models, Yakindu in particular, so that medical functionalities and\nproperties can be quickly prototyped and validated. Existing formal\nverification technologies, UPPAAL timed automata in particular, is integrated\ninto the framework to provide formal verification capabilities to verify safety\nproperties. However, some components used/built into the framework, such as the\nopen-source Yakindu statecharts as well as the transformation rules from\nstatecharts to timed automata, do not have built-in semantics. The ambiguity\nbecomes unavoidable unless formal semantics is defined for the framework, which\nis what the paper is to present.\n", "versions": [{"version": "v1", "created": "Mon, 23 Sep 2019 17:25:50 GMT"}], "update_date": "2019-09-24", "authors_parsed": [["Guo", "Chunhui", ""], ["Fu", "Zhicheng", ""], ["Zhang", "Zhenyu", ""], ["Ren", "Shangping", ""], ["Sha", "Lui", ""]]}, {"id": "1909.11159", "submitter": "Lars Lindemann", "authors": "Lars Lindemann and Dimos V. Dimarogonas", "title": "Efficient Automata-based Planning and Control under Spatio-Temporal\n  Logic Specifications", "comments": "8 pages - Accepted for Publication at ACC 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The use of spatio-temporal logics in control is motivated by the need to\nimpose complex spatial and temporal behavior on dynamical systems, and to\ncontrol these systems accordingly. Synthesizing correct-by-design control laws\nis a challenging task resulting in computationally demanding methods. We\nconsider efficient automata-based planning for continuous-time systems under\nsignal interval temporal logic specifications, an expressive fragment of signal\ntemporal logic. The planning is based on recent results for automata-based\nverification of metric interval temporal logic. A timed signal transducer is\nobtained accepting all Boolean signals that satisfy a metric interval temporal\nlogic specification, which is abstracted from the signal interval temporal\nlogic specification at hand. This transducer is modified to account for the\nspatial properties of the signal interval temporal logic specification,\ncharacterizing all real-valued signals that satisfy this specification. Using\nlogic-based feedback control laws, such as the ones we have presented in\nearlier works, we then provide an abstraction of the system that, in a suitable\nway, aligns with the modified timed signal transducer. This allows to avoid the\nstate space explosion that is typically induced by forming a product automaton\nbetween an abstraction of the system and the specification.\n", "versions": [{"version": "v1", "created": "Tue, 24 Sep 2019 20:23:45 GMT"}, {"version": "v2", "created": "Tue, 24 Mar 2020 22:35:40 GMT"}], "update_date": "2020-03-26", "authors_parsed": [["Lindemann", "Lars", ""], ["Dimarogonas", "Dimos V.", ""]]}, {"id": "1909.12004", "submitter": "Peter Chini", "authors": "Peter Chini, Roland Meyer, Prakash Saivasan", "title": "Complexity of Liveness in Parameterized Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the fine-grained complexity of liveness verification for\nleader contributor systems. These consist of a designated leader thread and an\narbitrary number of identical contributor threads communicating via a shared\nmemory. The liveness verification problem asks whether there is an infinite\ncomputation of the system in which the leader reaches a final state infinitely\noften. Like its reachability counterpart, the problem is known to be\nNP-complete. Our results show that, even from a fine-grained point of view, the\ncomplexities differ only by a polynomial factor.\n  Liveness verification decomposes into reachability and cycle detection. We\npresent a fixed point iteration solving the latter in polynomial time. For\nreachability, we reconsider the two standard parameterizations. When\nparameterized by the number of states of the leader L and the size of the data\ndomain D, we show an (L + D)^O(L + D)-time algorithm. It improves on a previous\nalgorithm, thereby settling an open problem. When parameterized by the number\nof states of the contributor C, we reuse an O*(2^C)-time algorithm. We show how\nto connect both algorithms with the cycle detection to obtain algorithms for\nliveness verification. The running times of the composed algorithms match those\nof reachability, proving that the fine-grained lower bounds for liveness\nverification are met.\n", "versions": [{"version": "v1", "created": "Thu, 26 Sep 2019 09:47:25 GMT"}, {"version": "v2", "created": "Mon, 7 Oct 2019 08:27:52 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Chini", "Peter", ""], ["Meyer", "Roland", ""], ["Saivasan", "Prakash", ""]]}, {"id": "1909.12582", "submitter": "Lionel Rieg", "authors": "G\\'erard Berry and Lionel Rieg", "title": "Towards Coq-verified Esterel Semantics and Compiling", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper focuses on semantics of the Esterel synchronous programming\nlanguage. In particular, in addition to the usual behavioral (CBS) and state\n(CSS) semantics, it introduces a novel microstep semantics which does not need\nthe Can potential function. Formal proofs in Coq of the equivalence between the\nCBS and CSS semantics and of the refinement between the CSS and microstep\nsemantics are also provided.\n", "versions": [{"version": "v1", "created": "Fri, 27 Sep 2019 09:43:14 GMT"}], "update_date": "2019-09-30", "authors_parsed": [["Berry", "G\u00e9rard", ""], ["Rieg", "Lionel", ""]]}, {"id": "1909.12626", "submitter": "Tayssir Touili", "authors": "Tayssir Touili and Xin Ye", "title": "Reachability Analysis of Self Modifying Code", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A Self modifying code is code that modifies its own instructions during\nexecution time. It is nowadays widely used, especially in malware to make the\ncode hard to analyse and to detect by anti-viruses. Thus, the analysis of such\nself modifying programs is a big challenge. Pushdown systems (PDSs) is a\nnatural model that is extensively used for the analysis of sequential programs\nbecause they allow to accurately model procedure calls and mimic the program's\nstack. In this work, we propose to extend the PushDown System model with\nself-modifying rules. We call the new model Self-Modifying PushDown System\n(SM-PDS). A SM-PDS is a PDS that can modify its own set of transitions during\nexecution. We show how SM-PDSs can be used to naturally represent\nself-modifying programs and provide efficient algorithms to compute the\nbackward and forward reachable configurations of SM-PDSs. We implemented our\ntechniques in a tool and obtained encouraging results. In particular, we\nsuccessfully applied our tool for the detection of self-modifying malware.\n", "versions": [{"version": "v1", "created": "Fri, 27 Sep 2019 11:25:09 GMT"}], "update_date": "2019-09-30", "authors_parsed": [["Touili", "Tayssir", ""], ["Ye", "Xin", ""]]}, {"id": "1909.12713", "submitter": "Jakub Ber\\'anek", "authors": "Stanislav B\\\"ohm, Jakub Ber\\'anek, Martin \\v{S}urkovsk\\'y", "title": "Haydi: Rapid Prototyping and Combinatorial Objects", "comments": null, "journal-ref": "Foundations of Information and Knowledge Systems - 10th\n  International Symposium, FoIKS 2018, Budapest, Hungary, May 14-18, 2018,\n  Proceedings. Lecture Notes in Computer Science 10833, Springer 2018, ISBN\n  978-3-319-90049-0", "doi": "10.1007/978-3-319-90050-6_8", "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Haydi (http://haydi.readthedocs.io) is a framework for generating discrete\nstructures. It provides a way to define a structure from basic building blocks\nand then enumerate all elements, all non-isomorphic elements, or generate\nrandom elements in the structure. Haydi is designed as a tool for rapid\nprototyping. It is implemented as a pure Python package and supports execution\nin distributed environments. The goal of this paper is to give the overall\npicture of Haydi together with a formal definition for the case of generating\ncanonical forms.\n", "versions": [{"version": "v1", "created": "Fri, 27 Sep 2019 14:35:49 GMT"}], "update_date": "2020-10-22", "authors_parsed": [["B\u00f6hm", "Stanislav", ""], ["Ber\u00e1nek", "Jakub", ""], ["\u0160urkovsk\u00fd", "Martin", ""]]}, {"id": "1909.13139", "submitter": "Alessandro Trindade", "authors": "Alessandro Trindade and Lucas Cordeiro", "title": "Optimal Sizing of Stand-alone Solar PV Systems via Automated Formal\n  Synthesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There exist various methods and tools to size solar photovoltaic systems;\nhowever, these tools rely on simulations, which do not cover all aspects of the\ndesign space during the search for optimal solution. In prior studies in\noptimal sizing, the focus was always on criteria or objectives. Here, we\npresent a new sound and automated approach to obtain optimal sizing using an\nunprecedented program synthesis. Our variant of counterexample guided inductive\nsynthesis (CEGIS) approach has two phases linking the technical and cost\nanalysis: first we synthesize a feasible candidate based on power reliability,\nbut that may not achieve the lowest cost; second, the candidate is then\nverified iteratively with a lower bound cost via symbolic model checking. If\nthe verification step does not fail, the lower bound is adjusted; and if it\nfails, a counterexample provides the optimal solution. Experimental results\nusing seven case studies and commercial equipment data show that our synthesis\nmethod can produce within an acceptable run-time the optimal system sizing. We\nalso present a comparative with a specialized simulation tool over real\nphotovoltaic systems to show the effectiveness of our approach, which can\nprovide a more detailed and accurate solution than that simulation tool.\n", "versions": [{"version": "v1", "created": "Sat, 28 Sep 2019 19:34:19 GMT"}], "update_date": "2019-10-01", "authors_parsed": [["Trindade", "Alessandro", ""], ["Cordeiro", "Lucas", ""]]}, {"id": "1909.13604", "submitter": "Ramon Janssen", "authors": "Ramon Janssen, Frits Vaandrager, Jan Tretmans", "title": "Relating Alternating Relations for Conformance and Refinement", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-40914-2_10", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Various relations have been defined to express refinement and conformance for\nstate-transition systems with inputs and outputs, such as ioco and uioco in the\narea of model-based testing, and alternating simulation and alternating-trace\ncontainment originating from game theory and formal verification. Several\npapers have compared these independently developed relations, but these\ncomparisons make assumptions (e.g., input-enabledness), pose restrictions\n(e.g., determinism - then they all coincide), use different models (e.g.,\ninterface automata and Kripke structures), or do not deal with the concept of\nquiescence. In this paper, we present the integration of the ioco/uioco theory\nof model-based testing and the theory of alternating refinements, within the\ndomain of non-deterministic, non-input-enabled interface automata. A standing\nconjecture is that ioco and alternating-trace containment coincide. Our main\nresult is that this conjecture does not hold, but that uioco coincides with a\nvariant of alternating-trace containment, for image finite interface automata\nand with explicit treatment of quiescence. From the comparison between ioco\ntheory and alternating refinements, we conclude that ioco and the original\nrelation of alternating-trace containment are too strong for realistic\nblack-box scenarios. We present a refinement relation which can express both\nuioco and refinement in game theory, while being simpler and having a clearer\nobservational interpretation.\n", "versions": [{"version": "v1", "created": "Mon, 30 Sep 2019 11:46:16 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Janssen", "Ramon", ""], ["Vaandrager", "Frits", ""], ["Tretmans", "Jan", ""]]}]