[{"id": "2107.01468", "submitter": "A V Sreejith", "authors": "Bharat Adsul, Saptarshi Sarkar, A.V. Sreejith", "title": "First-Order logic and its Infinitary Quantifier Extensions over\n  Countable Words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We contribute to the refined understanding of the language-logic-algebra\ninterplay in the context of first-order properties of countable words. We\nestablish decidable algebraic characterizations of one variable fragment of FO\nas well as boolean closure of existential fragment of FO via a strengthening of\nSimon's theorem about piecewise testable languages. We propose a new extension\nof FO which admits infinitary quantifiers to reason about the inherent\ninfinitary properties of countable words. We provide a very natural and\nhierarchical block-product based characterization of the new extension. We also\nexplicate its role in view of other natural and classical logical systems such\nas WMSO and FO[cut] - an extension of FO where quantification over\nDedekind-cuts is allowed. We also rule out the possibility of a finite basis\nfor a block-product based characterization of these logical systems. Finally,\nwe report simple but novel algebraic characterizations of one variable\nfragments of the hierarchies of the new proposed extension of FO.\n", "versions": [{"version": "v1", "created": "Sat, 3 Jul 2021 17:08:04 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["Adsul", "Bharat", ""], ["Sarkar", "Saptarshi", ""], ["Sreejith", "A. V.", ""]]}, {"id": "2107.01566", "submitter": "Salomon Sickert", "authors": "Orna Kupferman and Nir Lavee and Salomon Sickert", "title": "Certifying DFA Bounds for Recognition and Separation", "comments": "This is the full version of an article with the same title that\n  appears in the ATVA 2021 conference proceedings. The final authenticated\n  publication is available online at https://doi.org/[not-yet-existing-DOI]", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The automation of decision procedures makes certification essential. We\nsuggest to use determinacy of turn-based two-player games with regular winning\nconditions in order to generate certificates for the number of states that a\ndeterministic finite automaton (DFA) needs in order to recognize a given\nlanguage. Given a language $L$ and a bound $k$, recognizability of $L$ by a DFA\nwith $k$ states is reduced to a game between Prover and Refuter. The\ninteraction along the game then serves as a certificate. Certificates generated\nby Prover are minimal DFAs. Certificates generated by Refuter are faulty\nattempts to define the required DFA. We compare the length of offline\ncertificates, which are generated with no interaction between Prover and\nRefuter, and online certificates, which are based on such an interaction, and\nare thus shorter. We show that our approach is useful also for certification of\nseparability of regular languages by a DFA of a given size. Unlike DFA\nminimization, which can be solved in polynomial time, separation is\nNP-complete, and thus the certification approach is essential. In addition, we\nprove NP-completeness of a strict version of separation.\n", "versions": [{"version": "v1", "created": "Sun, 4 Jul 2021 07:37:11 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["Kupferman", "Orna", ""], ["Lavee", "Nir", ""], ["Sickert", "Salomon", ""]]}, {"id": "2107.01687", "submitter": "Stefan Kiefer", "authors": "Stefan Kiefer and Pavel Semukhin and Cas Widdershoven", "title": "Linear-Time Model Checking Branching Processes", "comments": "full version of a CONCUR'21 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  (Multi-type) branching processes are a natural and well-studied model for\ngenerating random infinite trees. Branching processes feature both\nnondeterministic and probabilistic branching, generalizing both transition\nsystems and Markov chains (but not generally Markov decision processes). We\nstudy the complexity of model checking branching processes against linear-time\nomega-regular specifications: is it the case almost surely that every branch of\na tree randomly generated by the branching process satisfies the omega-regular\nspecification? The main result is that for LTL specifications this problem is\nin PSPACE, subsuming classical results for transition systems and Markov\nchains, respectively. The underlying general model-checking algorithm is based\non the automata-theoretic approach, using unambiguous B\\\"uchi automata.\n", "versions": [{"version": "v1", "created": "Sun, 4 Jul 2021 17:18:26 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["Kiefer", "Stefan", ""], ["Semukhin", "Pavel", ""], ["Widdershoven", "Cas", ""]]}, {"id": "2107.01998", "submitter": "Tim Lyon", "authors": "Tim S. Lyon", "title": "Nested Sequents for Intuitionistic Modal Logics via Structural\n  Refinement", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DM cs.FL math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We employ a recently developed methodology -- called \"structural refinement\"\n-- to extract nested sequent systems for a sizable class of intuitionistic\nmodal logics from their respective labelled sequent systems. This method can be\nseen as a means by which labelled sequent systems can be transformed into\nnested sequent systems through the introduction of propagation rules and the\nelimination of structural rules, followed by a notational translation. The\nnested systems we obtain incorporate propagation rules that are parameterized\nwith formal grammars, and which encode certain frame conditions expressible as\nfirst-order Horn formulae that correspond to a subclass of the Scott-Lemmon\naxioms. We show that our nested systems are sound, cut-free complete, and admit\nhp-admissibility of typical structural rules.\n", "versions": [{"version": "v1", "created": "Mon, 5 Jul 2021 13:17:13 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["Lyon", "Tim S.", ""]]}, {"id": "2107.02262", "submitter": "\\\"Ozlem Salehi", "authors": "\\\"Ozlem Salehi, Abuzer Yakary{\\i}lmaz", "title": "State-efficient QFA Algorithm for Quantum Computers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The study of quantum finite automata (QFA's) is one of the possible\napproaches in exploring quantum computers with finite memory. Despite being one\nof the most restricted models, Moore-Crutchfield quantum finite automaton\n(MCQFA) is proven to be exponentially more succinct than classical finite\nautomata models in recognizing certain languages such as $\\mathtt{MOD}_{\\rm p}\n= \\{a^{j}~ |~ j \\equiv 0 \\mod p\\}$, where $p$ is a prime number. In this paper,\nwe present a modified MCQFA algorithm for the language $\\mathtt{MOD}_{\\rm p}$,\nthe operators of which are selected based on the basis gates on the available\nreal quantum computers. As a consequence, we obtain shorter quantum programs\nusing less basis gates compared to the implementation of the original algorithm\ngiven in the literature.\n", "versions": [{"version": "v1", "created": "Mon, 5 Jul 2021 20:41:18 GMT"}], "update_date": "2021-07-07", "authors_parsed": [["Salehi", "\u00d6zlem", ""], ["Yakary\u0131lmaz", "Abuzer", ""]]}, {"id": "2107.02503", "submitter": "Dominik K\\\"oppl", "authors": "Jacqueline W. Daykin and Dominik K\\\"oppl and David K\\\"ubel and Florian\n  Stober", "title": "On Arithmetically Progressed Suffix Arrays and related Burrows-Wheeler\n  Transforms", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We characterize those strings whose suffix arrays are based on arithmetic\nprogressions, in particular, arithmetically progressed permutations where all\npairs of successive entries of the permutation have the same difference modulo\nthe respective string length. We show that an arithmetically progressed\npermutation $P$ coincides with the suffix array of a unary, binary, or ternary\nstring. We further analyze the conditions of a given $P$ under which we can\nfind a uniquely defined string over either a binary or ternary alphabet having\n$P$ as its suffix array. For the binary case, we show its connection to lower\nChristoffel words, balanced words, and Fibonacci words. In addition to solving\nthe arithmetically progressed suffix array problem, we give the shape of the\nBurrows-Wheeler transform of those strings solving this problem. These results\ngive rise to numerous future research directions.\n", "versions": [{"version": "v1", "created": "Tue, 6 Jul 2021 09:48:41 GMT"}], "update_date": "2021-07-07", "authors_parsed": [["Daykin", "Jacqueline W.", ""], ["K\u00f6ppl", "Dominik", ""], ["K\u00fcbel", "David", ""], ["Stober", "Florian", ""]]}, {"id": "2107.02591", "submitter": "Sarah Winter", "authors": "Sarah Winter", "title": "Decision problems for origin-close top-down tree transducers (full\n  version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Tree transductions are binary relations of finite trees. For tree\ntransductions defined by non-deterministic top-down tree transducers,\ninclusion, equivalence and synthesis problems are known to be undecidable.\nAdding origin semantics to tree transductions, i.e., tagging each output node\nwith the input node it originates from, is a known way to recover decidability\nfor inclusion and equivalence. The origin semantics is rather rigid, in this\nwork, we introduce a similarity measure for transducers with origin semantics\nand show that we can decide inclusion, equivalence and synthesis problems for\norigin-close non-deterministic top-down tree transducers.\n", "versions": [{"version": "v1", "created": "Tue, 6 Jul 2021 13:07:05 GMT"}], "update_date": "2021-07-07", "authors_parsed": [["Winter", "Sarah", ""]]}, {"id": "2107.03174", "submitter": "Peter Leupold", "authors": "Peter Leupold and Sebastian Maneth", "title": "Deciding Top-Down Determinism of Regular Tree Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is well known that for a regular tree language it is decidable whether or\nnot it can be recognized by a deterministic top-down tree automaton (DTA).\nHowever, the computational complexity of this problem has not been studied. We\nshow that for a given deterministic bottom-up tree automaton it can be decided\nin quadratic time whether or not its language can be recognized by a DTA. Since\nthere are finite tree languages that cannot be recognized by DTAs, we also\nconsider finite unions of \\DTAs and show that also here, definability within\ndeterministic bottom-up tree automata is decidable in quadratic time.\n", "versions": [{"version": "v1", "created": "Wed, 7 Jul 2021 12:09:40 GMT"}], "update_date": "2021-07-08", "authors_parsed": [["Leupold", "Peter", ""], ["Maneth", "Sebastian", ""]]}, {"id": "2107.03213", "submitter": "Henning Urbat", "authors": "Henning Urbat and Daniel Hausmann and Stefan Milius and Lutz\n  Schr\\\"oder", "title": "Nominal B\\\"uchi Automata with Name Allocation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Infinite words over infinite alphabets serve as models of the temporal\ndevelopment of the allocation and (re-)use of resources over linear time. We\napproach omega-languages over infinite alphabets in the setting of nominal\nsets, and study languages of infinite bar strings, i.e. infinite sequences of\nnames that feature binding of fresh names; binding corresponds roughly to\nreading letters from input words in automata models with registers. We\nintroduce regular nominal nondeterministic B\\\"uchi automata (B\\\"uchi RNNAs), an\nautomata model for languages of infinite bar strings, repurposing the\npreviously introduced RNNAs over finite bar strings. Our machines feature\nexplicit binding (i.e. resource-allocating) transitions and process their input\nvia a B\\\"uchi-type acceptance condition. They emerge from the abstract\nperspective on name binding given by the theory of nominal sets. As our main\nresult we prove that, in contrast to most other nondeterministic automata\nmodels over infinite alphabets, language inclusion of B\\\"uchi RNNAs is\ndecidable and in fact elementary. This makes B\\\"uchi RNNAs a suitable tool for\napplications in model checking.\n", "versions": [{"version": "v1", "created": "Wed, 7 Jul 2021 13:38:35 GMT"}, {"version": "v2", "created": "Sat, 10 Jul 2021 09:38:21 GMT"}], "update_date": "2021-07-13", "authors_parsed": [["Urbat", "Henning", ""], ["Hausmann", "Daniel", ""], ["Milius", "Stefan", ""], ["Schr\u00f6der", "Lutz", ""]]}, {"id": "2107.03229", "submitter": "Henning Urbat", "authors": "Robert Samuel Ralph Myers and Henning Urbat", "title": "Syntactic Minimization of Nondeterministic Finite Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Nondeterministic automata may be viewed as succinct programs implementing\ndeterministic automata, i.e. complete specifications. Converting a given\ndeterministic automaton into a small nondeterministic one is known to be\ncomputationally very hard; in fact, the ensuing decision problem is\nPSPACE-complete. This paper stands in stark contrast to the status quo. We\nrestrict attention to subatomic nondeterministic automata, whose individual\nstates accept unions of syntactic congruence classes. They are general enough\nto cover almost all structural results concerning nondeterministic\nstate-minimality. We prove that converting a monoid recognizing a regular\nlanguage into a small subatomic acceptor corresponds to an NP-complete problem.\nThe NP certificates are solutions of simple equations involving relations over\nthe syntactic monoid. We also consider the subclass of atomic nondeterministic\nautomata introduced by Brzozowski and Tamm. Given a deterministic automaton and\nanother one for the reversed language, computing small atomic acceptors is\nshown to be NP-complete with analogous certificates. Our complexity results\nemerge from an algebraic characterization of (sub)atomic acceptors in terms of\ndeterministic automata with semilattice structure, combined with an equivalence\nof categories leading to succinct representations.\n", "versions": [{"version": "v1", "created": "Wed, 7 Jul 2021 14:00:12 GMT"}, {"version": "v2", "created": "Fri, 9 Jul 2021 14:56:48 GMT"}], "update_date": "2021-07-12", "authors_parsed": [["Myers", "Robert Samuel Ralph", ""], ["Urbat", "Henning", ""]]}, {"id": "2107.03984", "submitter": "Felix Stutz", "authors": "Rupak Majumdar, Madhavan Mukund, Felix Stutz, Damien Zufferey", "title": "Generalising Projection in Asynchronous Multiparty Session Types", "comments": "16 pages, 36 pages including appendix; to appear in CONCUR 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Multiparty session types (MSTs) provide an efficient methodology for\nspecifying and verifying message passing software systems. In the theory of\nMSTs, a global type specifies the interaction among the roles at the global\nlevel. A local specification for each role is generated by projecting from the\nglobal type on to the message exchanges it participates in. Whenever a global\ntype can be projected on to each role, the composition of the projections is\ndeadlock free and has exactly the behaviours specified by the global type. The\nkey to the usability of MSTs is the projection operation: a more expressive\nprojection allows more systems to be type-checked but requires a more difficult\nsoundness argument. In this paper, we generalise the standard projection\noperation in MSTs. This allows us to model and type-check many design patterns\nin distributed systems, such as load balancing, that are rejected by the\nstandard projection. The key to the new projection is an analysis that tracks\ncausality between messages. Our soundness proof uses novel graph-theoretic\ntechniques from the theory of message-sequence charts. We demonstrate the\nefficacy of the new projection operation by showing many global types for\ncommon patterns that can be projected under our projection but not under the\nstandard projection operation.\n", "versions": [{"version": "v1", "created": "Thu, 8 Jul 2021 17:24:18 GMT"}], "update_date": "2021-07-09", "authors_parsed": [["Majumdar", "Rupak", ""], ["Mukund", "Madhavan", ""], ["Stutz", "Felix", ""], ["Zufferey", "Damien", ""]]}, {"id": "2107.04025", "submitter": "Micha{\\l} Skrzypczak", "authors": "Olivier Finkel, Micha{\\l} Skrzypczak", "title": "On the expressive power of non-deterministic and unambiguous Petri nets\n  over infinite words", "comments": "arXiv admin note: text overlap with arXiv:1712.07945", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We prove that $\\omega$-languages of (non-deterministic) Petri nets and\n$\\omega$-languages of (non-deterministic) Turing machines have the same\ntopological complexity: the Borel and Wadge hierarchies of the class of\n$\\omega$-languages of (non-deterministic) Petri nets are equal to the Borel and\nWadge hierarchies of the class of $\\omega$-languages of (non-deterministic)\nTuring machines. We also show that it is highly undecidable to determine the\ntopological complexity of a Petri net $\\omega$-language. Moreover, we infer\nfrom the proofs of the above results that the equivalence and the inclusion\nproblems for $\\omega$-languages of Petri nets are $\\Pi_2^1$-complete, hence\nalso highly undecidable.\n  Additionally, we show that the situation is quite the opposite when\nconsidering unambiguous Petri nets, which have the semantic property that at\nmost one run exists on every input. We provide a procedure of determinising\nthem into deterministic Muller counter machines with counter copying. As a\nconsequence, we entail that the $\\omega$-languages recognisable by unambiguous\nPetri nets are $\\Delta^0_3$ sets.\n", "versions": [{"version": "v1", "created": "Thu, 8 Jul 2021 17:57:47 GMT"}], "update_date": "2021-07-09", "authors_parsed": [["Finkel", "Olivier", ""], ["Skrzypczak", "Micha\u0142", ""]]}, {"id": "2107.04455", "submitter": "Daniele Gorla", "authors": "Michele Boreale, Daniele Gorla", "title": "Algebra and coalgebra of stream products", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We study connections among polynomials, differential equations and streams\nover a field K, in terms of algebra and coalgebra. We first introduce the class\nof (F,G)-products on streams, those where the stream derivative of a product\ncan be expressed as a polynomial of the streams themselves and their\nderivatives. Our first result is that, for every (F,G)-product, there is a\ncanonical way to construct a transition function on polynomials such that the\ninduced unique final coalgebra morphism from polynomials into streams is the\n(unique) K-algebra homomorphism -- and vice versa. This implies one can reason\nalgebraically on streams, via their polynomial representation. We apply this\nresult to obtain an algebraic-geometric decision algorithm for polynomial\nstream equivalence, for an underlying generic (F,G)-product. As an example of\nreasoning on streams, we focus on specific products (convolution, shuffle,\nHadamard) and show how to obtain closed forms of algebraic generating functions\nof combinatorial sequences, as well as solutions of nonlinear ordinary\ndifferential equations.\n", "versions": [{"version": "v1", "created": "Fri, 9 Jul 2021 14:20:36 GMT"}], "update_date": "2021-07-12", "authors_parsed": [["Boreale", "Michele", ""], ["Gorla", "Daniele", ""]]}, {"id": "2107.04633", "submitter": "Taylor Dohmen", "authors": "Alvaro Velasquez, Andre Beckus, Taylor Dohmen, Ashutosh Trivedi, Noah\n  Topper, George Atia", "title": "Learning Probabilistic Reward Machines from Non-Markovian Stochastic\n  Reward Processes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL stat.ML", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The success of reinforcement learning in typical settings is, in part,\npredicated on underlying Markovian assumptions on the reward signal by which an\nagent learns optimal policies. In recent years, the use of reward machines has\nrelaxed this assumption by enabling a structured representation of\nnon-Markovian rewards. In particular, such representations can be used to\naugment the state space of the underlying decision process, thereby\nfacilitating non-Markovian reinforcement learning. However, these reward\nmachines cannot capture the semantics of stochastic reward signals. In this\npaper, we make progress on this front by introducing probabilistic reward\nmachines (PRMs) as a representation of non-Markovian stochastic rewards. We\npresent an algorithm to learn PRMs from the underlying decision process as well\nas to learn the PRM representation of a given decision-making policy.\n", "versions": [{"version": "v1", "created": "Fri, 9 Jul 2021 19:00:39 GMT"}], "update_date": "2021-07-14", "authors_parsed": [["Velasquez", "Alvaro", ""], ["Beckus", "Andre", ""], ["Dohmen", "Taylor", ""], ["Trivedi", "Ashutosh", ""], ["Topper", "Noah", ""], ["Atia", "George", ""]]}, {"id": "2107.04683", "submitter": "Isma\\\"el Jecker", "authors": "Isma\\\"el Jecker, Nicolas Mazzocchi, Petra Wolf", "title": "Decomposing Permutation Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  A deterministic finite automaton (DFA) is composite if its language can be\ndecomposed into an intersection of languages of smaller DFAs. Otherwise, A is\nprime. This notion of primality was introduced by Kupferman and Mosheiff in\n2013, and while they proved that we can decide whether a DFA is composite, the\nprecise complexity of this problem is still open, with a doubly-exponential gap\nbetween the upper and lower bounds. In this work, we focus on permutation DFAs,\ni.e., those for which the transition monoid is a group. We provide an NP\nalgorithm to decide whether a permutation DFA is composite, and show that the\ndifficulty of this problem comes from the number of non-accepting states of the\ninstance: we give a fixed-parameter tractable algorithm with the number of\nrejecting states as the parameter. Moreover, we investigate the class of\ncommutative permutation DFAs. Their structural properties allow us to decide\ncompositionality in NLOGSPACE, and even in LOGSPACE if the alphabet size is\nfixed. Despite this low complexity, we show that complex behaviors still arise\nin this class: we provide a family of composite DFAs each requiring\npolynomially many factors with respect to its size. We also consider the\nvariant of the problem that asks whether a DFA is k-factor composite, that is,\ndecomposable into k smaller DFAs, for some given integer k. We show that, for\ncommutative permutation DFAs, restricting the number of factors makes the\ndecision computationally harder, and yields a problem with tight bounds: it is\nNP-complete. Finally, we show that in general, this problem is in PSPACE, and\nit is in LOGSPACE for DFAs with a singleton alphabet.\n", "versions": [{"version": "v1", "created": "Fri, 9 Jul 2021 21:20:39 GMT"}], "update_date": "2021-07-13", "authors_parsed": [["Jecker", "Isma\u00ebl", ""], ["Mazzocchi", "Nicolas", ""], ["Wolf", "Petra", ""]]}, {"id": "2107.05419", "submitter": "Thorsten Wi{\\ss}mann", "authors": "Frits Vaandrager, Bharat Garhewal, Jurriaan Rot, Thorsten Wi{\\ss}mann", "title": "A New Approach for Active Automata Learning Based on Apartness", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present $L^{\\#}$, a new and simple approach to active automata learning.\nInstead of focusing on equivalence of observations, like the $L^{\\ast}$\nalgorithm and its descendants, $L^{\\#}$ takes a different perspective: it tries\nto establish apartness, a constructive form of inequality. $L^{\\#}$ does not\nrequire auxiliary notions such as observation tables or discrimination trees,\nbut operates directly on tree-shaped automata. $L^{\\#}$ has the same asymptotic\nquery and symbol complexities as the best existing learning algorithms, but we\nshow that adaptive distinguishing sequences can be naturally integrated to\nboost the performance of $L^{\\#}$ in practice. Experiments with a prototype\nimplementation, written in Rust, suggest that $L^{\\#}$ outperforms existing\nalgorithms.\n", "versions": [{"version": "v1", "created": "Mon, 12 Jul 2021 13:39:34 GMT"}], "update_date": "2021-07-13", "authors_parsed": [["Vaandrager", "Frits", ""], ["Garhewal", "Bharat", ""], ["Rot", "Jurriaan", ""], ["Wi\u00dfmann", "Thorsten", ""]]}, {"id": "2107.05979", "submitter": "Liam Jordon", "authors": "Liam Jordon, Philippe Moser", "title": "Normal Sequences with Non Maximal Automatic Complexity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper examines Automatic Complexity, a complexity notion introduced by\nShallit and Wang in 2001. We demonstrate that there exists a normal sequence\n$T$ such that $I(T) = 0$ and $S(T) \\leq 1/2$, where $I(T)$ and $S(T)$ are the\nlower and upper automatic complexity rates of $T$ respectively. We furthermore\nshow that there exists a Champernowne sequence $C$, i.e. a sequence formed by\nconcatenating all strings of length $1$ followed by concatenating all strings\nof length $2$ and so on, such that $S(C) \\leq 2/3$.\n", "versions": [{"version": "v1", "created": "Tue, 13 Jul 2021 10:54:35 GMT"}], "update_date": "2021-07-14", "authors_parsed": [["Jordon", "Liam", ""], ["Moser", "Philippe", ""]]}, {"id": "2107.06084", "submitter": "Florian Gallay", "authors": "Florian Gallay and Yli\\`es Falcone", "title": "Decentralized LTL Enforcement", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the runtime enforcement of Linear-time Temporal Logic formulas on\ndecentralized systems. A so-called enforcer is attached to each system\ncomponent and observes its local trace. Should the global trace violate the\nspecification, the enforcers coordinate to correct their local traces. We\nformalize the decentralized runtime enforcement problem and define the expected\nproperties of enforcers, namely soundness, transparency and optimality. We\npresent two enforcement algorithms. In the first one, the enforcers explore all\npossible local modifications to find the best global correction. Although this\nguarantees an optimal correction, it forces the system to synchronize and is\nmore costly, computation and communication wise. In the second one, each\nenforcer makes a local correction before communicating. The reduced cost of\nthis version comes at the price of the optimality of the enforcer corrections.\n", "versions": [{"version": "v1", "created": "Wed, 7 Jul 2021 14:39:46 GMT"}], "update_date": "2021-07-14", "authors_parsed": [["Gallay", "Florian", ""], ["Falcone", "Yli\u00e8s", ""]]}, {"id": "2107.06727", "submitter": "Emilio Tuosto", "authors": "Franco Barbanera and Ivan Lanese and Emilio Tuosto", "title": "Composition of choreography automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Choreography automata are an automata-based model of choreographies, that we\nshow to be a compositional one. Choreography automata represent global views of\nchoreographies (and rely on the well-known model of communicating finite-state\nmachines to model local behaviours). The projections of well-formed global\nviews are live as well as lock- and deadlock-free. In the class of choreography\nautomata we define an internal operation of {\\em composition}, which connects\ntwo global views via roles acting as interfaces. We show that under mild\nconditions the composition of well-formed choreography automata is well-formed.\nThe composition operation enables for a flexible modular mechanism at the\ndesign level.\n", "versions": [{"version": "v1", "created": "Wed, 14 Jul 2021 14:17:34 GMT"}], "update_date": "2021-07-15", "authors_parsed": [["Barbanera", "Franco", ""], ["Lanese", "Ivan", ""], ["Tuosto", "Emilio", ""]]}, {"id": "2107.09930", "submitter": "Yi Lv", "authors": "Chao Wang, Gustavo Petri, Yi Lv, Teng Long, Zhiming Liu", "title": "Decidability of Liveness on the TSO Memory Model", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An important property of concurrent objects is whether they support progress\n-a special case of liveness-guarantees, which ensure the termination of\nindividual method calls under system fairness assumptions. Liveness properties\nhave been proposed for concurrent objects. Typical liveness properties\nincludelock-freedom,wait-freedom,deadlock-freedom,starvation-freedom and\nobstruction-freedom. It is known that the five liveness properties above are\ndecidable on the Sequential Consistency (SC) memory model for a bounded number\nof processes. However, the problem of decidability of liveness for finite state\nconcurrent programs running on relaxed memory models remains open. In this\npaper we address this problem for the Total Store Order (TSO) memory model,as\nfound in the x86 architecture. We prove that lock-freedom,\nwait-freedom,deadlock-freedom and starvation-freedom are undecidable on TSO for\na bounded number of processes, while obstruction-freedom is decidable.\n", "versions": [{"version": "v1", "created": "Wed, 21 Jul 2021 08:08:51 GMT"}], "update_date": "2021-07-22", "authors_parsed": [["Wang", "Chao", ""], ["Petri", "Gustavo", ""], ["Lv", "Yi", ""], ["Long", "Teng", ""], ["Liu", "Zhiming", ""]]}, {"id": "2107.11421", "submitter": "Adilson Bonifacio", "authors": "Adilson Luiz Bonifacio and Arnaldo Vieira Moura", "title": "Testing Pushdown Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Testing on reactive systems is a well-known laborious activity on software\ndevelopment due to their asynchronous interaction with the environment. In this\nsetting model based testing has been employed when checking conformance and\ngenerating test suites of such systems using labeled transition system as a\nformalism as well as the classical ioco conformance relation. In this work we\nturn to a more complex scenario where the target systems have an auxiliary\nmemory, a stack. We then studied a more powerful model, the Visibly Pushdown\nLabeled Transition System (VPTS), its variant Input/Output VPTS (IOVPTS), its\nassociated model Visibly Pushdown Automaton (VPA), and aspects of conformance\ntesting and test suite generation. This scenario is much more challenge since\nthe base model has a pushdown stack to capture more complex behaviors which\ncommonly found on reactive systems. We then defined a more general conformance\nrelation for pushdown reactive systems such that it prevents any observable\nimplementation behavior that was not already present in the given\nspecification. Further we gave an efficient algorithm to check conformance in\nthis testing scenario and also showed that it runs in worst case asymptotic\npolynomial time in the size of both the given specification and the\nimplementation that are put under test.\n", "versions": [{"version": "v1", "created": "Fri, 23 Jul 2021 19:06:54 GMT"}], "update_date": "2021-07-27", "authors_parsed": [["Bonifacio", "Adilson Luiz", ""], ["Moura", "Arnaldo Vieira", ""]]}, {"id": "2107.12902", "submitter": "Hari Govind Vediramana Krishnan", "authors": "Hari Govind V K, Sharon Shoham, Arie Gurfinkel", "title": "Logical Characterization of Coherent Uninterpreted Programs", "comments": "Accepted at FMCAD 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An uninterpreted program (UP) is a program whose semantics is defined over\nthe theory of uninterpreted functions. This is a common abstraction used in\nequivalence checking, compiler optimization, and program verification. While\nsimple, the model is sufficiently powerful to encode counter automata, and,\nhence, undecidable. Recently, a class of UP programs, called coherent, has been\nproposed and shown to be decidable. We provide an alternative, logical\ncharacterization, of this result. Specifically, we show that every coherent\nprogram is bisimilar to a finite state system. Moreover, an inductive invariant\nof a coherent program is representable by a formula whose terms are of depth at\nmost 1. We also show that the original proof, via automata, only applies to\nprograms over unary uninterpreted functions. While this work is purely\ntheoretical, it suggests a novel abstraction that is complete for coherent\nprograms but can be soundly used on arbitrary uninterpreted (and partially\ninterpreted) programs.\n", "versions": [{"version": "v1", "created": "Mon, 26 Jul 2021 03:52:56 GMT"}], "update_date": "2021-07-28", "authors_parsed": [["K", "Hari Govind V", ""], ["Shoham", "Sharon", ""], ["Gurfinkel", "Arie", ""]]}, {"id": "2107.12986", "submitter": "Khushraj Madnani", "authors": "Shankara Narayanan Krishna, Khushraj Nanik Madnani, Manuel Mazo Jr.,\n  Paritosh K. Pandya", "title": "Logics Meet 2-Way 1-Clock Alternating Timed Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper, we study the extension of 1-clock Alternating Timed Automata\n(1-ATA) with the ability to read in both forward and backward direction, the\n2-Way 1-clock Alternating Timed Automata (2-Way 1-ATA). We show that subclass\nof 2-Way 1-ATA with reset free loops (2-Way 1-ATA-rfl) is expressively\nequivalent to MSO[<] extended with Guarded Metric Quantifiers (GQMSO).\nEmptiness Checking problem for 2-Way 1-ATA-rfl (and hence GQMSO) is\nundecidable, in general. We propose a \"non-punctuality\" like restriction,\ncalled non-adjacency, for 2-Way 1-ATA-rfl, and also for GQMSO, for which the\nemptiness (respectively, satisfiability) checking becomes decidable.\nNon-Adjacent 2-Way 1-ATA is the first such class of Timed Automata with\nalternations and 2-wayness for which the emptiness checking is decidable (and\nthat too with elementary complexity). We also show that 2-Way 1-ATA-rfl, even\nwith the non-adjacent restrictions, can express properties is not recognizable\nusing 1-ATA.\n", "versions": [{"version": "v1", "created": "Tue, 27 Jul 2021 17:55:36 GMT"}], "update_date": "2021-07-28", "authors_parsed": [["Krishna", "Shankara Narayanan", ""], ["Madnani", "Khushraj Nanik", ""], ["Mazo", "Manuel", "Jr."], ["Pandya", "Paritosh K.", ""]]}, {"id": "2107.13373", "submitter": "Ludovic Mignot", "authors": "Samira Attou, Ludovic Mignot and Djelloul Ziadi", "title": "Bottom-Up Derivatives of Tree Expressions", "comments": null, "journal-ref": "RAIRO-Theor. Inf. Appl. 55 (2021) 4", "doi": "10.1051/ita/2021008", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we extend the notion of (word) derivatives and partial\nderivatives due to (respectively) Brzozowski and Antimirov to tree derivatives\nusing already known inductive formulae of quotients.\n  We define a new family of extended regular tree expressions (using negation\nor intersection operators), and we show how to compute a Brzozowski-like\ninductive tree automaton; the fixed point of this construction, when it exists,\nis the derivative tree automaton.\n  Such a deterministic tree automaton can be used to solve the membership test\nefficiently: the whole structure is not necessarily computed, and the\nderivative computations can be performed in parallel.\n  We also show how to solve the membership test using our (Bottom-Up) partial\nderivatives, without computing an automaton.\n", "versions": [{"version": "v1", "created": "Wed, 28 Jul 2021 14:03:44 GMT"}], "update_date": "2021-07-29", "authors_parsed": [["Attou", "Samira", ""], ["Mignot", "Ludovic", ""], ["Ziadi", "Djelloul", ""]]}]