[{"id": "1201.0295", "submitter": "Janusz Brzozowski", "authors": "Janusz Brzozowski, Hellis Tamm", "title": "Quotient Complexities of Atoms of Regular Languages", "comments": "17 pages, 2 figures, 9 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An atom of a regular language L with n (left) quotients is a non-empty\nintersection of uncomplemented or complemented quotients of L, where each of\nthe n quotients appears in a term of the intersection. The quotient complexity\nof L, which is the same as the state complexity of L, is the number of\nquotients of L. We prove that, for any language L with quotient complexity n,\nthe quotient complexity of any atom of L with r complemented quotients has an\nupper bound of 2^n-1 if r=0 or r=n, and 1+\\sum_{k=1}^{r} \\sum_{h=k+1}^{k+n-r}\nC_{h}^{n} \\cdot C_{k}^{h} otherwise, where C_j^i is the binomial coefficient.\nFor each n\\ge 1, we exhibit a language whose atoms meet these bounds.\n", "versions": [{"version": "v1", "created": "Sat, 31 Dec 2011 18:04:27 GMT"}, {"version": "v2", "created": "Thu, 8 Mar 2012 20:03:20 GMT"}], "update_date": "2012-03-09", "authors_parsed": [["Brzozowski", "Janusz", ""], ["Tamm", "Hellis", ""]]}, {"id": "1201.0597", "submitter": "Miko&#322;aj Boja&#324;czyk", "authors": "Miko{\\l}aj Boja\\'nczyk (University of Warsaw), S{\\l}awomir Lasota\n  (University of Warsaw)", "title": "An extension of data automata that captures XPath", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 1 (February\n  16, 2012) lmcs:672", "doi": "10.2168/LMCS-8(1:5)2012", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define a new kind of automata recognizing properties of data words or data\ntrees and prove that the automata capture all queries definable in Regular\nXPath. We show that the automata-theoretic approach may be applied to answer\ndecidability and expressibility questions for XPath.\n", "versions": [{"version": "v1", "created": "Tue, 3 Jan 2012 09:13:14 GMT"}, {"version": "v2", "created": "Wed, 15 Feb 2012 10:38:30 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Boja\u0144czyk", "Miko\u0142aj", "", "University of Warsaw"], ["Lasota", "S\u0142awomir", "", "University of Warsaw"]]}, {"id": "1201.0682", "submitter": "Vojt\\v{e}ch \\v{R}eh\\'ak", "authors": "Tom\\'a\\v{s} Babiak, Mojm\\'ir K\\v{r}et\\'insk\\'y, Vojt\\v{e}ch\n  \\v{R}eh\\'ak, and Jan Strej\\v{c}ek", "title": "LTL to B\\\"uchi Automata Translation: Fast and More Deterministic", "comments": "Full version of the paper presented at TACAS 2012", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce improvements in the algorithm by Gastin and Oddoux translating\nLTL formulae into B\\\"uchi automata via very weak alternating co-B\\\"uchi\nautomata and generalized B\\\"uchi automata. Several improvements are based on\nspecific properties of any formula where each branch of its syntax tree\ncontains at least one eventually operator and at least one always operator.\nThese changes usually result in faster translations and smaller automata. Other\nimprovements reduce non-determinism in the produced automata. In fact, we\nmodified all the steps of the original algorithm and its implementation known\nas LTL2BA. Experimental results show that our modifications are real\nimprovements. Their implementations within an LTL2BA translation made LTL2BA\nvery competitive with the current version of SPOT, sometimes outperforming it\nsubstantially.\n", "versions": [{"version": "v1", "created": "Tue, 3 Jan 2012 16:04:28 GMT"}, {"version": "v2", "created": "Thu, 29 Mar 2012 20:12:37 GMT"}], "update_date": "2012-04-02", "authors_parsed": [["Babiak", "Tom\u00e1\u0161", ""], ["K\u0159et\u00ednsk\u00fd", "Mojm\u00edr", ""], ["\u0158eh\u00e1k", "Vojt\u011bch", ""], ["Strej\u010dek", "Jan", ""]]}, {"id": "1201.1095", "submitter": "Krasimir Yordzhev", "authors": "Krasimir Yordzhev", "title": "An Entertaining Example of Using the Concepts of Context-Free Grammar\n  and Pushdown Automation", "comments": null, "journal-ref": "Open Journal of Discrete Mathematics, 2012, 2, 105-108", "doi": "10.4236/ojdm.2012.23020", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A formal-linguistic approach for solving an entertaining task is made in this\npaper. The well-known task of the Hanoi towers is discussed in relation to some\nconcepts of discrete mathematics. A context-free grammar which generate an\nalgorithm for solving this task is described. A deterministic pushdown\nautomation which in its work imitates the work of monks in solving the task of\nthe Hanoi towers is built.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jan 2012 09:47:46 GMT"}], "update_date": "2013-01-24", "authors_parsed": [["Yordzhev", "Krasimir", ""]]}, {"id": "1201.1733", "submitter": "Tom\\'a\\v{s} Masopust", "authors": "Jan Komenda, Tom\\'a\\v{s} Masopust, Jan H. van Schuppen", "title": "On Conditional Decomposability", "comments": "A few minor corrections", "journal-ref": "Systems & Control Letters 61 (12), 1260-1268, 2012", "doi": "10.1016/j.sysconle.2012.07.013", "report-no": null, "categories": "cs.SY cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The requirement of a language to be conditionally decomposable is imposed on\na specification language in the coordination supervisory control framework of\ndiscrete-event systems. In this paper, we present a polynomial-time algorithm\nfor the verification whether a language is conditionally decomposable with\nrespect to given alphabets. Moreover, we also present a polynomial-time\nalgorithm to extend the common alphabet so that the language becomes\nconditionally decomposable. A relationship of conditional decomposability to\nnonblockingness of modular discrete-event systems is also discussed in this\npaper in the general settings. It is shown that conditional decomposability is\na weaker condition than nonblockingness.\n", "versions": [{"version": "v1", "created": "Mon, 9 Jan 2012 10:51:33 GMT"}, {"version": "v2", "created": "Tue, 20 Mar 2012 20:32:59 GMT"}, {"version": "v3", "created": "Fri, 19 Dec 2014 11:36:03 GMT"}], "update_date": "2014-12-22", "authors_parsed": [["Komenda", "Jan", ""], ["Masopust", "Tom\u00e1\u0161", ""], ["van Schuppen", "Jan H.", ""]]}, {"id": "1201.1754", "submitter": "Tomas Masopust", "authors": "Tom\\'a\\v{s} Masopust", "title": "A Note on Undecidability of Observation Consistency for Non-Regular\n  Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One of the most interesting questions concerning hierarchical control of\ndiscrete-event systems with partial observations is a condition under which the\nlanguage observability is preserved between the original and the abstracted\nplant. Recently, we have characterized two such sufficient\nconditions---observation consistency and local observation consistency. In this\npaper, we prove that the condition of observation consistency is undecidable\nfor non-regular (linear, deterministic context-free) languages. The question\nwhether the condition is decidable for regular languages is open.\n", "versions": [{"version": "v1", "created": "Mon, 9 Jan 2012 13:40:34 GMT"}], "update_date": "2012-01-10", "authors_parsed": [["Masopust", "Tom\u00e1\u0161", ""]]}, {"id": "1201.2829", "submitter": "Yaron Velner", "authors": "Krishnendu Chatterjee and Yaron Velner", "title": "Mean-Payoff Pushdown Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two-player games on graphs is central in many problems in formal verification\nand program analysis such as synthesis and verification of open systems. In\nthis work we consider solving recursive game graphs (or pushdown game graphs)\nthat can model the control flow of sequential programs with recursion. While\npushdown games have been studied before with qualitative objectives, such as\nreachability and $\\omega$-regular objectives, in this work we study for the\nfirst time such games with the most well-studied quantitative objective,\nnamely, mean-payoff objectives. In pushdown games two types of strategies are\nrelevant: (1) global strategies, that depend on the entire global history; and\n(2) modular strategies, that have only local memory and thus does not depend on\nthe context of invocation, but only on the history of the current invocation of\nthe module. Our main results are as follows (1) One-player pushdown games with\nmean-payoff objectives under global strategies is decidable in polynomial time.\n(2) Two-player pushdown games with mean-payoff objectives under global\nstrategies is undecidable. (3) One-player pushdown games with mean-payoff\nobjectives under modular strategies is NP-hard. (4) Two-player pushdown games\nwith mean-payoff objectives under modular strategies can be solved in NP (i.e.,\nboth one-player and two-player pushdown games with mean-payoff objectives under\nmodular strategies is NP-complete). We also establish the optimal strategy\ncomplexity showing that global strategies for mean-payoff objectives require\ninfinite memory even in one-player pushdown games; and memoryless modular\nstrategies are sufficient in two-player pushdown games. Finally we also show\nthat all the problems have the same complexity if the stack boundedness\ncondition is added, where along with the mean-payoff objective the player must\nalso ensure that the stack height is bounded.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jan 2012 13:18:16 GMT"}, {"version": "v2", "created": "Mon, 9 Apr 2012 11:43:16 GMT"}, {"version": "v3", "created": "Sun, 15 May 2016 11:27:46 GMT"}], "update_date": "2016-05-17", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Velner", "Yaron", ""]]}, {"id": "1201.3082", "submitter": "Takashi Yokomori", "authors": "Fumiya Okubo, Satoshi Kobayashi, Takashi Yokomori", "title": "On the Properties of Language Classes Defined by Bounded Reaction\n  Automata", "comments": "23 pages with 3 figures", "journal-ref": null, "doi": null, "report-no": "EMTR-12-01", "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reaction automata are a formal model that has been introduced to investigate\nthe computing powers of interactive behaviors of biochemical reactions([14]).\nReaction automata are language acceptors with multiset rewriting mechanism\nwhose basic frameworks are based on reaction systems introduced in [4]. In this\npaper we continue the investigation of reaction automata with a focus on the\nformal language theoretic properties of subclasses of reaction automata, called\nlinearbounded reaction automata (LRAs) and exponentially-bounded reaction\nautomata (ERAs). Besides LRAs, we newly introduce an extended model (denoted by\nlambda-LRAs) by allowing lambda-moves in the accepting process of reaction, and\ninvestigate the closure properties of language classes accepted by both LRAs\nand lambda-LRAs. Further, we establish new relationships of language classes\naccepted by LRAs and by ERAs with the Chomsky hierarchy. The main results\ninclude the following : (i) the class of languages accepted by lambda-LRAs\nforms an AFL with additional closure properties, (ii) any recursively\nenumerable language can be expressed as a homomorphic image of a language\naccepted by an LRA, (iii) the class of languages accepted by ERAs coincides\nwith the class of context-sensitive languages.\n", "versions": [{"version": "v1", "created": "Sun, 15 Jan 2012 11:28:56 GMT"}], "update_date": "2012-01-17", "authors_parsed": [["Okubo", "Fumiya", ""], ["Kobayashi", "Satoshi", ""], ["Yokomori", "Takashi", ""]]}, {"id": "1201.3194", "submitter": "Pierre Ganty", "authors": "Javier Esparza, Pierre Ganty, Rupak Majumdar", "title": "A Perfect Model for Bounded Verification", "comments": "14 pages, 6 figures", "journal-ref": null, "doi": "10.1109/LICS.2012.39", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A class of languages C is perfect if it is closed under Boolean operations\nand the emptiness problem is decidable. Perfect language classes are the basis\nfor the automata-theoretic approach to model checking: a system is correct if\nthe language generated by the system is disjoint from the language of bad\ntraces. Regular languages are perfect, but because the disjointness problem for\nCFLs is undecidable, no class containing the CFLs can be perfect.\n  In practice, verification problems for language classes that are not perfect\nare often under-approximated by checking if the property holds for all\nbehaviors of the system belonging to a fixed subset. A general way to specify a\nsubset of behaviors is by using bounded languages (languages of the form w1*\n... wk* for fixed words w1,...,wk). A class of languages C is perfect modulo\nbounded languages if it is closed under Boolean operations relative to every\nbounded language, and if the emptiness problem is decidable relative to every\nbounded language.\n  We consider finding perfect classes of languages modulo bounded languages. We\nshow that the class of languages accepted by multi-head pushdown automata are\nperfect modulo bounded languages, and characterize the complexities of decision\nproblems. We also show that bounded languages form a maximal class for which\nperfection is obtained. We show that computations of several known models of\nsystems, such as recursive multi-threaded programs, recursive counter machines,\nand communicating finite-state machines can be encoded as multi-head pushdown\nautomata, giving uniform and optimal underapproximation algorithms modulo\nbounded languages.\n", "versions": [{"version": "v1", "created": "Mon, 16 Jan 2012 10:11:49 GMT"}], "update_date": "2012-08-28", "authors_parsed": [["Esparza", "Javier", ""], ["Ganty", "Pierre", ""], ["Majumdar", "Rupak", ""]]}, {"id": "1201.3250", "submitter": "Alexander Kartzow", "authors": "Alexander Kartzow and Pawe{\\l} Parys", "title": "Strictness of the Collapsible Pushdown Hierarchy", "comments": "68 pages, short version in MFCS 2012", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a pumping lemma for each level of the collapsible pushdown graph\nhierarchy in analogy to the second author's pumping lemma for higher-order\npushdown graphs (without collapse). Using this lemma, we give the first known\nexamples that separate the levels of the collapsible pushdown graph hierarchy\nand of the collapsible pushdown tree hierarchy, i.e., the hierarchy of trees\ngenerated by higher-order recursion schemes. This confirms the open conjecture\nthat higher orders allow one to generate more graphs and more trees.\n", "versions": [{"version": "v1", "created": "Mon, 16 Jan 2012 13:23:17 GMT"}, {"version": "v2", "created": "Thu, 14 Jun 2012 12:58:06 GMT"}], "update_date": "2012-06-15", "authors_parsed": [["Kartzow", "Alexander", ""], ["Parys", "Pawe\u0142", ""]]}, {"id": "1201.5529", "submitter": "Vincent Nesme", "authors": "Pablo Arrighi, Vincent Nesme", "title": "A simple block representation of reversible cellular automata with\n  time-symmetry", "comments": "6 pages, 3 figures, Automata 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.FL quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reversible Cellular Automata (RCA) are a physics-like model of computation\nconsisting of an array of identical cells, evolving in discrete time steps by\niterating a global evolution G. Further, G is required to be shift-invariant\n(it acts the same everywhere), causal (information cannot be transmitted faster\nthan some fixed number of cells per time step), and reversible (it has an\ninverse which verifies the same requirements). An important, though only\nrecently studied special case is that of Time-symmetric Cellular Automata\n(TSCA), for which G and its inverse are related via a local operation. In this\nnote we revisit the question of the Block representation of RCA, i.e. we\nprovide a very simple proof of the existence of a reversible circuit\ndescription implementing G. This operational, bottom-up description of G turns\nout to be time-symmetric, suggesting interesting connections with TSCA. Indeed\nwe prove, using a similar technique, that a wide class of them admit an Exact\nblock representation (EBR), i.e. one which does not increase the state space.\n", "versions": [{"version": "v1", "created": "Thu, 26 Jan 2012 14:26:23 GMT"}], "update_date": "2012-01-27", "authors_parsed": [["Arrighi", "Pablo", ""], ["Nesme", "Vincent", ""]]}]