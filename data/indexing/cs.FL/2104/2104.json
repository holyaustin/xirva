[{"id": "2104.00176", "submitter": "Abhishek Kulkarni", "authors": "Abhishek N. Kulkarni, Shuo Han, Nandi O. Leslie, Charles A. Kamhoua,\n  and Jie Fu", "title": "Qualitative Planning in Imperfect Information Games with Active Sensing\n  and Reactive Sensor Attacks: Cost of Unawareness", "comments": "7 pages, 5 figures, Submitted to CDC2021; Revised Alg. 2 to fix a\n  typo and notation, results unchanged", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the probabilistic planning problem where the agent (called Player\n1, or P1) can jointly plan the control actions and sensor queries in a sensor\nnetwork and an attacker (called player 2, or P2) can carry out attacks on the\nsensors. We model such an adversarial interaction using a formal model -- a\nreachability game with partially controllable observation functions. The main\ncontribution of this paper is to assess the cost of P1's unawareness: Suppose\nP1 misinterprets the sensor failures as probabilistic node failures due to\nunreliable network communication, and P2 is aware of P1's misinterpretation in\naddition to her partial observability. Then, from which states can P2 carry out\nsensor attacks to ensure, with probability one, that P1 will not be able to\ncomplete her reachability task even though, due to misinterpretation, P1\nbelieves that she can almost-surely achieve her task. We develop an algorithm\nto solve the almost-sure winning sensor-attack strategy given P1's\nobservation-based strategy. Our attack analysis could be used for attack\ndetection in wireless communication networks and the design of provably secured\nattack-aware sensor allocation in decision-theoretic models for cyber-physical\nsystems.\n", "versions": [{"version": "v1", "created": "Thu, 1 Apr 2021 00:43:10 GMT"}, {"version": "v2", "created": "Sun, 2 May 2021 18:55:10 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Kulkarni", "Abhishek N.", ""], ["Han", "Shuo", ""], ["Leslie", "Nandi O.", ""], ["Kamhoua", "Charles A.", ""], ["Fu", "Jie", ""]]}, {"id": "2104.01363", "submitter": "Diego Krivochen", "authors": "Diego Gabriel Krivochen", "title": "From n-grams to trees in Lindenmayer systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CL cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper we present two approaches to Lindenmayer systems: the\nrule-based (or generative) approach, which focuses on L-systems as Thue\nrewriting systems and a constraint-based (or model-theoretic) approach, in\nwhich rules are abandoned in favour of conditions over allowable expressions in\nthe language (Pullum, 2019). We will argue that it is possible, for at least a\nsubset of L-systems and the languages they generate, to map string\nadmissibility conditions (the 'Three Laws') to local tree admissibility\nconditions (cf. Rogers, 1997). This is equivalent to defining a model for those\nlanguages. We will work out how to construct structure assuming only\nsuperficial constraints on expressions, and define a set of constraints that\nwell-formed expressions of specific L-languages must satisfy. We will see that\nL-systems that other methods distinguish turn out to satisfy the same model.\n", "versions": [{"version": "v1", "created": "Sat, 3 Apr 2021 09:42:44 GMT"}], "update_date": "2021-04-06", "authors_parsed": [["Krivochen", "Diego Gabriel", ""]]}, {"id": "2104.01503", "submitter": "Lars Lindemann", "authors": "Lars Lindemann, Nikolai Matni, and George J. Pappas", "title": "STL Robustness Risk over Discrete-Time Stochastic Processes", "comments": "Submitted to the Conference on Decision and Control 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.LG cs.SY math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a framework to interpret signal temporal logic (STL) formulas over\ndiscrete-time stochastic processes in terms of the induced risk. Each\nrealization of a stochastic process either satisfies or violates an STL\nformula. In fact, we can assign a robustness value to each realization that\nindicates how robustly this realization satisfies an STL formula. We then\ndefine the risk of a stochastic process not satisfying an STL formula robustly,\nreferred to as the \"STL robustness risk\". In our definition, we permit general\nclasses of risk measures such as, but not limited to, the value-at-risk. While\nin general hard to compute, we propose an approximation of the STL robustness\nrisk. This approximation has the desirable property of being an upper bound of\nthe STL robustness risk when the chosen risk measure is monotone, a property\nsatisfied by most risk measures. Motivated by the interest in data-driven\napproaches, we present a sampling-based method for calculating an upper bound\nof the approximate STL robustness risk for the value-at-risk that holds with\nhigh probability. While we consider the case of the value-at-risk, we highlight\nthat such sampling-based methods are viable for other risk measures.\n", "versions": [{"version": "v1", "created": "Sat, 3 Apr 2021 23:44:04 GMT"}, {"version": "v2", "created": "Thu, 22 Apr 2021 20:30:15 GMT"}], "update_date": "2021-04-26", "authors_parsed": [["Lindemann", "Lars", ""], ["Matni", "Nikolai", ""], ["Pappas", "George J.", ""]]}, {"id": "2104.01667", "submitter": "Rene Haberland", "authors": "Ren\\'e Haberland", "title": "A Logical Programming Language as an Instrument for Specifying and\n  Verifying Dynamic Memory", "comments": "209 pages, 97 figures, 6 appendices", "journal-ref": "Dissertation, Thesis, 2017", "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.PL cs.SC cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work proposes a Prolog-dialect for the found and prioritised problems on\nexpressibility and automation. Given some given C-like program, if dynamic\nmemory is allocated, altered and freed on runtime, then a description of\ndesired dynamic memory is a heap specification. The check of calculated memory\nstate against a given specification is dynamic memory verification. This\ncontribution only considers formal specification and verification in a Hoare\ncalculus. Issues found include: invalid assignment, (temporary) unavailable\ndata in memory cells, excessive memory allocation, (accidental) heap alteration\nin unexpected regions and others. Excessive memory allocation is nowadays\nsuccessfully resolved by memory analysers like Valgrind. Essentially, papers in\nthose areas did not bring any big breakthrough. Possible reasons may also\ninclude the decrease of tension due to more available memory and parallel\nthreads. However, starting with Apt, problems related to variable modes have\nnot yet been resolved -- neither entirely nor in an acceptable way. Research\ncontributions over the last decades show again and again that heap issues\nremain and remain complex and still important. A significant contribution was\nreached in 2016 by Peter O'Hearn, who accepted the G\\\"{o}del prize for his\nparallel approach on a spatial heap operation.\n", "versions": [{"version": "v1", "created": "Sun, 4 Apr 2021 19:18:07 GMT"}], "update_date": "2021-04-06", "authors_parsed": [["Haberland", "Ren\u00e9", ""]]}, {"id": "2104.02438", "submitter": "Bartek Klin", "authors": "Miko{\\l}aj Boja\\'nczyk, Bartek Klin and Joshua Moerman", "title": "Orbit-Finite-Dimensional Vector Spaces and Weighted Register Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We develop a theory of vector spaces spanned by orbit-finite sets. Using this\ntheory, we give a decision procedure for equivalence of weighted register\nautomata, which are the common generalization of weighted automata and register\nautomata for infinite alphabets. The algorithm runs in exponential time, and in\npolynomial time for a fixed number of registers. As a special case, we can\ndecide, with the same complexity, language equivalence for unambiguous register\nautomata, which improves previous results in three ways: (a) we allow for order\ncomparisons on atoms, and not just equality; (b) the complexity is\nexponentially better; and (c) we allow automata with guessing.\n", "versions": [{"version": "v1", "created": "Tue, 6 Apr 2021 11:54:51 GMT"}, {"version": "v2", "created": "Fri, 23 Apr 2021 14:45:04 GMT"}], "update_date": "2021-04-26", "authors_parsed": [["Boja\u0144czyk", "Miko\u0142aj", ""], ["Klin", "Bartek", ""], ["Moerman", "Joshua", ""]]}, {"id": "2104.02737", "submitter": "Suhail Alsalehi", "authors": "Suhail Alsalehi, Noushin Mehdipour, Ezio Bartocci and Calin Belta", "title": "Neural Network-based Control for Multi-Agent Systems from\n  Spatio-Temporal Specifications", "comments": "8 pages. Submitted to the CDC 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.AI cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a framework for solving control synthesis problems for multi-agent\nnetworked systems required to satisfy spatio-temporal specifications. We use\nSpatio-Temporal Reach and Escape Logic (STREL) as a specification language. For\nthis logic, we define smooth quantitative semantics, which captures the degree\nof satisfaction of a formula by a multi-agent team. We use the novel\nquantitative semantics to map control synthesis problems with STREL\nspecifications to optimization problems and propose a combination of heuristic\nand gradient-based methods to solve such problems. As this method might not\nmeet the requirements of a real-time implementation, we develop a machine\nlearning technique that uses the results of the off-line optimizations to train\na neural network that gives the control inputs at current states. We illustrate\nthe effectiveness of the proposed framework by applying it to a model of a\nrobotic team required to satisfy a spatial-temporal specification under\ncommunication constraints.\n", "versions": [{"version": "v1", "created": "Tue, 6 Apr 2021 18:08:09 GMT"}], "update_date": "2021-04-08", "authors_parsed": [["Alsalehi", "Suhail", ""], ["Mehdipour", "Noushin", ""], ["Bartocci", "Ezio", ""], ["Belta", "Calin", ""]]}, {"id": "2104.02876", "submitter": "Dmitry Berdinsky", "authors": "Dmitry Berdinsky and Prohrak Kruengthomya", "title": "Representing Polynomial Splines over Infinite Hierarchical Meshes by\n  Finite Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CG cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a data structure based on finite automata for representing\npolynomial splines over infinite hierarchical meshes. It allows to store and\noperate such splines using only finite amount of memory. This naturally extends\na classical framework of hierarchical tensor product B-splines for infinite\nmeshes in a way suitable for computing.\n", "versions": [{"version": "v1", "created": "Wed, 7 Apr 2021 02:59:43 GMT"}], "update_date": "2021-04-08", "authors_parsed": [["Berdinsky", "Dmitry", ""], ["Kruengthomya", "Prohrak", ""]]}, {"id": "2104.02920", "submitter": "Shigeru Ninagawa", "authors": "Shigeru Ninagawa and Genaro J. Martinez", "title": "Visualization of the Computation Process of a Universal Register Machine", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Universal register machine, a formal model of computation, can be emulated on\nthe array of the Game of Life, a two-dimensional cellular automaton. We perform\nspectral analysis on the computation dynamical process of the universal\nregister machine on the Game of Life. The array is divided into small sectors\nand the power spectrum is calculated from the evolution in each sector. The\npower spectrum can be classified into four categories by its shape; null, white\nnoise, sharp peaks, and power law. By representing the shape of power spectrum\nby a mark, we can visualize the activity of the sector during the computation\nprocess. For example, the track of pulse moving between components of the\nuniversal register machine and the position of frequently modified registers\ncan be identified. This method can expose the functional difference in each\nregion of computing machine.\n", "versions": [{"version": "v1", "created": "Wed, 7 Apr 2021 05:23:29 GMT"}, {"version": "v2", "created": "Sun, 9 May 2021 00:59:58 GMT"}, {"version": "v3", "created": "Sat, 22 May 2021 13:39:09 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Ninagawa", "Shigeru", ""], ["Martinez", "Genaro J.", ""]]}, {"id": "2104.03425", "submitter": "Josep Silva", "authors": "Marisa Llorens, Javier Oliver, Josep Silva, Salvador Tamarit", "title": "Maximal and minimal dynamic Petri net slicing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Context: Petri net slicing is a technique to reduce the size of a Petri net\nso that it can ease the analysis or understanding of the original Petri net.\n  Objective: Presenting two new Petri net slicing algorithms to isolate those\nplaces and transitions of a Petri net (the slice) that may contribute tokens to\none or more places given (the slicing criterion).\n  Method: The two algorithms proposed are formalized. The completeness of the\nfirst algorithm and the minimality of the second algorithm are formally proven.\nBoth algorithms together with other three state-of-the-art algorithms have been\nimplemented and integrated into a single tool so that we have been able to\ncarry out a fair empirical evaluation.\n  Results: Besides the two new Petri net slicing algorithms, a public, free,\nand open-source implementation of five algorithms is reported. The results of\nan empirical evaluation of the new algorithms and the slices that they produce\nare also presented.\n  Conclusions: The first algorithm collects all places and transitions that may\ninfluence (in any computation) the slicing criterion, while the second\nalgorithm collects a minimum set of places and transitions that may influence\n(in some computation) the slicing criterion. Therefore, the net computed by the\nfirst algorithm can reproduce any computation that contributes tokens to any\nplace of interest. In contrast, the second algorithm loses this possibility but\nit often produces a much more reduced subnet (which still can reproduce some\ncomputations that contribute tokens to some places of interest). The first\nalgorithm is proven complete, and the second one is proven minimal.\n", "versions": [{"version": "v1", "created": "Wed, 7 Apr 2021 23:01:26 GMT"}], "update_date": "2021-04-09", "authors_parsed": [["Llorens", "Marisa", ""], ["Oliver", "Javier", ""], ["Silva", "Josep", ""], ["Tamarit", "Salvador", ""]]}, {"id": "2104.03555", "submitter": "Yong Li", "authors": "Yong Li, Yih-Kuen Tsay, Andrea Turrini, Moshe Y. Vardi and Lijun Zhang", "title": "Congruence Relations for B\\\"uchi Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We revisit here congruence relations for B\\\"uchi automata, which play a\ncentral role in the automata-based verification. The size of the classical\ncongruence relation is in $3^{\\mathcal{O}(n^2)}$, where $n$ is the number of\nstates of a given B\\\"uchi automaton $\\mathcal{A}$. Here we present improved\ncongruence relations that can be exponentially coarser than the classical one.\nWe further give asymptotically optimal congruence relations of size\n$2^{\\mathcal{O}(n \\log n)}$. Based on these optimal congruence relations, we\nobtain an optimal translation from B\\\"uchi automata to a family of\ndeterministic finite automata (FDFW) that accepts the complementary language.\nTo the best of our knowledge, our construction is the first direct and optimal\ntranslation from B\\\"uchi automata to FDFWs.\n", "versions": [{"version": "v1", "created": "Thu, 8 Apr 2021 07:16:32 GMT"}, {"version": "v2", "created": "Fri, 23 Apr 2021 06:51:02 GMT"}, {"version": "v3", "created": "Tue, 11 May 2021 01:35:57 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Li", "Yong", ""], ["Tsay", "Yih-Kuen", ""], ["Turrini", "Andrea", ""], ["Vardi", "Moshe Y.", ""], ["Zhang", "Lijun", ""]]}, {"id": "2104.03690", "submitter": "Lorenzo Clemente", "authors": "Lorenzo Clemente and S{\\l}awomir Lasota and Rados{\\l}aw Pi\\'orkowski", "title": "Determinisability of register and timed automata", "comments": "journal version of a CONCUR'20 paper. arXiv admin note: substantial\n  text overlap with arXiv:2007.09340", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The deterministic membership problem for timed automata asks whether the\ntimed language given by a nondeterministic timed automaton can be recognised by\na deterministic timed automaton. An analogous problem can be stated in the\nsetting of register automata. We draw the complete decidability/complexity\nlandscape of the deterministic membership problem, in the setting of both\nregister and timed automata. For register automata, we prove that the\ndeterministic membership problem is decidable when the input automaton is a\nnondeterministic one-register automaton (possibly with epsilon transitions) and\nthe number of registers of the output deterministic register automaton is\nfixed. This is optimal: We show that in all the other cases the problem is\nundecidable, i.e., when either 1) the input nondeterministic automaton has two\nregisters or more (even without epsilon transitions), or 2) it uses guessing,\nor 3) the number of registers of the output deterministic automaton is not\nfixed. The landscape for timed automata follows a similar pattern. We show that\nthe problem is decidable when the input automaton is a one-clock\nnondeterministic timed automaton without epsilon transitions and the number of\nclocks of the output deterministic timed automaton is fixed. Again, this is\noptimal: We show that the problem in all the other cases is undecidable, i.e.,\nwhen either 1) the input nondeterministic timed automaton has two clocks or\nmore, or 2) it uses epsilon transitions, or 3) the number of clocks of the\noutput deterministic automaton is not fixed.\n", "versions": [{"version": "v1", "created": "Thu, 8 Apr 2021 11:21:09 GMT"}], "update_date": "2021-04-09", "authors_parsed": [["Clemente", "Lorenzo", ""], ["Lasota", "S\u0142awomir", ""], ["Pi\u00f3rkowski", "Rados\u0142aw", ""]]}, {"id": "2104.04463", "submitter": "Yurii Kostyukov", "authors": "Yurii Kostyukov, Dmitry Mordvinov and Grigory Fedyukovich", "title": "Beyond the Elementary Representations of Program Invariants over\n  Algebraic Data Types", "comments": "Extended version of a paper appearing in PLDI'21", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  First-order logic is a natural way of expressing properties of computation.\nIt is traditionally used in various program logics for expressing the\ncorrectness properties and certificates. Although such representations are\nexpressive for some theories, they fail to express many interesting properties\nof algebraic data types (ADTs). In this paper, we explore three different\napproaches to represent program invariants of ADT-manipulating programs: tree\nautomata, and first-order formulas with or without size constraints. We compare\nthe expressive power of these representations and prove the negative\ndefinability of both first-order representations using the pumping lemmas. We\npresent an approach to automatically infer program invariants of\nADT-manipulating programs by a reduction to a finite model finder. The\nimplementation called RInGen has been evaluated against state-of-the-art\ninvariant synthesizers and has been experimentally shown to be competitive. In\nparticular, program invariants represented by automata are capable of\nexpressing more complex properties of computation and their automatic\nconstruction is often less expensive.\n", "versions": [{"version": "v1", "created": "Fri, 9 Apr 2021 16:26:00 GMT"}, {"version": "v2", "created": "Wed, 14 Apr 2021 10:14:25 GMT"}], "update_date": "2021-04-15", "authors_parsed": [["Kostyukov", "Yurii", ""], ["Mordvinov", "Dmitry", ""], ["Fedyukovich", "Grigory", ""]]}, {"id": "2104.04904", "submitter": "Meiyi Ma", "authors": "Meiyi Ma, Ezio Bartocci, Eli Lifland, John Stankovic and Lu Feng", "title": "A Novel Spatial-Temporal Specification-Based Monitoring System for Smart\n  Cities", "comments": "17 pages. arXiv admin note: substantial text overlap with\n  arXiv:1908.02366", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  With the development of the Internet of Things, millions of sensors are being\ndeployed in cities to collect real-time data. This leads to a need for checking\ncity states against city requirements at runtime. In this paper, we develop a\nnovel spatial-temporal specification-based monitoring system for smart cities.\nWe first describe a study of over 1,000 smart city requirements, some of which\ncannot be specified using existing logic such as Signal Temporal Logic (STL)\nand its variants. To tackle this limitation, we develop SaSTL -- a novel\nSpatial Aggregation Signal Temporal Logic -- for the efficient runtime\nmonitoring of safety and performance requirements in smart cities. We develop\ntwo new logical operators in SaSTL to augment STL for expressing spatial\naggregation and spatial counting characteristics that are commonly found in\nreal city requirements. We define Boolean and \\newcontent{quantitative\nsemantics}~for SaSTL in support of the analysis of city performance across\ndifferent periods and locations. We also develop efficient monitoring\nalgorithms that can check a SaSTL requirement in parallel over multiple data\nstreams (e.g., generated by multiple sensors distributed spatially in a city).\nAdditionally, we build a SaSTL-based monitoring tool to support decision making\nof different stakeholders to specify and runtime monitor their requirements in\nsmart cities. We evaluate our SaSTL monitor by applying it to three case\nstudies with large-scale real city sensing data (e.g., up to 10,000 sensors in\none study). The results show that SaSTL has a much higher coverage\nexpressiveness than other spatial-temporal logic, and with a significant\nreduction of computation time for monitoring requirements. We also demonstrate\nthat the SaSTL monitor improves the safety and performance of smart cities via\nsimulated experiments.\n", "versions": [{"version": "v1", "created": "Sun, 11 Apr 2021 03:12:40 GMT"}], "update_date": "2021-04-13", "authors_parsed": [["Ma", "Meiyi", ""], ["Bartocci", "Ezio", ""], ["Lifland", "Eli", ""], ["Stankovic", "John", ""], ["Feng", "Lu", ""]]}, {"id": "2104.05262", "submitter": "Pierre Ohlmann", "authors": "Thomas Colcombet, Nathana\\\"el Fijalkow, Pawe{\\l} Gawrychowski and\n  Pierre Ohlmann", "title": "The Theory of Universal Graphs for Infinite Duration Games", "comments": "43 pages, 10 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.GT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce the notion of universal graphs as a tool for constructing\nalgorithms solving games of infinite duration such as parity games and mean\npayoff games. In the first part we develop the theory of universal graphs, with\ntwo goals: showing an equivalence and normalisation result between different\nrecently introduced related models, and constructing generic value iteration\nalgorithms for any positionally determined objective. In the second part we\ngive four applications: to parity games, to mean payoff games, and to\ncombinations of them (in the form of disjunctions of objectives). For each of\nthese four cases we construct algorithms achieving or improving over the best\nknown time and space complexity.\n", "versions": [{"version": "v1", "created": "Mon, 12 Apr 2021 07:53:43 GMT"}, {"version": "v2", "created": "Wed, 21 Apr 2021 13:15:26 GMT"}, {"version": "v3", "created": "Tue, 27 Jul 2021 08:44:47 GMT"}], "update_date": "2021-07-28", "authors_parsed": [["Colcombet", "Thomas", ""], ["Fijalkow", "Nathana\u00ebl", ""], ["Gawrychowski", "Pawe\u0142", ""], ["Ohlmann", "Pierre", ""]]}, {"id": "2104.05772", "submitter": "Alan Logan", "authors": "Laura Ciobanu, Alan D. Logan", "title": "Variations on the Post Correspondence Problem for free groups", "comments": "14 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Post Correspondence Problem is a classical decision problem about\nequalisers of free monoid homomorphisms. We prove connections between several\nvariations of this classical problem, but in the setting of free groups and\nfree group homomorphisms. Among other results, and working under certain\ninjectivity assumptions, we prove that computing the rank of the equaliser of a\npair of free group homomorphisms can be applied to computing a basis of this\nequaliser, and also to solve the \"generalised\" Post Correspondence Problem for\nfree groups.\n", "versions": [{"version": "v1", "created": "Mon, 12 Apr 2021 19:03:11 GMT"}], "update_date": "2021-04-14", "authors_parsed": [["Ciobanu", "Laura", ""], ["Logan", "Alan D.", ""]]}, {"id": "2104.08980", "submitter": "Daniel Selvaratnam", "authors": "Daniel Selvaratnam, Michael Cantoni, J. M. Davoren, Iman Shames", "title": "Sampling Polynomial Trajectories for LTL Verification", "comments": "Submitted to Theoretical Computer Science", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  This paper concerns the verification of continuous-time polynomial spline\ntrajectories against linear temporal logic specifications (LTL without 'next').\nEach atomic proposition is assumed to represent a state space region described\nby a multivariate polynomial inequality. The proposed approach is based on\nsampling the trajectories in a manner that captures all region transitions, to\nyield a discrete word called a trace, which is amenable to established formal\nmethods for path checking. The continuous-time trajectory is shown to satisfy\nthe specification if and only if the trace does. General topological conditions\non the sample points are derived that ensure a trace is recorded for arbitrary\ncontinuous paths, given arbitrary region descriptions. Using techniques from\ncomputer algebra, a trace generation algorithm is developed to satisfy these\nconditions when the path and region boundaries are defined by polynomials. The\nproposed PolyTrace algorithm has polynomial complexity in the number of atomic\npropositions, and is guaranteed to produce a trace of any polynomial path. Its\nperformance is demonstrated via numerical simulations.\n", "versions": [{"version": "v1", "created": "Mon, 19 Apr 2021 00:12:47 GMT"}], "update_date": "2021-04-20", "authors_parsed": [["Selvaratnam", "Daniel", ""], ["Cantoni", "Michael", ""], ["Davoren", "J. M.", ""], ["Shames", "Iman", ""]]}, {"id": "2104.09154", "submitter": "Ebru Aydin Gol", "authors": "Ebru Aydin Gol", "title": "Control Synthesis for Parametric Timed Automata under Unavoidability\n  Specifications", "comments": "Submitted to ECC'21", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Timed automata (TA) is used for modeling systems with timing aspects. A TA\nextends a finite automaton with a set of real valued variables called clocks,\nthat measure the time and constraints over the clocks guard the transitions. A\nparametric TA (PTA) is a TA extension that allows parameters in clock\nconstraints. In this paper, we focus on synthesis of a control strategy and\nparameter valuation for a PTA such that each run of the resulting TA reaches a\ntarget location within the given amount of time while avoiding unsafe\nlocations. We propose an algorithm based on depth first analysis combined with\nan iterative feasibility check. The algorithm iteratively constructs a symbolic\nrepresentation of the possible solutions, and employs a feasibility check to\nterminate the exploration along infeasible directions. Once the construction is\ncompleted, a mixed integer linear program is solved for each candidate strategy\nto generate a parameter valuation and a control strategy pair. We present a\nrobotic planning example to motivate the problem and to illustrate the results.\n", "versions": [{"version": "v1", "created": "Mon, 19 Apr 2021 09:29:01 GMT"}], "update_date": "2021-04-20", "authors_parsed": [["Gol", "Ebru Aydin", ""]]}, {"id": "2104.09717", "submitter": "Pawe{\\l} Parys", "authors": "Karoliina Lehtinen, Pawe{\\l} Parys, Sven Schewe, Dominik Wojtczak", "title": "A Recursive Approach to Solving Parity Games in Quasipolynomial Time", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Zielonka's classic recursive algorithm for solving parity games is perhaps\nthe simplest among the many existing parity game algorithms. However, its\ncomplexity is exponential, while currently the state-of-the-art algorithms have\nquasipolynomial complexity. Here, we present a modification of Zielonka's\nclassic algorithm that brings its complexity down to\n$n^{\\mathcal{O}\\left(\\log\\left(1+\\frac{d}{\\log n}\\right)\\right)}$, for parity\ngames of size $n$ with $d$ priorities, in line with previous\nquasipolynomial-time solutions.\n", "versions": [{"version": "v1", "created": "Tue, 20 Apr 2021 02:10:01 GMT"}], "update_date": "2021-04-21", "authors_parsed": [["Lehtinen", "Karoliina", ""], ["Parys", "Pawe\u0142", ""], ["Schewe", "Sven", ""], ["Wojtczak", "Dominik", ""]]}, {"id": "2104.09753", "submitter": "Daowen Qiu", "authors": "Daowen Qiu", "title": "Supervisory Control of Quantum Discrete Event Systems", "comments": "17 pages, 8 figures, minor typos are corrected; comments are welcome", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.AI cs.FL cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Discrete event systems (DES) have been established and deeply developed in\nthe framework of probabilistic and fuzzy computing models due to the necessity\nof practical applications in fuzzy and probabilistic systems. With the\ndevelopment of quantum computing and quantum control, a natural problem is to\nsimulate DES by means of quantum computing models and to establish {\\it quantum\nDES} (QDES). The motivation is twofold: on the one hand, QDES have potential\napplications when DES are simulated and processed by quantum computers, where\nquantum systems are employed to simulate the evolution of states driven by\ndiscrete events, and on the other hand, QDES may have essential advantages over\nDES concerning state complexity for imitating some practical problems. The goal\nof this paper is to establish a basic framework of QDES by using {\\it quantum\nfinite automata} (QFA) as the modelling formalisms, and the supervisory control\ntheorems of QDES are established and proved. Then we present a polynomial-time\nalgorithm to decide whether or not the controllability condition holds. In\nparticular, we construct a number of new examples of QFA to illustrate the\nsupervisory control of QDES and to verify the essential advantages of QDES over\nDES in state complexity.\n", "versions": [{"version": "v1", "created": "Tue, 20 Apr 2021 04:17:41 GMT"}, {"version": "v2", "created": "Thu, 22 Apr 2021 16:48:46 GMT"}], "update_date": "2021-04-23", "authors_parsed": [["Qiu", "Daowen", ""]]}, {"id": "2104.10358", "submitter": "Victor Selivanov", "authors": "Victor Selivanov", "title": "Wadge Degrees of Classes of omega-Regular k-Partitions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a theory of k-partitions of the set of infinite words recognizable\nby classes of finite automata. The theory enables to complete proofs of\nexisting results about topological classifications of the (aperiodic)\nomega-regular k-partitions and provides tools for dealing with other similar\nquestions. In particular, we characterize the structure of Wadge degrees of\n(aperiodic) omega-regular $k$-partitions, prove the decidability of many\nrelated problems, and discuss their complexity.\n", "versions": [{"version": "v1", "created": "Wed, 21 Apr 2021 05:19:32 GMT"}], "update_date": "2021-04-22", "authors_parsed": [["Selivanov", "Victor", ""]]}, {"id": "2104.11192", "submitter": "Abuzer Yakaryilmaz", "authors": "Aliya Khadieva and Abuzer Yakary{\\i}lmaz", "title": "Affine automata verifiers", "comments": "21 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We initiate the study of the verification power of AfAs as part of\nArthur-Merlin (AM) proof systems. We show that every unary language is verified\nby a real-valued AfA verifier. Then, we focus on the verifiers restricted to\nhave only integer-valued or rational-valued transitions. We observe that\nrational-valued verifiers can be simulated by integer-valued verifiers, and,\ntheir protocols can be simulated in nondeterministic polynomial time. We show\nthat this bound tight by presenting an AfA verifier for NP-complete problem\nSUBSETSUM. We also show that AfAs can verify certain non-affine and\nnon-stochastic unary languages.\n", "versions": [{"version": "v1", "created": "Thu, 22 Apr 2021 17:24:28 GMT"}], "update_date": "2021-04-23", "authors_parsed": [["Khadieva", "Aliya", ""], ["Yakary\u0131lmaz", "Abuzer", ""]]}, {"id": "2104.11453", "submitter": "Pierre Ganty", "authors": "Pierre Ganty, Elena Guti\\'errez, Pedro Valero", "title": "A Congruence-Based Perspective on Finite Tree Automata", "comments": "50 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide new insights on the determinization and minimization of tree\nautomata using congruences on trees. From this perspective, we study a\nBrzozowski's style minimization algorithm for tree automata. First, we prove\ncorrect this method relying on the following fact: when the automata-based and\nthe language-based congruences coincide, determinizing the automaton yields the\nminimal one. Such automata-based congruences, in the case of word automata, are\ndefined using pre and post operators. Now we extend these operators to tree\nautomata, a task that is particularly challenging due to the reduced expressive\npower of deterministic top-down (or equivalently co-deterministic bottom-up)\nautomata. We leverage further our framework to offer two extensions of the\noriginal result by Brzozowski for word automata.\n", "versions": [{"version": "v1", "created": "Fri, 23 Apr 2021 07:55:32 GMT"}], "update_date": "2021-04-26", "authors_parsed": [["Ganty", "Pierre", ""], ["Guti\u00e9rrez", "Elena", ""], ["Valero", "Pedro", ""]]}, {"id": "2104.11676", "submitter": "Abhishek Kulkarni", "authors": "Abhishek N. Kulkarni and Jie Fu", "title": "Synthesis of Deceptive Strategies in Reachability Games with Action\n  Misperception (Technical Report)", "comments": "40 pages, 6 figures, under review Journal of AI Research (JAIR)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Strategic deception is an act of manipulating the opponent's perception to\ngain strategic advantages. In this paper, we study synthesis of deceptive\nwinning strategies in two-player turn-based zero-sum reachability games on\ngraphs with one-sided incomplete information of action sets. In particular, we\nconsider the class of games in which Player 1 (P1) starts with a non-empty set\nof private actions, which she may 'reveal' to Player 2 (P2) during the course\nof the game. P2 is equipped with an inference mechanism using which he updates\nhis perception of P1's action set whenever a new action is revealed. Under this\ninformation structure, the objective of P1 is to reach a set of goal states in\nthe game graph while that of P2 is to prevent it. We address the question: how\ncan P1 leverage her information advantages to deceive P2 into choosing actions\nthat in turn benefit P1? To this end, we introduce a dynamic hypergame model to\ncapture the reachability game with evolving misperception of P2. Analyzing the\ngame qualitatively, we design algorithms to synthesize deceptive sure and\nalmost-sure winning regions, and establish two key results: (1) under\nsure-winning condition, deceptive winning strategy is equivalent to the\nnon-deceptive winning strategy - i.e. use of deception has no advantages, (2)\nunder almost-sure winning condition, the deceptive winning strategy could be\nmore powerful than the non-deceptive strategy. We illustrate our algorithms\nusing a capture-the-flag game, and demonstrate the use of proposed approach to\na larger class of games with temporal logic objectives.\n", "versions": [{"version": "v1", "created": "Fri, 23 Apr 2021 16:12:01 GMT"}], "update_date": "2021-04-26", "authors_parsed": [["Kulkarni", "Abhishek N.", ""], ["Fu", "Jie", ""]]}, {"id": "2104.11758", "submitter": "Rapha\\\"el Berthon", "authors": "Rapha\\\"el Berthon, Adrien Boiret, Guillermo A. Perez,\n  Jean-Fran\\c{c}ois Raskin", "title": "Active Learning of Sequential Transducers with Side Information about\n  the Domain", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Active learning is a setting in which a student queries a teacher, through\nmembership and equivalence queries, in order to learn a language. Performance\non these algorithms is often measured in the number of queries required to\nlearn a target, with an emphasis on costly equivalence queries. In graybox\nlearning, the learning process is accelerated by foreknowledge of some\ninformation on the target. Here, we consider graybox active learning of\nsubsequential string transducers, where a regular overapproximation of the\ndomain is known by the student. We show that there exists an algorithm using\nstring equation solvers that uses this knowledge to learn subsequential string\ntransducers with a better guarantee on the required number of equivalence\nqueries than classical active learning.\n", "versions": [{"version": "v1", "created": "Fri, 23 Apr 2021 18:01:10 GMT"}], "update_date": "2021-04-27", "authors_parsed": [["Berthon", "Rapha\u00ebl", ""], ["Boiret", "Adrien", ""], ["Perez", "Guillermo A.", ""], ["Raskin", "Jean-Fran\u00e7ois", ""]]}, {"id": "2104.12018", "submitter": "S{\\l}awomir Lasota", "authors": "Piotr Hofman and Marta Juzepczuk and S{\\l}awomir Lasota and Mohnish\n  Pattathurajan", "title": "Parikh's theorem for infinite alphabets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We investigate commutative images of languages recognised by register\nautomata and grammars. Semi-linear and rational sets can be naturally extended\nto this setting by allowing for orbit-finite unions instead of only finite\nones. We prove that commutative images of languages of one-register automata\nare not always semi-linear, but they are always rational. We also lift the\nlatter result to grammars: commutative images of one-register context-free\nlanguages are rational, and in consequence commutatively equivalent to register\nautomata. We conjecture analogous results for automata and grammars with\narbitrarily many registers.\n", "versions": [{"version": "v1", "created": "Sat, 24 Apr 2021 20:31:06 GMT"}], "update_date": "2021-04-27", "authors_parsed": [["Hofman", "Piotr", ""], ["Juzepczuk", "Marta", ""], ["Lasota", "S\u0142awomir", ""], ["Pattathurajan", "Mohnish", ""]]}, {"id": "2104.12455", "submitter": "Lorenzo Bacchiani", "authors": "Lorenzo Bacchiani, Mario Bravetti, Julien Lange, Gianluigi Zavattaro", "title": "A Session Subtyping Tool (Extended Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Session types are becoming popular and have been integrated in several\nmainstream programming languages. Nevertheless, while many programming\nlanguages consider asynchronous fifo channel communication, the notion of\nsubtyping used in session type implementations is the one defined by Gay and\nHole for synchronous communication. This might be because there are several\nnotions of asynchronous session subtyping, these notions are usually\nundecidable, and only recently sound (but not complete) algorithmic\ncharacterizations for these subtypings have been proposed. But the fact that\nthe definition of asynchronous session subtyping and the theory behind related\nalgorithms are not easily accessible to non-experts may also prevent further\nintegration. The aim of this paper, and of the tool presented therein, is to\nmake the growing body of knowledge about asynchronous session subtyping more\naccessible, thus promoting its integration in practical applications of session\ntypes.\n", "versions": [{"version": "v1", "created": "Mon, 26 Apr 2021 10:35:17 GMT"}, {"version": "v2", "created": "Wed, 28 Apr 2021 18:27:53 GMT"}], "update_date": "2021-04-30", "authors_parsed": [["Bacchiani", "Lorenzo", ""], ["Bravetti", "Mario", ""], ["Lange", "Julien", ""], ["Zavattaro", "Gianluigi", ""]]}, {"id": "2104.12508", "submitter": "Sarah Winter", "authors": "Christof L\\\"oding and Sarah Winter", "title": "Resynchronized Uniformization and Definability Problems for Rational\n  Relations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Regular synchronization languages can be used to define rational relations of\nfinite words, and to characterize subclasses of rational relations, like\nautomatic or recognizable relations. We provide a systematic study of the\ndecidability of uniformization and definability problems for subclasses of\nrational relations defined in terms of such synchronization languages. We\nrephrase known results in this setting and complete the picture by adding\nseveral new decidability and undecidability results.\n", "versions": [{"version": "v1", "created": "Mon, 26 Apr 2021 12:17:31 GMT"}], "update_date": "2021-04-27", "authors_parsed": [["L\u00f6ding", "Christof", ""], ["Winter", "Sarah", ""]]}, {"id": "2104.13315", "submitter": "Shivam Handa", "authors": "Shivam Handa and Martin Rinard", "title": "Inductive Program Synthesis over Noisy Datasets using Abstraction\n  Refinement Based Optimization", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new synthesis algorithm to solve program synthesis over noisy\ndatasets, i.e., data that may contain incorrect/corrupted input-output\nexamples. Our algorithm uses an abstraction refinement based optimization\nprocess to synthesize programs which optimize the tradeoff between the loss\nover the noisy dataset and the complexity of the synthesized program. The\nalgorithm uses abstractions to divide the search space of programs into\nsubspaces by computing an abstract value that represents outputs for all\nprograms in a subspace. The abstract value allows our algorithm to compute, for\neach subspace, a sound approximate lower bound of the loss over all programs in\nthe subspace. It iteratively refines these abstractions to further subdivide\nthe space into smaller subspaces, prune subspaces that do not contain an\noptimal program, and eventually synthesize an optimal program.\n  We implemented this algorithm in a tool called Rose. We compare Rose to a\ncurrent state-of-the-art noisy program synthesis system using the SyGuS 2018\nbenchmark suite. Our evaluation demonstrates that Rose significantly\noutperforms this previous system: on two noisy benchmark program synthesis\nproblems sets drawn from the SyGus 2018 benchmark suite, Rose delivers speedups\nof up to 1587 and 81.7, with median speedups of 20.5 and 81.7. Rose also\nterminates on 20 (out of 54) and 4 (out of 11) more benchmark problems than the\nprevious system. Both Rose and the previous system synthesize programs that are\noptimal over the provided noisy data sets. For the majority of the problems in\nthe benchmark sets ($272$ out of $286$), the synthesized programs also produce\ncorrect outputs for all inputs in the original (unseen) noise-free data set.\nThese results highlight the benefits that Rose can deliver for effective noisy\nprogram synthesis.\n", "versions": [{"version": "v1", "created": "Tue, 27 Apr 2021 16:45:11 GMT"}], "update_date": "2021-04-28", "authors_parsed": [["Handa", "Shivam", ""], ["Rinard", "Martin", ""]]}, {"id": "2104.13421", "submitter": "Stefan Zetzsche", "authors": "Stefan Zetzsche, Gerco van Heerdt, Alexandra Silva, Matteo Sammartino", "title": "Canonical automata via distributive law homomorphisms", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The classical powerset construction is a standard method converting a\nnondeterministic automaton into a deterministic one recognising the same\nlanguage. Recently, the powerset construction has been lifted to a more general\nframework that converts an automaton with side-effects, given by a monad, into\na deterministic automaton accepting the same language. The resulting automaton\nhas additional algebraic properties, both in the state space and transition\nstructure, inherited from the monad. In this paper, we study the reverse\nconstruction and present a framework in which a deterministic automaton with\nadditional algebraic structure over a given monad can be converted into an\nequivalent succinct automaton with side-effects. Apart from recovering examples\nfrom the literature, such as the canonical residual finite-state automaton and\nthe \\'atomaton, we discover a new canonical automaton for a regular language by\nrelating the free vector space monad over the two element field to the\nneighbourhood monad. Finally, we show that every regular language satisfying a\nsuitable property parametric in two monads admits a size-minimal succinct\nacceptor.\n", "versions": [{"version": "v1", "created": "Tue, 27 Apr 2021 18:35:24 GMT"}, {"version": "v2", "created": "Thu, 10 Jun 2021 16:35:20 GMT"}], "update_date": "2021-06-11", "authors_parsed": [["Zetzsche", "Stefan", ""], ["van Heerdt", "Gerco", ""], ["Silva", "Alexandra", ""], ["Sammartino", "Matteo", ""]]}, {"id": "2104.13434", "submitter": "Abdulrazaq Abba", "authors": "Abdulrazaq Abba, Ana Cavalcanti, Jeremy Jacob", "title": "Temporal Reasoning Through Automatic Translation of tock-CSP into Timed\n  Automata", "comments": "arXiv admin note: substantial text overlap with arXiv:2008.06935", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we consider translating tock-CSP into Timed Automata for UPPAAL\nto facilitate using UPPAAL in reasoning about temporal specifications of\ntock-CSP models. The process algebra tock-CSP provides textual notations for\nmodelling discrete-time behaviours, with the support of tools for automatic\nverification. Similarly, automatic verification of Timed Automata (TA) with a\ngraphical notation is supported by the UPPAAL real-time verification toolbox\n\\uppaal. The two modelling approaches, TA and tock-CSP, differ in both\nmodelling and verification approaches, temporal logic and refinement,\nrespectively, as well as their provided facilities for automatic verification.\nFor instance, liveness requirements are difficult to specify with the\nconstructs of tock-CSP, but they are easy to specify and verify in UPPAAL. To\ntake advantage of temporal logic, we translate tock-CSP into TA for \\uppaal; we\nhave developed a translation technique and its supporting tool. We provide\nrules for translating tock-CSP into a network of small TAs for capturing the\ncompositional structure of tock-CSP that is not available in TA. For\nvalidation, we start with an experimental approach based on finite\napproximations to trace sets. Then, we explore mathematical proof to establish\nthe correctness of the rules for covering infinite traces.\n", "versions": [{"version": "v1", "created": "Tue, 27 Apr 2021 19:06:15 GMT"}], "update_date": "2021-04-29", "authors_parsed": [["Abba", "Abdulrazaq", ""], ["Cavalcanti", "Ana", ""], ["Jacob", "Jeremy", ""]]}, {"id": "2104.13831", "submitter": "Lucia Nasti", "authors": "Lucia Nasti, Roberta Gori, Paolo Milazzo", "title": "Formal characterization and efficient verification of a biological\n  robustness property", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Robustness is an observable property for which a chemical reaction network\n(CRN) can maintain its functionalities despite the influence of different\nperturbations. In general, to verify whether a network is robust, it is\nnecessary to consider all the possible parameter configurations. This is a\nprocess that can entail a massive computational effort. In the work of Rizk et\nal., the authors propose a definition of robustness in linear temporal logic\n(LTL) through which, on the basis of multiple numerical timed traces obtained\nby considering different parameter configurations, they verify the robustness\nof a reaction network. In this paper, we focus on a notion of initial\nconcentration robustness ($\\alpha$-robustness), which is related to the\ninfluence of the perturbation of the initial concentration of one species\n(i.e., the input) on the concentration of another species (i.e., the output) at\nthe steady state. We characterize this notion of robustness in the framework\nproposed by Rizk et al., and we show that, for monotonic reaction networks,\nthis allows us to drastically reduce the number of traces necessary to verify\nrobustness of the CRN.\n", "versions": [{"version": "v1", "created": "Wed, 28 Apr 2021 15:37:10 GMT"}], "update_date": "2021-04-29", "authors_parsed": [["Nasti", "Lucia", ""], ["Gori", "Roberta", ""], ["Milazzo", "Paolo", ""]]}, {"id": "2104.13866", "submitter": "Wojciech Czerwi\\'nski", "authors": "Wojciech Czerwi\\'nski, {\\L}ukasz Orlikowski", "title": "Reachability in Vector Addition Systems is Ackermann-complete", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Vector Addition Systems and equivalent Petri nets are a well established\nmodels of concurrency. The central algorithmic problem for Vector Addition\nSystems with a long research history is the reachability problem asking whether\nthere exists a run from one given configuration to another. We settle its\ncomplexity to be Ackermann-complete thus closing the problem open for 45 years.\nIn particular we prove that the problem is $\\mathcal{F}_k$-hard for Vector\nAddition Systems with States in dimension $6k$, where $\\mathcal{F}_k$ is the\n$k$-th complexity class from the hierarchy of fast-growing complexity classes.\n", "versions": [{"version": "v1", "created": "Wed, 28 Apr 2021 16:23:18 GMT"}, {"version": "v2", "created": "Thu, 10 Jun 2021 10:56:14 GMT"}], "update_date": "2021-06-11", "authors_parsed": [["Czerwi\u0144ski", "Wojciech", ""], ["Orlikowski", "\u0141ukasz", ""]]}, {"id": "2104.14019", "submitter": "Ga\\\"etan Dou\\'eneau-Tabot", "authors": "Ga\\\"etan Dou\\'eneau-Tabot", "title": "Pebble transducers with unary output", "comments": "39 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Boja\\'nczyk recently initiated an intensive study of deterministic pebble\ntransducers, which are two-way automata that can drop marks (named \"pebbles\")\non their input word, and produce an output word. They describe functions from\nwords to words. Two natural restrictions of this definition have been\ninvestigated: marble transducers by Dou\\'eneau-Tabot et al., and\ncomparison-free pebble transducers (that we rename here \"blind transducers\") by\nNguy\\^en et al.\n  Here, we study the decidability of membership problems between the classes of\nfunctions computed by pebble, marble and blind transducers that produce a unary\noutput. First, we show that pebble and marble transducers have the same\nexpressive power when the outputs are unary (which is false over non-unary\noutputs). Then, we characterize 1-pebble transducers with unary output that\ndescribe a function computable by a blind transducer, and show that the\nmembership problem is decidable. These results can be interpreted in terms of\nautomated simplification of programs.\n", "versions": [{"version": "v1", "created": "Wed, 28 Apr 2021 20:52:04 GMT"}, {"version": "v2", "created": "Fri, 30 Apr 2021 19:27:14 GMT"}, {"version": "v3", "created": "Sun, 11 Jul 2021 10:13:25 GMT"}], "update_date": "2021-07-13", "authors_parsed": [["Dou\u00e9neau-Tabot", "Ga\u00ebtan", ""]]}, {"id": "2104.14266", "submitter": "Mathias Ruggaard Pedersen", "authors": "Antonis Achilleos, Mathias Ruggaard Pedersen", "title": "Axiomatizations and Computability of Weighted Monadic Second-Order Logic", "comments": "Full version of paper to be published in the proceedings of LICS 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Weighted monadic second-order logic is a weighted extension of monadic\nsecond-order logic that captures exactly the behaviour of weighted automata.\nIts semantics is parameterized with respect to a semiring on which the values\nthat weighted formulas output are evaluated. Gastin and Monmege (2018) gave\nabstract semantics for a version of weighted monadic second-order logic to give\na more general and modular proof of the equivalence of the logic with weighted\nautomata. We focus on the abstract semantics of the logic and we give a\ncomplete axiomatization both for the full logic and for a fragment without\ngeneral sum, thus giving a more fine-grained understanding of the logic. We\ndiscuss how common decision problems for logical languages can be adapted to\nthe weighted setting, and show that many of these are decidable, though they\ninherit bad complexity from the underlying first- and second-order logics.\nHowever, we show that a weighted adaptation of satisfiability is undecidable\nfor the logic when one uses the abstract interpretation.\n", "versions": [{"version": "v1", "created": "Thu, 29 Apr 2021 11:24:26 GMT"}], "update_date": "2021-04-30", "authors_parsed": [["Achilleos", "Antonis", ""], ["Pedersen", "Mathias Ruggaard", ""]]}, {"id": "2104.14408", "submitter": "Laetitia Laversa", "authors": "Cinzia Di Giusto, Laetitia Laversa, Etienne Lozes", "title": "Guessing the buffer bound for k-synchronizability", "comments": "Long version of CIAA paper (19 pages)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A communicating system is $k$-synchronizable if all of the message sequence\ncharts representing the executions can be divided into slices of $k$ sends\nfollowed by $k$ receptions. It was previously shown that, for a fixed given\n$k$, one could decide whether a communicating system is $k$-synchronizable.\nThis result is interesting because the reachability problem can be solved for\n$k$-synchronizable systems. However, the decision procedure assumes that the\nbound $k$ is fixed. In this paper we improve this result and show that it is\npossible to decide if such a bound $k$ exists.\n", "versions": [{"version": "v1", "created": "Thu, 29 Apr 2021 15:19:34 GMT"}], "update_date": "2021-04-30", "authors_parsed": [["Di Giusto", "Cinzia", ""], ["Laversa", "Laetitia", ""], ["Lozes", "Etienne", ""]]}, {"id": "2104.14519", "submitter": "Rohit Chadha", "authors": "Rohit Chadha, A. Prasad Sistla and Mahesh Viswanathan", "title": "On Linear Time Decidability of Differential Privacy for Programs with\n  Unbounded Inputs", "comments": "An extended abstract to be published in 36th Annual IEEE Symposium on\n  Logic in Computer Science (LICS 2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce an automata model for describing interesting classes of\ndifferential privacy mechanisms/algorithms that include known mechanisms from\nthe literature. These automata can model algorithms whose inputs can be an\nunbounded sequence of real-valued query answers. We consider the problem of\nchecking whether there exists a constant $d$ such that the algorithm described\nby these automata are $d\\epsilon$-differentially private for all positive\nvalues of the privacy budget parameter $\\epsilon$. We show that this problem\ncan be decided in time linear in the automaton's size by identifying a\nnecessary and sufficient condition on the underlying graph of the automaton.\nThis paper's results are the first decidability results known for algorithms\nwith an unbounded number of query answers taking values from the set of reals.\n", "versions": [{"version": "v1", "created": "Thu, 29 Apr 2021 17:34:44 GMT"}], "update_date": "2021-04-30", "authors_parsed": [["Chadha", "Rohit", ""], ["Sistla", "A. Prasad", ""], ["Viswanathan", "Mahesh", ""]]}, {"id": "2104.14785", "submitter": "Sayandeep Sanyal", "authors": "Sayandeep Sanyal, Ayan Chakraborty, Pallab Dasgupta, Aritra Hazra", "title": "Methodology for Biasing Random Simulation for Rapid Coverage of Corner\n  Cases in AMS Designs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Exploring the limits of an Analog and Mixed Signal (AMS) circuit by driving\nappropriate inputs has been a serious challenge to the industry. Doing an\nexhaustive search of the entire input state space is a time-consuming exercise\nand the returns to efforts ratio is quite low. In order to meet time-to-market\nrequirements, often suboptimal coverage results of an integrated circuit (IC)\nare leveraged. Additionally, no standards have been defined which can be used\nto identify a target in the continuous state space of analog domain such that\nthe searching algorithm can be guided with some heuristics. In this report, we\nelaborate on two approaches for tackling this challenge - one is based on\nfrequency domain analysis of the circuit, while the other applies the concept\nof Bayesian optimization. We have also presented our results by applying the\ntwo approaches on an industrial LDO and a few AMS benchmark circuits.\n", "versions": [{"version": "v1", "created": "Fri, 30 Apr 2021 06:50:33 GMT"}], "update_date": "2021-05-03", "authors_parsed": [["Sanyal", "Sayandeep", ""], ["Chakraborty", "Ayan", ""], ["Dasgupta", "Pallab", ""], ["Hazra", "Aritra", ""]]}, {"id": "2104.15083", "submitter": "Rajarshi Roy", "authors": "Jean-Rapha\\\"el Gaglione, Daniel Neider, Rajarshi Roy, Ufuk Topcu and\n  Zhe Xu", "title": "Learning Linear Temporal Properties from Noisy Data: A MaxSAT Approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.AI cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address the problem of inferring descriptions of system behavior using\nLinear Temporal Logic (LTL) from a finite set of positive and negative\nexamples. Most of the existing approaches for solving such a task rely on\npredefined templates for guiding the structure of the inferred formula. The\napproaches that can infer arbitrary LTL formulas, on the other hand, are not\nrobust to noise in the data. To alleviate such limitations, we devise two\nalgorithms for inferring concise LTL formulas even in the presence of noise.\nOur first algorithm infers minimal LTL formulas by reducing the inference\nproblem to a problem in maximum satisfiability and then using off-the-shelf\nMaxSAT solvers to find a solution. To the best of our knowledge, we are the\nfirst to incorporate the usage of MaxSAT solvers for inferring formulas in LTL.\nOur second learning algorithm relies on the first algorithm to derive a\ndecision tree over LTL formulas based on a decision tree learning algorithm. We\nhave implemented both our algorithms and verified that our algorithms are\nefficient in extracting concise LTL descriptions even in the presence of noise.\n", "versions": [{"version": "v1", "created": "Fri, 30 Apr 2021 16:06:03 GMT"}, {"version": "v2", "created": "Thu, 24 Jun 2021 19:56:55 GMT"}], "update_date": "2021-06-28", "authors_parsed": [["Gaglione", "Jean-Rapha\u00ebl", ""], ["Neider", "Daniel", ""], ["Roy", "Rajarshi", ""], ["Topcu", "Ufuk", ""], ["Xu", "Zhe", ""]]}]