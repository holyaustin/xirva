[{"id": "1808.00261", "submitter": "Tom\\'a\\v{s} Masopust", "authors": "Tom\\'a\\v{s} Masopust", "title": "Critical Observability for Automata and Petri Nets", "comments": "Accepted for publication in IEEE TAC", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Critical observability is a property of cyber-physical systems to detect\nwhether the current state belongs to a set of critical states. In\nsafety-critical applications, critical states model operations that may be\nunsafe or of a particular interest. De Santis et al. introduced critical\nobservability for linear switching systems, and Pola et al. adapted it for\ndiscrete-event systems, focusing on algorithmic complexity. We study the\ncomputational complexity of deciding critical observability for systems modeled\nas (networks of) finite-state automata and Petri nets. We show that deciding\ncritical observability is (i) NL-complete for finite automata, that is, it is\nefficiently verifiable on parallel computers, (ii) PSPACE-complete for networks\nof finite automata, that is, it is very unlikely solvable in polynomial time,\nand (iii) undecidable for labeled Petri nets, but becoming decidable if the set\nof critical states (markings) is finite or co-finite, in which case the problem\nis as hard as the non-reachability problem for Petri nets.\n", "versions": [{"version": "v1", "created": "Wed, 1 Aug 2018 10:53:34 GMT"}, {"version": "v2", "created": "Wed, 17 Apr 2019 09:41:39 GMT"}], "update_date": "2019-04-18", "authors_parsed": [["Masopust", "Tom\u00e1\u0161", ""]]}, {"id": "1808.00843", "submitter": "Tuan Phong Ngo", "authors": "Parosh Aziz Abdulla and Mohamed Faouzi Atig and Bengt Jonsson and Tuan\n  Phong Ngo", "title": "Optimal Stateless Model Checking under the Release-Acquire Semantics", "comments": "Accepted paper in OOPSLA'18", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a framework for the efficient application of stateless model\nchecking (SMC) to concurrent programs running under the Release-Acquire (RA)\nfragment of the C/C++11 memory model. Our approach is based on exploring the\npossible program orders, which define the order in which instructions of a\nthread are executed, and read-from relations, which specify how reads obtain\ntheir values from writes. This is in contrast to previous approaches, which\nalso explore the possible coherence orders, i.e., orderings between conflicting\nwrites. Since unexpected test results such as program crashes or assertion\nviolations depend only on the read-from relation, we avoid a potentially\nsignificant source of redundancy. Our framework is based on a novel technique\nfor determining whether a particular read-from relation is feasible under the\nRA semantics. We define an SMC algorithm which is provably optimal in the sense\nthat it explores each program order and read-from relation exactly once. This\noptimality result is strictly stronger than previous analogous optimality\nresults, which also take coherence order into account. We have implemented our\nframework in the tool Tracer. Experiments show that Tracer can be significantly\nfaster than state-of-the-art tools that can handle the RA semantics.\n", "versions": [{"version": "v1", "created": "Thu, 2 Aug 2018 14:55:27 GMT"}, {"version": "v2", "created": "Mon, 10 Sep 2018 21:26:47 GMT"}], "update_date": "2018-09-12", "authors_parsed": [["Abdulla", "Parosh Aziz", ""], ["Atig", "Mohamed Faouzi", ""], ["Jonsson", "Bengt", ""], ["Ngo", "Tuan Phong", ""]]}, {"id": "1808.00940", "submitter": "Stefan Kiefer", "authors": "Stefan Kiefer and Corto Mascle", "title": "On Nonnegative Integer Matrices and Short Killing Words", "comments": "This version has been accepted by the SIAM Journal on Discrete\n  Mathematics (SIDMA). The article extends the STACS'19 paper as follows. (1)\n  The main result has been generalized to monoids generated by finite sets\n  whose joint spectral radius is at most 1. (2) The use of Carpi's theorem is\n  avoided. (3) A more precise result is offered on Restivo's conjecture for\n  finite codes", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let $n$ be a natural number and $\\mathcal{M}$ a set of $n \\times n$-matrices\nover the nonnegative integers such that the joint spectral radius of\n$\\mathcal{M}$ is at most one. We show that if the zero matrix $0$ is a product\nof matrices in $\\mathcal{M}$, then there are $M_1, \\ldots, M_{n^5} \\in\n\\mathcal{M}$ with $M_1 \\cdots M_{n^5} = 0$. This result has applications in\nautomata theory and the theory of codes. Specifically, if $X \\subset \\Sigma^*$\nis a finite incomplete code, then there exists a word $w \\in \\Sigma^*$ of\nlength polynomial in $\\sum_{x \\in X} |x|$ such that $w$ is not a factor of any\nword in $X^*$. This proves a weak version of Restivo's conjecture.\n", "versions": [{"version": "v1", "created": "Thu, 2 Aug 2018 17:44:35 GMT"}, {"version": "v2", "created": "Sun, 23 Dec 2018 13:11:19 GMT"}, {"version": "v3", "created": "Mon, 18 Mar 2019 12:43:03 GMT"}, {"version": "v4", "created": "Fri, 26 Feb 2021 18:31:08 GMT"}], "update_date": "2021-03-01", "authors_parsed": [["Kiefer", "Stefan", ""], ["Mascle", "Corto", ""]]}, {"id": "1808.01711", "submitter": "Shubh Singh", "authors": "Shubh N. Singh and Ankit Raj", "title": "On the Synchronization of Circular Semi-Flower Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Pin proved that every circular automaton with a prime number of states\ncontaining a non-permutation is synchronizing. In this paper, we investigate\nthe synchronization of circular semi-flower automata. We first prove that every\nsemi-flower automaton is a one-cluster automaton. Subsequently, we prove that\nevery semi-flower automaton containing a 1-cycle is synchronizing. Further, we\nprove that every circular semi-flower automaton with an odd number of states\ncontaining a 2-cycle is synchronizing.\n", "versions": [{"version": "v1", "created": "Mon, 6 Aug 2018 02:19:31 GMT"}], "update_date": "2018-08-07", "authors_parsed": [["Singh", "Shubh N.", ""], ["Raj", "Ankit", ""]]}, {"id": "1808.01893", "submitter": "Cinzia Di Giusto", "authors": "Elisabetta De Maria (C&A), Cinzia Di Giusto (C&A), Laetitia Laversa\n  (C&A)", "title": "Spiking Neural Networks modelled as Timed Automata with parameter\n  learning", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "q-bio.NC cs.FL q-bio.QM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present a novel approach to automatically infer parameters\nof spiking neural networks. Neurons are modelled as timed automata waiting for\ninputs on a number of different channels (synapses), for a given amount of time\n(the accumulation period). When this period is over, the current potential\nvalue is computed considering current and past inputs. If this potential\novercomes a given threshold, the automaton emits a broadcast signal over its\noutput channel , otherwise it restarts another accumulation period. After each\nemission, the automaton remains inactive for a fixed refractory period. Spiking\nneural networks are formalised as sets of automata, one for each neuron,\nrunning in parallel and sharing channels according to the network structure.\nSuch a model is formally validated against some crucial properties defined via\nproper temporal logic formulae. The model is then exploited to find an\nassignment for the synaptical weights of neural networks such that they can\nreproduce a given behaviour. The core of this approach consists in identifying\nsome correcting actions adjusting synaptical weights and back-propagating them\nuntil the expected behaviour is displayed. A concrete case study is discussed.\n", "versions": [{"version": "v1", "created": "Wed, 1 Aug 2018 08:19:31 GMT"}], "update_date": "2018-08-07", "authors_parsed": [["De Maria", "Elisabetta", "", "C&A"], ["Di Giusto", "Cinzia", "", "C&A"], ["Laversa", "Laetitia", "", "C&A"]]}, {"id": "1808.02529", "submitter": "Jeffrey Shallit", "authors": "Jeffrey Shallit, Ramin Zarifi", "title": "Circular critical exponents for Thue-Morse factors", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove various results about the largest exponent of a repetition in a\nfactor of the Thue-Morse word, when that factor is considered as a circular\nword. Our results confirm and generalize previous results of Fitzpatrick and\nAberkane & Currie.\n", "versions": [{"version": "v1", "created": "Tue, 7 Aug 2018 19:25:35 GMT"}], "update_date": "2018-08-09", "authors_parsed": [["Shallit", "Jeffrey", ""], ["Zarifi", "Ramin", ""]]}, {"id": "1808.02680", "submitter": "Gwenael Richomme", "authors": "Gwena\\\"el Richomme (ESCAPE, UM3)", "title": "Characterization of infinite LSP words and endomorphisms preserving the\n  LSP property", "comments": "arXiv admin note: text overlap with arXiv:1705.05786", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Answering a question of G. Fici, we give an $S$-adic characterization of\nthefamily of infinite LSP words, that is, the family of infinite words having\nall their left special factors as prefixes.More precisely we provide a finite\nset of morphisms $S$ and an automaton ${\\cal A}$ such that an infinite word is\nLSP if and only if it is $S$-adic and one of its directive words is\nrecognizable by ${\\cal A}$.Then we characterize the endomorphisms that preserve\nthe property of being LSP for infinite words.This allows us to prove that there\nexists no set $S'$ of endomorphisms for which the set of infinite LSP words\ncorresponds to the set of $S'$-adic words. This implies that an automaton is\nrequired no matter which set of morphisms is used.\n", "versions": [{"version": "v1", "created": "Wed, 8 Aug 2018 09:12:57 GMT"}], "update_date": "2018-08-09", "authors_parsed": [["Richomme", "Gwena\u00ebl", "", "ESCAPE, UM3"]]}, {"id": "1808.02692", "submitter": "Yli\\`es Falcone", "authors": "Antoine El-Hokayem and Yli\\`es Falcone", "title": "On the Monitoring of Decentralized Specifications Semantics, Properties,\n  Analysis, and Simulation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define two complementary approaches to monitor decentralized systems. The\nfirst relies on those with a centralized specification, i.e, when the\nspecification is written for the behavior of the entire system. To do so, our\napproach introduces a data-structure that i) keeps track of the execution of an\nautomaton, ii) has predictable parameters and size, and iii) guarantees strong\neventual consistency. The second approach defines decentralized specifications\nwherein multiple specifications are provided for separate parts of the system.\nWe study two properties of decentralized specifications pertaining to\nmonitorability and compatibility between specification and architecture. We\nalso present a general algorithm for monitoring decentralized specifications.\nWe map three existing algorithms to our approaches and provide a framework for\nanalyzing their behavior. Furthermore, we introduce THEMIS, a framework for\ndesigning such decentralized algorithms and simulating their behavior. We show\nthe usage of THEMIS to compare multiple algorithms and verify the trends\npredicted by the analysis by studying two scenarios: a synthetic benchmark and\na real example.\n", "versions": [{"version": "v1", "created": "Wed, 8 Aug 2018 09:40:35 GMT"}], "update_date": "2018-08-09", "authors_parsed": [["El-Hokayem", "Antoine", ""], ["Falcone", "Yli\u00e8s", ""]]}, {"id": "1808.03315", "submitter": "Curtis Madsen", "authors": "Curtis Madsen, Prashant Vaidyanathan, Sadra Sadraddini, Cristian-Ioan\n  Vasile, Nicholas A. DeLateur, Ron Weiss, Douglas Densmore, Calin Belta", "title": "Metrics for Signal Temporal Logic Formulae", "comments": "This paper has been accepted for presentation at, and publication in\n  the proceedings of, the 2018 IEEE Conference on Decision and Control (CDC),\n  to be held in Fontainebleau, Miami Beach, FL, USA on Dec. 17-19, 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Signal Temporal Logic (STL) is a formal language for describing a broad range\nof real-valued, temporal properties in cyber-physical systems. While there has\nbeen extensive research on verification and control synthesis from STL\nrequirements, there is no formal framework for comparing two STL formulae. In\nthis paper, we show that under mild assumptions, STL formulae admit a metric\nspace. We propose two metrics over this space based on i) the Pompeiu-Hausdorff\ndistance and ii) the symmetric difference measure, and present algorithms to\ncompute them. Alongside illustrative examples, we present applications of these\nmetrics for two fundamental problems: a) design quality measures: to compare\nall the temporal behaviors of a designed system, such as a synthetic genetic\ncircuit, with the \"desired\" specification, and b) loss functions: to quantify\nerrors in Temporal Logic Inference (TLI) as a first step to establish formal\nperformance guarantees of TLI algorithms.\n", "versions": [{"version": "v1", "created": "Wed, 1 Aug 2018 07:27:30 GMT"}], "update_date": "2018-08-13", "authors_parsed": [["Madsen", "Curtis", ""], ["Vaidyanathan", "Prashant", ""], ["Sadraddini", "Sadra", ""], ["Vasile", "Cristian-Ioan", ""], ["DeLateur", "Nicholas A.", ""], ["Weiss", "Ron", ""], ["Densmore", "Douglas", ""], ["Belta", "Calin", ""]]}, {"id": "1808.03559", "submitter": "Achim Blumensath", "authors": "Achim Blumensath", "title": "Regular Tree Algebras", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 1 (February\n  13, 2020) lmcs:6101", "doi": "10.23638/LMCS-16(1:16)2020", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce a class of algebras that can be used as recognisers for regular\ntree languages. We show that it is the only such class that forms a\npseudo-variety and we prove the existence of syntactic algebras. Finally, we\ngive a more algebraic characterisation of the algebras in our class.\n", "versions": [{"version": "v1", "created": "Fri, 10 Aug 2018 14:25:01 GMT"}, {"version": "v2", "created": "Thu, 15 Aug 2019 15:27:04 GMT"}, {"version": "v3", "created": "Mon, 3 Feb 2020 13:28:53 GMT"}, {"version": "v4", "created": "Wed, 12 Feb 2020 14:03:42 GMT"}], "update_date": "2020-06-17", "authors_parsed": [["Blumensath", "Achim", ""]]}, {"id": "1808.04239", "submitter": "Chen-Kai Lin", "authors": "Chen-Kai Lin, Ching-Chun (Jim) Huang, Bow-Yaw Wang", "title": "A Spin-based model checking for the simple concurrent program on a\n  preemptive RTOS", "comments": "7 pages, 5 figures, The 24th Workshop on Compiler Techniques and\n  System Software for High-Performance and Embedded Computing, 2018, Chiayi,\n  Taiwan", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  We adapt an existing preemptive scheduling model of RTOS kernel by eChronos\nfrom machine-assisted proof to Spin-based model checker. The model we\nconstructed can be automatically verified rather than formulating proofs by\nhand. Moreover, we look into the designs of a Linux-like real-time\nkernel--Piko/RT and the specification of ARMv7-M architecture to reconstruct\nthe model, and use LTL to specify a simple concurrent\nprograms--consumer/producer problem during the development stage of the kernel.\nWe show that under the preemptive scheduling and the mechanism of ARMv7-M, the\nprogram will not suffer from race condition, starvation, and deadlock.\n", "versions": [{"version": "v1", "created": "Tue, 7 Aug 2018 08:21:58 GMT"}], "update_date": "2018-08-14", "authors_parsed": [["Lin", "Chen-Kai", "", "Jim"], ["Ching-Chun", "", "", "Jim"], ["Huang", "", ""], ["Wang", "Bow-Yaw", ""]]}, {"id": "1808.05791", "submitter": "Mickael Randour", "authors": "St\\'ephane Le Roux, Arno Pauly, Mickael Randour", "title": "Extending finite-memory determinacy by Boolean combination of winning\n  conditions", "comments": "Conference version appeared in FSTTCS 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study finite-memory (FM) determinacy in games on finite graphs, a central\nquestion for applications in controller synthesis, as FM strategies correspond\nto implementable controllers. We establish general conditions under which FM\nstrategies suffice to play optimally, even in a broad multi-objective setting.\nWe show that our framework encompasses important classes of games from the\nliterature, and permits to go further, using a unified approach. While such an\napproach cannot match ad-hoc proofs with regard to tightness of memory bounds,\nit has two advantages: first, it gives a widely-applicable criterion for FM\ndeterminacy; second, it helps to understand the cornerstones of FM determinacy,\nwhich are often hidden but common in proofs for specific (combinations of)\nwinning conditions.\n", "versions": [{"version": "v1", "created": "Fri, 17 Aug 2018 08:25:42 GMT"}, {"version": "v2", "created": "Thu, 4 Oct 2018 18:26:00 GMT"}], "update_date": "2018-10-08", "authors_parsed": [["Roux", "St\u00e9phane Le", ""], ["Pauly", "Arno", ""], ["Randour", "Mickael", ""]]}, {"id": "1808.07826", "submitter": "Matthew Hammer", "authors": "Matthew A. Hammer, Jana Dunfield, Kyle Headley, Monal Narasimhamurthy,\n  Dimitrios J. Economou", "title": "Fungi: Typed incremental computation with names", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Incremental computations attempt to exploit input similarities over time,\nreusing work that is unaffected by input changes. To maximize this reuse in a\ngeneral-purpose programming setting, programmers need a mechanism to identify\ndynamic allocations (of data and subcomputations) that correspond over time. We\npresent Fungi, a typed functional language for incremental computation with\nnames. Unlike prior general-purpose languages for incremental computing,\nFungi's notion of names is formal, general, and statically verifiable. Fungi's\ntype-and-effect system permits the programmer to encode (program-specific)\nlocal invariants about names, and to use these invariants to establish global\nuniqueness for their composed programs, the property of using names correctly.\nWe prove that well-typed Fungi programs respect global uniqueness. We derive a\nbidirectional version of the type and effect system, and we have implemented a\nprototype of Fungi in Rust. We apply Fungi to a library of incremental\ncollections, showing that it is expressive in practice.\n", "versions": [{"version": "v1", "created": "Mon, 20 Aug 2018 15:55:24 GMT"}], "update_date": "2021-03-24", "authors_parsed": [["Hammer", "Matthew A.", ""], ["Dunfield", "Jana", ""], ["Headley", "Kyle", ""], ["Narasimhamurthy", "Monal", ""], ["Economou", "Dimitrios J.", ""]]}, {"id": "1808.07827", "submitter": "EPTCS", "authors": "Vincenzo Arceri (University of Verona, Department of Computer Science,\n  Verona, Italy), Isabella Mastroeni (University of Verona, Department of\n  Computer Science, Verona, Italy)", "title": "Static Program Analysis for String Manipulation Languages", "comments": "In Proceedings VPT 2019, arXiv:1908.06723", "journal-ref": "EPTCS 299, 2019, pp. 19-33", "doi": "10.4204/EPTCS.299.5", "report-no": null, "categories": "cs.PL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In recent years, dynamic languages, such as JavaScript or Python, have been\nincreasingly used in a wide range of fields and applications. Their tricky and\nmisunderstood behaviors pose a hard challenge for static analysis of these\nprogramming languages. A key aspect of any dynamic language program is the\nmultiple usage of strings, since they can be implicitly converted to another\ntype value, transformed by string-to-code primitives or used to access an\nobject-property. Unfortunately, string analyses for dynamic languages still\nlack precision and do not take into account some important string features.\nMoreover, string obfuscation is very popular in the context of dynamic language\nmalicious code, for example, to hide code information inside strings and then\nto dynamically transform strings into executable code. In this scenario, more\nprecise string analyses become a necessity. This paper is placed in the context\nof static string analysis by abstract interpretation and proposes a new\nsemantics for string analysis, placing a first step for handling dynamic\nlanguages string features.\n", "versions": [{"version": "v1", "created": "Fri, 17 Aug 2018 22:21:07 GMT"}, {"version": "v2", "created": "Tue, 20 Aug 2019 06:35:39 GMT"}], "update_date": "2019-08-21", "authors_parsed": [["Arceri", "Vincenzo", "", "University of Verona, Department of Computer Science,\n  Verona, Italy"], ["Mastroeni", "Isabella", "", "University of Verona, Department of\n  Computer Science, Verona, Italy"]]}, {"id": "1808.08217", "submitter": "Enric Cosme Ll\\'opez", "authors": "Juan Climent Vidal, Enric Cosme Ll\\'opez", "title": "Congruence based proofs of the recognizability theorems for free\n  many-sorted algebras", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We generalize several recognizability theorems for free single-sorted\nalgebras to the field of many-sorted algebras and provide, in a uniform way and\nwithout using neither regular tree grammars nor tree automata, purely algebraic\nproofs of them based on the concept of congruence.\n", "versions": [{"version": "v1", "created": "Fri, 24 Aug 2018 17:29:22 GMT"}], "update_date": "2018-08-27", "authors_parsed": [["Vidal", "Juan Climent", ""], ["Ll\u00f3pez", "Enric Cosme", ""]]}, {"id": "1808.08655", "submitter": "EPTCS", "authors": "Doriana Medic, Claudio Antares Mezzina, Iain Phillips, Nobuko Yoshida", "title": "A Parametric Framework for Reversible Pi-Calculi", "comments": "In Proceedings EXPRESS/SOS 2018, arXiv:1808.08071. A full version of\n  this paper, containing all proofs, appears as arXiv:1807.11800", "journal-ref": "EPTCS 276, 2018, pp. 87-103", "doi": "10.4204/EPTCS.276.8", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a study of causality in a reversible, concurrent setting.\nThere exist various notions of causality in pi-calculus, which differ in the\ntreatment of parallel extrusions of the same name. In this paper we present a\nuniform framework for reversible pi-calculi that is parametric with respect to\na data structure that stores information about an extrusion of a name.\nDifferent data structures yield different approaches to the parallel extrusion\nproblem. We map three well-known causal semantics into our framework. We show\nthat the (parametric) reversibility induced by our framework is\ncausally-consistent and prove a causal correspondence between an appropriate\ninstance of the framework and Boreale and Sangiorgi's causal semantics.\n", "versions": [{"version": "v1", "created": "Mon, 27 Aug 2018 01:29:36 GMT"}], "update_date": "2018-08-28", "authors_parsed": [["Medic", "Doriana", ""], ["Mezzina", "Claudio Antares", ""], ["Phillips", "Iain", ""], ["Yoshida", "Nobuko", ""]]}, {"id": "1808.08697", "submitter": "Ville Salo", "authors": "Ville Salo", "title": "Universal groups of cellular automata", "comments": "Major scientific revision: fixed serious problem in the universality\n  proof and solved the main questions + many smaller improvements. Comments\n  welcome!", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the group of reversible cellular automata (RCA), on any\nalphabet $A$, contains a perfect subgroup generated by six involutions which\ncontains an isomorphic copy of every finitely-generated group of RCA on any\nalphabet $B$. This result follows from a case study of groups of RCA generated\nby symbol permutations and partial shifts with respect to a fixed Cartesian\nproduct decomposition of the alphabet. For prime alphabets, we show that this\ngroup is virtually cyclic, and that for composite alphabets it is non-amenable.\nFor alphabet size four, it is a linear group. For non-prime non-four alphabets,\nit contains copies of all finitely-generated groups of RCA. We also obtain that\nRCA of biradius one on all large enough alphabets generate copies of all\nfinitely-generated groups of RCA. We ask a long list of questions.\n", "versions": [{"version": "v1", "created": "Mon, 27 Aug 2018 06:05:19 GMT"}, {"version": "v2", "created": "Fri, 9 Nov 2018 08:37:22 GMT"}], "update_date": "2018-11-12", "authors_parsed": [["Salo", "Ville", ""]]}, {"id": "1808.08893", "submitter": "Aaron Moss", "authors": "Aaron Moss", "title": "Simplified Parsing Expression Derivatives", "comments": "14 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a new derivative parsing algorithm for parsing expression\ngrammars; this new algorithm is both simpler and faster than the existing\nparsing expression derivative algorithm presented by Moss. This new algorithm\nimproves on the worst-case space and runtime bounds of the previous algorithm\nby a linear factor, as well as decreasing runtime by about half in practice. A\nproof of correctness for the new algorithm is included in this paper, a result\nnot present in earlier work.\n", "versions": [{"version": "v1", "created": "Mon, 27 Aug 2018 15:47:11 GMT"}], "update_date": "2018-08-28", "authors_parsed": [["Moss", "Aaron", ""]]}, {"id": "1808.09028", "submitter": "Alexander Weinert", "authors": "Daniel Neider and Alexander Weinert and Martin Zimmermann", "title": "Robust, Expressive, and Quantitative Linear Temporal Logics: Pick any\n  Two for Free (full version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linear Temporal Logic (LTL) is the standard specification language for\nreactive systems and is successfully applied in industrial settings. However,\nmany shortcomings of LTL have been identified in the literature, among them the\nlimited expressiveness, the lack of quantitative features, and the inability to\nexpress robustness. There is work on overcoming these shortcomings, but each of\nthese is typically addressed in isolation. This is insufficient for\napplications where all shortcomings manifest themselves simultaneously.\n  Here, we tackle this issue by introducing logics that address more than one\nshortcoming. To this end, we combine the logics Linear Dynamic Logic,\nPrompt-LTL, and robust LTL, each addressing one aspect, to new logics. For all\ncombinations of two aspects, the resulting logic has the same desirable\nalgorithmic properties as plain LTL. In particular, the highly efficient\nalgorithmic backends that have been developed for LTL are also applicable to\nthese new logics. Finally, we discuss how to address all three aspects\nsimultaneously.\n", "versions": [{"version": "v1", "created": "Mon, 27 Aug 2018 20:30:42 GMT"}, {"version": "v2", "created": "Mon, 20 May 2019 08:34:22 GMT"}, {"version": "v3", "created": "Tue, 21 May 2019 08:22:33 GMT"}, {"version": "v4", "created": "Sun, 14 Jul 2019 09:16:05 GMT"}, {"version": "v5", "created": "Fri, 19 Jul 2019 20:18:51 GMT"}, {"version": "v6", "created": "Fri, 20 Sep 2019 09:49:57 GMT"}, {"version": "v7", "created": "Thu, 29 Apr 2021 09:21:24 GMT"}], "update_date": "2021-04-30", "authors_parsed": [["Neider", "Daniel", ""], ["Weinert", "Alexander", ""], ["Zimmermann", "Martin", ""]]}, {"id": "1808.10240", "submitter": "Loic Pauleve", "authors": "Thomas Chatain (MEXICO), Stefan Haar (MEXICO), Juraj Kol{\\v{c}}\\'ak\n  (LSV), Lo\\\"ic Paulev\\'e (LaBRI, BioInfo - LRI)", "title": "Most Permissive Semantics of Boolean Networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO q-bio.QM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As shown in (http://dx.doi.org/10.1101/2020.03.22.998377), the usual update\nmodes of Boolean networks (BNs), including synchronous and (generalized)\nasynchronous, fail to capture behaviors introduced by multivalued refinements.\nThus, update modes do not allow a correct abstract reasoning on dynamics of\nbiological systems, as they may lead to reject valid BN models.This technical\nreport lists the main definitions and properties of the most permissive\nsemantics of BNs introduced in http://dx.doi.org/10.1101/2020.03.22.998377.\nThis semantics meets with a correct abstraction of any multivalued refinements,\nwith any update mode. It subsumes all the usual updating modes, while enabling\nnew behaviors achievable by more concrete models. Moreover, it appears that\nclassical dynamical analyzes of reachability and attractors have a simpler\ncomputational complexity:- reachability can be assessed in a polynomial number\nof iterations. The computation of iterations is in NP in the very general case,\nand is linear when local functions are monotonic, or with some usual\nrepresentations of functions of BNs (binary decision diagrams, Petri nets,\nautomata networks, etc.). Thus, reachability is in P with locally-monotonic\nBNs, and P$^{\\text{NP}}$ otherwise (instead of being PSPACE-complete with\nupdate modes);- deciding wherever a configuration belongs to an attractor is in\ncoNP with locally-monotonic BNs, and coNP$^{\\text{coNP}}$ otherwise (instead of\nPSPACE-complete with update modes).Furthermore, we demonstrate that the\nsemantics completely captures any behavior achievable with any multilevel or\nODE refinement of the BN; and the semantics is minimal with respect to this\nmodel refinement criteria: to any most permissive trajectory, there exists a\nmultilevel refinement of the BN which can reproduce it.In brief, the most\npermissive semantics of BNs enables a correct abstract reasoning on dynamics of\nBNs, with a greater tractability than previously introduced update modes.\n", "versions": [{"version": "v1", "created": "Thu, 30 Aug 2018 11:49:31 GMT"}, {"version": "v2", "created": "Wed, 8 Apr 2020 08:12:21 GMT"}], "update_date": "2020-04-09", "authors_parsed": [["Chatain", "Thomas", "", "MEXICO"], ["Haar", "Stefan", "", "MEXICO"], ["Kol{\u010d}\u00e1k", "Juraj", "", "LSV"], ["Paulev\u00e9", "Lo\u00efc", "", "LaBRI, BioInfo - LRI"]]}, {"id": "1808.10717", "submitter": "Malte Schmitz", "authors": "Lukas Convent and Sebastian Hungerecker and Martin Leucker and Torben\n  Scheffel and Malte Schmitz and Daniel Thoma", "title": "TeSSLa: Temporal Stream-based Specification Language", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Runtime verification is concerned with monitoring program traces. In\nparticular, stream runtime verification (SRV) takes the program trace as input\nstreams and incrementally derives output streams. SRV can check logical\nproperties and compute temporal metrics and statistics from the trace. We\npresent TeSSLa, a temporal stream-based specification language for SRV. TeSSLa\nsupports timestamped events natively and is hence suitable for streams that are\nboth sparse and fine-grained, which often occur in practice. We prove results\non TeSSLa's expressiveness and compare different TeSSLa fragments to (timed)\nautomata, thereby inheriting various decidability results. Finally, we present\na monitor implementation and prove its correctness.\n", "versions": [{"version": "v1", "created": "Fri, 31 Aug 2018 12:59:50 GMT"}], "update_date": "2018-09-03", "authors_parsed": [["Convent", "Lukas", ""], ["Hungerecker", "Sebastian", ""], ["Leucker", "Martin", ""], ["Scheffel", "Torben", ""], ["Schmitz", "Malte", ""], ["Thoma", "Daniel", ""]]}]