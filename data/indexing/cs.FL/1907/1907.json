[{"id": "1907.00298", "submitter": "Adithya Murali", "authors": "Umang Mathur, Adithya Murali, Paul Krogmeier, P. Madhusudan, Mahesh\n  Viswanathan", "title": "Deciding Memory Safety for Single-Pass Heap-Manipulating Programs", "comments": "StreamVerif tool for automata-based verification of uninterpreted\n  programs can be found at https://github.com/umangm/streamverif", "journal-ref": "Proceedings of the ACM on Programming Languages Vol. 4, Issue\n  POPL, Article 35 (December 2019)", "doi": "10.1145/3371103", "report-no": null, "categories": "cs.PL cs.FL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the decidability of automatic program verification for\nprograms that manipulate heaps, and in particular, decision procedures for\nproving memory safety for them. We extend recent work that identified a\ndecidable subclass of uninterpreted programs to a class of alias-aware programs\nthat can update maps. We apply this theory to develop verification algorithms\nfor memory safety--- determining if a heap-manipulating program that allocates\nand frees memory locations and manipulates heap pointers does not dereference\nan unallocated memory location. We show that this problem is decidable when the\ninitial allocated heap forms a forest data-structure and when programs are\nstreaming-coherent, which intuitively restricts programs to make a single pass\nover a data-structure. Our experimental evaluation on a set of library routines\nthat manipulate forest data-structures shows that common single-pass algorithms\non data-structures often fall in the decidable class, and that our decision\nprocedure is efficient in verifying them.\n", "versions": [{"version": "v1", "created": "Sat, 29 Jun 2019 23:53:22 GMT"}, {"version": "v2", "created": "Tue, 31 Dec 2019 12:34:38 GMT"}], "update_date": "2020-01-01", "authors_parsed": [["Mathur", "Umang", ""], ["Murali", "Adithya", ""], ["Krogmeier", "Paul", ""], ["Madhusudan", "P.", ""], ["Viswanathan", "Mahesh", ""]]}, {"id": "1907.00467", "submitter": "L\\^e Th\\`anh D\\~ung Nguy\\^en", "authors": "L\\^e Th\\`anh D\\~ung Nguy\\^en", "title": "Typed lambda-calculi and superclasses of regular functions", "comments": "23 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We propose to use Church encodings in typed lambda-calculi as the basis for\nan automata-theoretic counterpart of implicit computational complexity, in the\nsame way that monadic second-order logic provides a counterpart to descriptive\ncomplexity. Specifically, we look at transductions i.e. string-to-string (or\ntree-to-tree) functions - in particular those with superlinear growth, such as\npolyregular functions, HDT0L transductions and S\\'enizergues's \"k-computable\nmappings\".\n  Our first results towards this aim consist showing the inclusion of some\ntransduction classes in some classes defined by lambda-calculi. In particular,\nthis sheds light on a basic open question on the expressivity of the simply\ntyped lambda-calculus. We also encode regular functions (and, by changing the\ntype of programs considered, we get a larger subclass of polyregular functions)\nin the elementary affine lambda-calculus, a variant of linear logic originally\ndesigned for implicit computational complexity.\n", "versions": [{"version": "v1", "created": "Sun, 30 Jun 2019 21:24:59 GMT"}], "update_date": "2019-07-02", "authors_parsed": [["Nguy\u00ean", "L\u00ea Th\u00e0nh D\u0169ng", ""]]}, {"id": "1907.01076", "submitter": "Florian Zuleger", "authors": "Florian Zuleger", "title": "The Polynomial Complexity of Vector Addition Systems with States", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Vector addition systems are an important model in theoretical computer\nscience and have been used in a variety of areas. In this paper, we consider\nvector addition systems with states over a parameterized initial configuration.\nFor these systems, we are interested in the standard notion of computational\ncomplexity, i.e., we want to understand the length of the longest trace for a\nfixed vector addition system with states depending on the size of the initial\nconfiguration. We show that the asymptotic complexity of a given vector\naddition system with states is either $\\Theta(N^k)$ for some computable integer\n$k$, where $N$ is the size of the initial configuration, or at least\nexponential. We further show that $k$ can be computed in polynomial time in the\nsize of the considered vector addition system. Finally, we show that $1 \\le k\n\\le 2^n$, where $n$ is the dimension of the considered vector addition system.\n", "versions": [{"version": "v1", "created": "Mon, 1 Jul 2019 21:09:19 GMT"}, {"version": "v2", "created": "Fri, 25 Oct 2019 15:00:00 GMT"}, {"version": "v3", "created": "Sat, 14 Mar 2020 19:34:26 GMT"}], "update_date": "2020-03-17", "authors_parsed": [["Zuleger", "Florian", ""]]}, {"id": "1907.01168", "submitter": "Ramchandra Phawade", "authors": "Ramchandra Phawade", "title": "Kleene Theorems for Free Choice Nets Labelled with Distributed Alphabets", "comments": "32 pages, A preliminary version of this paper appeared at 14th PNSE\n  workshop, held at Bratislava (2018)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provided (PNSE'2014) expressions for free choice nets having \"distributed\nchoice property\" which makes the nets \"direct product\" representable.\n  In a recent work (PNSE'2016), we gave equivalent syntax for a larger class of\nfree choice nets obtained by dropping distributed choice property.\n  In both these works, the classes of free choice nets were restricted by a\n\"product condition\" on the set of final markings. In this paper we do away with\nthis restriction and give expressions for the resultant classes of nets which\ncorrespond to \"free choice synchronous products and Zielonka automata\". For\nfree choice nets with distributed choice property, we give an alternative\ncharacterization using properties checkable in polynomial time.\n  Free choice nets we consider are 1-bounded, S-coverable, and are labelled\nwith distributed alphabets, where S-components of the associated S-cover\nrespect the given alphabet distribution.\n", "versions": [{"version": "v1", "created": "Tue, 2 Jul 2019 05:04:00 GMT"}], "update_date": "2019-07-03", "authors_parsed": [["Phawade", "Ramchandra", ""]]}, {"id": "1907.01214", "submitter": "Paul Gastin", "authors": "Paul Gastin and Amaldev Manuel and R. Govind", "title": "Logics for Reversible Regular Languages and Semigroups with Involution", "comments": "Accepted for DLT 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present MSO and FO logics with predicates `between' and `neighbour' that\ncharacterise various fragments of the class of regular languages that are\nclosed under the reverse operation. The standard connections that exist between\nMSO and FO logics and varieties of finite semigroups extend to this setting\nwith semigroups extended with an involution. The case is different for FO with\nneighbour relation where we show that one needs additional equations to\ncharacterise the class.\n", "versions": [{"version": "v1", "created": "Tue, 2 Jul 2019 07:54:10 GMT"}], "update_date": "2019-07-03", "authors_parsed": [["Gastin", "Paul", ""], ["Manuel", "Amaldev", ""], ["Govind", "R.", ""]]}, {"id": "1907.01240", "submitter": "Patrick Totzke", "authors": "Lorenzo Clemente and Piotr Hofman and Patrick Totzke", "title": "Timed Basic Parallel Processes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Timed basic parallel processes (TBPP) extend communication-free Petri nets\n(aka. BPP or commutative context-free grammars) by a global notion of time.\nTBPP can be seen as an extension of timed automata (TA) with context-free\nbranching rules, and as such may be used to model networks of independent timed\nautomata with process creation.\n  We show that the coverability and reachability problems (with unary encoded\ntarget multiplicities) are PSPACE-complete and EXPTIME-complete, respectively.\nFor the special case of 1-clock TBPP, both are NP-complete and hence not more\ncomplex than for untimed BPP. This contrasts with known\nsuper-Ackermannian-completeness and undecidability results for general timed\nPetri nets.\n  As a result of independent interest, and basis for our NP upper bounds, we\nshow that the reachability relation of 1-clock TA can be expressed by a formula\nof polynomial size in the existential fragment of linear arithmetic, which\nimproves on recent results from the literature.\n", "versions": [{"version": "v1", "created": "Tue, 2 Jul 2019 08:52:36 GMT"}, {"version": "v2", "created": "Mon, 8 Jul 2019 10:20:40 GMT"}], "update_date": "2019-07-09", "authors_parsed": [["Clemente", "Lorenzo", ""], ["Hofman", "Piotr", ""], ["Totzke", "Patrick", ""]]}, {"id": "1907.01464", "submitter": "Jacques Sakarovitch", "authors": "Val\\'erie Berth\\'e, Christiane Frougny, Michel Rigo and Jacques\n  Sakarovitch", "title": "The carry propagation of the successor function", "comments": "55 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given any numeration system, we call carry propagation at a number $N$ the\nnumber of digits that are changed when going from the representation of $N$ to\nthe one of $N+1$, and amortized carry propagation the limit of the mean of the\ncarry propagations at the first $N$ integers, when $N$ tends to infinity, if\nthis limit exists.\n  In the case of the usual base $p$ numeration system, it can be shown that the\nlimit indeed exists and is equal to $p/(p-1)$. We recover a similar value for\nthose numeration systems we consider and for which the limit exists.\n  We address the problem of the existence of the amortized carry propagation in\nnon-standard numeration systems of various kinds: abstract numeration systems,\nrational base numeration systems, greedy numeration systems and\nbeta-numeration. We tackle the problem by three different types of techniques:\ncombinatorial, algebraic, and ergodic. For each kind of numeration systems that\nwe consider, the relevant method allows for establishing sufficient conditions\nfor the existence of the carry propagation and examples show that these\nconditions are close to being necessary conditions.\n", "versions": [{"version": "v1", "created": "Tue, 2 Jul 2019 15:49:12 GMT"}, {"version": "v2", "created": "Wed, 29 Apr 2020 16:57:49 GMT"}], "update_date": "2020-04-30", "authors_parsed": [["Berth\u00e9", "Val\u00e9rie", ""], ["Frougny", "Christiane", ""], ["Rigo", "Michel", ""], ["Sakarovitch", "Jacques", ""]]}, {"id": "1907.01471", "submitter": "Paul Bell", "authors": "Paul C. Bell and Mika Hirvensalo", "title": "On Injectivity of Quantum Finite Automata", "comments": "Accepted journal version (with change of name from Acceptance\n  Ambiguity for Quantum Automata)", "journal-ref": null, "doi": "10.1016/j.jcss.2021.05.002", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We consider notions of freeness and ambiguity for the acceptance probability\nof Moore-Crutchfield Measure Once Quantum Finite Automata (MO-QFA). We study\nthe injectivity problem of determining if the acceptance probability function\nof a MO-QFA is injective over all input words, i.e., giving a distinct\nprobability for each input word. We show that the injectivity problem is\nundecidable for 8 state MO-QFA, even when all unitary matrices and the\nprojection matrix are rational and the initial state vector is real algebraic.\nWe also show undecidability of this problem when the initial vector is\nrational, although with a huge increase in the number of states. We utilize\nproperties of quaternions, free rotation groups, representations of tuples of\nrationals as linear sums of radicals and a reduction of the mixed modification\nof Post's correspondence problem, as well as a new result on rational\npolynomial packing functions which may be of independent interest.\n", "versions": [{"version": "v1", "created": "Tue, 2 Jul 2019 16:01:46 GMT"}, {"version": "v2", "created": "Wed, 30 Jun 2021 15:54:13 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Bell", "Paul C.", ""], ["Hirvensalo", "Mika", ""]]}, {"id": "1907.01721", "submitter": "\\'Etienne Andr\\'e", "authors": "\\'Etienne Andr\\'e", "title": "What's decidable about parametric timed automata?", "comments": "This is the author version of the manuscript of the same name\n  published in the International Journal on Software Tools for Technology\n  Transfer (STTT), April 2019, Volume 21, Issue 2, pp 203-219. This work is\n  partially supported by the ANR national research program PACS\n  (ANR-14-CE28-0002)", "journal-ref": "International Journal on Software Tools for Technology Transfer\n  (STTT), April 2019, Volume 21, Issue 2, pp 203-219", "doi": "10.1007/s10009-017-0467-0", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parametric timed automata (PTAs) are a powerful formalism to reason, simulate\nand formally verify critical real-time systems. After 25 years of research on\nPTAs, it is now well-understood that any non-trivial problem studied is\nundecidable for general PTAs. We provide here a survey of decision and\ncomputation problems for PTAs. On the one hand, bounding time, bounding the\nnumber of parameters or the domain of the parameters does not (in general) lead\nto any decidability. On the other hand, restricting the number of clocks, the\nuse of clocks (compared or not with the parameters), and the use of parameters\n(e.g. used only as upper or lower bounds) leads to decidability of some\nproblems. We also put emphasis on open problems. We also discuss formalisms\nclose to parametric timed automata (such as parametric hybrid automata or\nparametric interrupt timed automata), and we study tools dedicated to PTAs and\ntheir extensions.\n", "versions": [{"version": "v1", "created": "Wed, 3 Jul 2019 03:26:33 GMT"}], "update_date": "2019-07-04", "authors_parsed": [["Andr\u00e9", "\u00c9tienne", ""]]}, {"id": "1907.01768", "submitter": "Giorgio Bacci", "authors": "Giorgio Bacci and Giovanni Bacci and Kim G. Larsen and Radu Mardare\n  and Qiyi Tang and Franck van Breugel", "title": "Computing Probabilistic Bisimilarity Distances for Probabilistic\n  Automata", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 17, Issue 1 (February\n  2, 2021) lmcs:7147", "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The probabilistic bisimilarity distance of Deng et al. has been proposed as a\nrobust quantitative generalization of Segala and Lynch's probabilistic\nbisimilarity for probabilistic automata. In this paper, we present a\ncharacterization of the bisimilarity distance as the solution of a simple\nstochastic game. The characterization gives us an algorithm to compute the\ndistances by applying Condon's simple policy iteration on these games. The\ncorrectness of Condon's approach, however, relies on the assumption that the\ngames are stopping. Our games may be non-stopping in general, yet we are able\nto prove termination for this extended class of games. Already other algorithms\nhave been proposed in the literature to compute these distances, with\ncomplexity in $\\textbf{UP} \\cap \\textbf{coUP}$ and \\textbf{PPAD}. Despite the\ntheoretical relevance, these algorithms are inefficient in practice. To the\nbest of our knowledge, our algorithm is the first practical solution.\n  The characterization of the probabilistic bisimilarity distance mentioned\nabove crucially uses a dual presentation of the Hausdorff distance due to\nM\\'emoli. As an additional contribution, in this paper we show that M\\'emoli's\nresult can be used also to prove that the bisimilarity distance bounds the\ndifference in the maximal (or minimal) probability of two states to satisfying\narbitrary $\\omega$-regular properties, expressed, eg., as LTL formulas.\n", "versions": [{"version": "v1", "created": "Wed, 3 Jul 2019 07:04:26 GMT"}, {"version": "v2", "created": "Thu, 4 Jul 2019 08:48:03 GMT"}, {"version": "v3", "created": "Wed, 18 Dec 2019 17:06:09 GMT"}, {"version": "v4", "created": "Thu, 19 Dec 2019 06:48:30 GMT"}, {"version": "v5", "created": "Wed, 27 May 2020 10:06:32 GMT"}, {"version": "v6", "created": "Mon, 14 Sep 2020 12:46:36 GMT"}, {"version": "v7", "created": "Mon, 21 Sep 2020 07:49:59 GMT"}, {"version": "v8", "created": "Mon, 1 Feb 2021 14:27:26 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Bacci", "Giorgio", ""], ["Bacci", "Giovanni", ""], ["Larsen", "Kim G.", ""], ["Mardare", "Radu", ""], ["Tang", "Qiyi", ""], ["van Breugel", "Franck", ""]]}, {"id": "1907.02296", "submitter": "B Srivathsan", "authors": "R. Govind, Fr\\'ed\\'eric Herbreteau, B. Srivathsan, Igor Walukiewicz", "title": "Revisiting local time semantics for networks of timed automata", "comments": "A shorter version appears in proceedings of CONCUR 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We investigate a zone based approach for the reachability problem in timed\nautomata. The challenge is to alleviate the size explosion of the search space\nwhen considering networks of timed automata working in parallel. In the timed\nsetting this explosion is particularly visible as even different interleavings\nof local actions of processes may lead to different zones. Salah et al. in 2006\nhave shown that the union of all these different zones is also a zone. This\nobservation was used in an algorithm which from time to time detects and\naggregates these zones into a single zone.\n  We show that such aggregated zones can be calculated more efficiently using\nthe local time semantics and the related notion of local zones proposed by\nBengtsson et al. in 1998. Next, we point out a flaw in the existing method to\nensure termination of the local zone graph computation. We fix this with a new\nalgorithm that builds the local zone graph and uses abstraction techniques over\n(standard) zones for termination. We evaluate our algorithm on standard\nexamples. On various examples, we observe an order of magnitude decrease in the\nsearch space. On the other examples, the algorithm performs like the standard\nzone algorithm.\n", "versions": [{"version": "v1", "created": "Thu, 4 Jul 2019 09:37:59 GMT"}], "update_date": "2019-07-05", "authors_parsed": [["Govind", "R.", ""], ["Herbreteau", "Fr\u00e9d\u00e9ric", ""], ["Srivathsan", "B.", ""], ["Walukiewicz", "Igor", ""]]}, {"id": "1907.02834", "submitter": "Adrien Pommellet", "authors": "Adrien Pommellet and Tayssir Touili", "title": "Static Analysis of Multithreaded Recursive Programs Communicating via\n  Rendez-vous", "comments": "Full, corrected version of a paper first presented at APLAS'17", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present in this paper a generic framework for the analysis of\nmulti-threaded programs with recursive procedure calls, synchronisation by\nrendez-vous between parallel threads, and dynamic creation of new threads. To\nthis end, we consider a model called Synchronized Dynamic Pushdown Networks\n(SDPNs) that can be seen as a network of pushdown processes executing\nsynchronized transitions, spawning new pushdown processes, and performing\ninternal pushdown actions. The reachability problem for this model is\nunfortunately undecidable. Therefore, we tackle this problem by introducing an\nabstraction framework based on Kleene algebras in order to compute an\nabstraction of the execution paths between two regular sets of configurations.\nWe combine an automata theoretic saturation procedure with constraint solving\nin a finite domain. We then apply this framework to an iterative abstraction\nrefinement scheme, using multiple abstractions of increasing complexity and\nprecision.\n", "versions": [{"version": "v1", "created": "Fri, 5 Jul 2019 13:57:55 GMT"}], "update_date": "2019-07-08", "authors_parsed": [["Pommellet", "Adrien", ""], ["Touili", "Tayssir", ""]]}, {"id": "1907.02887", "submitter": "David M\\\"uller", "authors": "Simon Jantsch and David M\\\"uller and Christel Baier and Joachim Klein", "title": "From LTL to Unambiguous B\\\"uchi Automata via Disambiguation of\n  Alternating Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  This paper proposes a new algorithm for the generation of unambiguous B\\\"uchi\nautomata (UBA) from LTL formulas. Unlike existing tableau-based LTL-to-UBA\ntranslations, our algorithm deals with very weak alternating automata (VWAA) as\nan intermediate representation. It relies on a new notion of unambiguity for\nVWAA and a disambiguation procedure for VWAA. We introduce optimizations on the\nVWAA level and new LTL simplifications targeted at generating small UBA.\n  We report on an implementation of the construction in our tool duggi and\ndiscuss experimental results that compare the automata sizes and computation\ntimes of duggi with the tableau-based LTL-to-UBA translation of the SPOT tool\nset. Our experiments also cover the analysis of Markov chains under LTL\nspecifications, which is an important application of UBA.\n", "versions": [{"version": "v1", "created": "Fri, 5 Jul 2019 15:16:57 GMT"}], "update_date": "2019-07-08", "authors_parsed": [["Jantsch", "Simon", ""], ["M\u00fcller", "David", ""], ["Baier", "Christel", ""], ["Klein", "Joachim", ""]]}, {"id": "1907.02916", "submitter": "Tomoyuki Yamakami", "authors": "Tomoyuki Yamakami", "title": "Nonuniform Families of Polynomial-Size Quantum Finite Automata and\n  Quantum Logarithmic-Space Computation with Polynomial-Size Advice", "comments": "(10pt, A4, pp.32, 1 figure) This current version corrects and extends\n  the preliminary version that appeared in the Proceedings of the 13th\n  International Conference on Language and Automata Theory and Applications\n  (LATA 2019), Saint Petersburg, Russia, March 26-29, 2019, Lecture Notes in\n  Computer Science, Springer, vol. 11417, pp. 134-145, 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The state complexity of a finite(-state) automaton intuitively measures the\nsize of the description of the automaton. Sakoda and Sipser [STOC 1972, pp.\n275--286] were concerned with nonuniform families of finite automata and they\ndiscussed the behaviors of the nonuniform complexity classes defined by such\nfamilies of finite automata having polynomial-size state complexity. In a\nsimilar fashion, we introduce nonuniform state complexity classes using\nnonuniform families of quantum finite automata empowered by the flexible use of\ngarbage tapes. We first present general inclusion and separation relationships\namong nonuniform state complexity classes of various one-way finite automata,\nincluding deterministic, nondeterministic, probabilistic, and quantum finite\nautomata having polynomially many inner states. For two-way quantum finite\nautomata equipped with flexible garbage tapes, we show a close relationship\nbetween the nonuniform state complexity of the family of such polynomial-size\nquantum finite automata and the parameterized complexity class induced by\nlogarithmic-space quantum computation assisted by polynomial-size advice. We\nfurther establish a direct connection between space-bounded quantum computation\nwith quantum advice and quantum finite automata whose transitions are dictated\nby superpositions of transition tables.\n", "versions": [{"version": "v1", "created": "Fri, 5 Jul 2019 16:30:12 GMT"}, {"version": "v2", "created": "Sun, 12 Apr 2020 09:31:29 GMT"}, {"version": "v3", "created": "Sun, 29 Nov 2020 10:16:52 GMT"}, {"version": "v4", "created": "Fri, 16 Apr 2021 13:52:46 GMT"}], "update_date": "2021-04-19", "authors_parsed": [["Yamakami", "Tomoyuki", ""]]}, {"id": "1907.03285", "submitter": "Konstantin Chukharev", "authors": "Konstantin Chukharev and Daniil Chivilikhin", "title": "fbSAT: Automatic Inference of Minimal Finite-State Models of Function\n  Blocks Using SAT Solver", "comments": "21 pages (16 paper, 2 refs, 3 appendix); 9 figures; submitted without\n  an appendix to TAP 2020. Keywords: SAT, Finite-state automata, LTL, Model\n  checking, Counterexample-guided inductive synthesis, Function blocks, IEC\n  61499", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Finite-state models are widely used in software engineering, especially in\ncontrol systems development. Commonly, in control applications such models are\ndeveloped manually, hence, keeping them up-to-date requires extra effort. To\nsimplify the maintenance process, an automatic approach may be used, allowing\nto infer models from behavior examples and temporal properties. As an example\nof a specific control systems development application we focus on inferring\nfinite-state models of function blocks (FBs) defined by the IEC 61499\ninternational standard for distributed automation systems. In this paper we\npropose a method for FB model inference from behavior examples based on\nreduction to Boolean satisfiability problem (SAT). Additionally, we take into\naccount linear temporal properties using counterexample-guided synthesis. We\nalso present the developed tool fbSAT which implements the proposed method, and\nevaluate it in two case studies: inference of a finite-state model of a\nPick-and-Place manipulator, and reconstruction of randomly generated automata.\nIn contrast to existing approaches, the suggested method is more efficient and\nproduces finite-state models minimal both in terms of number of states and\nguard conditions complexity.\n", "versions": [{"version": "v1", "created": "Sun, 7 Jul 2019 13:34:31 GMT"}, {"version": "v2", "created": "Fri, 25 Oct 2019 00:30:40 GMT"}, {"version": "v3", "created": "Tue, 4 Feb 2020 11:22:06 GMT"}], "update_date": "2020-02-05", "authors_parsed": [["Chukharev", "Konstantin", ""], ["Chivilikhin", "Daniil", ""]]}, {"id": "1907.04036", "submitter": "Luca Reggio", "authors": "Mai Gehrke, Tom\\'a\\v{s} Jakl and Luca Reggio", "title": "A duality theoretic view on limits of finite structures", "comments": "19 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A systematic theory of structural limits for finite models has been developed\nby Nesetril and Ossona de Mendez. It is based on the insight that the\ncollection of finite structures can be embedded, via a map they call the Stone\npairing, in a space of measures, where the desired limits can be computed. We\nshow that a closely related but finer grained space of measures arises --- via\nStone-Priestley duality and the notion of types from model theory --- by\nenriching the expressive power of first-order logic with certain\n``probabilistic operators''. We provide a sound and complete calculus for this\nextended logic and expose the functorial nature of this construction.\n  The consequences are two-fold. On the one hand, we identify the logical gist\nof the theory of structural limits. On the other hand, our construction shows\nthat the duality-theoretic variant of the Stone pairing captures the adding of\na layer of quantifiers, thus making a strong link to recent work on semiring\nquantifiers in logic on words. In the process, we identify the model theoretic\nnotion of types as the unifying concept behind this link. These results\ncontribute to bridging the strands of logic in computer science which focus on\nsemantics and on more algorithmic and complexity related areas, respectively.\n", "versions": [{"version": "v1", "created": "Tue, 9 Jul 2019 08:10:37 GMT"}, {"version": "v2", "created": "Sat, 10 Aug 2019 08:37:57 GMT"}, {"version": "v3", "created": "Tue, 7 Jan 2020 16:20:37 GMT"}], "update_date": "2020-01-08", "authors_parsed": [["Gehrke", "Mai", ""], ["Jakl", "Tom\u00e1\u0161", ""], ["Reggio", "Luca", ""]]}, {"id": "1907.04660", "submitter": "Marinella Sciortino", "authors": "Sabrina Mantaci and Antonio Restivo and Giuseppe Romana and Giovanna\n  Rosone and Marinella Sciortino", "title": "String Attractors and Combinatorics on Words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The notion of \\emph{string attractor} has recently been introduced in\n[Prezza, 2017] and studied in [Kempa and Prezza, 2018] to provide a unifying\nframework for known dictionary-based compressors. A string attractor for a word\n$w=w[1]w[2]\\cdots w[n]$ is a subset $\\Gamma$ of the positions $\\{1,\\ldots,n\\}$,\nsuch that all distinct factors of $w$ have an occurrence crossing at least one\nof the elements of $\\Gamma$. While finding the smallest string attractor for a\nword is a NP-complete problem, it has been proved in [Kempa and Prezza, 2018]\nthat dictionary compressors can be interpreted as algorithms approximating the\nsmallest string attractor for a given word.\n  In this paper we explore the notion of string attractor from a combinatorial\npoint of view, by focusing on several families of finite words. The results\npresented in the paper suggest that the notion of string attractor can be used\nto define new tools to investigate combinatorial properties of the words.\n", "versions": [{"version": "v1", "created": "Wed, 10 Jul 2019 12:21:12 GMT"}], "update_date": "2019-07-11", "authors_parsed": [["Mantaci", "Sabrina", ""], ["Restivo", "Antonio", ""], ["Romana", "Giuseppe", ""], ["Rosone", "Giovanna", ""], ["Sciortino", "Marinella", ""]]}, {"id": "1907.05070", "submitter": "Corto Mascle", "authors": "Corto Mascle and Martin Zimmermann", "title": "The Keys to Decidable HyperLTL Satisfiability: Small Models or Very\n  Simple Formulas", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  HyperLTL, the extension of Linear Temporal Logic by trace quantifiers, is a\nuniform framework for expressing information flow policies by relating multiple\ntraces of a security-critical system. HyperLTL has been successfully applied to\nexpress fundamental security policies like noninterference and observational\ndeterminism, but has also found applications beyond security, e.g., distributed\nprotocols and coding theory. However, HyperLTL satisfiability is undecidable as\nsoon as there are existential quantifiers in the scope of a universal one. To\novercome this severe limitation to applicability, we investigate here\nrestricted variants of the satisfiability problem to pinpoint the decidability\nborder.\n  First, we restrict the space of admissible models and show decidability when\nrestricting the search space to models of bounded size or to finitely\nrepresentable ones. Second, we consider formulas with restricted nesting of\ntemporal operators and show that nesting depth one yields decidability for a\nslightly larger class of quantifier prefixes. We provide tight complexity\nbounds in almost all cases.\n", "versions": [{"version": "v1", "created": "Thu, 11 Jul 2019 09:22:58 GMT"}, {"version": "v2", "created": "Mon, 4 Nov 2019 16:20:24 GMT"}, {"version": "v3", "created": "Fri, 13 Dec 2019 22:23:41 GMT"}], "update_date": "2019-12-17", "authors_parsed": [["Mascle", "Corto", ""], ["Zimmermann", "Martin", ""]]}, {"id": "1907.05128", "submitter": "St\\'ephane Le Roux", "authors": "St\\'ephane Le Roux", "title": "Time-aware uniformization of winning strategies", "comments": "23 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two-player win/lose games of infinite duration are involved in several\ndisciplines including computer science and logic. If such a game has\ndeterministic winning strategies, one may ask how simple such strategies can\nget. The answer may help with actual implementation, or to win despite\nimperfect information, or to conceal sensitive information especially if the\ngame is repeated. Given a concurrent two-player win/lose game of infinite\nduration, this article considers equivalence relations over histories of played\nactions. A classical restriction used here is that equivalent histories have\nequal length, hence \\emph{time awareness}. A sufficient condition is given such\nthat if a player has winning strategies, she has one that prescribes the same\naction at equivalent histories, hence \\emph{uniformization}. The proof is\nfairly constructive and preserves finiteness of strategy memory, and\ncounterexamples show relative tightness of the result. Several corollaries\nfollow for games with states and colors.\n", "versions": [{"version": "v1", "created": "Thu, 11 Jul 2019 11:58:22 GMT"}, {"version": "v2", "created": "Mon, 3 Feb 2020 17:53:46 GMT"}], "update_date": "2020-02-04", "authors_parsed": [["Roux", "St\u00e9phane Le", ""]]}, {"id": "1907.05368", "submitter": "Rita Gitik", "authors": "Rita Gitik and Eliyahy Rips", "title": "On The Structure of Dyck Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the closure of the one-sided Dyck language in a free monoid is\na two-sided Dyck language.\n", "versions": [{"version": "v1", "created": "Thu, 4 Jul 2019 19:06:50 GMT"}], "update_date": "2019-07-12", "authors_parsed": [["Gitik", "Rita", ""], ["Rips", "Eliyahy", ""]]}, {"id": "1907.05369", "submitter": "Salah Triki", "authors": "Salah Triki", "title": "Abelian-square factors and binary words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this work, we affirm the conjecture proposed by Gabriele Fici and Filippo\nMignosi at the 10th Conference on Combinatorics on Words.\n", "versions": [{"version": "v1", "created": "Thu, 4 Jul 2019 21:14:28 GMT"}], "update_date": "2019-07-12", "authors_parsed": [["Triki", "Salah", ""]]}, {"id": "1907.05384", "submitter": "Rita Macedo", "authors": "Rita Macedo, Artur Miguel Dias, Ant\\'onio Ravara", "title": "Visualiza\\c{c}\\~ao e anima\\c{c}\\~ao de aut\\'omatos em Ocsigen Framework", "comments": "Article in Portuguese, submitted to the national informatics\n  conference INForum (http://inforum.org.pt/INForum2019)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Formal Languages and Automata Theory are important foundational topics in\nComputer Science. Their rigorous and formal characteristics make their learning\nthem demanding. An important support for the assimilation of concepts is the\npossibility of interactively visualizing concrete examples of these\ncomputational models, facilitating understanding them. The tools available are\nneither complete nor fully support the interactive aspect. This project aims at\nthe development of an interactive web tool in Portuguese to help in an assisted\nand intuitive way to understand the concepts and algorithms in question, seeing\nthem work step-by-step, through typical examples preloaded or built by the user\n(an original aspect of our platform). The tool should therefore enable the\ncreation and edition of an automata, as well as execute the relevant classical\nalgorithms such as word acceptance, model conversions, etc. It is also intended\nto visualize not only the process of construction of the automaton, but also\nall the steps of applying the given algorithm. This tool uses the Ocsigen\nFramework because it provides the development of complete and interactive web\ntools written in OCaml, a functional language with a strong type checking\nsystem and therefore perfect for a web page without errors. Ocsigen was also\nchosen because it allows the creation of dynamic pages with a singular\nclient-server system. This article presents the first phase of the development\nof the project. It is already possible to create automata, check the nature of\nits states and verify step-by-step (with undo) the acceptance of a word.\n", "versions": [{"version": "v1", "created": "Thu, 11 Jul 2019 17:04:35 GMT"}], "update_date": "2019-07-12", "authors_parsed": [["Macedo", "Rita", ""], ["Dias", "Artur Miguel", ""], ["Ravara", "Ant\u00f3nio", ""]]}, {"id": "1907.05751", "submitter": "\\v{S}t\\v{e}p\\'an Starosta", "authors": "V\\'aclav Ko\\v{s}\\'ik and \\v{S}t\\v{e}p\\'an Starosta", "title": "On substitutions closed under derivation: examples", "comments": "10 pages, 1 figures, submitted to Words 2019", "journal-ref": "In: Merca\\c{s} R., Reidenbach D. (eds) Combinatorics on Words.\n  WORDS 2019. Lecture Notes in Computer Science, vol 11682. Springer, Cham", "doi": "10.1007/978-3-030-28796-2_18", "report-no": null, "categories": "math.CO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study infinite words fixed by a morphism and their derived words. A\nderived word is a coding of return words to a factor. We exhibit two examples\nof sets of morphisms which are closed under derivation --- any derived word\nwith respect to any factor of the fixed point is again fixed by a morphism from\nthis set. The first example involves standard episturmian morphisms, and the\nsecond concerns the period doubling morphism.\n", "versions": [{"version": "v1", "created": "Fri, 12 Jul 2019 14:02:49 GMT"}], "update_date": "2019-11-28", "authors_parsed": [["Ko\u0161\u00edk", "V\u00e1clav", ""], ["Starosta", "\u0160t\u011bp\u00e1n", ""]]}, {"id": "1907.05995", "submitter": "Yusuke Kawamoto", "authors": "Yusuke Kawamoto", "title": "Statistical Epistemic Logic", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-31175-9_20", "report-no": null, "categories": "cs.LO cs.FL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a modal logic for describing statistical knowledge, which we\ncall statistical epistemic logic. We propose a Kripke model dealing with\nprobability distributions and stochastic assignments, and show a stochastic\nsemantics for the logic. To our knowledge, this is the first semantics for\nmodal logic that can express the statistical knowledge dependent on\nnon-deterministic inputs and the statistical significance of observed results.\nBy using statistical epistemic logic, we express a notion of statistical\nsecrecy with a confidence level. We also show that this logic is useful to\nformalize statistical hypothesis testing and differential privacy in a simple\nand abstract manner.\n", "versions": [{"version": "v1", "created": "Sat, 13 Jul 2019 01:42:56 GMT"}], "update_date": "2019-12-16", "authors_parsed": [["Kawamoto", "Yusuke", ""]]}, {"id": "1907.06012", "submitter": "Xinyu Du", "authors": "Xinyu Du, Chao Wang, Tianze Wang, Zeyu Gao", "title": "Efficient methods to determine the reversibility of general 1D linear\n  cellular automata in polynomial complexity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL nlin.CG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we study reversibility of one-dimensional(1D) linear cellular\nautomata(LCA) under null boundary condition, whose core problems have been\ndivided into two main parts: calculating the period of reversibility and\nverifying the reversibility in a period. With existing methods, the time and\nspace complexity of these two parts are still too expensive to be employed. So\nthe process soon becomes totally incalculable with a slightly big size, which\ngreatly limits its application. In this paper, we set out to solve these two\nproblems using two efficient algorithms, which make it possible to solve\nreversible LCA of very large size. Furthermore, we provide an interesting\nperspective to conversely generate 1D LCA from a given period of reversibility.\nDue to our methods' efficiency, we can calculate the reversible LCA with large\nsize, which has much potential to enhance security in cryptography system.\n", "versions": [{"version": "v1", "created": "Sat, 13 Jul 2019 05:27:55 GMT"}], "update_date": "2019-07-16", "authors_parsed": [["Du", "Xinyu", ""], ["Wang", "Chao", ""], ["Wang", "Tianze", ""], ["Gao", "Zeyu", ""]]}, {"id": "1907.06048", "submitter": "Abhijit Mahalunkar", "authors": "Abhijit Mahalunkar and John D. Kelleher", "title": "Multi-Element Long Distance Dependencies: Using SPk Languages to Explore\n  the Characteristics of Long-Distance Dependencies", "comments": "To appear in ACL 2019 workshop on Deep Learning and Formal Languages:\n  Building Bridges. arXiv admin note: substantial text overlap with\n  arXiv:1810.02966", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL stat.ML", "license": "http://creativecommons.org/publicdomain/zero/1.0/", "abstract": "  In order to successfully model Long Distance Dependencies (LDDs) it is\nnecessary to understand the full-range of the characteristics of the LDDs\nexhibited in a target dataset. In this paper, we use Strictly k-Piecewise\nlanguages to generate datasets with various properties. We then compute the\ncharacteristics of the LDDs in these datasets using mutual information and\nanalyze the impact of factors such as (i) k, (ii) length of LDDs, (iii)\nvocabulary size, (iv) forbidden subsequences, and (v) dataset size. This\nanalysis reveal that the number of interacting elements in a dependency is an\nimportant characteristic of LDDs. This leads us to the challenge of modelling\nmulti-element long-distance dependencies. Our results suggest that attention\nmechanisms in neural networks may aide in modeling datasets with multi-element\nlong-distance dependencies. However, we conclude that there is a need to\ndevelop more efficient attention mechanisms to address this issue.\n", "versions": [{"version": "v1", "created": "Sat, 13 Jul 2019 11:27:13 GMT"}], "update_date": "2020-12-09", "authors_parsed": [["Mahalunkar", "Abhijit", ""], ["Kelleher", "John D.", ""]]}, {"id": "1907.06205", "submitter": "Venkatesh Theru Mohan", "authors": "Venkatesh Theru Mohan and Ali Jannesari", "title": "Automatic Repair and Type Binding of Undeclared Variables using Neural\n  Networks", "comments": "16 pages, 16 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.CL cs.FL cs.LG cs.PL stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deep learning had been used in program analysis for the prediction of hidden\nsoftware defects using software defect datasets, security vulnerabilities using\ngenerative adversarial networks as well as identifying syntax errors by\nlearning a trained neural machine translation on program codes. However, all\nthese approaches either require defect datasets or bug-free source codes that\nare executable for training the deep learning model. Our neural network model\nis neither trained with any defect datasets nor bug-free programming source\ncodes, instead it is trained using structural semantic details of Abstract\nSyntax Tree (AST) where each node represents a construct appearing in the\nsource code. This model is implemented to fix one of the most common semantic\nerrors, such as undeclared variable errors as well as infer their type\ninformation before program compilation. By this approach, the model has\nachieved in correctly locating and identifying 81% of the programs on prutor\ndataset of 1059 programs with only undeclared variable errors and also\ninferring their types correctly in 80% of the programs.\n", "versions": [{"version": "v1", "created": "Sun, 14 Jul 2019 11:14:14 GMT"}], "update_date": "2019-07-16", "authors_parsed": [["Mohan", "Venkatesh Theru", ""], ["Jannesari", "Ali", ""]]}, {"id": "1907.06264", "submitter": "Fabio Mogavero Ph.D.", "authors": "Massimo Benerecetti and Daniele Dell'Erba and Fabio Mogavero", "title": "Solving Mean-Payoff Games via Quasi Dominions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a novel algorithm for the solution of mean-payoff games that\nmerges together two seemingly unrelated concepts introduced in the context of\nparity games, small progress measures and quasi dominions. We show that the\nintegration of the two notions can be highly beneficial and significantly\nspeeds up convergence to the problem solution. Experiments show that the\nresulting algorithm performs orders of magnitude better than the\nasymptotically-best solution algorithm currently known, without sacrificing on\nthe worst-case complexity.\n", "versions": [{"version": "v1", "created": "Sun, 14 Jul 2019 19:11:51 GMT"}], "update_date": "2019-07-16", "authors_parsed": [["Benerecetti", "Massimo", ""], ["Dell'Erba", "Daniele", ""], ["Mogavero", "Fabio", ""]]}, {"id": "1907.07761", "submitter": "Malte Schmitz", "authors": "Martin Leucker, C\\'esar S\\'anchez, Torben Scheffel, Malte Schmitz,\n  Daniel Thoma", "title": "Runtime Verification For Timed Event Streams With Partial Information", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Runtime Verification (RV) studies how to analyze execution traces of a system\nunder observation. Stream Runtime Verification (SRV) applies stream\ntransformations to obtain information from observed traces. Incomplete traces\nwith information missing in gaps pose a common challenge when applying RV and\nSRV techniques to real-world systems as RV approaches typically require the\ncomplete trace without missing parts. This paper presents a solution to perform\nSRV on incomplete traces based on abstraction. We use TeSSLa as specification\nlanguage for non-synchronized timed event streams and define abstract event\nstreams representing the set of all possible traces that could have occurred\nduring gaps in the input trace. We show how to translate a TeSSLa specification\nto its abstract counterpart that can propagate gaps through the transformation\nof the input streams and thus generate sound outputs even if the input streams\ncontain gaps and events with imprecise values. The solution has been\nimplemented as a set of macros for the original TeSSLa and an empirical\nevaluation shows the feasibility of the approach.\n", "versions": [{"version": "v1", "created": "Wed, 10 Jul 2019 15:27:44 GMT"}], "update_date": "2019-07-19", "authors_parsed": [["Leucker", "Martin", ""], ["S\u00e1nchez", "C\u00e9sar", ""], ["Scheffel", "Torben", ""], ["Schmitz", "Malte", ""], ["Thoma", "Daniel", ""]]}, {"id": "1907.07885", "submitter": "Abhishek Kr Singh", "authors": "Suneel Sarswat and Abhishek Kr Singh", "title": "Formal verification of trading in financial markets", "comments": "Preprint of 12 pages in lipicsv2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DS cs.FL cs.GT cs.SC q-fin.TR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a formal framework for analyzing trades in financial markets. An\nexchange is where multiple buyers and sellers participate to trade. These days,\nall big exchanges use computer algorithms that implement double sided auctions\nto match buy and sell requests and these algorithms must abide by certain\nregulatory guidelines. For example, market regulators enforce that a matching\nproduced by exchanges should be \\emph{fair}, \\emph{uniform} and\n\\emph{individual rational}. To verify these properties of trades, we first\nformally define these notions in a theorem prover and then give formal proofs\nof relevant results on matchings. Finally, we use this framework to verify\nproperties of two important classes of double sided auctions. All the\ndefinitions and results presented in this paper are completely formalised in\nthe Coq proof assistant without adding any additional axioms to it.\n", "versions": [{"version": "v1", "created": "Thu, 18 Jul 2019 05:50:29 GMT"}], "update_date": "2019-07-19", "authors_parsed": [["Sarswat", "Suneel", ""], ["Singh", "Abhishek Kr", ""]]}, {"id": "1907.08565", "submitter": "Darij Grinberg", "authors": "Alberto Dennunzio, Enrico Formenti, Darij Grinberg, Luciano Margara", "title": "Integrality of matrices, finiteness of matrix semigroups, and dynamics\n  of linear and additive cellular automata", "comments": "50 pages. v3 adds Bourbaki reference for the integrality criterion", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.AC cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let $\\mathbb{K}$ be a finite commutative ring, and let $\\mathbb{L}$ be a\ncommutative $\\mathbb{K}$-algebra. Let $A$ and $B$ be two $n \\times n$-matrices\nover $\\mathbb{L}$ that have the same characteristic polynomial. The main result\nof this paper states that the set $\\left\\{ A^0,A^1,A^2,\\ldots\\right\\}$ is\nfinite if and only if the set $\\left\\{ B^0,B^1,B^2,\\ldots\\right\\}$ is finite.\nWe apply this result to Cellular Automata (CA). Indeed, it gives a complete and\neasy-to-check characterization of sensitivity to initial conditions and\nequicontinuity for linear CA over the alphabet $\\mathbb{K}^n$ for $\\mathbb{K} =\n\\mathbb{Z}/m\\mathbb{Z}$ i.e., CA in which the local rule is defined by $n\\times\nn$-matrices with elements in $\\mathbb{Z}/m\\mathbb{Z}$. To prove our main\nresult, we derive an integrality criterion for matrices that is likely of\nindependent interest. Namely, let $\\mathbb{K}$ be any commutative ring (not\nnecessarily finite), and let $\\mathbb{L}$ be a commutative\n$\\mathbb{K}$-algebra. Consider any $n \\times n$-matrix $A$ over $\\mathbb{L}$.\nThen, $A \\in \\mathbb{L}^{n \\times n}$ is integral over $\\mathbb{K}$ (that is,\nthere exists a monic polynomial $f \\in \\mathbb{K}\\left[t\\right]$ satisfying\n$f\\left(A\\right) = 0$) if and only if all coefficients of the characteristic\npolynomial of $A$ are integral over $\\mathbb{K}$. The proof of this fact relies\non a strategic use of exterior powers (a trick pioneered by Gert Almkvist).\nFurthermore, we extend the decidability result concerning sensitivity and\nequicontinuity to the wider class of additive CA over a finite abelian group.\nFor such CA, we also prove the decidability of injectivity, surjectivity,\ntopological transitivity and all the properties (as, for instance, ergodicity)\nthat are equivalent to the latter.\n", "versions": [{"version": "v1", "created": "Fri, 19 Jul 2019 16:34:57 GMT"}, {"version": "v2", "created": "Tue, 7 Jan 2020 17:31:22 GMT"}, {"version": "v3", "created": "Sat, 6 Jun 2020 09:09:10 GMT"}], "update_date": "2020-06-09", "authors_parsed": [["Dennunzio", "Alberto", ""], ["Formenti", "Enrico", ""], ["Grinberg", "Darij", ""], ["Margara", "Luciano", ""]]}, {"id": "1907.08837", "submitter": "Ulya Trofimovich", "authors": "Ulya Trofimovich", "title": "Tagged Deterministic Finite Automata with Lookahead", "comments": "32 pages, 23 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper extends the work of Laurikari and Kuklewicz on tagged\ndeterministic finite automata (TDFA) in the context of submatch extraction in\nregular expressions. The main goal of this work is application of TDFA to lexer\ngenerators that optimize for speed of the generated code. I suggest a number of\npractical improvements to Laurikari algorithm; notably, the use of one-symbol\nlookahead, which results in significant reduction of tag variables and\noperations on them. Experimental results confirm that lookahead-aware TDFA are\nconsiderably faster and usually smaller than baseline TDFA; and they are\nreasonably close in speed and size to ordinary DFA used for recognition of\nregular languages. The proposed algorithm can handle repeated submatch and\ntherefore is applicable to full parsing. Furthermore, I examine the problem of\ndisambiguation in the case of leftmost greedy and POSIX policies. I formalize\nPOSIX disambiguation algorithm suggested by Kuklewicz and show that the\nresulting TDFA are as efficient as Laurikari TDFA or TDFA that use leftmost\ngreedy disambiguation. All discussed algorithms are implemented in the open\nsource lexer generator RE2C.\n", "versions": [{"version": "v1", "created": "Sat, 20 Jul 2019 16:54:11 GMT"}], "update_date": "2019-07-23", "authors_parsed": [["Trofimovich", "Ulya", ""]]}, {"id": "1907.09271", "submitter": "Sankardeep Chakraborty", "authors": "Sankardeep Chakraborty, Roberto Grossi, Kunihiko Sadakane, Srinivasa\n  Rao Satti", "title": "Succinct Representation for (Non)Deterministic Finite Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deterministic finite automata are one of the simplest and most practical\nmodels of computation studied in automata theory. Their conceptual extension is\nthe non-deterministic finite automata which also have plenty of applications.\nIn this article, we study these models through the lens of succinct data\nstructures where our ultimate goal is to encode these mathematical objects\nusing information-theoretically optimal number of bits along with supporting\nqueries on them efficiently. Towards this goal, we first design a succinct data\nstructure for representing any deterministic finite automaton $\\mathcal{D}$\nhaving $n$ states over a $\\sigma$-letter alphabet $\\Sigma$ using $(\\sigma-1)\nn\\log n + O(n \\log \\sigma)$ bits of space, which can determine, given an input\nstring $x$ over $\\Sigma$, whether $\\mathcal{D}$ accepts $x$ in $O(|x| \\log\n\\sigma)$ time, using constant words of working space. When the input\ndeterministic finite automaton is acyclic, not only we can improve the above\nspace-bound significantly to $(\\sigma -1) (n-1)\\log n+ 3n + O(\\log^2 \\sigma) +\no(n)$ bits, we also obtain optimal query time for string acceptance checking.\nMore specifically, using our succinct representation, we can check if a given\ninput string $x$ can be accepted by the acyclic deterministic finite automaton\nusing time proportional to the length of $x$, hence, the optimal query time. We\nalso exhibit a succinct data structure for representing a non-deterministic\nfinite automaton $\\mathcal{N}$ having $n$ states over a $\\sigma$-letter\nalphabet $\\Sigma$ using $\\sigma n^2+n$ bits of space, such that given an input\nstring $x$, we can decide whether $\\mathcal{N}$ accepts $x$ efficiently in\n$O(n^2|x|)$ time. Finally, we also provide time and space-efficient algorithms\nfor performing several standard operations such as union, intersection, and\ncomplement on the languages accepted by deterministic finite automata.\n", "versions": [{"version": "v1", "created": "Mon, 22 Jul 2019 12:29:03 GMT"}], "update_date": "2019-07-24", "authors_parsed": [["Chakraborty", "Sankardeep", ""], ["Grossi", "Roberto", ""], ["Sadakane", "Kunihiko", ""], ["Satti", "Srinivasa Rao", ""]]}, {"id": "1907.09362", "submitter": "Nicolas Mazzocchi", "authors": "Emmanuel Filiot, Shibashis Guha and Nicolas Mazzocchi", "title": "Two-way Parikh Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parikh automata extend automata with counters whose values can only be tested\nat the end of the computation, with respect to membership into a semi-linear\nset. Parikh automata have found several applications, for instance in\ntransducer theory, as they enjoy decidable emptiness problem. In this paper, we\nstudy two-way Parikh automata. We show that emptiness becomes undecidable in\nthe non-deterministic case. However, it is PSpace-C when the number of visits\nto any input position is bounded and the semi-linear set is given as an\nexistential Presburger formula. We also give tight complexity bounds for the\ninclusion, equivalence and universality problems. Finally, we characterise\nprecisely the complexity of those problems when the semi-linear constraint is\ngiven by an arbitrary Presburger formula.\n", "versions": [{"version": "v1", "created": "Mon, 22 Jul 2019 15:03:33 GMT"}], "update_date": "2019-07-23", "authors_parsed": [["Filiot", "Emmanuel", ""], ["Guha", "Shibashis", ""], ["Mazzocchi", "Nicolas", ""]]}, {"id": "1907.09563", "submitter": "Olivier Gauwin", "authors": "Olivier Gauwin, Anca Muscholl and Michael Raskin", "title": "Minimization of visibly pushdown automata is NP-complete", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 1 (February\n  13, 2020) lmcs:6099", "doi": "10.23638/LMCS-16(1:14)2020", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We show that the minimization of visibly pushdown automata is NP-complete.\nThis result is obtained by introducing immersions, that recognize multiple\nlanguages (over a usual, non-visible alphabet) using a common deterministic\ntransition graph, such that each language is associated with an initial state\nand a set of final states. We show that minimizing immersions is NP-complete,\nand reduce this problem to the minimization of visibly pushdown automata.\n", "versions": [{"version": "v1", "created": "Mon, 22 Jul 2019 20:36:44 GMT"}, {"version": "v2", "created": "Wed, 18 Dec 2019 20:32:14 GMT"}, {"version": "v3", "created": "Wed, 12 Feb 2020 13:40:55 GMT"}], "update_date": "2020-06-17", "authors_parsed": [["Gauwin", "Olivier", ""], ["Muscholl", "Anca", ""], ["Raskin", "Michael", ""]]}, {"id": "1907.10504", "submitter": "Rafa{\\l} Stefa\\'nski", "authors": "Miko{\\l}aj Boja\\'nczyk and Rafa{\\l} Stefa\\'nski", "title": "Single use register automata for data words", "comments": "59 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Our starting point are register automata for data words, in the style of\nKaminski and Francez. We study the effects of the single-use restriction, which\nsays that a register is emptied immediately after being used. We show that\nunder the single-use restriction, the theory of automata for data words becomes\nmuch more robust. The main results are: (a) five different machine models are\nequivalent as language acceptors, including one-way and two-way single-use\nregister automata; (b) one can recover some of the algebraic theory of\nlanguages over finite alphabets, including a version of the Krohn-Rhodes\nTheorem; (c) there is also a robust theory of transducers, with four equivalent\nmodels, including two-way single use transducers and a variant of streaming\nstring transducers for data words. These results are in contrast with automata\nfor data words without the single-use restriction, where essentially all models\nare pairwise non-equivalent.\n", "versions": [{"version": "v1", "created": "Wed, 24 Jul 2019 15:12:40 GMT"}, {"version": "v2", "created": "Thu, 7 May 2020 17:08:05 GMT"}], "update_date": "2020-05-08", "authors_parsed": [["Boja\u0144czyk", "Miko\u0142aj", ""], ["Stefa\u0144ski", "Rafa\u0142", ""]]}, {"id": "1907.11010", "submitter": "Dominik Velan", "authors": "Tom\\'a\\v{s} Br\\'azdil, Krishnendu Chatterjee, Anton\\'in Ku\\v{c}era,\n  Petr Novotn\\'y, Dominik Velan", "title": "Deciding Fast Termination for Probabilistic VASS with Nondeterminism", "comments": "23 pages, was accepted to ATVA 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A probabilistic vector addition system with states (pVASS) is a finite state\nMarkov process augmented with non-negative integer counters that can be\nincremented or decremented during each state transition, blocking any behaviour\nthat would cause a counter to decrease below zero. The pVASS can be used as\nabstractions of probabilistic programs with many decidable properties. The use\nof pVASS as abstractions requires the presence of nondeterminism in the model.\nIn this paper, we develop techniques for checking fast termination of pVASS\nwith nondeterminism.\n  That is, for every initial configuration of size n, we consider the worst\nexpected number of transitions needed to reach a configuration with some\ncounter negative (the expected termination time). We show that the problem\nwhether the asymptotic expected termination time is linear is decidable in\npolynomial time for a certain natural class of pVASS with nondeterminism.\nFurthermore, we show the following dichotomy: if the asymptotic expected\ntermination time is not linear, then it is at least quadratic, i.e., in\n$\\Omega(n^2)$.\n", "versions": [{"version": "v1", "created": "Thu, 25 Jul 2019 12:41:23 GMT"}], "update_date": "2019-07-26", "authors_parsed": [["Br\u00e1zdil", "Tom\u00e1\u0161", ""], ["Chatterjee", "Krishnendu", ""], ["Ku\u010dera", "Anton\u00edn", ""], ["Novotn\u00fd", "Petr", ""], ["Velan", "Dominik", ""]]}, {"id": "1907.11034", "submitter": "Petra Van Den Bos", "authors": "Petra van den Bos and Frits Vaandrager", "title": "State Identification for Labeled Transition Systems with Inputs and\n  Outputs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For Finite State Machines (FSMs) a rich testing theory has been developed to\ndiscover aspects of their behavior and ensure their correct functioning.\nAlthough this theory is widely used, e.g., to check conformance of protocol\nimplementations, its applicability is limited by restrictions of the FSM\nframework: the fact that inputs and outputs alternate in an FSM, and outputs\nare fully determined by the previous input and state. Labeled Transition\nSystems with inputs and outputs (LTSs), as studied in ioco testing theory,\nprovide a richer framework for testing component oriented systems, but lack the\nalgorithms for test generation from FSM theory.\n  In this article, we propose an algorithm for the fundamental problem of state\nidentification during testing of LTSs. Our algorithm is a direct generalization\nof the well-known algorithm for computing adaptive distinguishing sequences for\nFSMs proposed by Lee & Yannakakis. Our algorithm has to deal with so-called\ncompatible states, states that cannot be distinguished in case of an\nadversarial system-under-test. Analogous to the result of Lee & Yannakakis, we\nprove that if an (adaptive) test exists that distinguishes all pairs of\nincompatible states of an LTS, our algorithm will find one. In practice, such\nadaptive tests typically do not exist. However, in experiments with an\nimplementation of our algorithm on an industrial benchmark, we find that tests\nproduced by our algorithm still distinguish more than 99% of the incompatible\nstate pairs.\n", "versions": [{"version": "v1", "created": "Thu, 25 Jul 2019 13:28:31 GMT"}, {"version": "v2", "created": "Tue, 22 Oct 2019 14:43:22 GMT"}], "update_date": "2019-10-23", "authors_parsed": [["Bos", "Petra van den", ""], ["Vaandrager", "Frits", ""]]}, {"id": "1907.11573", "submitter": "Szabolcs Iv\\'an", "authors": "Kitti Gelle, Szabolcs Ivan", "title": "The order type of scattered context-free orderings of rank one is\n  computable", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A linear ordering is called context-free if it is the lexicographic ordering\nof some context-free language and is called scattered if it has no dense\nsubordering. Each scattered ordering has an associated ordinal, called its\nrank. It is known that the isomorphism problem of scattered context-free\norderings is undecidable, if one of them has a rank at least two. In this paper\nwe show that it is decidable whether a context-free ordering has rank at most\none, and if so, its order type is effectively computable.\n", "versions": [{"version": "v1", "created": "Fri, 26 Jul 2019 13:41:52 GMT"}], "update_date": "2019-07-29", "authors_parsed": [["Gelle", "Kitti", ""], ["Ivan", "Szabolcs", ""]]}, {"id": "1907.11895", "submitter": "Igor Buzhinsky", "authors": "Igor Buzhinsky, Valeriy Vyatkin", "title": "Combining closed-loop test generation and execution by means of model\n  checking", "comments": "15 pages, 4 figures, 2 tables, submitted to International Journal on\n  Software Tools for Technology Transfer", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Model checking is an established technique to formally verify automation\nsystems which are required to be trusted. However, for sufficiently complex\nsystems model checking becomes computationally infeasible. On the other hand,\ntesting, which offers less reliability, often does not present a serious\ncomputational challenge. Searching for synergies between these two approaches,\nthis paper proposes a framework to ensure reliability of industrial automation\nsystems by means of hybrid use of model checking and testing. This framework\nrepresents a way to achieve a trade-off between verification reliability and\ncomputational complexity which has not yet been explored in other approaches.\nInstead of undergoing usual model checking, system requirements are checked\nonly on particular system behaviors which represent a test suite achieving\ncoverage for both the system and the requirements. Then, all stages of the\nframework support the case of a closed-loop model, where not only the\ncontroller, but also the plant is modeled.\n", "versions": [{"version": "v1", "created": "Sat, 27 Jul 2019 11:15:18 GMT"}], "update_date": "2019-07-30", "authors_parsed": [["Buzhinsky", "Igor", ""], ["Vyatkin", "Valeriy", ""]]}, {"id": "1907.12034", "submitter": "Gabriele Fici", "authors": "Gabriele Fici and Pawe{\\l} Gawrychowski", "title": "Minimal Absent Words in Rooted and Unrooted Trees", "comments": "This is a slightly modified version of the paper that appeared in the\n  proceedings of SPIRE 2019, which contained an error in the example showed in\n  Fig.1, now corrected", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We extend the theory of minimal absent words to (rooted and unrooted) trees,\nhaving edges labeled by letters from an alphabet $\\Sigma$ of cardinality\n$\\sigma$. We show that the set $\\text{MAW}(T)$ of minimal absent words of a\nrooted (resp. unrooted) tree $T$ with $n$ nodes has cardinality $O(n\\sigma)$\n(resp. $O(n^{2}\\sigma)$), and we show that these bounds are realized. Then, we\nexhibit algorithms to compute all minimal absent words in a rooted (resp.\nunrooted) tree in output-sensitive time $O(n+|\\text{MAW}(T)|)$ (resp.\n$O(n^{2}+|\\text{MAW}(T)|)$ assuming an integer alphabet of size polynomial in\n$n$.\n", "versions": [{"version": "v1", "created": "Sun, 28 Jul 2019 07:32:58 GMT"}, {"version": "v2", "created": "Wed, 30 Oct 2019 07:58:05 GMT"}], "update_date": "2019-10-31", "authors_parsed": [["Fici", "Gabriele", ""], ["Gawrychowski", "Pawe\u0142", ""]]}, {"id": "1907.12713", "submitter": "Cristopher Moore", "authors": "Cristopher Moore", "title": "Lecture Notes on Automata, Languages, and Grammars", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  These lecture notes are intended as a supplement to Moore and Mertens' The\nNature of Computation or as a standalone resource, and are available to anyone\nwho wants to use them. Comments are welcome, and please let me know if you use\nthese notes in a course. There are 61 exercises.\n  I emphasize that automata are elementary playgrounds where we can explore the\nissues of deterministic and nondeterministic computation. Unlike P vs. NP, we\ncan prove that nondeterminism is equivalent to determinism, or strictly more\npowerful than determinism, in finite-state and push-down automata respectively.\nI also correct several historical and aesthetic injustices: in particular, the\nMyhill-Nerode theorem and the idea of building minimal DFAs from equivalence\nclasses of prefixes is restored to its rightful place above the Pumping Lemma\nfor regular languages. I also discuss the Pumping Lemma for context-free\nlanguages, and briefly discuss counter automata, queue automata, and the\nconnection between unambiguous context-free languages and algebraic generating\nfunctions.\n", "versions": [{"version": "v1", "created": "Tue, 30 Jul 2019 02:54:30 GMT"}], "update_date": "2019-08-01", "authors_parsed": [["Moore", "Cristopher", ""]]}, {"id": "1907.13115", "submitter": "Tom\\'a\\v{s} Masopust", "authors": "Tom\\'a\\v{s} Masopust and Markus Kr\\\"otzsch", "title": "Partially Ordered Automata and Piecewise Testability", "comments": "arXiv admin note: text overlap with arXiv:1704.07860", "journal-ref": "Logical Methods in Computer Science, Volume 17, Issue 2 (May 11,\n  2021) lmcs:7475", "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Partially ordered automata are automata where the transition relation induces\na partial order on states. The expressive power of partially ordered automata\nis closely related to the expressivity of fragments of first-order logic on\nfinite words or, equivalently, to the language classes of the levels of the\nStraubing-Th\\'erien hierarchy. Several fragments (levels) have been intensively\ninvestigated under various names. For instance, the fragment of first-order\nformulae with a single existential block of quantifiers in prenex normal form\nis known as piecewise testable languages or $J$-trivial languages. These\nlanguages are characterized by confluent partially ordered DFAs or by complete,\nconfluent, and self-loop-deterministic partially ordered NFAs (ptNFAs for\nshort). In this paper, we study the complexity of basic questions for several\ntypes of partially ordered automata on finite words; namely, the questions of\ninclusion, equivalence, and ($k$-)piecewise testability. The lower-bound\ncomplexity boils down to the complexity of universality. The universality\nproblem asks whether a system recognizes all words over its alphabet. For\nptNFAs, the complexity of universality decreases if the alphabet is fixed, but\nit is open if the alphabet may grow with the number of states. We show that\ndeciding universality for general ptNFAs is as hard as for general NFAs. Our\nproof is a novel and nontrivial extension of our recent construction for\nself-loop-deterministic partially ordered NFAs, a model strictly more\nexpressive than ptNFAs. We provide a comprehensive picture of the complexities\nof the problems of inclusion, equivalence, and ($k$-)piecewise testability for\nthe considered types of automata.\n", "versions": [{"version": "v1", "created": "Mon, 29 Jul 2019 10:50:26 GMT"}, {"version": "v2", "created": "Sun, 29 Sep 2019 18:03:19 GMT"}, {"version": "v3", "created": "Fri, 8 Nov 2019 16:33:55 GMT"}, {"version": "v4", "created": "Sun, 5 Jul 2020 20:42:56 GMT"}, {"version": "v5", "created": "Fri, 16 Apr 2021 20:04:03 GMT"}, {"version": "v6", "created": "Wed, 21 Apr 2021 20:17:12 GMT"}, {"version": "v7", "created": "Mon, 10 May 2021 13:46:30 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Masopust", "Tom\u00e1\u0161", ""], ["Kr\u00f6tzsch", "Markus", ""]]}, {"id": "1907.13288", "submitter": "Vasudevan Nagendra", "authors": "Vasudevan Nagendra, Arani Bhattacharya, Vinod Yegneswaran, Amir\n  Rahmati, Samir R Das", "title": "VISCR: Intuitive & Conflict-free Automation for Securing the Dynamic\n  Consumer IoT Infrastructures", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Consumer IoT is characterized by heterogeneous devices with diverse\nfunctionality and programming interfaces. This lack of homogeneity makes the\nintegration and security management of IoT infrastructures a daunting task for\nusers and administrators. In this paper, we introduce VISCR, a\nVendor-Independent policy Specification and Conflict Resolution engine that\nenables conflict-free policy specification and enforcement in IoT environments.\nVISCR converts the topology of the IoT infrastructure into a tree-based\nabstraction and translates existing policies from heterogeneous vendor-specific\nprogramming languages such as Groovy-based SmartThings, OpenHAB, IFTTT-based\ntemplates, and MUD-based profiles into a vendor-independent graph-based\nspecification. Using the two, VISCR can automatically detect rouge policies,\nconflicts, and bugs for coherent automation. Upon detection, VISCR infers new\npolicies and proposes them to users as alternatives to existing policies for\nfine-tuning and conflict-free enforcement. We evaluated VISCR using a dataset\nof 907 IoT apps, programmed using heterogeneous automation specifications in a\nsimulated smart-building IoT infrastructure. In our experiments, among 907 IoT\napps, VISCR exposed 342 of IoT apps as exhibiting one or more violations. VISCR\ndetected 100% of violations reported by existing state-of-the-art tool, while\ndetecting new types of violations in an additional 266 apps. In terms of\nperformance, VISCR can generate 400 abstraction trees (used in specifying\npolicies) with 100K leaf nodes in <1.2sec. In our experiments, VISCR took 80.7\nseconds to analyze our infrastructure of 907 apps; a 14.2X reduction compared\nto the state-of-the-art. After the initial analysis, VISCR is capable of\nadopting new policies in sub-second latency to handle changes.\n", "versions": [{"version": "v1", "created": "Wed, 31 Jul 2019 02:31:06 GMT"}], "update_date": "2019-08-01", "authors_parsed": [["Nagendra", "Vasudevan", ""], ["Bhattacharya", "Arani", ""], ["Yegneswaran", "Vinod", ""], ["Rahmati", "Amir", ""], ["Das", "Samir R", ""]]}, {"id": "1907.13577", "submitter": "Ola Wingbrant", "authors": "Ola Wingbrant", "title": "Regular languages, derivatives and finite automata", "comments": "Keywords: regular expressions, regular languages, Brzozowski\n  derivatives, DFA, submatching", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This report is mostly written for educational purposes. It is meant as a self\ncontained introduction to regular languages, regular expressions, and regular\nexpression matching by using Brzozowski derivatives. As such it is mostly based\non the work by Brzozowski[4] and Owens et al.[12] The language basics material\nhave been inspired by books[2] and web material[16].\n  Chapter 1 introduces the fundamental concepts of formal languages, as well as\nthe idea of string derivatives. In chapter 2 we define the class of regular\nlanguages, and further develops the theory of derivatives for that class. We\nuse derivatives to prove the Myhill-Nerod theorem, the Pumping lemma, and the\nclosure of regular languages under all Boolean connectives. In chapter 3 we\nintroduce regular expressions and regular expression matching. Chapter 4\nconnects the theory of regular languages and derivatives with that of finite\nautomata. Chapter 5 looks at the concept of anchors, and how this can be\nincorporated into a matcher based on derivatives. Chapter 6 discusses\nsubmatching using derivatives with an approach inspired by Laurikari and his\nwork on tagged transitions[11]. This is the part we consider as our main\ncontribution to the field. In the last chapter, chapter 7, we summarize by\ngiving a regular expression matching algorithm using the previously discussed\ntechniques. We also discuss related work by others.\n", "versions": [{"version": "v1", "created": "Sun, 21 Jul 2019 15:07:52 GMT"}], "update_date": "2019-08-01", "authors_parsed": [["Wingbrant", "Ola", ""]]}]