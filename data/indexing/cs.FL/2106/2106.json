[{"id": "2106.00041", "submitter": "Milliam Maxime Zekeng Ndadji", "authors": "Milliam Maxime Zekeng Ndadji", "title": "A Grammatical Approach for Distributed Business Process Management using\n  Structured and Cooperatively Edited Mobile Artifacts", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this thesis, we focus on the proposal of distributed workflow systems\ndedicated to the automation of administrative business processes. We propose an\napproach to build such systems by relying on the concepts of multiagent\nsystems, Peer to Peer (P2P) architecture, Service-Oriented Architecture (SOA)\nand structured documents (artifacts) cooperative edition. Indeed, we develop\nmathematical tools that allow any workflow systems designer, to express each\nadministrative process in the form of an attributed grammar whose symbols\nrepresent tasks to be executed, productions specify a scheduling of these\ntasks, and instances (the derivation trees that conform to it) represent the\ndifferent execution scenarios leading to business goal states. The obtained\ngrammatical model is then introduced into a proposed P2P system which is in\ncharge of carrying out the completely decentralised execution of the underlying\nprocess's instances. The said system orchestrates a process's instance\nexecution as a choreography during which, various software agents driven by\nhuman agents (actors), coordinate themselves through artifacts that they\ncollectively edit. The exchanged artifacts represent the system's memory: they\nprovide information on already executed tasks, on those ready to be executed\nand on their executors. The software agents are autonomous and identical: they\nexecute the same unique protocol each time they receive an artifact. This\nprotocol allows them to identify the tasks they must immediately execute, to\nexecute them, to update the artifact and to disseminate it if necessary, for\nthe continuation of the execution. Moreover, actors potentially have only a\npartial perception of processes in which they are involved. In practice, this\nmeans that certain tasks can be carried out confidentially.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 18:18:13 GMT"}], "update_date": "2021-06-02", "authors_parsed": [["Ndadji", "Milliam Maxime Zekeng", ""]]}, {"id": "2106.00156", "submitter": "Eryk Lipka", "authors": "Artur Pola\\'nski and Eryk Lipka", "title": "Detecting a single fault in a deterministic finite automaton", "comments": "13 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a deterministic finite automaton and its implementation with at most\none single fault, that we can test on a set of inputs, we provide an algorithm\nto find a test set that guarantees finding whether the fault exists.\n", "versions": [{"version": "v1", "created": "Tue, 1 Jun 2021 00:22:11 GMT"}], "update_date": "2021-06-02", "authors_parsed": [["Pola\u0144ski", "Artur", ""], ["Lipka", "Eryk", ""]]}, {"id": "2106.00315", "submitter": "Davide Martincigh", "authors": "Giovanna D'Agostino and Davide Martincigh and Alberto Policriti", "title": "Ordering regular languages: a danger zone", "comments": "24 pages, 6 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Ordering the collection of states of a given automaton starting from an order\nof the underlying alphabet is a natural move towards a computational treatment\nof the language accepted by the automaton. Along this path, Wheeler\n\\emph{graphs} have been recently introduced as an extension/adaptation of the\nBurrows-Wheeler Transform (the now famous BWT, originally defined on strings)\nto graphs. These graphs constitute an important data-structure for languages,\nsince they allow a very efficient storage mechanism for the transition function\nof an automaton, while providing a fast support to all sorts of substring\nqueries. This is possible as a consequence of a property -- the so-called\n\\emph{path coherence} -- valid on Wheeler graphs and consisting in an ordering\non nodes that \"propagates\" to (collections of) strings. By looking at a Wheeler\ngraph as an automaton, the ordering on strings corresponds to the\nco-lexicographic order of the words entering each state. This leads naturally\nto consider the class of regular languages accepted by Wheeler automata, i.e.\nthe Wheeler languages.\n  It has been shown that, as opposed to the general case, the classic\ndeterminization by powerset construction is polynomial on Wheeler languages. As\na consequence, most of the classical problems turn out to be \"easy\" -- that is,\nsolvable in polynomial time -- on Wheeler languages. Moreover, deciding whether\na DFA is Wheeler and deciding whether a DFA accepts a Wheeler language is\npolynomial.\n  Our contribution here is to put an upper bound to easy problems. For\ninstance, whenever we generalize by switching to general NFAs or by not fixing\nan order of the underlying alphabet, the above mentioned problems become \"hard\"\n-- that is NP-complete or even PSPACE-complete.\n", "versions": [{"version": "v1", "created": "Tue, 1 Jun 2021 08:43:53 GMT"}, {"version": "v2", "created": "Thu, 3 Jun 2021 13:53:56 GMT"}, {"version": "v3", "created": "Fri, 11 Jun 2021 12:37:07 GMT"}], "update_date": "2021-06-14", "authors_parsed": [["D'Agostino", "Giovanna", ""], ["Martincigh", "Davide", ""], ["Policriti", "Alberto", ""]]}, {"id": "2106.01062", "submitter": "Jeffrey Shallit", "authors": "Jeffrey Shallit", "title": "Hilbert's spacefilling curve described by automatic, regular, and\n  synchronized sequences", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe Hilbert's spacefilling curve in several different ways: as an\nautomatic sequence of directions,as a regular and synchronized sequence of\ncoordinates of lattice points encountered, and as an automatic bitmap image.\n", "versions": [{"version": "v1", "created": "Wed, 2 Jun 2021 10:33:48 GMT"}], "update_date": "2021-06-03", "authors_parsed": [["Shallit", "Jeffrey", ""]]}, {"id": "2106.01870", "submitter": "James Hsin-Yu Chiang", "authors": "Massimo Bartoletti, James Hsin-yu Chiang, Alberto Lluch-Lafuente", "title": "Maximizing Extractable Value from Automated Market Makers", "comments": "12 pages. Under submission", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.CE cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automated Market Makers (AMMs) are decentralized applications that allow\nusers to exchange crypto-tokens without the need to find a matching exchange\norder. AMMs are one of the most successful DeFi use case so far, as the main\nAMM platforms UniSwap and Balancer process a daily volume of transactions worth\nbillions of dollars. Despite this success story, AMMs are well-known to suffer\nfrom transaction-ordering issues: indeed, adversaries can frontrun user\ntransactions to increase their gain to the detriment of honest users. Being\nspecifically designated to arrange user transactions into blocks, miners can\neasily play the role of adversary, by suitably selecting and ordering\ntransactions - and possibly inserting their own - to increase their gain. In\nthis paper we formally characterize rational miners as players which follow an\noptimal strategy in the mining game. We identify relevant variants of the game,\ncorresponding to specific real-world constraints that a miner might have. We\ndevise effective procedures to construct solutions to mining game, both in its\nmost general form and in some relevant variants. Most notably, miners can\nexploit these solutions to maximize the value extracted from user transactions.\n", "versions": [{"version": "v1", "created": "Wed, 2 Jun 2021 10:32:05 GMT"}], "update_date": "2021-06-04", "authors_parsed": [["Bartoletti", "Massimo", ""], ["Chiang", "James Hsin-yu", ""], ["Lluch-Lafuente", "Alberto", ""]]}, {"id": "2106.02309", "submitter": "Giovanna D'Agostino", "authors": "Giovanna D'Agostino and Nicola Cotumaccio and Alberto Policriti and\n  Nicola Prezza", "title": "On (co-lex) Ordering Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The states of a deterministic finite automaton A can be identified with\ncollections of words in Pf(L(A)) -- the set of prefixes of words belonging to\nthe regular language accepted by A. But words can be ordered and among the many\npossible orders a very natural one is the co-lexicographic one. Such\nnaturalness stems from the fact that it suggests a transfer of the order from\nwords to the automaton's states. In a number of papers automata admitting a\ntotal ordering of states coherent with the ordering of the set of words\nreaching them have been proposed. Such class of ordered automata -- the Wheeler\nautomata -- turned out to be efficiently stored/searched using an index.\nUnfortunately not all automata can be totally ordered as previously outlined.\nHowever, automata can always be partially ordered and an intrinsic measure of\ntheir complexity can be defined and effectively determined, as the minimum\nwidth of one of their admissible partial orders. As shown in previous works,\nthis new concept of width of an automaton has useful consequences in the fields\nof graph compression, indexing data structures, and automata theory. In this\npaper we prove that a canonical, minimum-width, partially-ordered automaton\naccepting a language L -- dubbed the Hasse automaton H of L -- can be\nexhibited. H provides, in a precise sense, the best possible way to (partially)\norder the states of any automaton accepting L, as long as we want to maintain\nan operational link with the (co-lexicographic) order of Pf(L(A)). Using H we\nprove that the width of the language can be effectively computed from the\nminimum automaton recognizing the language. Finally, we explore the\nrelationship between two (often conflicting) objectives: minimizing the width\nand minimizing the number of states of an automaton.\n", "versions": [{"version": "v1", "created": "Fri, 4 Jun 2021 07:41:58 GMT"}], "update_date": "2021-06-07", "authors_parsed": [["D'Agostino", "Giovanna", ""], ["Cotumaccio", "Nicola", ""], ["Policriti", "Alberto", ""], ["Prezza", "Nicola", ""]]}, {"id": "2106.02312", "submitter": "Avraham N. Trahtman", "authors": "A.N. Trahtman", "title": "Verification Tools for Checking some kinds of Testability", "comments": "14 pages, 6 figures, Algebraic Methods in Language Processing, 2003", "journal-ref": "Verification of algorithms for checking some kinds of testability.\n  In Algebraic Methods in Language Processing, TWLT 21, eds. F.Spoto, 21(2003),\n  253-263", "doi": null, "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A locally testable language L is a language with the property that for some\nnon negative integer k, called the order of local testability, whether or not a\nword u is in the language L depends on (1) the prefix and suffix of the word u\nof length k + 1 and (2) the set of intermediate substrings of length k of the\nword u. For given k the language is called k-testable. The local testability\nhas a wide spectrum of generalizations. A set of procedures for deciding\nwhether or not a language given by its minimal automaton or by its syntactic\nsemigroup is locally testable, right or left locally testable, threshold\nlocally testable, strictly locally testable, or piecewise testable was\nimplemented in the package TESTAS written in C=C++. The bounds on order of\nlocal testability of transition graph and order of local testability of\ntransition semigroup are also found. For given k, the k-testability of\ntransition graph is verified. We consider some approaches to verify these\nprocedures and use for this aim some auxiliary programs. The approaches are\nbased on distinct forms of presentation of a given finite automaton and on\nalgebraic properties of the presentation. New proof and fresh wording of\nnecessary and sufficient conditions for local testability of deterministic\nfinite automaton is presented.\n", "versions": [{"version": "v1", "created": "Fri, 4 Jun 2021 07:44:25 GMT"}], "update_date": "2021-06-07", "authors_parsed": [["Trahtman", "A. N.", ""]]}, {"id": "2106.02571", "submitter": "Manfred Kufleitner", "authors": "Marcial Gai{\\ss}ert and Manfred Kufleitner", "title": "The Inclusion Problem for Forest Languages under Substitutions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We consider algorithms and lower bounds for various problems over forest\nlanguages; as input models we allow forest algebras, deterministic forest\nautomata and nondeterministic forest automata. For the equivalence problem, we\ngive an almost-linear-time algorithm for both forest algebras and deterministic\nforest automata; this is complemented by a polynomial time hardness result. The\nemptiness problem is complete for polynomial time over each of the three\nmodels. Additionally, we consider the emptiness of intersection problem for\nforest algebras and deterministic forest automata; this problem turns out to be\ncomplete for exponential time. It is well-known that the corresponding problems\nfor word languages are complete for nondeterministic logarithmic space and for\npolynomial space, respectively.\n  Equipped with this toolbox of algorithms and lower bounds, we consider\nvarious inclusion problems for regular forest languages under substitutions.\nThe substitutions in this paper replace leaf variables by forest languages.\nDepending on the direction of the inclusion, the problem for a given\nsubstitution is either complete for polynomial time or for exponential time; in\nparticular, the equivalence problem under substitutions is complete for\nexponential time and, hence, more difficult than the equivalence problem for\nforest languages without substitutions. If we ask whether there exists a\nsubstitution such that a given inclusion holds, then this problem is either\ncomplete for NP or exponential time, depending on whether we consider inclusion\nor equivalence; moreover, the problem is undecidable if the substitution is\napplied on both sides.\n", "versions": [{"version": "v1", "created": "Fri, 4 Jun 2021 16:07:16 GMT"}], "update_date": "2021-06-07", "authors_parsed": [["Gai\u00dfert", "Marcial", ""], ["Kufleitner", "Manfred", ""]]}, {"id": "2106.02937", "submitter": "Ujjwal Mishra", "authors": "Ujjwal Kumar Mishra, Kalpana Mahalingam, Rama Raghavan", "title": "Generalized Linear One-Way Jumping Finite Automata", "comments": "16 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A new discontinuous model of computation called one-way jumping finite\nautomata was defined by H. Chigahara et. al. This model was a restricted\nversion of the model jumping finite automata. These automata read an input\nsymbol-by-symbol and jump only in one direction. A generalized linear one-way\njumping finite automaton makes jumps after deleting a substring of an input\nstring and then changes its state. These automata can make sequence of jumps in\nonly one direction on an input string either from left to right or from right\nto left. We show that newly defined model is powerful than its original\ncounterpart. We define and compare the variants, generalized right linear\none-way jumping finite automata and generalized left linear one-way jumping\nfinite automata. We also compare the newly defined models with Chomsky\nhierarchy. Finally, we explore closure properties of the model.\n", "versions": [{"version": "v1", "created": "Sat, 5 Jun 2021 17:35:53 GMT"}], "update_date": "2021-06-08", "authors_parsed": [["Mishra", "Ujjwal Kumar", ""], ["Mahalingam", "Kalpana", ""], ["Raghavan", "Rama", ""]]}, {"id": "2106.02965", "submitter": "Clara Lacroce", "authors": "Clara Lacroce, Prakash Panangaden, Guillaume Rabusseau", "title": "Extracting Weighted Automata for Approximate Minimization in Language\n  Modelling", "comments": "Full version of ICGI 2020/21 paper, authors are listed in\n  alphabetical order", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we study the approximate minimization problem for language\nmodelling. We assume we are given some language model as a black box. The\nobjective is to obtain a weighted finite automaton (WFA) that fits within a\ngiven size constraint and which mimics the behaviour of the original model\nwhile minimizing some notion of distance between the black box and the\nextracted WFA. We provide an algorithm for the approximate minimization of\nblack boxes trained for language modelling of sequential data over a one-letter\nalphabet. By reformulating the problem in terms of Hankel matrices, we leverage\nclassical results on the approximation of Hankel operators, namely the\ncelebrated Adamyan-Arov-Krein (AAK) theory. This allows us to use the spectral\nnorm to measure the distance between the black box and the WFA. We provide\ntheoretical guarantees to study the potentially infinite-rank Hankel matrix of\nthe black box, without accessing the training data, and we prove that our\nmethod returns an asymptotically-optimal approximation.\n", "versions": [{"version": "v1", "created": "Sat, 5 Jun 2021 21:19:42 GMT"}, {"version": "v2", "created": "Fri, 23 Jul 2021 15:09:36 GMT"}], "update_date": "2021-07-26", "authors_parsed": [["Lacroce", "Clara", ""], ["Panangaden", "Prakash", ""], ["Rabusseau", "Guillaume", ""]]}, {"id": "2106.03202", "submitter": "Marieh Jahannia", "authors": "Marieh Jahannia and Morteza Mohammad-noori and Narad Rampersad and\n  Manon Stipulanti", "title": "Closed Ziv-Lempel factorization of the $m$-bonacci words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  A word $w$ is said to be closed if it has a proper factor $x$ which occurs\nexactly twice in $w$, as a prefix and as a suffix of $w$. Based on the concept\nof Ziv-Lempel factorization, we define the closed $z$-factorization of finite\nand infinite words. Then we find the closed $z$-factorization of the infinite\n$m$-bonacci words for all $m \\geq 2$. We also classify closed prefixes of the\ninfinite $m$-bonacci words.\n", "versions": [{"version": "v1", "created": "Sun, 6 Jun 2021 18:20:58 GMT"}], "update_date": "2021-06-08", "authors_parsed": [["Jahannia", "Marieh", ""], ["Mohammad-noori", "Morteza", ""], ["Rampersad", "Narad", ""], ["Stipulanti", "Manon", ""]]}, {"id": "2106.03245", "submitter": "Yixuan Wang", "authors": "Yixuan Wang, Chao Huang, Zhaoran Wang, Zhilu Wang and Qi Zhu", "title": "Verification in the Loop: Correct-by-Construction Control Learning with\n  Reach-avoid Guarantees", "comments": "Under review", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the current control design of safety-critical autonomous systems, formal\nverification techniques are typically applied after the controller is designed\nto evaluate whether the required properties (e.g., safety) are satisfied.\nHowever, due to the increasing system complexity and the fundamental hardness\nof designing a controller with formal guarantees, such an open-loop process of\ndesign-then-verify often results in many iterations and fails to provide the\nnecessary guarantees. In this paper, we propose a correct-by-construction\ncontrol learning framework that integrates the verification into the control\ndesign process in a closed-loop manner, i.e., design-while-verify.\nSpecifically, we leverage the verification results (computed reachable set of\nthe system state) to construct feedback metrics for control learning, which\nmeasure how likely the current design of control parameters can meet the\nrequired reach-avoid property for safety and goal-reaching. We formulate an\noptimization problem based on such metrics for tuning the controller\nparameters, and develop an approximated gradient descent algorithm with a\ndifference method to solve the optimization problem and learn the controller.\nThe learned controller is formally guaranteed to meet the required reach-avoid\nproperty. By treating verifiability as a first-class objective and effectively\nleveraging the verification results during the control learning process, our\napproach can significantly improve the chance of finding a control design with\nformal property guarantees. This is demonstrated via a set of experiments on\nboth linear and non-linear systems that use model-based or neural network based\ncontrollers.\n", "versions": [{"version": "v1", "created": "Sun, 6 Jun 2021 20:56:06 GMT"}], "update_date": "2021-06-08", "authors_parsed": [["Wang", "Yixuan", ""], ["Huang", "Chao", ""], ["Wang", "Zhaoran", ""], ["Wang", "Zhilu", ""], ["Zhu", "Qi", ""]]}, {"id": "2106.03445", "submitter": "Murray Elder", "authors": "Murray Elder and Adam Piggott", "title": "On groups presented by inverse-closed finite convergent length-reducing\n  rewriting systems", "comments": "15 pages, 6 figures. Some typos corrected", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We show that groups presented by inverse-closed finite convergent\nlength-reducing rewriting systems are characterised by a striking geometric\nproperty: their Cayley graphs are geodetic and side-lengths of non-degenerate\ntriangles are uniformly bounded. This leads to a new algebraic result: the\ngroup is plain (isomorphic to the free product of finitely many finite groups\nand copies of $\\mathbb Z$) if and only if a certain relation on the set of\nnon-trivial finite-order elements of the group is transitive on a bounded set.\nWe use this to prove that deciding if a group presented by an inverse-closed\nfinite convergent length-reducing rewriting system is not plain is in\n$\\mathsf{NP}$. A \"yes\" answer would disprove a longstanding conjecture of\nMadlener and Otto from 1987. We also prove that the isomorphism problem for\nplain groups presented by inverse-closed finite convergent length-reducing\nrewriting systems is in $\\mathsf{PSPACE}$.\n", "versions": [{"version": "v1", "created": "Mon, 7 Jun 2021 09:23:08 GMT"}, {"version": "v2", "created": "Wed, 14 Jul 2021 07:10:16 GMT"}, {"version": "v3", "created": "Sun, 25 Jul 2021 08:01:20 GMT"}], "update_date": "2021-07-27", "authors_parsed": [["Elder", "Murray", ""], ["Piggott", "Adam", ""]]}, {"id": "2106.03554", "submitter": "Wil van der Aalst", "authors": "Wil M.P. van der Aalst", "title": "Free-Choice Nets With Home Clusters Are Lucent", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL cs.SY eess.SY", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A marked Petri net is lucent if there are no two different reachable markings\nenabling the same set of transitions, i.e., states are fully characterized by\nthe transitions they enable. Characterizing the class of systems that are\nlucent is a foundational and also challenging question. However, little\nresearch has been done on the topic. In this paper, it is shown that all\nfree-choice nets having a home cluster are lucent. These nets have a so-called\nhome marking such that it is always possible to reach this marking again. Such\na home marking can serve as a regeneration point or as an end-point. The result\nis highly relevant because in many applications, we want the system to be\nlucent and many well-behaved process models fall into the class identified in\nthis paper. Unlike previous work, we do not require the marked Petri net to be\nlive and strongly connected. Most of the analysis techniques for free-choice\nnets are tailored towards well-formed nets. The approach presented in this\npaper provides a novel perspective enabling new analysis techniques for\nfree-choice nets that do not need to be well-formed. Therefore, we can also\nmodel systems and processes that are terminating and/or have an initialization\nphase.\n", "versions": [{"version": "v1", "created": "Mon, 7 Jun 2021 12:34:29 GMT"}], "update_date": "2021-06-08", "authors_parsed": [["van der Aalst", "Wil M. P.", ""]]}, {"id": "2106.03658", "submitter": "Wil van der Aalst", "authors": "Wil M.P. van der Aalst", "title": "Reduction Using Induced Subnets To Systematically Prove Properties For\n  Free-Choice Nets", "comments": "Keywords: Petri Nets, Free-Choice Nets, Net Reduction, Lucency", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We use sequences of t-induced T-nets and p-induced P-nets to convert\nfree-choice nets into T-nets and P-nets while preserving properties such as\nwell-formedness, liveness, lucency, pc-safety, and perpetuality. The approach\nis general and can be applied to different properties. This allows for more\nsystematic proofs that \"peel off\" non-trivial parts while retaining the essence\nof the problem (e.g., lifting properties from T-net and P-net to free-choice\nnets).\n", "versions": [{"version": "v1", "created": "Mon, 7 Jun 2021 14:37:39 GMT"}, {"version": "v2", "created": "Thu, 17 Jun 2021 15:27:16 GMT"}], "update_date": "2021-06-18", "authors_parsed": [["van der Aalst", "Wil M. P.", ""]]}, {"id": "2106.03852", "submitter": "Ujjwal Mishra", "authors": "Ujjwal Kumar Mishra, Kalpana Mahalingam, Rama Raghavan", "title": "Generalized Circular One-Way Jumping Finite Automata", "comments": "18 pages, 4 figures. arXiv admin note: substantial text overlap with\n  arXiv:2106.02937", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A discontinuous model of computation called one-way jumping finite automata\nwas defined by H. Chigahara et. al. This model was a restricted version of the\nmodel jumping finite automata. One-way jumping finite automata change their\nstates after deleting a letter of an input and jump only in one direction.\nAllowing a state to delete a subword instead of a letter, we define a new model\ngeneralized circular one-way jumping finite automata. These automata work on an\ninput in a circular manner. Similar to one-way jumping finite automata,\ngeneralized circular one-way jumping finite automata also jump only in one\ndirection. We show that this newly defined model is powerful than one-way\njumping finite automata. We define new variants(right and left) of the model\ngeneralized circular one-way jumping finite automata and compare them. We also\ncompare the newly defined model with Chomsky hierarchy. Finally, we explore\nclosure properties of the model.\n", "versions": [{"version": "v1", "created": "Sat, 5 Jun 2021 17:57:04 GMT"}], "update_date": "2021-06-09", "authors_parsed": [["Mishra", "Ujjwal Kumar", ""], ["Mahalingam", "Kalpana", ""], ["Raghavan", "Rama", ""]]}, {"id": "2106.06249", "submitter": "Stefan Siemer", "authors": "Pawe{\\l} Gawrychowski, Florin Manea, Stefan Siemer", "title": "Matching Patterns with Variables under Hamming Distance", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.CC cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A pattern $\\alpha$ is a string of variables and terminal letters. We say that\n$\\alpha$ matches a word $w$, consisting only of terminal letters, if $w$ can be\nobtained by replacing the variables of $\\alpha$ by terminal words. The matching\nproblem, i.e., deciding whether a given pattern matches a given word, was\nheavily investigated: it is NP-complete in general, but can be solved\nefficiently for classes of patterns with restricted structure. In this paper,\nwe approach this problem in a generalized setting, by considering approximate\npattern matching under Hamming distance. More precisely, we are interested in\nwhat is the minimum Hamming distance between $w$ and any word $u$ obtained by\nreplacing the variables of $\\alpha$ by terminal words. Firstly, we address the\nclass of regular patterns (in which no variable occurs twice) and propose\nefficient algorithms for this problem, as well as matching conditional lower\nbounds. We show that the problem can still be solved efficiently if we allow\nrepeated variables, but restrict the way the different variables can be\ninterleaved according to a locality parameter. However, as soon as we allow a\nvariable to occur more than once and its occurrences can be interleaved\narbitrarily with those of other variables, even if none of them occurs more\nthan once, the problem becomes intractable.\n", "versions": [{"version": "v1", "created": "Fri, 11 Jun 2021 09:00:37 GMT"}], "update_date": "2021-06-14", "authors_parsed": [["Gawrychowski", "Pawe\u0142", ""], ["Manea", "Florin", ""], ["Siemer", "Stefan", ""]]}, {"id": "2106.06745", "submitter": "Bader Abu Radi", "authors": "Bader Abu Radi and Orna Kupferman", "title": "Minimization and Canonization of GFG Transition-Based Automata", "comments": "28 pages, 9 figures. arXiv admin note: substantial text overlap with\n  arXiv:2009.10885", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While many applications of automata in formal methods can use\nnondeterministic automata, some applications, most notably synthesis, need\ndeterministic or good-for-games(GFG) automata. The latter are nondeterministic\nautomata that can resolve their nondeterministic choices in a way that only\ndepends on the past. The minimization problem for deterministic B\\\"uchi and\nco-B\\\"uchi word automata is NP-complete. In particular, no canonical minimal\ndeterministic automaton exists, and a language may have different minimal\ndeterministic automata. We describe a polynomial minimization algorithm for GFG\nco-B\\\"uchi word automata with transition-based acceptance. Thus, a run is\naccepting if it traverses a set $\\alpha$ of designated transitions only\nfinitely often. Our algorithm is based on a sequence of transformations we\napply to the automaton, on top of which a minimal quotient automaton is\ndefined. We use our minimization algorithm to show canonicity for\ntransition-based GFG co-B\\\"uchi word automata: all minimal automata have\nisomorphic safe components (namely components obtained by restricting the\ntransitions to these not in $\\alpha$) and once we saturate the automata with\n$\\alpha$-transitions, we get full isomorphism.\n", "versions": [{"version": "v1", "created": "Sat, 12 Jun 2021 11:06:07 GMT"}], "update_date": "2021-06-15", "authors_parsed": [["Radi", "Bader Abu", ""], ["Kupferman", "Orna", ""]]}, {"id": "2106.07233", "submitter": "Thorsten Wi{\\ss}mann", "authors": "Thorsten Wi{\\ss}mann", "title": "Minimality Notions via Factorization Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For the minimization of state-based systems (i.e. the reduction of the number\nof states while retaining the system's semantics), there are two obvious\naspects: removing unnecessary states of the system and merging redundant states\nin the system.\n  In the present article, we relate the two aspects on coalgebras by defining\nan abstract notion of minimality using factorization systems. We will find\ncriteria on the category that ensure uniqueness, existence, and functoriality\nof the minimization aspects, where the proofs instantiate to those for\nreachability and bisimilarity minimization in the standard coalgebra\nliterature. Finally, we will see how the two aspects of minimization interact\nand under which criteria they can be sequenced in any order, like in automata\nminimization.\n", "versions": [{"version": "v1", "created": "Mon, 14 Jun 2021 08:40:45 GMT"}], "update_date": "2021-06-15", "authors_parsed": [["Wi\u00dfmann", "Thorsten", ""]]}, {"id": "2106.07249", "submitter": "Jarkko Peltom\\\"aki", "authors": "Jarkko Peltom\\\"aki and Ville Salo", "title": "Automatic winning shifts", "comments": "28 pages, 5 figures, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  To each one-dimensional subshift $X$, we may associate a winning shift $W(X)$\nwhich arises from a combinatorial game played on the language of $X$.\nPreviously it has been studied what properties of $X$ does $W(X)$ inherit. For\nexample, $X$ and $W(X)$ have the same factor complexity and if $X$ is a sofic\nsubshift, then $W(X)$ is also sofic. In this paper, we develop a notion of\nautomaticity for $W(X)$, that is, we propose what it means that a vector\nrepresentation of $W(X)$ is accepted by a finite automaton.\n  Let $S$ be an abstract numeration system such that addition with respect to\n$S$ is a rational relation. Let $X$ be a subshift generated by an $S$-automatic\nword. We prove that as long as there is a bound on the number of nonzero\nsymbols in configurations of $W(X)$ (which follows from $X$ having sublinear\nfactor complexity), then $W(X)$ is accepted by a finite automaton, which can be\neffectively constructed from the description of $X$. We provide an explicit\nautomaton when $X$ is generated by certain automatic words such as the\nThue-Morse word.\n", "versions": [{"version": "v1", "created": "Mon, 14 Jun 2021 09:06:36 GMT"}], "update_date": "2021-06-15", "authors_parsed": [["Peltom\u00e4ki", "Jarkko", ""], ["Salo", "Ville", ""]]}, {"id": "2106.07750", "submitter": "Luca Mariot", "authors": "Luca Mariot", "title": "Hip to Be (Latin) Square: Maximal Period Sequences from Orthogonal\n  Cellular Automata", "comments": "16 pages, 3 figures, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Orthogonal Cellular Automata (OCA) have been recently investigated in the\nliterature as a new approach to construct orthogonal Latin squares for\ncryptographic applications such as secret sharing schemes. In this paper, we\nconsider OCA for a different cryptographic task, namely the generation of\npseudorandom sequences. The idea is to iterate a dynamical system where the\noutput of an OCA pair is fed back as a new set of coordinates on the superposed\nsquares. The main advantage is that OCA ensure a certain amount of diffusion in\nthe generated sequences, a property which is usually missing from traditional\nCA-based pseudorandom number generators. We study the problem of finding OCA\npairs with maximal period by first performing an exhaustive search up to local\nrules of diameter $d=5$, and then focusing on the subclass of linear\nbipermutive rules. In this case, we characterize the periods of the sequences\nin terms of the order of the subgroup generated by an invertible Sylvester\nmatrix. We finally devise an algorithm based on Lagrange's theorem to\nefficiently enumerate all linear OCA pairs of maximal period up to diameter\n$d=11$.\n", "versions": [{"version": "v1", "created": "Mon, 14 Jun 2021 20:42:10 GMT"}], "update_date": "2021-06-16", "authors_parsed": [["Mariot", "Luca", ""]]}, {"id": "2106.07990", "submitter": "Maxim Vidgof", "authors": "Adriano Augusto, Jan Mendling, Maxim Vidgof, Bastian Wurm", "title": "The Connection between Process Complexity of Event Sequences and Models\n  discovered by Process Mining", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Process mining is a research area focusing on the design of algorithms that\ncan automatically provide insights into business processes by analysing\nhistoric process execution data, known as event logs. Among the most popular\nalgorithms are those for automated process discovery, whose ultimate goal is to\ngenerate the best process model that summarizes the behaviour recorded in the\ninput event log. Over the past decade, several process discovery algorithms\nhave been proposed but, until now, this research was driven by the implicit\nassumption that a better algorithm would discover better process models, no\nmatter the characteristics of the input event log. In this paper, we take a\nstep back and question that assumption. Specifically, we investigate what are\nthe relations between measures capturing characteristics of the input event log\nand the quality of the discovered process models. To this end, we review the\nstate-of-the-art process complexity measures, propose a new process complexity\nmeasure based on graph entropy, and analyze this set of complexity measures on\nan extensive collection of event logs and corresponding automatically\ndiscovered process models. Our analysis shows that many process complexity\nmeasures correlate with the quality of the discovered process models,\ndemonstrating the potential of using complexity measures as predictors for the\nquality of process models discovered with state-of-the-art process discovery\nalgorithms. This finding is important for process mining research, as it\nhighlights that not only algorithms, but also connections between input data\nand output quality should be studied.\n", "versions": [{"version": "v1", "created": "Tue, 15 Jun 2021 09:10:08 GMT"}], "update_date": "2021-06-16", "authors_parsed": [["Augusto", "Adriano", ""], ["Mendling", "Jan", ""], ["Vidgof", "Maxim", ""], ["Wurm", "Bastian", ""]]}, {"id": "2106.08074", "submitter": "Todd Schmid", "authors": "Todd Schmid, Jurriaan Rot, and Alexandra Silva", "title": "On Star Expressions and Coalgebraic Completeness Theorems", "comments": "31 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  An open problem posed by Milner asks for a proof that a certain\naxiomatisation, which Milner showed is sound with respect to bisimilarity for\nregular expressions, is also complete. One of the main difficulties of the\nproblem is the lack of a full Kleene theorem, since there are automata that can\nnot be specified, up to bisimilarity, by an expression. Grabmayer and Fokkink\n(2020) characterise those automata that can be expressed by regular expressions\nwithout the constant 1, and use this characterisation to give a positive answer\nto Milner's question for this subset of expressions. In this paper, we analyse\nGrabmayer and Fokkink's proof of completeness from the perspective of universal\ncoalgebra, and thereby give an abstract account of their proof method. We then\ncompare this proof method to another approach to completeness proofs from\ncoalgebraic language theory. This culminates in two abstract proof methods for\ncompleteness, what we call the local and global approaches, and a description\nof when one method can be used in place of the other.\n", "versions": [{"version": "v1", "created": "Tue, 15 Jun 2021 12:04:32 GMT"}], "update_date": "2021-06-16", "authors_parsed": [["Schmid", "Todd", ""], ["Rot", "Jurriaan", ""], ["Silva", "Alexandra", ""]]}, {"id": "2106.09374", "submitter": "Kamil Khadiev", "authors": "Kamil Khadiev and Dmitry Kravchenko", "title": "Quantum algorithm for Dyck Language with Multiple Types of Brackets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.CC cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We consider the recognition problem of the Dyck Language generalized for\nmultiple types of brackets. We provide an algorithm with quantum query\ncomplexity $O(\\sqrt{n}(\\log n)^{0.5k})$, where $n$ is the length of input and\n$k$ is the maximal nesting depth of brackets. Additionally, we show the lower\nbound for this problem which is $O(\\sqrt{n}c^{k})$ for some constant $c$.\n  Interestingly, classical algorithms solving the Dyck Language for multiple\ntypes of brackets substantially differ form the algorithm solving the original\nDyck language. At the same time, quantum algorithms for solving both kinds of\nthe Dyck language are of similar nature and requirements.\n", "versions": [{"version": "v1", "created": "Thu, 17 Jun 2021 10:48:19 GMT"}], "update_date": "2021-06-18", "authors_parsed": [["Khadiev", "Kamil", ""], ["Kravchenko", "Dmitry", ""]]}, {"id": "2106.10541", "submitter": "Marie-Pierre B\\'eal", "authors": "Marie-Pierre B\\'eal and Maxime Crochemore", "title": "Checking whether a word is Hamming-isometric in linear time", "comments": "A second algorithm for checking whether a word is Hamming-isometric\n  is added using the result given in reference [5]", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A finite word $f$ is Hamming-isometric if for any two word $u$ and $v$ of\nsame length avoiding $f$, $u$ can be transformed into $v$ by changing one by\none all the letters on which $u$ differs from $v$, in such a way that all of\nthe new words obtained in this process also avoid~$f$. Words which are not\nHamming-isometric have been characterized as words having a border with two\nmismatches. We derive from this characterization a linear-time algorithm to\ncheck whether a word is Hamming-isometric. It is based on pattern matching\nalgorithms with $k$ mismatches. Lee-isometric words over a four-letter alphabet\nhave been characterized as words having a border with two Lee-errors. We derive\nfrom this characterization a linear-time algorithm to check whether a word over\nan alphabet of size four is Lee-isometric.\n", "versions": [{"version": "v1", "created": "Sat, 19 Jun 2021 17:41:30 GMT"}, {"version": "v2", "created": "Fri, 23 Jul 2021 09:36:31 GMT"}], "update_date": "2021-07-26", "authors_parsed": [["B\u00e9al", "Marie-Pierre", ""], ["Crochemore", "Maxime", ""]]}, {"id": "2106.10895", "submitter": "Uli Fahrenberg", "authors": "Uli Fahrenberg, Christian Johansen, Georg Struth, Krzysztof\n  Ziemia\\'nski", "title": "Posets with Interfaces for Concurrent Kleene Algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce posets with interfaces (iposets) and generalise the serial\ncomposition of posets to a new gluing composition of iposets. In partial order\nsemantics of concurrency, this amounts to designate events that continue their\nexecution across components. Alternatively, in terms of decomposing concurrent\nsystems, it allows cutting through some events, whereas serial composition may\ncut through edges only.\n  We show that iposets under gluing composition form a category, extending the\nmonoid of posets under serial composition, and a 2-category when enriched with\na subsumption order and a suitable parallel composition as a lax tensor. This\ngeneralises the interchange monoids used in concurrent Kleene algebra.\n  We also consider gp-iposets, which are generated from singletons by finitary\ngluing and parallel compositions. We show that the class includes the\nseries-parallel posets as well as the interval orders, which are also well\nstudied in concurrency theory. Finally, we show that not all posets are\ngp-iposets, exposing several posets that cannot occur as induced substructures\nof gp-iposets.\n", "versions": [{"version": "v1", "created": "Mon, 21 Jun 2021 07:22:36 GMT"}], "update_date": "2021-06-22", "authors_parsed": [["Fahrenberg", "Uli", ""], ["Johansen", "Christian", ""], ["Struth", "Georg", ""], ["Ziemia\u0144ski", "Krzysztof", ""]]}, {"id": "2106.11041", "submitter": "Dejan Ni\\v{c}kovi\\'c", "authors": "Nicolas Basset, Thao Dang, Felix Gigler, Cristinel Mateis, Dejan\n  Nickovic", "title": "Sampling of Shape Expressions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CY cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cyber-physical systems (CPS) are increasingly becoming driven by data, using\nmultiple types of sensors to capture huge amounts of data. Extraction and\ncharacterization of useful information from big streams of data is a\nchallenging problem. Shape expressions facilitate formal specification of rich\ntemporal patterns encountered in time series as well as in behaviors of CPS. In\nthis paper, we introduce a method for systematically sampling shape\nexpressions. The proposed approach combines methods for uniform sampling of\nautomata (for exploring qualitative shapes) with hit-and-run Monte Carlo\nsampling procedures (for exploring multi-dimensional parameter spaces defined\nby sets of possibly non-linear constraints). We study and implement several\npossible solutions and evaluate them in the context of visualization and\ntesting applications.\n", "versions": [{"version": "v1", "created": "Fri, 28 May 2021 07:29:37 GMT"}], "update_date": "2021-06-22", "authors_parsed": [["Basset", "Nicolas", ""], ["Dang", "Thao", ""], ["Gigler", "Felix", ""], ["Mateis", "Cristinel", ""], ["Nickovic", "Dejan", ""]]}, {"id": "2106.11505", "submitter": "EPTCS", "authors": "R. Ramanujam (Institute of Mathematical Sciences, Chennai)", "title": "Reasoning about Emergence of Collective Memory", "comments": "In Proceedings TARK 2021, arXiv:2106.10886", "journal-ref": "EPTCS 335, 2021, pp. 269-280", "doi": "10.4204/EPTCS.335.26", "report-no": null, "categories": "cs.FL cs.DC cs.SI", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We offer a very simple model of how collective memory may form. Agents keep\nsignalling within neighbourhoods, and depending on how many support each\nsignal, some signals \"win\" in that neighbourhood. By agents interacting between\ndifferent neighbourhoods, 'influence' spreads and sometimes, a collective\nsignal emerges. We propose a logic in which we can reason about such emergence\nof memory and present preliminary technical results on the logic.\n", "versions": [{"version": "v1", "created": "Tue, 22 Jun 2021 02:47:31 GMT"}], "update_date": "2021-06-23", "authors_parsed": [["Ramanujam", "R.", "", "Institute of Mathematical Sciences, Chennai"]]}, {"id": "2106.11703", "submitter": "Raussen Martin", "authors": "Martin Raussen", "title": "Connectivity of spaces of directed paths in geometric models for\n  concurrent computation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.AT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Higher Dimensional Automata (HDA) are higher dimensional relatives to\ntransition systems in concurrency theory taking into account to which degree\nvarious actions commute. Mathematically, they take the form of labelled cubical\ncomplexes. It is important to know, and challenging from a\ngeometric/topological perspective, whether the space of directed paths\n(executions in the model) between two vertices (states) is connected; more\ngenerally, to estimate higher connectedness of these path spaces.\n  This paper presents an approach for such an estimation for particularly\nsimple HDA modelling the access of a number of processors to a number of\nresources with given limited capacity each. It defines a spare capacity for a\nconcurrent program with prescribed periods of access of the processors to the\nresources. It shows that the connectedness of spaces of directed paths can be\nestimated (from above) by spare capacities. Moreover, spare capacities can also\nbe used to detect deadlocks and critical states in such a HDA.\n  The key theoretical ingredient is a transition from the calculation of local\nconnectedness bounds (of the upper links of vertices of an HDA) to global ones\nby applying a version of the nerve lemma due to Anders Bj\\\"orner.\n", "versions": [{"version": "v1", "created": "Tue, 22 Jun 2021 12:18:49 GMT"}], "update_date": "2021-06-23", "authors_parsed": [["Raussen", "Martin", ""]]}, {"id": "2106.12474", "submitter": "Michele Colledanchise", "authors": "Michele Colledanchise, Giuseppe Cicala, Daniele E. Domenichelli,\n  Lorenzo Natale, Armando Tacchella", "title": "Formalizing the Execution Context of Behavior Trees for Runtime\n  Verification of Deliberative Policies", "comments": "Accepted version of IROS2021 conference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.RO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we enable automated property verification of deliberative\ncomponents in robot control architectures. We focus on formalizing the\nexecution context of Behavior Trees (BTs) to provide a scalable, yet formally\ngrounded, methodology to enable runtime verification and prevent unexpected\nrobot behaviors. To this end, we consider a message-passing model that\naccommodates both synchronous and asynchronous composition of parallel\ncomponents, in which BTs and other components execute and interact according to\nthe communication patterns commonly adopted in robotic software architectures.\nWe introduce a formal property specification language to encode requirements\nand build runtime monitors. We performed a set of experiments, both on\nsimulations and on the real robot, demonstrating the feasibility of our\napproach in a realistic application and its integration in a typical robot\nsoftware architecture. We also provide an OS-level virtualization environment\nto reproduce the experiments in the simulated scenario.\n", "versions": [{"version": "v1", "created": "Wed, 23 Jun 2021 15:42:52 GMT"}, {"version": "v2", "created": "Thu, 29 Jul 2021 10:13:53 GMT"}], "update_date": "2021-07-30", "authors_parsed": [["Colledanchise", "Michele", ""], ["Cicala", "Giuseppe", ""], ["Domenichelli", "Daniele E.", ""], ["Natale", "Lorenzo", ""], ["Tacchella", "Armando", ""]]}, {"id": "2106.12525", "submitter": "C\\'elia Borlido", "authors": "C\\'elia Borlido and Mai Gehrke", "title": "Substitution Principle and semidirect products", "comments": "45 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL math.GN", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the classical theory of regular languages the concept of recognition by\nprofinite monoids is an important tool. Beyond regularity, Boolean spaces with\ninternal monoids (BiMs) were recently proposed as a generalization. On the\nother hand, fragments of logic defining regular languages can be studied\ninductively via the so-called \"Substitution Principle\". In this paper we make\nthe logical underpinnings of this principle explicit and extend it to arbitrary\nlanguages using Stone duality. Subsequently we show how it can be used to\nobtain topo-algebraic recognizers for classes of languages defined by a wide\nclass of first-order logic fragments. This naturally leads to a notion of\nsemidirect product of BiMs extending the classical such construction for\nprofinite monoids. Our main result is a generalization of Almeida and Weil's\nDecomposition Theorem for semidirect products from the profinite setting to\nthat of BiMs. This is a crucial step in a program to extend the profinite\nmethods of regular language theory to the setting of complexity theory.\n", "versions": [{"version": "v1", "created": "Wed, 23 Jun 2021 16:44:04 GMT"}], "update_date": "2021-06-24", "authors_parsed": [["Borlido", "C\u00e9lia", ""], ["Gehrke", "Mai", ""]]}, {"id": "2106.13852", "submitter": "Viktor Teren", "authors": "Viktor Teren, Jordi Cortadella and Tiziano Villa", "title": "Decomposition of transition systems into sets of synchronizing state\n  machines", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.AR cs.SY eess.SY", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Transition systems (TS) and Petri nets (PN) are important models of\ncomputation ubiquitous in formal methods for modeling systems. An important\nproblem is how to extract from a given TS a PN whose reachability graph is\nequivalent (with a suitable notion of equivalence) to the original TS.\n  This paper addresses the decomposition of transition systems into\nsynchronizing state machines (SMs), which are a class of Petri nets where each\ntransition has one incoming and one outgoing arc and all markings have exactly\none token. This is an important case of the general problem of extracting a PN\nfrom a TS. The decomposition is based on the theory of regions, and it is shown\nthat a property of regions called excitation-closure is a sufficient condition\nto guarantee the equivalence between the original TS and a decomposition into\nSMs.\n  An efficient algorithm is provided which solves the problem by reducing its\ncritical steps to the maximal independent set problem (to compute a minimal set\nof irredundant SMs) or to satisfiability (to merge the SMs). We report\nexperimental results that show a good trade-off between quality of results vs.\ncomputation time.\n", "versions": [{"version": "v1", "created": "Fri, 25 Jun 2021 19:15:15 GMT"}], "update_date": "2021-06-29", "authors_parsed": [["Teren", "Viktor", ""], ["Cortadella", "Jordi", ""], ["Villa", "Tiziano", ""]]}, {"id": "2106.14471", "submitter": "Dominique Perrin", "authors": "Dominique Perrin and Andrew Ryzhikov", "title": "Finitely generated submonoids", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We prove several results concerning finitely generated submonoids of the free\nmonoid. These results generalize those known for free submonoids. We prove in\nparticular that if $X=Y\\circ Z$ is a composition of finite sets of words with\n$Y$ complete, then $d(X)=d(Y)d(Z)$.\n", "versions": [{"version": "v1", "created": "Mon, 28 Jun 2021 08:35:53 GMT"}], "update_date": "2021-06-29", "authors_parsed": [["Perrin", "Dominique", ""], ["Ryzhikov", "Andrew", ""]]}, {"id": "2106.15311", "submitter": "Rick Erkens", "authors": "Rick Erkens, Jan Friso Groote", "title": "A Set Automaton to Locate All Pattern Matches in a Term", "comments": "Submitted to ICTAC 2021. Contains appendix with proofs", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Term pattern matching is the problem of finding all pattern matches in a\nsubject term, given a set of patterns. Finding efficient algorithms for this\nproblem is an important direction for research [19]. We present a new set\nautomaton solution for the term pattern matching problem that is based on match\nset derivatives where each function symbol in the subject pattern is visited\nexactly once. The algorithm allows for various traversal patterns over the\nsubject term and is particularly suited to search the subject term in parallel.\n", "versions": [{"version": "v1", "created": "Tue, 29 Jun 2021 12:26:22 GMT"}], "update_date": "2021-06-30", "authors_parsed": [["Erkens", "Rick", ""], ["Groote", "Jan Friso", ""]]}, {"id": "2106.15372", "submitter": "Lo\\\"ic Paulev\\'e", "authors": "Lo\\\"ic Paulev\\'e, Sylvain Sen\\'e", "title": "Non-deterministic updates of Boolean networks", "comments": "Accepted at AUTOMATA 2021", "journal-ref": null, "doi": "10.4230/OASIcs.AUTOMATA.2021.10", "report-no": null, "categories": "math.DS cs.FL q-bio.QM", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Boolean networks are discrete dynamical systems where each automaton has its\nown Boolean function for computing its state according to the configuration of\nthe network. The updating mode then determines how the configuration of the\nnetwork evolves over time. Many of updating modes from the literature,\nincluding synchronous and asynchronous modes, can be defined as the composition\nof elementary deterministic configuration updates, i.e., by functions mapping\nconfigurations of the network. Nevertheless, alternative dynamics have been\nintroduced using ad-hoc auxiliary objects, such as that resulting from binary\nprojections of Memory Boolean networks, or that resulting from additional\npseudo-states for Most Permissive Boolean networks. One may wonder whether\nthese latter dynamics can still be classified as updating modes of finite\nBoolean networks, or belong to a different class of dynamical systems. In this\npaper, we study the extension of updating modes to the composition of\nnon-deterministic updates, i.e., mapping sets of finite configurations. We show\nthat the above dynamics can be expressed in this framework, enabling a better\nunderstanding of them as updating modes of Boolean networks. More generally, we\nargue that non-deterministic updates pave the way to a unifying framework for\nexpressing complex updating modes, some of them enabling transitions that\ncannot be computed with elementary and non-elementary deterministic updates.\n", "versions": [{"version": "v1", "created": "Tue, 29 Jun 2021 12:57:11 GMT"}], "update_date": "2021-06-30", "authors_parsed": [["Paulev\u00e9", "Lo\u00efc", ""], ["Sen\u00e9", "Sylvain", ""]]}, {"id": "2106.15398", "submitter": "Anna Kalenkova", "authors": "Anna Kalenkova, Josep Carmona, Artem Polyvyanyy, Marcello La Rosa", "title": "Automated Repair of Process Models with Non-Local Constraints Using\n  State-Based Region Theory", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  State-of-the-art process discovery methods construct free-choice process\nmodels from event logs. Consequently, the constructed models do not take into\naccount indirect dependencies between events. Whenever the input behaviour is\nnot free-choice, these methods fail to provide a precise model. In this paper,\nwe propose a novel approach for enhancing free-choice process models by adding\nnon-free-choice constructs discovered a-posteriori via region-based techniques.\nThis allows us to benefit from the performance of existing process discovery\nmethods and the accuracy of the employed fundamental synthesis techniques. We\nprove that the proposed approach preserves fitness with respect to the event\nlog while improving the precision when indirect dependencies exist. The\napproach has been implemented and tested on both synthetic and real-life\ndatasets. The results show its effectiveness in repairing models discovered\nfrom event logs.\n", "versions": [{"version": "v1", "created": "Sat, 26 Jun 2021 21:14:04 GMT"}], "update_date": "2021-06-30", "authors_parsed": [["Kalenkova", "Anna", ""], ["Carmona", "Josep", ""], ["Polyvyanyy", "Artem", ""], ["La Rosa", "Marcello", ""]]}, {"id": "2106.15729", "submitter": "Franck Djeumou", "authors": "Franck Djeumou, Zhe Xu, Murat Cubuktepe, and Ufuk Topcu", "title": "Probabilistic Control of Heterogeneous Swarms Subject to Graph Temporal\n  Logic Specifications: A Decentralized and Scalable Approach", "comments": "Initial submission to TAC", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.MA cs.SY math.OC", "license": "http://creativecommons.org/publicdomain/zero/1.0/", "abstract": "  We develop a probabilistic control algorithm, $\\texttt{GTLProCo}$, for swarms\nof agents with heterogeneous dynamics and objectives, subject to high-level\ntask specifications. The resulting algorithm not only achieves decentralized\ncontrol of the swarm but also significantly improves scalability over\nstate-of-the-art existing algorithms. Specifically, we study a setting in which\nthe agents move along the nodes of a graph, and the high-level task\nspecifications for the swarm are expressed in a recently-proposed language\ncalled graph temporal logic (GTL). By constraining the distribution of the\nswarm over the nodes of the graph, GTL can specify a wide range of properties,\nincluding safety, progress, and response. $\\texttt{GTLProCo}$, agnostic to the\nnumber of agents comprising the swarm, controls the density distribution of the\nswarm in a decentralized and probabilistic manner. To this end, it synthesizes\na time-varying Markov chain modeling the time evolution of the density\ndistribution under the GTL constraints. We first identify a subset of GTL,\nnamely reach-avoid specifications, for which we can reduce the synthesis of\nsuch a Markov chain to either linear or semi-definite programs. Then, in the\ngeneral case, we formulate the synthesis of the Markov chain as a mixed-integer\nnonlinear program (MINLP). We exploit the structure of the problem to provide\nan efficient sequential mixed-integer linear programming scheme with trust\nregions to solve the MINLP. We empirically demonstrate that our sequential\nscheme is at least three orders of magnitude faster than off-the-shelf MINLP\nsolvers and illustrate the effectiveness of $\\texttt{GTLProCo}$ in several\nswarm scenarios.\n", "versions": [{"version": "v1", "created": "Tue, 29 Jun 2021 21:34:55 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Djeumou", "Franck", ""], ["Xu", "Zhe", ""], ["Cubuktepe", "Murat", ""], ["Topcu", "Ufuk", ""]]}, {"id": "2106.15867", "submitter": "D\\'avid K\\'osz\\'o", "authors": "Manfred Droste, Zolt\\'an F\\\"ul\\\"op, D\\'avid K\\'osz\\'o, Heiko Vogler", "title": "Finite-image property of weighted tree automata over past-finite\n  monotonic strong bimonoids", "comments": "42 pages, 4 figures, 1 algorithm", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider weighted tree automata over strong bimonoids (for short: wta). A\nwta $\\mathcal{A}$ has the finite-image property if its recognized weighted tree\nlanguage $[\\![\\mathcal{A}]\\!]$ has finite image; moreover, $\\mathcal{A}$ has\nthe preimage property if the preimage under $[\\![\\mathcal{A}]\\!]$ of each\nelement of the underlying strong bimonoid is a recognizable tree language. For\neach wta $\\mathcal{A}$ over a past-finite monotonic strong bimonoid we prove\nthe following results. In terms of $\\mathcal{A}$'s structural properties, we\ncharacterize whether it has the finite-image property. We characterize those\npast-finite monotonic strong bimonoids such that for each wta $\\mathcal{A}$ it\nis decidable whether $\\mathcal{A}$ has the finite-image property. In\nparticular, the finite-image property is decidable for wta over past-finite\nmonotonic semirings. Moreover, we prove that $\\mathcal{A}$ has the preimage\nproperty. All our results also hold for weighted string automata.\n", "versions": [{"version": "v1", "created": "Wed, 30 Jun 2021 07:51:00 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Droste", "Manfred", ""], ["F\u00fcl\u00f6p", "Zolt\u00e1n", ""], ["K\u00f3sz\u00f3", "D\u00e1vid", ""], ["Vogler", "Heiko", ""]]}, {"id": "2106.15878", "submitter": "Benjamin Maschler", "authors": "Matthias Wei{\\ss}, Philipp Marks, Benjamin Maschler, Dustin White,\n  Pascal Kesseli and Michael Weyrich", "title": "Towards establishing formal verification and inductive code synthesis in\n  the PLC domain", "comments": "8 pages, 6 figures, 1 table. Accepted for publication at IEEE INDIN\n  2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL cs.PL cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Nowadays, formal methods are used in various areas for the verification of\nprograms or for code generation from models in order to increase the quality of\nsoftware and to reduce costs. However, there are still fields in which formal\nmethods have not been widely adopted, despite the large set of possible\nbenefits offered. This is the case for the area of programmable logic\ncontrollers (PLC). This article aims to evaluate the potential of formal\nmethods in the context of PLC development. For this purpose, the general\nconcepts of formal methods are first introduced and then transferred to the PLC\narea, resulting in an engineering-oriented description of the technology that\nis based on common concepts from PLC development. Based on this description,\nPLC professionals with varying degrees of experience were interviewed for their\nperspective on the topic and to identify possible use cases within the PLC\ndomain. The survey results indicate the technology's high potential in the PLC\narea, either as a tool to directly support the developer or as a key element\nwithin a model-based systems engineering toolchain. The evaluation of the\nsurvey results is performed with the aid of a demo application that\ncommunicates with the Totally Integrated Automation Portal from Siemens and\ngenerates programs via Fastsynth, a model-based open source code generator.\nBenchmarks based on an industry-related PLC project show satisfactory synthesis\ntimes and a successful integration into the workflow of a PLC developer.\n", "versions": [{"version": "v1", "created": "Wed, 30 Jun 2021 08:13:10 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Wei\u00df", "Matthias", ""], ["Marks", "Philipp", ""], ["Maschler", "Benjamin", ""], ["White", "Dustin", ""], ["Kesseli", "Pascal", ""], ["Weyrich", "Michael", ""]]}, {"id": "2106.15892", "submitter": "Simon Jantsch", "authors": "Tobias John, Simon Jantsch, Christel Baier and Sascha Kl\\\"uppelholz", "title": "Determinization and Limit-determinization of Emerson-Lei automata", "comments": "29 pages, conference version accepted at ATVA'21", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study the problem of determinizing $\\omega$-automata whose acceptance\ncondition is defined on the transitions using Boolean formulas, also known as\ntransition-based Emerson-Lei automata (TELA). The standard approach to\ndeterminize TELA first constructs an equivalent generalized B\\\"uchi automaton\n(GBA), which is later determinized. We introduce three new ways of translating\nTELA to GBA. Furthermore, we give a new determinization construction which\ndeterminizes several GBA separately and combines them using a product\nconstruction. An experimental evaluation shows that the product approach is\ncompetitive when compared with state-of-the-art determinization procedures. We\nalso study limit-determinization of TELA and show that this can be done with a\nsingle-exponential blow-up, in contrast to the known double-exponential\nlower-bound for determinization. Finally, one version of the\nlimit-determinization procedure yields good-for-MDP automata which can be used\nfor quantitative probabilistic model checking.\n", "versions": [{"version": "v1", "created": "Wed, 30 Jun 2021 08:33:38 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["John", "Tobias", ""], ["Jantsch", "Simon", ""], ["Baier", "Christel", ""], ["Kl\u00fcppelholz", "Sascha", ""]]}, {"id": "2106.16197", "submitter": "Abuzer Yakaryilmaz", "authors": "Abuzer Yakary{\\i}lmaz", "title": "Improved constructions for succinct affine automata", "comments": "12 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Affine finite automata (AfA) can be more succinct than probabilistic and\nquantum finite automata when recognizing some regular languages with\nbounded-error. In this paper, we improve previously known constructions given\nfor the succinctness of AfAs in three ways. First, we replace some of fixed\nerror bounds with arbitrarily small error bounds. Second, we present new\nconstructions by using less states than the previous constructions. Third, we\nshow that any language recognized by a nondeterministic finite automaton (NFA)\nis also recognized by bounded-error AfAs having one more state, and so, AfAs\ninherit all succinct results by NFAs. As a special case, we also show that any\nlanguage recognized by a NFA is recognized by AfAs with zero error if the\nnumber of accepting path(s) for each member is exactly the same number.\n", "versions": [{"version": "v1", "created": "Wed, 30 Jun 2021 16:48:55 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Yakary\u0131lmaz", "Abuzer", ""]]}]