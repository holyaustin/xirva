[{"id": "1701.00650", "submitter": "EPTCS", "authors": "Ryota Nakayama (Nagoya University), Naoki Nishida (Nagoya University),\n  Masahiko Sakai (Nagoya University)", "title": "Sound Structure-Preserving Transformation for Weakly-Left-Linear\n  Deterministic Conditional Term Rewriting Systems", "comments": "In Proceedings WPTE 2016, arXiv:1701.00233", "journal-ref": "EPTCS 235, 2017, pp. 62-77", "doi": "10.4204/EPTCS.235.5", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we show that the SR transformation, a computationally\nequivalent transformation proposed by Serbanuta and Rosu, is a sound\nstructure-preserving transformation for weakly-left-linear deterministic\nconditional term rewriting systems. More precisely, we show that every\nweakly-left-linear deterministic conditional term rewriting system can be\nconverted to an equivalent weakly-left-linear and ultra-weakly-left-linear\ndeterministic conditional term rewriting system and prove that the SR\ntransformation is sound for weakly-left-linear and ultra-weakly-left-linear\ndeterministic conditional term rewriting systems. Here, soundness for a\nconditional term rewriting system means that reduction of the transformed\nunconditional term rewriting system creates no undesired reduction sequence for\nthe conditional system.\n", "versions": [{"version": "v1", "created": "Tue, 3 Jan 2017 11:10:52 GMT"}], "update_date": "2017-01-04", "authors_parsed": [["Nakayama", "Ryota", "", "Nagoya University"], ["Nishida", "Naoki", "", "Nagoya University"], ["Sakai", "Masahiko", "", "Nagoya University"]]}, {"id": "1701.00948", "submitter": "Gabriele Fici", "authors": "Gabriele Fici, Filippo Mignosi, Jeffrey Shallit", "title": "Abelian-Square-Rich Words", "comments": "To appear in Theoretical Computer Science. Corrected a flaw in the\n  proof of Proposition 7", "journal-ref": null, "doi": "10.1016/j.tcs.2017.02.012", "report-no": null, "categories": "cs.DM cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An abelian square is the concatenation of two words that are anagrams of one\nanother. A word of length $n$ can contain at most $\\Theta(n^2)$ distinct\nfactors, and there exist words of length $n$ containing $\\Theta(n^2)$ distinct\nabelian-square factors, that is, distinct factors that are abelian squares.\nThis motivates us to study infinite words such that the number of distinct\nabelian-square factors of length $n$ grows quadratically with $n$. More\nprecisely, we say that an infinite word $w$ is {\\it abelian-square-rich} if,\nfor every $n$, every factor of $w$ of length $n$ contains, on average, a number\nof distinct abelian-square factors that is quadratic in $n$; and {\\it uniformly\nabelian-square-rich} if every factor of $w$ contains a number of distinct\nabelian-square factors that is proportional to the square of its length. Of\ncourse, if a word is uniformly abelian-square-rich, then it is\nabelian-square-rich, but we show that the converse is not true in general. We\nprove that the Thue-Morse word is uniformly abelian-square-rich and that the\nfunction counting the number of distinct abelian-square factors of length $2n$\nof the Thue-Morse word is $2$-regular. As for Sturmian words, we prove that a\nSturmian word $s_{\\alpha}$ of angle $\\alpha$ is uniformly abelian-square-rich\nif and only if the irrational $\\alpha$ has bounded partial quotients, that is,\nif and only if $s_{\\alpha}$ has bounded exponent.\n", "versions": [{"version": "v1", "created": "Wed, 4 Jan 2017 10:16:30 GMT"}, {"version": "v2", "created": "Mon, 13 Feb 2017 16:02:50 GMT"}, {"version": "v3", "created": "Fri, 24 Feb 2017 17:14:54 GMT"}], "update_date": "2017-02-27", "authors_parsed": [["Fici", "Gabriele", ""], ["Mignosi", "Filippo", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1701.01045", "submitter": "Amber Settle", "authors": "Thiago Correa, Breno Gustavo, Lucas Lemos, Amber Settle", "title": "An Overview of Recent Solutions to and Lower Bounds for the Firing\n  Synchronization Problem", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL nlin.CG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Complex systems in a wide variety of areas such as biological modeling, image\nprocessing, and language recognition can be modeled using networks of very\nsimple machines called finite automata. Connecting subsystems modeled using\nfinite automata into a network allows for more computational power. One such\nnetwork, called a cellular automaton, consists of an n-dimensional array for n\n> 1 with a single finite automaton located at each point of the array. One of\nthe oldest problems associated with cellular automata is the firing\nsynchronization problem, originally proposed by John Myhill in 1957. As with\nany long-standing problem, there are a large number of solutions to the firing\nsynchronization problem. Our goal, and the contribution of this work, is to\nsummarize recent solutions to the problem. We focus primarily on solutions to\nthe original problem, that is, the problem where the network is a\none-dimensional array and there is a single initiator located at one of the\nends. We summarize both minimal-time and non-minimal-time solutions, with an\nemphasis on solutions that were published after 1998. We also focus on\nsolutions that minimize the number of states required by the finite automata.\nIn the process we also identify open problems that remain in terms of finding\nminimal-state solutions to the firing synchronization problem.\n", "versions": [{"version": "v1", "created": "Wed, 4 Jan 2017 15:19:51 GMT"}], "update_date": "2017-01-05", "authors_parsed": [["Correa", "Thiago", ""], ["Gustavo", "Breno", ""], ["Lemos", "Lucas", ""], ["Settle", "Amber", ""]]}, {"id": "1701.01190", "submitter": "Roman Kolpakov", "authors": "Roman Kolpakov", "title": "On the number of gapped repeats with arbitrary gap", "comments": "17 pages, 2 figures. arXiv admin note: text overlap with\n  arXiv:1309.4055, arXiv:1509.01221", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For any functions $f(x)$, $g(x)$ from $\\mathbb {N}$ to $\\mathbb {R}$ we call\nrepeats $uvu$ such that $g(|u|)\\le |v|\\le f(|u|)$ as {\\it $f,g$-gapped\nrepeats}. We study the possible number of $f,g$-gapped repeats in words of\nfixed length~$n$. For quite weak conditions on $f(x)$, $g(x)$ we obtain an\nupper bound on this number which is linear to~$n$.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jan 2017 01:01:05 GMT"}], "update_date": "2017-01-06", "authors_parsed": [["Kolpakov", "Roman", ""]]}, {"id": "1701.01580", "submitter": "Gabriele Fici", "authors": "Alessandro De Luca, Gabriele Fici, Luca Q. Zamboni", "title": "The sequence of open and closed prefixes of a Sturmian word", "comments": "Published in Advances in Applied Mathematics. Journal version of\n  arXiv:1306.2254", "journal-ref": "Advances in Applied Mathematics Volume 90, September 2017, Pages\n  27-45", "doi": "10.1016/j.aam.2017.04.007", "report-no": null, "categories": "cs.DM cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A finite word is closed if it contains a factor that occurs both as a prefix\nand as a suffix but does not have internal occurrences, otherwise it is open.\nWe are interested in the {\\it oc-sequence} of a word, which is the binary\nsequence whose $n$-th element is $0$ if the prefix of length $n$ of the word is\nopen, or $1$ if it is closed. We exhibit results showing that this sequence is\ndeeply related to the combinatorial and periodic structure of a word. In the\ncase of Sturmian words, we show that these are uniquely determined (up to\nrenaming letters) by their oc-sequence. Moreover, we prove that the class of\nfinite Sturmian words is a maximal element with this property in the class of\nbinary factorial languages. We then discuss several aspects of Sturmian words\nthat can be expressed through this sequence. Finally, we provide a linear-time\nalgorithm that computes the oc-sequence of a finite word, and a linear-time\nalgorithm that reconstructs a finite Sturmian word from its oc-sequence.\n", "versions": [{"version": "v1", "created": "Fri, 6 Jan 2017 09:13:16 GMT"}, {"version": "v2", "created": "Thu, 1 Jun 2017 09:25:20 GMT"}], "update_date": "2018-05-28", "authors_parsed": [["De Luca", "Alessandro", ""], ["Fici", "Gabriele", ""], ["Zamboni", "Luca Q.", ""]]}, {"id": "1701.01971", "submitter": "Thomas Wilke", "authors": "Sebastian Preugschat and Thomas Wilke", "title": "Backward deterministic and weak alternating $\\omega$-automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a direct transformation of weak alternating $\\omega$-automata into\nequivalent backward deterministic $\\omega$-automata and show (1) how it can be\nused to obtain a transformation of non-deterministic B\\\"uchi automata into\nequivalent backward deterministic automata and (2) that it yields optimal\nequivalent backward deterministic automata when applied to linear-time temporal\nlogic formulas. (1) uses the alternation-free fragment of the linear-time\n$\\mu$-calculus as an intermediate step; (2) is based on the straightforward\ntranslation of linear-time temporal logic into weak alternating\n$\\omega$-automata.\n", "versions": [{"version": "v1", "created": "Sun, 8 Jan 2017 15:25:53 GMT"}], "update_date": "2017-01-10", "authors_parsed": [["Preugschat", "Sebastian", ""], ["Wilke", "Thomas", ""]]}, {"id": "1701.02168", "submitter": "Martin Zimmermann", "authors": "Martin Zimmermann", "title": "Games with Costs and Delays", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We demonstrate the usefulness of adding delay to infinite games with\nquantitative winning conditions. In a delay game, one of the players may delay\nher moves to obtain a lookahead on her opponent's moves. We show that\ndetermining the winner of delay games with winning conditions given by parity\nautomata with costs is EXPTIME-complete and that exponential bounded lookahead\nis both sufficient and in general necessary. Thus, although the parity\ncondition with costs is a quantitative extension of the parity condition, our\nresults show that adding costs does not increase the complexity of delay games\nwith parity conditions.\n  Furthermore, we study a new phenomenon that appears in quantitative delay\ngames: lookahead can be traded for the quality of winning strategies and vice\nversa. We determine the extent of this tradeoff. In particular, even the\nsmallest lookahead allows to improve the quality of an optimal strategy from\nthe worst possible value to almost the smallest possible one. Thus, the benefit\nof introducing lookahead is twofold: not only does it allow the delaying player\nto win games she would lose without, but lookahead also allows her to improve\nthe quality of her winning strategies in games she wins even without lookahead.\n", "versions": [{"version": "v1", "created": "Mon, 9 Jan 2017 13:26:22 GMT"}, {"version": "v2", "created": "Thu, 20 Apr 2017 09:09:32 GMT"}], "update_date": "2017-04-21", "authors_parsed": [["Zimmermann", "Martin", ""]]}, {"id": "1701.02502", "submitter": "Olivier Gauwin", "authors": "F\\'elix Baschenis, Olivier Gauwin, Anca Muscholl and Gabriele Puppis", "title": "Untwisting two-way transducers in elementary time", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Functional transductions realized by two-way transducers (equivalently, by\nstreaming transducers and by MSO transductions) are the natural and standard\nnotion of \"regular\" mappings from words to words. It was shown recently\n(LICS'13) that it is decidable if such a transduction can be implemented by\nsome one-way transducer, but the given algorithm has non-elementary complexity.\nWe provide an algorithm of different flavor solving the above question, that\nhas double exponential space complexity. We further apply our technique to\ndecide whether the transduction realized by a two-way transducer can be\nimplemented by a sweeping transducer, with either known or unknown number of\npasses.\n", "versions": [{"version": "v1", "created": "Tue, 10 Jan 2017 10:02:12 GMT"}], "update_date": "2017-01-11", "authors_parsed": [["Baschenis", "F\u00e9lix", ""], ["Gauwin", "Olivier", ""], ["Muscholl", "Anca", ""], ["Puppis", "Gabriele", ""]]}, {"id": "1701.02673", "submitter": "Micha\\\"el Cadilhac", "authors": "Micha\\\"el Cadilhac, Charles Paperman", "title": "A Crevice on the Crane Beach: Finite-Degree Predicates", "comments": "Submitted", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  First-order logic (FO) over words is shown to be equiexpressive with FO\nequipped with a restricted set of numerical predicates, namely the order, a\nbinary predicate MSB$_0$, and the finite-degree predicates: FO[Arb] = FO[<,\nMSB$_0$, Fin].\n  The Crane Beach Property (CBP), introduced more than a decade ago, is true of\na logic if all the expressible languages admitting a neutral letter are\nregular.\n  Although it is known that FO[Arb] does not have the CBP, it is shown here\nthat the (strong form of the) CBP holds for both FO[<, Fin] and FO[<, MSB$_0$].\nThus FO[<, Fin] exhibits a form of locality and the CBP, and can still express\na wide variety of languages, while being one simple predicate away from the\nexpressive power of FO[Arb]. The counting ability of FO[<, Fin] is studied as\nan application.\n", "versions": [{"version": "v1", "created": "Tue, 10 Jan 2017 16:40:19 GMT"}, {"version": "v2", "created": "Wed, 11 Jan 2017 15:42:44 GMT"}, {"version": "v3", "created": "Thu, 12 Jan 2017 10:29:16 GMT"}], "update_date": "2017-01-13", "authors_parsed": [["Cadilhac", "Micha\u00ebl", ""], ["Paperman", "Charles", ""]]}, {"id": "1701.02692", "submitter": "Alonso Castillo-Ramirez", "authors": "Alonso Castillo-Ramirez and Maximilien Gadouleau", "title": "Von Neumann Regular Cellular Automata", "comments": "10 pages. Theorem 5 corrected from previous versions, in A.\n  Dennunzio, E. Formenti, L. Manzoni, A.E. Porreca (Eds.): Cellular Automata\n  and Discrete Complex Systems, AUTOMATA 2017, LNCS 10248, pp. 44-55, Springer,\n  2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For any group $G$ and any set $A$, a cellular automaton (CA) is a\ntransformation of the configuration space $A^G$ defined via a finite memory set\nand a local function. Let $\\text{CA}(G;A)$ be the monoid of all CA over $A^G$.\nIn this paper, we investigate a generalisation of the inverse of a CA from the\nsemigroup-theoretic perspective. An element $\\tau \\in \\text{CA}(G;A)$ is von\nNeumann regular (or simply regular) if there exists $\\sigma \\in \\text{CA}(G;A)$\nsuch that $\\tau \\circ \\sigma \\circ \\tau = \\tau$ and $\\sigma \\circ \\tau \\circ\n\\sigma = \\sigma$, where $\\circ$ is the composition of functions. Such an\nelement $\\sigma$ is called a generalised inverse of $\\tau$. The monoid\n$\\text{CA}(G;A)$ itself is regular if all its elements are regular. We\nestablish that $\\text{CA}(G;A)$ is regular if and only if $\\vert G \\vert = 1$\nor $\\vert A \\vert = 1$, and we characterise all regular elements in\n$\\text{CA}(G;A)$ when $G$ and $A$ are both finite. Furthermore, we study\nregular linear CA when $A= V$ is a vector space over a field $\\mathbb{F}$; in\nparticular, we show that every regular linear CA is invertible when $G$ is\ntorsion-free elementary amenable (e.g. when $G=\\mathbb{Z}^d, \\ d \\in\n\\mathbb{N}$) and $V=\\mathbb{F}$, and that every linear CA is regular when $V$\nis finite-dimensional and $G$ is locally finite with $\\text{Char}(\\mathbb{F})\n\\nmid o(g)$ for all $g \\in G$.\n", "versions": [{"version": "v1", "created": "Tue, 10 Jan 2017 17:12:29 GMT"}, {"version": "v2", "created": "Thu, 23 Mar 2017 14:55:06 GMT"}, {"version": "v3", "created": "Fri, 26 May 2017 16:51:20 GMT"}], "update_date": "2017-05-29", "authors_parsed": [["Castillo-Ramirez", "Alonso", ""], ["Gadouleau", "Maximilien", ""]]}, {"id": "1701.02808", "submitter": "S{\\l}awomir Lasota", "authors": "Wojciech Czerwi\\'nski and S{\\l}awomir Lasota", "title": "Regular Separability of One Counter Automata", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 2 (June 11,\n  2019) lmcs:5563", "doi": "10.23638/LMCS-15(2:20)2019", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The regular separability problem asks, for two given languages, if there\nexists a regular language including one of them but disjoint from the other.\nOur main result is decidability, and PSpace-completeness, of the regular\nseparability problem for languages of one counter automata without zero tests\n(also known as one counter nets). This contrasts with undecidability of the\nregularity problem for one counter nets, and with undecidability of the regular\nseparability problem for one counter automata, which is our second result.\n", "versions": [{"version": "v1", "created": "Tue, 10 Jan 2017 23:15:29 GMT"}, {"version": "v2", "created": "Thu, 29 Mar 2018 15:43:46 GMT"}, {"version": "v3", "created": "Fri, 1 Mar 2019 13:47:05 GMT"}, {"version": "v4", "created": "Sat, 1 Jun 2019 15:43:40 GMT"}, {"version": "v5", "created": "Mon, 10 Jun 2019 08:26:43 GMT"}], "update_date": "2019-09-04", "authors_parsed": [["Czerwi\u0144ski", "Wojciech", ""], ["Lasota", "S\u0142awomir", ""]]}, {"id": "1701.02903", "submitter": "Guillermo P\\'erez", "authors": "Emmanuel Filiot, Isma\\\"el Jecker, Nathan Lhote, Guillermo A. P\\'erez,\n  and Jean-Fran\\c{c}ois Raskin", "title": "On Delay and Regret Determinization of Max-Plus Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Decidability of the determinization problem for weighted automata over the\nsemiring $(\\mathbb{Z} \\cup {-\\infty}, \\max, +)$, WA for short, is a\nlong-standing open question. We propose two ways of approaching it by\nconstraining the search space of deterministic WA: k-delay and r-regret. A WA N\nis k-delay determinizable if there exists a deterministic automaton D that\ndefines the same function as N and for all words {\\alpha} in the language of N,\nthe accepting run of D on {\\alpha} is always at most k-away from a maximal\naccepting run of N on {\\alpha}. That is, along all prefixes of the same length,\nthe absolute difference between the running sums of weights of the two runs is\nat most k. A WA N is r-regret determinizable if for all words {\\alpha} in its\nlanguage, its non-determinism can be resolved on the fly to construct a run of\nN such that the absolute difference between its value and the value assigned to\n{\\alpha} by N is at most r.\n  We show that a WA is determinizable if and only if it is k-delay\ndeterminizable for some k. Hence deciding the existence of some k is as\ndifficult as the general determinization problem. When k and r are given as\ninput, the k-delay and r-regret determinization problems are shown to be\nEXPtime-complete. We also show that determining whether a WA is r-regret\ndeterminizable for some r is in EXPtime.\n", "versions": [{"version": "v1", "created": "Wed, 11 Jan 2017 09:48:53 GMT"}, {"version": "v2", "created": "Fri, 3 Mar 2017 18:52:37 GMT"}], "update_date": "2017-03-06", "authors_parsed": [["Filiot", "Emmanuel", ""], ["Jecker", "Isma\u00ebl", ""], ["Lhote", "Nathan", ""], ["P\u00e9rez", "Guillermo A.", ""], ["Raskin", "Jean-Fran\u00e7ois", ""]]}, {"id": "1701.02927", "submitter": "Sebastian Muskalla", "authors": "Mohamed Faouzi Atig, Roland Meyer, Sebastian Muskalla, Prakash\n  Saivasan", "title": "On the Upward/Downward Closures of Petri Nets", "comments": "The conference version of this paper has been published in the\n  proceedings of the 42nd International Symposium on Mathematical Foundations\n  of Computer Science, MFCS 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the size and the complexity of computing finite state automata (FSA)\nrepresenting and approximating the downward and the upward closure of Petri net\nlanguages with coverability as the acceptance condition. We show how to\nconstruct an FSA recognizing the upward closure of a Petri net language in\ndoubly-exponential time, and therefore the size is at most doubly exponential.\nFor downward closures, we prove that the size of the minimal automata can be\nnon-primitive recursive. In the case of BPP nets, a well-known subclass of\nPetri nets, we show that an FSA accepting the downward/upward closure can be\nconstructed in exponential time. Furthermore, we consider the problem of\nchecking whether a simple regular language is included in the downward/upward\nclosure of a Petri net/BPP net language. We show that this problem is\nEXPSPACE-complete (resp. NP-complete) in the case of Petri nets (resp. BPP\nnets). Finally, we show that it is decidable whether a Petri net language is\nupward/downward closed. To this end, we prove that one can decide whether a\ngiven regular language is a subset of a Petri net coverability language.\n", "versions": [{"version": "v1", "created": "Wed, 11 Jan 2017 11:20:31 GMT"}, {"version": "v2", "created": "Fri, 6 Apr 2018 17:05:17 GMT"}], "update_date": "2018-04-09", "authors_parsed": [["Atig", "Mohamed Faouzi", ""], ["Meyer", "Roland", ""], ["Muskalla", "Sebastian", ""], ["Saivasan", "Prakash", ""]]}, {"id": "1701.02947", "submitter": "Sebastian Muskalla", "authors": "Roland Meyer, Sebastian Muskalla, Elisabeth Neumann", "title": "Liveness Verification and Synthesis: New Algorithms for Recursive\n  Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problems of liveness verification and liveness synthesis for\nrecursive programs. The liveness verification problem (LVP) is to decide\nwhether a given omega-context-free language is contained in a given\nomega-regular language. The liveness synthesis problem (LSP) is to compute a\nstrategy so that a given omega-context-free game, when played along the\nstrategy, is guaranteed to derive a word in a given omega-regular language. The\nproblems are known to be EXPTIME-complete and EXPTIME-complete, respectively.\nOur contributions are new algorithms with optimal time complexity. For LVP, we\ngeneralize recent lasso-finding algorithms (also known as Ramsey-based\nalgorithms) from finite to recursive programs. For LSP, we generalize a recent\nsummary-based algorithm from finite to infinite words. Lasso finding and\nsummaries have proven to be efficient in a number of implementations for the\nfinite state and finite word setting.\n", "versions": [{"version": "v1", "created": "Wed, 11 Jan 2017 12:21:51 GMT"}], "update_date": "2017-01-12", "authors_parsed": [["Meyer", "Roland", ""], ["Muskalla", "Sebastian", ""], ["Neumann", "Elisabeth", ""]]}, {"id": "1701.03297", "submitter": "Murray Elder", "authors": "Volker Diekert and Murray Elder", "title": "Solutions to twisted word equations and equations in virtually free\n  groups", "comments": "70 pages, 13 figures. An extended abstract of a preliminary version\n  of this paper was presented at ICALP 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.CC cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is well known that the problem solving equations in virtually free groups\ncan be reduced to the problem of solving twisted word equations with regular\nconstraints over free monoids with involution. In this paper we prove that the\nset of all solutions of a twisted word equation is an EDT0L language whose\nspecification can be computed in $\\mathsf{PSPACE}$. Within the same complexity\nbound we can decide whether the solution set is empty, finite, or infinite.\n  In the second part of the paper we apply the results for twisted equations to\nobtain in $\\mathsf{PSPACE}$ an EDT0L description of the solution set of\nequations with rational constraints for finitely generated virtually free\ngroups in standard normal forms with respect to a natural set of generators. If\nthe rational constraints are given by a homomorphism into a fixed (or \"small\nenough\") finite monoid, then our algorithms can be implemented in\n$\\mathsf{NSPACE}(n^2\\log n)$, that is, in quasi-quadratic nondeterministic\nspace.\n  Our results generalize the work by Lohrey and S\\'enizergues (ICALP 2006) and\nDahmani and Guirardel (J. of Topology 2010) with respect to both complexity and\nexpressive power. Neither paper gave any concrete complexity bound and the\nresults in these papers are stated for subsets of solutions only, whereas our\nresults concern all solutions.\n", "versions": [{"version": "v1", "created": "Thu, 12 Jan 2017 10:51:33 GMT"}, {"version": "v2", "created": "Fri, 4 May 2018 07:32:48 GMT"}, {"version": "v3", "created": "Sun, 18 Aug 2019 01:31:16 GMT"}, {"version": "v4", "created": "Tue, 20 Aug 2019 08:22:35 GMT"}, {"version": "v5", "created": "Sun, 1 Dec 2019 22:03:26 GMT"}], "update_date": "2019-12-03", "authors_parsed": [["Diekert", "Volker", ""], ["Elder", "Murray", ""]]}, {"id": "1701.03670", "submitter": "Luc Dartois", "authors": "Luc Dartois and Emmanuel Filiot and Nathan Lhote", "title": "Logics for Word Transductions with Synthesis", "comments": "10 pages + appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a logic, called LT, to express properties of transductions, i.e.\nbinary relations from input to output (finite) words. In LT, the input/output\ndependencies are modelled via an origin function which associates to any\nposition of the output word, the input position from which it originates. LT is\nwell-suited to express relations (which are not necessarily functional), and\ncan express all regular functional transductions, i.e. transductions definable\nfor instance by deterministic two-way transducers. Despite its high expressive\npower, LT has decidable satisfiability and equivalence problems, with tight\nnon-elementary and elementary complexities, depending on specific\nrepresentation of LT-formulas. Our main contribution is a synthesis result:\nfrom any transduction R defined in LT , it is possible to synthesise a regular\nfunctional transduction f such that for all input words u in the domain of R, f\nis defined and (u,f(u)) belongs to R. As a consequence, we obtain that any\nfunctional transduction is regular iff it is LT-definable. We also investigate\nthe algorithmic and expressiveness properties of several extensions of LT, and\nexplicit a correspondence between transductions and data words. As a\nside-result, we obtain a new decidable logic for data words.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jan 2017 13:57:07 GMT"}, {"version": "v2", "created": "Wed, 15 Feb 2017 12:32:45 GMT"}, {"version": "v3", "created": "Tue, 26 Sep 2017 11:43:43 GMT"}, {"version": "v4", "created": "Wed, 30 May 2018 11:35:47 GMT"}], "update_date": "2018-05-31", "authors_parsed": [["Dartois", "Luc", ""], ["Filiot", "Emmanuel", ""], ["Lhote", "Nathan", ""]]}, {"id": "1701.03768", "submitter": "Marek Szyku{\\l}a", "authors": "Robert Ferens and Marek Szyku{\\l}a", "title": "Complexity of regular bifix-free languages", "comments": "20 pages, 1 figure, 4 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study descriptive complexity properties of the class of regular bifix-free\nlanguages, which is the intersection of prefix-free and suffix-free regular\nlanguages. We show that there exist a single ternary universal (stream of)\nbifix-free languages that meet all the bounds for the state complexity basic\noperations (Boolean operations, product, star, and reversal). This is in\ncontrast with suffix-free languages, where it is known that there does not\nexist such a stream. Then we present a stream of bifix-free languages that is\nmost complex in terms of all basic operations, syntactic complexity, and the\nnumber of atoms and their complexities, which requires a superexponential\nalphabet.\n  We also complete the previous results by characterizing state complexity of\nproduct, star, and reversal, and establishing tight upper bounds for atom\ncomplexities of bifix-free languages. We show that to meet the bound for\nreversal we require at least 3 letters and to meet the bound for atom\ncomplexities $n+1$ letters are sufficient and necessary. For the cases of\nproduct, star, and reversal we show that there are no gaps (magic numbers) in\nthe interval of possible state complexities of the languages resulted from an\noperation; in particular, the state complexity of the product $L_m L_n$ is\nalways $m+n-2$, while of the star is either $n-1$ or $n-2$.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jan 2017 18:31:53 GMT"}], "update_date": "2017-01-16", "authors_parsed": [["Ferens", "Robert", ""], ["Szyku\u0142a", "Marek", ""]]}, {"id": "1701.03944", "submitter": "Janusz Brzozowski", "authors": "Janusz A. Brzozowski, Sylvie Davies", "title": "Most Complex Non-Returning Regular Languages", "comments": "22 pages, 6 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A regular language $L$ is non-returning if in the minimal deterministic\nfinite automaton accepting it there are no transitions into the initial state.\nEom, Han and Jir\\'askov\\'a derived upper bounds on the state complexity of\nboolean operations and Kleene star, and proved that these bounds are tight\nusing two different binary witnesses. They derived upper bounds for\nconcatenation and reversal using three different ternary witnesses. These five\nwitnesses use a total of six different transformations. We show that for each\n$n\\ge 4$ there exists a ternary witness of state complexity $n$ that meets the\nbound for reversal and that at least three letters are needed to meet this\nbound. Moreover, the restrictions of this witness to binary alphabets meet the\nbounds for product, star, and boolean operations. We also derive tight upper\nbounds on the state complexity of binary operations that take arguments with\ndifferent alphabets. We prove that the maximal syntactic semigroup of a\nnon-returning language has $(n-1)^n$ elements and requires at least\n$\\binom{n}{2}$ generators. We find the maximal state complexities of atoms of\nnon-returning languages. Finally, we show that there exists a most complex\nnon-returning language that meets the bounds for all these complexity measures.\n", "versions": [{"version": "v1", "created": "Sat, 14 Jan 2017 16:29:01 GMT"}], "update_date": "2017-01-17", "authors_parsed": [["Brzozowski", "Janusz A.", ""], ["Davies", "Sylvie", ""]]}, {"id": "1701.04045", "submitter": "Valentin W\\\"ustholz", "authors": "Valentin W\\\"ustholz and Oswaldo Olivo and Marijn J. H. Heule and Isil\n  Dillig", "title": "Static Detection of DoS Vulnerabilities in Programs that use Regular\n  Expressions (Extended Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In an algorithmic complexity attack, a malicious party takes advantage of the\nworst-case behavior of an algorithm to cause denial-of-service. A prominent\nalgorithmic complexity attack is regular expression denial-of-service (ReDoS),\nin which the attacker exploits a vulnerable regular expression by providing a\ncarefully-crafted input string that triggers worst-case behavior of the\nmatching algorithm. This paper proposes a technique for automatically finding\nReDoS vulnerabilities in programs. Specifically, our approach automatically\nidentifies vulnerable regular expressions in the program and determines whether\nan \"evil\" input string can be matched against a vulnerable regular expression.\nWe have implemented our proposed approach in a tool called REXPLOITER and found\n41 exploitable security vulnerabilities in Java web applications.\n", "versions": [{"version": "v1", "created": "Sun, 15 Jan 2017 14:05:07 GMT"}], "update_date": "2017-01-17", "authors_parsed": [["W\u00fcstholz", "Valentin", ""], ["Olivo", "Oswaldo", ""], ["Heule", "Marijn J. H.", ""], ["Dillig", "Isil", ""]]}, {"id": "1701.04288", "submitter": "Jad Hamza", "authors": "Mika\\\"el Mayer, Jad Hamza, Viktor Kuncak", "title": "Polynomial-Time Proactive Synthesis of Tree-to-String Functions from\n  Examples", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Synthesis from examples enables non-expert users to generate programs by\nspecifying examples of their behavior. A domain-specific form of such synthesis\nhas been recently deployed in a widely used spreadsheet software product. In\nthis paper we contribute to foundations of such techniques and present a\ncomplete algorithm for synthesis of a class of recursive functions defined by\nstructural recursion over a given algebraic data type definition. The functions\nwe consider map an algebraic data type to a string; they are useful for, e.g.,\npretty printing and serialization of programs and data. We formalize our\nproblem as learning deterministic sequential top-down tree-to-string\ntransducers with a single state.\n  The first problem we consider is learning a tree-to-string transducer from\nany set of input/output examples provided by the user. We show that this\nproblem is NP-complete in general, but can be solved in polynomial time under a\n(practically useful) closure condition that each subtree of a tree in the\ninput/output example set is also part of the input/output examples.\n  Because coming up with relevant input/output examples may be difficult for\nthe user while creating hard constraint problems for the synthesizer, we also\nstudy a more automated active learning scenario in which the algorithm chooses\nthe inputs for which the user provides the outputs. Our algorithm asks a\nworst-case linear number of queries as a function of the size of the algebraic\ndata type definition to determine a unique transducer.\n", "versions": [{"version": "v1", "created": "Mon, 16 Jan 2017 13:47:26 GMT"}, {"version": "v2", "created": "Wed, 24 May 2017 11:12:12 GMT"}], "update_date": "2017-05-25", "authors_parsed": [["Mayer", "Mika\u00ebl", ""], ["Hamza", "Jad", ""], ["Kuncak", "Viktor", ""]]}, {"id": "1701.04632", "submitter": "Pierre-Alain Reynier", "authors": "Laure Daviaud and Ismael Jecker and Pierre-Alain Reynier and Didier\n  Villevalois", "title": "Degree of sequentiality of weighted automata", "comments": "35 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Weighted automata (WA) are an important formalism to describe quantitative\nproperties. Obtaining equivalent deterministic machines is a longstanding\nresearch problem. In this paper we consider WA with a set semantics, meaning\nthat the semantics is given by the set of weights of accepting runs. We focus\non multi-sequential WA that are defined as finite unions of sequential WA. The\nproblem we address is to minimize the size of this union. We call this minimum\nthe degree of sequentiality of (the relation realized by) the WA. For a given\npositive integer k, we provide multiple characterizations of relations realized\nby a union of k sequential WA over an infinitary finitely generated group: a\nLipschitz-like machine independent property, a pattern on the automaton (a new\ntwinning property) and a subclass of cost register automata. When possible, we\neffectively translate a WA into an equivalent union of k sequential WA. We also\nprovide a decision procedure for our twinning property for commutative\ncomputable groups thus allowing to compute the degree of sequentiality. Last,\nwe show that these results also hold for word transducers and that the\nassociated decision problem is Pspace-complete.\n", "versions": [{"version": "v1", "created": "Tue, 17 Jan 2017 11:56:50 GMT"}], "update_date": "2017-01-18", "authors_parsed": [["Daviaud", "Laure", ""], ["Jecker", "Ismael", ""], ["Reynier", "Pierre-Alain", ""], ["Villevalois", "Didier", ""]]}, {"id": "1701.05001", "submitter": "Barbara K\\\"onig", "authors": "Filippo Bonchi, Barbara K\\\"onig, Sebastian K\\\"upper", "title": "Up-To Techniques for Weighted Systems (Extended Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show how up-to techniques for (bi-)similarity can be used in the setting\nof weighted systems. The problems we consider are language equivalence,\nlanguage inclusion and the threshold problem (also known as universality\nproblem) for weighted automata. We build a bisimulation relation on the fly and\nwork up-to congruence and up-to similarity. This requires to determine whether\na pair of vectors (over a semiring) is in the congruence closure of a given\nrelation of vectors. This problem is considered for rings and l-monoids, for\nthe latter we provide a rewriting algorithm and show its confluence and\ntermination. We then explain how to apply these up-to techniques to weighted\nautomata and provide runtime results.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jan 2017 10:33:52 GMT"}, {"version": "v2", "created": "Mon, 23 Jan 2017 08:29:17 GMT"}], "update_date": "2017-01-24", "authors_parsed": [["Bonchi", "Filippo", ""], ["K\u00f6nig", "Barbara", ""], ["K\u00fcpper", "Sebastian", ""]]}, {"id": "1701.05160", "submitter": "Christian Schilling", "authors": "Matthias Heizmann, Christian Schilling, Daniel Tischner", "title": "Minimization of Visibly Pushdown Automata Using Partial Max-SAT", "comments": "extended version", "journal-ref": "TACAS 2017", "doi": "10.1007/978-3-662-54577-5_27", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  We consider the problem of state-space reduction for nondeterministic\nweakly-hierarchical visibly pushdown automata (VPA). VPA recognize a robust and\nalgorithmically tractable fragment of context-free languages that is natural\nfor modeling programs.\n  We define an equivalence relation that is sufficient for language-preserving\nquotienting of VPA. Our definition allows to merge states that have different\nbehavior, as long as they show the same behavior for reachable equivalent\nstacks. We encode the existence of such a relation as a Boolean partial maximum\nsatisfiability (PMax-SAT) problem and present an algorithm that quickly finds\nsatisfying assignments. These assignments are sub-optimal solutions to the\nPMax-SAT problem but can still lead to a significant reduction of states.\n  We integrated our method in the automata-based software verifier Ultimate\nAutomizer and show performance improvements on benchmarks from the software\nverification competition SV-COMP.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jan 2017 17:37:52 GMT"}, {"version": "v2", "created": "Tue, 18 Apr 2017 13:35:05 GMT"}], "update_date": "2017-04-19", "authors_parsed": [["Heizmann", "Matthias", ""], ["Schilling", "Christian", ""], ["Tischner", "Daniel", ""]]}, {"id": "1701.05303", "submitter": "Pawe{\\l} Parys", "authors": "Pawe{\\l} Parys", "title": "Intersection Types and Counting", "comments": "Full version (with appendix) of a conference paper from Eighth\n  Workshop on Intersection Types and Related Systems", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new approach to the following meta-problem: given a quantitative\nproperty of trees, design a type system such that the desired property for the\ntree generated by an infinitary ground $\\lambda$-term corresponds to some\nproperty of a derivation of a type for this $\\lambda$-term, in this type\nsystem.\n  Our approach is presented in the particular case of the language finiteness\nproblem for nondeterministic higher-order recursion schemes (HORSes): given a\nnondeterministic HORS, decide whether the set of all finite trees generated by\nthis HORS is finite. We give a type system such that the HORS can generate a\ntree of an arbitrarily large finite size if and only if in the type system we\ncan obtain derivations that are arbitrarily large, in an appropriate sense; the\nlatter condition can be easily decided.\n", "versions": [{"version": "v1", "created": "Thu, 19 Jan 2017 05:33:29 GMT"}], "update_date": "2017-01-20", "authors_parsed": [["Parys", "Pawe\u0142", ""]]}, {"id": "1701.05738", "submitter": "Jan K\\v{r}et\\'insk\\'y", "authors": "Jan K\\v{r}et\\'insk\\'y and Tobias Meggendorfer and Clara Waldmann and\n  Maximilian Weininger", "title": "Index appearance record for transforming Rabin automata into parity\n  automata", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-662-54577-5_26", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Transforming deterministic $\\omega$-automata into deterministic parity\nautomata is traditionally done using variants of appearance records. We present\na more efficient variant of this approach, tailored to Rabin automata, and\nseveral optimizations applicable to all appearance records. We compare the\nmethods experimentally and find out that our method produces smaller automata\nthan previous approaches. Moreover, the experiments demonstrate the potential\nof our method for LTL synthesis, using LTL-to-Rabin translators. It leads to\nsignificantly smaller parity automata when compared to state-of-the-art\napproaches on complex formulae.\n", "versions": [{"version": "v1", "created": "Fri, 20 Jan 2017 09:52:01 GMT"}], "update_date": "2021-02-02", "authors_parsed": [["K\u0159et\u00ednsk\u00fd", "Jan", ""], ["Meggendorfer", "Tobias", ""], ["Waldmann", "Clara", ""], ["Weininger", "Maximilian", ""]]}, {"id": "1701.06040", "submitter": "Giacomo Micheli", "authors": "Andrea Ferraguti, Giacomo Micheli and Reto Schnyder", "title": "Irreducible compositions of degree two polynomials over finite fields\n  have regular structure", "comments": "To appear in The Quarterly Journal of Mathematics", "journal-ref": null, "doi": "10.1093/qmath/hay015", "report-no": null, "categories": "math.NT cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let $q$ be an odd prime power and $D$ be the set of monic irreducible\npolynomials in $\\mathbb F_q[x]$ which can be written as a composition of monic\ndegree two polynomials. In this paper we prove that $D$ has a natural regular\nstructure by showing that there exists a finite automaton having $D$ as\naccepted language. Our method is constructive.\n", "versions": [{"version": "v1", "created": "Sat, 21 Jan 2017 15:24:35 GMT"}, {"version": "v2", "created": "Mon, 7 Aug 2017 16:23:45 GMT"}, {"version": "v3", "created": "Fri, 16 Mar 2018 15:33:46 GMT"}], "update_date": "2019-02-13", "authors_parsed": [["Ferraguti", "Andrea", ""], ["Micheli", "Giacomo", ""], ["Schnyder", "Reto", ""]]}, {"id": "1701.06103", "submitter": "Jan K\\v{r}et\\'insk\\'y", "authors": "Javier Esparza and Jan K\\v{r}et\\'insk\\'y and Jean-Fran\\c{c}ois Raskin\n  and Salomon Sickert", "title": "From LTL and Limit-Deterministic B\\\"uchi Automata to Deterministic\n  Parity Automata", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-662-54577-5_25", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Controller synthesis for general linear temporal logic (LTL) objectives is a\nchallenging task. The standard approach involves translating the LTL objective\ninto a deterministic parity automaton (DPA) by means of the Safra-Piterman\nconstruction. One of the challenges is the size of the DPA, which often grows\nvery fast in practice, and can reach double exponential size in the length of\nthe LTL formula. In this paper we describe a single exponential translation\nfrom limit-deterministic B\\\"uchi automata (LDBA) to DPA, and show that it can\nbe concatenated with a recent efficient translation from LTL to LDBA to yield a\ndouble exponential, \\enquote{Safraless} LTL-to-DPA construction. We also report\non an implementation, a comparison with the SPOT library, and performance on\nseveral sets of formulas, including instances from the 2016 SyntComp\ncompetition.\n", "versions": [{"version": "v1", "created": "Sat, 21 Jan 2017 23:40:49 GMT"}], "update_date": "2018-05-04", "authors_parsed": [["Esparza", "Javier", ""], ["K\u0159et\u00ednsk\u00fd", "Jan", ""], ["Raskin", "Jean-Fran\u00e7ois", ""], ["Sickert", "Salomon", ""]]}, {"id": "1701.06282", "submitter": "Tomas Fiedor", "authors": "Tom\\'a\\v{s} Fiedor, Luk\\'a\\v{s} Hol\\'ik, Petr Jank\\r{u}, Ond\\v{r}ej\n  Leng\\'al and Tom\\'a\\v{s} Vojnar", "title": "Lazy Automata Techniques for WS1S", "comments": "Technical Report for a paper to be published in TACAS'17", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new decision procedure for the logic WS1S. It originates from\nthe classical approach, which first builds an automaton accepting all models of\na formula and then tests whether its language is empty. The main novelty is to\ntest the emptiness on the fly, while constructing a symbolic, term-based\nrepresentation of the automaton, and prune the constructed state space from\nparts irrelevant to the test. The pruning is done by a generalization of two\ntechniques used in antichain-based language inclusion and universality checking\nof finite automata: subsumption and early termination. The richer structure of\nthe WS1S decision problem allows us, however, to elaborate on these techniques\nin novel ways. Our experiments show that the proposed approach can in many\ncases significantly outperform the classical decision procedure (implemented in\nthe MONA tool) as well as recently proposed alternatives.\n", "versions": [{"version": "v1", "created": "Mon, 23 Jan 2017 07:30:12 GMT"}, {"version": "v2", "created": "Tue, 24 Jan 2017 08:49:11 GMT"}], "update_date": "2017-01-25", "authors_parsed": [["Fiedor", "Tom\u00e1\u0161", ""], ["Hol\u00edk", "Luk\u00e1\u0161", ""], ["Jank\u016f", "Petr", ""], ["Leng\u00e1l", "Ond\u0159ej", ""], ["Vojnar", "Tom\u00e1\u0161", ""]]}, {"id": "1701.06790", "submitter": "Rachid Echahed", "authors": "Rachid Echahed and Aude Maignan", "title": "Parallel Graph Rewriting with Overlapping Rules", "comments": "26 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We tackle the problem of simultaneous transformations of networks represented\nas graphs. Roughly speaking, one may distinguish two kinds of simultaneous or\nparallel rewrite relations over complex structures such as graphs: (i) those\nwhich transform disjoint subgraphs in parallel and hence can be simulated by\nsuccessive mere sequential and local transformations and (ii) those which\ntransform overlapping subgraphs simultaneously. In the latter situations,\nparallel transformations cannot be simulated in general by means of successive\nlocal rewrite steps. We investigate this last problem in the framework of\noverlapping graph transformation systems. As parallel transformation of a graph\ndoes not produce a graph in general, we propose first some sufficient\nconditions that ensure the closure of graphs by parallel rewrite relations.\nThen we mainly introduce and discuss two parallel rewrite relations over\ngraphs. One relation is functional and thus deterministic, the other one is not\nfunctional for which we propose sufficient conditions which ensure its\nconfluence.\n", "versions": [{"version": "v1", "created": "Tue, 24 Jan 2017 10:02:55 GMT"}], "update_date": "2017-01-25", "authors_parsed": [["Echahed", "Rachid", ""], ["Maignan", "Aude", ""]]}, {"id": "1701.07470", "submitter": "Georg Zetzsche", "authors": "Simon Halfon, Philippe Schnoebelen, Georg Zetzsche", "title": "Decidability, Complexity, and Expressiveness of First-Order Logic Over\n  the Subword Ordering", "comments": "26 pages, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We consider first-order logic over the subword ordering on finite words,\nwhere each word is available as a constant. Our first result is that the\n$\\Sigma_1$ theory is undecidable (already over two letters).\n  We investigate the decidability border by considering fragments where all but\na certain number of variables are alternation bounded, meaning that the\nvariable must always be quantified over languages with a bounded number of\nletter alternations. We prove that when at most two variables are not\nalternation bounded, the $\\Sigma_1$ fragment is decidable, and that it becomes\nundecidable when three variables are not alternation bounded. Regarding higher\nquantifier alternation depths, we prove that the $\\Sigma_2$ fragment is\nundecidable already for one variable without alternation bound and that when\nall variables are alternation bounded, the entire first-order theory is\ndecidable.\n", "versions": [{"version": "v1", "created": "Wed, 25 Jan 2017 20:12:02 GMT"}], "update_date": "2017-01-27", "authors_parsed": [["Halfon", "Simon", ""], ["Schnoebelen", "Philippe", ""], ["Zetzsche", "Georg", ""]]}, {"id": "1701.07954", "submitter": "Dmitry Ananichev", "authors": "Dmitry Ananichev", "title": "A new lower bound for reset threshold of synchronizing automata with\n  sink state", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new series of examples of binary slowly synchronizing automata\nwith sink state. The reset threshold of the $n$-state automaton in this series\nis $\\frac{n^2}{4}+2n-9$. This improves on the previously known lower bound for\nthe maximum reset threshold of binary synchronizing $n$-state automata with\nsink state.\n", "versions": [{"version": "v1", "created": "Fri, 27 Jan 2017 06:26:46 GMT"}], "update_date": "2017-01-30", "authors_parsed": [["Ananichev", "Dmitry", ""]]}, {"id": "1701.08524", "submitter": "Uli Fahrenberg", "authors": "David Cachera, Uli Fahrenberg, Axel Legay", "title": "An $\\omega$-Algebra for Real-Time Energy Problems", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 2 (May 24,\n  2019) lmcs:5507", "doi": "10.23638/LMCS-15(2:17)2019", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We develop a $^*$-continuous Kleene $\\omega$-algebra of real-time energy\nfunctions. Together with corresponding automata, these can be used to model\nsystems which can consume and regain energy (or other types of resources)\ndepending on available time. Using recent results on $^*$-continuous Kleene\n$\\omega$-algebras and computability of certain manipulations on real-time\nenergy functions, it follows that reachability and B\\\"uchi acceptance in\nreal-time energy automata can be decided in a static way which only involves\nmanipulations of real-time energy functions.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jan 2017 09:40:46 GMT"}, {"version": "v2", "created": "Fri, 16 Mar 2018 23:16:28 GMT"}, {"version": "v3", "created": "Fri, 25 Jan 2019 08:54:53 GMT"}, {"version": "v4", "created": "Thu, 23 May 2019 08:27:00 GMT"}], "update_date": "2019-09-04", "authors_parsed": [["Cachera", "David", ""], ["Fahrenberg", "Uli", ""], ["Legay", "Axel", ""]]}, {"id": "1701.08682", "submitter": "Ale\\v{s} Bizjak", "authors": "Parosh Aziz Abdulla, Mohamed Faouzi Atig, Ahmed Bouajjani, Tuan Phong\n  Ngo", "title": "A Load-Buffer Semantics for Total Store Ordering", "comments": "Logic in computer science", "journal-ref": "Logical Methods in Computer Science, Volume 14, Issue 1 (January\n  23, 2018) lmcs:4228", "doi": "10.23638/LMCS-14(1:9)2018", "report-no": null, "categories": "cs.FL cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address the problem of verifying safety properties of concurrent programs\nrunning over the Total Store Order (TSO) memory model. Known decision\nprocedures for this model are based on complex encodings of store buffers as\nlossy channels. These procedures assume that the number of processes is fixed.\nHowever, it is important in general to prove the correctness of a\nsystem/algorithm in a parametric way with an arbitrarily large number of\nprocesses.\n  In this paper, we introduce an alternative (yet equivalent) semantics to the\nclassical one for the TSO semantics that is more amenable to efficient\nalgorithmic verification and for the extension to parametric verification. For\nthat, we adopt a dual view where load buffers are used instead of store\nbuffers. The flow of information is now from the memory to load buffers. We\nshow that this new semantics allows (1) to simplify drastically the safety\nanalysis under TSO, (2) to obtain a spectacular gain in efficiency and\nscalability compared to existing procedures, and (3) to extend easily the\ndecision procedure to the parametric case, which allows obtaining a new\ndecidability result, and more importantly, a verification algorithm that is\nmore general and more efficient in practice than the one for bounded instances.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jan 2017 16:26:43 GMT"}, {"version": "v2", "created": "Tue, 31 Jan 2017 16:08:39 GMT"}, {"version": "v3", "created": "Wed, 6 Dec 2017 12:57:27 GMT"}, {"version": "v4", "created": "Mon, 22 Jan 2018 08:39:46 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Abdulla", "Parosh Aziz", ""], ["Atig", "Mohamed Faouzi", ""], ["Bouajjani", "Ahmed", ""], ["Ngo", "Tuan Phong", ""]]}, {"id": "1701.08703", "submitter": "Ale\\v{s} Bizjak", "authors": "Manfred Droste, Werner Kuich", "title": "Weighted omega-Restricted One Counter Automata", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 14, Issue 1 (March 6,\n  2018) lmcs:4347", "doi": "10.23638/LMCS-14(1:21)2018", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Let $S$ be a complete star-omega semiring and $\\Sigma$ be an alphabet. For a\nweighted $\\omega$-restricted one-counter automaton $\\mathcal{C}$ with set of\nstates $\\{1, \\dots, n\\}$, $n \\geq 1$, we show that there exists a mixed\nalgebraic system over a complete semiring-semimodule pair ${((S \\ll \\Sigma^*\n\\gg)^{n\\times n}, (S \\ll \\Sigma^{\\omega}\\gg)^n)}$ such that the behavior\n$\\Vert\\mathcal{C} \\Vert$ of $\\mathcal{C}$ is a component of a solution of this\nsystem. In case the basic semiring is $\\mathbb{B}$ or $\\mathbb{N}^{\\infty}$ we\nshow that there exists a mixed context-free grammar that generates\n$\\Vert\\mathcal{C} \\Vert$. The construction of the mixed context-free grammar\nfrom $\\mathcal{C}$ is a generalization of the well-known triple construction in\ncase of restricted one-counter automata and is called now triple-pair\nconstruction for $\\omega$-restricted one-counter automata.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jan 2017 16:52:01 GMT"}, {"version": "v2", "created": "Tue, 31 Jan 2017 19:25:49 GMT"}, {"version": "v3", "created": "Fri, 15 Sep 2017 16:49:47 GMT"}, {"version": "v4", "created": "Mon, 5 Mar 2018 09:34:52 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Droste", "Manfred", ""], ["Kuich", "Werner", ""]]}, {"id": "1701.09060", "submitter": "Alexander Shen", "authors": "Alexander Kozachinskiy, Alexander Shen", "title": "Automatic Kolmogorov complexity, normality and finite state dimension\n  revisited", "comments": "Revised version (2019): finite state dimension, criterion of\n  normality in terms of complexity implying results of Champernowne et al,,\n  superadditive calibrated functions. Covers FCT 2017 and FCT2019 conference\n  papers. Sept. 16, 2019: spelling of author's name. August 2020: corrections\n  and additions due to reviewer's report for the submitted version (including\n  strong dimensions)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.IT cs.FL math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is well known that normality can be described as incompressibility via\nfinite automata. Still the statement and the proof of this result as given by\nBecher and Heiber (2013) in terms of \"lossless finite-state compressors\" do not\nfollow the standard scheme of Kolmogorov complexity definition (an automaton is\nused for compression, not decompression). We modify this approach to make it\nmore similar to the traditional Kolmogorov complexity theory (and simpler) by\nexplicitly defining the notion of automatic Kolmogorov complexity and using its\nsimple properties.\n  Using this characterization and a sufficient condition for normality in terms\nof Kolmogorov complexity derived from it, we provide easy proofs for classical\nresults about normal sequences (Champernown, Wall, Piatetski-Shapiro,\nBesicovitch, Copeland, Erdos et al.)\n  Then we extend this approach to finite state dimension. We show that the\nblock entropy definition of the finite state dimension remains the same if\nnon-aligned blocks are used. Then we provide equivalent definitions in terms of\nautomatic complexity, superadditive bounds for Kolmogorov complexity,\ncalibrated superadditive functions and finite state a priori probability and\nuse them to give simple proofs for known results about finite state dimension,\nand for Agafonov's result saying that normality is preserved by automatic\nselection rules as well as the results of Schnorr and Stimm that relate\nnormality to finite state martingales.\n  Some results of this paper were presented at the Fundamentals in Computing\nTheory conferences in 2017 and 2019. Preliminary version of this paper (that\ndoes not mention the finite state dimension) was published in arxiv in~2017\n(see the previous version of this submission).\n", "versions": [{"version": "v1", "created": "Tue, 31 Jan 2017 14:39:25 GMT"}, {"version": "v2", "created": "Sat, 18 Feb 2017 11:48:59 GMT"}, {"version": "v3", "created": "Mon, 28 Aug 2017 14:26:11 GMT"}, {"version": "v4", "created": "Tue, 2 Jul 2019 14:54:19 GMT"}, {"version": "v5", "created": "Mon, 16 Sep 2019 15:00:24 GMT"}, {"version": "v6", "created": "Mon, 24 Aug 2020 10:46:45 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Kozachinskiy", "Alexander", ""], ["Shen", "Alexander", ""]]}, {"id": "1701.09097", "submitter": "Daniel Merkle", "authors": "Jakob L. Andersen, Christoph Flamm, Daniel Merkle, Peter F. Stadler", "title": "An Intermediate Level of Abstraction for Computational Systems Chemistry", "comments": null, "journal-ref": null, "doi": "10.1098/rsta.2016.0354", "report-no": null, "categories": "q-bio.MN cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computational techniques are required for narrowing down the vast space of\npossibilities to plausible prebiotic scenarios, since precise information on\nthe molecular composition, the dominant reaction chemistry, and the conditions\nfor that era are scarce. The exploration of large chemical reaction networks is\na central aspect in this endeavour. While quantum chemical methods can\naccurately predict the structures and reactivities of small molecules, they are\nnot efficient enough to cope with large-scale reaction systems. The\nformalization of chemical reactions as graph grammars provides a generative\nsystem, well grounded in category theory, at the right level of abstraction for\nthe analysis of large and complex reaction networks. An extension of the basic\nformalism into the realm of integer hyperflows allows for the identification of\ncomplex reaction patterns, such as auto-catalysis, in large reaction networks\nusing optimization techniques.\n", "versions": [{"version": "v1", "created": "Tue, 31 Jan 2017 15:37:33 GMT"}], "update_date": "2018-02-07", "authors_parsed": [["Andersen", "Jakob L.", ""], ["Flamm", "Christoph", ""], ["Merkle", "Daniel", ""], ["Stadler", "Peter F.", ""]]}]