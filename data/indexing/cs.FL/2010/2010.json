[{"id": "2010.00523", "submitter": "Ian McQuillan", "authors": "Oscar H. Ibarra and Ian McQuillan", "title": "On Store Languages and Applications", "comments": null, "journal-ref": "Information and Computation, 267, 28-48, 2019", "doi": "10.1016/j.ic.2019.03.003", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The store language of a machine of some arbitrary type is the set of all\nstore configurations (state plus store contents but not the input) that can\nappear in an accepting computation. New algorithms and characterizations of\nstore languages are obtained, such as the result that any nondeterministic\npushdown automaton augmented with reversal-bounded counters, where the pushdown\ncan \"flip\" its contents up to a bounded number of times, can be accepted by a\nmachine with only reversal-bounded counters. Then, connections are made between\nstore languages and several model checking and reachability problems, such as\naccepting the set of all predecessor and successor configurations from a given\nset of configurations, and determining whether there are at least one, or\ninfinitely many, common configurations between accepting computations of two\nmachines. These are explored for a variety of different machine models often\ncontaining multiple parallel data stores. Many of the machine models studied\ncan accept the set of predecessor configurations (of a regular set of\nconfigurations), the set of successor configurations, and the set of common\nconfigurations between two machines, with a machine model that is simpler than\nitself, with a decidable emptiness, infiniteness, and disjointness property.\nStore languages are key to showing these properties.\n", "versions": [{"version": "v1", "created": "Thu, 1 Oct 2020 16:13:01 GMT"}], "update_date": "2020-10-02", "authors_parsed": [["Ibarra", "Oscar H.", ""], ["McQuillan", "Ian", ""]]}, {"id": "2010.01208", "submitter": "Abhishek Kulkarni", "authors": "Abhishek N. Kulkarni, Jie Fu, Huan Luo, Charles A. Kamhoua and Nandi\n  O. Leslie", "title": "Decoy Allocation Games on Graphs with Temporal Logic Objectives", "comments": "20 page, 4 figures, 2 algorithms, Accepted at Conference on Decision\n  and Game Theory for Security (GameSec) 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study a class of games, in which the adversary (attacker) is to satisfy a\ncomplex mission specified in linear temporal logic, and the defender is to\nprevent the adversary from achieving its goal. A deceptive defender can\nallocate decoys, in addition to defense actions, to create disinformation for\nthe attacker. Thus, we focus on the problem of jointly synthesizing a decoy\nplacement strategy and a deceptive defense strategy that maximally exploits the\nincomplete information the attacker about the decoy locations. We introduce a\nmodel of hypergames on graphs with temporal logic objectives to capture such\nadversarial interactions with asymmetric information. Using the hypergame\nmodel, we analyze the effectiveness of a given decoy placement, quantified by\nthe set of deceptive winning states where the defender can prevent the attacker\nfrom satisfying the attack objective given its incomplete information about\ndecoy locations. Then, we investigate how to place decoys to maximize the\ndefender's deceptive winning region. Considering the large search space for all\npossible decoy allocation strategies, we incorporate the idea of compositional\nsynthesis from formal methods and show that the objective function in the class\nof decoy allocation problem is monotone and non-decreasing. We derive the\nsufficient conditions under which the objective function for the decoy\nallocation problem is submodular, or supermodular, respectively. We show a\nsub-optimal allocation can be efficiently computed by iteratively composing the\nsolutions of hypergames with a subset of decoys and the solution of a hypergame\ngiven a single decoy. We use a running example to illustrate the proposed\nmethod.\n", "versions": [{"version": "v1", "created": "Fri, 2 Oct 2020 21:43:25 GMT"}], "update_date": "2020-10-06", "authors_parsed": [["Kulkarni", "Abhishek N.", ""], ["Fu", "Jie", ""], ["Luo", "Huan", ""], ["Kamhoua", "Charles A.", ""], ["Leslie", "Nandi O.", ""]]}, {"id": "2010.01611", "submitter": "Pouya Rezazadeh Kalehbasti", "authors": "Liubov Nikolenko, Pouya Rezazadeh Kalehbasti", "title": "When in Doubt, Ask: Generating Answerable and Unanswerable Questions,\n  Unsupervised", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CL cs.FL cs.LG", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Question Answering (QA) is key for making possible a robust communication\nbetween human and machine. Modern language models used for QA have surpassed\nthe human-performance in several essential tasks; however, these models require\nlarge amounts of human-generated training data which are costly and\ntime-consuming to create. This paper studies augmenting human-made datasets\nwith synthetic data as a way of surmounting this problem. A state-of-the-art\nmodel based on deep transformers is used to inspect the impact of using\nsynthetic answerable and unanswerable questions to complement a well-known\nhuman-made dataset. The results indicate a tangible improvement in the\nperformance of the language model (measured in terms of F1 and EM scores)\ntrained on the mixed dataset. Specifically, unanswerable question-answers prove\nmore effective in boosting the model: the F1 score gain from adding to the\noriginal dataset the answerable, unanswerable, and combined question-answers\nwere 1.3%, 5.0%, and 6.7%, respectively. [Link to the Github repository:\nhttps://github.com/lnikolenko/EQA]\n", "versions": [{"version": "v1", "created": "Sun, 4 Oct 2020 15:56:44 GMT"}, {"version": "v2", "created": "Mon, 19 Oct 2020 02:29:13 GMT"}], "update_date": "2020-10-20", "authors_parsed": [["Nikolenko", "Liubov", ""], ["Kalehbasti", "Pouya Rezazadeh", ""]]}, {"id": "2010.02047", "submitter": "Wil Van Der Aalst", "authors": "Wil M.P. van der Aalst and Alessandro Berti", "title": "Discovering Object-Centric Petri Nets", "comments": "Preprint of a paper to be published in Fundamenta Informaticae", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.AI cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Techniques to discover Petri nets from event data assume precisely one case\nidentifier per event. These case identifiers are used to correlate events, and\nthe resulting discovered Petri net aims to describe the life-cycle of\nindividual cases. In reality, there is not one possible case notion, but\nmultiple intertwined case notions. For example, events may refer to mixtures of\norders, items, packages, customers, and products. A package may refer to\nmultiple items, multiple products, one order, and one customer. Therefore, we\nneed to assume that each event refers to a collection of objects, each having a\ntype (instead of a single case identifier). Such object-centric event logs are\ncloser to data in real-life information systems. From an object-centric event\nlog, we want to discover an object-centric Petri net with places that\ncorrespond to object types and transitions that may consume and produce\ncollections of objects of different types. Object-centric Petri nets visualize\nthe complex relationships among objects from different types. This paper\ndiscusses a novel process discovery approach implemented in PM4Py. As will be\ndemonstrated, it is indeed feasible to discover holistic process models that\ncan be used to drill-down into specific viewpoints if needed.\n", "versions": [{"version": "v1", "created": "Mon, 5 Oct 2020 14:25:42 GMT"}], "update_date": "2020-10-06", "authors_parsed": [["van der Aalst", "Wil M. P.", ""], ["Berti", "Alessandro", ""]]}, {"id": "2010.02055", "submitter": "Suguman Bansal", "authors": "Suguman Bansal", "title": "Automata-based Quantitative Verification", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Quantitative analysis of computing systems is an emerging area in automated\nformal analysis. Such properties address aspects such as costs and rewards,\nquality measures, resource consumption, distance metrics, etc.\n  Existing solutions for problems in quantitative analysis face two challenges,\nnamely lack of generalizability and separation-of-techniques. Lack of\ngeneralizability refers to the issue that solution approaches are specialized\nto cost model. Different cost models deploy such disparate algorithms that\nthere is no transfer of knowledge from one cost model to another.\nSeparation-of-techniques refers to the inherent dichotomy in solving problems\nin quantitative analysis. Most algorithms comprise of a structural phase which\nreasons about the structure of the quantitative system(s) using techniques from\nautomata or graphs, and a numerical phase, which reasons about the quantitative\ndimension/cost model using numerical methods. The techniques used in both\nphases are so unlike each other that they are difficult to combine, thereby\nimpacting scalability.\n  This thesis contributes to a novel framework that addresses these challenges.\nThe introduced framework, called comparator automata or comparators in short,\nbuilds on automata-theoretic foundations to generalize across a variety of cost\nmodels. Comparators enable automata-based methods in the numerical phase, hence\neradicating the dependence on numerical methods. In doing so, comparators are\nable to integrate the structural and numerical phases. On the theoretical\nfront, we demonstrate that these have the advantage of generalizable results,\nand yield complexity-theoretic improvements over a range of problems in\nquantitative analysis. On the empirical front, we demonstrate that\ncomparator-based solutions render more efficient, scalable, and robust\nperformance, and are able to integrate quantitative with qualitative\nobjectives.\n", "versions": [{"version": "v1", "created": "Mon, 5 Oct 2020 14:43:28 GMT"}], "update_date": "2020-10-06", "authors_parsed": [["Bansal", "Suguman", ""]]}, {"id": "2010.03227", "submitter": "Karen Seidel", "authors": "Ardalan Khazraei, Timo K\\\"otzing, Karen Seidel", "title": "Learning Half-Spaces and other Concept Classes in the Limit with\n  Iterative Learners", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In order to model an efficient learning paradigm, iterative learning\nalgorithms access data one by one, updating the current hypothesis without\nregress to past data. Past research on iterative learning analyzed for example\nmany important additional requirements and their impact on iterative learners.\nIn this paper, our results are twofold. First, we analyze the relative learning\npower of various settings of iterative learning, including learning from text\nand from informant, as well as various further restrictions, for example we\nshow that strongly non-U-shaped learning is restrictive for iterative learning\nfrom informant. Second, we investigate the learnability of the concept class of\nhalf-spaces and provide a constructive iterative algorithm to learn the set of\nhalf-spaces from informant.\n", "versions": [{"version": "v1", "created": "Wed, 7 Oct 2020 07:20:50 GMT"}, {"version": "v2", "created": "Wed, 28 Apr 2021 10:57:50 GMT"}], "update_date": "2021-04-29", "authors_parsed": [["Khazraei", "Ardalan", ""], ["K\u00f6tzing", "Timo", ""], ["Seidel", "Karen", ""]]}, {"id": "2010.04258", "submitter": "Oliviero Riganelli", "authors": "Michell Guzman, Oliviero Riganelli, Daniela Micucci, Leonardo Mariani", "title": "Test4Enforcers: Test Case Generation for Software Enforcers", "comments": "For associated video presentation, see https://youtu.be/TcOTlo4ILmo.\n  For associated slides, see\n  https://www.slideshare.net/OlivieroRiganelli/test4enforcers-test-case-generation-for-software-enforcers", "journal-ref": "In: Runtime Verification. RV 2020. Lecture Notes in Computer\n  Science, vol 12399. Springer, Cham", "doi": "10.1007/978-3-030-60508-7_15", "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Software enforcers can be used to modify the runtime behavior of software\napplications to guarantee that relevant correctness policies are satisfied.\nIndeed, the implementation of software enforcers can be tricky, due to the\nheterogeneity of the situations that they must be able to handle. Assessing\ntheir ability to steer the behavior of the target system without introducing\nany side effect is an important challenge to fully trust the resulting system.\nTo address this challenge, this paper presents Test4Enforcers, the first\napproach to derive thorough test suites that can validate the impact of\nenforcers on a target system. The paper also shows how to implement the\nTest4Enforcers approach in the DroidBot test generator to validate enforcers\nfor Android apps.\n", "versions": [{"version": "v1", "created": "Thu, 8 Oct 2020 21:09:57 GMT"}, {"version": "v2", "created": "Tue, 13 Oct 2020 07:30:23 GMT"}], "update_date": "2020-10-14", "authors_parsed": [["Guzman", "Michell", ""], ["Riganelli", "Oliviero", ""], ["Micucci", "Daniela", ""], ["Mariani", "Leonardo", ""]]}, {"id": "2010.04303", "submitter": "Javid Ebrahimi", "authors": "Javid Ebrahimi, Dhruv Gelda, Wei Zhang", "title": "How Can Self-Attention Networks Recognize Dyck-n Languages?", "comments": null, "journal-ref": "Findings of EMNLP 2020", "doi": null, "report-no": null, "categories": "cs.CL cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We focus on the recognition of Dyck-n ($\\mathcal{D}_n$) languages with\nself-attention (SA) networks, which has been deemed to be a difficult task for\nthese networks. We compare the performance of two variants of SA, one with a\nstarting symbol (SA$^+$) and one without (SA$^-$). Our results show that SA$^+$\nis able to generalize to longer sequences and deeper dependencies. For\n$\\mathcal{D}_2$, we find that SA$^-$ completely breaks down on long sequences\nwhereas the accuracy of SA$^+$ is 58.82$\\%$. We find attention maps learned by\n$\\text{SA}{^+}$ to be amenable to interpretation and compatible with a\nstack-based language recognizer. Surprisingly, the performance of SA networks\nis at par with LSTMs, which provides evidence on the ability of SA to learn\nhierarchies without recursion.\n", "versions": [{"version": "v1", "created": "Fri, 9 Oct 2020 00:03:17 GMT"}], "update_date": "2020-10-12", "authors_parsed": [["Ebrahimi", "Javid", ""], ["Gelda", "Dhruv", ""], ["Zhang", "Wei", ""]]}, {"id": "2010.04782", "submitter": "Karen Seidel", "authors": "Timo K\\\"otzing, Karen Seidel", "title": "Learning Languages in the Limit from Positive Information with Finitely\n  Many Memory Changes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate learning collections of languages from texts by an inductive\ninference machine with access to the current datum and a bounded memory in form\nof states. Such a bounded memory states (BMS) learner is considered successful\nin case it eventually settles on a correct hypothesis while exploiting only\nfinitely many different states.\n  We give the complete map of all pairwise relations for an established\ncollection of criteria of successfull learning. Most prominently, we show that\nnon-U-shapedness is not restrictive, while conservativeness and (strong)\nmonotonicity are. Some results carry over from iterative learning by a general\nlemma showing that, for a wealth of restrictions (the semantic restrictions),\niterative and bounded memory states learning are equivalent. We also give an\nexample of a non-semantic restriction (strongly non-U-shapedness) where the two\nsettings differ.\n", "versions": [{"version": "v1", "created": "Fri, 9 Oct 2020 19:59:49 GMT"}, {"version": "v2", "created": "Tue, 8 Dec 2020 10:48:56 GMT"}, {"version": "v3", "created": "Thu, 17 Jun 2021 12:52:05 GMT"}], "update_date": "2021-06-18", "authors_parsed": [["K\u00f6tzing", "Timo", ""], ["Seidel", "Karen", ""]]}, {"id": "2010.04823", "submitter": "Krasimir Yordzhev", "authors": "Krasimir Yordzhev", "title": "On some representations of context-free languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/publicdomain/zero/1.0/", "abstract": "  Context-free languages are widely used to describe the syntax of programming\nlanguages and natural languages. Usually, we describe a context-free language\nmathematically with the help of context-free grammar (for generation) or\npushdown automata (for recognition). The purpose of this study is to describe\nsome unconventional methods of description of context-free languages, namely a\nrepresentation with the help of finite digraphs and with automata - generators\nof context-free languages. We will mainly focus on the mathematical models of\nthese representations.\n", "versions": [{"version": "v1", "created": "Fri, 9 Oct 2020 21:52:56 GMT"}], "update_date": "2020-10-13", "authors_parsed": [["Yordzhev", "Krasimir", ""]]}, {"id": "2010.06037", "submitter": "Mart\\'in Mu\\~noz", "authors": "Mart\\'in Mu\\~noz, Cristian Riveros", "title": "Constant-delay enumeration algorithms for document spanners over nested\n  documents", "comments": "29 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Some of the most relevant document schemas used online, such as XML and JSON,\nhave a nested format. In recent years, the task of extracting data from large\nnested documents has become especially relevant. We model queries of this kind\nas Visibly Pushdown Transducers (VPT), a structure that extends visibly\npushdown automata with outputs. Since processing a string through a VPT can\ngenerate a huge number of outputs, we are interested in the task of enumerating\nthem one after another as efficiently as possible. This paper describes an\nalgorithm that enumerates these elements with output-linear delay after\npreprocessing the string in a single pass. We show applications of this result\non recursive document spanners over nested documents and show how our algorithm\ncan be adapted to enumerate the outputs in this context.\n", "versions": [{"version": "v1", "created": "Mon, 12 Oct 2020 21:26:31 GMT"}], "update_date": "2020-10-14", "authors_parsed": [["Mu\u00f1oz", "Mart\u00edn", ""], ["Riveros", "Cristian", ""]]}, {"id": "2010.06361", "submitter": "Olivier Serre", "authors": "Christopher H. Broadbent, Arnaud Carayol, Matthew Hague, Andrzej S.\n  Murawski, C.-H. Luke Ong, Olivier Serre", "title": "Collapsible Pushdown Parity Games", "comments": "51 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies a large class of two-player perfect-information turn-based\nparity games on infinite graphs, namely those generated by collapsible pushdown\nautomata. The main motivation for studying these games comes from the\nconnections from collapsible pushdown automata and higher-order recursion\nschemes, both models being equi-expressive for generating infinite trees. Our\nmain result is to establish the decidability of such games and to provide an\neffective representation of the winning region as well as of a winning\nstrategy. Thus, the results obtained here provide all necessary tools for an\nin-depth study of logical properties of trees generated by collapsible pushdown\nautomata/recursion schemes.\n", "versions": [{"version": "v1", "created": "Tue, 13 Oct 2020 13:15:46 GMT"}], "update_date": "2020-10-14", "authors_parsed": [["Broadbent", "Christopher H.", ""], ["Carayol", "Arnaud", ""], ["Hague", "Matthew", ""], ["Murawski", "Andrzej S.", ""], ["Ong", "C. -H. Luke", ""], ["Serre", "Olivier", ""]]}, {"id": "2010.06366", "submitter": "Olivier Serre", "authors": "Christopher H. Broadbent, Arnaud Carayol, C.-H. Luke Ong, Olivier\n  Serre", "title": "Higher-Order Recursion Schemes and Collapsible Pushdown Automata:\n  Logical Properties", "comments": "35 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies the logical properties of a very general class of infinite\nranked trees, namely those generated by higher-order recursion schemes. We\nconsider, for both monadic second-order logic and modal mu-calculus, three main\nproblems: model-checking, logical reflection (aka global model-checking, that\nasks for a finite description of the set of elements for which a formula holds)\nand selection (that asks, if exists, for some finite description of a set of\nelements for which an MSO formula with a second-order free variable holds). For\neach of these problems we provide an effective solution. This is obtained\nthanks to a known connection between higher-order recursion schemes and\ncollapsible pushdown automata and on previous work regarding parity games\nplayed on transition graphs of collapsible pushdown automata.\n", "versions": [{"version": "v1", "created": "Tue, 13 Oct 2020 13:19:39 GMT"}, {"version": "v2", "created": "Tue, 2 Mar 2021 14:05:30 GMT"}], "update_date": "2021-03-03", "authors_parsed": [["Broadbent", "Christopher H.", ""], ["Carayol", "Arnaud", ""], ["Ong", "C. -H. Luke", ""], ["Serre", "Olivier", ""]]}, {"id": "2010.06674", "submitter": "Niveditha Manjunath", "authors": "Ezio Bartocci (1), Roderick Bloem (2), Benedikt Maderbacher (2),\n  Niveditha Manjunath (1 and 3), Dejan Ni\\v{c}kovi\\'c (3) ((1) Vienna\n  University of Technology, (2) Graz University of Technology, (3) AIT Austrian\n  Institute of Technology)", "title": "Adaptive Testing for Specification Coverage", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL cs.GT cs.LO cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Ensuring correctness of cyber-physical systems (CPS) is an extremely\nchallenging task that is in practice often addressed with simulation based\ntesting. Formal specification languages, such as Signal Temporal Logic (STL),\nare used to mathematically express CPS requirements and thus render the\nsimulation activity more systematic and principled. We propose a novel method\nfor adaptive generation of tests with specification coverage for STL. To\nachieve this goal, we devise cooperative reachability games that we combine\nwith numerical optimization to create tests that explore the system in a way\nthat exercise various parts of the specification. To the best of our knowledge\nour approach is the first adaptive testing approach that can be applied\ndirectly to MATLAB\\texttrademark\\; Simulink/Stateflow models. We implemented\nour approach in a prototype tool and evaluated it on several illustrating\nexamples and a case study from the avionics domain, demonstrating the\neffectiveness of adaptive testing to (1) incrementally build a test case that\nreaches a test objective, (2) generate a test suite that increases the\nspecification coverage, and (3) infer what part of the specification is\nactually implemented.\n", "versions": [{"version": "v1", "created": "Tue, 13 Oct 2020 20:14:51 GMT"}, {"version": "v2", "created": "Tue, 26 Jan 2021 15:09:57 GMT"}], "update_date": "2021-01-27", "authors_parsed": [["Bartocci", "Ezio", "", "1 and 3"], ["Bloem", "Roderick", "", "1 and 3"], ["Maderbacher", "Benedikt", "", "1 and 3"], ["Manjunath", "Niveditha", "", "1 and 3"], ["Ni\u010dkovi\u0107", "Dejan", ""]]}, {"id": "2010.06797", "submitter": "Mingyu Cai", "authors": "Mingyu Cai, Shaoping Xiao, Baoluo Li, Zhiliang Li and Zhen Kan", "title": "Reinforcement Learning Based Temporal Logic Control with Maximum\n  Probabilistic Satisfaction", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.AI cs.RO math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a model-free reinforcement learning (RL) algorithm to\nsynthesize a control policy that maximizes the satisfaction probability of\nlinear temporal logic (LTL) specifications. Due to the consideration of\nenvironment and motion uncertainties, we model the robot motion as a\nprobabilistic labeled Markov decision process with unknown transition\nprobabilities and unknown probabilistic label functions. The LTL task\nspecification is converted to a limit deterministic generalized B\\\"uchi\nautomaton (LDGBA) with several accepting sets to maintain dense rewards during\nlearning. The novelty of applying LDGBA is to construct an embedded LDGBA\n(E-LDGBA) by designing a synchronous tracking-frontier function, which enables\nthe record of non-visited accepting sets without increasing dimensional and\ncomputational complexity. With appropriate dependent reward and discount\nfunctions, rigorous analysis shows that any method that optimizes the expected\ndiscount return of the RL-based approach is guaranteed to find the optimal\npolicy that maximizes the satisfaction probability of the LTL specifications. A\nmodel-free RL-based motion planning strategy is developed to generate the\noptimal policy in this paper. The effectiveness of the RL-based control\nsynthesis is demonstrated via simulation and experimental results.\n", "versions": [{"version": "v1", "created": "Wed, 14 Oct 2020 03:49:16 GMT"}, {"version": "v2", "created": "Thu, 15 Oct 2020 04:45:16 GMT"}, {"version": "v3", "created": "Fri, 26 Mar 2021 20:51:11 GMT"}, {"version": "v4", "created": "Thu, 22 Jul 2021 01:36:30 GMT"}], "update_date": "2021-07-23", "authors_parsed": [["Cai", "Mingyu", ""], ["Xiao", "Shaoping", ""], ["Li", "Baoluo", ""], ["Li", "Zhiliang", ""], ["Kan", "Zhen", ""]]}, {"id": "2010.06974", "submitter": "Christian Lindorfer", "authors": "Florian Lehner and Christian Lindorfer", "title": "Self-avoiding walks and multiple context-free languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL math.GR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let $G$ be a quasi-transitive, locally finite, connected graph rooted at a\nvertex $o$, and let $c_n(o)$ be the number of self-avoiding walks of length $n$\non $G$ starting at $o$. We show that if $G$ has only thin ends, then the\ngenerating function $F_{\\mathrm{SAW},o}(z)=\\sum_{n \\geq 0} c_n(o) z^n$ is an\nalgebraic function. In particular, the connective constant of such a graph is\nan algebraic number.\n  If $G$ is deterministically edge labelled, that is, every (directed) edge\ncarries a label such that any two edges starting at the same vertex have\ndifferent labels, then the set of all words which can be read along the edges\nof self-avoiding walks starting at $o$ forms a language denoted by\n$L_{\\mathrm{SAW},o}$. Assume that the group of label-preserving graph\nautomorphisms acts quasi-transitively. We show that $L_{\\mathrm{SAW},o}$ is a\n$k$-multiple context-free language if and only if the size of all ends of $G$\nis at most $2k$. Applied to Cayley graphs of finitely generated groups this\nsays that $L_{\\mathrm{SAW},o}$ is multiple context-free if and only if the\ngroup is virtually free.\n", "versions": [{"version": "v1", "created": "Wed, 14 Oct 2020 11:35:36 GMT"}], "update_date": "2020-10-15", "authors_parsed": [["Lehner", "Florian", ""], ["Lindorfer", "Christian", ""]]}, {"id": "2010.07834", "submitter": "Ond\\v{r}ej Leng\\'al", "authors": "Vojt\\v{e}ch Havlena and Ond\\v{r}ej Leng\\'al", "title": "Reducing (to) the Ranks: Efficient Rank-based B\\\"{u}chi Automata\n  Complementation (Technical Report)", "comments": "Accepted at CONCUR'21", "journal-ref": null, "doi": "10.4230/LIPIcs.CONCUR.2021.9", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper provides several optimizations of the rank-based approach for\ncomplementing B\\\"{u}chi automata. We start with Schewe's theoretically optimal\nconstruction and develop a set of techniques for pruning its state space that\nare key to obtaining small complement automata in practice. In particular, the\nreductions (except one) have the property that they preserve (at least some)\nso-called super-tight runs, which are runs whose ranking is as tight as\npossible. Our evaluation on a large benchmark shows that the optimizations\nindeed significantly help the rank-based approach and that, in a large number\nof cases, the obtained complement is the smallest from those produced by a\nlarge number of state-of-the-art tools for B\\\"{u}chi complementation.\n", "versions": [{"version": "v1", "created": "Thu, 15 Oct 2020 15:53:13 GMT"}, {"version": "v2", "created": "Fri, 16 Oct 2020 11:01:28 GMT"}, {"version": "v3", "created": "Wed, 21 Jul 2021 07:57:27 GMT"}], "update_date": "2021-07-22", "authors_parsed": [["Havlena", "Vojt\u011bch", ""], ["Leng\u00e1l", "Ond\u0159ej", ""]]}, {"id": "2010.07874", "submitter": "Peter Belc\\'ak", "authors": "Peter Belcak", "title": "The LL(finite) strategy for optimal LL(k) parsing", "comments": "An error was found in one of the algorithms for weak LL(k) grammars", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.CL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The LL(finite) parsing strategy for parsing of LL(k) grammars where k needs\nnot to be known is presented. The strategy parses input in linear time, uses\narbitrary but always minimal lookahead necessary to disambiguate between\nalternatives of nonterminals, and it is optimal in the number of lookahead\nterminal scans performed. Modifications to the algorithm are shown that allow\nfor resolution of grammar ambiguities by precedence -- effectively interpreting\nthe input as a parsing expression grammar -- as well as for the use of\npredicates, and a proof of concept, the open-source parser generator Astir,\nemploys the LL(finite) strategy in the output it generates.\n", "versions": [{"version": "v1", "created": "Thu, 15 Oct 2020 16:52:29 GMT"}, {"version": "v2", "created": "Wed, 20 Jan 2021 10:22:50 GMT"}], "update_date": "2021-01-21", "authors_parsed": [["Belcak", "Peter", ""]]}, {"id": "2010.08042", "submitter": "Alejandro Grez", "authors": "Pierre Bourhis, Alejandro Grez, Louis Jachiet and Cristian Riveros", "title": "Ranked enumeration of MSO logic on words", "comments": "29 pages (with appendix), 2 figures, submitted to the ICDT21\n  conference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the last years, enumeration algorithms with bounded delay have attracted a\nlot of attention for several data management tasks. Given a query and the data,\nthe task is to preprocess the data and then enumerate all the answers to the\nquery one by one and without repetitions. This enumeration scheme is typically\nuseful when the solutions are treated on the fly or when we want to stop the\nenumeration once the pertinent solutions have been found. However, with the\ncurrent schemes, there is no restriction on the order how the solutions are\ngiven and this order usually depends on the techniques used and not on the\nrelevance for the user.\n  In this paper we study the enumeration of monadic second order logic (MSO)\nover words when the solutions are ranked. We present a framework based on MSO\ncost functions that allows to express MSO formulae on words with a cost\nassociated with each solution. We then demonstrate the generality of our\nframework which subsumes, for instance, document spanners and regular complex\nevent processing queries and adds ranking to them. The main technical result of\nthe paper is an algorithm for enumerating all the solutions of formulae in\nincreasing order of cost efficiently, namely, with a linear preprocessing phase\nand logarithmic delay between solutions. The novelty of this algorithm is based\non using functional data structures, in particular, by extending functional\nBrodal queues to suit with the ranked enumeration of MSO on words.\n", "versions": [{"version": "v1", "created": "Thu, 15 Oct 2020 22:12:20 GMT"}], "update_date": "2020-10-19", "authors_parsed": [["Bourhis", "Pierre", ""], ["Grez", "Alejandro", ""], ["Jachiet", "Louis", ""], ["Riveros", "Cristian", ""]]}, {"id": "2010.08288", "submitter": "Pierre Ohlmann", "authors": "Marcin Jurdzi\\'nski, R\\'emi Morvan, Pierre Ohlmann and K. S.\n  Thejaswini", "title": "A symmetric attractor-decomposition lifting algorithm for parity games", "comments": "30 pages, including 10 pages of appendix and 5 figures. Submitted to\n  FoSSaCS2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Progress-measure lifting algorithms for solving parity games have the best\nworst-case asymptotic runtime, but are limited by their asymmetric nature, and\nknown from the work of Czerwi\\'nski et al. (2018) to be subject to a matching\nquasi-polynomial lower bound inherited from the combinatorics of universal\ntrees. Parys (2019) has developed an ingenious quasi-polynomial McNaughton-\nZielonka-style algorithm, and Lehtinen et al. (2019) have improved its\nworst-case runtime. Jurdzi\\'nski and Morvan (2020) have recently brought\nforward a generic attractor-based algorithm, formalizing a second class of\nquasi-polynomial solutions to solving parity games, which have runtime\nquadratic in the size of universal trees. First, we adapt the framework of\niterative lifting algorithms to computing attractor-based strategies. Second,\nwe design a symmetric lifting algorithm in this setting, in which two lifting\niterations, one for each player, accelerate each other in a recursive fashion.\nThe symmetric algorithm performs at least as well as progress-measure liftings\nin the worst-case, whilst bypassing their inherent asymmetric limitation.\nThirdly, we argue that the behaviour of the generic attractor-based algorithm\nof Jurdzinski and Morvan (2020) can be reproduced by a specific deceleration of\nour symmetric lifting algorithm, in which some of the information collected by\nthe algorithm is repeatedly discarded. This yields a novel interpretation of\nMcNaughton-Zielonka-style algorithms as progress-measure lifting iterations\n(with deliberate set-backs), further strengthening the ties between all known\nquasi-polynomial algorithms to date.\n", "versions": [{"version": "v1", "created": "Fri, 16 Oct 2020 10:27:39 GMT"}], "update_date": "2020-10-19", "authors_parsed": [["Jurdzi\u0144ski", "Marcin", ""], ["Morvan", "R\u00e9mi", ""], ["Ohlmann", "Pierre", ""], ["Thejaswini", "K. S.", ""]]}, {"id": "2010.08347", "submitter": "Jan K\\v{r}et\\'insk\\'y", "authors": "Javier Esparza, Stefan Kiefer, Jan Kretinsky and Maximilian Weininger", "title": "Online Monitoring $\\omega$-Regular Properties in Unknown Markov Chains", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study runtime monitoring of $\\omega$-regular properties. We consider a\nsimple setting in which a run of an unknown finite-state Markov chain $\\mathcal\nM$ is monitored against a fixed but arbitrary $\\omega$-regular specification\n$\\varphi$. The purpose of monitoring is to keep aborting runs that are\n\"unlikely\" to satisfy the specification until $\\mathcal M$ executes a correct\nrun. We design controllers for the reset action that (assuming that $\\varphi$\nhas positive probability) satisfy the following property w.p.1: the number of\nresets is finite, and the run executed by $\\mathcal M$ after the last reset\nsatisfies $\\varphi$.\n", "versions": [{"version": "v1", "created": "Fri, 16 Oct 2020 12:31:06 GMT"}], "update_date": "2020-10-19", "authors_parsed": [["Esparza", "Javier", ""], ["Kiefer", "Stefan", ""], ["Kretinsky", "Jan", ""], ["Weininger", "Maximilian", ""]]}, {"id": "2010.09460", "submitter": "Vanja Dosko\\v{c}", "authors": "Julian Berger, Maximilian B\\\"other, Vanja Dosko\\v{c}, Jonathan Gadea\n  Harder, Nicolas Klodt, Timo K\\\"otzing, Winfried L\\\"otzsch, Jannik Peters,\n  Leon Schiller, Lars Seifert, Armin Wells, Simon Wietheger", "title": "Maps for Learning Indexable Classes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study learning of indexed families from positive data where a learner can\nfreely choose a hypothesis space (with uniformly decidable membership)\ncomprising at least the languages to be learned. This abstracts a very\nuniversal learning task which can be found in many areas, for example learning\nof (subsets of) regular languages or learning of natural languages. We are\ninterested in various restrictions on learning, such as consistency,\nconservativeness or set-drivenness, exemplifying various natural learning\nrestrictions.\n  Building on previous results from the literature, we provide several maps\n(depictions of all pairwise relations) of various groups of learning criteria,\nincluding a map for monotonicity restrictions and similar criteria and a map\nfor restrictions on data presentation. Furthermore, we consider, for various\nlearning criteria, whether learners can be assumed consistent.\n", "versions": [{"version": "v1", "created": "Thu, 15 Oct 2020 09:34:07 GMT"}], "update_date": "2020-10-20", "authors_parsed": [["Berger", "Julian", ""], ["B\u00f6ther", "Maximilian", ""], ["Dosko\u010d", "Vanja", ""], ["Harder", "Jonathan Gadea", ""], ["Klodt", "Nicolas", ""], ["K\u00f6tzing", "Timo", ""], ["L\u00f6tzsch", "Winfried", ""], ["Peters", "Jannik", ""], ["Schiller", "Leon", ""], ["Seifert", "Lars", ""], ["Wells", "Armin", ""], ["Wietheger", "Simon", ""]]}, {"id": "2010.09461", "submitter": "Vanja Dosko\\v{c}", "authors": "Vanja Dosko\\v{c} and Timo K\\\"otzing", "title": "Normal Forms for (Semantically) Witness-Based Learners in Inductive\n  Inference", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study learners (computable devices) inferring formal languages, a setting\nreferred to as language learning in the limit or inductive inference. In\nparticular, we require the learners we investigate to be witness-based, that\nis, to justify each of their mind changes. Besides being a natural requirement\nfor a learning task, this restriction deserves special attention as it is a\nspecialization of various important learning paradigms. In particular, with the\nhelp of witness-based learning, explanatory learners are shown to be equally\npowerful under these seemingly incomparable paradigms. Nonetheless, until now,\nwitness-based learners have only been studied sparsely.\n  In this work, we conduct a thorough study of these learners both when\nrequiring syntactic and semantic convergence and obtain normal forms thereof.\nIn the former setting, we extend known results such that they include\nwitness-based learning and generalize these to hold for a variety of learners.\nTransitioning to behaviourally correct learning, we also provide normal forms\nfor semantically witness-based learners. Most notably, we show that set-driven\nglobally semantically witness-based learners are equally powerful as their\nGold-style semantically conservative counterpart. Such results are key to\nunderstanding the, yet undiscovered, mutual relation between various important\nlearning paradigms when learning behaviourally correctly.\n", "versions": [{"version": "v1", "created": "Thu, 15 Oct 2020 09:18:27 GMT"}], "update_date": "2020-10-20", "authors_parsed": [["Dosko\u010d", "Vanja", ""], ["K\u00f6tzing", "Timo", ""]]}, {"id": "2010.09464", "submitter": "Vanja Dosko\\v{c}", "authors": "Vanja Dosko\\v{c} and Timo K\\\"otzing", "title": "Mapping Monotonic Restrictions in Inductive Inference", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In language learning in the limit we investigate computable devices\n(learners) learning formal languages. Through the years, many natural\nrestrictions have been imposed on the studied learners. As such, monotonic\nrestrictions always enjoyed particular attention as, although being a natural\nrequirement, monotonic learners show significantly diverse behaviour when\nstudied in different settings. A recent study thoroughly analysed the learning\ncapabilities of strongly monotone learners imposed with memory restrictions and\nvarious additional requirements. The unveiled differences between explanatory\nand behaviourally correct such learners motivate our studies of monotone\nlearners dealing with the same restrictions.\n  We reveal differences and similarities between monotone learners and their\nstrongly monotone counterpart when studied with various additional\nrestrictions. In particular, we show that explanatory monotone learners,\nalthough known to be strictly stronger, do (almost) preserve the pairwise\nrelation as seen in strongly monotone learning. Contrasting this similarity, we\nfind substantial differences when studying behaviourally correct monotone\nlearners. Most notably, we show that monotone learners, as opposed to their\nstrongly monotone counterpart, do heavily rely on the order the information is\ngiven in, an unusual result for behaviourally correct learners.\n", "versions": [{"version": "v1", "created": "Thu, 15 Oct 2020 08:54:30 GMT"}], "update_date": "2020-10-20", "authors_parsed": [["Dosko\u010d", "Vanja", ""], ["K\u00f6tzing", "Timo", ""]]}, {"id": "2010.09527", "submitter": "\\'Etienne Andr\\'e", "authors": "\\'Etienne Andr\\'e and Aleksander Kryukov", "title": "Parametric non-interference in timed automata", "comments": "This is the author version of the manuscript of the same name\n  published in the proceedings of the 25th International Conference on\n  Engineering of Complex Computer Systems (ICECCS 2020)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider a notion of non-interference for timed automata (TAs) that allows\nto quantify the frequency of an attack; that is, we infer values of the minimal\ntime between two consecutive actions of the attacker, so that (s)he disturbs\nthe set of reachable locations. We also synthesize valuations for the timing\nconstants of the TA (seen as parameters) guaranteeing non-interference. We show\nthat this can reduce to reachability synthesis in parametric timed automata. We\napply our method to a model of the Fischer mutual exclusion protocol and obtain\npreliminary results.\n", "versions": [{"version": "v1", "created": "Mon, 19 Oct 2020 13:58:16 GMT"}], "update_date": "2020-10-20", "authors_parsed": [["Andr\u00e9", "\u00c9tienne", ""], ["Kryukov", "Aleksander", ""]]}, {"id": "2010.09646", "submitter": "Aritra Sarkar", "authors": "Aritra Sarkar", "title": "Quines are the fittest programs: Nesting algorithmic probability\n  converges to constructors", "comments": "5 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.IT math.IT", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  In this article we explore the limiting behavior of the universal prior\ndistribution applied over multiple meta-level hierarchy of program and output\ndata of a Turing machine. We were motivated to reduce the effect of\nSolomonoff's assumption that all computable functions/hypothesis of the same\nlength are equally likely, by weighing each program in turn by the algorithmic\nprobability of their description number encoding. In the limiting case we\nconverge the set of all possible program strings of a fixed-length to a\ndistribution of self-replicating quines and quine-relays - having the structure\nof a constructor. We discuss how experimental algorithmic information theory\nprovides insights towards understanding the fundamental metrics proposed in\nthis work and reflect on the significance of these result in the constructor\ntheory of life.\n", "versions": [{"version": "v1", "created": "Mon, 12 Oct 2020 13:36:08 GMT"}], "update_date": "2020-10-20", "authors_parsed": [["Sarkar", "Aritra", ""]]}, {"id": "2010.10029", "submitter": "Guillaume Rabusseau", "authors": "Tianyu Li, Doina Precup, Guillaume Rabusseau", "title": "Connecting Weighted Automata, Tensor Networks and Recurrent Neural\n  Networks through Spectral Learning", "comments": "Extended version of AISTATS paper (arXiv:1807.01406) Preprint (under\n  review). arXiv admin note: text overlap with arXiv:1807.01406", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present connections between three models used in different\nresearch fields: weighted finite automata~(WFA) from formal languages and\nlinguistics, recurrent neural networks used in machine learning, and tensor\nnetworks which encompasses a set of optimization techniques for high-order\ntensors used in quantum physics and numerical analysis. We first present an\nintrinsic relation between WFA and the tensor train decomposition, a particular\nform of tensor network. This relation allows us to exhibit a novel low rank\nstructure of the Hankel matrix of a function computed by a WFA and to design an\nefficient spectral learning algorithm leveraging this structure to scale the\nalgorithm up to very large Hankel matrices. We then unravel a fundamental\nconnection between WFA and second-order recurrent neural networks~(2-RNN): in\nthe case of sequences of discrete symbols, WFA and 2-RNN with linear activation\nfunctions are expressively equivalent. Furthermore, we introduce the first\nprovable learning algorithm for linear 2-RNN defined over sequences of\ncontinuous input vectors. This algorithm relies on estimating low rank\nsub-blocks of the Hankel tensor, from which the parameters of a linear 2-RNN\ncan be provably recovered. The performances of the proposed learning algorithm\nare assessed in a simulation study on both synthetic and real-world data.\n", "versions": [{"version": "v1", "created": "Mon, 19 Oct 2020 15:28:00 GMT"}], "update_date": "2020-10-21", "authors_parsed": [["Li", "Tianyu", ""], ["Precup", "Doina", ""], ["Rabusseau", "Guillaume", ""]]}, {"id": "2010.10141", "submitter": "\\\"Ozlem Salehi", "authors": "Alper \\c{S}ekerci, \\\"Ozlem Salehi", "title": "Language Inference with Multi-head Automata through Reinforcement\n  Learning", "comments": "Published in: 2020 International Joint Conference on Neural Networks\n  (IJCNN)", "journal-ref": "2020 International Joint Conference on Neural Networks (IJCNN),\n  Glasgow, United Kingdom, 2020, pp. 1-8,", "doi": "10.1109/IJCNN48605.2020.9207156", "report-no": null, "categories": "cs.LG cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The purpose of this paper is to use reinforcement learning to model learning\nagents which can recognize formal languages. Agents are modeled as simple\nmulti-head automaton, a new model of finite automaton that uses multiple heads,\nand six different languages are formulated as reinforcement learning problems.\nTwo different algorithms are used for optimization. First algorithm is\nQ-learning which trains gated recurrent units to learn optimal policies. The\nsecond one is genetic algorithm which searches for the optimal solution by\nusing evolution inspired operations. The results show that genetic algorithm\nperforms better than Q-learning algorithm in general but Q-learning algorithm\nfinds solutions faster for regular languages.\n", "versions": [{"version": "v1", "created": "Tue, 20 Oct 2020 09:11:54 GMT"}], "update_date": "2020-10-21", "authors_parsed": [["\u015eekerci", "Alper", ""], ["Salehi", "\u00d6zlem", ""]]}, {"id": "2010.10223", "submitter": "Stefan Zetzsche", "authors": "Stefan Zetzsche, Alexandra Silva, Matteo Sammartino", "title": "Generators and bases for algebras over a monad", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Some of the fundamental notions of linear algebra are the concepts of a\ngenerator and a basis for a vector space. In the category theoretic formulation\nof universal algebra, vector spaces are the Eilenberg-Moore algebras over the\nfree vector space monad on the category of sets. In this paper we investigate\ngeneral notions of generators and bases for algebras over arbitrary monads on\narbitrary categories. On the one hand, we establish purely algebraic results,\nfor instance about the existence and uniqueness of generators and bases, the\nrepresentation of algebra homomorphisms, and the product of generators. On the\nother hand, we use the general notion in the context of coalgebraic systems and\nshow that a generator for the underlying algebra of a bialgebra gives rise to\nan equivalent free bialgebra. As a result, we are able to recover known\nconstructions from automata theory such as the canonical residual finite state\nautomaton and the minimal xor automaton. Finally, we instantiate the framework\nto a variety of example monads, both set and non set-based.\n", "versions": [{"version": "v1", "created": "Tue, 20 Oct 2020 12:17:06 GMT"}, {"version": "v2", "created": "Thu, 10 Jun 2021 15:29:52 GMT"}, {"version": "v3", "created": "Wed, 30 Jun 2021 14:16:56 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Zetzsche", "Stefan", ""], ["Silva", "Alexandra", ""], ["Sammartino", "Matteo", ""]]}, {"id": "2010.10912", "submitter": "Daniel Hausmann", "authors": "Daniel Hausmann, Stefan Milius and Lutz Schr\\\"oder", "title": "Harnessing LTL With Freeze Quantification", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logics and automata models for languages over infinite alphabets, such as\nFreeze LTL and register automata, serve the verification of processes or\ndocuments with data. They relate tightly to formalisms over nominal sets, such\nas nondetermininistic orbit-finite automata (NOFAs), where names play the role\nof data. Reasoning problems in such formalisms tend to be computationally hard.\nName-binding nominal automata models such as regular nondeterministic automata\n(RNNAs) have been shown to be computationally more tractable. In the present\npaper, we introduce a linear-time logic Bar-muTL for finite words over an\ninfinite alphabet, which features full negation and freeze quantification via\nname binding. We show by reduction to extended regular nondeterministic nominal\nautomata that even though Bar-muTL allows liveness constraints, unrestricted\nnondeterminism, and unboundedly many registers, model checking Bar-muTL over\nRNNAs and satisfiability checking both have elementary complexity. E.g., model\nchecking is in ExpSpace, more precisely in parametrized PSpace, effectively\nwith the number of registers as the parameter.\n", "versions": [{"version": "v1", "created": "Wed, 21 Oct 2020 11:48:33 GMT"}, {"version": "v2", "created": "Wed, 11 Nov 2020 12:51:36 GMT"}, {"version": "v3", "created": "Sat, 13 Feb 2021 18:24:17 GMT"}], "update_date": "2021-02-16", "authors_parsed": [["Hausmann", "Daniel", ""], ["Milius", "Stefan", ""], ["Schr\u00f6der", "Lutz", ""]]}, {"id": "2010.10956", "submitter": "Jeffrey Shallit", "authors": "Jeffrey Shallit", "title": "Subword complexity of the Fibonacci-Thue-Morse sequence: the proof of\n  Dekking's conjecture", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recently Dekking conjectured the form of the subword complexity function for\nthe Fibonacci-Thue-Morse sequence. In this note we prove his conjecture by\npurely computational means, using the free software Walnut.\n", "versions": [{"version": "v1", "created": "Wed, 21 Oct 2020 12:51:03 GMT"}, {"version": "v2", "created": "Sat, 31 Oct 2020 07:23:22 GMT"}, {"version": "v3", "created": "Sun, 8 Nov 2020 10:31:35 GMT"}], "update_date": "2020-11-10", "authors_parsed": [["Shallit", "Jeffrey", ""]]}, {"id": "2010.11056", "submitter": "Carina Pilch", "authors": "Jannik H\\\"uls, Carina Pilch, Patricia Schinke, Henner Niehaus, Joanna\n  Delicaris, Anne Remke", "title": "State-space construction of Hybrid Petri nets with multiple stochastic\n  firings", "comments": "36 pages, 9 figures, submitted to ACM Transactions on Modeling and\n  Computer Simulation (TOMACS)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hybrid Petri nets have been extended to include general transitions that fire\nafter a randomly distributed amount of time. With a single general one-shot\ntransition the state space and evolution over time can be represented either as\na Parametric Location Tree or as a Stochastic Time Diagram. Recent work has\nshown that both representations can be combined and then allow multiple\nstochastic firings. This work presents an algorithm for building the Parametric\nLocation Tree with multiple general transition firings and shows how its\ntransient probability distribution can be computed using multi-dimensional\nintegration. We discuss the (dis-)advantages of an interval arithmetic and a\ngeometric approach to compute the areas of integration. Furthermore, we provide\ndetails on how to perform a Monte Carlo integration either directly on these\nintervals or convex polytopes, or after transformation to standard simplices. A\ncase study on a battery-backup system shows the feasibility of the approach and\ndiscusses the performance of the different integration approaches.\n", "versions": [{"version": "v1", "created": "Wed, 21 Oct 2020 15:08:15 GMT"}], "update_date": "2020-10-22", "authors_parsed": [["H\u00fcls", "Jannik", ""], ["Pilch", "Carina", ""], ["Schinke", "Patricia", ""], ["Niehaus", "Henner", ""], ["Delicaris", "Joanna", ""], ["Remke", "Anne", ""]]}, {"id": "2010.11605", "submitter": "Jens Oliver Gutsfeld", "authors": "Jens Oliver Gutsfeld, Markus M\\\"uller-Olm and Christoph Ohrem", "title": "Automata and Fixpoints for Asynchronous Hyperproperties", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hyperproperties have received increasing attention in the last decade due to\ntheir importance e.g. for security analyses. Past approaches have focussed on\nsynchronous analyses, i.e. techniques in which different paths are compared\nlockstepwise. In this paper, we systematically study asynchronous analyses for\nhyperproperties by introducing both a novel automata model (Alternating\nAsynchronous Parity Automata) and the temporal fixpoint calculus $\\Hmu$, the\nfirst fixpoint calculus that can systematically express hyperproperties in an\nasynchronous manner and at the same time subsumes the existing logic HyperLTL.\nWe show that the expressive power of both models coincides over fixed path\nassignments. The high expressive power of both models is evidenced by the fact\nthat decision problems of interest are highly undecidable, i.e. not even\narithmetical. As a remedy, we propose approximative analyses for both models\nthat also induce natural decidable fragments.\n", "versions": [{"version": "v1", "created": "Thu, 22 Oct 2020 11:06:16 GMT"}], "update_date": "2020-10-23", "authors_parsed": [["Gutsfeld", "Jens Oliver", ""], ["M\u00fcller-Olm", "Markus", ""], ["Ohrem", "Christoph", ""]]}, {"id": "2010.11706", "submitter": "Martin Zimmermann", "authors": "Martin Zimmermann", "title": "Approximating the Minimal Lookahead Needed to Win Infinite Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an exponential-time algorithm approximating the minimal lookahead\nnecessary to win an $\\omega$-regular delay game.\n", "versions": [{"version": "v1", "created": "Thu, 22 Oct 2020 13:30:30 GMT"}], "update_date": "2020-10-23", "authors_parsed": [["Zimmermann", "Martin", ""]]}, {"id": "2010.12892", "submitter": "Christoph Haase", "authors": "Christoph Haase and Jakub R\\'o\\.zycki", "title": "On the Expressiveness of B\\\"uchi Arithmetic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We show that the existential fragment of B\\\"uchi arithmetic is strictly less\nexpressive than full B\\\"uchi arithmetic of any base, and moreover establish\nthat its $\\Sigma_2$-fragment is already expressively complete. Furthermore, we\nshow that regular languages of polynomial growth are definable in the\nexistential fragment of B\\\"uchi arithmetic.\n", "versions": [{"version": "v1", "created": "Sat, 24 Oct 2020 12:39:27 GMT"}, {"version": "v2", "created": "Fri, 8 Jan 2021 15:02:07 GMT"}, {"version": "v3", "created": "Tue, 2 Mar 2021 23:49:48 GMT"}], "update_date": "2021-03-04", "authors_parsed": [["Haase", "Christoph", ""], ["R\u00f3\u017cycki", "Jakub", ""]]}, {"id": "2010.13347", "submitter": "Milliam Maxime Zekeng Ndadji", "authors": "Milliam Maxime Zekeng Ndadji and Maurice Tchoup\\'e Tchendji and\n  Cl\\'ementin Tayou Djamegni and Didier Parigot", "title": "A Language and Methodology based on Scenarios, Grammars and Views, for\n  Administrative Business Processes Modelling", "comments": null, "journal-ref": "ParadigmPlus, Volume 1, Number 3, October 2020, pages 1-22", "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In Business Process Management (BPM), process modelling has been solved in\nvarious ways. However, there are no commonly accepted modelling tools\n(languages). Some of them are criticized for their inability to capture both\nthe lifecycle, informational and organizational models of processes. For some\nothers, process modelling is generally done using a single graph; this does not\nfacilitate modularity, maintenance and scalability. In addition, some of these\nlanguages are very general; hence, their application to specific domain\nprocesses (such as administrative processes) is very complex. In this paper, we\npresent a new language and a new methodology, dedicated to administrative\nprocess modelling. This language is based on a variant of attributed grammars\nand is able to capture the lifecycle, informational and organizational models\nof such processes. Also, it proposes a simple graphical formalism allowing to\nmodel each process's execution scenario as an annotated tree (modularity). In\nthe new language, a particular emphasis is put on modelling (using \"views\") the\nperceptions that actors have on processes and their data.\n", "versions": [{"version": "v1", "created": "Mon, 26 Oct 2020 05:28:54 GMT"}], "update_date": "2020-10-27", "authors_parsed": [["Ndadji", "Milliam Maxime Zekeng", ""], ["Tchendji", "Maurice Tchoup\u00e9", ""], ["Djamegni", "Cl\u00e9mentin Tayou", ""], ["Parigot", "Didier", ""]]}, {"id": "2010.13442", "submitter": "Markus Schmid", "authors": "Markus L. Schmid and Nicole Schweikardt", "title": "A Purely Regular Approach to Non-Regular Core Spanners", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.FL cs.IR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The regular spanners (characterised by vset-automata) are closed under the\nalgebraic operations of union, join and projection, and have desirable\nalgorithmic properties. The core spanners (introduced by Fagin, Kimelfeld,\nReiss, and Vansummeren (PODS 2013, JACM 2015) as a formalisation of the core\nfunctionality of the query language AQL used in IBM's SystemT) additionally\nneed string equality selections and it has been shown by Freydenberger and\nHolldack (ICDT 2016, Theory of Computing Systems 2018) that this leads to high\ncomplexity and even undecidability of the typical problems in static analysis\nand query evaluation. We propose an alternative approach to core spanners: by\nincorporating the string-equality selections directly into the regular language\nthat represents the underlying regular spanner (instead of treating it as an\nalgebraic operation on the table extracted by the regular spanner), we obtain a\nfragment of core spanners that, while having slightly weaker expressive power\nthan the full class of core spanners, arguably still covers the intuitive\napplications of string equality selections for information extraction and has\nmuch better upper complexity bounds of the typical problems in static analysis\nand query evaluation.\n", "versions": [{"version": "v1", "created": "Mon, 26 Oct 2020 09:27:39 GMT"}], "update_date": "2020-10-27", "authors_parsed": [["Schmid", "Markus L.", ""], ["Schweikardt", "Nicole", ""]]}, {"id": "2010.13675", "submitter": "Daniela Petri\\c{s}an", "authors": "Thomas Colcombet, Daniela Petri\\c{s}an, Riccardo Stabile", "title": "Learning automata and transducers: a categorical approach", "comments": "30 pages, long version of a CSL'21 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper, we present a categorical approach to learning automata over\nwords, in the sense of the $L^*$-algorithm of Angluin. This yields a new\ngeneric $L^*$-like algorithm which can be instantiated for learning\ndeterministic automata, automata weighted over fields, as well as subsequential\ntransducers. The generic nature of our algorithm is obtained by adopting an\napproach in which automata are simply functors from a particular category\nrepresenting words to a \"computation category\". We establish that the\nsufficient properties for yielding the existence of minimal automata (that were\ndisclosed in a previous paper), in combination with some additional hypotheses\nrelative to termination, ensure the correctness of our generic algorithm.\n", "versions": [{"version": "v1", "created": "Mon, 26 Oct 2020 15:52:15 GMT"}], "update_date": "2020-10-27", "authors_parsed": [["Colcombet", "Thomas", ""], ["Petri\u015fan", "Daniela", ""], ["Stabile", "Riccardo", ""]]}, {"id": "2010.14432", "submitter": "Edon Kelmendi", "authors": "Shaull Almagor, Toghrul Karimov, Edon Kelmendi, J\\\"oel Ouaknine, James\n  Worrell", "title": "Deciding $\\omega$-Regular Properties on Linear Recurrence Sequences", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problem of deciding $\\omega$-regular properties on infinite\ntraces produced by linear loops. Here we think of a given loop as producing a\nsingle infinite trace that encodes information about the signs of program\nvariables at each time step. Formally, our main result is a procedure that\ninputs a prefix-independent $\\omega$-regular property and a sequence of numbers\nsatisfying a linear recurrence, and determines whether the sign description of\nthe sequence (obtained by replacing each positive entry with \"$+$\", each\nnegative entry with \"$-$\", and each zero entry with \"$0$\") satisfies the given\nproperty. Our procedure requires that the recurrence be simple, \\ie, that the\nupdate matrix of the underlying loop be diagonalisable. This assumption is\ninstrumental in proving our key technical lemma: namely that the sign\ndescription of a simple linear recurrence sequence is almost periodic in the\nsense of Muchnik, Sem\\\"enov, and Ushakov. To complement this lemma, we give an\nexample of a linear recurrence sequence whose sign description fails to be\nalmost periodic. Generalising from sign descriptions, we also consider the\nverification of properties involving semi-algebraic predicates on program\nvariables.\n", "versions": [{"version": "v1", "created": "Tue, 27 Oct 2020 16:49:14 GMT"}], "update_date": "2020-10-28", "authors_parsed": [["Almagor", "Shaull", ""], ["Karimov", "Toghrul", ""], ["Kelmendi", "Edon", ""], ["Ouaknine", "J\u00f6el", ""], ["Worrell", "James", ""]]}, {"id": "2010.16235", "submitter": "Karl-Heinz Zimmermann", "authors": "Karl-Heinz Zimmermann", "title": "On Krohn-Rhodes theory for semiautomata", "comments": "29 pages, 0 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Krohn-Rhodes theory encompasses the techniques for the study of finite\nautomata and their decomposition into elementary automata. The famous result of\nKrohn and Rhodes roughly states that each finite automaton can be decomposed\ninto elementary components which correspond to permutation and reset automata\nconnected by a cascade product. However, this outcome is not easy to access for\nthe working computer scientist. This paper provides a short introduction into\nKrohn-Rhodes theory based on the valuable work of Ginzburg.\n", "versions": [{"version": "v1", "created": "Fri, 30 Oct 2020 13:09:22 GMT"}], "update_date": "2020-11-02", "authors_parsed": [["Zimmermann", "Karl-Heinz", ""]]}]