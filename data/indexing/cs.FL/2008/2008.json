[{"id": "2008.00255", "submitter": "Palak Pandoh Ms.", "authors": "Kalpana Mahalingam, Palak Pandoh, Anuran Maity", "title": "Theta palindromes in theta conjugates", "comments": "Any suggestions and comments are welcome", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A DNA string is a Watson-Crick (WK) palindrome when the complement of its\nreverse is equal to itself. The Watson-Crick mapping $\\theta$ is an involution\nthat is also an antimorphism. $\\theta$-conjugates of a word is a generalisation\nof conjugates of a word that incorporates the notion of WK-involution $\\theta$.\nIn this paper, we study the distribution of palindromes and Watson-Crick\npalindromes, also known as $\\theta$-palindromes among both the set of\nconjugates and $\\theta$-conjugates of a word $w$. We also consider some general\nproperties of the set $C_{\\theta}(w)$, i.e., the set of $\\theta$-conjugates of\na word $w$, and characterize words $w$ such that $|C_{\\theta}(w)|=|w|+1$, i.e.,\nwith the maximum number of elements in $C_{\\theta}(w)$. We also find the\nstructure of words that have at least one (WK)-palindrome in $C_{\\theta}(w)$.\n", "versions": [{"version": "v1", "created": "Sat, 1 Aug 2020 12:05:34 GMT"}], "update_date": "2020-08-04", "authors_parsed": [["Mahalingam", "Kalpana", ""], ["Pandoh", "Palak", ""], ["Maity", "Anuran", ""]]}, {"id": "2008.00474", "submitter": "Aryeh Wiesen", "authors": "David Dayan, Rivka Kaplinsky, Aryeh Wiesen, and Simon Bloch", "title": "MDA Models and PIM/PSM Transformations Using Extended Automata", "comments": "11 pages, 5 figures, 2 tables", "journal-ref": null, "doi": "10.1109/SwSTE.2007.13", "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes a model of execution platform for the OMG request of a\ngeneric PlatformIndependent-Model (PIM) allowing realization of the Model\nDriven Architecture (MDA) standard. We propose AMDA (Automata based MDA), a\nmethod based on the use of parallel automata, which can be a common tool for\nbuilding a PIM from UML diagrams (including OCL) and transforming the PIM to\nPSM automata and further to compilable code. Each platform would then have a\nmechanism to execute the translated code. Our architecture for a general PSM\ntranslator of these automata allows portable execution on various specific\nimplementation platforms. This general translator must be written, once, for\nthe languages and with the libraries of the required specific PSM. This allows\nalso interoperability between different PSMs. An ATM case study example is\npresented to illustrate the approach.\n", "versions": [{"version": "v1", "created": "Sun, 2 Aug 2020 12:53:04 GMT"}], "update_date": "2020-08-04", "authors_parsed": [["Dayan", "David", ""], ["Kaplinsky", "Rivka", ""], ["Wiesen", "Aryeh", ""], ["Bloch", "Simon", ""]]}, {"id": "2008.00650", "submitter": "Thorsten Wissmann", "authors": "Pawe{\\l} Parys", "title": "On the Expressive Power of Higher-Order Pushdown Systems", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 3 (August\n  20, 2020) lmcs:6723", "doi": "10.23638/LMCS-16(3:11)2020", "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We show that deterministic collapsible pushdown automata of second order can\nrecognize a language that is not recognizable by any deterministic higher-order\npushdown automaton (without collapse) of any order. This implies that there\nexists a tree generated by a second order collapsible pushdown system\n(equivalently, by a recursion scheme of second order) that is not generated by\nany deterministic higher-order pushdown system (without collapse) of any order\n(equivalently, by any safe recursion scheme of any order). As a side effect, we\npresent a pumping lemma for deterministic higher-order pushdown automata, which\npotentially can be useful for other applications.\n", "versions": [{"version": "v1", "created": "Mon, 3 Aug 2020 05:24:14 GMT"}, {"version": "v2", "created": "Wed, 19 Aug 2020 14:16:43 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Parys", "Pawe\u0142", ""]]}, {"id": "2008.01050", "submitter": "L\\^e Th\\`anh D\\~ung (Tito) Nguy\\^en", "authors": "L\\^e Th\\`anh D\\~ung Nguy\\^en, Camille No\\^us and Pierre Pradic", "title": "Implicit automata in typed $\\lambda$-calculi II: streaming transducers\n  vs categorical semantics", "comments": "105 pages, 24 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We characterize regular string transductions as programs in a linear\n$\\lambda$-calculus with additives. One direction of this equivalence is proved\nby encoding copyless streaming string transducers (SSTs), which compute regular\nfunctions, into our $\\lambda$-calculus. For the converse, we consider a\ncategorical framework for defining automata and transducers over words, which\nallows us to relate register updates in SSTs to the semantics of the linear\n$\\lambda$-calculus in a suitable monoidal closed category. To illustrate the\nrelevance of monoidal closure to automata theory, we also leverage this notion\nto give abstract generalizations of the arguments showing that copyless SSTs\nmay be determinized and that the composition of two regular functions may be\nimplemented by a copyless SST. Our main result is then generalized from strings\nto trees using a similar approach. In doing so, we exhibit a connection between\na feature of streaming tree transducers and the multiplicative/additive\ndistinction of linear logic.\n  Keywords: MSO transductions, implicit complexity, Dialectica categories,\nChurch encodings\n", "versions": [{"version": "v1", "created": "Mon, 3 Aug 2020 17:37:10 GMT"}, {"version": "v2", "created": "Mon, 16 Nov 2020 16:04:39 GMT"}], "update_date": "2020-11-17", "authors_parsed": [["Nguy\u00ean", "L\u00ea Th\u00e0nh D\u0169ng", ""], ["No\u00fbs", "Camille", ""], ["Pradic", "Pierre", ""]]}, {"id": "2008.01413", "submitter": "Ryoma Sin'ya", "authors": "Ryoma Sin'ya", "title": "Asymptotic Approximation by Regular Languages", "comments": "This is the full version of a paper accepted by SOFSEM 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper investigates a new property of formal languages called\nREG-measurability where REG is the class of regular languages. Intuitively, a\nlanguage \\(L\\) is REG-measurable if there exists an infinite sequence of\nregular languages that \"converges\" to \\(L\\). A language without\nREG-measurability has a complex shape in some sense so that it can not be\n(asymptotically) approximated by regular languages. We show that several\ncontext-free languages are REG-measurable (including languages with\ntranscendental generating function and transcendental density, in particular),\nwhile a certain simple deterministic context-free language and the set of\nprimitive words are REG-immeasurable in a strong sense.\n", "versions": [{"version": "v1", "created": "Tue, 4 Aug 2020 08:43:50 GMT"}, {"version": "v2", "created": "Tue, 17 Nov 2020 10:44:13 GMT"}], "update_date": "2020-11-18", "authors_parsed": [["Sin'ya", "Ryoma", ""]]}, {"id": "2008.01704", "submitter": "Depeng Liu", "authors": "Depeng Liu, Bow-yaw Wang and Lijun Zhang", "title": "Verifying Pufferfish Privacy in Hidden Markov Models", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Pufferfish is a Bayesian privacy framework for designing and analyzing\nprivacy mechanisms. It refines differential privacy, the current gold standard\nin data privacy, by allowing explicit prior knowledge in privacy analysis.\nThrough these privacy frameworks, a number of privacy mechanisms have been\ndeveloped in literature. In practice, privacy mechanisms often need be modified\nor adjusted to specific applications. Their privacy risks have to be\nre-evaluated for different circumstances. Moreover, computing devices only\napproximate continuous noises through floating-point computation, which is\ndiscrete in nature. Privacy proofs can thus be complicated and prone to errors.\nSuch tedious tasks can be burdensome to average data curators. In this paper,\nwe propose an automatic verification technique for Pufferfish privacy. We use\nhidden Markov models to specify and analyze discretized Pufferfish privacy\nmechanisms. We show that the Pufferfish verification problem in hidden Markov\nmodels is NP-hard. Using Satisfiability Modulo Theories solvers, we propose an\nalgorithm to analyze privacy requirements. We implement our algorithm in a\nprototypical tool called FAIER, and present several case studies. Surprisingly,\nour case studies show that na\\\"ive discretization of well-established privacy\nmechanisms often fail, witnessed by counterexamples generated by FAIER. In\ndiscretized \\emph{Above Threshold}, we show that it results in absolutely no\nprivacy. Finally, we compare our approach with testing based approach on\nseveral case studies, and show that our verification technique can be combined\nwith testing based approach for the purpose of (i) efficiently certifying\ncounterexamples and (ii) obtaining a better lower bound for the privacy budget\n$\\epsilon$.\n", "versions": [{"version": "v1", "created": "Tue, 4 Aug 2020 17:11:45 GMT"}], "update_date": "2020-08-05", "authors_parsed": [["Liu", "Depeng", ""], ["Wang", "Bow-yaw", ""], ["Zhang", "Lijun", ""]]}, {"id": "2008.01824", "submitter": "\\v{S}t\\v{e}p\\'an Holub", "authors": "Giuseppa Castiglione and \\v{S}t\\v{e}p\\'an Holub", "title": "The Intersection of $3$-Maximal Submonids", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Very little is known about the structure of the intersection of two\n$k$-generated monoids of words, even for $k=3$. Here we investigate the case of\n$k$-maximal monoids, that is, monoids whose basis of cardinality $k$ cannot be\nnon-trivially decomposed into at most $k$ words. We characterize the\nintersection in the case of two $3$-maximal monoids.\n", "versions": [{"version": "v1", "created": "Tue, 4 Aug 2020 20:56:08 GMT"}], "update_date": "2020-08-06", "authors_parsed": [["Castiglione", "Giuseppa", ""], ["Holub", "\u0160t\u011bp\u00e1n", ""]]}, {"id": "2008.02239", "submitter": "Aleksander Mendoza-Drosik", "authors": "Aleksander Mendoza-Drosik", "title": "Glushkov's construction for functional subsequential transducers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Glushkov's construction has many interesting properties and they become even\nmore evident when applied to transducers. This article strives to show the wast\nrange of possible extensions and optimisations for this algorithm. Special\nflavour of regular expressions is introduced, which can be efficiently\nconverted to $\\epsilon$-free functional subsequential weighted finite state\ntransducers. Produced automata are very compact, as they contain only one state\nfor each symbol (from input alphabet) of original expression and only one\ntransition for each range of symbols, no matter how large. Such compactified\nranges of transitions allow for efficient binary search lookup during automaton\nevaluation. All the methods and algorithms presented here were used to\nimplement open-source compiler of regular expressions for multitape\ntransducers.\n", "versions": [{"version": "v1", "created": "Wed, 5 Aug 2020 17:09:58 GMT"}, {"version": "v2", "created": "Wed, 12 Aug 2020 16:09:54 GMT"}, {"version": "v3", "created": "Fri, 21 Aug 2020 17:42:10 GMT"}, {"version": "v4", "created": "Tue, 22 Sep 2020 13:36:57 GMT"}], "update_date": "2020-09-23", "authors_parsed": [["Mendoza-Drosik", "Aleksander", ""]]}, {"id": "2008.02511", "submitter": "Dmitry Berdinsky", "authors": "Dmitry Berdinsky, Murray Elder, Prohrak Kruengthomya", "title": "Cayley Polynomial-Time Computable Groups", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a new generalisation of Cayley automatic groups, varying the time\ncomplexity of computing multiplication, and language complexity of the normal\nform representatives. We first consider groups which have normal form language\nin the class $\\mathcal C$ and multiplication by generators computable in linear\ntime on a certain restricted Turing machine model (position-faithful one-tape).\nWe show that many of the algorithmic properties of automatic groups are\npreserved (quadratic time word problem), prove various closure properties, and\nshow that the class is quite large; for example it includes all virtually\npolycyclic groups. We then generalise to groups which have normal form language\nin the class $\\mathcal C$ and multiplication by generators computable in\npolynomial time on a (standard) Turing machine. Of particular interest is when\n$\\mathcal C= \\mathrm{REG}$ (the class of regular languages). We prove that\n$\\mathrm{REG}$-Cayley polynomial-time computable groups includes all finitely\ngenerated nilpotent groups, the wreath product $\\mathbb Z_2 \\wr \\mathbb Z^2$,\nand Thompson's group $F$.\n", "versions": [{"version": "v1", "created": "Thu, 6 Aug 2020 08:13:36 GMT"}], "update_date": "2020-08-07", "authors_parsed": [["Berdinsky", "Dmitry", ""], ["Elder", "Murray", ""], ["Kruengthomya", "Prohrak", ""]]}, {"id": "2008.02929", "submitter": "EPTCS", "authors": "Alain Finkel (Universite Paris-Saclay, ENS Paris-Saclay, CNRS)", "title": "From Well Structured Transition Systems to Program Verification", "comments": "In Proceedings VPT/HCVS 2020, arXiv:2008.02483", "journal-ref": "EPTCS 320, 2020, pp. 44-49", "doi": "10.4204/EPTCS.320.3", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe the use of the theory of WSTS for verifying programs.\n", "versions": [{"version": "v1", "created": "Fri, 7 Aug 2020 01:22:54 GMT"}], "update_date": "2020-08-10", "authors_parsed": [["Finkel", "Alain", "", "Universite Paris-Saclay, ENS Paris-Saclay, CNRS"]]}, {"id": "2008.03516", "submitter": "Lukas Haschke", "authors": "Pamela Fleischmann, Lukas Haschke, Florin Manea, Dirk Nowotka, Cedric\n  Tsatia Tsida, and Judith Wiedenbeck", "title": "Blocksequences of k-local Words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The locality of words is a relatively young structural complexity measure,\nintroduced by Day et al. in 2017 in order to define classes of patterns with\nvariables which can be matched in polynomial time. The main tool used to\ncompute the locality of a word is called marking sequence: an ordering of the\ndistinct letters occurring in the respective order. Once a marking sequence is\ndefined, the letters of the word are marked in steps: in the ith marking step,\nall occurrences of the ith letter of the marking sequence are marked. As such,\nafter each marking step, the word can be seen as a sequence of blocks of marked\nletters separated by blocks of non-marked letters. By keeping track of the\nevolution of the marked blocks of the word through the marking defined by a\nmarking sequence, one defines the blocksequence of the respective marking\nsequence. We first show that the words sharing the same blocksequence are only\nloosely connected, so we consider the stronger notion of extended\nblocksequence, which stores additional information on the form of each single\nmarked block. In this context, we present a series of combinatorial results for\nwords sharing the extended blocksequence.\n", "versions": [{"version": "v1", "created": "Sat, 8 Aug 2020 13:13:37 GMT"}, {"version": "v2", "created": "Mon, 17 Aug 2020 17:30:51 GMT"}], "update_date": "2020-08-18", "authors_parsed": [["Fleischmann", "Pamela", ""], ["Haschke", "Lukas", ""], ["Manea", "Florin", ""], ["Nowotka", "Dirk", ""], ["Tsida", "Cedric Tsatia", ""], ["Wiedenbeck", "Judith", ""]]}, {"id": "2008.04080", "submitter": "Qiang Wang", "authors": "Qiang Wang and Dachuan Li and Joseph Sifakis", "title": "Safe and efficient collision avoidance control for autonomous vehicles", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.SE cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study a novel principle for safe and efficient collision avoidance that\nadopts a mathematically elegant and general framework abstracting as much as\npossible from the controlled vehicle's dynamics and of its environment. Vehicle\ndynamics is characterized by pre-computed functions for accelerating and\nbraking to a given speed. Environment is modeled by a function of time giving\nthe free distance ahead of the controlled vehicle under the assumption that the\nobstacles are either fixed or are moving in the same direction. The main result\nis a control policy enforcing the vehicle's speed so as to avoid collision and\nefficiently use the free distance ahead, provided some initial safety condition\nholds. The studied principle is applied to the design of two discrete\ncontrollers, one synchronous and another asynchronous. We show that both\ncontrollers are safe by construction. Furthermore, we show that their\nefficiency strictly increases for decreasing granularity of discretization. We\npresent implementations of the two controllers, their experimental evaluation\nin the Carla autonomous driving simulator and investigate various performance\nissues.\n", "versions": [{"version": "v1", "created": "Mon, 10 Aug 2020 12:53:56 GMT"}, {"version": "v2", "created": "Fri, 2 Oct 2020 19:15:38 GMT"}], "update_date": "2020-10-06", "authors_parsed": [["Wang", "Qiang", ""], ["Li", "Dachuan", ""], ["Sifakis", "Joseph", ""]]}, {"id": "2008.04160", "submitter": "Radu Iosif", "authors": "Marius Bozga and Radu Iosif", "title": "Verifying Safety Properties of Inductively Defined Parameterized Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a term algebra as a new formal specification language for the\ncoordinating architectures of distributed systems consisting of a finite yet\nunbounded number of components. The language allows to describe infinite sets\nof systems whose coordination between components share the same pattern, using\ninductive definitions similar to the ones used to describe algebraic data types\nor recursive data structures. Further, we give a verification method for the\nparametric systems described in this language, relying on the automatic\nsynthesis of structural invariants that enable proving general safety\nproperties (mutual exclusion, absence of deadlocks). The invariants are defined\nusing the WSkS fragment of the monadic second order logic, known to be\ndecidable by a classical automata-logic connection. This reduces the safety\nverification problem to checking satisfiability of a WSkS formula.\n", "versions": [{"version": "v1", "created": "Mon, 10 Aug 2020 14:32:34 GMT"}, {"version": "v2", "created": "Sun, 11 Oct 2020 12:48:47 GMT"}, {"version": "v3", "created": "Wed, 14 Oct 2020 08:57:16 GMT"}], "update_date": "2020-10-15", "authors_parsed": [["Bozga", "Marius", ""], ["Iosif", "Radu", ""]]}, {"id": "2008.04232", "submitter": "Fabio Mogavero Ph.D.", "authors": "Massimo Benerecetti, Daniele Dell'Erba, Marco Faella, and Fabio\n  Mogavero", "title": "From Quasi-Dominions to Progress Measures", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we revisit the approaches to the solution of parity games based\non progress measures and show how the notion of quasi dominions can be\nintegrated with those approaches. The idea is that, while progress measure\nbased techniques typically focus on one of the two players, little information\nis gathered on the other player during the solution process. Adding quasi\ndominions provides additional information on this player that can be leveraged\nto accelerate convergence to a progress measure. To accommodate quasi\ndominions, however, a non trivial refinement of the approach is necessary. In\nparticular, we need to introduce a novel notion of measure and a new approach\nto prove correctness of the resulting solution technique.\n", "versions": [{"version": "v1", "created": "Mon, 10 Aug 2020 16:10:23 GMT"}], "update_date": "2020-08-11", "authors_parsed": [["Benerecetti", "Massimo", ""], ["Dell'Erba", "Daniele", ""], ["Faella", "Marco", ""], ["Mogavero", "Fabio", ""]]}, {"id": "2008.04461", "submitter": "Umair Siddique", "authors": "Umair Siddique", "title": "SafetyOps", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Safety assurance is a paramount factor in the large-scale deployment of\nvarious autonomous systems (e.g., self-driving vehicles). However, the\nexecution of safety engineering practices and processes have been challenged by\nan increasing complexity of modern safety-critical systems. This attribute has\nbecome more critical for autonomous systems that involve artificial\nintelligence (AI) and data-driven techniques along with the complex\ninteractions of the physical world and digital computing platforms. In this\nposition paper, we highlight some challenges of applying current safety\nprocesses to modern autonomous systems. Then, we introduce the concept of\nSafetyOps - a set of practices, which combines DevOps, TestOps, DataOps, and\nMLOps to provide an efficient, continuous and traceable system safety\nlifecycle. We believe that SafetyOps can play a significant role in scalable\nintegration and adaptation of safety engineering into various industries\nrelying on AI and data.\n", "versions": [{"version": "v1", "created": "Tue, 11 Aug 2020 00:33:15 GMT"}], "update_date": "2020-08-12", "authors_parsed": [["Siddique", "Umair", ""]]}, {"id": "2008.04667", "submitter": "EPTCS", "authors": "Lorenzo Clemente (University of Warsaw)", "title": "On the Complexity of the Universality and Inclusion Problems for\n  Unambiguous Context-Free Grammars", "comments": "In Proceedings VPT/HCVS 2020, arXiv:2008.02483. arXiv admin note:\n  identical to arXiv:2006.05275 , which has an added appendix", "journal-ref": "EPTCS 320, 2020, pp. 29-43", "doi": "10.4204/EPTCS.320.2", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the computational complexity of universality and inclusion problems\nfor unambiguous finite automata and context-free grammars. We observe that\nseveral such problems can be reduced to the universality problem for\nunambiguous context-free grammars. The latter problem has long been known to be\ndecidable and we propose a PSPACE algorithm that works by reduction to the\nzeroness problem of recurrence equations with convolution. We are not aware of\nany non-trivial complexity lower bounds. However, we show that computing the\ncoin-flip measure of an unambiguous context-free language, a quantitative\ngeneralisation of universality, is hard for the long-standing open problem\nSQRTSUM.\n", "versions": [{"version": "v1", "created": "Fri, 7 Aug 2020 01:22:41 GMT"}], "update_date": "2020-08-12", "authors_parsed": [["Clemente", "Lorenzo", "", "University of Warsaw"]]}, {"id": "2008.04971", "submitter": "Gunther Cornelissen", "authors": "Jakub Byszewski, Gunther Cornelissen and Djurre Tijsma", "title": "Automata and finite order elements in the Nottingham group", "comments": "49 pages, 18 figures; arxiv submission includes ancillary files:\n  Mathematica notebooks (+pdf) containing examples and verifications;, a\n  txt-file containing a MAGMA routine by A. Bridy and G. Cornelissen to compute\n  the labelled graph structure of an automaton from an algebraic equation\n  (using differential forms on algebraic curves); v2: small corrections", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NT cs.FL math.AG math.GR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Nottingham group at 2 is the group of (formal) power series $t+a_2 t^2+\na_3 t^3+ \\cdots$ in the variable $t$ with coefficients $a_i$ from the field\nwith two elements, where the group operation is given by composition of power\nseries. The depth of such a series is the largest $d\\geq 1$ for which\n$a_2=\\dots=a_d=0$. Only a handful of power series of finite order are\nexplicitly known through a formula for their coefficients. We argue in this\npaper that it is advantageous to describe such series in closed computational\nform through automata, based on effective versions of proofs of Christol's\ntheorem identifying algebraic and automatic series. Up to conjugation, there\nare only finitely many series $\\sigma$ of order $2^n$ with fixed break sequence\n(i.e. the sequence of depths of $\\sigma^{\\circ 2^i}$). Starting from Witt\nvector or Carlitz module constructions, we give an explicit automaton-theoretic\ndescription of: (a) representatives up to conjugation for all series of order 4\nwith break sequence (1,m) for m<10; (b) representatives up to conjugation for\nall series of order 8 with minimal break sequence (1,3,11); and (c) an\nembedding of the Klein four-group into the Nottingham group at 2. We study the\ncomplexity of the new examples from the algebro-geometric properties of the\nequations they satisfy. For this, we generalise the theory of sparseness of\npower series to a four-step hierarchy of complexity, for which we give both\nGalois-theoretic and combinatorial descriptions. We identify where our\ndifferent series fit into this hierarchy. We construct sparse representatives\nfor the conjugacy class of elements of order two and depth $2^\\mu \\pm 1$ $(\\mu\n\\geq 1)$. Series with small state complexity can end up high in the hierarchy.\nThis is true, for example, for a new automaton we found, representing a series\nof order 4 with 5 states, the minimal possible number for such a series.\n", "versions": [{"version": "v1", "created": "Tue, 11 Aug 2020 19:16:41 GMT"}, {"version": "v2", "created": "Thu, 1 Oct 2020 17:45:28 GMT"}], "update_date": "2020-10-02", "authors_parsed": [["Byszewski", "Jakub", ""], ["Cornelissen", "Gunther", ""], ["Tijsma", "Djurre", ""]]}, {"id": "2008.04993", "submitter": "Szabolcs Iv\\'an", "authors": "Zsolt Gazdag and K\\'aroly Hajagos and Szabolcs Iv\\'an", "title": "On the number of useful objects in P systems with active membranes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we investigate the number of objects actually used in the\nterminating computations of a certain variant of polarizationless P systems\nwith active membranes. The P systems we consider here have no in-communication\nrules and have no different rules triggered by the same object to manipulate\nthe same membrane. We show that if we consider such a P system $\\Pi$ and its\nterminating computation $\\cal C$, then we can compute the result of $\\cal C$ by\nsetting a polynomial upper bound on the content of each region in $\\cal C$.\n", "versions": [{"version": "v1", "created": "Tue, 11 Aug 2020 20:30:03 GMT"}], "update_date": "2020-08-13", "authors_parsed": [["Gazdag", "Zsolt", ""], ["Hajagos", "K\u00e1roly", ""], ["Iv\u00e1n", "Szabolcs", ""]]}, {"id": "2008.05263", "submitter": "Adam Svahn", "authors": "Adam J. Svahn and Mikhail Prokopenko", "title": "An Ansatz for undecidable computation in RNA-world automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "q-bio.QM cs.FL q-bio.PE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this Ansatz we consider theoretical constructions of RNA polymers into\nautomata, a form of computational structure. The basis for transitions in our\nautomata are plausible RNA-world enzymes that may perform ligation or cleavage.\nLimited to these operations, we construct RNA automata of increasing\ncomplexity; from the Finite Automaton (RNA-FA) to the Turing Machine equivalent\n2-stack PDA (RNA-2PDA) and the universal RNA-UPDA. For each automaton we show\nhow the enzymatic reactions match the logical operations of the RNA automaton,\nand describe how biological exploration of the corresponding evolutionary space\nis facilitated by the efficient arrangement of RNA polymers into a\ncomputational structure. A critical theme of the Ansatz is the self-reference\nin RNA automata configurations which exploits the program-data duality but\nresults in undecidable computation. We describe how undecidable computation is\nexemplified in the self-referential Liar paradox that places a boundary on a\nlogical system, and by construction, any RNA automata. We argue that an\nexpansion of the evolutionary space for RNA-2PDA automata can be interpreted as\na hierarchical resolution of the undecidable computation by a meta-system (akin\nto Turing's oracle), in a continual process analogous to Turing's ordinal\nlogics and Post's extensible recursively generated logics. On this basis, we\nput forward the hypothesis that the resolution of undecidable configurations in\nRNA-world automata represents a mechanism for novelty generation in the\nevolutionary space, and propose avenues for future investigation of biological\nautomata.\n", "versions": [{"version": "v1", "created": "Wed, 12 Aug 2020 12:16:07 GMT"}, {"version": "v2", "created": "Wed, 30 Sep 2020 12:22:25 GMT"}], "update_date": "2020-10-01", "authors_parsed": [["Svahn", "Adam J.", ""], ["Prokopenko", "Mikhail", ""]]}, {"id": "2008.05335", "submitter": "Luca Geatti", "authors": "Alessandro Cimatti, Luca Geatti, Nicola Gigante, Angelo Montanari and\n  Stefano Tonetta", "title": "Reactive Synthesis from Extended Bounded Response LTL Specifications", "comments": "Extended Version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reactive synthesis is a key technique for the design of\ncorrect-by-construction systems and has been thoroughly investigated in the\nlast decades. It consists in the synthesis of a controller that reacts to\nenvironment's inputs satisfying a given temporal logic specification. Common\napproaches are based on the explicit construction of automata and on their\ndeterminization, which limit their scalability.\n  In this paper, we introduce a new fragment of Linear Temporal Logic, called\nExtended Bounded Response LTL (\\LTLEBR), that allows one to combine bounded and\nuniversal unbounded temporal operators (thus covering a large set of practical\ncases), and we show that reactive synthesis from \\LTLEBR specifications can be\nreduced to solving a safety game over a deterministic symbolic automaton built\ndirectly from the specification. We prove the correctness of the proposed\napproach and we successfully evaluate it on various benchmarks.\n", "versions": [{"version": "v1", "created": "Wed, 12 Aug 2020 14:13:14 GMT"}], "update_date": "2020-08-13", "authors_parsed": [["Cimatti", "Alessandro", ""], ["Geatti", "Luca", ""], ["Gigante", "Nicola", ""], ["Montanari", "Angelo", ""], ["Tonetta", "Stefano", ""]]}, {"id": "2008.05420", "submitter": "Stefan Hoffmann", "authors": "Stefan Hoffmann", "title": "The Commutative Closure of Shuffle Expressions over Group Languages is\n  Regular", "comments": "Reworked the presentation of the first version and used the previous\n  result to prove that shuffle expressions over group languages are regular.\n  The rather long and technical presentation of the state label method is\n  deferred to the appendix, the main paper tries to give an intuitive picture", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that the commutative closure combined with the iterative shuffle is a\nregularity-preserving operation on group languages. In particular, for\ncommutative group languages, the iterated shuffle is a regularity-preserving\noperation. We also give bounds for the size of minimal recognizing automata.\nThen, we use these results to deduce that the commutative closure of any\nshuffle expression over group languages, i.e., expressions involving shuffle,\niterated shuffle, concatenation, Kleene star and union in any order, starting\nwith the group languages, always yields a regular language.\n", "versions": [{"version": "v1", "created": "Wed, 12 Aug 2020 16:22:40 GMT"}, {"version": "v2", "created": "Sun, 14 Mar 2021 19:33:41 GMT"}], "update_date": "2021-03-16", "authors_parsed": [["Hoffmann", "Stefan", ""]]}, {"id": "2008.06268", "submitter": "Muddassar Sindhu", "authors": "Muddassar A. Sindhu", "title": "An Efficient Model Inference Algorithm for Learning-based Testing of\n  Reactive Systems", "comments": "29 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Learning-based testing (LBT) is an emerging methodology to automate iterative\nblack-box requirements testing of software systems. The methodology involves\ncombining model inference with model checking techniques. However, a variety of\noptimisations on model inference are necessary in order to achieve scalable\ntesting for large systems. In this paper we describe the IKL learning algorithm\nwhich is an active incremental learning algorithm for deterministic Kripke\nstructures. We formally prove the correctness of IKL. We discuss the\noptimisations it incorporates to achieve scalability of testing. We also\nevaluate a black box heuristic for test termination based on convergence of IKL\nlearning.\n", "versions": [{"version": "v1", "created": "Fri, 14 Aug 2020 09:48:58 GMT"}], "update_date": "2020-08-17", "authors_parsed": [["Sindhu", "Muddassar A.", ""]]}, {"id": "2008.06315", "submitter": "Stanly Samuel", "authors": "Stanly Samuel (1), Kaushik Mallik (2), Anne-Kathrin Schmuck (2), and\n  Daniel Neider (2) ((1) Indian Institute of Science (IISc), Bengaluru, India,\n  (2) Max Planck Institute for Software Systems (MPI-SWS), Kaiserslautern,\n  Germany)", "title": "Resilient Abstraction-Based Controller Design", "comments": "9 pages, 5 images, 1 table, to appear in CDC 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the computation of resilient controllers for perturbed non-linear\ndynamical systems w.r.t. linear-time temporal logic specifications. We address\nthis problem through the paradigm of Abstraction-Based Controller Design (ABCD)\nwhere a finite state abstraction of the perturbed system dynamics is\nconstructed and utilized for controller synthesis. In this context, our\ncontribution is twofold: (I) We construct abstractions which model the impact\nof occasional high disturbance spikes on the system via so called disturbance\nedges. (II) We show that the application of resilient reactive synthesis\ntechniques to these abstract models results in closed loop systems which are\noptimally resilient to these occasional high disturbance spikes. We have\nimplemented this resilient ABCD workflow on top of SCOTS and showcase our\nmethod through multiple robot planning examples.\n", "versions": [{"version": "v1", "created": "Fri, 14 Aug 2020 12:07:52 GMT"}], "update_date": "2020-08-17", "authors_parsed": [["Samuel", "Stanly", ""], ["Mallik", "Kaushik", ""], ["Schmuck", "Anne-Kathrin", ""], ["Neider", "Daniel", ""]]}, {"id": "2008.06790", "submitter": "Lucas M. Tabajara", "authors": "Shufang Zhu, Lucas M. Tabajara, Geguang Pu, Moshe Y. Vardi", "title": "On the Power of Automata Minimization in Temporal Synthesis", "comments": "13 pages including Appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reactive synthesis is the problem of automatically constructing a reactive\nsystem from a formal specification, with the guarantee that the executions of\nthe system align with the specification. The specification is often described\nin temporal logic. Some types of specifications can be converted into\ndeterministic finite automata (DFA) as an intermediate step in synthesis, thus\nbenefiting from the fact that DFAs can be fully minimized in polynomial time.\nIn this work we investigate DFA-minimization algorithms in the context of\ntemporal synthesis. In particular, we compare between the Hopcroft and\nBrzozowski minimization algorithms, adapting them to start from temporal-logic\nformulas and integrating them into an existing temporal synthesis framework.\nWhile earlier studies comparing the two algorithms for randomly-generated\nautomata concluded that neither algorithm dominates, our results suggest that\nin the context of temporal-synthesis, Hopcroft's algorithm is the best choice.\nAnalyzing the results, we observe that the reason for the poor performance of\nBrzozowski's algorithm is a discrepancy between theory and practice. This\nalgorithm first constructs a DFA for the reverse language of the specification\nand then performs a series of operations to transform it into a minimal DFA for\nthe specification itself. In theory, the DFA for the reverse language can be\nexponentially smaller, which would potentially make this algorithm more\nefficient than directly constructing the DFA for the original specification. In\npractice, however, we find that the reverse DFA is often of comparable size or\neven larger, which cancels the advantage that this approach could have.\n", "versions": [{"version": "v1", "created": "Sat, 15 Aug 2020 21:30:38 GMT"}], "update_date": "2020-08-18", "authors_parsed": [["Zhu", "Shufang", ""], ["Tabajara", "Lucas M.", ""], ["Pu", "Geguang", ""], ["Vardi", "Moshe Y.", ""]]}, {"id": "2008.06805", "submitter": "Michael Wehar", "authors": "Andr\\'as Z. Salamon and Michael Wehar", "title": "Superlinear Lower Bounds Based on ETH", "comments": "Changed title, fixed minor typos, added additional explanation", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce techniques for proving superlinear conditional lower bounds for\npolynomial time problems. In particular, we show that CircuitSat for circuits\nwith m gates and log(m) inputs (denoted by log-CircuitSat) is not decidable in\nessentially-linear time unless the exponential time hypothesis (ETH) is false\nand k-Clique is decidable in essentially-linear time in terms of the graph's\nsize for all fixed k. These results offer significant progress towards proving\nunconditional superlinear time complexity lower bounds for natural problems in\npolynomial time.\n", "versions": [{"version": "v1", "created": "Sat, 15 Aug 2020 23:00:23 GMT"}, {"version": "v2", "created": "Sun, 8 Nov 2020 23:25:24 GMT"}, {"version": "v3", "created": "Tue, 10 Nov 2020 04:56:02 GMT"}, {"version": "v4", "created": "Mon, 1 Mar 2021 01:11:24 GMT"}], "update_date": "2021-03-02", "authors_parsed": [["Salamon", "Andr\u00e1s Z.", ""], ["Wehar", "Michael", ""]]}, {"id": "2008.06935", "submitter": "Abdulrazaq Abba", "authors": "Abdulrazaq Abba, Ana Cavalcanti, Jeremy Jacob", "title": "Automatic Translation of tock-CSP into Timed Automata", "comments": "An updated version of this paper is available in this link\n  arXiv:2104.13434", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The process algebra tock-CSP provides textual notations for modelling\ndiscrete-time behaviours, with the support of various tools for verification.\nSimilarly, automatic verification of Timed Automata (TA) is supported by the\nreal-time verification toolbox UPPAAL. TA and tock-CSP differ in both modelling\nand verification approaches. For instance, liveness requirements are difficult\nto specify with the constructs of tock-CSP, but they are easy to verify in\nUPPAAL. In this work, we translate tock-CSP into TA to take advantage of\nUPPAAL. We have developed a translation technique and tool; our work uses rules\nfor translating tock-CSP into a network of small TA, which address the\ncomplexity of capturing the compositionality of tock-CSP . For validation, we\nuse an experimental approach based on finite approximations to trace sets. We\nplan to use mathematical proof to establish the correctness of the rules that\nwill cover an infinite set of traces.\n", "versions": [{"version": "v1", "created": "Sun, 16 Aug 2020 15:23:43 GMT"}, {"version": "v2", "created": "Thu, 29 Apr 2021 09:33:52 GMT"}], "update_date": "2021-04-30", "authors_parsed": [["Abba", "Abdulrazaq", ""], ["Cavalcanti", "Ana", ""], ["Jacob", "Jeremy", ""]]}, {"id": "2008.08125", "submitter": "Markus Whiteland", "authors": "Svetlana Puzynina and Markus A. Whiteland", "title": "Abelian Closures of Infinite Binary Words", "comments": "32 pages, 8 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two finite words $u$ and $v$ are called Abelian equivalent if each letter\noccurs equally many times in both $u$ and $v$. The abelian closure\n$\\mathcal{A}(\\mathbf{x})$ of (the shift orbit closure of) an infinite word\n$\\mathbf{x}$ is the set of infinite words $\\mathbf{y}$ such that, for each\nfactor $u$ of $\\mathbf{y}$, there exists a factor $v$ of $\\mathbf{x}$ which is\nabelian equivalent to $u$. The notion of an abelian closure gives a\ncharacterization of Sturmian words: among binary uniformly recurrent words,\nSturmian words are exactly those words for which $\\mathcal{A}(\\mathbf{x})$\nequals the shift orbit closure $\\Omega(\\mathbf{x})$. In this paper we show\nthat, contrary to larger alphabets, the abelian closure of a uniformly\nrecurrent aperiodic binary word which is not Sturmian contains infinitely many\nminimal subshifts.\n", "versions": [{"version": "v1", "created": "Tue, 18 Aug 2020 19:09:58 GMT"}], "update_date": "2020-08-20", "authors_parsed": [["Puzynina", "Svetlana", ""], ["Whiteland", "Markus A.", ""]]}, {"id": "2008.08506", "submitter": "Zsuzsanna Lipt\\'ak", "authors": "Sara Giuliani and Shunsuke Inenaga and Zsuzsanna Lipt\\'ak and Nicola\n  Prezza and Marinella Sciortino and Anna Toffanello", "title": "Novel Results on the Number of Runs of the Burrows-Wheeler-Transform", "comments": "14 pages, 2 figues", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Burrows-Wheeler-Transform (BWT), a reversible string transformation, is\none of the fundamental components of many current data structures in string\nprocessing. It is central in data compression, as well as in efficient query\nalgorithms for sequence data, such as webpages, genomic and other biological\nsequences, or indeed any textual data. The BWT lends itself well to compression\nbecause its number of equal-letter-runs (usually referred to as $r$) is often\nconsiderably lower than that of the original string; in particular, it is well\nsuited for strings with many repeated factors. In fact, much attention has been\npaid to the $r$ parameter as measure of repetitiveness, especially to evaluate\nthe performance in terms of both space and time of compressed indexing data\nstructures.\n  In this paper, we investigate $\\rho(v)$, the ratio of $r$ and of the number\nof runs of the BWT of the reverse of $v$. Kempa and Kociumaka [FOCS 2020] gave\nthe first non-trivial upper bound as $\\rho(v) = O(\\log^2(n))$, for any string\n$v$ of length $n$. However, nothing is known about the tightness of this upper\nbound. We present infinite families of binary strings for which $\\rho(v) =\n\\Theta(\\log n)$ holds, thus giving the first non-trivial lower bound on\n$\\rho(n)$, the maximum over all strings of length $n$.\n  Our results suggest that $r$ is not an ideal measure of the repetitiveness of\nthe string, since the number of repeated factors is invariant between the\nstring and its reverse. We believe that there is a more intricate relationship\nbetween the number of runs of the BWT and the string's combinatorial\nproperties.\n", "versions": [{"version": "v1", "created": "Wed, 19 Aug 2020 15:33:51 GMT"}], "update_date": "2020-08-21", "authors_parsed": [["Giuliani", "Sara", ""], ["Inenaga", "Shunsuke", ""], ["Lipt\u00e1k", "Zsuzsanna", ""], ["Prezza", "Nicola", ""], ["Sciortino", "Marinella", ""], ["Toffanello", "Anna", ""]]}, {"id": "2008.08828", "submitter": "Pedro Valero", "authors": "Pedro Valero", "title": "On the Use of Quasiorders in Formal Language Theory", "comments": "PhD thesis", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this thesis we use quasiorders on words to offer a new perspective on two\nwell-studied problems from Formal Language Theory: deciding language inclusion\nand manipulating the finite automata representations of regular languages.\nFirst, we present a generic quasiorder-based framework that, when instantiated\nwith different quasiorders, yields different algorithms (some of them new) for\ndeciding language inclusion. We then instantiate this framework to devise an\nefficient algorithm for searching with regular expressions on\ngrammar-compressed text. Finally, we define a framework of quasiorder-based\nautomata constructions to offer a new perspective on residual automata.\n", "versions": [{"version": "v1", "created": "Thu, 20 Aug 2020 08:07:33 GMT"}], "update_date": "2020-08-21", "authors_parsed": [["Valero", "Pedro", ""]]}, {"id": "2008.09254", "submitter": "EPTCS", "authors": "Marco T. Moraz\\'an (Seton Hall University), Joshua M. Schappel (Seton\n  Hall University), Sachin Mahashabde (Seton Hall University)", "title": "Visual Designing and Debugging of Deterministic Finite-State Machines in\n  FSM", "comments": "In Proceedings TFPIE 2019 and 2020, arXiv:2008.08923", "journal-ref": "EPTCS 321, 2020, pp. 55-77", "doi": "10.4204/EPTCS.321.4", "report-no": null, "categories": "cs.HC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article presents a visualization tool for designing and debugging\ndeterministic finite-state machines in FSM -- a domain specific language for\nthe automata theory classroom. Like other automata visualization tools, users\ncan edit machines and observe their execution, given some input. Unlike other\nautomata visualization tools, the user is not burdened nor distracted with\nrendering a machine as a graph. Furthermore, emphasis is placed on the design\nof machines and this article presents a novel design recipe for deterministic\nfinite-state machines. In support of the design process, the visualization tool\nallows for each state to be associated with an invariant predicate. During\nmachine execution, the visualization tool indicates if the proposed invariant\nholds or does not hold after each transition. In this manner, students can\nvalidate and debug their machines before attempting to prove partial\ncorrectness or submitting for grading. In addition, any machine edited with the\nvisualization tool can be rendered as executable code. The interface of the\nvisualization tool along with extended examples of its use are presented.\n", "versions": [{"version": "v1", "created": "Fri, 21 Aug 2020 01:22:20 GMT"}], "update_date": "2020-08-24", "authors_parsed": [["Moraz\u00e1n", "Marco T.", "", "Seton Hall University"], ["Schappel", "Joshua M.", "", "Seton\n  Hall University"], ["Mahashabde", "Sachin", "", "Seton Hall University"]]}, {"id": "2008.09558", "submitter": "Artem Polyvyanyy", "authors": "Artem Polyvyanyy, Hanan Alkhammash, Claudio Di Ciccio, Luciano\n  Garc\\'ia-Ba\\~nuelos, Anna Kalenkova, Sander J. J. Leemans, Jan Mendling,\n  Alistair Moffat, Matthias Weidlich", "title": "Entropia: A Family of Entropy-Based Conformance Checking Measures for\n  Process Mining", "comments": "4 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.CL cs.FL cs.IT math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a command-line tool, called Entropia, that implements a\nfamily of conformance checking measures for process mining founded on the\nnotion of entropy from information theory. The measures allow quantifying\nclassical non-deterministic and stochastic precision and recall quality\ncriteria for process models automatically discovered from traces executed by\nIT-systems and recorded in their event logs. A process model has \"good\"\nprecision with respect to the log it was discovered from if it does not encode\nmany traces that are not part of the log, and has \"good\" recall if it encodes\nmost of the traces from the log. By definition, the measures possess useful\nproperties and can often be computed quickly.\n", "versions": [{"version": "v1", "created": "Fri, 21 Aug 2020 15:54:47 GMT"}, {"version": "v2", "created": "Wed, 30 Sep 2020 03:26:57 GMT"}], "update_date": "2020-10-01", "authors_parsed": [["Polyvyanyy", "Artem", ""], ["Alkhammash", "Hanan", ""], ["Di Ciccio", "Claudio", ""], ["Garc\u00eda-Ba\u00f1uelos", "Luciano", ""], ["Kalenkova", "Anna", ""], ["Leemans", "Sander J. J.", ""], ["Mendling", "Jan", ""], ["Moffat", "Alistair", ""], ["Weidlich", "Matthias", ""]]}, {"id": "2008.10782", "submitter": "A H M Jakaria", "authors": "A H M Jakaria, Mohammad Ashiqur Rahman, Matthew Anderson, Steven\n  Drager", "title": "Automated Trajectory Synthesis for UAV Swarms Based on Resilient Data\n  Collection Objectives", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.MA eess.SP", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The use of Unmanned Aerial Vehicles (UAVs) for collecting data from remotely\nlocated sensor systems is emerging. The data can be time-sensitive and require\nto be transmitted to a data processing center. However, planning the trajectory\nof a collaborative UAV swarm depends on multi-fold constraints, such as data\ncollection requirements, UAV maneuvering capacity, and budget limitation. Since\na UAV may fail or be compromised, it is important to provide necessary\nresilience to such contingencies, thus ensuring data security. It is important\nto provide the UAVs with efficient spatio-temporal trajectories so that they\ncan efficiently cover necessary data sources. In this work, we present\nSynth4UAV, a formal approach for automated synthesis of efficient trajectories\nfor a UAV swarm by logically modeling the aerial space and data point topology,\nUAV moves, and associated constraints in terms of the turning and climbing\nangle, fuel usage, data collection point coverage, data freshness, and\nresiliency properties. We use efficient, logical formulas to encode and solve\nthe complex model. The solution to the model provides the routing and\nmaneuvering plan for each UAV, including the time to visit the points on the\npaths and corresponding fuel usage such that the necessary data points are\nvisited while satisfying the resiliency requirements. We evaluate the proposed\ntrajectory synthesizer, and the results show that the relationship among\ndifferent parameters follow the requirements while the tool scales well with\nthe problem size.\n", "versions": [{"version": "v1", "created": "Tue, 25 Aug 2020 02:05:19 GMT"}], "update_date": "2020-08-26", "authors_parsed": [["Jakaria", "A H M", ""], ["Rahman", "Mohammad Ashiqur", ""], ["Anderson", "Matthew", ""], ["Drager", "Steven", ""]]}, {"id": "2008.11164", "submitter": "Taylor J. Smith", "authors": "Taylor J. Smith, Kai Salomaa", "title": "Concatenation Operations and Restricted Variants of Two-Dimensional\n  Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A two-dimensional automaton operates on arrays of symbols. While a standard\n(four-way) two-dimensional automaton can move its input head in four\ndirections, restricted two-dimensional automata are only permitted to move\ntheir input heads in three or two directions; these models are called three-way\nand two-way two-dimensional automata, respectively.\n  In two dimensions, we may extend the notion of concatenation in multiple\nways, depending on the words to be concatenated. We may row-concatenate (resp.,\ncolumn-concatenate) a pair of two-dimensional words when they have the same\nnumber of columns (resp., rows). In addition, the diagonal concatenation\noperation combines two words at their lower-right and upper-left corners, and\nis not dimension-dependent.\n  In this paper, we investigate closure properties of restricted models of\ntwo-dimensional automata under various concatenation operations. We give\nnon-closure results for two-way two-dimensional automata under row and column\nconcatenation in both the deterministic and nondeterministic cases. We further\ngive positive closure results for the same concatenation operations on unary\nnondeterministic two-way two-dimensional automata. Finally, we study closure\nproperties of diagonal concatenation on both two- and three-way two-dimensional\nautomata.\n", "versions": [{"version": "v1", "created": "Tue, 25 Aug 2020 16:50:51 GMT"}], "update_date": "2020-08-26", "authors_parsed": [["Smith", "Taylor J.", ""], ["Salomaa", "Kai", ""]]}, {"id": "2008.11562", "submitter": "Martin Zimmermann", "authors": "Aniello Murano, Sasha Rubin, Martin Zimmermann", "title": "Optimal Strategies in Weighted Limit Games (full version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove the existence and computability of optimal strategies in weighted\nlimit games, zero-sum infinite-duration games with a B\\\"uchi-style winning\ncondition requiring to produce infinitely many play prefixes that satisfy a\ngiven regular specification. Quality of plays is measured in the maximal weight\nof infixes between successive play prefixes that satisfy the specification.\n", "versions": [{"version": "v1", "created": "Wed, 26 Aug 2020 13:43:29 GMT"}, {"version": "v2", "created": "Mon, 7 Sep 2020 16:10:34 GMT"}], "update_date": "2020-09-08", "authors_parsed": [["Murano", "Aniello", ""], ["Rubin", "Sasha", ""], ["Zimmermann", "Martin", ""]]}, {"id": "2008.11635", "submitter": "Miko{\\l}aj Boja\\'nczyk", "authors": "Miko{\\l}aj Boja\\'nczyk", "title": "Languages recognised by finite semigroups, and their generalisations to\n  objects such as trees and graphs, with an emphasis on definability in monadic\n  second-order logic", "comments": "The most recent version can be found here:\n  https://www.mimuw.edu.pl/~bojan/2019-2020/algebraic-language-theory-2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  These are lecture notes on the algebraic approach to regular languages. The\nclassical algebraic approach is for finite words; it uses semigroups instead of\nautomata. However, the algebraic approach can be extended to structures beyond\nwords, e.g.~infinite words, or trees or graphs. The purpose of this book is to\ndescribe the algebraic approach in a way that covers these extensions.\n", "versions": [{"version": "v1", "created": "Wed, 26 Aug 2020 15:54:18 GMT"}], "update_date": "2020-08-27", "authors_parsed": [["Boja\u0144czyk", "Miko\u0142aj", ""]]}, {"id": "2008.12151", "submitter": "Joost Engelfriet", "authors": "Joost Engelfriet", "title": "Computability by Monadic Second-Order Logic", "comments": "12 pages, 4 figures, to appear in Information Processing Letters", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A binary relation on graphs is recursively enumerable if and only if it can\nbe computed by a formula in monadic second-order logic. The latter means that\nthe formula defines a set of graphs, in the usual way, such that each\n\"computation graph\" in that set determines a pair consisting of an input graph\nand an output graph.\n", "versions": [{"version": "v1", "created": "Thu, 27 Aug 2020 14:24:47 GMT"}, {"version": "v2", "created": "Sun, 22 Nov 2020 13:42:06 GMT"}, {"version": "v3", "created": "Tue, 24 Nov 2020 15:24:06 GMT"}], "update_date": "2020-11-25", "authors_parsed": [["Engelfriet", "Joost", ""]]}]