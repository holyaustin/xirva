[{"id": "1710.00213", "submitter": "L\\'eo Exibard", "authors": "Olivier Carton, L\\'eo Exibard and Olivier Serre", "title": "Two-way Two-tape Automata", "comments": "Developments in Language Theory 2017", "journal-ref": null, "doi": "10.1007/978-3-319-62809-7_10", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this article we consider two-way two-tape (alternating) automata accepting\npairs of words and we study some closure properties of this model. Our main\nresult is that such alternating automata are not closed under complementation\nfor non-unary alphabets. This improves a similar result of Kari and Moore for\npicture languages. We also show that these deterministic, non-deterministic and\nalternating automata are not closed under composition.\n", "versions": [{"version": "v1", "created": "Sat, 30 Sep 2017 15:10:52 GMT"}], "update_date": "2017-10-03", "authors_parsed": [["Carton", "Olivier", ""], ["Exibard", "L\u00e9o", ""], ["Serre", "Olivier", ""]]}, {"id": "1710.00258", "submitter": "Pavel Ageev", "authors": "Pavel Ageev", "title": "Implementation of the algorithm for testing an automaton for\n  synchronization in linear expected time", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Berlinkov has suggested an algorithm that, given a deterministic finite\nautomaton $\\mathcal{A}$, verifies whether or not $\\mathcal{A}$ is synchronizing\nin linear (of the number of states and letters) expected time. We present a\nmodification of Berlinkov's algorithm which we have implemented and tested. Our\nexperiments show that the implementation outperforms the standard quadratic\nalgorithm even for automata of modest size and allow us to give a statistically\naccurate approximation of the ratio of non-synchronizing automata amongst all\nautomata with a given number of states.\n", "versions": [{"version": "v1", "created": "Sat, 30 Sep 2017 20:25:02 GMT"}], "update_date": "2017-10-03", "authors_parsed": [["Ageev", "Pavel", ""]]}, {"id": "1710.02317", "submitter": "Wim Martens", "authors": "Wim Martens and Tina Trautner", "title": "Enumeration Problems for Regular Path Queries", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Evaluation of regular path queries (RPQs) is a central problem in graph\ndatabases. We investigate the corresponding enumeration problem, that is, given\na graph and an RPQ, enumerate all paths in the graph that match the RPQ. We\nconsider several versions of this problem, corresponding to different semantics\nof RPQs that have recently been considered: arbitrary paths, shortest paths,\nsimple paths, and trails. Whereas arbitrary and shortest paths can be\nenumerated in polynomial delay, the situation is much more intricate for simple\npaths and trails. For instance, already the question if a given graph contains\na simple path or trail of a certain length has cases with highly non-trivial\nsolutions and cases that are long-standing open problems. In this setting, we\nstudy RPQ evaluation from a parameterized complexity perspective. We define a\nclass of simple transitive expressions that is prominent in practice and for\nwhich we can prove two dichotomy-like results: one for simple paths and one for\ntrails paths. We observe that, even though simple path semantics and trail\nsemantics are intractable for RPQs in general, they are feasible for the vast\nmajority of the kinds of RPQs that users use in practice. At the heart of this\nstudy is a result of independent interest on the parameterized complexity of\nfinding disjoint paths in graphs: the two disjoint paths problem is W[1]-hard\nif parameterized by the length of one of the two paths.\n", "versions": [{"version": "v1", "created": "Fri, 6 Oct 2017 09:04:45 GMT"}], "update_date": "2017-10-09", "authors_parsed": [["Martens", "Wim", ""], ["Trautner", "Tina", ""]]}, {"id": "1710.02329", "submitter": "Karin Quaas", "authors": "Karin Quaas and Mahsa Shirmohammadi", "title": "Synchronizing Data Words for Register Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Register automata (RAs) are finite automata extended with a finite set of\nregisters to store and compare data from an infinite domain. We study the\nconcept of synchronizing data words in RAs: does there exist a data word that\nsends all states of the RA to a single state?\n  For deterministic RAs with k registers (k-DRAs), we prove that inputting data\nwords with 2k+1 distinct data from the infinite data domain is sufficient to\nsynchronize. We show that the synchronization problem for DRAs is in general\nPSPACE-complete, and it is NLOGSPACE-complete for 1-DRAs. For nondeterministic\nRAs (NRAs), we show that Ackermann(n) distinct data (where n is the size of the\nRA) might be necessary to synchronize. The synchronization problem for NRAs is\nin general undecidable, however, we establish Ackermann-completeness of the\nproblem for 1-NRAs.\n  Another main result is the NEXPTIME-completeness of the length-bounded\nsynchronization problem for NRAs, where a bound on the length of the\nsynchronizing data word, written in binary, is given. A variant of this last\nconstruction allows to prove that the length-bounded universality problem for\nNRAs is co-NEXPTIME-complete.\n", "versions": [{"version": "v1", "created": "Fri, 6 Oct 2017 09:53:13 GMT"}, {"version": "v2", "created": "Sun, 9 Jun 2019 11:31:42 GMT"}], "update_date": "2019-06-11", "authors_parsed": [["Quaas", "Karin", ""], ["Shirmohammadi", "Mahsa", ""]]}, {"id": "1710.02387", "submitter": "Chrystopher L. Nehaniv", "authors": "Chrystopher L. Nehaniv and Elena Antonova", "title": "Simulating and Reconstructing Neurodynamics with Epsilon-Automata\n  Applied to Electroencephalography (EEG) Microstate Sequences", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "q-bio.NC cs.FL nlin.AO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce new techniques to the analysis of neural spatiotemporal dynamics\nvia applying $\\epsilon$-machine reconstruction to electroencephalography (EEG)\nmicrostate sequences. Microstates are short duration quasi-stable states of the\ndynamically changing electrical field topographies recorded via an array of\nelectrodes from the human scalp, and cluster into four canonical classes. The\nsequence of microstates observed under particular conditions can be considered\nan information source with unknown underlying structure. $\\epsilon$-machines\nare discrete dynamical system automata with state-dependent probabilities on\ndifferent future observations (in this case the next measured EEG microstate).\nThey artificially reproduce underlying structure in an optimally predictive\nmanner as generative models exhibiting dynamics emulating the behaviour of the\nsource. Here we present experiments using both simulations and empirical data\nsupporting the value of associating these discrete dynamical systems with\nmental states (e.g. mind-wandering, focused attention, etc.) and with clinical\npopulations. The neurodynamics of mental states and clinical populations can\nthen be further characterized by properties of these dynamical systems,\nincluding: i) statistical complexity (determined by the number of states of the\ncorresponding $\\epsilon$-automaton); ii) entropy rate; iii) characteristic\nsequence patterning (syntax, probabilistic grammars); iv) duration, persistence\nand stability of dynamical patterns; and v) algebraic measures such as\nKrohn-Rhodes complexity or holonomy length of the decompositions of these. The\npotential applications include the characterization of mental states in\nneurodynamic terms for mental health diagnostics, well-being interventions,\nhuman-machine interface, and others on both subject-specific and\ngroup/population-level.\n", "versions": [{"version": "v1", "created": "Fri, 29 Sep 2017 09:19:14 GMT"}], "update_date": "2017-10-09", "authors_parsed": [["Nehaniv", "Chrystopher L.", ""], ["Antonova", "Elena", ""]]}, {"id": "1710.02516", "submitter": "Tom\\'a\\v{s} Masopust", "authors": "Tom\\'a\\v{s} Masopust", "title": "Complexity of Deciding Detectability in Discrete Event Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Detectability of discrete event systems (DESs) is a question whether the\ncurrent and subsequent states can be determined based on observations. Shu and\nLin designed a polynomial-time algorithm to check strong (periodic)\ndetectability and an exponential-time (polynomial-space) algorithm to check\nweak (periodic) detectability. Zhang showed that checking weak (periodic)\ndetectability is PSpace-complete. This intractable complexity opens a question\nwhether there are structurally simpler DESs for which the problem is tractable.\nIn this paper, we show that it is not the case by considering DESs represented\nas deterministic finite automata without non-trivial cycles, which are\nstructurally the simplest deadlock-free DESs. We show that even for such very\nsimple DESs, checking weak (periodic) detectability remains intractable. On the\ncontrary, we show that strong (periodic) detectability of DESs can be\nefficiently verified on a parallel computer.\n", "versions": [{"version": "v1", "created": "Fri, 6 Oct 2017 17:50:25 GMT"}], "update_date": "2017-10-09", "authors_parsed": [["Masopust", "Tom\u00e1\u0161", ""]]}, {"id": "1710.02787", "submitter": "Tobias Kapp\\'e", "authors": "Tobias Kapp\\'e and Paul Brunet and Alexandra Silva and Fabio Zanasi", "title": "Concurrent Kleene Algebra: Free Model and Completeness", "comments": "Version 2 includes an overview section that outlines the completeness\n  proof, as well as some extra discussion of the interpolation lemma. It also\n  includes better typography and a number of minor fixes. Version 3\n  incorporates the changes by comments from the anonymous referees at ESOP.\n  Among other things, these include a worked example of computing the syntactic\n  closure by hand", "journal-ref": null, "doi": "10.1007/978-3-319-89884-1_30", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Concurrent Kleene Algebra (CKA) was introduced by Hoare, Moeller, Struth and\nWehrman in 2009 as a framework to reason about concurrent programs. We prove\nthat the axioms for CKA with bounded parallelism are complete for the semantics\nproposed in the original paper; consequently, these semantics are the free\nmodel for this fragment. This result settles a conjecture of Hoare and\ncollaborators. Moreover, the techniques developed along the way are reusable;\nin particular, they allow us to establish pomset automata as an operational\nmodel for CKA.\n", "versions": [{"version": "v1", "created": "Sun, 8 Oct 2017 06:06:09 GMT"}, {"version": "v2", "created": "Sun, 22 Oct 2017 08:34:29 GMT"}, {"version": "v3", "created": "Mon, 26 Feb 2018 12:06:38 GMT"}], "update_date": "2018-07-30", "authors_parsed": [["Kapp\u00e9", "Tobias", ""], ["Brunet", "Paul", ""], ["Silva", "Alexandra", ""], ["Zanasi", "Fabio", ""]]}, {"id": "1710.02877", "submitter": "Tom\\'a\\v{s} Masopust", "authors": "Tom\\'a\\v{s} Masopust and Xiang Yin", "title": "Complexity of Detectability, Opacity and A-Diagnosability for Modular\n  Discrete Event Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the complexity of deciding whether a modular discrete event system\nis detectable (resp. opaque, A-diagnosable). Detectability arises in the state\nestimation of discrete event systems, opacity is related to the privacy and\nsecurity analysis, and A-diagnosability appears in the fault diagnosis of\nstochastic discrete event systems. Previously, deciding weak detectability\n(opacity, A-diagnosability) for monolithic systems was shown to be\nPSPACE-complete. In this paper, we study the complexity of deciding weak\ndetectability (opacity, A-diagnosability) for modular systems. We show that the\ncomplexities of these problems are significantly worse than in the monolithic\ncase. Namely, we show that deciding modular weak detectability (opacity,\nA-diagnosability) is EXPSPACE-complete. We further discuss a special case where\nall unobservable events are private, and show that in this case the problems\nare PSPACE-complete. Consequently, if the systems are all fully observable,\nthen deciding weak detectability (opacity) for modular systems is\nPSPACE-complete.\n", "versions": [{"version": "v1", "created": "Sun, 8 Oct 2017 19:56:51 GMT"}], "update_date": "2017-10-10", "authors_parsed": [["Masopust", "Tom\u00e1\u0161", ""], ["Yin", "Xiang", ""]]}, {"id": "1710.04002", "submitter": "Thorsten Wissmann", "authors": "Olivier Finkel, Olivier Carton, Dominique Lecomte", "title": "Polishness of some topologies related to word or tree automata", "comments": "This paper is an extended version of a paper which appeared in the\n  proceedings of the 26th EACSL Annual Conference on Computer Science and\n  Logic, CSL 2017. The main addition with regard to the conference paper\n  consists in the study of the B\\\"uchi topology and of the Muller topology in\n  the case of a space of trees, which now forms Section 4", "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 2 (May 8,\n  2019) lmcs:5440", "doi": "10.23638/LMCS-15(2:9)2019", "report-no": null, "categories": "math.LO cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We prove that the B\\\"uchi topology and the automatic topology are Polish. We\nalso show that this cannot be fully extended to the case of a space of infinite\nlabelled binary trees; in particular the B\\\"uchi and the Muller topologies are\nnot Polish in this case.\n", "versions": [{"version": "v1", "created": "Wed, 11 Oct 2017 11:09:18 GMT"}, {"version": "v2", "created": "Fri, 24 Aug 2018 11:34:31 GMT"}, {"version": "v3", "created": "Fri, 5 Apr 2019 09:33:25 GMT"}, {"version": "v4", "created": "Tue, 7 May 2019 07:58:58 GMT"}], "update_date": "2019-09-04", "authors_parsed": [["Finkel", "Olivier", ""], ["Carton", "Olivier", ""], ["Lecomte", "Dominique", ""]]}, {"id": "1710.04115", "submitter": "Micha{\\l} Skrzypczak", "authors": "Udi Boker, Orna Kupferman, Micha{\\l} Skrzypczak", "title": "How Deterministic are Good-For-Games Automata?", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In GFG automata, it is possible to resolve nondeterminism in a way that only\ndepends on the past and still accepts all the words in the language. The\nmotivation for GFG automata comes from their adequacy for games and synthesis,\nwherein general nondeterminism is inappropriate. We continue the ongoing effort\nof studying the power of nondeterminism in GFG automata. Initial indications\nhave hinted that every GFG automaton embodies a deterministic one. Today we\nknow that this is not the case, and in fact GFG automata may be exponentially\nmore succinct than deterministic ones.\n  We focus on the typeness question, namely the question of whether a GFG\nautomaton with a certain acceptance condition has an equivalent GFG automaton\nwith a weaker acceptance condition on the same structure. Beyond the\ntheoretical interest in studying typeness, its existence implies efficient\ntranslations among different acceptance conditions. This practical issue is of\nspecial interest in the context of games, where the Buchi and co-Buchi\nconditions admit memoryless strategies for both players. Typeness is known to\nhold for deterministic automata and not to hold for general nondeterministic\nautomata.\n  We show that GFG automata enjoy the benefits of typeness, similarly to the\ncase of deterministic automata. In particular, when Rabin or Streett GFG\nautomata have equivalent Buchi or co-Buchi GFG automata, respectively, then\nsuch equivalent automata can be defined on a substructure of the original\nautomata. Using our typeness results, we further study the place of GFG\nautomata in between deterministic and nondeterministic ones. Specifically,\nconsidering automata complementation, we show that GFG automata lean toward\nnondeterministic ones, admitting an exponential state blow-up in the\ncomplementation of a Streett automaton into a Rabin automaton, as opposed to\nthe constant blow-up in the deterministic case.\n", "versions": [{"version": "v1", "created": "Wed, 11 Oct 2017 15:25:02 GMT"}], "update_date": "2017-10-12", "authors_parsed": [["Boker", "Udi", ""], ["Kupferman", "Orna", ""], ["Skrzypczak", "Micha\u0142", ""]]}, {"id": "1710.04247", "submitter": "Jeffrey Shallit", "authors": "Parthasarathy Madhusudan, Dirk Nowotka, Aayush Rajasekaran, Jeffrey\n  Shallit", "title": "Lagrange's Theorem for Binary Squares", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NT cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show how to prove theorems in additive number theory using a decision\nprocedure based on finite automata. Among other things, we obtain the following\nanalogue of Lagrange's theorem: every natural number > 686 is the sum of at\nmost 4 natural numbers whose canonical base-2 representation is a binary\nsquare, that is, a string of the form xx for some block of bits x. Here the\nnumber 4 is optimal. While we cannot embed this theorem itself in a decidable\ntheory, we show that stronger lemmas that imply that the theorem can be\nembedded in decidable theories, and show how automated methods can be used to\nsearch for these stronger lemmas.\n", "versions": [{"version": "v1", "created": "Wed, 11 Oct 2017 18:32:57 GMT"}, {"version": "v2", "created": "Fri, 22 Jun 2018 10:46:22 GMT"}], "update_date": "2018-06-25", "authors_parsed": [["Madhusudan", "Parthasarathy", ""], ["Nowotka", "Dirk", ""], ["Rajasekaran", "Aayush", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1710.04313", "submitter": "Marc  Zeitoun", "authors": "Thomas Place and Marc Zeitoun", "title": "Generic Results for Concatenation Hierarchies", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the theory of formal languages, the understanding of concatenation\nhierarchies of regular languages is one of the most fundamental and challenging\ntopic. In this paper, we survey progress made in the comprehension of this\nproblem since 1971, and we establish new generic statements regarding this\nproblem.\n", "versions": [{"version": "v1", "created": "Wed, 11 Oct 2017 21:38:35 GMT"}], "update_date": "2017-10-13", "authors_parsed": [["Place", "Thomas", ""], ["Zeitoun", "Marc", ""]]}, {"id": "1710.04490", "submitter": "Jan Otop", "authors": "Jakub Michaliszyn, Jan Otop", "title": "Average Stack Cost of Buechi Pushdown Automata", "comments": "A conference version of this paper has been accepted to FSTTCS 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the average stack cost of Buechi pushdown automata (Buechi PDA). We\nassociate a non-negative price with each stack symbol and define the cost of a\nstack as the sum of costs of all its elements. We introduce and study the\naverage stack cost problem (ASC), which asks whether there exists an accepting\nrun of a given Buechi PDA such that the long-run average of stack costs is\nbelow some given threshold. The ASC problem generalizes mean-payoff objective\nand can be used to express quantitative properties of pushdown systems. In\nparticular, we can compute the average response time using the ASC problem. We\nshow that the ASC problem can be solved in polynomial time.\n", "versions": [{"version": "v1", "created": "Thu, 12 Oct 2017 13:10:30 GMT"}], "update_date": "2017-10-13", "authors_parsed": [["Michaliszyn", "Jakub", ""], ["Otop", "Jan", ""]]}, {"id": "1710.04551", "submitter": "Joost Engelfriet", "authors": "Joost Engelfriet", "title": "The Trees of Hanoi", "comments": "11 pages, slightly revised version of a note from 1981", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DS math.HO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The game of the Towers of Hanoi is generalized to binary trees. First, a\nstraightforward solution of the game is discussed. Second, a shorter solution\nis presented, which is then shown to be optimal.\n", "versions": [{"version": "v1", "created": "Thu, 12 Oct 2017 14:56:56 GMT"}], "update_date": "2017-10-13", "authors_parsed": [["Engelfriet", "Joost", ""]]}, {"id": "1710.04597", "submitter": "Subhadip Chowdhury", "authors": "Subhadip Chowdhury", "title": "A Topological proof that $O_2$ is $2$-MCFL", "comments": "11 figures, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.AT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give a new proof of Salvati's theorem that the group language $O_2$ is $2$\nmultiple context free. Unlike Salvati's proof, our arguments do not use any\nidea specific to two-dimensions. This raises the possibility that the argument\nmight generalize to $O_n$.\n", "versions": [{"version": "v1", "created": "Thu, 12 Oct 2017 16:29:22 GMT"}, {"version": "v2", "created": "Tue, 31 Oct 2017 00:03:59 GMT"}], "update_date": "2017-11-01", "authors_parsed": [["Chowdhury", "Subhadip", ""]]}, {"id": "1710.05061", "submitter": "Sylvie Davies", "authors": "Sylvie Davies", "title": "A New Technique for Reachability of States in Concatenation Automata", "comments": "23 pages, 1 table. Added missing affiliation/funding information", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new technique for demonstrating the reachability of states in\ndeterministic finite automata representing the concatenation of two languages.\nSuch demonstrations are a necessary step in establishing the state complexity\nof the concatenation of two languages, and thus in establishing the state\ncomplexity of concatenation as an operation. Typically, ad-hoc induction\narguments are used to show particular states are reachable in concatenation\nautomata. We prove some results that seem to capture the essence of many of\nthese induction arguments. Using these results, reachability proofs in\nconcatenation automata can often be done more simply and without using\ninduction directly.\n", "versions": [{"version": "v1", "created": "Fri, 13 Oct 2017 19:52:31 GMT"}, {"version": "v2", "created": "Tue, 17 Oct 2017 23:32:56 GMT"}], "update_date": "2017-10-19", "authors_parsed": [["Davies", "Sylvie", ""]]}, {"id": "1710.05633", "submitter": "R\\\"udiger Ehlers", "authors": "Ruediger Ehlers, Bernd Finkbeiner", "title": "Symmetric Synthesis", "comments": "Full Version of the paper with the same name accepted at FSTTCS 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the problem of determining whether a given temporal specification\ncan be implemented by a symmetric system, i.e., a system composed from\nidentical components. Symmetry is an important goal in the design of\ndistributed systems, because systems that are composed from identical\ncomponents are easier to build and maintain. We show that for the class of\nrotation-symmetric architectures, i.e., multi-process architectures where all\nprocesses have access to all system inputs, but see different rotations of the\ninputs, the symmetric synthesis problem is EXPTIME-complete in the number of\nprocesses. In architectures where the processes do not have access to all input\nvariables, the symmetric synthesis problem becomes undecidable, even in cases\nwhere the standard distributed synthesis problem is decidable.\n", "versions": [{"version": "v1", "created": "Mon, 16 Oct 2017 11:49:48 GMT"}], "update_date": "2017-10-17", "authors_parsed": [["Ehlers", "Ruediger", ""], ["Finkbeiner", "Bernd", ""]]}, {"id": "1710.06000", "submitter": "Marek Szyku{\\l}a", "authors": "Janusz Brzozowski, Lila Kari, Bai Li, Marek Szyku{\\l}a", "title": "State Complexity of Overlap Assembly", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The \\emph{state complexity} of a regular language $L_m$ is the number $m$ of\nstates in a minimal deterministic finite automaton (DFA) accepting $L_m$. The\nstate complexity of a regularity-preserving binary operation on regular\nlanguages is defined as the maximal state complexity of the result of the\noperation where the two operands range over all languages of state complexities\n$\\le m$ and $\\le n$, respectively. We find a tight upper bound on the state\ncomplexity of the binary operation \\emph{overlap assembly} on regular\nlanguages. This operation was introduced by Csuhaj-Varj\\'u, Petre, and Vaszil\nto model the process of self-assembly of two linear DNA strands into a longer\nDNA strand, provided that their ends \"overlap\". We prove that the state\ncomplexity of the overlap assembly of languages $L_m$ and $L_n$, where $m\\ge 2$\nand $n\\ge1$, is at most $2 (m-1) 3^{n-1} + 2^n$. Moreover, for $m \\ge 2$ and $n\n\\ge 3$ there exist languages $L_m$ and $L_n$ over an alphabet of size $n$ whose\noverlap assembly meets the upper bound and this bound cannot be met with\nsmaller alphabets. Finally, we prove that $m+n$ is a tight upper bound on the\noverlap assembly of unary languages, and that there are binary languages whose\noverlap assembly has exponential state complexity at least $m(2^{n-1}-2)+2$.\n", "versions": [{"version": "v1", "created": "Mon, 16 Oct 2017 20:58:17 GMT"}, {"version": "v2", "created": "Mon, 4 Dec 2017 20:47:23 GMT"}, {"version": "v3", "created": "Thu, 10 May 2018 17:03:40 GMT"}, {"version": "v4", "created": "Tue, 11 Dec 2018 21:47:28 GMT"}], "update_date": "2018-12-13", "authors_parsed": [["Brzozowski", "Janusz", ""], ["Kari", "Lila", ""], ["Li", "Bai", ""], ["Szyku\u0142a", "Marek", ""]]}, {"id": "1710.06678", "submitter": "Martin Sulzmann", "authors": "Martin Sulzmann and Peter Thiemann", "title": "LTL Semantic Tableaux and Alternating $\\omega$-automata via Linear\n  Factors", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linear Temporal Logic (LTL) is a widely used specification framework for\nlinear time properties of systems. The standard approach for verifying such\nproperties is by transforming LTL formulae to suitable $\\omega$-automata and\nthen applying model checking.\n  We revisit Vardi's transformation of an LTL formula to an alternating\n$\\omega$-automaton and Wolper's LTL tableau method for satisfiability checking.\nWe observe that both constructions effectively rely on a decomposition of\nformulae into linear factors.\n  Linear factors have been introduced previously by Antimirov in the context of\nregular expressions.\n  We establish the notion of linear factors for LTL and verify essential\nproperties such as expansion and finiteness.\n  Our results shed new insights on the connection between the construction of\nalternating $\\omega$-automata and semantic tableaux.\n", "versions": [{"version": "v1", "created": "Wed, 18 Oct 2017 11:17:03 GMT"}], "update_date": "2017-10-19", "authors_parsed": [["Sulzmann", "Martin", ""], ["Thiemann", "Peter", ""]]}, {"id": "1710.07261", "submitter": "Jakub Konieczny", "authors": "Jakub Byszewski and Jakub Konieczny", "title": "A density version of Cobham's theorem", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NT cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cobham's theorem asserts that if a sequence is automatic with respect to two\nmultiplicatively independent bases, then it is ultimately periodic. We prove a\nstronger density version of the result: if two sequences which are automatic\nwith respect to two multiplicatively independent bases coincide on a set of\ndensity one, then they also coincide on a set of density one with a periodic\nsequence. We apply the result to a problem of Deshouillers and Ruzsa concerning\nthe least nonzero digit of $n!$ in base $12$.\n", "versions": [{"version": "v1", "created": "Thu, 19 Oct 2017 17:36:41 GMT"}, {"version": "v2", "created": "Wed, 1 Nov 2017 15:19:58 GMT"}], "update_date": "2017-11-02", "authors_parsed": [["Byszewski", "Jakub", ""], ["Konieczny", "Jakub", ""]]}, {"id": "1710.07528", "submitter": "Georg Zetzsche", "authors": "Georg Zetzsche", "title": "The Emptiness Problem for Valence Automata over Graph Monoids", "comments": "Preprint of contribution to special issue on RP2015 (Information &\n  Computation)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO math.GR", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This work studies which storage mechanisms in automata permit decidability of\nthe emptiness problem. The question is formalized using valence automata, an\nabstract model of automata in which the storage mechanism is given by a monoid.\nFor each of a variety of storage mechanisms, one can choose a (typically\ninfinite) monoid $M$ such that valence automata over $M$ are equivalent to\n(one-way) automata with this type of storage. In fact, many important storage\nmechanisms can be realized by monoids defined by finite graphs, called graph\nmonoids. Examples include pushdown stacks, partially blind counters (which\nbehave like Petri net places), blind counters (which may attain negative\nvalues), and combinations thereof.\n  Hence, we study for which graph monoids the emptiness problem for valence\nautomata is decidable. A particular model realized by graph monoids is that of\nPetri nets with a pushdown stack. For these, decidability is a long-standing\nopen question and we do not answer it here.\n  However, if one excludes subgraphs corresponding to this model, a\ncharacterization can be achieved. Moreover, we provide a description of those\nstorage mechanisms for which decidability remains open. This leads to a model\nthat naturally generalizes both pushdown Petri nets and the priority\nmulticounter machines introduced by Reinhardt.\n  The cases that are proven decidable constitute a natural and apparently new\nextension of Petri nets with decidable reachability. It is finally shown that\nthis model can be combined with another such extension by Atig and Ganty: We\npresent a further decidability result that subsumes both of these Petri net\nextensions.\n", "versions": [{"version": "v1", "created": "Fri, 20 Oct 2017 13:44:30 GMT"}], "update_date": "2017-10-23", "authors_parsed": [["Zetzsche", "Georg", ""]]}, {"id": "1710.07997", "submitter": "Wiktor Daszczuk", "authors": "Wiktor B. Daszczuk", "title": "Timed Concurrent State Machines", "comments": "13 pages, 4 figures", "journal-ref": "Computer Science, vol. 8, 2007, pp. 23-36", "doi": null, "report-no": null, "categories": "cs.LO cs.DC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Timed Concurrent State Machines are an application of Alur's Timed Automata\nconcept to coincidence-based (rather than interleaving) CSM modeling technique.\nTCSM support the idea of testing automata, allowing to specify time properties\neasier than temporal formulas. Also, calculation of a global state space in\nreal-time domain (Region Concurrent State Machines) is defined, allowing to\nstore a verified system in ready-to-verification form, and to multiply it by\nvarious testing automata.\n", "versions": [{"version": "v1", "created": "Sun, 22 Oct 2017 18:41:28 GMT"}], "update_date": "2017-10-24", "authors_parsed": [["Daszczuk", "Wiktor B.", ""]]}, {"id": "1710.08111", "submitter": "Joonatan Jalonen", "authors": "Joonatan Jalonen and Jarkko Kari", "title": "Conjugacy of one-dimensional one-sided cellular automata is undecidable", "comments": "12 pages, 2 figures, accepted for SOFSEM 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two cellular automata are strongly conjugate if there exists a\nshift-commuting conjugacy between them. We prove that the following two sets of\npairs $(F,G)$ of one-dimensional one-sided cellular automata over a full shift\nare recursively inseparable: (i) pairs where $F$ has strictly larger\ntopological entropy than $G$, and (ii) pairs that are strongly conjugate and\nhave zero topological entropy.\n  Because there is no factor map from a lower entropy system to a higher\nentropy one, and there is no embedding of a higher entropy system into a lower\nentropy system, we also get as corollaries that the following decision problems\nare undecidable: Given two one-dimensional one-sided cellular automata $F$ and\n$G$ over a full shift: Are $F$ and $G$ conjugate? Is $F$ a factor of $G$? Is\n$F$ a subsystem of $G$? All of these are undecidable in both strong and weak\nvariants (whether the homomorphism is required to commute with the shift or\nnot, respectively). It also immediately follows that these results hold for\none-dimensional two-sided cellular automata.\n", "versions": [{"version": "v1", "created": "Mon, 23 Oct 2017 06:58:54 GMT"}], "update_date": "2017-10-24", "authors_parsed": [["Jalonen", "Joonatan", ""], ["Kari", "Jarkko", ""]]}, {"id": "1710.08353", "submitter": "Jeffrey Shallit", "authors": "Jason Bell, Kathryn Hare, Jeffrey Shallit", "title": "When is an automatic set an additive basis?", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NT cs.DM cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We characterize those $k$-automatic sets $S$ of natural numbers that form an\nadditive basis for the natural numbers, and we show that this characterization\nis effective. In addition, we give an algorithm to determine the smallest $j$\nsuch that $S$ forms an additive basis of order $j$, if it exists.\n", "versions": [{"version": "v1", "created": "Mon, 23 Oct 2017 15:54:31 GMT"}], "update_date": "2017-10-24", "authors_parsed": [["Bell", "Jason", ""], ["Hare", "Kathryn", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1710.08647", "submitter": "Ond\\v{r}ej Leng\\'al", "authors": "Milan Ceska and Vojtech Havlena and Lukas Holik and Ondrej Lengal and\n  Tomas Vojnar", "title": "Approximate Reduction of Finite Automata for High-Speed Network\n  Intrusion Detection (Technical Report)", "comments": "An extended version of a paper accepted at TACAS'18", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.NI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problem of approximate reduction of non-deterministic\nautomata that appear in hardware-accelerated network intrusion detection\nsystems (NIDSes). We define an error distance of a reduced automaton from the\noriginal one as the probability of packets being incorrectly classified by the\nreduced automaton (wrt the probabilistic distribution of packets in the network\ntraffic). We use this notion to design an approximate reduction procedure that\nachieves a great size reduction (much beyond the state-of-the-art\nlanguage-preserving techniques) with a controlled and small error. We have\nimplemented our approach and evaluated it on use cases from Snort, a popular\nNIDS. Our results provide experimental evidence that the method can be highly\nefficient in practice, allowing NIDSes to follow the rapid growth in the speed\nof networks.\n", "versions": [{"version": "v1", "created": "Tue, 24 Oct 2017 08:33:34 GMT"}, {"version": "v2", "created": "Sat, 27 Jan 2018 22:23:47 GMT"}, {"version": "v3", "created": "Wed, 21 Feb 2018 13:48:13 GMT"}], "update_date": "2018-02-22", "authors_parsed": [["Ceska", "Milan", ""], ["Havlena", "Vojtech", ""], ["Holik", "Lukas", ""], ["Lengal", "Ondrej", ""], ["Vojnar", "Tomas", ""]]}, {"id": "1710.08820", "submitter": "Narad Rampersad", "authors": "Adam Borchert and Narad Rampersad", "title": "Permutation complexity of images of Sturmian words by marked morphisms", "comments": "9 pages", "journal-ref": "Discrete Mathematics & Theoretical Computer Science, Vol. 20 no.\n  1, Combinatorics (June 4, 2018) dmtcs:4551", "doi": "10.23638/DMTCS-20-1-20", "report-no": null, "categories": "math.CO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that the permutation complexity of the image of a Sturmian word by a\nbinary marked morphism is $n+k$ for some constant $k$ and all lengths $n$\nsufficiently large.\n", "versions": [{"version": "v1", "created": "Tue, 24 Oct 2017 15:01:32 GMT"}, {"version": "v2", "created": "Wed, 1 Nov 2017 15:52:12 GMT"}, {"version": "v3", "created": "Sun, 1 Apr 2018 22:15:50 GMT"}, {"version": "v4", "created": "Mon, 28 May 2018 19:00:04 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Borchert", "Adam", ""], ["Rampersad", "Narad", ""]]}, {"id": "1710.09083", "submitter": "Wiktor Daszczuk", "authors": "Wiktor B. Daszczuk", "title": "State Space Reduction for Reachability Graph of CSM Automata", "comments": "12 pages, 10 figures", "journal-ref": null, "doi": null, "report-no": "ICS WUT Research Report No 10/2000", "categories": "cs.SE cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Classical CTL temporal logics are built over systems with interleaving model\nconcurrency. Many attempts are made to fight a state space explosion problem\n(for instance, compositional model checking). There are some methods of\nreduction of a state space based on independence of actions. However, in CSM\nmodel, which is based on coincidences rather than on interleaving, independence\nof actions cannot be defined. Therefore a state space reduction basing on\nidentical temporal consequences rather than on independence of action is\nproposed. The new reduction is not as good as for interleaving systems, because\nall successors of a state (in depth of two levels) must be obtained before a\nreduction may be applied. This leads to reduction of space required for\nrepresentation of a state space, but not in time of state space construction.\nYet much savings may occur in regular state spaces for CSM systems.\n", "versions": [{"version": "v1", "created": "Wed, 25 Oct 2017 06:17:03 GMT"}], "update_date": "2017-10-27", "authors_parsed": [["Daszczuk", "Wiktor B.", ""]]}, {"id": "1710.09208", "submitter": "Jad Hamza", "authors": "Jad Hamza, Viktor Kun\\v{c}ak", "title": "Minimal Synthesis of String To String Functions From Examples", "comments": "SYNT 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the problem of synthesizing string to string transformations from a\nset of input/output examples. The transformations we consider are expressed\nusing deterministic finite automata (DFA) that read pairs of letters, one\nletter from the input and one from the output. The DFA corresponding to these\ntransformations have additional constraints, ensuring that each input string is\nmapped to exactly one output string.\n  We suggest that, given a set of input/output examples, the smallest DFA\nconsistent with the examples is a good candidate for the transformation the\nuser was expecting. We therefore study the problem of, given a set of examples,\nfinding a minimal DFA consistent with the examples and satisfying the\nfunctionality and totality constraints mentioned above.\n  We prove that, in general, this problem (the corresponding decision problem)\nis NP-complete. This is unlike the standard DFA minimization problem which can\nbe solved in polynomial time. We provide several NP-hardness proofs that show\nthe hardness of multiple (independent) variants of the problem.\n  Finally, we propose an algorithm for finding the minimal DFA consistent with\ninput/output examples, that uses a reduction to SMT solvers. We implemented the\nalgorithm, and used it to evaluate the likelihood that the minimal DFA indeed\ncorresponds to the DFA expected by the user.\n", "versions": [{"version": "v1", "created": "Wed, 25 Oct 2017 12:59:03 GMT"}, {"version": "v2", "created": "Mon, 4 Jun 2018 21:09:53 GMT"}], "update_date": "2018-06-06", "authors_parsed": [["Hamza", "Jad", ""], ["Kun\u010dak", "Viktor", ""]]}, {"id": "1710.09595", "submitter": "Kamil Khadiev", "authors": "Kamil Khadiev, Aliya Khadieva, Dmitry Kravchenko, Alexander Rivosh,\n  Ramis Yamilov and Ilnaz Mannapov", "title": "Quantum versus Classical Online Streaming Algorithms with Logarithmic\n  Size of Memory", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.DS cs.FL quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider online algorithms with respect to the competitive ratio. Here, we\ninvestigate quantum and classical one-way automata with non-constant size of\nmemory (streaming algorithms) as a model for online algorithms. We construct\nproblems that can be solved by quantum online streaming algorithms better than\nby classical ones in a case of logarithmic or sublogarithmic size of memory.\n", "versions": [{"version": "v1", "created": "Thu, 26 Oct 2017 08:53:20 GMT"}, {"version": "v2", "created": "Wed, 31 Jan 2018 12:46:06 GMT"}, {"version": "v3", "created": "Thu, 20 Jun 2019 10:44:11 GMT"}], "update_date": "2019-06-21", "authors_parsed": [["Khadiev", "Kamil", ""], ["Khadieva", "Aliya", ""], ["Kravchenko", "Dmitry", ""], ["Rivosh", "Alexander", ""], ["Yamilov", "Ramis", ""], ["Mannapov", "Ilnaz", ""]]}, {"id": "1710.09612", "submitter": "Dmitry Golubenko", "authors": "Dmitry Golubenko", "title": "Proving Parikh's theorem using Chomsky-Schutzenberger theorem", "comments": "4 pages, first appeared as solution to an excersize in my formal\n  language course", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parikh theorem was originally stated and proved by Rohkit Parikh in MIT\nresearch report in 1961. Many different proofs of this classical theorems were\nproduced then; our goal is to give another proof using Chomsky-Schutzenberger\nrepresentation theorem. We present the proof which doesn't use any formal\nlanguage theory tool at all except the representation theorem, just some linear\nalgebra.\n", "versions": [{"version": "v1", "created": "Thu, 26 Oct 2017 09:36:17 GMT"}, {"version": "v2", "created": "Wed, 13 Jun 2018 05:10:00 GMT"}], "update_date": "2018-06-14", "authors_parsed": [["Golubenko", "Dmitry", ""]]}, {"id": "1710.10756", "submitter": "Ond\\v{r}ej Leng\\'al", "authors": "Ondrej Lengal and Anthony W. Lin and Rupak Majumdar and Philipp\n  Ruemmer", "title": "Fair Termination for Parameterized Probabilistic Concurrent Systems\n  (Technical Report)", "comments": "A technical report of a TACAS'17 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problem of automatically verifying that a parameterized\nfamily of probabilistic concurrent systems terminates with probability one for\nall instances against adversarial schedulers. A parameterized family defines an\ninfinite-state system: for each number n, the family consists of an instance\nwith n finite-state processes. In contrast to safety, the parameterized\nverification of liveness is currently still considered extremely challenging\nespecially in the presence of probabilities in the model. One major challenge\nis to provide a sufficiently powerful symbolic framework. One well-known\nsymbolic framework for the parameterized verification of non-probabilistic\nconcurrent systems is regular model checking. Although the framework was\nrecently extended to probabilistic systems, incorporating fairness in the\nframework - often crucial for verifying termination - has been especially\ndifficult due to the presence of an infinite number of fairness constraints\n(one for each process). Our main contribution is a systematic,\nregularity-preserving, encoding of finitary fairness (a realistic notion of\nfairness proposed by Alur & Henzinger) in the framework of regular model\nchecking for probabilistic parameterized systems. Our encoding reduces\ntermination with finitary fairness to verifying parameterized termination\nwithout fairness over probabilistic systems in regular model checking (for\nwhich a verification framework already exists). We show that our algorithm\ncould verify termination for many interesting examples from distributed\nalgorithms (Herman's protocol) and evolutionary biology (Moran process, cell\ncycle switch), which do not hold under the standard notion of fairness. To the\nbest of our knowledge, our algorithm is the first fully-automatic method that\ncan prove termination for these examples.\n", "versions": [{"version": "v1", "created": "Mon, 30 Oct 2017 03:33:46 GMT"}], "update_date": "2017-10-31", "authors_parsed": [["Lengal", "Ondrej", ""], ["Lin", "Anthony W.", ""], ["Majumdar", "Rupak", ""], ["Ruemmer", "Philipp", ""]]}, {"id": "1710.10991", "submitter": "Thorsten Wissmann", "authors": "Bertram Felgenhauer", "title": "Deciding Confluence and Normal Form Properties of Ground Term Rewrite\n  Systems Efficiently", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 14, Issue 4 (October\n  29, 2018) lmcs:4925", "doi": "10.23638/LMCS-14(4:7)2018", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  It is known that the first-order theory of rewriting is decidable for ground\nterm rewrite systems, but the general technique uses tree automata and often\ntakes exponential time. For many properties, including confluence (CR),\nuniqueness of normal forms with respect to reductions (UNR) and with respect to\nconversions (UNC), polynomial time decision procedures are known for ground\nterm rewrite systems. However, this is not the case for the normal form\nproperty (NFP). In this work, we present a cubic time algorithm for NFP, an\nalmost cubic time algorithm for UNR, and an almost linear time algorithm for\nUNC, improving previous bounds. We also present a cubic time algorithm for CR.\n", "versions": [{"version": "v1", "created": "Mon, 30 Oct 2017 14:51:25 GMT"}, {"version": "v2", "created": "Mon, 4 Jun 2018 23:32:21 GMT"}, {"version": "v3", "created": "Fri, 26 Oct 2018 15:22:39 GMT"}], "update_date": "2018-11-27", "authors_parsed": [["Felgenhauer", "Bertram", ""]]}, {"id": "1710.11301", "submitter": "Chris Bruno", "authors": "Daniel Harasim, Chris Bruno, Eva Portelance, Martin Rohrmeier, Timothy\n  J. O'Donnell", "title": "A generalized parsing framework for Abstract Grammars", "comments": "Technical Report [v2: added Martin Rohrmeier as author.] [v3: fixed\n  error stating that AGs are equivalent to GCFGS. this is in fact not known\n  yet. other minor typos fixed.]", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This technical report presents a general framework for parsing a variety of\ngrammar formalisms. We develop a grammar formalism, called an Abstract Grammar,\nwhich is general enough to represent grammars at many levels of the hierarchy,\nincluding Context Free Grammars, Minimalist Grammars, and Generalized\nContext-free Grammars. We then develop a single parsing framework which is\ncapable of parsing grammars which are at least up to GCFGs on the hierarchy.\nOur parsing framework exposes a grammar interface, so that it can parse any\nparticular grammar formalism that can be reduced to an Abstract Grammar.\n", "versions": [{"version": "v1", "created": "Tue, 31 Oct 2017 02:23:15 GMT"}, {"version": "v2", "created": "Thu, 30 Nov 2017 15:04:09 GMT"}, {"version": "v3", "created": "Fri, 19 Jan 2018 17:49:05 GMT"}], "update_date": "2018-01-22", "authors_parsed": [["Harasim", "Daniel", ""], ["Bruno", "Chris", ""], ["Portelance", "Eva", ""], ["Rohrmeier", "Martin", ""], ["O'Donnell", "Timothy J.", ""]]}, {"id": "1710.11553", "submitter": "Anna Frid", "authors": "Anna Frid", "title": "Sturmian numeration systems and decompositions to palindromes", "comments": "Submitted to European Journal of Combinatorics", "journal-ref": "A. E. Frid, Sturmian numeration systems and decompositions to\n  palindromes. European J. Combin. 71 (2018) 202-212", "doi": "10.1016/j.ejc.2018.04.003", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We extend the classical Ostrowski numeration systems, closely related to\nSturmian words, by allowing a wider range of coefficients, so that possible\nrepresentations of a number $n$ better reflect the structure of the associated\nSturmian word. In particular, this extended numeration system helps to catch\noccurrences of palindromes in a characteristic Sturmian word and thus to prove\nfor Sturmian words the following conjecture stated in 2013 by Puzynina, Zamboni\nand the author: If a word is not periodic, then for every $Q>0$ it has a prefix\nwhich cannot be decomposed to a concatenation of at most $Q$ palindromes.\n", "versions": [{"version": "v1", "created": "Tue, 31 Oct 2017 16:10:24 GMT"}, {"version": "v2", "created": "Thu, 2 Nov 2017 12:17:43 GMT"}], "update_date": "2018-07-13", "authors_parsed": [["Frid", "Anna", ""]]}]