[{"id": "1910.00417", "submitter": "Sahar Mohajerani", "authors": "Sahar Mohajerani, Yiding Ji, Stephane Lafortune", "title": "Compositional and Abstraction-Based Approach for Synthesis of Edit\n  Functions for Opacity Enforcement", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper develops a novel compositional and abstraction-based approach to\nsynthesize edit functions for opacity enforcement in modular discrete event\nsystems. Edit functions alter the output of the system by erasing or inserting\nevents in order to obfuscate the outside intruder, whose goal is to infer the\nsecrets of the system from its observation. We synthesize edit functions to\nsolve the opacity enforcement problem in a modular setting, which significantly\nreduces the computational complexity compared with the monolithic approach. Two\nabstraction methods called opaque observation equivalence and opaque\nbisimulation are first employed to abstract the individual components of the\nmodular system and their observers. Subsequently, we propose a method to\ntransform the synthesis of edit functions to the calculation of modular\nsupremal nonblocking supervisors. We show that the edit functions synthesized\nin this manner correctly solve the opacity enforcement problem.\n", "versions": [{"version": "v1", "created": "Tue, 1 Oct 2019 14:15:54 GMT"}], "update_date": "2019-10-02", "authors_parsed": [["Mohajerani", "Sahar", ""], ["Ji", "Yiding", ""], ["Lafortune", "Stephane", ""]]}, {"id": "1910.00849", "submitter": "Davide Basile", "authors": "Davide Basile, Maurice H. ter Beek, and Rosario Pugliese", "title": "Synthesis of Orchestrations and Choreographies: Bridging the Gap between\n  Supervisory Control and Coordination of Services", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 2 (June 3,\n  2020) lmcs:6527", "doi": "10.23638/LMCS-16(2:9)2020", "report-no": null, "categories": "eess.SY cs.DC cs.FL cs.SY", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present a number of contributions to bridging the gap between supervisory\ncontrol theory and coordination of services in order to explore the frontiers\nbetween coordination and control systems. Firstly, we modify the classical\nsynthesis algorithm from supervisory control theory for obtaining the so-called\nmost permissive controller in order to synthesise orchestrations and\nchoreographies of service contracts formalised as contract automata. The key\ningredient to make this possible is a novel notion of controllability. Then, we\npresent an abstract parametric synthesis algorithm and show that it generalises\nthe classical synthesis as well as the orchestration and choreography\nsyntheses. Finally, through the novel abstract synthesis, we show that the\nconcrete syntheses are in a refinement order. A running example from the\nservice domain illustrates our contributions.\n", "versions": [{"version": "v1", "created": "Wed, 2 Oct 2019 09:47:29 GMT"}, {"version": "v2", "created": "Wed, 8 Apr 2020 11:44:35 GMT"}, {"version": "v3", "created": "Mon, 4 May 2020 10:22:19 GMT"}, {"version": "v4", "created": "Tue, 2 Jun 2020 07:48:43 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Basile", "Davide", ""], ["ter Beek", "Maurice H.", ""], ["Pugliese", "Rosario", ""]]}, {"id": "1910.01100", "submitter": "Arnd Hartmanns", "authors": "Arnd Hartmanns, Benjamin Lucien Kaminski", "title": "Optimistic Value Iteration", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Markov decision processes are widely used for planning and verification in\nsettings that combine controllable or adversarial choices with probabilistic\nbehaviour. The standard analysis algorithm, value iteration, only provides a\nlower bound on unbounded probabilities or reward values. Two \"sound\"\nvariations, which also deliver an upper bound, have recently appeared. In this\npaper, we present optimistic value iteration, a new sound approach that\nleverages value iteration's ability to usually deliver tight lower bounds: we\nobtain a lower bound via standard value iteration, use the result to \"guess\" an\nupper bound, and prove the latter's correctness. Optimistic value iteration is\neasy to implement, does not require extra precomputations or a priori state\nspace transformations, and works for computing reachability probabilities as\nwell as expected rewards. It is also fast, as we show via an extensive\nexperimental evaluation using our publicly available implementation within the\nModest Toolset.\n", "versions": [{"version": "v1", "created": "Wed, 2 Oct 2019 17:36:24 GMT"}, {"version": "v2", "created": "Thu, 17 Oct 2019 18:17:34 GMT"}], "update_date": "2019-10-21", "authors_parsed": [["Hartmanns", "Arnd", ""], ["Kaminski", "Benjamin Lucien", ""]]}, {"id": "1910.01935", "submitter": "Petra Wolf", "authors": "Petra Wolf", "title": "Synchronization under Dynamic Constraints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Imagine an assembly line where a box with a lid and liquid in it enters in\nsome unknown orientation. The box should leave the line with the open lid\nfacing upwards with the liquid still in it. To save costs there are no complex\nsensors or image recognition software available on the assembly line, so a\nreset sequence needs to be computed. But how can the dependencies of the\ndeforming impact of a transformation of the box, such as 'do not tilt the box\nover when the lid is open' or 'open the lid again each time it gets closed' be\nmodeled? We present three attempts to model constraints of these kinds on the\norder in which the states of an automaton are transitioned by a synchronizing\nword. The first two concepts relate the last visits of states and form\nconstraints on which states still need to be reached, whereas the third concept\nconcerns the first visits of states and forms constraints on which states might\nstill be reached. We examine the computational complexity of different variants\nof the problem, whether an automaton can be synchronized with a word that\nrespects the constraints defined in the respective concept, and obtain nearly a\nfull classification. While most of the problems are PSPACE-complete we also\nobserve NP-complete variants and variants solvable in polynomial time. We will\nalso observe a drop of the complexity if we track the orders of states on\nseveral paths simultaneously instead of tracking the set of active states.\nFurther, we give upper bounds on the length of a synchronizing word depending\non the size of the input relation and show that the Cerny conjecture holds for\npartial weakly acyclic automata.\n", "versions": [{"version": "v1", "created": "Fri, 4 Oct 2019 13:07:54 GMT"}, {"version": "v2", "created": "Mon, 13 Jan 2020 15:10:39 GMT"}, {"version": "v3", "created": "Thu, 9 Apr 2020 20:08:52 GMT"}, {"version": "v4", "created": "Sun, 3 May 2020 17:16:01 GMT"}, {"version": "v5", "created": "Fri, 17 Jul 2020 13:20:32 GMT"}], "update_date": "2020-07-20", "authors_parsed": [["Wolf", "Petra", ""]]}, {"id": "1910.01996", "submitter": "Ond\\v{r}ej Leng\\'al", "authors": "Luk\\'a\\v{s} Hol\\'ik, Ond\\v{r}ej Leng\\'al, Olli Saarikivi, Lenka\n  Turo\\v{n}ov\\'a, Margus Veanes, Tom\\'a\\v{s} Vojnar", "title": "Succinct Determinisation of Counting Automata via Sphere Construction\n  (Technical Report)", "comments": "An extended version of a paper accepted at APLAS'19", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose an efficient algorithm for determinising counting automata (CAs),\ni.e., finite automata extended with bounded counters. The algorithm avoids\nunfolding counters into control states, unlike the na\\\"ive approach, and thus\nproduces much smaller deterministic automata. We also develop a simplified and\nfaster version of the general algorithm for the sub-class of so-called monadic\nCAs (MCAs), i.e., CAs with counting loops on character classes, which are\ncommon in practice. Our main motivation is (besides applications in\nverification and decision procedures of logics) the application of\ndeterministic (M)CAs in pattern matching regular expressions with counting,\nwhich are very common in e.g. network traffic processing and log analysis. We\nhave evaluated our algorithm against practical benchmarks from these\napplication domains and concluded that compared to the na\\\"ive approach, our\nalgorithm is much less prone to explode, produces automata that can be several\norders of magnitude smaller, and is overall faster.\n", "versions": [{"version": "v1", "created": "Fri, 4 Oct 2019 15:38:28 GMT"}], "update_date": "2019-10-07", "authors_parsed": [["Hol\u00edk", "Luk\u00e1\u0161", ""], ["Leng\u00e1l", "Ond\u0159ej", ""], ["Saarikivi", "Olli", ""], ["Turo\u0148ov\u00e1", "Lenka", ""], ["Veanes", "Margus", ""], ["Vojnar", "Tom\u00e1\u0161", ""]]}, {"id": "1910.02164", "submitter": "Thomas Colcombet", "authors": "Thomas Colcombet, Sylvain Lombardy", "title": "Unambiguous separators for tropical tree automata", "comments": "submitted version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we show that given a max-plus automaton (over trees, and with\nreal weights) computing a function $f$ and a min-plus automaton (similar)\ncomputing a function $g$ such that $f\\leqslant g$, there exists effectively an\nunambiguous tropical automaton computing $h$ such that $f\\leqslant h\\leqslant\ng$. This generalizes a result of Lombardy and Mairesse of 2006 stating that\nseries which are both max-plus and min-plus rational are unambiguous. This\ngeneralization goes in two directions: trees are considered instead of words,\nand separation is established instead of characterization (separation implies\ncharacterization). The techniques in the two proofs are very different.\n", "versions": [{"version": "v1", "created": "Fri, 4 Oct 2019 23:03:36 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Colcombet", "Thomas", ""], ["Lombardy", "Sylvain", ""]]}, {"id": "1910.02302", "submitter": "Pavel Semukhin", "authors": "Volker Diekert, Igor Potapov and Pavel Semukhin", "title": "Decidability of membership problems for flat rational subsets of\n  $\\mathrm{GL}(2,\\mathbb{Q})$ and singular matrices", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work we extend previously known decidability results for $2\\times 2$\nmatrices over $\\mathbb{Q}$. Namely, we introduce a notion of flat rational\nsets: if $M$ is a monoid and $N\\leq M$ is its submonoid, then flat rational\nsets of $M$ relative to $N$ are finite unions of the form $L_0g_1L_1 \\cdots g_t\nL_t$ where all $L_i$s are rational subsets of $N$ and $g_i\\in M$. We give quite\ngeneral sufficient conditions under which flat rational sets form an effective\nrelative Boolean algebra. As a corollary, we obtain that the emptiness problem\nfor Boolean combinations of flat rational subsets of\n$\\mathrm{GL}(2,\\mathbb{Q})$ over $\\mathrm{GL}(2,\\mathbb{Z})$ is decidable.\n  We also show a dichotomy for nontrivial group extension of\n$\\mathrm{GL}(2,\\mathbb{Z})$ in $\\mathrm{GL}(2,\\mathbb{Q})$: if $G$ is a f.g.\ngroup such that $\\mathrm{GL}(2,\\mathbb{Z}) < G \\leq \\mathrm{GL}(2,\\mathbb{Q})$,\nthen either $G\\cong \\mathrm{GL}(2,\\mathbb{Z})\\times \\mathbb{Z}^k$, for some\n$k\\geq 1$, or $G$ contains an extension of the Baumslag-Solitar group\n$\\mathrm{BS}(1,q)$, with $q\\geq2$, of infinite index. It turns out that in the\nfirst case the membership problem for $G$ is decidable but the equality problem\nfor rational subsets of $G$ is undecidable. In the second case, the membership\nproblem for $G$ is an open problem as it is open for $\\mathrm{BS}(1,q)$.\n  In the last section we prove new decidability results for flat rational sets\nthat contain singular matrices. In particular, we show that the membership\nproblem is decidable for flat rational subsets of $M(2,\\mathbb{Q})$ relative to\nthe submonoid that is generated by the matrices from $M(2,\\mathbb{Z})$ with\ndeterminants $0,\\pm1$ and the central rational matrices.\n", "versions": [{"version": "v1", "created": "Sat, 5 Oct 2019 18:07:01 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Diekert", "Volker", ""], ["Potapov", "Igor", ""], ["Semukhin", "Pavel", ""]]}, {"id": "1910.02561", "submitter": "Mahsa Ghasemi", "authors": "Rayna Dimitrova, Mahsa Ghasemi, Ufuk Topcu", "title": "Reactive Synthesis with Maximum Realizability of Linear Temporal Logic\n  Specifications", "comments": "arXiv admin note: substantial text overlap with arXiv:1804.00415", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A challenging problem for autonomous systems is to synthesize a reactive\ncontroller that conforms to a set of given correctness properties. Linear\ntemporal logic (LTL) provides a formal language to specify the desired\nbehavioral properties of systems. In applications in which the specifications\noriginate from various aspects of the system design, or consist of a large set\nof formulas, the overall system specification may be unrealizable. Driven by\nthis fact, we develop an optimization variant of synthesis from LTL formulas,\nwhere the goal is to design a controller that satisfies a set of hard\nspecifications and minimally violates a set of soft specifications. To that\nend, we introduce a value function that, by exploiting the LTL semantics,\nquantifies the level of violation of properties. Inspired by the idea of\nbounded synthesis, we fix a bound on the implementation size and search for an\nimplementation that is optimal with respect to the said value function. We\npropose a novel maximum satisfiability encoding of the search for an optimal\nimplementation (within the given bound on the implementation size). We\niteratively increase the bound on the implementation size until a termination\ncriterion, such as a threshold over the value function, is met.\n", "versions": [{"version": "v1", "created": "Fri, 4 Oct 2019 17:57:07 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Dimitrova", "Rayna", ""], ["Ghasemi", "Mahsa", ""], ["Topcu", "Ufuk", ""]]}, {"id": "1910.02736", "submitter": "Ekanshdeep Gupta", "authors": "Alain Finkel (LSV), Ekanshdeep Gupta", "title": "The Well Structured Problem for Presburger Counter Machines", "comments": null, "journal-ref": "39th IARCS Annual Conference on Foundations of Software Technology\n  and Theoretical Computer Science (FSTTCS 2019), Arkadev Chattopadhyay; Paul\n  Gastin, Dec 2019, Mumbai, India", "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce the well structured problem as the question of whether a model\n(here a counter machine) is well structured (here for the usual ordering on\nintegers). We show that it is undecidable for most of the (Presburger-defined)\ncounter machines except for Affine VASS of dimension one. However, the strong\nwell structured problem is decidable for all Presburger counter machines. While\nAffine VASS of dimension one are not, in general, well structured, we give an\nalgorithm that computes the set of predecessors of a configuration; as a\nconsequence this allows to decide the well structured problem for 1-Affine\nVASS.\n", "versions": [{"version": "v1", "created": "Mon, 7 Oct 2019 11:43:20 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Finkel", "Alain", "", "LSV"], ["Gupta", "Ekanshdeep", ""]]}, {"id": "1910.03919", "submitter": "Pawe{\\l} Parys", "authors": "Pawe{\\l} Parys", "title": "Parity Games: Another View on Lehtinen's Algorithm", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recently, five quasi-polynomial-time algorithms solving parity games were\nproposed. We elaborate on one of the algorithms, by Lehtinen (2018).\n  Czerwi\\'nski et al. (2019) observe that four of the algorithms can be\nexpressed as constructions of separating automata (of quasi-polynomial size),\nthat is, automata that accept all plays decisively won by one of the players,\nand rejecting all plays decisively won by the other player. The separating\nautomata corresponding to three of the algorithms are deterministic, and it is\nclear that deterministic separating automata can be used to solve parity games.\nThe separating automaton corresponding to the algorithm of Lehtinen is\nnondeterministic, though. While this particular automaton can be used to solve\nparity games, this is not true for every nondeterministic separating automaton.\nAs a first (more conceptual) contribution, we specify when a nondeterministic\nseparating automaton can be used to solve parity games.\n  We also repeat the correctness proof of the Lehtinen's algorithm, using\nseparating automata. In this part, we prove that her construction actually\nleads to a faster algorithm than originally claimed in her paper: its\ncomplexity is $n^{O(\\log n)}$ rather than $n^{O(\\log d \\cdot \\log n)}$ (where\n$n$ is the number of nodes, and $d$ the number of priorities of a considered\nparity game), which is similar to complexities of the other\nquasi-polynomial-time algorithms.\n", "versions": [{"version": "v1", "created": "Wed, 9 Oct 2019 12:05:22 GMT"}], "update_date": "2019-10-10", "authors_parsed": [["Parys", "Pawe\u0142", ""]]}, {"id": "1910.04266", "submitter": "Thorsten Wissmann", "authors": "Hern\\'an Melgratti, Claudio Antares Mezzina, Irek Ulidowski", "title": "Reversing Place Transition Nets", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 4 (October\n  16, 2020) lmcs:6843", "doi": "10.23638/LMCS-16(4:5)2020", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Petri nets are a well-known model of concurrency and provide an ideal setting\nfor the study of fundamental aspects in concurrent systems. Despite their\nsimplicity, they still lack a satisfactory causally reversible semantics. We\ndevelop such semantics for Place/Transitions Petri nets (P/T nets) based on two\nobservations. Firstly, a net that explicitly expresses causality and conflict\namong events, for example an occurrence net, can be straightforwardly reversed\nby adding a reverse transition for each of its forward transitions. Secondly,\ngiven a P/T net the standard unfolding construction associates with it an\noccurrence net that preserves all of its computation. Consequently, the\nreversible semantics of a P/T net can be obtained as the reversible semantics\nof its unfolding. We show that such reversible behaviour can be expressed as a\nfinite net whose tokens are coloured by causal histories. Colours in our\nencoding resemble the causal memories that are typical in reversible process\ncalculi.\n", "versions": [{"version": "v1", "created": "Wed, 9 Oct 2019 21:38:19 GMT"}, {"version": "v2", "created": "Mon, 20 Apr 2020 12:51:59 GMT"}, {"version": "v3", "created": "Mon, 21 Sep 2020 15:11:20 GMT"}, {"version": "v4", "created": "Thu, 15 Oct 2020 11:24:18 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Melgratti", "Hern\u00e1n", ""], ["Mezzina", "Claudio Antares", ""], ["Ulidowski", "Irek", ""]]}, {"id": "1910.05003", "submitter": "Maria Spichkova", "authors": "Heinz Schmidt, Maria Spichkova", "title": "Towards Readability Aspects of Probabilistic Mode Automata", "comments": "Preprint. Accepted to 14th International Conference on Evaluation of\n  Novel Approaches to Software Engineering (ENASE 2019). Final version\n  published by SciTePress", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a new approach and design model targeting hybrid\ndesigner- and operator-defined performance budgets for timing and energy\nconsumption. The approach is based on Petri Nets formalism. As the cognitive\nload is typically high while using formal methods, this increases the chances\nof mistakes. Our approach is focused on the readability aspects and aims to\ndecrease the cognitive load of developers. We illustrate the proposed approach\non example of a sample embedded multi-media system, a modern digital camera.\n", "versions": [{"version": "v1", "created": "Fri, 11 Oct 2019 07:27:43 GMT"}], "update_date": "2019-10-14", "authors_parsed": [["Schmidt", "Heinz", ""], ["Spichkova", "Maria", ""]]}, {"id": "1910.05018", "submitter": "Nathana\\\"el Fijalkow", "authors": "Nathana\\\"el Fijalkow, Mohit Kumar Gupta", "title": "Verification of Neural Networks: Specifying Global Robustness using\n  Generative Models", "comments": "A preliminary version was presented at the VNN Symposium\n  (Verification of Neural Networks) in Stanford, 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL cs.NE stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The success of neural networks across most machine learning tasks and the\npersistence of adversarial examples have made the verification of such models\nan important quest. Several techniques have been successfully developed to\nverify robustness, and are now able to evaluate neural networks with thousands\nof nodes. The main weakness of this approach is in the specification:\nrobustness is asserted on a validation set consisting of a finite set of\nexamples, i.e. locally.\n  We propose a notion of global robustness based on generative models, which\nasserts the robustness on a very large and representative set of examples. We\nshow how this can be used for verifying neural networks. In this paper we\nexperimentally explore the merits of this approach, and show how it can be used\nto construct realistic adversarial examples.\n", "versions": [{"version": "v1", "created": "Fri, 11 Oct 2019 08:05:54 GMT"}], "update_date": "2019-10-14", "authors_parsed": [["Fijalkow", "Nathana\u00ebl", ""], ["Gupta", "Mohit Kumar", ""]]}, {"id": "1910.05558", "submitter": "Davide Giacomo Cavezza", "authors": "Davide G. Cavezza, Dalal Alrajeh, Andras Gyorgy", "title": "Minimal Assumptions Refinement for GR(1) Specifications", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reactive synthesis is concerned with finding a correct-by-construction\ncontroller from formal specifications, typically expressed in Linear Temporal\nLogic (LTL). The specifications describe assumptions about an environment and\nguarantees to be achieved by the controller operating in that environment. If a\ncontroller exists, given the assumptions, the specification is said to be\nrealizable. This paper focuses on finding a minimal set of assumptions that\nguarantee realizability in the context of counterstrategy-guided assumption\nrefinement procedures. Specifically, we introduce the notion of minimal\nassumptions refinements and provide an algorithm that provably computes these\nwith little time overhead. We show experimentally, using common benchmarks,\nthat embedding our algorithm in state-of-the-art approaches for assumption\nrefinement results in consistently shorter solutions than without such\nembedding, and allows to explore a higher number of candidate solutions. We\nalso propose a hybrid variant for dealing with the higher sparsity of solutions\nin the space of minimal refinements and show that its application speeds up the\nidentification of a solution.\n", "versions": [{"version": "v1", "created": "Sat, 12 Oct 2019 12:44:15 GMT"}], "update_date": "2019-10-15", "authors_parsed": [["Cavezza", "Davide G.", ""], ["Alrajeh", "Dalal", ""], ["Gyorgy", "Andras", ""]]}, {"id": "1910.06019", "submitter": "Nathan Lhote", "authors": "Paulin Fournier and Nathan Lhote", "title": "Equivalence kernels of sequential functions and sequential observation\n  synthesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that one can decide if a rational equivalence relation can be given\nas the equivalence kernel of a sequential letter-to-letter transduction. This\nproblem comes from the setting of games with imperfect information. In [1, p.\n6] the authors propose to model imperfect information by a rational equivalence\nrelation and leave open the problem of deciding if one can synthesize a\nsequential letter-to-letter transducer (Mealy machine) which maps equivalent\nhistories to the same sequence of observations. We also show that knowing if an\nequivalence relation can be given as the equivalence kernel of a sequential\ntransducer is undecidable, even if the relation is given as a letter-to-letter\ntransducer.\n", "versions": [{"version": "v1", "created": "Mon, 14 Oct 2019 09:58:24 GMT"}], "update_date": "2019-10-15", "authors_parsed": [["Fournier", "Paulin", ""], ["Lhote", "Nathan", ""]]}, {"id": "1910.06097", "submitter": "Bernhard Kragl", "authors": "Thomas Ferr\\`ere, Thomas A. Henzinger, Bernhard Kragl", "title": "Monitoring Event Frequencies", "comments": "This is an extended version of a paper presented at the 28th EACSL\n  Annual Conference on Computer Science Logic (CSL 2020), which provides\n  missing proofs in the appendix", "journal-ref": null, "doi": "10.4230/LIPIcs.CSL.2020.20", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The monitoring of event frequencies can be used to recognize behavioral\nanomalies, to identify trends, and to deduce or discard hypotheses about the\nunderlying system. For example, the performance of a web server may be\nmonitored based on the ratio of the total count of requests from the least and\nmost active clients. Exact frequency monitoring, however, can be prohibitively\nexpensive; in the above example it would require as many counters as there are\nclients. In this paper, we propose the efficient probabilistic monitoring of\ncommon frequency properties, including the mode (i.e., the most common event)\nand the median of an event sequence. We define a logic to express composite\nfrequency properties as a combination of atomic frequency properties. Our main\ncontribution is an algorithm that, under suitable probabilistic assumptions,\ncan be used to monitor these important frequency properties with four counters,\nindependent of the number of different events. Our algorithm samples longer and\nlonger subwords of an infinite event sequence. We prove the almost-sure\nconvergence of our algorithm by generalizing ergodic theory from\nincreasing-length prefixes to increasing-length subwords of an infinite\nsequence. A similar algorithm could be used to learn a connected Markov chain\nof a given structure from observing its outputs, to arbitrary precision, for a\ngiven confidence.\n", "versions": [{"version": "v1", "created": "Mon, 14 Oct 2019 12:35:04 GMT"}, {"version": "v2", "created": "Fri, 10 Jan 2020 13:59:43 GMT"}], "update_date": "2020-01-13", "authors_parsed": [["Ferr\u00e8re", "Thomas", ""], ["Henzinger", "Thomas A.", ""], ["Kragl", "Bernhard", ""]]}, {"id": "1910.06162", "submitter": "Uli Fahrenberg", "authors": "Uli Fahrenberg, Christian Johansen, Georg Struth, Ratan Bahadur Thapa", "title": "Generating Posets Beyond N", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce iposets---posets with interfaces---equipped with a novel gluing\ncomposition along interfaces and the standard parallel composition. We study\ntheir basic algebraic properties as well as the hierarchy of gluing-parallel\nposets generated from singletons by finitary applications of the two\ncompositions. We show that not only series-parallel posets, but also interval\norders, which seem more interesting for modelling concurrent and distributed\nsystems, can be generated, but not all posets. Generating posets is also\nimportant for constructing free algebras for concurrent semirings and Kleene\nalgebras that allow compositional reasoning about such systems.\n", "versions": [{"version": "v1", "created": "Mon, 14 Oct 2019 14:14:55 GMT"}], "update_date": "2019-10-15", "authors_parsed": [["Fahrenberg", "Uli", ""], ["Johansen", "Christian", ""], ["Struth", "Georg", ""], ["Thapa", "Ratan Bahadur", ""]]}, {"id": "1910.07519", "submitter": "Frederic Prost", "authors": "Dominique Duval (CASC), Rachid Echahed (LIG Laboratoire d'Informatique\n  de Grenoble), Frederic Prost (LIG)", "title": "On foundational aspects of RDF and SPARQL", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the recommendations of the World Wide Web Consortium (W3C) about\nthe Resource Description Framework (RDF) and the associated query language\nSPARQL. We propose a new formal framework based on category theory which\nprovides clear and concise formal definitions of the main basic features of RDF\nand SPARQL. We propose to define the notions of RDF graphs as well as SPARQL\nbasic graph patterns as objects of some nested categories. This allows one to\nclarify, in particular, the role of blank nodes. Furthermore, we consider basic\nSPARQL CONSTRUCT and SELECT queries and formalize their operational semantics\nfollowing a novel algebraic graph transformation approach called POIM.\n", "versions": [{"version": "v1", "created": "Wed, 16 Oct 2019 08:21:57 GMT"}, {"version": "v2", "created": "Mon, 16 Mar 2020 16:55:33 GMT"}], "update_date": "2020-03-17", "authors_parsed": [["Duval", "Dominique", "", "CASC"], ["Echahed", "Rachid", "", "LIG Laboratoire d'Informatique\n  de Grenoble"], ["Prost", "Frederic", "", "LIG"]]}, {"id": "1910.07583", "submitter": "Andreas Stahlbauer", "authors": "Andreas Stahlbauer", "title": "Abstract Transducers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Several abstract machines that operate on symbolic input alphabets have been\nproposed in the last decade, for example, symbolic automata or lattice\nautomata. Applications of these types of automata include software security\nanalysis and natural language processing. While these models provide means to\ndescribe words over infinite input alphabets, there is no considerable work on\nsymbolic output (as present in transducers) alphabets, or even abstraction\n(widening) thereof. Furthermore, established approaches for transforming, for\nexample, minimizing or reducing, finite-state machines that produce output on\nstates or transitions are not applicable. A notion of equivalence of this type\nof machines is needed to make statements about whether or not transformations\nmaintain the semantics. We present abstract transducers as a new form of\nfinite-state transducers. Both their input alphabet and the output alphabet is\ncomposed of abstract words, where one abstract word represents a set of\nconcrete words. The mapping between these representations is described by\nabstract word domains. By using words instead of single letters, abstract\ntransducers provide the possibility of lookaheads to decide on state\ntransitions to conduct. Since both the input symbol and the output symbol on\neach transition is an abstract entity, abstraction techniques can be applied\nnaturally. We apply abstract transducers as the foundation for sharing task\nartifacts for reuse in context of program analysis and verification, and\ndescribe task artifacts as abstract words. A task artifact is any entity that\ncontributes to an analysis task and its solution, for example, candidate\ninvariants or source code to weave.\n", "versions": [{"version": "v1", "created": "Wed, 16 Oct 2019 19:34:55 GMT"}], "update_date": "2019-10-18", "authors_parsed": [["Stahlbauer", "Andreas", ""]]}, {"id": "1910.08518", "submitter": "Jorge Lucero", "authors": "Jorge C. Lucero", "title": "Pumping lemmas for classes of languages generated by folding systems", "comments": "12 pages, 6 figures. This is a preprint (pre-refereeing) version of a\n  manuscript accepted for publication in Natural Computing", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Geometric folding processes are ubiquitous in natural systems ranging from\nprotein biochemistry to patterns of insect wings and leaves. In a previous\nstudy, a folding operation between strings of formal languages was introduced\nas a model of such processes. The operation was then used to define a folding\nsystem (F-system) as a construct consisting of a core language, containing the\nstrings to be folded, and a folding procedure language, which defines how the\nfolding is done. This paper reviews main definitions associated with F-systems\nand next it determines necessary conditions for a language to belong to classes\ngenerated by such systems. The conditions are stated in the form of pumping\nlemmas and four classes are considered, in which the core and folding procedure\nlanguages are both regular, one of them is regular and the other context-free,\nor both are context-free. Full demonstrations of the lemmas are provided, and\nthe analysis is illustrated with examples.\n", "versions": [{"version": "v1", "created": "Fri, 18 Oct 2019 17:30:04 GMT"}], "update_date": "2019-10-21", "authors_parsed": [["Lucero", "Jorge C.", ""]]}, {"id": "1910.08543", "submitter": "Adeline Massuir", "authors": "\\'Emilie Charlier, C\\'elia Cisternino and Adeline Massuir", "title": "Minimal automaton for multiplying and translating the Thue-Morse set", "comments": "arXiv admin note: substantial text overlap with arXiv:1909.07676,\n  arXiv:1903.06114", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Thue-Morse set $\\mathcal{T}$ is the set of those non-negative integers\nwhose binary expansions have an even number of $1$. The name of this set comes\nfrom the fact that its characteristic sequence is given by the famous\nThue-Morse word ${\\tt abbabaabbaababba\\cdots}$, which is the fixed point\nstarting with ${\\tt a}$ of the word morphism ${\\tt a\\mapsto ab,b\\mapsto ba}$.\nThe numbers in $\\mathcal{T}$ are commonly called the {\\em evil numbers}. We\nobtain an exact formula for the state complexity of the set $m\\mathcal{T}+r$\n(i.e.\\ the number of states of its minimal automaton) with respect to any base\n$b$ which is a power of $2$. Our proof is constructive and we are able to\nexplicitly provide the minimal automaton of the language of all\n$2^p$-expansions of the set of integers $m\\mathcal{T}+r$ for any positive\nintegers $p$ and $m$ and any remainder $r\\in\\{0,\\ldots,m-1\\}$. The proposed\nmethod is general for any $b$-recognizable set of integers. As an application,\nwe obtain a decision procedure running in quadratic time for the problem of\ndeciding whether a given $2^p$-recognizable set is equal to a set of the form\n$m\\mathcal{T}+r$.\n", "versions": [{"version": "v1", "created": "Fri, 18 Oct 2019 09:20:24 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Charlier", "\u00c9milie", ""], ["Cisternino", "C\u00e9lia", ""], ["Massuir", "Adeline", ""]]}, {"id": "1910.08546", "submitter": "Jean-Paul Allouche", "authors": "Jean-Paul Allouche, Jeffrey Shallit", "title": "Automatic sequences are also non-uniformly morphic", "comments": "arXiv admin note: text overlap with arXiv:0905.0015", "journal-ref": "in \"Discrete Mathematics and Applications'', A. M. Raigorodskii\n  and M. Th. Rassias eds., Springer Optimization and Its Applications, Springer\n  Nature 165 (2020), 1-6", "doi": null, "report-no": null, "categories": "math.NT cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is well-known that there exist infinite sequences that are the fixed point\nof non-uniform morphisms, but not $k$-automatic for any $k$. In this note we\nshow that every $k$-automatic sequence is the image of a fixed point of a {\\it\nnon-uniform\\/} morphism.\n", "versions": [{"version": "v1", "created": "Fri, 18 Oct 2019 11:53:11 GMT"}], "update_date": "2021-03-23", "authors_parsed": [["Allouche", "Jean-Paul", ""], ["Shallit", "Jeffrey", ""]]}, {"id": "1910.08992", "submitter": "Lars Luthmann M.Sc.", "authors": "Lars Luthmann (1), Hendrik G\\\"ottmann (1), Isabelle Bacher (1), Malte\n  Lochau (2) ((1) Real-Time Systems Lab, TU Darmstadt, (2) Model-based\n  Engineering Group, University of Siegen)", "title": "Checking Timed Bisimulation with Bounded Zone-History Graphs --\n  Technical Report", "comments": "23 pages, 7 figures, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Timed automata (TA) are a well-established formalism for specifying\ndiscrete-state/continuous-time behavior of time-critical reactive systems.\nConcerning the fundamental analysis problem of comparing a candidate\nimplementation against a specification, both given as TA, it has been shown\nthat timed trace equivalence is undecidable, whereas timed bisimulation\nequivalence is decidable. The corresponding proof utilizes region graphs, a\nfinite, but generally very space-consuming characterization of TA semantics.\nHence, most practical TA tools utilize zone graphs instead, a symbolic and\ngenerally more efficient representation of TA semantics, to automate analysis\ntasks. However, zone graphs only produce sound results for analysis tasks being\nreducible to plain reachability problems thus being too imprecise for checking\ntimed bisimilarity. In this paper, we propose bounded zone-history graphs, a\nnovel characterization of TA semantics facilitating an adjustable trade-off\nbetween precision and scalability of timed-bisimilarity checking. Our tool\nTimBrCheck is, to the best of our knowledge, the only currently available tool\nfor effectively checking timed bisimilarity and even supports non-deterministic\nTA with silent moves. We further present experimental results gained from\napplying our tool to a collection of community benchmarks, providing insights\ninto trade-offs between precision and efficiency, depending on the bound value.\n", "versions": [{"version": "v1", "created": "Sun, 20 Oct 2019 14:33:42 GMT"}, {"version": "v2", "created": "Fri, 25 Oct 2019 14:56:51 GMT"}, {"version": "v3", "created": "Wed, 16 Sep 2020 16:19:32 GMT"}], "update_date": "2020-09-17", "authors_parsed": [["Luthmann", "Lars", ""], ["G\u00f6ttmann", "Hendrik", ""], ["Bacher", "Isabelle", ""], ["Lochau", "Malte", ""]]}, {"id": "1910.09072", "submitter": "Taylor Dohmen", "authors": "Vrunda Dave, Taylor Dohmen, Shankara Narayana Krishna, Ashutosh\n  Trivedi", "title": "Regular Model Checking with Regular Relations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Regular model checking is an exploration technique for infinite state systems\nwhere state spaces are represented as regular languages and transition\nrelations are expressed using rational relations over infinite (or finite)\nstrings. We extend the regular model checking paradigm to permit the use of\nmore powerful transition relations: the class of regular relations, of which\nthe rational relations are a strict subset. We use the language of monadic\nsecond-order logic on infinite strings to specify such relations and adopt\nstreaming string transducers (SSTs) as a suitable computational model. We\nintroduce nondeterministic SSTs over infinite strings and show that they\nprecisely capture the relations definable in MSO. We further explore\ntheoretical properties of omega-NSSTs required to effectively carry out regular\nmodel checking. In particular, we establish that the regular type checking\nproblem for omega-NSSTs is decidable in PSPACE. Since the post-image of a\nregular language under a regular relation may not be regular (or even\ncontext-free), approaches that iteratively compute the image can not be\neffectively carried out in this setting. Instead, we utilize the fact that\nregular relations are closed under composition, which, together with our\ndecidability result, provides a foundation for regular model checking with\nregular relations.\n", "versions": [{"version": "v1", "created": "Sun, 20 Oct 2019 22:11:23 GMT"}, {"version": "v2", "created": "Mon, 12 Jul 2021 02:03:08 GMT"}], "update_date": "2021-07-13", "authors_parsed": [["Dave", "Vrunda", ""], ["Dohmen", "Taylor", ""], ["Krishna", "Shankara Narayana", ""], ["Trivedi", "Ashutosh", ""]]}, {"id": "1910.09327", "submitter": "Michele Chiari", "authors": "Michele Chiari, Dino Mandrioli and Matteo Pradella", "title": "POTL: A First-Order Complete Temporal Logic for Operator Precedence\n  Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The problem of model checking procedural programs has fostered much research\ntowards the definition of temporal logics for reasoning on context-free\nstructures. The most notable of such results are temporal logics on Nested\nWords, such as CaRet and NWTL. Recently, the logic OPTL was introduced, based\non the class of Operator Precedence Languages (OPL), more powerful than Nested\nWords. We define the new OPL-based logic POTL, prove its FO-completeness, and\nprovide a model checking procedure for it. POTL improves on NWTL by enabling\nthe formulation of requirements involving pre/post-conditions, stack\ninspection, and others in the presence of exception-like constructs. It\nimproves on OPTL by being FO-complete, and by expressing more easily stack\ninspection and function-local properties.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 12:59:01 GMT"}, {"version": "v2", "created": "Sat, 31 Oct 2020 15:14:56 GMT"}], "update_date": "2020-11-03", "authors_parsed": [["Chiari", "Michele", ""], ["Mandrioli", "Dino", ""], ["Pradella", "Matteo", ""]]}, {"id": "1910.09339", "submitter": "Samuel Huang", "authors": "Samuel Huang, Rance Cleaveland", "title": "A Tableau Construction for Finite Linear-Time Temporal Logic", "comments": "29 pages, 2 tables 1 figure, 8 page appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes a method for converting formulas in finite propositional\nlinear-time temporal logic (Finite LTL) into finite-state automata whose\nlanguages are the models of the given formula. Finite LTL differs from\ntraditional LTL in that formulas are interpreted with respect to finite, rather\nthan infinite, sequences of states; this fact means that traditional\nfinite-state automata, rather than {\\omega}-automata such as those developed by\nB\\\"uchi and others, suffice for recognizing models of such formulas. The\napproach considered is based on well-known tableau-construction techniques\ndeveloped for LTL, which we adapt here for the setting of Finite LTL. The\nresulting automata may be used as a basis for model checking, satisfiability\ntesting, and model synthesis.\n", "versions": [{"version": "v1", "created": "Wed, 16 Oct 2019 16:33:02 GMT"}, {"version": "v2", "created": "Mon, 22 Jun 2020 01:03:35 GMT"}], "update_date": "2020-06-23", "authors_parsed": [["Huang", "Samuel", ""], ["Cleaveland", "Rance", ""]]}, {"id": "1910.09744", "submitter": "Umang Mathur", "authors": "Paul Krogmeier, Umang Mathur, Adithya Murali, P. Madhusudan, Mahesh\n  Viswanathan", "title": "Decidable Synthesis of Programs with Uninterpreted Functions", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-53291-8_32", "report-no": null, "categories": "cs.PL cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We identify a decidable synthesis problem for a class of programs of\nunbounded size with conditionals and iteration that work over infinite data\ndomains. The programs in our class use uninterpreted functions and relations,\nand abide by a restriction called coherence that was recently identified to\nyield decidable verification. We formulate a powerful grammar-restricted\n(syntax-guided) synthesis problem for coherent uninterpreted programs, and we\nshow the problem to be decidable, identify its precise complexity, and also\nstudy several variants of the problem.\n", "versions": [{"version": "v1", "created": "Tue, 22 Oct 2019 03:06:11 GMT"}, {"version": "v2", "created": "Wed, 22 Jul 2020 21:36:15 GMT"}], "update_date": "2020-07-24", "authors_parsed": [["Krogmeier", "Paul", ""], ["Mathur", "Umang", ""], ["Murali", "Adithya", ""], ["Madhusudan", "P.", ""], ["Viswanathan", "Mahesh", ""]]}, {"id": "1910.10357", "submitter": "Ryoma Senda", "authors": "Ryoma Senda, Yoshiaki Takata and Hiroyuki Seki", "title": "Complexity Results on Register Pushdown Automata", "comments": "Proceedings of the Third Workshop on Software Foundations for Data\n  Interoperability (SFDI2019+), October 28, 2019, Fukuoka, Japan", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Register pushdown automata (RPDA) is an extension of classical pushdown\nautomata to handle data values in a restricted way. RPDA attracts attention as\na model of a query language for structured documents with data values. The\nmembership and emptiness problems for RPDA are known to be EXPTIME-complete.\nThis paper shows the membership problem becomes PSPACE-complete and NP-complete\nfor nondecreasing and growing RPDA, respectively, while the emptiness problem\nremains EXPTIME-complete for these subclasses.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2019 05:19:33 GMT"}], "update_date": "2019-10-24", "authors_parsed": [["Senda", "Ryoma", ""], ["Takata", "Yoshiaki", ""], ["Seki", "Hiroyuki", ""]]}, {"id": "1910.10507", "submitter": "Ra\\'ul E. Monti", "authors": "Raul E. Monti and Pedro R. D'Argenio and Carlos E. Budde", "title": "A compositional semantics for Repairable Fault Trees with general\n  distributions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Fault Tree Analysis (FTA) is a prominent technique in industrial and\nscientific risk assessment. Repairable Fault Trees (RFT) enhance the classical\nFault Tree (FT) model by introducing the possibility to describe complex\ndependent repairs of system components. Usual frameworks for analyzing FTs such\nas BDD, SBDD, and Markov chains fail to assess the desired properties over RFT\ncomplex models, either because these become too large, or due to cyclic\nbehaviour introduced by dependent repairs. Simulation is another way to carry\nout this kind of analysis. In this paper we review the RFT model with Repair\nBoxes as introduced by Daniele Codetta-Raiteri. We present compositional\nsemantics for this model in terms of Input/Output Stochastic Automata, which\nallows for the modelling of events occurring according to general continuous\ndistribution. Moreover, we prove that the semantics generates (weakly)\ndeterministic models, hence suitable for discrete event simulation, and\nprominently for Rare Event Simulation using the FIG tool.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2019 12:05:25 GMT"}], "update_date": "2019-10-24", "authors_parsed": [["Monti", "Raul E.", ""], ["D'Argenio", "Pedro R.", ""], ["Budde", "Carlos E.", ""]]}, {"id": "1910.10546", "submitter": "Christoph Ohrem", "authors": "Jens Oliver Gutsfeld, Markus M\\\"uller-Olm, Christoph Ohrem", "title": "Propositional Dynamic Logic for Hyperproperties", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Information security properties of reactive systems like non-interference\noften require relating different executions of the system to each other and\nfollowing them simultaneously. Such hyperproperties can also be useful in other\ncontexts, e.g., when analysing properties of distributed systems like\nlinearizability. Since common logics like LTL, CTL, or the modal mu-calculus\ncannot express hyperproperties, the hyperlogics HyperLTL and HyperCTL* were\ndeveloped to cure this defect. However, these logics are not able to express\narbitrary omega-regular properties. In this paper, we introduce HyperPDL-Delta,\nan adaptation of the Propositional Dynamic Logic of Fischer and Ladner for\nhyperproperties, in order to remove this limitation. Using an elegant\nautomata-theoretic framework, we show that HyperPDL-Delta model checking is\nasymptotically not more expensive than HyperCTL* model checking, despite its\nvastly increased expressive power. We further investigate fragments of\nHyperPDL-Delta with regard to satisfiability checking.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2019 13:13:55 GMT"}, {"version": "v2", "created": "Fri, 17 Jul 2020 11:08:32 GMT"}], "update_date": "2020-07-20", "authors_parsed": [["Gutsfeld", "Jens Oliver", ""], ["M\u00fcller-Olm", "Markus", ""], ["Ohrem", "Christoph", ""]]}, {"id": "1910.10680", "submitter": "Jie An", "authors": "Jie An, Mingshuai Chen, Bohua Zhan, Naijun Zhan and Miaomiao Zhang", "title": "Learning One-Clock Timed Automata", "comments": "Full version of the paper in TACAS2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an algorithm for active learning of deterministic timed automata\nwith a single clock. The algorithm is within the framework of Angluin's $L^*$\nalgorithm and inspired by existing work on the active learning of symbolic\nautomata. Due to the need of guessing for each transition whether it resets the\nclock, the algorithm is of exponential complexity in the size of the learned\nautomata. Before presenting this algorithm, we propose a simpler version where\nthe teacher is assumed to be smart in the sense of being able to provide the\nreset information. We show that this simpler setting yields a polynomial\ncomplexity of the learning process. Both of the algorithms are implemented and\nevaluated on a collection of randomly generated examples. We furthermore\ndemonstrate the simpler algorithm on the functional specification of the TCP\nprotocol.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2019 17:33:24 GMT"}, {"version": "v2", "created": "Thu, 24 Oct 2019 15:16:00 GMT"}, {"version": "v3", "created": "Thu, 26 Mar 2020 07:02:03 GMT"}], "update_date": "2020-03-27", "authors_parsed": [["An", "Jie", ""], ["Chen", "Mingshuai", ""], ["Zhan", "Bohua", ""], ["Zhan", "Naijun", ""], ["Zhang", "Miaomiao", ""]]}, {"id": "1910.10987", "submitter": "Claudio Mezzina", "authors": "Hern\\'an Melgratti, Claudio Antares Mezzina, Iain Phillips, G. Michele\n  Pinna, Irek Ulidowski", "title": "Reversible Causal Nets and Reversible Event Structures", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One of the well-known results in concurrency theory concerns the relationship\nbetween event structures and occurrence nets: an occurrence net can be\nassociated with a prime event structure, and vice versa. More generally, the\nrelationships between various forms of event structures and suitable forms of\nnets have been long established. Good examples are the close relationship\nbetween inhibitor event structures and inhibitor occurrence nets, or between\nasymmetric event structures and asymmetric occurrence nets. Several forms of\nevent structures suited for the modelling of reversible computation have\nrecently been developed; also a method for reversing occurrence nets has been\nproposed. This paper bridges the gap between reversible event structures and\nreversible nets. We introduce the notion of reversible causal net, which is a\ngeneralisation of the notion of reversible unfolding. We show that reversible\ncausal nets correspond precisely to a subclass of reversible prime event\nstructures, the causal reversible prime event structures.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 09:26:21 GMT"}], "update_date": "2019-10-25", "authors_parsed": [["Melgratti", "Hern\u00e1n", ""], ["Mezzina", "Claudio Antares", ""], ["Phillips", "Iain", ""], ["Pinna", "G. Michele", ""], ["Ulidowski", "Irek", ""]]}, {"id": "1910.11594", "submitter": "Jens Oliver Gutsfeld", "authors": "Jens Oliver Gutsfeld, Markus M\\\"uller-Olm and Christian Dielitz", "title": "Temporal Logics with Language Parameters", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computation Tree Logic (CTL) and its extensions CTL* and CTL+ are widely used\nin automated verification as a basis for common model checking tools. But while\nthey can express many properties of interest like reachability, even simple\nregular properties like \"Every other index is labelled a cannot be expressed in\nthese logics. While many extensions were developed to include regular or even\nnon-regular (e.g. visibly pushdown) languages, the first generic framework,\nExtended CTL, for CTL with arbitrary language classes was given by Axelsson et.\nal. and applied to regular, visibly pushdown and (deterministic) context-free\nlanguages. We extend this framework to CTL* and CTL+ and analyse it with regard\nto decidability, complexity, expressivity and satisfiability.\n", "versions": [{"version": "v1", "created": "Fri, 25 Oct 2019 09:32:53 GMT"}], "update_date": "2019-10-28", "authors_parsed": [["Gutsfeld", "Jens Oliver", ""], ["M\u00fcller-Olm", "Markus", ""], ["Dielitz", "Christian", ""]]}, {"id": "1910.11666", "submitter": "Joshua Moerman", "authors": "Joshua Moerman and Matteo Sammartino", "title": "Residuality and Learning for Nondeterministic Register Automata", "comments": "Extended version of the CONCUR'20 paper \"Residual Nominal Automata\".\n  Submitted to LMCS special issue of CONCUR 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We are motivated by the following question: which data languages admit an\nactive learning algorithm? This question was left open in previous work, and is\nparticularly challenging for languages recognised by nondeterministic automata.\nTo answer it, we develop the theory of residual register automata, a subclass\nof nondeterministic register automata. We prove that this class has canonical\nrepresentatives, which can always be constructed via a finite number of\nobservations. This property enables active learning algorithms, and makes up\nfor the fact that residuality - a semantic property - is undecidable for\nregister automata. Our construction for canonical residual automata is based on\na machine-independent characterisation of residual languages, for which we\ndevelop new results in nominal lattice theory. Studying residuality in the\ncontext of nominal languages is a step towards a better understanding of\nlearnability of automata with some sort of nondeterminism.\n", "versions": [{"version": "v1", "created": "Fri, 25 Oct 2019 12:47:13 GMT"}, {"version": "v2", "created": "Thu, 5 Mar 2020 11:13:13 GMT"}, {"version": "v3", "created": "Tue, 6 Apr 2021 14:58:08 GMT"}, {"version": "v4", "created": "Wed, 7 Apr 2021 11:14:03 GMT"}], "update_date": "2021-04-08", "authors_parsed": [["Moerman", "Joshua", ""], ["Sammartino", "Matteo", ""]]}, {"id": "1910.11672", "submitter": "Carlos E. Budde", "authors": "Carlos E. Budde, Marco Biagi, Ra\\'ul E. Monti, Pedro R. D'Argenio,\n  Mari\\\"elle Stoelinga", "title": "Rare Event Simulation for non-Markovian repairable Fault Trees", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.FL cs.SY eess.SY", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Dynamic Fault Trees (DFT) are widely adopted in industry to assess the\ndependability of safety-critical equipment. Since many systems are too large to\nbe studied numerically, DFTs dependability is often analysed using Monte Carlo\nsimulation. A bottleneck here is that many simulation samples are required in\nthe case of rare events, e.g. in highly reliable systems where components fail\nseldomly. Rare Event Simulation (RES) provides techniques to reduce the number\nof samples in the case of rare events. We present a RES technique based on\nimportance splitting, to study failures in highly reliable DFTs. Whereas RES\nusually requires meta-information from an expert, our method is fully\nautomatic: by cleverly exploiting the fault tree structure we extract the\nso-called importance function. We handle DFTs with Markovian and non-Markovian\nfailure and repair distributions (for which no numerical methods exist) and\nshow the efficiency of our approach on several case studies.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2019 19:20:42 GMT"}, {"version": "v2", "created": "Mon, 28 Oct 2019 14:56:27 GMT"}], "update_date": "2019-10-29", "authors_parsed": [["Budde", "Carlos E.", ""], ["Biagi", "Marco", ""], ["Monti", "Ra\u00fal E.", ""], ["D'Argenio", "Pedro R.", ""], ["Stoelinga", "Mari\u00eblle", ""]]}, {"id": "1910.12787", "submitter": "Thomas Kahl", "authors": "Thomas Kahl", "title": "Weak equivalence of higher-dimensional automata", "comments": null, "journal-ref": "Discrete Mathematics & Theoretical Computer Science, vol. 23 no.\n  1, Automata, Logic and Semantics (May 18, 2021) dmtcs:7490", "doi": null, "report-no": null, "categories": "cs.LO cs.FL math.AT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces a notion of equivalence for higher-dimensional\nautomata, called weak equivalence. Weak equivalence focuses mainly on a\ntraditional trace language and a new homology language, which captures the\noverall independence structure of an HDA. It is shown that weak equivalence is\ncompatible with both the tensor product and the coproduct of HDAs and that,\nunder certain conditions, HDAs may be reduced to weakly equivalent smaller ones\nby merging and collapsing cubes.\n", "versions": [{"version": "v1", "created": "Mon, 28 Oct 2019 16:30:42 GMT"}, {"version": "v2", "created": "Wed, 13 Jan 2021 12:14:47 GMT"}, {"version": "v3", "created": "Sun, 16 May 2021 16:53:31 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Kahl", "Thomas", ""]]}, {"id": "1910.13526", "submitter": "Qin Lin", "authors": "Qin Lin, Sicco Verwer, John Dolan", "title": "Learning a Safety Verifiable Adaptive Cruise Controller from Human\n  Driving Data", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Imitation learning provides a way to automatically construct a controller by\nmimicking human behavior from data. For safety-critical systems such as\nautonomous vehicles, it can be problematic to use controllers learned from data\nbecause they cannot be guaranteed to be collision-free. Recently, a method has\nbeen proposed for learning a multi-mode hybrid automaton cruise controller\n(MOHA). Besides being accurate, the logical nature of this model makes it\nsuitable for formal verification. In this paper, we demonstrate this capability\nusing the SpaceEx hybrid model checker as follows. After learning, we translate\nthe automaton model into constraints and equations required by SpaceEx. We then\nverify that a pure MOHA controller is not collision-free. By adding a safety\nstate based on headway in time, a rule that human drivers should follow anyway,\nwe do obtain a provably safe cruise control. Moreover, the safe controller\nremains more human-like than existing cruise controllers.\n", "versions": [{"version": "v1", "created": "Tue, 29 Oct 2019 20:51:13 GMT"}], "update_date": "2019-10-31", "authors_parsed": [["Lin", "Qin", ""], ["Verwer", "Sicco", ""], ["Dolan", "John", ""]]}, {"id": "1910.13615", "submitter": "Xiang Huang", "authors": "Xiang Huang, Jack H. Lutz, Elvira Mayordomo, and Donald M. Stull", "title": "Asymptotic Divergences and Strong Dichotomy", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.IT cs.CC cs.FL cs.GT math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Schnorr-Stimm dichotomy theorem concerns finite-state gamblers that bet\non infinite sequences of symbols taken from a finite alphabet $\\Sigma$.\n  In this paper we use the Kullback-Leibler divergence to formulate the\n$\\textit{lower asymptotic divergence}$ $\\text{div}(S||\\alpha)$ of a probability\nmeasure $\\alpha$ on $\\Sigma$ from a sequence $S$ over $\\Sigma$ and the\n$\\textit{upper asymptotic divergence}$ $\\text{Div}(S||\\alpha)$ of $\\alpha$ from\n$S$ in such a way that a sequence $S$ is $\\alpha$-normal (meaning that every\nstring $w$ has asymptotic frequency $\\alpha(w)$ in $S$) if and only if\n$\\text{Div}(S||\\alpha)=0$. We also use the Kullback-Leibler divergence to\nquantify the $\\textit{total risk }$ $\\text{Risk}_G(w)$ that a finite-state\ngambler $G$ takes when betting along a prefix $w$ of $S$.\n  Our main theorem is a $\\textit{strong dichotomy theorem}$ that uses the above\nnotions to $\\textit{quantify}$ the exponential rates of winning and losing on\nthe two sides of the Schnorr-Stimm dichotomy theorem (with the latter routinely\nextended from normality to $\\alpha$-normality). Modulo asymptotic caveats in\nthe paper, our strong dichotomy theorem says that the following two things hold\nfor prefixes $w$ of $S$.\n  (1) The infinitely-often exponential rate of winning is\n$2^{\\text{Div}(S||\\alpha)|w|}$.\n  (2) The exponential rate of loss is $2^{-\\text{Risk}_G(w)}$.\n  We also use (1) to show that $1-\\text{Div}(S||\\alpha)/c$, where $c= \\log(1/\n\\min_{a\\in\\Sigma}\\alpha(a))$, is an upper bound on the finite-state\n$\\alpha$-dimension of $S$ and prove the dual fact that\n$1-\\text{div}(S||\\alpha)/c$ is an upper bound on the finite-state strong\n$\\alpha$-dimension of $S$.\n", "versions": [{"version": "v1", "created": "Wed, 30 Oct 2019 01:30:23 GMT"}], "update_date": "2019-10-31", "authors_parsed": [["Huang", "Xiang", ""], ["Lutz", "Jack H.", ""], ["Mayordomo", "Elvira", ""], ["Stull", "Donald M.", ""]]}, {"id": "1910.13895", "submitter": "Gail Weiss", "authors": "Gail Weiss, Yoav Goldberg, and Eran Yahav", "title": "Learning Deterministic Weighted Automata with Queries and\n  Counterexamples", "comments": "Presented in NeurIPS 2019. Update: fix email address, add reference\n  to github repo (available at https://github.com/tech-srl/weighted_lstar )", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.FL stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an algorithm for extraction of a probabilistic deterministic\nfinite automaton (PDFA) from a given black-box language model, such as a\nrecurrent neural network (RNN). The algorithm is a variant of the\nexact-learning algorithm L*, adapted to a probabilistic setting with noise. The\nkey insight is the use of conditional probabilities for observations, and the\nintroduction of a local tolerance when comparing them. When applied to RNNs,\nour algorithm often achieves better word error rate (WER) and normalised\ndistributed cumulative gain (NDCG) than that achieved by spectral extraction of\nweighted finite automata (WFA) from the same networks. PDFAs are substantially\nmore expressive than n-grams, and are guaranteed to be stochastic and\ndeterministic - unlike spectrally extracted WFAs.\n", "versions": [{"version": "v1", "created": "Wed, 30 Oct 2019 14:37:33 GMT"}, {"version": "v2", "created": "Sun, 29 Dec 2019 10:29:51 GMT"}], "update_date": "2020-01-01", "authors_parsed": [["Weiss", "Gail", ""], ["Goldberg", "Yoav", ""], ["Yahav", "Eran", ""]]}, {"id": "1910.14294", "submitter": "Benedikt Bollig", "authors": "B\\'eatrice B\\'erard, Benedikt Bollig, Mathieu Lehaut, Nathalie\n  Sznajder", "title": "Parameterized Synthesis for Fragments of First-Order Logic over Data\n  Words", "comments": "Technical report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the synthesis problem for systems with a parameterized number of\nprocesses. As in the classical case due to Church, the system selects actions\ndepending on the program run so far, with the aim of fulfilling a given\nspecification. The difficulty is that, at the same time, the environment\nexecutes actions that the system cannot control. In contrast to the case of\nfixed, finite alphabets, here we consider the case of parameterized alphabets.\nAn alphabet reflects the number of processes that are static but unknown. The\nsynthesis problem then asks whether there is a finite number of processes for\nwhich the system can satisfy the specification. This variant is already\nundecidable for very limited logics. Therefore, we consider a first-order logic\nwithout the order on word positions. We show that even in this restricted case\nsynthesis is undecidable if both the system and the environment have access to\nall processes. On the other hand, we prove that the problem is decidable if the\nenvironment only has access to a bounded number of processes. In that case,\nthere is even a cutoff meaning that it is enough to examine a bounded number of\nprocess architectures to solve the synthesis problem.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 08:11:10 GMT"}], "update_date": "2019-11-01", "authors_parsed": [["B\u00e9rard", "B\u00e9atrice", ""], ["Bollig", "Benedikt", ""], ["Lehaut", "Mathieu", ""], ["Sznajder", "Nathalie", ""]]}, {"id": "1910.14381", "submitter": "Paul Brunet", "authors": "Paul Brunet", "title": "A note on commutative Kleene algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present a detailed proof of an important result of algebraic\nlogic: namely that the free commutative Kleene algebra is the space of\nsemilinear sets. The first proof of this result was proposed by Redko in 1964,\nand simplified and corrected by Pilling in his 1970 thesis. However, we feel\nthat a new account of this proof is needed now. This result has acquired a\nparticular importance in recent years, since it is a key component in the\ncompleteness proofs of several algebraic models of concurrent computations\n(bi-Kleene algebra, concurrent Kleene algebra...). To that effect, we present a\nnew proof of this result.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 11:24:40 GMT"}], "update_date": "2019-11-01", "authors_parsed": [["Brunet", "Paul", ""]]}, {"id": "1910.14574", "submitter": "Guy Katz", "authors": "Yizhak Yisrael Elboher, Justin Gottschlich, Guy Katz", "title": "An Abstraction-Based Framework for Neural Network Verification", "comments": "This paper appeared at CAV 2020", "journal-ref": null, "doi": "10.1007/978-3-030-53288-8_3", "report-no": null, "categories": "cs.FL cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deep neural networks are increasingly being used as controllers for\nsafety-critical systems. Because neural networks are opaque, certifying their\ncorrectness is a significant challenge. To address this issue, several neural\nnetwork verification approaches have recently been proposed. However, these\napproaches afford limited scalability, and applying them to large networks can\nbe challenging. In this paper, we propose a framework that can enhance neural\nnetwork verification techniques by using over-approximation to reduce the size\nof the network - thus making it more amenable to verification. We perform the\napproximation such that if the property holds for the smaller (abstract)\nnetwork, it holds for the original as well. The over-approximation may be too\ncoarse, in which case the underlying verification tool might return a spurious\ncounterexample. Under such conditions, we perform counterexample-guided\nrefinement to adjust the approximation, and then repeat the process. Our\napproach is orthogonal to, and can be integrated with, many existing\nverification techniques. For evaluation purposes, we integrate it with the\nrecently proposed Marabou framework, and observe a significant improvement in\nMarabou's performance. Our experiments demonstrate the great potential of our\napproach for verifying larger neural networks.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 16:27:42 GMT"}, {"version": "v2", "created": "Tue, 21 Jul 2020 06:49:23 GMT"}], "update_date": "2020-07-22", "authors_parsed": [["Elboher", "Yizhak Yisrael", ""], ["Gottschlich", "Justin", ""], ["Katz", "Guy", ""]]}]