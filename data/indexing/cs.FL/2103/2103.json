[{"id": "2103.00167", "submitter": "Dirk Fahland", "authors": "Dirk Fahland, Vadim Denisov, Wil. M.P. van der Aalst", "title": "Inferring Unobserved Events in Systems With Shared Resources and Queues", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.AI cs.FL cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  To identify the causes of performance problems or to predict process\nbehavior, it is essential to have correct and complete event data. This is\nparticularly important for distributed systems with shared resources, e.g., one\ncase can block another case competing for the same machine, leading to\ninter-case dependencies in performance. However, due to a variety of reasons,\nreal-life systems often record only a subset of all events taking place. For\nexample, to reduce costs, the number of sensors is minimized or parts of the\nsystem are not connected. To understand and analyze the behavior of processes\nwith shared resources, we aim to reconstruct bounds for timestamps of events\nthat must have happened but were not recorded. We present a novel approach that\ndecomposes system runs into entity traces of cases and resources that may need\nto synchronize in the presence of many-to-many relationships. Such\nrelationships occur, for example, in warehouses where packages for N incoming\norders are not handled in a single delivery but in M different deliveries. We\nuse linear programming over entity traces to derive the timestamps of\nunobserved events in an efficient manner. This helps to complete the event logs\nand facilitates analysis. We focus on material handling systems like baggage\nhandling systems in airports to illustrate our approach. However, the approach\ncan be applied to other settings where recording is incomplete. The ideas have\nbeen implemented in ProM and were evaluated using both synthetic and real-life\nevent logs.\n", "versions": [{"version": "v1", "created": "Sat, 27 Feb 2021 09:34:01 GMT"}], "update_date": "2021-03-02", "authors_parsed": [["Fahland", "Dirk", ""], ["Denisov", "Vadim", ""], ["van der Aalst", "Wil. M. P.", ""]]}, {"id": "2103.00942", "submitter": "Magnus Steinby", "authors": "Magnus Steinby", "title": "Directing Words of Fuzzy Finite Automata", "comments": "arXiv admin note: text overlap with arXiv:1709.07719", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A deterministic finite automaton is directable if it has a directing word\nwhich takes the automaton from every state to the same state. These notions\nhave been extended also to other kinds of automata. Thus, B.~Imreh and\nM.~Steinby (1999) identified three natural types of directing words, called\nD1-, D2- and D3-directing words, for nondeterministic finite automata (NFAs).\nHere we adapt these notions for fuzzy finite automata (FFAs). The D3-directing\nwords obtained this way are precisely the directing words introduced by\nV.~Karthikeyan and M. Rajasekar (2015). With any FFA F we associate an NFA Fnd\nwhich has the same Di-directing words as F. Thus, if these definitions are\nused, the theory of directable FFAs reduces to that of NFAs.\n  We also introduce three new kinds of directing words of fuzzy automata that\nwe call DD1-, DD2- and DD3-directing words, respectively which depend more on\nthe fuzzy transition degrees between states. We establish some basic properties\nof the sets $DDi(F)$ of DDi-directing words of any given FFA F. In particular,\nit is shown that these languages are regular, and that DDi-directability is\ndecidable. For so-called normal FFAs the languages DDi(F) are shown to have\nsome special properties. Several relationships between the families of the\ncorresponding sets DDi(F) of DDi-directing words are presented. We also\ndetermine the complete meet-semilattice of the various classes of\nDDi-directable FFAs and normal FFAs and their intersections.\n", "versions": [{"version": "v1", "created": "Mon, 1 Mar 2021 12:11:27 GMT"}], "update_date": "2021-03-02", "authors_parsed": [["Steinby", "Magnus", ""]]}, {"id": "2103.01012", "submitter": "Dominique Perrin", "authors": "Marie-Pierre B\\'eal and Dominique Perrin and Antonio Restivo", "title": "Unambiguously coded systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.DS cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study the coded systems introduced by Blanchard and Hansel. We give\nseveral constructions which allow one to represent a coded system as a strongly\nunambiguous one.\n", "versions": [{"version": "v1", "created": "Mon, 1 Mar 2021 14:01:10 GMT"}, {"version": "v2", "created": "Sun, 4 Jul 2021 16:06:05 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["B\u00e9al", "Marie-Pierre", ""], ["Perrin", "Dominique", ""], ["Restivo", "Antonio", ""]]}, {"id": "2103.03908", "submitter": "Miroslav Stankovic", "authors": "Ezio Bartocci, Laura Kovacs, Miroslav Stankovic", "title": "MORA -- Automatic Generation of Moment-Based Invariants", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce MORA, an automated tool for generating invariants of\nprobabilistic programs. Inputs to MORA are so-called Prob-solvable loops, that\nis probabilistic programs with polynomial assignments over random variables and\nparametrized distributions. Combining methods from symbolic computation and\nstatistics, MORA computes invariant properties over higher-order moments of\nloop variables, expressing, for example, statistical properties, such as\nexpected values and variances, over the value distribution of loop variables.\n", "versions": [{"version": "v1", "created": "Fri, 5 Mar 2021 19:36:10 GMT"}], "update_date": "2021-03-09", "authors_parsed": [["Bartocci", "Ezio", ""], ["Kovacs", "Laura", ""], ["Stankovic", "Miroslav", ""]]}, {"id": "2103.04079", "submitter": "Alexander Okhotin", "authors": "Mizuhito Ogawa, Alexander Okhotin", "title": "On the determinization of event-clock input-driven pushdown automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Input-driven pushdown automata (also known as visibly pushdown automata and\nas nested word automata) are a subclass of deterministic pushdown automata and\na superclass of the parenthesis languages. Nguyen and Ogawa (\"Event-clock\nvisibly pushdown automata\", SOFSEM 2009) defined a timed extension of these\nautomata under the event-clock model, and showed that this model can be\ndeterminized using the method of region construction. This paper defines a\nfurther extension of this model with the event clock on the call-return\noperations, and proposes a new, direct determinization procedure for these\nautomata: an $n$-state nondeterministic automaton with $k$ different clock\nconstraints is transformed to a deterministic automaton with $2^{n^2}$ states,\n$2^{n^2+k}$ stack symbols and the same clock constraints as in the original\nautomaton. The construction is shown to be asymptotically optimal with respect\nto both the number of states and the number of stack symbols.\n", "versions": [{"version": "v1", "created": "Sat, 6 Mar 2021 09:17:07 GMT"}], "update_date": "2021-03-09", "authors_parsed": [["Ogawa", "Mizuhito", ""], ["Okhotin", "Alexander", ""]]}, {"id": "2103.04868", "submitter": "Davide Bresolin", "authors": "Davide Bresolin, Khaled El-Fakih, Tiziano Villa, Nina Yevtushenko", "title": "Equivalence Checking and Intersection of Deterministic Timed Finite\n  State Machines", "comments": "24 pages, 9 figures, 2 algorithms. arXiv admin note: text overlap\n  with arXiv:1408.5967", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  There has been a growing interest in defining models of automata enriched\nwith time, such as finite automata extended with clocks (timed automata). In\nthis paper, we study deterministic timed finite state machines (TFSMs), i.e.,\nfinite state machines with a single clock, timed guards and timeouts which\ntransduce timed input words into timed output words. We solve the problem of\nequivalence checking by defining a bisimulation from timed FSMs to untimed ones\nand viceversa. Moreover, we apply these bisimulation relations to build the\nintersection of two timed finite state machines by untiming them, intersecting\nthem and transforming back to the timed intersection.\n", "versions": [{"version": "v1", "created": "Mon, 8 Mar 2021 16:19:24 GMT"}], "update_date": "2021-03-09", "authors_parsed": [["Bresolin", "Davide", ""], ["El-Fakih", "Khaled", ""], ["Villa", "Tiziano", ""], ["Yevtushenko", "Nina", ""]]}, {"id": "2103.05485", "submitter": "Luca Prigioniero", "authors": "Bruno Guillon, Giovanni Pighizzini, Luca Prigioniero, Daniel\n  Pr\\r{u}\\v{s}a", "title": "Converting Nondeterministic Two-Way Automata into Small Deterministic\n  Linear-Time Machines", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In 1978 Sakoda and Sipser raised the question of the cost, in terms of size\nof representations, of the transformation of two-way and one-way\nnondeterministic automata into equivalent two-way deterministic automata.\nDespite all the attempts, the question has been answered only for particular\ncases (e.g., restrictions of the class of simulated automata or of the class of\nsimulating automata). However the problem remains open in the general case, the\nbest-known upper bound being exponential. We present a new approach in which\nunrestricted nondeterministic finite automata are simulated by deterministic\nmodels extending two-way deterministic finite automata, paying a polynomial\nincrease of size only. Indeed, we study the costs of the conversions of\nnondeterministic finite automata into some variants of one-tape deterministic\nTuring machines working in linear time, namely Hennie machines, weight-reducing\nTuring machines, and weight-reducing Hennie machines. All these variants are\nknown to share the same computational power: they characterize the class of\nregular languages.\n", "versions": [{"version": "v1", "created": "Tue, 9 Mar 2021 15:16:29 GMT"}, {"version": "v2", "created": "Wed, 10 Mar 2021 11:45:54 GMT"}], "update_date": "2021-03-11", "authors_parsed": [["Guillon", "Bruno", ""], ["Pighizzini", "Giovanni", ""], ["Prigioniero", "Luca", ""], ["Pr\u016f\u0161a", "Daniel", ""]]}, {"id": "2103.05486", "submitter": "Luca Prigioniero", "authors": "Bruno Guillon, Giovanni Pighizzini, Luca Prigioniero, Daniel\n  Pr\\r{u}\\v{s}a", "title": "Weight-Reducing Turing Machines", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is well-known that one-tape Turing machines working in linear time are no\nmore powerful than finite automata, namely they recognize exactly the class of\nregular languages. We prove that it is not decidable if a one-tape machine\nworks in linear time, even if it is deterministic and restricted to use only\nthe portion of the tape which initially contains the input. This motivates the\nintroduction of a constructive variant of one-tape machines, called\nweight-reducing machine, and the investigation of its properties. We focus on\nthe deterministic case. In particular, we show that, paying a polynomial size\nincrease only, each weight-reducing machine can be turned into a halting one\nthat works in linear time. Furthermore each weight-reducing machine can be\nconverted into equivalent nondeterministic and deterministic finite automata by\npaying exponential and doubly-exponential increase in size, respectively. These\ncosts cannot be reduced in general.\n", "versions": [{"version": "v1", "created": "Tue, 9 Mar 2021 15:17:51 GMT"}, {"version": "v2", "created": "Wed, 10 Mar 2021 11:42:29 GMT"}], "update_date": "2021-03-11", "authors_parsed": [["Guillon", "Bruno", ""], ["Pighizzini", "Giovanni", ""], ["Prigioniero", "Luca", ""], ["Pr\u016f\u0161a", "Daniel", ""]]}, {"id": "2103.05550", "submitter": "Sarah Winter", "authors": "Emmanuel Filiot and Christof L\\\"oding and Sarah Winter", "title": "Synthesis from Weighted Specifications with Partial Domains over Finite\n  Words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.GT cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper, we investigate the synthesis problem of terminating reactive\nsystems from quantitative specifications. Such systems are modeled as finite\ntransducers whose executions are represented as finite words in $(I\\times\nO)^*$, where $I,O$ are finite sets of input and output symbols, respectively. A\nweighted specification $S$ assigns a rational value (or $-\\infty$) to words in\n$(I\\times O)^*$, and we consider three kinds of objectives for synthesis,\nnamely threshold objectives where the system's executions are required to be\nabove some given threshold, best-value and approximate objectives where the\nsystem is required to perform as best as it can by providing output symbols\nthat yield the best value and $\\varepsilon$-best value respectively w.r.t. $S$.\nWe establish a landscape of decidability results for these three objectives and\nweighted specifications with partial domain over finite words given by\ndeterministic weighted automata equipped with sum, discounted-sum and average\nmeasures. The resulting objectives are not regular in general and we develop an\ninfinite game framework to solve the corresponding synthesis problems, namely\nthe class of (weighted) critical prefix games.\n", "versions": [{"version": "v1", "created": "Tue, 9 Mar 2021 16:57:12 GMT"}], "update_date": "2021-03-10", "authors_parsed": [["Filiot", "Emmanuel", ""], ["L\u00f6ding", "Christof", ""], ["Winter", "Sarah", ""]]}, {"id": "2103.05672", "submitter": "Marcell Vazquez-Chanlatte", "authors": "Marcell Vazquez-Chanlatte, Sebastian Junges, Daniel J. Fremont, Sanjit\n  Seshia", "title": "Entropy-Guided Control Improvisation", "comments": "RSS 21", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.RO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  High level declarative constraints provide a powerful (and popular) way to\ndefine and construct control policies; however, most synthesis algorithms do\nnot support specifying the degree of randomness (unpredictability) of the\nresulting controller. In many contexts, e.g., patrolling, testing, behavior\nprediction,and planning on idealized models, predictable or biased controllers\nare undesirable. To address these concerns, we introduce the \\emph{Entropic\nReactive Control Improvisation} (ERCI) framework and algorithm which supports\nsynthesizing control policies for stochastic games that are declaratively\nspecified by (i) a \\emph{hard constraint} specifying what must occur, (ii) a\n\\emph{soft constraint} specifying what typically occurs, and (iii) a\n\\emph{randomization constraint} specifying the unpredictability and variety of\nthe controller, as quantified using causal entropy. This framework, extends the\nstate of the art by supporting arbitrary combinations of adversarial and\nprobabilistic uncertainty in the environment. ERCI enables a flexible modeling\nformalism which we argue, theoretically and empirically, remains tractable.\n", "versions": [{"version": "v1", "created": "Tue, 9 Mar 2021 19:18:58 GMT"}, {"version": "v2", "created": "Mon, 28 Jun 2021 23:16:38 GMT"}], "update_date": "2021-06-30", "authors_parsed": [["Vazquez-Chanlatte", "Marcell", ""], ["Junges", "Sebastian", ""], ["Fremont", "Daniel J.", ""], ["Seshia", "Sanjit", ""]]}, {"id": "2103.05674", "submitter": "Sarah Winter", "authors": "Emmanuel Filiot and Sarah Winter", "title": "Continuous Uniformization of Rational Relations and Synthesis of\n  Computable Functions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A uniformizer of a binary relation is a function whose graph is contained in\nthe relation and which is defined on the same domain as the relation. It is\nknown that any rational relation of infinite words, i.e. a relation given as a\ntransducer, admits a rational uniformizer. Although rational, those\nuniformizers are not necessarily well-behaved, in the sense that the $i$th\nletter of the output word may depend on the whole infinite input word. In other\nwords, those uniformizers might not be continuous (for the Cantor topology).\nThis paper addresses the question of whether rational relations of infinite\nwords can be uniformized by continuous functions. On the negative side,\ncontinuous uniformizers might not exist in general and we prove that deciding\ntheir existence is algorithmically impossible. On the positive side, we exhibit\na large class of rational relations of infinite words, called weakly\ndeterministic rational relations, for which deciding whether a relation in this\nclass admits a continuous uniformizer is an ExpTime-c problem. This class\nincludes the known classes of deterministic rational relations and automatic\nrelations of infinite words.\n  As an application of the previous result, and by exploiting a connection\nbetween computability and continuity for rational functions of infinite words,\nwe show a result on the synthesis of computable functions from specifications\ngiven as weakly deterministic rational relations. In particular, we show that\ndeciding the existence of a computable uniformizer is ExpTime-c and if there is\none, it is possible to effectively synthesize a deterministic two-way\ntransducer computing it. This generalizes the classical setting of Church\nsynthesis to asynchronous implementations which can arbitrarily delay the\nproduction of their output signals.\n", "versions": [{"version": "v1", "created": "Tue, 9 Mar 2021 19:21:00 GMT"}], "update_date": "2021-03-11", "authors_parsed": [["Filiot", "Emmanuel", ""], ["Winter", "Sarah", ""]]}, {"id": "2103.06248", "submitter": "Predrag Filipovikj", "authors": "Predrag Filipovikj and Dilian Gurov and Mattias Nyberg", "title": "Bounded Invariant Checking for Stateflow Programs", "comments": "36 pages, 2 figures, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.SE", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Stateflow models are complex software models, often used as part of\nsafety-critical software solutions designed with Matlab Simulink. They\nincorporate design principles that are typically very hard to verify formally.\nIn particular, the standard exhaustive formal verification techniques are\nunlikely to scale well for the complex designs that are developed in industry.\nFurthermore, the Stateflow language lacks a formal semantics, which\nadditionally hinders the formal analysis.\n  To address these challenges, we lay here the foundations of a scalable\ntechnique for provably correct formal analysis of Stateflow models, with\nrespect to invariant properties, based on bounded model checking (BMC) over\nsymbolic executions. The crux of our technique is: i) a representation of the\nstate space of Stateflow models as a symbolic transition system (STS) over the\nsymbolic configurations of the model, as the basis for BMC, and ii) application\nof incremental BMC, to generate verification results after each unrolling of\nthe next-state relation of the transition system. To this end, we develop a\nsymbolic structural operational semantics (SSOS) for Stateflow, starting from\nan existing structural operational semantics (SOS), and show the preservation\nof invariant properties between the two. Next, we define bounded invariant\nchecking for STS over symbolic configurations as a satisfiability problem. We\ndevelop an automated procedure for generating the initial and next-state\npredicates of the STS, and propose an encoding scheme of the bounded invariant\nchecking problem as a set of constraints, ready for automated analysis with\nstandard, off-the-shelf satisfiability solvers. Finally, we present preliminary\nresults from an experimental comparison of our technique against the Simulink\nDesign Verifier, the proprietary built-in tool of the Simulink environment.\n", "versions": [{"version": "v1", "created": "Wed, 10 Mar 2021 18:28:28 GMT"}], "update_date": "2021-03-11", "authors_parsed": [["Filipovikj", "Predrag", ""], ["Gurov", "Dilian", ""], ["Nyberg", "Mattias", ""]]}, {"id": "2103.06714", "submitter": "Philipp Schlicht", "authors": "Ziyuan Gao, Sanjay Jain, Ji Qi, Philipp Schlicht, Frank Stephan and\n  Jacob Tarr", "title": "Ordered Semiautomatic Rings with Applications to Geometry", "comments": null, "journal-ref": "Extended version of the article in the Proceedings of the\n  International Conference on Language and Automata Theory and Applications\n  2020 Mar 4 (pp. 141-153). Springer, Cham", "doi": null, "report-no": null, "categories": "cs.FL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The present work looks at semiautomatic rings with automatic addition and\ncomparisons which are dense subrings of the real numbers and asks how these can\nbe used to represent geometric objects such that certain operations and\ntransformations are automatic. The underlying ring has always to be a countable\ndense subring of the real numbers and additions and comparisons and\nmultiplications with constants need to be automatic. It is shown that the ring\ncan be selected such that equilateral triangles can be represented and\nrotations by 30 degrees are possible, while the standard representation of the\nb-adic rationals does not allow this.\n", "versions": [{"version": "v1", "created": "Thu, 11 Mar 2021 14:59:35 GMT"}], "update_date": "2021-03-16", "authors_parsed": [["Gao", "Ziyuan", ""], ["Jain", "Sanjay", ""], ["Qi", "Ji", ""], ["Schlicht", "Philipp", ""], ["Stephan", "Frank", ""], ["Tarr", "Jacob", ""]]}, {"id": "2103.07557", "submitter": "Uli Fahrenberg", "authors": "Uli Fahrenberg, Christian Johansen, Georg Struth, Krzysztof\n  Ziemia\\'nski", "title": "Languages of Higher-Dimensional Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce languages of higher-dimensional automata (HDAs) and develop some\nof their properties. To this end, we define a new category of precubical sets,\nuniquely naturally isomorphic to the standard one, and introduce a notion of\nevent consistency. HDAs are then finite, labeled, event-consistent precubical\nsets with distinguished subsets of initial and accepting cells. Their languages\nare sets of interval orders closed under subsumption; as a major technical step\nwe expose a bijection between interval orders and a subclass of HDAs. We show\nthat any finite subsumption-closed set of interval orders is the language of an\nHDA, that languages of HDAs are closed under binary unions and parallel\ncomposition, and that bisimilarity implies language equivalence.\n", "versions": [{"version": "v1", "created": "Fri, 12 Mar 2021 22:30:05 GMT"}], "update_date": "2021-03-16", "authors_parsed": [["Fahrenberg", "Uli", ""], ["Johansen", "Christian", ""], ["Struth", "Georg", ""], ["Ziemia\u0144ski", "Krzysztof", ""]]}, {"id": "2103.08351", "submitter": "Jarkko Peltom\\\"aki", "authors": "Jarkko Peltom\\\"aki", "title": "Initial nonrepetitive complexity of regular episturmian words and their\n  Diophantine exponents", "comments": "50 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL math.NT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Regular episturmian words are episturmian words whose directive words have a\nregular and restricted form making them behave more like Sturmian words than\ngeneral episturmian words. We present a method to evaluate the initial\nnonrepetitive complexity of regular episturmian words extending the work of\nWojcik on Sturmian words. For this, we develop a theory of generalized\nOstrowski numeration systems and show how to associate with each episturmian\nword a unique sequence of numbers written in this numeration system.\n  The description of the initial nonrepetitive complexity allows us to obtain\nnovel results on the Diophantine exponents of regular episturmian words. We\nprove that the Diophantine exponent of a regular episturmian word is finite if\nand only if its directive word has bounded partial quotients. Moreover, we\nprove that the Diophantine exponent of a regular episturmian word is strictly\ngreater than $2$ if the sequence of partial quotients is eventually at least\n$3$.\n  Given an infinite word $x$ over an integer alphabet, we may consider a real\nnumber $\\xi_x$ having $x$ as a fractional part. The Diophantine exponent of $x$\nis a lower bound for the irrationality exponent of $\\xi_x$. Our results thus\nyield nontrivial lower bounds for the irrationality exponents of real numbers\nwhose fractional parts are regular episturmian words. As a consequence, we\nidentify a new uncountable class of transcendental numbers whose irrationality\nexponents are strictly greater than $2$. This class contains an uncountable\nsubclass of Liouville numbers.\n", "versions": [{"version": "v1", "created": "Mon, 15 Mar 2021 12:43:22 GMT"}, {"version": "v2", "created": "Tue, 30 Mar 2021 05:51:43 GMT"}], "update_date": "2021-03-31", "authors_parsed": [["Peltom\u00e4ki", "Jarkko", ""]]}, {"id": "2103.08436", "submitter": "Paolo Modesti", "authors": "Paolo Modesti, Siamak F. Shahandashti, Patrick McCorry, Feng Hao", "title": "Formal Modelling and Security Analysis of Bitcoin's Payment Protocol", "comments": "30 pages, 6 figures. This is an accepted manuscript to appear in\n  Computers & Security. Please cite as: Modesti, Shahandashti, McCorry, and\n  Hao. \"Formal Modelling and Security Analysis of Bitcoin's Payment Protocol\".\n  To appear in Computer & Security, Elsevier, 2021", "journal-ref": null, "doi": "10.1016/j.cose.2021.102279", "report-no": null, "categories": "cs.CR cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  The Payment Protocol standard BIP70, specifying how payments in Bitcoin are\nperformed by merchants and customers, is supported by the largest payment\nprocessors and most widely-used wallets. The protocol has been shown to be\nvulnerable to refund attacks due to lack of authentication of the refund\naddresses. In this paper, we give the first formal model of the protocol and\nformalise the refund address security goals for the protocol, namely refund\naddress authentication and secrecy. The formal model utilises communication\nchannels as abstractions conveying security goals on which the protocol\nmodeller and verifier can rely. We analyse the Payment Protocol confirming that\nit is vulnerable to an attack violating the refund address authentication\nsecurity goal. Moreover, we present a concrete protocol revision proposal\nsupporting the merchant with publicly verifiable evidence that can mitigate the\nattack. We verify that the revised protocol meets the security goals defined\nfor the refund address. Hence, we demonstrate that the revised protocol is\nsecure, not only against the existing attacks, but also against any further\nattacks violating the formalised security goals.\n", "versions": [{"version": "v1", "created": "Mon, 15 Mar 2021 15:05:01 GMT"}], "update_date": "2021-04-21", "authors_parsed": [["Modesti", "Paolo", ""], ["Shahandashti", "Siamak F.", ""], ["McCorry", "Patrick", ""], ["Hao", "Feng", ""]]}, {"id": "2103.09587", "submitter": "Stefan Hoffmann", "authors": "Stefan Hoffmann", "title": "Regularity Conditions for Iterated Shuffle on Commutative Regular\n  Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We identify a subclass of the regular commutative languages that is closed\nunder the iterated shuffle, or shuffle closure. In particular, it is\nregularity-preserving on this subclass. This subclass contains the commutative\ngroup languages and, for every alphabet $\\Sigma$, the class\n$\\textbf{Com}^+(\\Sigma^*)$ given by the ordered variety $\\textbf{Com}^+$. Then,\nwe state a simple characterization when the iterated shuffle on finite\ncommutative languages gives a regular language again and state partial results\nfor aperiodic commutative languages. We also show that the aperiodic, or\nstar-free, commutative languages and the commutative group languages are closed\nunder projection.\n", "versions": [{"version": "v1", "created": "Wed, 17 Mar 2021 12:08:01 GMT"}], "update_date": "2021-03-18", "authors_parsed": [["Hoffmann", "Stefan", ""]]}, {"id": "2103.10501", "submitter": "Andrew Wintenberg", "authors": "Andrew Wintenberg, Matthew Blischke, St\\'ephane Lafortune, Necmiye\n  Ozay", "title": "A General Language-Based Framework for Specifying and Verifying Notions\n  of Opacity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Opacity is an information flow property that captures the notion of plausible\ndeniability in dynamic systems, that is whether an intruder can deduce that\n\"secret\" behavior has occurred. In this paper we provide a general framework of\nopacity to unify the many existing notions of opacity that exist for discrete\nevent systems. We use this framework to discuss language-based and state-based\nnotions of opacity over automata. We present several methods for language-based\nopacity verification, and a general approach to transform state-based notions\ninto language-based ones. We demonstrate this approach for current-state and\ninitial-state opacity, unifying existing results. We then investigate the\nnotions of K-step opacity. We provide a language-based view of K-step opacity\nencompassing two existing notions and two new ones. We then analyze the\ncorresponding language-based verification methods both formally and with\nnumerical examples. In each case, the proposed methods offer significant\nreductions in runtime and space complexity.\n", "versions": [{"version": "v1", "created": "Thu, 18 Mar 2021 20:06:06 GMT"}], "update_date": "2021-03-22", "authors_parsed": [["Wintenberg", "Andrew", ""], ["Blischke", "Matthew", ""], ["Lafortune", "St\u00e9phane", ""], ["Ozay", "Necmiye", ""]]}, {"id": "2103.10546", "submitter": "Xiaofan Wang", "authors": "Xiaofan Wang and Xiaolan Zhang", "title": "Discovering an Algorithm Actually Learning Restricted Single Occurrence\n  Regular Expression with Interleaving", "comments": "6 papges", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A recent paper proposed an algorithm iSOIRE, which combines single-occurrence\nautomaton (SOA) and maximum independent set (MIS) to learn a subclass\nsingle-occurrence regular expressions with interleaving (SOIREs) and claims the\nlearnt expression is SOIRE, which has unrestricted usage for interleaving.\nHowever, in reality, the learnt expression still has many restrictions for\nusing interleaving, even does for Kleene-star or interation, i.e, the learnt\nexpression is not an SOIRE, we prove that by examples. In this paper, for the\nalgorithm iSOIRE, we first give the basic notions, then provide analyses about\nincorrectness, finally present the correct result learnt by iSOIRE. Our\ntheoretical analyses demonstrate that the result derived by iSOIRE belongs to a\nsubclass of SOIREs.\n", "versions": [{"version": "v1", "created": "Thu, 18 Mar 2021 22:18:47 GMT"}], "update_date": "2021-03-22", "authors_parsed": [["Wang", "Xiaofan", ""], ["Zhang", "Xiaolan", ""]]}, {"id": "2103.10881", "submitter": "Marie Farrell", "authors": "Marie Farrell, Rosemary Monahan, James F. Power", "title": "Building Specifications in the Event-B Institution", "comments": "54 pages, 25 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper describes a formal semantics for the Event-B specification\nlanguage using the theory of institutions. We define an institution for\nEvent-B, EVT, and prove that it meets the validity requirements for\nsatisfaction preservation and model amalgamation. We also present a series of\nfunctions that show how the constructs of the Event-B specification language\ncan be mapped into our institution. Our semantics sheds new light on the\nstructure of the Event-B language, allowing us to clearly delineate three\nconstituent sub-languages: the superstructure, infrastructure and mathematical\nlanguages. One of the principal goals of our semantics is to provide access to\nthe generic modularisation constructs available in institutions, including\nspecification-building operators for parameterisation and refinement. We\ndemonstrate how these features subsume and enhance the corresponding features\nalready present in Event-B through a detailed study of their use in a worked\nexample. We have implemented our approach via a parser and translator for\nEvent-B specifications, EBtoEVT, which also provides a gateway to the Hets\ntoolkit for heterogeneous specification.\n", "versions": [{"version": "v1", "created": "Fri, 19 Mar 2021 16:05:41 GMT"}], "update_date": "2021-03-22", "authors_parsed": [["Farrell", "Marie", ""], ["Monahan", "Rosemary", ""], ["Power", "James F.", ""]]}, {"id": "2103.10904", "submitter": "Jeffrey Shallit", "authors": "Jeffrey Shallit", "title": "Frobenius Numbers and Automatic Sequences", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NT cs.DM cs.FL math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Frobenius number $g(S)$ of a set $S$ of non-negative integers with $\\gcd\n1$ is the largest integer not expressible as a linear combination of elements\nof $S$. Given a sequence ${\\bf s} = (s_i)_{i \\geq 0}$, we can define the\nassociated sequence $G_{\\bf s} (i) = g(\\{ s_i,s_{i+1},\\ldots \\})$. In this\npaper we compute $G_{\\bf s} (i)$ for some classical automatic sequences: the\nevil numbers, the odious numbers, and the lower and upper Wythoff sequences. In\ncontrast with the usual methods, our proofs are based largely on automata\ntheory and logic.\n", "versions": [{"version": "v1", "created": "Fri, 19 Mar 2021 16:56:08 GMT"}, {"version": "v2", "created": "Mon, 22 Mar 2021 08:02:48 GMT"}], "update_date": "2021-03-23", "authors_parsed": [["Shallit", "Jeffrey", ""]]}, {"id": "2103.11174", "submitter": "Dmitry Golubenko", "authors": "Dmitry Golubenko", "title": "Nonterminal complexity of some families of infinite regular languages", "comments": "(to be revisited later)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Nonterminal complexity of a context-free language is the smallest possible\nnumber of nonterminals in its generating grammar. While in general case\nnonterminal complexity computation problem is unsolvable, it can be computed\nfor different families of regular languages. In this paper we study nonterminal\ncomplexity of some families of infinite regular languages.\n", "versions": [{"version": "v1", "created": "Sat, 20 Mar 2021 13:17:54 GMT"}], "update_date": "2021-03-23", "authors_parsed": [["Golubenko", "Dmitry", ""]]}, {"id": "2103.11197", "submitter": "Liyong Lin", "authors": "Liyong Lin, Ruochen Tai, Yuting Zhu, Rong Su", "title": "Observation-Assisted Heuristic Synthesis of Covert Attackers Against\n  Unknown Supervisors", "comments": "This paper is under review for the journal of Discrete Event Dynamic\n  Systems", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we address the problem of synthesis of covert attackers in the\nsetup where the model of the plant is available, but the model of the\nsupervisor is unknown, to the adversary. To compensate the lack of knowledge on\nthe supervisor, we assume that the adversary has recorded a (prefix-closed)\nfinite set of observations of the runs of the closed-loop system, which can be\nused for assisting the synthesis. We present a heuristic algorithm for the\nsynthesis of covert damage-reachable attackers, based on the model of the plant\nand the (finite) set of observations, by a transformation into solving an\ninstance of the partial-observation supervisor synthesis problem. The heuristic\nalgorithm developed in this paper may allow the adversary to synthesize covert\nattackers without having to know the model of the supervisor, which could be\nhard to obtain in practice. For simplicity, we shall only consider covert\nattackers that are able to carry out sensor replacement attacks and actuator\ndisablement attacks. The effectiveness of our approach is illustrated on a\nwater tank example adapted from the literature.\n", "versions": [{"version": "v1", "created": "Sat, 20 Mar 2021 15:43:52 GMT"}, {"version": "v2", "created": "Wed, 23 Jun 2021 08:35:10 GMT"}], "update_date": "2021-06-24", "authors_parsed": [["Lin", "Liyong", ""], ["Tai", "Ruochen", ""], ["Zhu", "Yuting", ""], ["Su", "Rong", ""]]}, {"id": "2103.12919", "submitter": "Josefine Graebener", "authors": "Josefine Graebener, Tung Phan-Minh, Jiaqi Yan, Qiming Zhao, Richard M.\n  Murray", "title": "Failure-Tolerant Contract-Based Design of an Automated Valet Parking\n  System using a Directive-Response Architecture", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.FL cs.SY", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Increased complexity in cyber-physical systems calls for modular system\ndesign methodologies that guarantee correct and reliable behavior, both in\nnormal operations and in the presence of failures. This paper aims to extend\nthe contract-based design approach using a directive-response architecture to\nenable reactivity to failure scenarios. The architecture is demonstrated on a\nmodular automated valet parking (AVP) system. The contracts for the different\ncomponents in the AVP system are explicitly defined, implemented, and validated\nagainst a Python implementation.\n", "versions": [{"version": "v1", "created": "Wed, 24 Mar 2021 01:32:17 GMT"}], "update_date": "2021-03-25", "authors_parsed": [["Graebener", "Josefine", ""], ["Phan-Minh", "Tung", ""], ["Yan", "Jiaqi", ""], ["Zhao", "Qiming", ""], ["Murray", "Richard M.", ""]]}, {"id": "2103.13166", "submitter": "Fernando Alves", "authors": "Fernando C. Alves", "title": "Language learnability in the limit for general metrics: a Gold-Angluin\n  result", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CL cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In his pioneering work in the field of Inductive Inference, Gold (1967)\nproved that a set containing all finite languages and at least one infinite\nlanguage over the same fixed alphabet is not learnable in the exact sense.\nWithin the same framework, Angluin (1980) provided a complete characterization\nfor the learnability of language families. Mathematically, the concept of exact\nlearning in that classical setting can be seen as the use of a particular type\nof metric for learning in the limit. In this short research note we use\nNiyogi's extended version of a theorem by Blum and Blum (1975) on the existence\nof locking data sets to prove a necessary condition for learnability in the\nlimit of any family of languages in any given metric. This recovers Gold's\ntheorem as a special case. Moreover, when the language family is further\nassumed to contain all finite languages, the same condition also becomes\nsufficient for learnability in the limit.\n", "versions": [{"version": "v1", "created": "Wed, 24 Mar 2021 13:11:09 GMT"}], "update_date": "2021-03-25", "authors_parsed": [["Alves", "Fernando C.", ""]]}, {"id": "2103.13175", "submitter": "Nelma Moreira", "authors": "Sabine Broda and Ant\\'onio Machiavelo and Nelma Moreira and Rog\\'erio\n  Reis", "title": "On the Uniform Distribution of Regular Expressions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Although regular expressions do not correspond univocally to regular\nlanguages, it is still worthwhile to study their properties and algorithms. For\nthe average case analysis one often relies on the uniform random generation\nusing a specific grammar for regular expressions, that can represent regular\nlanguages with more or less redundancy. Generators that are uniform on the set\nof expressions are not necessarily uniform on the set of regular languages.\nNevertheless, it is not straightforward that asymptotic estimates obtained by\nconsidering the whole set of regular expressions are different from those\nobtained using a more refined set that avoids some large class of equivalent\nexpressions. In this paper we study a set of expressions that avoid a given\nabsorbing pattern. It is shown that, although this set is significantly smaller\nthan the standard one, the asymptotic average estimates for the size of the\nGlushkov automaton for these expressions does not differ from the standard\ncase.\n", "versions": [{"version": "v1", "created": "Wed, 24 Mar 2021 13:24:42 GMT"}], "update_date": "2021-03-25", "authors_parsed": [["Broda", "Sabine", ""], ["Machiavelo", "Ant\u00f3nio", ""], ["Moreira", "Nelma", ""], ["Reis", "Rog\u00e9rio", ""]]}, {"id": "2103.13534", "submitter": "Mohit Tekriwal", "authors": "Mohit Tekriwal, Karthik Duraisamy, Jean-Baptiste Jeannin", "title": "A formal proof of the Lax equivalence theorem for finite difference\n  schemes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NA cs.FL cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The behavior of physical systems is typically modeled using differential\nequations which are too complex to solve analytically. In practical problems,\nthese equations are discretized on a computational domain, and numerical\nsolutions are computed. A numerical scheme is called convergent, if in the\nlimit of infinitesimal discretization, the bounds on the discretization error\nis also infinitesimally small. The approximate solution converges to the \"true\nsolution\" in this limit. The Lax equivalence theorem enables a proof of\nconvergence given consistency and stability of the method. In this work, we\nformally prove the Lax equivalence theorem using the Coq Proof Assistant. We\nassume a continuous linear differential operator between complete normed\nspaces, and define an equivalent mapping in the discretized space. Given that\nthe numerical method is consistent (i.e., the discretization error tends to\nzero as the discretization step tends to zero), and the method is stable (i.e.,\nthe error is uniformly bounded), we formally prove that the approximate\nsolution converges to the true solution. We then demonstrate convergence of the\ndifference scheme on an example problem by proving both its consistency and\nstability, and then applying the Lax equivalence theorem. In order to prove\nconsistency, we use the Taylor-Lagrange theorem by formally showing that the\ndiscretization error is bounded above by the nth power of the discretization\nstep, where n is the order of the truncated Taylor polynomial.\n", "versions": [{"version": "v1", "created": "Thu, 25 Mar 2021 00:11:05 GMT"}], "update_date": "2021-03-26", "authors_parsed": [["Tekriwal", "Mohit", ""], ["Duraisamy", "Karthik", ""], ["Jeannin", "Jean-Baptiste", ""]]}, {"id": "2103.14423", "submitter": "Karl-Heinz Zimmermann", "authors": "Merve Nur Cakir, Mehwish Saleemi, Karl-Heinz Zimmermann", "title": "On the Theory of Stochastic Automata", "comments": "50 pages, 11 figures, index included", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CL math.PR", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The theory of discrete stochastic systems has been initiated by the work of\nShannon and von Neumann. While Shannon has considered memory-less communication\nchannels and their generalization by introducing states, von Neumann has\nstudied the synthesis of reliable systems from unreliable components. The\nfundamental work of Rabin and Scott about deterministic finite-state automata\nhas led to two generalizations. First, the generalization of transition\nfunctions to conditional distributions studied by Carlyle and Starke. This in\nturn has led to a generalization of time-discrete Markov chains in which the\nchains are governed by more than one transition probability matrix. Second, the\ngeneralization of regular sets by introducing stochastic automata as described\nby Rabin. Stochastic automata are well-investigated. This report provides a\nshort introduction to stochastic automata based on the valuable book of Claus.\nThis includes the basic topics of the theory of stochastic automata:\nequivalence, minimization, reduction, covering, observability, and determinism.\nThen stochastic versions of Mealy and Moore automata are studied and finally\nstochastic language acceptors are considered as a generalization of\nnondeterministic finite-state acceptors.\n", "versions": [{"version": "v1", "created": "Fri, 26 Mar 2021 12:05:42 GMT"}], "update_date": "2021-03-29", "authors_parsed": [["Cakir", "Merve Nur", ""], ["Saleemi", "Mehwish", ""], ["Zimmermann", "Karl-Heinz", ""]]}, {"id": "2103.14489", "submitter": "Jie Fu", "authors": "Jie Fu", "title": "Probabilistic Planning with Preferences over Temporal Goals", "comments": "6 pages, 8 figures, Accepted by American Control Conference (ACC)\n  2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.FL cs.SY eess.SY", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We present a formal language for specifying qualitative preferences over\ntemporal goals and a preference-based planning method in stochastic systems.\nUsing automata-theoretic modeling, the proposed specification allows us to\nexpress preferences over different sets of outcomes, where each outcome\ndescribes a set of temporal sequences of subgoals. We define the value of\npreference satisfaction given a stochastic process over possible outcomes and\ndevelop an algorithm for time-constrained probabilistic planning in labeled\nMarkov decision processes where an agent aims to maximally satisfy its\npreference formula within a pre-defined finite time duration. We present\nexperimental results using a stochastic gridworld example and discuss possible\nextensions of the proposed preference model.\n", "versions": [{"version": "v1", "created": "Fri, 26 Mar 2021 14:26:40 GMT"}], "update_date": "2021-03-29", "authors_parsed": [["Fu", "Jie", ""]]}, {"id": "2103.14600", "submitter": "Alper Kamil Bozkurt", "authors": "Alper Kamil Bozkurt, Yu Wang, Miroslav Pajic", "title": "Model-Free Learning of Safe yet Effective Controllers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.RO cs.FL cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we study the problem of learning safe control policies that\nare also effective -- i.e., maximizing the probability of satisfying the linear\ntemporal logic (LTL) specification of the task, and the discounted reward\ncapturing the (classic) control performance. We consider unknown environments\nthat can be modeled as Markov decision processes (MDPs). We propose a\nmodel-free reinforcement learning algorithm that learns a policy that first\nmaximizes the probability of ensuring the safety, then the probability of\nsatisfying the given LTL specification and lastly, the sum of discounted\nQuality of Control (QoC) rewards. Finally, we illustrate the applicability of\nour RL-based approach on a case study.\n", "versions": [{"version": "v1", "created": "Fri, 26 Mar 2021 17:05:12 GMT"}], "update_date": "2021-03-29", "authors_parsed": [["Bozkurt", "Alper Kamil", ""], ["Wang", "Yu", ""], ["Pajic", "Miroslav", ""]]}, {"id": "2103.14831", "submitter": "Aman Goel", "authors": "Aman Goel, Karem A. Sakallah", "title": "On Symmetry and Quantification: A New Approach to Verify Distributed\n  Protocols", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-76384-8_9", "report-no": null, "categories": "cs.LO cs.DC cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Proving that an unbounded distributed protocol satisfies a given safety\nproperty amounts to finding a quantified inductive invariant that implies the\nproperty for all possible instance sizes of the protocol. Existing methods for\nsolving this problem can be described as search procedures for an invariant\nwhose quantification prefix fits a particular template. We propose an\nalternative constructive approach that does not prescribe, a priori, a specific\nquantifier prefix. Instead, the required prefix is automatically inferred\nwithout any search by carefully analyzing the structural symmetries of the\nprotocol. The key insight underlying this approach is that symmetry and\nquantification are closely related concepts that express protocol invariance\nunder different re-arrangements of its components. We propose symmetric\nincremental induction, an extension of the finite-domain IC3/PDR algorithm,\nthat automatically derives the required quantified inductive invariant by\nexploiting the connection between symmetry and quantification. While various\nattempts have been made to exploit symmetry in verification applications, to\nour knowledge, this is the first demonstration of a direct link between\nsymmetry and quantification in the context of clause learning during\nincremental induction. We also describe a procedure to automatically find a\nminimal finite size, the cutoff, that yields a quantified invariant proving\nsafety for any size.\n  Our approach is implemented in IC3PO, a new verifier for distributed\nprotocols that significantly outperforms the state-of-the-art, scales orders of\nmagnitude faster, and robustly derives compact inductive invariants fully\nautomatically.\n", "versions": [{"version": "v1", "created": "Sat, 27 Mar 2021 07:36:39 GMT"}], "update_date": "2021-05-20", "authors_parsed": [["Goel", "Aman", ""], ["Sakallah", "Karem A.", ""]]}, {"id": "2103.15223", "submitter": "Thomas Kahl", "authors": "Thomas Kahl", "title": "On symmetric higher-dimensional automata and bisimilarity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is shown that a higher-dimensional automaton is hhp-bisimilar to the free\nsymmetric HDA generated by it. Consequently, up to hereditary\nhistory-preserving bisimilarity, ordinary HDAs and symmetric HDAs are models of\nconcurrency with the same expressive power.\n", "versions": [{"version": "v1", "created": "Sun, 28 Mar 2021 21:20:07 GMT"}], "update_date": "2021-03-30", "authors_parsed": [["Kahl", "Thomas", ""]]}, {"id": "2103.15265", "submitter": "Eric Dolores Cuenca", "authors": "Eric Dolores-Cuenca, Jose Antonio Arciniega-Nevarez, Anh Nguyen,\n  Yitong Zou, Nathan Crock, Gordon Erlebacher, Jose L. Mendoza-Cortes", "title": "Polychrony as Chinampas", "comments": "32 pages. We refocus our study on nonlinear signal-flow graphs. We\n  add possible generalizations of our work", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.FL math.CT q-bio.NC", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study the flow of signals through paths with the following condition: a\nnode emits a signal if two incoming signals from other nodes arrive\ncoincidentally or if it receives an external stimuli. We apply our study to\ncount and describe families of polychrony groups on a line, and we introduce\ntriangular sequences.\n", "versions": [{"version": "v1", "created": "Mon, 29 Mar 2021 01:37:38 GMT"}, {"version": "v2", "created": "Wed, 7 Jul 2021 22:20:43 GMT"}], "update_date": "2021-07-09", "authors_parsed": [["Dolores-Cuenca", "Eric", ""], ["Arciniega-Nevarez", "Jose Antonio", ""], ["Nguyen", "Anh", ""], ["Zou", "Yitong", ""], ["Crock", "Nathan", ""], ["Erlebacher", "Gordon", ""], ["Mendoza-Cortes", "Jose L.", ""]]}, {"id": "2103.15651", "submitter": "Luc Dartois", "authors": "Olivier Carton and Luc Dartois", "title": "Aperiodic two-way transducers and FO-transductions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Deterministic two-way transducers on finite words have been shown by\nEngelfriet and Hoogeboom to have the same expressive power as\nMSO-transductions. We introduce a notion of aperiodicity for these transducers\nand we show that aperiodic transducers correspond exactly to FO-transductions.\nThis lifts to transducers the classical equivalence for languages between\nFO-definability, recognition by aperiodic monoids and acceptance by\ncounter-free automata.\n", "versions": [{"version": "v1", "created": "Mon, 29 Mar 2021 14:27:35 GMT"}], "update_date": "2021-03-30", "authors_parsed": [["Carton", "Olivier", ""], ["Dartois", "Luc", ""]]}, {"id": "2103.15659", "submitter": "Nathan Grosshans", "authors": "Nathan Grosshans", "title": "A Note on the Join of Varieties of Monoids with LI", "comments": "Version submitted for publication at the MFCS 2021 conference.\n  Compared to version 1, the introduction, the preliminaries and the conclusion\n  have been fully written, the proofs and the presentation have been improved\n  in section 4 and section 5 has been completed. Several mistakes have been\n  corrected in the whole paper. The results do not change though", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this note, we give a characterisation in terms of identities of the join\nof $\\mathbf{V}$ with the variety of finite locally trivial semigroups\n$\\mathbf{LI}$ for several well-known varieties of finite monoids $\\mathbf{V}$\nby using classical algebraic-automata-theoretic techniques. To achieve this, we\nuse the new notion of essentially-$\\mathbf{V}$ stamps defined by Grosshans,\nMcKenzie and Segoufin and show that it actually coincides with the join of\n$\\mathbf{V}$ and $\\mathbf{LI}$ precisely when some natural condition on the\nvariety of languages corresponding to $\\mathbf{V}$ is verified. This work is a\nkind of rediscovery of the work of J. C. Costa around 20 years ago from a\nrather different angle, since Costa's work relies on the use of advanced\ndevelopments in profinite topology, whereas what is presented here essentially\nuses an algebraic, language-based approach.\n", "versions": [{"version": "v1", "created": "Mon, 29 Mar 2021 14:35:03 GMT"}, {"version": "v2", "created": "Fri, 14 May 2021 10:06:33 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Grosshans", "Nathan", ""]]}, {"id": "2103.16185", "submitter": "Jakub Ruszil", "authors": "Jakub Ruszil", "title": "Approximation algorithm for finding short synchronizing words in\n  weighted automata", "comments": "9 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM cs.DS math.CO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper we are dealing with the issue of finding possibly short\nsynchronizing words in automata with weight assigned to each letter in the\nalphabet $\\Sigma$. First we discuss some complexity problems, and then we\npresent new approximation algorithm in four variations.\n", "versions": [{"version": "v1", "created": "Tue, 30 Mar 2021 09:07:57 GMT"}], "update_date": "2021-03-31", "authors_parsed": [["Ruszil", "Jakub", ""]]}, {"id": "2103.16966", "submitter": "Manon Stipulanti", "authors": "Michel Rigo and Manon Stipulanti", "title": "Revisiting regular sequences in light of rational base numeration\n  systems", "comments": "31 pages, 12 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Regular sequences generalize the extensively studied automatic sequences. Let\n$S$ be an abstract numeration system. When the numeration language $L$ is\nprefix-closed and regular, a sequence is said to be $S$-regular if the module\ngenerated by its $S$-kernel is finitely generated.\n  In this paper, we give a new characterization of such sequences in terms of\nthe underlying numeration tree $T(L)$ whose nodes are words of $L$. We may\ndecorate these nodes by the sequence of interest following a breadth-first\nenumeration. For a prefix-closed regular language $L$, we prove that a sequence\nis $S$-regular if and only if the tree $T(L)$ decorated by the sequence is\nlinear, i.e., the decoration of a node depends linearly on the decorations of a\nfixed number of ancestors.\n  Next, we introduce and study regular sequences in a rational base numeration\nsystem, whose numeration language is known to be highly non-regular. We\nmotivate and comment our definition that a sequence is $\\frac{p}{q}$-regular if\nthe underlying numeration tree decorated by the sequence is linear. We give the\nfirst few properties of such sequences, we provide a few examples of them, and\nwe propose a method for guessing $\\frac{p}{q}$-regularity. Then we discuss the\nrelationship between $\\frac{p}{q}$-automatic sequences and\n$\\frac{p}{q}$-regular sequences. We finally present a graph directed linear\nrepresentation of a $\\frac{p}{q}$-regular sequence. Our study permits us to\nhighlight the places where the regularity of the numeration language plays a\npredominant role.\n", "versions": [{"version": "v1", "created": "Wed, 31 Mar 2021 10:40:38 GMT"}], "update_date": "2021-04-01", "authors_parsed": [["Rigo", "Michel", ""], ["Stipulanti", "Manon", ""]]}]