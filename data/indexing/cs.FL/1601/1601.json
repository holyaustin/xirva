[{"id": "1601.00335", "submitter": "Hector Zenil", "authors": "Hector Zenil and J\\\"urgen Riedel", "title": "Asymptotic Intrinsic Universality and Reprogrammability by Behavioural\n  Emulation", "comments": "16 pages, 7 images. Invited contribution in Advances in\n  Unconventional Computation. A. Adamatzky (ed), Springer Verlag", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.FL nlin.CG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We advance a Bayesian concept of 'intrinsic asymptotic universality' taking\nto its final conclusions previous conceptual and numerical work based upon a\nconcept of a reprogrammability test and an investigation of the complex\nqualitative behaviour of computer programs. Our method may quantify the trust\nand confidence of the computing capabilities of natural and classical systems,\nand quantify computers by their degree of reprogrammability. We test the method\nto provide evidence in favour of a conjecture concerning the computing\ncapabilities of Busy Beaver Turing machines as candidates for Turing\nuniversality. The method has recently been used to quantify the number of\n'intrinsically universal' cellular automata, with results that point towards\nthe pervasiveness of universality due to a widespread capacity for emulation.\nOur method represents an unconventional approach to the classical and seminal\nconcept of Turing universality, and it may be extended and applied in a broader\ncontext to natural computation, by (in something like the spirit of the Turing\ntest) observing the behaviour of a system under circumstances where formal\nproofs of universality are difficult, if not impossible to come by.\n", "versions": [{"version": "v1", "created": "Sun, 3 Jan 2016 20:11:06 GMT"}, {"version": "v2", "created": "Sat, 9 Jan 2016 14:24:25 GMT"}, {"version": "v3", "created": "Wed, 13 Jan 2016 17:44:14 GMT"}], "update_date": "2016-01-14", "authors_parsed": [["Zenil", "Hector", ""], ["Riedel", "J\u00fcrgen", ""]]}, {"id": "1601.01168", "submitter": "Alan Cain", "authors": "Tara Brough and Alan J. Cain", "title": "Automaton semigroups: new construction results and examples of\n  non-automaton semigroups", "comments": "27 pages, 6 figures; substantially revised", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies the class of automaton semigroups from two perspectives:\nclosure under constructions, and examples of semigroups that are not automaton\nsemigroups. We prove that (semigroup) free products of finite semigroups always\narise as automaton semigroups, and that the class of automaton monoids is\nclosed under forming wreath products with finite monoids. We also consider\nclosure under certain kinds of Rees matrix constructions, strong semilattices,\nand small extensions. Finally, we prove that no subsemigroup of $(\\mathbb{N},\n+)$ arises as an automaton semigroup. (Previously, $(\\mathbb{N},+)$ itself was\nthe unique example of a finitely generated residually finite semigroup that was\nknown not to arise as an automaton semigroup.)\n", "versions": [{"version": "v1", "created": "Wed, 6 Jan 2016 13:09:02 GMT"}, {"version": "v2", "created": "Sun, 15 Jan 2017 19:45:04 GMT"}], "update_date": "2017-01-17", "authors_parsed": [["Brough", "Tara", ""], ["Cain", "Alan J.", ""]]}, {"id": "1601.01579", "submitter": "J\\\"urgen Koslowski", "authors": "Florent Jacquemard, Luc Segoufin, Jer\\'emie Dimino", "title": "FO2(<,+1,~) on data trees, data tree automata and branching vector\n  addition systems", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 2 (April 26,\n  2016) lmcs:1635", "doi": "10.2168/LMCS-12(2:3)2016", "report-no": null, "categories": "cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A data tree is an unranked ordered tree where each node carries a label from\na finite alphabet and a datum from some infinite domain. We consider the two\nvariable first order logic FO2(<,+1,~) over data trees. Here +1 refers to the\nchild and the next sibling relations while < refers to the descendant and\nfollowing sibling relations. Moreover, ~ is a binary predicate testing data\nequality. We exhibit an automata model, denoted DAD# that is more expressive\nthan FO2(<,+1,~) but such that emptiness of DAD# and satisfiability of\nFO2(<,+1,~) are inter-reducible. This is proved via a model of counter tree\nautomata, denoted EBVASS, that extends Branching Vector Addition Systems with\nStates (BVASS) with extra features for merging counters. We show that, as\ndecision problems, reachability for EBVASS, satisfiability of FO2(<,+1,~) and\nemptiness of DAD# are equivalent.\n", "versions": [{"version": "v1", "created": "Thu, 7 Jan 2016 16:01:31 GMT"}, {"version": "v2", "created": "Sat, 23 Apr 2016 23:16:22 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Jacquemard", "Florent", ""], ["Segoufin", "Luc", ""], ["Dimino", "Jer\u00e9mie", ""]]}, {"id": "1601.01660", "submitter": "Daniel Neider", "authors": "Daniel Neider, Ufuk Topcu", "title": "An Automaton Learning Approach to Solving Safety Games over Infinite\n  Graphs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a method to construct finite-state reactive controllers for\nsystems whose interactions with their adversarial environment are modeled by\ninfinite-duration two-player games over (possibly) infinite graphs. The\nproposed method targets safety games with infinitely many states or with such a\nlarge number of states that it would be impractical---if not impossible---for\nconventional synthesis techniques that work on the entire state space. We\nresort to constructing finite-state controllers for such systems through an\nautomata learning approach, utilizing a symbolic representation of the\nunderlying game that is based on finite automata. Throughout the learning\nprocess, the learner maintains an approximation of the winning region\n(represented as a finite automaton) and refines it using different types of\ncounterexamples provided by the teacher until a satisfactory controller can be\nderived (if one exists). We present a symbolic representation of safety games\n(inspired by regular model checking), propose implementations of the learner\nand teacher, and evaluate their performance on examples motivated by robotic\nmotion planning in dynamic environments.\n", "versions": [{"version": "v1", "created": "Thu, 7 Jan 2016 20:42:19 GMT"}], "update_date": "2016-01-08", "authors_parsed": [["Neider", "Daniel", ""], ["Topcu", "Ufuk", ""]]}, {"id": "1601.02014", "submitter": "Carlos Martin", "authors": "Carlos Martin", "title": "Predicting the large-scale evolution of tag systems", "comments": null, "journal-ref": null, "doi": "10.25088/ComplexSystems.25.2.79", "report-no": null, "categories": "cs.FL cs.DM math.CO math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a method for predicting the large-scale evolution of a tag system\nfrom its production rules. A tag system's evolution is first divided into\nstages called `epochs' in which the tag system evolves monotonously. The\ndistribution of symbols in the queue at the beginning of each epoch determines\nthe tag system's large-scale properties, including growth rate and string\ndensities, during that epoch. We derive the symbol distribution for the next\nepoch from the distribution for the current one, using this to make predictions\nover multiple successive epochs. Finally, we compare predictions that were\nobtained with this method to computer simulations and find that it retains\ngreat accuracy over several epochs.\n", "versions": [{"version": "v1", "created": "Sun, 10 Jan 2016 22:04:42 GMT"}, {"version": "v2", "created": "Wed, 30 Mar 2016 07:58:34 GMT"}], "update_date": "2018-02-06", "authors_parsed": [["Martin", "Carlos", ""]]}, {"id": "1601.02453", "submitter": "Robert Merca\\c{s}", "authors": "Robert Merca\\c{s} and Dirk Nowotka", "title": "A note on Thue games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work we improve on a result from~\\cite{GryKosZma15}. In particular,\nwe investigate the situation where a word is constructed jointly by two players\nwho alternately append letters to the end of an existing word. One of the\nplayers (Ann) tries to avoid (non-trivial) repetitions, while the other one\n(Ben) tries to enforce them. We show a construction that is closer to the lower\nbound showed in~\\cite{GryKozMic13} using entropy compression, and building on\nthe probabilistic arguments based on a version of the Lov\\'asz Local Lemma\nfrom~\\cite{Peg11}. We provide an explicit strategy for Ann to avoid\n(non-trivial) repetitions over a $7$-letter alphabet.\n", "versions": [{"version": "v1", "created": "Mon, 11 Jan 2016 14:14:23 GMT"}], "update_date": "2016-01-12", "authors_parsed": [["Merca\u015f", "Robert", ""], ["Nowotka", "Dirk", ""]]}, {"id": "1601.04661", "submitter": "Christoph Haase", "authors": "Christoph Haase and Stefan Kiefer and Markus Lohrey", "title": "Efficient Quantile Computation in Markov Chains via Counting Problems\n  for Parikh Images", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.CC cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A cost Markov chain is a Markov chain whose transitions are labelled with\nnon-negative integer costs. A fundamental problem on this model, with\napplications in the verification of stochastic systems, is to compute\ninformation about the distribution of the total cost accumulated in a run. This\nincludes the probability of large total costs, the median cost, and other\nquantiles. While expectations can be computed in polynomial time, previous work\nhas demonstrated that the computation of cost quantiles is harder but can be\ndone in PSPACE. In this paper we show that cost quantiles in cost Markov chains\ncan be computed in the counting hierarchy, thus providing evidence that\ncomputing those quantiles is likely not PSPACE-hard. We obtain this result by\nexhibiting a tight link to a problem in formal language theory: counting the\nnumber of words that are both accepted by a given automaton and have a given\nParikh image. Motivated by this link, we comprehensively investigate the\ncomplexity of the latter problem. Among other techniques, we rely on the\nso-called BEST theorem for efficiently computing the number of Eulerian\ncircuits in a directed graph.\n", "versions": [{"version": "v1", "created": "Mon, 18 Jan 2016 19:31:03 GMT"}], "update_date": "2016-01-19", "authors_parsed": [["Haase", "Christoph", ""], ["Kiefer", "Stefan", ""], ["Lohrey", "Markus", ""]]}, {"id": "1601.05176", "submitter": "Hugo Gimbert", "authors": "Hugo Gimbert (LaBRI)", "title": "On the Control of Asynchronous Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The decidability of the distributed version of the Ramadge and Wonham\ncontroller synthesis problem,where both the plant and the controllers are\nmodeled as asynchronous automataand the controllers have causal memoryis a\nchallenging open problem.There exist three classes of plants for which the\nexistence of a correct controller with causal memory has been shown decidable:\nwhen the dependency graph of actions is series-parallel, when the processes are\nconnectedly communicating and when the dependency graph of processes is a tree.\nWe design a class of plants, called decomposable games, with a decidable\ncontroller synthesis problem.This provides a unified proof of the three\nexisting decidability results as well as new examples of decidable plants.\n", "versions": [{"version": "v1", "created": "Wed, 20 Jan 2016 05:52:21 GMT"}, {"version": "v10", "created": "Fri, 28 Jul 2017 14:36:47 GMT"}, {"version": "v11", "created": "Tue, 1 Aug 2017 12:47:55 GMT"}, {"version": "v12", "created": "Fri, 4 Aug 2017 06:34:52 GMT"}, {"version": "v2", "created": "Tue, 26 Jan 2016 08:47:06 GMT"}, {"version": "v3", "created": "Fri, 29 Jan 2016 13:57:19 GMT"}, {"version": "v4", "created": "Tue, 2 Feb 2016 10:04:26 GMT"}, {"version": "v5", "created": "Mon, 24 Oct 2016 11:24:02 GMT"}, {"version": "v6", "created": "Tue, 25 Oct 2016 07:29:44 GMT"}, {"version": "v7", "created": "Tue, 13 Dec 2016 13:21:55 GMT"}, {"version": "v8", "created": "Wed, 1 Feb 2017 10:12:54 GMT"}, {"version": "v9", "created": "Mon, 24 Apr 2017 08:37:07 GMT"}], "update_date": "2017-08-07", "authors_parsed": [["Gimbert", "Hugo", "", "LaBRI"]]}, {"id": "1601.06101", "submitter": "David Elkouss Coronas", "authors": "David Elkouss and David P\\'erez-Garc\\'ia", "title": "Memory effects can make the transmission capability of a communication\n  channel uncomputable", "comments": "Improved presentation and clarified claims", "journal-ref": "Nature Communications vol 9 no 1149 (2018)", "doi": "10.1038/s41467-018-03428-0", "report-no": null, "categories": "cs.IT cs.CC cs.FL math.IT quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most communication channels are subjected to noise. One of the goals of\nInformation Theory is to add redundancy in the transmission of information so\nthat the information is transmitted reliably and the amount of information\ntransmitted through the channel is as large as possible. The maximum rate at\nwhich reliable transmission is possible is called the capacity. If the channel\ndoes not keep memory of its past, the capacity is given by a simple\noptimization problem and can be efficiently computed. The situation of channels\nwith memory is less clear. Here we show that for channels with memory the\ncapacity cannot be computed to within precision 1/5. Our result holds even if\nwe consider one of the simplest families of such channels -information-stable\nfinite state machine channels-, restrict the input and output of the channel to\n4 and 1 bit respectively and allow 6 bits of memory.\n", "versions": [{"version": "v1", "created": "Fri, 22 Jan 2016 19:05:23 GMT"}, {"version": "v2", "created": "Thu, 19 May 2016 12:52:59 GMT"}, {"version": "v3", "created": "Tue, 20 Mar 2018 11:40:50 GMT"}], "update_date": "2018-03-21", "authors_parsed": [["Elkouss", "David", ""], ["P\u00e9rez-Garc\u00eda", "David", ""]]}, {"id": "1601.06456", "submitter": "Torsten M\\\"utze", "authors": "Herman Z.Q. Chen, Sergey Kitaev, Torsten M\\\"utze and Brian Y. Sun", "title": "On universal partial words", "comments": null, "journal-ref": "Discrete Mathematics & Theoretical Computer Science, Vol. 19 no.\n  1, Combinatorics (May 31, 2017) dmtcs:3690", "doi": "10.23638/DMTCS-19-1-16", "report-no": null, "categories": "math.CO cs.FL cs.IT math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A universal word for a finite alphabet $A$ and some integer $n\\geq 1$ is a\nword over $A$ such that every word in $A^n$ appears exactly once as a subword\n(cyclically or linearly). It is well-known and easy to prove that universal\nwords exist for any $A$ and $n$. In this work we initiate the systematic study\nof universal partial words. These are words that in addition to the letters\nfrom $A$ may contain an arbitrary number of occurrences of a special `joker'\nsymbol $\\Diamond\\notin A$, which can be substituted by any symbol from $A$. For\nexample, $u=0\\Diamond 011100$ is a linear partial word for the binary alphabet\n$A=\\{0,1\\}$ and for $n=3$ (e.g., the first three letters of $u$ yield the\nsubwords $000$ and $010$). We present results on the existence and\nnon-existence of linear and cyclic universal partial words in different\nsituations (depending on the number of $\\Diamond$s and their positions),\nincluding various explicit constructions. We also provide numerous examples of\nuniversal partial words that we found with the help of a computer.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jan 2016 00:40:26 GMT"}, {"version": "v2", "created": "Wed, 9 Nov 2016 11:57:07 GMT"}, {"version": "v3", "created": "Mon, 8 May 2017 10:28:39 GMT"}, {"version": "v4", "created": "Tue, 30 May 2017 02:10:08 GMT"}, {"version": "v5", "created": "Thu, 1 Jun 2017 06:28:20 GMT"}], "update_date": "2018-02-16", "authors_parsed": [["Chen", "Herman Z. Q.", ""], ["Kitaev", "Sergey", ""], ["M\u00fctze", "Torsten", ""], ["Sun", "Brian Y.", ""]]}, {"id": "1601.06945", "submitter": "Igor Buzhinsky", "authors": "Vladimir Ulyantsev, Igor Buzhinsky, Anatoly Shalyto", "title": "Exact Finite-State Machine Identification from Scenarios and Temporal\n  Properties", "comments": "21 pages, 9 figures, 7 tables, accepted to International Journal on\n  Software Tools for Technology Transfer. Major changes: the description and\n  results of the Iterative method were updated, the last sections were\n  restructured, new figures were added", "journal-ref": null, "doi": "10.1007/s10009-016-0442-1", "report-no": null, "categories": "cs.SE cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Finite-state models, such as finite-state machines (FSMs), aid software\nengineering in many ways. They are often used in formal verification and also\ncan serve as visual software models. The latter application is associated with\nthe problems of software synthesis and automatic derivation of software models\nfrom specification. Smaller synthesized models are more general and are easier\nto comprehend, yet the problem of minimum FSM identification has received\nlittle attention in previous research.\n  This paper presents four exact methods to tackle the problem of minimum FSM\nidentification from a set of test scenarios and a temporal specification\nrepresented in linear temporal logic. The methods are implemented as an\nopen-source tool. Three of them are based on translations of the FSM\nidentification problem to SAT or QSAT problem instances. Accounting for\ntemporal properties is done via counterexample prohibition. Counterexamples are\neither obtained from previously identified FSMs, or based on bounded model\nchecking. The fourth method uses backtracking. The proposed methods are\nevaluated on several case studies and on a larger number of randomly generated\ninstances of increasing complexity. The results show that the Iterative\nSAT-based method is the leader among the proposed methods. The methods are also\ncompared with existing inexact approaches, i.e. the ones which do not\nnecessarily identify the minimum FSM, and these comparisons show encouraging\nresults.\n", "versions": [{"version": "v1", "created": "Tue, 26 Jan 2016 09:34:15 GMT"}, {"version": "v2", "created": "Sat, 19 Nov 2016 18:34:32 GMT"}], "update_date": "2016-11-22", "authors_parsed": [["Ulyantsev", "Vladimir", ""], ["Buzhinsky", "Igor", ""], ["Shalyto", "Anatoly", ""]]}, {"id": "1601.08237", "submitter": "Jorge Almeida", "authors": "J. Almeida, O. Kl\\'ima, M. Kunc", "title": "The omega-inequality problem for concatenation hierarchies of star-free\n  languages", "comments": null, "journal-ref": "Forum Math. 30 (2018), no. 3, 663-679", "doi": "10.1515/forum-2016-0028", "report-no": null, "categories": "math.GR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem considered in this paper is whether an inequality of omega-terms\nis valid in a given level of a concatenation hierarchy of star-free languages.\nThe main result shows that this problem is decidable for all (integer and half)\nlevels of the Straubing-Th\\'erien hierarchy.\n", "versions": [{"version": "v1", "created": "Fri, 29 Jan 2016 20:17:07 GMT"}, {"version": "v2", "created": "Tue, 23 May 2017 12:44:01 GMT"}], "update_date": "2019-03-18", "authors_parsed": [["Almeida", "J.", ""], ["Kl\u00edma", "O.", ""], ["Kunc", "M.", ""]]}]