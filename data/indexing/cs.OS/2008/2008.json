[{"id": "2008.02145", "submitter": "Alexander Harri Bell-Thomas", "authors": "A. H. Bell-Thomas", "title": "Interprocess Communication in FreeBSD 11: Performance Analysis", "comments": "10 pages, 7 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Interprocess communication, IPC, is one of the most fundamental functions of\na modern operating system, playing an essential role in the fabric of\ncontemporary applications. This report conducts an investigation in FreeBSD of\nthe real world performance considerations behind two of the most common IPC\nmechanisms; pipes and sockets. A simple benchmark provides a fair sense of\neffective bandwidth for each, and analysis using DTrace, hardware performance\ncounters and the operating system's source code is presented. We note that\npipes outperform sockets by 63% on average across all configurations, and\nfurther that the size of userspace transmission buffers has a profound effect\non performance - larger buffers are beneficial up to a point (~32-64 KiB) after\nwhich performance collapses as a result of devastating cache exhaustion. A deep\nscrutiny of the probe effects at play is also presented, justifying the\nvalidity of conclusions drawn from these experiments.\n", "versions": [{"version": "v1", "created": "Wed, 5 Aug 2020 14:07:24 GMT"}], "update_date": "2020-08-06", "authors_parsed": [["Bell-Thomas", "A. H.", ""]]}, {"id": "2008.03563", "submitter": "Karunakaran Murali Krishnan", "authors": "K. Murali Krishnan", "title": "eXpOS: A Simple Pedagogical Operating System for Undergraduate\n  Instruction", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An operating system project suitable for undergraduate computing/electrical\nsciences students is presented. The project can be used as a course project in\na one semester course, or as a self-study project for motivated students. The\ncourse is organized such that a student with a basic background in programming\nand computer organization can follow the implementation road map available\nonline, and build the OS from scratch on her personal machine/laptop, with\nminimal instructional supervision. The student is provided with a simulated\nabstract machine, an application interface specification, specification and\ndesign of the OS, and a step by step project implementation road map. The\nfunctionalities of the OS include multitasking, virtual memory, semaphores,\nshared memory, an elementary file system, interrupt driven disk and console\nI/O, and a limited multi-user support. The final stage of the project involves\nporting the OS to a two-core machine. An independent one semester compiler\ndesign project, where the student builds a compiler for a tiny object oriented\nprogramming language that generates target code that can be loaded and executed\nby the OS is also briefly discussed.\n", "versions": [{"version": "v1", "created": "Sat, 8 Aug 2020 17:41:15 GMT"}], "update_date": "2020-08-11", "authors_parsed": [["Krishnan", "K. Murali", ""]]}, {"id": "2008.06152", "submitter": "Kazuichi Oe", "authors": "Kazuichi Oe", "title": "Consideration for effectively handling parallel workloads on public\n  cloud system", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.DS cs.OS cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We retrieved and analyzed parallel storage workloads of the FUJITSU K5 cloud\nservice to clarify how to build cost-effective hybrid storage systems. A hybrid\nstorage system consists of fast but low-capacity tier (first tier) and slow but\nhigh-capacity tier (second tier). And, it typically consists of either SSDs and\nHDDs or NVMs and SSDs. As a result, we found that 1) regions for first tier\nshould be assigned only if a workload includes large number of IO accesses for\na whole day, 2) the regions that include a large number of IO accesses should\nbe dynamically chosen and moved from second tier to first tier for a short\ninterval, and 3) if a cache hit ratio is regularly low, use of the cache for\nthe workload should be cancelled, and the whole workload region should be\nassigned to the region for first tier. These workloads already have been\nreleased from the SNIA web site.\n", "versions": [{"version": "v1", "created": "Fri, 14 Aug 2020 01:18:04 GMT"}], "update_date": "2020-08-17", "authors_parsed": [["Oe", "Kazuichi", ""]]}, {"id": "2008.06536", "submitter": "Adriana Szekeres", "authors": "Adriana Szekeres, Irene Zhang, Katelin Bailey, Isaac Ackerman, Haichen\n  Shen, Franziska Roesner, Dan R. K. Ports, Arvind Krishnamurthy, and Henry M.\n  Levy", "title": "Making Distributed Mobile Applications SAFE: Enforcing User Privacy\n  Policies on Untrusted Applications with Secure Application Flow Enforcement", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Today's mobile devices sense, collect, and store huge amounts of personal\ninformation, which users share with family and friends through a wide range of\napplications. Once users give applications access to their data, they must\nimplicitly trust that the apps correctly maintain data privacy. As we know from\nboth experience and all-too-frequent press articles, that trust is often\nmisplaced. While users do not trust applications, they do trust their mobile\ndevices and operating systems. Unfortunately, sharing applications are not\nlimited to mobile clients but must also run on cloud services to share data\nbetween users. In this paper, we leverage the trust that users have in their\nmobile OSes to vet cloud services. To do so, we define a new Secure Application\nFlow Enforcement (SAFE) framework, which requires cloud services to attest to a\nsystem stack that will enforce policies provided by the mobile OS for user\ndata. We implement a mobile OS that enforces SAFE policies on unmodified mobile\napps and two systems for enforcing policies on untrusted cloud services. Using\nthese prototypes, we demonstrate that it is possible to enforce existing user\nprivacy policies on unmodified applications.\n", "versions": [{"version": "v1", "created": "Fri, 14 Aug 2020 18:35:38 GMT"}], "update_date": "2020-08-18", "authors_parsed": [["Szekeres", "Adriana", ""], ["Zhang", "Irene", ""], ["Bailey", "Katelin", ""], ["Ackerman", "Isaac", ""], ["Shen", "Haichen", ""], ["Roesner", "Franziska", ""], ["Ports", "Dan R. K.", ""], ["Krishnamurthy", "Arvind", ""], ["Levy", "Henry M.", ""]]}, {"id": "2008.11868", "submitter": "Landon Cox", "authors": "HyunJong Lee, Shadi Noghabi, Brian Noble, Matthew Furlong, and Landon\n  P. Cox", "title": "BumbleBee: Application-aware adaptation for container orchestration", "comments": "This version fixes problems (e.g., with the video-streaming\n  experiments) from the previous versions", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modern applications have embraced separation of concerns as a first-order\norganizing principle through the use of containers, container orchestration,\nand service meshes. However, adaptation to unexpected network variation has not\nfollowed suit. We present BumbleBee, a lightweight extension to the container\necosystem that supports application-aware adaptation. BumbleBee provides a\nsimple abstraction for making decisions about network data using application\nsemantics. Because this abstraction is placed within the communications\nframework of a modern service mesh, it is closer to the point at which changes\nare detected, providing more responsive and effective adaptation than possible\nat endpoints.\n", "versions": [{"version": "v1", "created": "Thu, 27 Aug 2020 00:20:00 GMT"}, {"version": "v2", "created": "Wed, 16 Sep 2020 18:18:42 GMT"}, {"version": "v3", "created": "Sun, 9 May 2021 19:21:04 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Lee", "HyunJong", ""], ["Noghabi", "Shadi", ""], ["Noble", "Brian", ""], ["Furlong", "Matthew", ""], ["Cox", "Landon P.", ""]]}, {"id": "2008.12501", "submitter": "Kazuichi Oe", "authors": "Kazuichi Oe", "title": "Analysis of Interference between RDMA and Local Access on Hybrid Memory\n  System", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PF cs.AR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We can use a hybrid memory system consisting of DRAM and Intel Optane DC\nPersistent Memory (We call it DCPM in this paper) as DCPM is now commercially\navailable since April 2019. Even if the latency for DCPM is several times\nhigher than that for DRAM, the capacity for DCPM is several times higher than\nthat for DRAM and the cost of DCPM is also several times lower than that for\nDRAM. In addition, DCPM is non-volatile. A Server with this hybrid memory\nsystem could improve the performance for in-memory database systems and virtual\nmachine (VM) systems because these systems often consume a large amount of\nmemory. Moreover, a high-speed shared storage system can be implemented by\naccessing DCPM via remote direct memory access (RDMA). I assume that some of\nthe DCPM is often assigned as a shared area among other remote servers because\napplications executed on a server with a hybrid memory system often cannot use\nthe entire capacity of DCPM. This paper evaluates the interference between\nlocal memory access and RDMA from a remote server. As a result, I indicate that\nthe interference on this hybrid memory system is significantly different from\nthat on a conventional DRAM-only memory system. I also believe that some kind\nof throttling implementation is needed when this interference occures.\n", "versions": [{"version": "v1", "created": "Fri, 28 Aug 2020 06:52:41 GMT"}], "update_date": "2020-08-31", "authors_parsed": [["Oe", "Kazuichi", ""]]}]