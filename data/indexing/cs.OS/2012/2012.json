[{"id": "2012.07917", "submitter": "Dan Wallach", "authors": "Daniel W. Song, Konstantinos Mamouras, Ang Chen, Nathan Dautenhahn,\n  and Dan S. Wallach", "title": "The Design and Implementation of a Verified File System with End-to-End\n  Data Integrity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Despite significant research and engineering efforts, many of today's\nimportant computer systems suffer from bugs. To increase the reliability of\nsoftware systems, recent work has applied formal verification to certify the\ncorrectness of such systems, with recent successes including certified file\nsystems and certified cryptographic protocols, albeit using quite different\nproof tactics and toolchains. Unifying these concepts, we present the first\ncertified file system that uses cryptographic primitives to protect itself\nagainst tampering. Our certified file system defends against adversaries that\nmight wish to tamper with the raw disk. Such an \"untrusted storage\" threat\nmodel captures the behavior of storage devices that might silently return\nerroneous bits as well as adversaries who might have limited access to a disk,\nperhaps while in transit. In this paper, we present IFSCQ, a certified\ncryptographic file system with strong integrity guarantees. IFSCQ combines and\nextends work on cryptographic file systems and formally certified file systems\nto prove that our design is correct. It is the first certified file system that\nis secure against strong adversaries that can maliciously corrupt on-disk data\nand metadata, including attempting to roll back the disk to earlier versions of\nvalid data. IFSCQ achieves this by constructing a Merkle hash tree of the whole\ndisk, and by proving that tampered disk blocks will always be detected if they\never occur. We demonstrate that IFSCQ runs with reasonable overhead while\ndetecting several kinds of attacks.\n", "versions": [{"version": "v1", "created": "Mon, 14 Dec 2020 20:02:26 GMT"}], "update_date": "2020-12-16", "authors_parsed": [["Song", "Daniel W.", ""], ["Mamouras", "Konstantinos", ""], ["Chen", "Ang", ""], ["Dautenhahn", "Nathan", ""], ["Wallach", "Dan S.", ""]]}, {"id": "2012.12868", "submitter": "Matan Rusanovsky", "authors": "Matan Rusanovsky, Ohad Ben-Baruch, Danny Hendler and Pedro Ramalhete", "title": "A Flat-Combining-Based Persistent Stack for Non-Volatile Memory", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.OS", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Flat combining (FC) is a synchronization paradigm in which a single thread,\nholding a global lock, collects requests by multiple threads for accessing a\nconcurrent data structure and applies their combined requests to it. Although\nFC is sequential, it significantly reduces synchronization overheads and cache\ninvalidations and thus often provides better performance than that of lock-free\nimplementations. The recent emergence of non-volatile memory (NVM) technologies\nincreases the interest in the development of persistent (a.k.a. durable or\nrecoverable) objects. These are objects that are able to recover from system\nfailures and ensure consistency by retaining their state in NVM and fixing it,\nif required, upon recovery. Of particular interest are detectable objects that,\nin addition to ensuring consistency, allow recovery code to infer if a failed\noperation took effect before the crash and, if it did, obtain its response. In\nthis work, we present the first FC-based persistent object. Specifically, we\nintroduce a detectable FC-based implementation of a concurrent LIFO stack\nobject. Our empirical evaluation establishes that thanks to the usage of flat\ncombining, the novel stack algorithm requires a much smaller number of costly\npersistence instructions than competing algorithms and is therefore able to\nsignificantly outperform them.\n", "versions": [{"version": "v1", "created": "Wed, 23 Dec 2020 18:34:45 GMT"}], "update_date": "2020-12-24", "authors_parsed": [["Rusanovsky", "Matan", ""], ["Ben-Baruch", "Ohad", ""], ["Hendler", "Danny", ""], ["Ramalhete", "Pedro", ""]]}, {"id": "2012.14219", "submitter": "Antoine Kaufmann", "authors": "Hejing Li, Jialin Li, Keon Jang, Antoine Kaufmann", "title": "Reproducible Host Networking Evaluation with End-to-End Simulation", "comments": "15 pages, 10 figures, under submission", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.NI cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Networking researchers are facing growing challenges in evaluating and\nreproducing results for modern network systems. As systems rely on closer\nintegration of system components and cross-layer optimizations in the pursuit\nof performance and efficiency, they are also increasingly tied to specific\nhardware and testbed properties. Combined with a trend towards heterogeneous\nhardware, such as protocol offloads, SmartNICs, and in-network accelerators,\nresearchers face the choice of either investing more and more time and\nresources into comparisons to prior work or, alternatively, lower the standards\nfor evaluation.\n  We aim to address this challenge by introducing SimBricks, a simulation\nframework that decouples networked systems from the physical testbed and\nenables reproducible end-to-end evaluation in simulation. Instead of\nreinventing the wheel, SimBricks is a modular framework for combining existing\ntried-and-true simulators for individual components, processor and memory, NIC,\nand network, into complete testbeds capable of running unmodified systems. In\nour evaluation, we reproduce key findings from prior work, including dctcp\ncongestion control, NOPaxos in-network consensus acceleration, and the Corundum\nFPGA NIC.\n", "versions": [{"version": "v1", "created": "Mon, 28 Dec 2020 13:03:04 GMT"}], "update_date": "2020-12-29", "authors_parsed": [["Li", "Hejing", ""], ["Li", "Jialin", ""], ["Jang", "Keon", ""], ["Kaufmann", "Antoine", ""]]}, {"id": "2012.14635", "submitter": "Behnam Dezfouli", "authors": "Chia-Chi Li, Vikram K. Ramanna, Daniel Webber, Cole Hunter, Tyler\n  Hack, and Behnam Dezfouli", "title": "Sensifi: A Wireless Sensing System for Ultra-High-Rate Applications", "comments": null, "journal-ref": null, "doi": null, "report-no": "SIOTLAB-2020-12-DEC", "categories": "cs.NI cs.OS cs.PF", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Wireless Sensor Networks (WSNs) are being used in various applications such\nas structural health monitoring and industrial control. Since energy efficiency\nis one of the major design factors, the existing WSNs primarily rely on\nlow-power, low-rate wireless technologies such as 802.15.4 and Bluetooth. In\nthis paper, we strive to tackle the challenges of developing ultra-high-rate\nWSNs based on 802.11 (WiFi) standard by proposing Sensifi. As an illustrative\napplication of this system, we consider vibration test monitoring of spacecraft\nand identify system design requirements and challenges. Our main contributions\nare as follows. First, we propose packet encoding methods to reduce the\noverhead of assigning accurate timestamps to samples. Second, we propose energy\nefficiency methods to enhance the system's lifetime. Third, we reduce the\noverhead of processing outgoing packets through network stack to enhance\nsampling rate and mitigate sampling rate instability. Fourth, we study and\nreduce the delay of processing incoming packets through network stack to\nenhance the accuracy of time synchronization among nodes. Fifth, we propose a\nlow-power node design for ultra-high-rate applications. Sixth, we use our node\ndesign to empirically evaluate the system.\n", "versions": [{"version": "v1", "created": "Tue, 29 Dec 2020 07:17:38 GMT"}, {"version": "v2", "created": "Sun, 20 Jun 2021 00:16:47 GMT"}], "update_date": "2021-06-22", "authors_parsed": [["Li", "Chia-Chi", ""], ["Ramanna", "Vikram K.", ""], ["Webber", "Daniel", ""], ["Hunter", "Cole", ""], ["Hack", "Tyler", ""], ["Dezfouli", "Behnam", ""]]}, {"id": "2012.15081", "submitter": "Mingqi Yuan", "authors": "Mingqi Yuan, Qi Cao, Man-on Pun, Yi Chen", "title": "Fairness-Oriented User Scheduling for Bursty Downlink Transmission Using\n  Multi-Agent Reinforcement Learning", "comments": "14 pages, 15 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS cs.AI cs.LG cs.NI", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this work, we develop practical user scheduling algorithms for downlink\nbursty traffic with emphasis on user fairness. In contrast to the conventional\nscheduling algorithms that either equally divides the transmission time slots\namong users or maximizing some ratios without physcial meanings, we propose to\nuse the 5%-tile user data rate (5TUDR) as the metric to evaluate user fairness.\nSince it is difficult to directly optimize 5TUDR, we first cast the problem\ninto the stochastic game framework and subsequently propose a Multi-Agent\nReinforcement Learning (MARL)-based algorithm to perform distributed\noptimization on the resource block group (RBG) allocation. Furthermore, each\nMARL agent is designed to take information measured by network counters from\nmultiple network layers (e.g. Channel Quality Indicator, Buffer size) as the\ninput states while the RBG allocation as action with a proposed reward function\ndesigned to maximize 5TUDR. Extensive simulation is performed to show that the\nproposed MARL-based scheduler can achieve fair scheduling while maintaining\ngood average network throughput as compared to conventional schedulers.\n", "versions": [{"version": "v1", "created": "Wed, 30 Dec 2020 08:41:51 GMT"}, {"version": "v10", "created": "Fri, 30 Apr 2021 08:09:39 GMT"}, {"version": "v11", "created": "Tue, 11 May 2021 13:51:29 GMT"}, {"version": "v2", "created": "Tue, 26 Jan 2021 02:55:02 GMT"}, {"version": "v3", "created": "Thu, 4 Feb 2021 03:14:17 GMT"}, {"version": "v4", "created": "Thu, 11 Feb 2021 16:00:14 GMT"}, {"version": "v5", "created": "Mon, 15 Feb 2021 16:53:45 GMT"}, {"version": "v6", "created": "Tue, 16 Feb 2021 06:06:10 GMT"}, {"version": "v7", "created": "Thu, 18 Feb 2021 02:30:27 GMT"}, {"version": "v8", "created": "Sun, 7 Mar 2021 12:20:34 GMT"}, {"version": "v9", "created": "Mon, 19 Apr 2021 07:08:08 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Yuan", "Mingqi", ""], ["Cao", "Qi", ""], ["Pun", "Man-on", ""], ["Chen", "Yi", ""]]}]