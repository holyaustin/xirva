[{"id": "1211.4839", "submitter": "Mohamed Farag", "authors": "Mohamed Farag", "title": "An Insight View of Kernel Visual Debugger in System Boot up", "comments": "10 pages, International Journal", "journal-ref": "International Journal of Computer Science & Information Technology\n  (IJCSIT) Vol 4, No 5, October 2012", "doi": "10.5121/ijcsit.2012.4510", "report-no": null, "categories": "cs.OS cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For many years, developers could not figure out the mystery of OS kernels.\nThe main source of this mystery is the interaction between operating systems\nand hardware while system's boot up and kernel initialization. In addition,\nmany operating system kernels differ in their behavior toward many situations.\nFor instance, kernels act differently in racing conditions, kernel\ninitialization and process scheduling. For such operations, kernel debuggers\nwere designed to help in tracing kernel behavior and solving many kernel bugs.\nThe importance of kernel debuggers is not limited to kernel code tracing but\nalso, they can be used in verification and performance comparisons. However,\ndevelopers had to be aware of debugger commands thus introducing some\ndifficulties to non-expert programmers. Later, several visual kernel debuggers\nwere presented to make it easier for programmers to trace their kernel code and\nanalyze kernel behavior. Nowadays, several kernel debuggers exist for solving\nthis mystery but only very few support line-by-line debugging at run-time. In\nthis paper, a generic approach for operating system source code debugging in\ngraphical mode with line-by-line tracing support is proposed. In the context of\nthis approach, system boot up and evaluation of two operating system schedulers\nfrom several points of views will be discussed.\n", "versions": [{"version": "v1", "created": "Tue, 20 Nov 2012 19:33:08 GMT"}], "update_date": "2012-11-21", "authors_parsed": [["Farag", "Mohamed", ""]]}, {"id": "1211.4840", "submitter": "Mohamed Farag", "authors": "Mohamed Farag", "title": "Multicore Dynamic Kernel Modules Attachment Technique for Kernel\n  Performance Enhancement", "comments": "13 pages, International Journal of Computer Science & Information\n  Technology (IJCSIT) Vol 4, No 4, August 2012", "journal-ref": null, "doi": "10.5121/ijcsit.2012.4405", "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Traditional monolithic kernels dominated kernel structures for long time\nalong with small sized kernels,few hardware companies and limited kernel\nfunctionalities. Monolithic kernel structure was not applicable when the number\nof hardware companies increased and kernel services consumed by different users\nfor many purposes. One of the biggest disadvantages of the monolithic kernels\nis the inflexibility due to the need to include all the available modules in\nkernel compilation causing high time consuming. Lately, new kernel structure\nwas introduced through multicore operating systems. Unfortunately, many\nmulticore operating systems such as barrelfish and FOS are experimental. This\npaper aims to simulate the performance of multicore hybrid kernels through\ndynamic kernel module customized attachment/ deattachment for multicore\nmachines. In addition, this paper proposes a new technique for loading dynamic\nkernel modules based on the user needs and machine capabilities.\n", "versions": [{"version": "v1", "created": "Tue, 20 Nov 2012 19:38:00 GMT"}], "update_date": "2012-11-21", "authors_parsed": [["Farag", "Mohamed", ""]]}, {"id": "1211.6185", "submitter": "EPTCS", "authors": "Sidney Amani (NICTA and UNSW), Peter Chubb (NICTA and UNSW), Alastair\n  F. Donaldson (Imperial College London), Alexander Legg (NICTA and UNSW),\n  Leonid Ryzhyk (NICTA and UNSW), Yanjin Zhu (NICTA and UNSW)", "title": "Automatic Verification of Message-Based Device Drivers", "comments": "In Proceedings SSV 2012, arXiv:1211.5873", "journal-ref": "EPTCS 102, 2012, pp. 4-17", "doi": "10.4204/EPTCS.102.3", "report-no": null, "categories": "cs.OS cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a practical solution to the problem of automatic verification of\nthe interface between device drivers and the OS. Our solution relies on a\ncombination of improved driver architecture and verification tools. It supports\ndrivers written in C and can be implemented in any existing OS, which sets it\napart from previous proposals for verification-friendly drivers. Our\nLinux-based evaluation shows that this methodology amplifies the power of\nexisting verification tools in detecting driver bugs, making it possible to\nverify properties beyond the reach of traditional techniques.\n", "versions": [{"version": "v1", "created": "Tue, 27 Nov 2012 02:36:10 GMT"}], "update_date": "2012-11-28", "authors_parsed": [["Amani", "Sidney", "", "NICTA and UNSW"], ["Chubb", "Peter", "", "NICTA and UNSW"], ["Donaldson", "Alastair F.", "", "Imperial College London"], ["Legg", "Alexander", "", "NICTA and UNSW"], ["Ryzhyk", "Leonid", "", "NICTA and UNSW"], ["Zhu", "Yanjin", "", "NICTA and UNSW"]]}, {"id": "1211.6187", "submitter": "EPTCS", "authors": "Gidon Ernst (University of Augsburg), Gerhard Schellhorn (University\n  of Augsburg), Dominik Haneberg (University of Augsburg), J\\\"org Pf\\\"ahler\n  (University of Augsburg), Wolfgang Reif (University of Augsburg)", "title": "A Formal Model of a Virtual Filesystem Switch", "comments": "In Proceedings SSV 2012, arXiv:1211.5873", "journal-ref": "EPTCS 102, 2012, pp. 33-45", "doi": "10.4204/EPTCS.102.5", "report-no": null, "categories": "cs.LO cs.OS cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work presents a formal model that is part of our effort to construct a\nverified file system for Flash memory. To modularize the verification we factor\nout generic aspects into a common component that is inspired by the Linux\nVirtual Filesystem Switch (VFS) and provides POSIX compatible operations. It\nrelies on an abstract specification of its internal interface to concrete file\nsystem implementations (AFS). We proved that preconditions of AFS are respected\nand that the state is kept consistent. The model can be made executable and\nmounted into the Linux directory tree using FUSE.\n", "versions": [{"version": "v1", "created": "Tue, 27 Nov 2012 02:36:24 GMT"}], "update_date": "2012-11-28", "authors_parsed": [["Ernst", "Gidon", "", "University of Augsburg"], ["Schellhorn", "Gerhard", "", "University\n  of Augsburg"], ["Haneberg", "Dominik", "", "University of Augsburg"], ["Pf\u00e4hler", "J\u00f6rg", "", "University of Augsburg"], ["Reif", "Wolfgang", "", "University of Augsburg"]]}, {"id": "1211.6190", "submitter": "EPTCS", "authors": "Hendrik Tews (TU Dresden), Marcus V\\\"olp (TU Dresden), Tjark Weber\n  (Uppsala University)", "title": "On the Use of Underspecified Data-Type Semantics for Type Safety in\n  Low-Level Code", "comments": "In Proceedings SSV 2012, arXiv:1211.5873", "journal-ref": "EPTCS 102, 2012, pp. 73-87", "doi": "10.4204/EPTCS.102.8", "report-no": null, "categories": "cs.LO cs.OS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In recent projects on operating-system verification, C and C++ data types are\noften formalized using a semantics that does not fully specify the precise byte\nencoding of objects. It is well-known that such an underspecified data-type\nsemantics can be used to detect certain kinds of type errors. In general,\nhowever, underspecified data-type semantics are unsound: they assign\nwell-defined meaning to programs that have undefined behavior according to the\nC and C++ language standards.\n  A precise characterization of the type-correctness properties that can be\nenforced with underspecified data-type semantics is still missing. In this\npaper, we identify strengths and weaknesses of underspecified data-type\nsemantics for ensuring type safety of low-level systems code. We prove\nsufficient conditions to detect certain classes of type errors and, finally,\nidentify a trade-off between the complexity of underspecified data-type\nsemantics and their type-checking capabilities.\n", "versions": [{"version": "v1", "created": "Tue, 27 Nov 2012 02:36:45 GMT"}], "update_date": "2012-11-28", "authors_parsed": [["Tews", "Hendrik", "", "TU Dresden"], ["V\u00f6lp", "Marcus", "", "TU Dresden"], ["Weber", "Tjark", "", "Uppsala University"]]}, {"id": "1211.6196", "submitter": "EPTCS", "authors": "Christel Baier (TU Dresden), Marcus Daum (TU Dresden), Benjamin Engel\n  (TU Dresden), Hermann H\\\"artig (TU Dresden), Joachim Klein (TU Dresden),\n  Sascha Kl\\\"uppelholz (TU Dresden), Steffen M\\\"arcker (TU Dresden), Hendrik\n  Tews (TU Dresden), Marcus V\\\"olp (TU Dresden)", "title": "Chiefly Symmetric: Results on the Scalability of Probabilistic Model\n  Checking for Operating-System Code", "comments": "In Proceedings SSV 2012, arXiv:1211.5873", "journal-ref": "EPTCS 102, 2012, pp. 156-166", "doi": "10.4204/EPTCS.102.14", "report-no": null, "categories": "cs.LO cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reliability in terms of functional properties from the safety-liveness\nspectrum is an indispensable requirement of low-level operating-system (OS)\ncode. However, with evermore complex and thus less predictable hardware,\nquantitative and probabilistic guarantees become more and more important.\nProbabilistic model checking is one technique to automatically obtain these\nguarantees. First experiences with the automated quantitative analysis of\nlow-level operating-system code confirm the expectation that the naive\nprobabilistic model checking approach rapidly reaches its limits when\nincreasing the numbers of processes. This paper reports on our work-in-progress\nto tackle the state explosion problem for low-level OS-code caused by the\nexponential blow-up of the model size when the number of processes grows. We\nstudied the symmetry reduction approach and carried out our experiments with a\nsimple test-and-test-and-set lock case study as a representative example for a\nwide range of protocols with natural inter-process dependencies and long-run\nproperties. We quickly see a state-space explosion for scenarios where\ninter-process dependencies are insignificant. However, once inter-process\ndependencies dominate the picture models with hundred and more processes can be\nconstructed and analysed.\n", "versions": [{"version": "v1", "created": "Tue, 27 Nov 2012 02:37:28 GMT"}], "update_date": "2012-11-28", "authors_parsed": [["Baier", "Christel", "", "TU Dresden"], ["Daum", "Marcus", "", "TU Dresden"], ["Engel", "Benjamin", "", "TU Dresden"], ["H\u00e4rtig", "Hermann", "", "TU Dresden"], ["Klein", "Joachim", "", "TU Dresden"], ["Kl\u00fcppelholz", "Sascha", "", "TU Dresden"], ["M\u00e4rcker", "Steffen", "", "TU Dresden"], ["Tews", "Hendrik", "", "TU Dresden"], ["V\u00f6lp", "Marcus", "", "TU Dresden"]]}]