[{"id": "1710.03789", "submitter": "Beom Heyn Kim", "authors": "Beom Heyn Kim, Eyal de Lara, David Lie", "title": "The Case for a Single System Image for Personal Devices", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computing technology has gotten cheaper and more powerful, allowing users to\nhave a growing number of personal computing devices at their disposal. While\nthis trend is beneficial for the user, it also creates a growing management\nburden for the user. Each device must be managed independently and users must\nrepeat the same management tasks on the each device, such as updating software,\nchanging configurations, backup, and replicating data for availability. To\nprevent the management burden from increasing with the number of devices, we\npropose that all devices run a single system image called a personal computing\nimage. Personal computing images export a device-specific user interface on\neach device, but provide a consistent view of application and operating state\nacross all devices. As a result, management tasks can be performed once on any\ndevice and will be automatically propagated to all other devices belonging to\nthe user. We discuss evolutionary steps that can be taken to achieve personal\ncomputing images for devices and elaborate on challenges that we believe\nbuilding such systems will face.\n", "versions": [{"version": "v1", "created": "Tue, 10 Oct 2017 19:10:40 GMT"}], "update_date": "2017-10-12", "authors_parsed": [["Kim", "Beom Heyn", ""], ["de Lara", "Eyal", ""], ["Lie", "David", ""]]}, {"id": "1710.06175", "submitter": "Hans Liljestrand", "authors": "Elena Reshetova, Hans Liljestrand, Andrew Paverd, N.Asokan", "title": "Towards Linux Kernel Memory Safety", "comments": null, "journal-ref": null, "doi": "10.1002/spe.2638", "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The security of billions of devices worldwide depends on the security and\nrobustness of the mainline Linux kernel. However, the increasing number of\nkernel-specific vulnerabilities, especially memory safety vulnerabilities,\nshows that the kernel is a popular and practically exploitable target. Two\nmajor causes of memory safety vulnerabilities are reference counter overflows\n(temporal memory errors) and lack of pointer bounds checking (spatial memory\nerrors).\n  To succeed in practice, security mechanisms for critical systems like the\nLinux kernel must also consider performance and deployability as critical\ndesign objectives. We present and systematically analyze two such mechanisms\nfor improving memory safety in the Linux kernel: (a) an overflow-resistant\nreference counter data structure designed to accommodate typical reference\ncounter usage in kernel source code, and (b) runtime pointer bounds checking\nusing Intel MPX in the kernel.\n", "versions": [{"version": "v1", "created": "Tue, 17 Oct 2017 09:07:13 GMT"}], "update_date": "2018-10-03", "authors_parsed": [["Reshetova", "Elena", ""], ["Liljestrand", "Hans", ""], ["Paverd", "Andrew", ""], ["Asokan", "N.", ""]]}, {"id": "1710.08705", "submitter": "Stephanie Abraham", "authors": "Stephanie Abraham, Tyler Silva, Robert Decourcy, Jim Cardon", "title": "Tails & Tor and other tools for Safeguarding Online Activities", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There are not many known ways to break Tor anonymity, and they require an\nenormous amount of computational power. Controlling both entrance and exit\nnodes allows an attacker to compromise client IP with enough pattern analysis.\nIf an .onion or public website does not use SSL, information will not be\nencrypted once it reaches the exit node. Tor has been successfully broken by\nCarnegie Mellon, however they will not answer questions nor confirm their\nmethod. This research paper investigates Tails & Tor and other tools for\nSafeguarding Online Activities.\n", "versions": [{"version": "v1", "created": "Tue, 24 Oct 2017 11:14:02 GMT"}], "update_date": "2017-12-13", "authors_parsed": [["Abraham", "Stephanie", ""], ["Silva", "Tyler", ""], ["Decourcy", "Robert", ""], ["Cardon", "Jim", ""]]}, {"id": "1710.09921", "submitter": "Seo Jin Park", "authors": "Seo Jin Park and John Ousterhout", "title": "Exploiting Commutativity For Practical Fast Replication", "comments": "16 pages, 13 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Traditional approaches to replication require client requests to be ordered\nbefore making them durable by copying them to replicas. As a result, clients\nmust wait for two round-trip times (RTTs) before updates complete. In this\npaper, we show that this entanglement of ordering and durability is unnecessary\nfor strong consistency. Consistent Unordered Replication Protocol (CURP) allows\nclients to replicate requests that have not yet been ordered, as long as they\nare commutative. This strategy allows most operations to complete in 1 RTT (the\nsame as an unreplicated system). We implemented CURP in the Redis and RAMCloud\nstorage systems. In RAMCloud, CURP improved write latency by ~2x (13.8 us ->\n7.3 us) and write throughput by 4x. Compared to unreplicated RAMCloud, CURP's\nlatency overhead for 3-way replication is just 0.4 us (6.9 us vs 7.3 us). CURP\ntransformed a non-durable Redis cache into a consistent and durable storage\nsystem with only a small performance overhead.\n", "versions": [{"version": "v1", "created": "Thu, 26 Oct 2017 21:34:34 GMT"}], "update_date": "2017-10-30", "authors_parsed": [["Park", "Seo Jin", ""], ["Ousterhout", "John", ""]]}]