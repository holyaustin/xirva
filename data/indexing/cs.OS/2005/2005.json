[{"id": "2005.00323", "submitter": "Daniele Cono D'Elia", "authors": "Daniele Cono D'Elia, Simone Nicchi, Matteo Mariani, Matteo Marini,\n  Federico Palmaro", "title": "Designing Robust API Monitoring Solutions", "comments": "This work has been submitted to the IEEE for possible publication.\n  Copyright may be transferred without notice, after which this version may no\n  longer be accessible", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Tracing the sequence of library and system calls that a program makes is very\nhelpful in the characterization of its interactions with the surrounding\nenvironment and ultimately of its semantics. Due to entanglements of real-world\nsoftware stacks, accomplishing this task can be surprisingly challenging as we\ntake accuracy, reliability, and transparency into the equation. To manage these\ndimensions effectively, we identify six challenges that API monitoring\nsolutions should overcome and outline actionable design points for them,\nreporting insights from our experience in building API tracers for software\nsecurity research. We detail two implementation variants, based on\nhardware-assisted virtualization (realizing the first general-purpose\nuser-space tracer of this kind) and on dynamic binary translation, that achieve\nAPI monitoring robustly. We share our SNIPER system as open source.\n", "versions": [{"version": "v1", "created": "Fri, 1 May 2020 11:57:22 GMT"}, {"version": "v2", "created": "Thu, 11 Mar 2021 19:49:06 GMT"}], "update_date": "2021-03-15", "authors_parsed": [["D'Elia", "Daniele Cono", ""], ["Nicchi", "Simone", ""], ["Mariani", "Matteo", ""], ["Marini", "Matteo", ""], ["Palmaro", "Federico", ""]]}, {"id": "2005.01498", "submitter": "Mathias Gottschlag", "authors": "Mathias Gottschlag, Yussuf Khalil, Frank Bellosa", "title": "Dim Silicon and the Case for Improved DVFS Policies", "comments": "19 pages, 8 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Due to thermal and power supply limits, modern Intel CPUs reduce their\nfrequency when AVX2 and AVX-512 instructions are executed. As the CPUs wait for\n670{\\mu}s before increasing the frequency again, the performance of some\nheterogeneous workloads is reduced. In this paper, we describe parallels\nbetween this situation and dynamic power management as well as between the\npolicy implemented by these CPUs and fixed-timeout device shutdown policies. We\nshow that the policy implemented by Intel CPUs is not optimal and describe\npotential better policies. In particular, we present a mechanism to classify\napplications based on their likeliness to cause frequency reduction. Our\napproach takes either the resulting classification information or information\nprovided by the application and generates hints for the DVFS policy. We show\nthat faster frequency changes based on these hints are able to improve\nperformance for a web server using the OpenSSL library.\n", "versions": [{"version": "v1", "created": "Mon, 4 May 2020 14:04:43 GMT"}], "update_date": "2020-05-05", "authors_parsed": [["Gottschlag", "Mathias", ""], ["Khalil", "Yussuf", ""], ["Bellosa", "Frank", ""]]}, {"id": "2005.02547", "submitter": "Mai Zheng", "authors": "Duo Zhang, Om Rameshwar Gatla, Runzhou Han, Mai Zheng", "title": "On Failure Diagnosis of the Storage Stack", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Diagnosing storage system failures is challenging even for professionals. One\nexample is the \"When Solid State Drives Are Not That Solid\" incident occurred\nat Algolia data center, where Samsung SSDs were mistakenly blamed for failures\ncaused by a Linux kernel bug. With the system complexity keeps increasing, such\nobscure failures will likely occur more often. As one step to address the\nchallenge, we present our on-going efforts called X-Ray. Different from\ntraditional methods that focus on either the software or the hardware, X-Ray\nleverages virtualization to collects events across layers, and correlates them\nto generate a correlation tree. Moreover, by applying simple rules, X-Ray can\nhighlight critical nodes automatically. Preliminary results based on 5 failure\ncases shows that X-Ray can effectively narrow down the search space for\nfailures.\n", "versions": [{"version": "v1", "created": "Wed, 6 May 2020 01:07:29 GMT"}, {"version": "v2", "created": "Wed, 21 Jul 2021 21:36:31 GMT"}], "update_date": "2021-07-23", "authors_parsed": [["Zhang", "Duo", ""], ["Gatla", "Om Rameshwar", ""], ["Han", "Runzhou", ""], ["Zheng", "Mai", ""]]}, {"id": "2005.04750", "submitter": "Anup Das", "authors": "Shihao Song, Anup Das, Nagarajan Kandasamy", "title": "Exploiting Inter- and Intra-Memory Asymmetries for Data Mapping in\n  Hybrid Tiered-Memories", "comments": "15 pages, 29 figures, accepted at ACM SIGPLAN International Symposium\n  on Memory Management", "journal-ref": null, "doi": "10.1145/3381898.3397215", "report-no": null, "categories": "cs.AR cs.OS", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Modern computing systems are embracing hybrid memory comprising of DRAM and\nnon-volatile memory (NVM) to combine the best properties of both memory\ntechnologies, achieving low latency, high reliability, and high density. A\nprominent characteristic of DRAM-NVM hybrid memory is that it has NVM access\nlatency much higher than DRAM access latency. We call this inter-memory\nasymmetry. We observe that parasitic components on a long bitline are a major\nsource of high latency in both DRAM and NVM, and a significant factor\ncontributing to high-voltage operations in NVM, which impact their reliability.\nWe propose an architectural change, where each long bitline in DRAM and NVM is\nsplit into two segments by an isolation transistor. One segment can be accessed\nwith lower latency and operating voltage than the other. By introducing tiers,\nwe enable non-uniform accesses within each memory type (which we call\nintra-memory asymmetry), leading to performance and reliability trade-offs in\nDRAM-NVM hybrid memory. We extend existing NVM-DRAM OS in three ways. First, we\nexploit both inter- and intra-memory asymmetries to allocate and migrate memory\npages between the tiers in DRAM and NVM. Second, we improve the OS's page\nallocation decisions by predicting the access intensity of a newly-referenced\nmemory page in a program and placing it to a matching tier during its initial\nallocation. This minimizes page migrations during program execution, lowering\nthe performance overhead. Third, we propose a solution to migrate pages between\nthe tiers of the same memory without transferring data over the memory channel,\nminimizing channel occupancy and improving performance. Our overall approach,\nwhich we call MNEME, to enable and exploit asymmetries in DRAM-NVM hybrid\ntiered memory improves both performance and reliability for both single-core\nand multi-programmed workloads.\n", "versions": [{"version": "v1", "created": "Sun, 10 May 2020 18:53:02 GMT"}], "update_date": "2020-05-12", "authors_parsed": [["Song", "Shihao", ""], ["Das", "Anup", ""], ["Kandasamy", "Nagarajan", ""]]}, {"id": "2005.04753", "submitter": "Anup Das", "authors": "Shihao Song, Anup Das, Onur Mutlu, Nagarajan Kandasamy", "title": "Improving Phase Change Memory Performance with Data Content Aware Access", "comments": "18 pages, 21 figures, accepted at ACM SIGPLAN International Symposium\n  on Memory Management (ISMM)", "journal-ref": null, "doi": "10.1145/3381898.3397210", "report-no": null, "categories": "cs.AR cs.OS", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A prominent characteristic of write operation in Phase-Change Memory (PCM) is\nthat its latency and energy are sensitive to the data to be written as well as\nthe content that is overwritten. We observe that overwriting unknown memory\ncontent can incur significantly higher latency and energy compared to\noverwriting known all-zeros or all-ones content. This is because all-zeros or\nall-ones content is overwritten by programming the PCM cells only in one\ndirection, i.e., using either SET or RESET operations, not both. In this paper,\nwe propose data content aware PCM writes (DATACON), a new mechanism that\nreduces the latency and energy of PCM writes by redirecting these requests to\noverwrite memory locations containing all-zeros or all-ones. DATACON operates\nin three steps. First, it estimates how much a PCM write access would benefit\nfrom overwriting known content (e.g., all-zeros, or all-ones) by\ncomprehensively considering the number of set bits in the data to be written,\nand the energy-latency trade-offs for SET and RESET operations in PCM. Second,\nit translates the write address to a physical address within memory that\ncontains the best type of content to overwrite, and records this translation in\na table for future accesses. We exploit data access locality in workloads to\nminimize the address translation overhead. Third, it re-initializes unused\nmemory locations with known all-zeros or all-ones content in a manner that does\nnot interfere with regular read and write accesses. DATACON overwrites unknown\ncontent only when it is absolutely necessary to do so. We evaluate DATACON with\nworkloads from state-of-the-art machine learning applications, SPEC CPU2017,\nand NAS Parallel Benchmarks. Results demonstrate that DATACON significantly\nimproves system performance and memory system energy consumption compared to\nthe best of performance-oriented state-of-the-art techniques.\n", "versions": [{"version": "v1", "created": "Sun, 10 May 2020 19:07:08 GMT"}], "update_date": "2020-05-12", "authors_parsed": [["Song", "Shihao", ""], ["Das", "Anup", ""], ["Mutlu", "Onur", ""], ["Kandasamy", "Nagarajan", ""]]}, {"id": "2005.09723", "submitter": "Samantha Miller", "authors": "Samantha Miller (1), Kaiyuan Zhang (1), Mengqi Chen (1), Ryan Jennings\n  (1), Ang Chen (2), Danyang Zhuo (3), Tom Anderson (1) ((1) University of\n  Washington, (2) Rice University, (3) Duke University)", "title": "High Velocity Kernel File Systems with Bento", "comments": "14 pages, 6 figures, to be published in FAST 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  High development velocity is critical for modern systems. This is especially\ntrue for Linux file systems which are seeing increased pressure from new\nstorage devices and new demands on storage systems. However, high velocity\nLinux kernel development is challenging due to the ease of introducing bugs,\nthe difficulty of testing and debugging, and the lack of support for\nredeployment without service disruption. Existing approaches to high-velocity\ndevelopment of file systems for Linux have major downsides, such as the high\nperformance penalty for FUSE file systems, slowing the deployment cycle for new\nfile system functionality.\n  We propose Bento, a framework for high velocity development of Linux kernel\nfile systems. It enables file systems written in safe Rust to be installed in\nthe Linux kernel, with errors largely sandboxed to the file system. Bento file\nsystems can be replaced with no disruption to running applications, allowing\ndaily or weekly upgrades in a cloud server setting. Bento also supports\nuserspace debugging. We implement a simple file system using Bento and show\nthat it performs similarly to VFS-native ext4 on a variety of benchmarks and\noutperforms a FUSE version by 7x on 'git clone'. We also show that we can\ndynamically add file provenance tracking to a running kernel file system with\nonly 15ms of service interruption.\n", "versions": [{"version": "v1", "created": "Tue, 19 May 2020 19:46:01 GMT"}, {"version": "v2", "created": "Fri, 25 Sep 2020 01:07:39 GMT"}, {"version": "v3", "created": "Mon, 8 Feb 2021 20:07:02 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Miller", "Samantha", ""], ["Zhang", "Kaiyuan", ""], ["Chen", "Mengqi", ""], ["Jennings", "Ryan", ""], ["Chen", "Ang", ""], ["Zhuo", "Danyang", ""], ["Anderson", "Tom", ""]]}, {"id": "2005.10333", "submitter": "Mohammad Sina Kiarostami", "authors": "Mohammad Sina Karvandi, Saleh Khalaj Monfared, Mohammad Sina\n  Kiarostami, Dara Rahmati, Saeid Gorgin", "title": "A Way Around UMIP and Descriptor-Table Exiting via TSX-based\n  Side-Channel", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.AR cs.OS", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Nowadays, in operating systems, numerous protection mechanisms prevent or\nlimit the user-mode applicationsto access the kernels internal information.\nThis is regularlycarried out by software-based defenses such as Address Space\nLayout Randomization (ASLR) and Kernel ASLR(KASLR). They play pronounced roles\nwhen the security of sandboxed applications such as Web-browser are\nconsidered.Armed with arbitrary write access in the kernel memory, if these\nprotections are bypassed, an adversary could find a suitable where to write in\norder to get an elevation of privilege or code execution in ring 0. In this\npaper, we introduce a reliable method based on Transactional Synchronization\nExtensions (TSX) side-channel leakage to reveal the address of the Global\nDescriptor Table (GDT) and Interrupt Descriptor Table (IDT). We indicate that\nby detecting these addresses, one could execute instructions to sidestep the\nIntels User-Mode InstructionPrevention (UMIP) and the Hypervisor-based\nmitigation and, consequently, neutralized them. The introduced method is\nsuccessfully performed after the most recent patches for Meltdown and Spectre.\nMoreover, the implementation of the proposed approach on different platforms,\nincluding the latest releases of Microsoft Windows, Linux, and, Mac OSX with\nthe latest 9th generation of Intel processors, shows that the proposed\nmechanism is independent from the Operating System implementation. We\ndemonstrate that a combinationof this method with call-gate mechanism\n(available in modernprocessors) in a chain of events will eventually lead toa\nsystem compromise despite the limitations of a super-secure sandboxed\nenvironment in the presence of Windows proprietary Virtualization Based\nSecurity (VBS). Finally, we suggest the software-based mitigation to avoid\nthese issues with an acceptable overhead cost.\n", "versions": [{"version": "v1", "created": "Wed, 20 May 2020 19:54:38 GMT"}, {"version": "v2", "created": "Thu, 22 Apr 2021 08:57:18 GMT"}], "update_date": "2021-04-23", "authors_parsed": [["Karvandi", "Mohammad Sina", ""], ["Monfared", "Saleh Khalaj", ""], ["Kiarostami", "Mohammad Sina", ""], ["Rahmati", "Dara", ""], ["Gorgin", "Saeid", ""]]}, {"id": "2005.11050", "submitter": "Mohsen Amini Salehi", "authors": "Ali Mokhtari, Chavit Denninnart, Mohsen Amini Salehi", "title": "Autonomous Task Dropping Mechanism to Achieve Robustness in\n  Heterogeneous Computing Systems", "comments": null, "journal-ref": "in 29th Heterogeneity in Computing Workshop (HCW 2019), in the\n  Proceedings of the IPDPS 2019 Workshops & PhD Forum (IPDPSW)", "doi": null, "report-no": null, "categories": "cs.DC cs.OS cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Robustness of a distributed computing system is defined as the ability to\nmaintain its performance in the presence of uncertain parameters. Uncertainty\nis a key problem in heterogeneous (and even homogeneous) distributed computing\nsystems that perturbs system robustness. Notably, the performance of these\nsystems is perturbed by uncertainty in both task execution time and arrival.\nAccordingly, our goal is to make the system robust against these uncertainties.\nConsidering task execution time as a random variable, we use probabilistic\nanalysis to develop an autonomous proactive task dropping mechanism to attain\nour robustness goal. Specifically, we provide a mathematical model that\nidentifies the optimality of a task dropping decision, so that the system\nrobustness is maximized. Then, we leverage the mathematical model to develop a\ntask dropping heuristic that achieves the system robustness within a feasible\ntime complexity. Although the proposed model is generic and can be applied to\nany distributed system, we concentrate on heterogeneous computing (HC) systems\nthat have a higher degree of exposure to uncertainty than homogeneous systems.\nExperimental results demonstrate that the autonomous proactive dropping\nmechanism can improve the system robustness by up to 20%.\n", "versions": [{"version": "v1", "created": "Fri, 22 May 2020 08:14:04 GMT"}], "update_date": "2020-05-25", "authors_parsed": [["Mokhtari", "Ali", ""], ["Denninnart", "Chavit", ""], ["Salehi", "Mohsen Amini", ""]]}, {"id": "2005.12821", "submitter": "Madhur Jain", "authors": "Madhur Jain", "title": "Study of Firecracker MicroVM", "comments": "4 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS cs.DC", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Firecracker is a virtualization technology that makes use of Kernel Virtual\nMachine (KVM). Firecracker belongs to a new virtualization class named the\nmicro-virtual machines (MicroVMs). Using Firecracker, we can launch lightweight\nMicroVMs in non-virtualized environments in a fraction of a second, at the same\ntime offering the security and workload isolation provided by traditional VMs\nand also the resource efficiency that comes along with containers \\cite{b1}.\nFirecracker aims to provide a slimmed-down MicroVM, comprised of approximately\n50K lines of code in Rust and with a reduced attack surface for guest VMs. This\nreport will examine the internals of Firecracker and understand why Firecracker\nis the next big thing going forward in virtualization and cloud computing.\n", "versions": [{"version": "v1", "created": "Tue, 26 May 2020 15:56:06 GMT"}], "update_date": "2020-05-27", "authors_parsed": [["Jain", "Madhur", ""]]}]