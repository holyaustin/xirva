[{"id": "1006.0813", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "On the definition of a theoretical concept of an operating system", "comments": "8 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We dwell on how a definition of a theoretical concept of an operating system,\nsuitable to be incorporated in a mathematical theory of operating systems,\ncould look like. This is considered a valuable preparation for the development\nof a mathematical theory of operating systems.\n", "versions": [{"version": "v1", "created": "Fri, 4 Jun 2010 09:03:39 GMT"}], "update_date": "2010-06-07", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "1006.2104", "submitter": "Harco Leslie Hendric Spits Warnars", "authors": "Spits Warnars H.L.H", "title": "Perbandingan Shell Unix", "comments": "21 Pages", "journal-ref": "Widya, Vol 21,No. 230, pp. 9-15, November 2004", "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  Is it possible for an Information Technology [IT] product to be both mature\nand state-of-theart at the same time? In the case of the UNIX system, the\nanswer is an unqualified \"Yes.\" The UNIX system has continued to develop over\nthe past twenty-five years. In millions of installations running on nearly\nevery hardware platform made, the UNIX system has earned its reputation for\nstability and scalability. Over the years, UNIX system suppliers have steadily\nassimilated new technologies so that UNIX systems today provide more\nfunctionality as any other operating system.\n", "versions": [{"version": "v1", "created": "Thu, 10 Jun 2010 18:13:36 GMT"}], "update_date": "2010-06-11", "authors_parsed": [["H", "Spits Warnars H. L.", ""]]}, {"id": "1006.2617", "submitter": "Joel Goossens", "authors": "Jo\\\"el Goossens and Vandy Berten", "title": "Gang FTP scheduling of periodic and parallel rigid real-time tasks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we consider the scheduling of periodic and parallel rigid\ntasks. We provide (and prove correct) an exact schedulability test for Fixed\nTask Priority (FTP) Gang scheduler sub-classes: Parallelism Monotonic, Idling,\nLimited Gang, and Limited Slack Reclaiming. Additionally, we study the\npredictability of our schedulers: we show that Gang FJP schedulers are not\npredictable and we identify several sub-classes which are actually predictable.\nMoreover, we extend the definition of rigid, moldable and malleable jobs to\nrecurrent tasks.\n", "versions": [{"version": "v1", "created": "Mon, 14 Jun 2010 07:17:14 GMT"}], "update_date": "2010-06-15", "authors_parsed": [["Goossens", "Jo\u00ebl", ""], ["Berten", "Vandy", ""]]}, {"id": "1006.2637", "submitter": "Joel Goossens", "authors": "Fran\\c{c}ois Dorin, Patrick Meumeu Yomsi, Jo\\\"el Goossens and Pascal\n  Richard", "title": "Semi-Partitioned Hard Real-Time Scheduling with Restricted Migrations\n  upon Identical Multiprocessor Platforms", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Algorithms based on semi-partitioned scheduling have been proposed as a\nviable alternative between the two extreme ones based on global and partitioned\nscheduling. In particular, allowing migration to occur only for few tasks which\ncannot be assigned to any individual processor, while most tasks are assigned\nto specific processors, considerably reduces the runtime overhead compared to\nglobal scheduling on the one hand, and improve both the schedulability and the\nsystem utilization factor compared to partitioned scheduling on the other hand.\nIn this paper, we address the preemptive scheduling problem of hard real-time\nsystems composed of sporadic constrained-deadline tasks upon identical\nmultiprocessor platforms. We propose a new algorithm and a scheduling paradigm\nbased on the concept of semi-partitioned scheduling with restricted migrations\nin which jobs are not allowed to migrate, but two subsequent jobs of a task can\nbe assigned to different processors by following a periodic strategy.\n", "versions": [{"version": "v1", "created": "Mon, 14 Jun 2010 08:51:05 GMT"}], "update_date": "2010-06-15", "authors_parsed": [["Dorin", "Fran\u00e7ois", ""], ["Yomsi", "Patrick Meumeu", ""], ["Goossens", "Jo\u00ebl", ""], ["Richard", "Pascal", ""]]}, {"id": "1006.5845", "submitter": "Mattia Monga", "authors": "Aristide Fattori, Roberto Paleari, Lorenzo Martignoni, Mattia Monga", "title": "Dynamic and Transparent Analysis of Commodity Production Systems", "comments": "10 pages, To appear in the 25th IEEE/ACM International Conference on\n  Automated Software Engineering, Antwerp, Belgium, 20-24 September 2010", "journal-ref": null, "doi": "10.1145/1858996.1859085", "report-no": null, "categories": "cs.OS cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a framework that provides a programming interface to perform\ncomplex dynamic system-level analyses of deployed production systems. By\nleveraging hardware support for virtualization available nowadays on all\ncommodity machines, our framework is completely transparent to the system under\nanalysis and it guarantees isolation of the analysis tools running on its top.\nThus, the internals of the kernel of the running system needs not to be\nmodified and the whole platform runs unaware of the framework. Moreover, errors\nin the analysis tools do not affect the running system and the framework. This\nis accomplished by installing a minimalistic virtual machine monitor and\nmigrating the system, as it runs, into a virtual machine. In order to\ndemonstrate the potentials of our framework we developed an interactive kernel\ndebugger, nicknamed HyperDbg. HyperDbg can be used to debug any critical kernel\ncomponent, and even to single step the execution of exception and interrupt\nhandlers.\n", "versions": [{"version": "v1", "created": "Wed, 30 Jun 2010 13:01:58 GMT"}], "update_date": "2015-03-04", "authors_parsed": [["Fattori", "Aristide", ""], ["Paleari", "Roberto", ""], ["Martignoni", "Lorenzo", ""], ["Monga", "Mattia", ""]]}]