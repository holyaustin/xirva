[{"id": "1904.05012", "submitter": "Jinwoo Ahn", "authors": "Jinwoo Ahn, Donggyu Park, Chang-Gyu Lee, Donghyun Min, Junghee Lee,\n  Sungyong Park, Qian Chen, Youngjae Kim", "title": "KEY-SSD: Access-Control Drive to Protect Files from Ransomware Attacks", "comments": "12 pages, 20 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Traditional techniques to prevent damage from ransomware attacks are to\ndetect and block attacks by monitoring the known behaviors such as frequent\nname changes, recurring access to cryptographic libraries and exchange keys\nwith remote servers. Unfortunately, intelligent ransomware can easily bypass\nthese techniques. Another prevention technique is to recover from the backup\ncopy when a file is infected with ransomware. However, the data backup\ntechnique requires extra storage space and can be removed with ransomware. In\nthis paper, we propose to implement an access control mechanism on a disk\ndrive, called a KEY-SSD disk drive. KEY-SSD is the data store and the last\nbarrier to data protection. Unauthorized applications will not be able to read\nfile data even if they bypass the file system defense, thus denying the block\nrequest without knowing the disk's registered block key and completely\neliminating the possibility of the file becoming hostage to ransomware. We have\nprototyped KEY-SSD and validated the usefulness of KEY-SSD by demonstrating 1)\nselective block access control, 2) unauthorized data access blocking and 3)\nnegligible performance overhead. Our comprehensive evaluation of KEY-SSD for\nvarious workloads show the KEY-SSD performance is hardly degraded due to OS\nlightweight key transmission and access control drive optimization. We also\nconfirmed that KEY-SSD successfully protects the files in the actual ransomware\nsample.\n", "versions": [{"version": "v1", "created": "Wed, 10 Apr 2019 06:15:28 GMT"}], "update_date": "2019-04-11", "authors_parsed": [["Ahn", "Jinwoo", ""], ["Park", "Donggyu", ""], ["Lee", "Chang-Gyu", ""], ["Min", "Donghyun", ""], ["Lee", "Junghee", ""], ["Park", "Sungyong", ""], ["Chen", "Qian", ""], ["Kim", "Youngjae", ""]]}, {"id": "1904.05572", "submitter": "Ren\\'e Mayrhofer", "authors": "Ren\\'e Mayrhofer, Jeffrey Vander Stoep, Chad Brubaker, Nick Kralevich", "title": "The Android Platform Security Model", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Android is the most widely deployed end-user focused operating system. With\nits growing set of use cases encompassing communication, navigation, media\nconsumption, entertainment, finance, health, and access to sensors, actuators,\ncameras, or microphones, its underlying security model needs to address a host\nof practical threats in a wide variety of scenarios while being useful to\nnon-security experts. The model needs to strike a difficult balance between\nsecurity, privacy, and usability for end users, assurances for app developers,\nand system performance under tight hardware constraints. While many of the\nunderlying design principles have implicitly informed the overall system\narchitecture, access control mechanisms, and mitigation techniques, the Android\nsecurity model has previously not been formally published. This paper aims to\nboth document the abstract model and discuss its implications. Based on a\ndefinition of the threat model and Android ecosystem context in which it\noperates, we analyze how the different security measures in past and current\nAndroid implementations work together to mitigate these threats. There are some\nspecial cases in applying the security model, and we discuss such deliberate\ndeviations from the abstract model.\n", "versions": [{"version": "v1", "created": "Thu, 11 Apr 2019 08:20:07 GMT"}, {"version": "v2", "created": "Mon, 14 Dec 2020 19:15:42 GMT"}], "update_date": "2020-12-16", "authors_parsed": [["Mayrhofer", "Ren\u00e9", ""], ["Stoep", "Jeffrey Vander", ""], ["Brubaker", "Chad", ""], ["Kralevich", "Nick", ""]]}, {"id": "1904.09984", "submitter": "Moo-Ryong Ra", "authors": "Moo-Ryong Ra and Hee Won Lee", "title": "IOArbiter: Dynamic Provisioning of Backend Block Storage in the Cloud", "comments": "7 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  With the advent of virtualization technology, cloud computing realizes\non-demand computing. The capability of dynamic resource provisioning is a\nfundamental driving factor for users to adopt the cloud technology. The aspect\nis important for cloud service providers to optimize the expense for running\nthe infrastructure as well. Despite many technological advances in related\nareas, however, it is still the case that the infrastructure providers must\ndecide hardware configuration before deploying a cloud infrastructure,\nespecially from the storage's perspective. This static nature of the storage\nprovisioning practice can cause many problems in meeting tenant requirements,\nwhich often come later into the picture. In this paper, we propose a system\ncalled IOArbiter that enables the dynamic creation of underlying storage\nimplementation in the cloud. IOArbiter defers storage provisioning to the time\nat which a tenant actually requests a storage space. As a result, an underlying\nstorage implementation, e.g., RAID-5, 6 or Ceph storage pool with 6+3 erasure\ncoding, will be materialized at the volume creation time. Using our prototype\nimplementation with Openstack Cinder, we show that IOArbiter can simultaneously\nsatisfy a number of different tenant demands, which may not be possible with a\nstatic configuration strategy. Additionally QoS mechanisms such as admission\ncontrol and dynamic throttling help the system mitigate a noisy neighbor\nproblem significantly.\n", "versions": [{"version": "v1", "created": "Tue, 23 Apr 2019 14:14:49 GMT"}], "update_date": "2019-04-24", "authors_parsed": [["Ra", "Moo-Ryong", ""], ["Lee", "Hee Won", ""]]}, {"id": "1904.11560", "submitter": "Morteza Hoseinzadeh", "authors": "Morteza Hoseinzadeh", "title": "A Survey on Tiering and Caching in High-Performance Storage Systems", "comments": "Ph.D. Research Exam Report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Although every individual invented storage technology made a big step towards\nperfection, none of them is spotless. Different data store essentials such as\nperformance, availability, and recovery requirements have not met together in a\nsingle economically affordable medium, yet. One of the most influential factors\nis price. So, there has always been a trade-off between having a desired set of\nstorage choices and the costs. To address this issue, a network of various\ntypes of storing media is used to deliver the high performance of expensive\ndevices such as solid state drives and non-volatile memories, along with the\nhigh capacity of inexpensive ones like hard disk drives. In software, caching\nand tiering are long-established concepts for handling file operations and\nmoving data automatically within such a storage network and manage data backup\nin low-cost media. Intelligently moving data around different devices based on\nthe needs is the key insight for this matter. In this survey, we discuss some\nrecent pieces of research that have been done to improve high-performance\nstorage systems with caching and tiering techniques.\n", "versions": [{"version": "v1", "created": "Thu, 25 Apr 2019 19:57:31 GMT"}], "update_date": "2019-04-29", "authors_parsed": [["Hoseinzadeh", "Morteza", ""]]}, {"id": "1904.12595", "submitter": "Rohan Garg", "authors": "Rohan Garg, Gregory Price, Gene Cooperman", "title": "MANA for MPI: MPI-Agnostic Network-Agnostic Transparent Checkpointing", "comments": "24 pages; 9 figures; accepted at HPDC-2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Transparently checkpointing MPI for fault tolerance and load balancing is a\nlong-standing problem in HPC. The problem has been complicated by the need to\nprovide checkpoint-restart services for all combinations of an MPI\nimplementation over all network interconnects. This work presents MANA\n(MPI-Agnostic Network-Agnostic transparent checkpointing), a single code base\nwhich supports all MPI implementation and interconnect combinations. The\nagnostic properties imply that one can checkpoint an MPI application under one\nMPI implementation and perhaps over TCP, and then restart under a second MPI\nimplementation over InfiniBand on a cluster with a different number of CPU\ncores per node. This technique is based on a novel \"split-process\" approach,\nwhich enables two separate programs to co-exist within a single process with a\nsingle address space. This work overcomes the limitations of the two most\nwidely adopted transparent checkpointing solutions, BLCR and DMTCP/InfiniBand,\nwhich require separate modifications to each MPI implementation and/or\nunderlying network API. The runtime overhead is found to be insignificant both\nfor checkpoint-restart within a single host, and when comparing a local MPI\ncomputation that was migrated to a remote cluster against an ordinary MPI\ncomputation running natively on that same remote cluster.\n", "versions": [{"version": "v1", "created": "Sat, 20 Apr 2019 16:11:54 GMT"}], "update_date": "2019-04-30", "authors_parsed": [["Garg", "Rohan", ""], ["Price", "Gregory", ""], ["Cooperman", "Gene", ""]]}]