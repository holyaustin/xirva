[{"id": "1401.6100", "submitter": "K. Eric Harper", "authors": "K. Eric Harper and Thijmen de Gooijer", "title": "Performance Impact of Lock-Free Algorithms on Multicore Communication\n  APIs", "comments": "17 pages, 8 figures, 36 references, Embedded World Conference 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.OS cs.PF cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Data race conditions in multi-tasking software applications are prevented by\nserializing access to shared memory resources, ensuring data consistency and\ndeterministic behavior. Traditionally tasks acquire and release locks to\nsynchronize operations on shared memory. Unfortunately, lock management can add\nsignificant processing overhead especially for multicore deployments where\ntasks on different cores convoy in queues waiting to acquire a lock.\nImplementing more than one lock introduces the risk of deadlock and using\nspinlocks constrains which cores a task can run on. The better alternative is\nto eliminate locks and validate that real-time properties are met, which is not\ndirectly considered in many embedded applications. Removing the locks is\nnon-trivial and packaging lock-free algorithms for developers reduces the\npossibility of concurrency defects. This paper details how a multicore\ncommunication API implementation is enhanced to support lock-free messaging and\nthe impact this has on data exchange latency between tasks. Throughput and\nlatency are compared on Windows and Linux between lock-based and lock-free\nimplementations for data exchange of messages, packets, and scalars. A model of\nthe lock-free exchange predicts performance at the system architecture level\nand provides a stop criterion for the refactoring. The results show that\nmigration from single to multicore hardware architectures degrades lock-based\nperformance, and increases lock-free performance.\n", "versions": [{"version": "v1", "created": "Thu, 9 Jan 2014 00:04:41 GMT"}], "update_date": "2014-01-24", "authors_parsed": [["Harper", "K. Eric", ""], ["de Gooijer", "Thijmen", ""]]}, {"id": "1401.6726", "submitter": "Earlence T Fernandes", "authors": "Earlence Fernandes, Alexander Crowell, Ajit Aluri and Atul Prakash", "title": "Anception: Application Virtualization For Android", "comments": "University of Michigan, Technical Report CSE-TR-583-13", "journal-ref": null, "doi": null, "report-no": "CSE-TR-583-13", "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of malware has become significant on Android devices. Library\noperating systems and application virtualization are both possible solutions\nfor confining malware. Unfortunately, such solutions do not exist for Android.\nDesigning mechanisms for application virtualization is a significant chal-\nlenge for several reasons: (1) graphics performance is important due to\npopularity of games and (2) applications with the same UID can share state.\nThis paper presents Anception, the first flexible application virtualization\nframework for Android. It is imple- mented as a modification to the Android\nkernel and supports application virtualization that addresses the above\nrequirements. Anception is able to confine many types of malware while\nsupporting unmodified Android applications. Our Anception- based system\nexhibits up to 3.9% overhead on various 2D/3D benchmarks, and 1.8% overhead on\nthe SunSpider benchmark.\n", "versions": [{"version": "v1", "created": "Mon, 27 Jan 2014 03:01:33 GMT"}], "update_date": "2014-01-28", "authors_parsed": [["Fernandes", "Earlence", ""], ["Crowell", "Alexander", ""], ["Aluri", "Ajit", ""], ["Prakash", "Atul", ""]]}]