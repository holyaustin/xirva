[{"id": "1711.02258", "submitter": "Gyeongyeol Choi", "authors": "Youjip Won, Jaemin Jung, Gyeongyeol Choi, Joontaek Oh, Seongbae Son,\n  Jooyoung Hwang, and Sangyeun Cho", "title": "Barrier Enabled IO Stack for Flash Storage", "comments": "15 pages, 15 figures, 71 references", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work is dedicated to eliminating the overhead of guaranteeing the\nstorage order in modern IO stack. The existing block device adopts\nprohibitively expensive resort in ensuring the storage order among write\nrequests: interleaving successive write requests with transfer and flush.\nExploiting the cache barrier command for the Flash storage, we overhaul the IO\nscheduler, the dispatch module and the filesystem so that these layers are\norchestrated to preserve the ordering condition imposed by the application can\nbe delivered to the storage. Key ingredients of Barrier Enabled IO stack are\nEpoch based IO scheduling, Order Preserving Dispatch, and Dual Mode Journaling.\nBarrier enabled IO stack successfully eliminates the root cause of excessive\noverhead in enforcing the storage order. Dual Mode Journaling in BarrierFS\ndedicates the separate threads to effectively decouple the control plane and\ndata plane of the journal commit. We implement Barrier Enabled IO Stack in\nserver as well as in mobile platform. SQLite performance increases by 270% and\n75%, in server and in smartphone, respectively. Relaxing the durability of a\ntransaction, SQLite performance and MySQL performance increases as much as by\n73X and by 43X, respectively, in server storage.\n", "versions": [{"version": "v1", "created": "Tue, 7 Nov 2017 02:09:09 GMT"}], "update_date": "2017-11-08", "authors_parsed": [["Won", "Youjip", ""], ["Jung", "Jaemin", ""], ["Choi", "Gyeongyeol", ""], ["Oh", "Joontaek", ""], ["Son", "Seongbae", ""], ["Hwang", "Jooyoung", ""], ["Cho", "Sangyeun", ""]]}, {"id": "1711.02294", "submitter": "Dinesh Subhraveti", "authors": "Dinesh Subhraveti, Sri Goli, Serge Hallyn, Ravi Chamarthy, Christos\n  Kozyrakis", "title": "AppSwitch: Resolving the Application Identity Crisis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Networked applications traditionally derive their identity from the identity\nof the host on which they run. The default application identity acquired from\nthe host results in subtle and substantial problems related to application\ndeployment, discovery and access, especially for modern distributed\napplications. A number of mechanisms and workarounds, often quite elaborate,\nare used to address those problems but they only address them indirectly and\nincompletely.\n  This paper presents AppSwitch, a novel transport layer network element that\ndecouples applications from underlying network at the system call layer and\nenables them to be identified independently of the network. Without requiring\nchanges to existing applications or infrastructure, it removes the cost and\ncomplexity associated with operating distributed applications while offering a\nnumber of benefits including an efficient implementation of common network\nfunctions such as application firewall and load balancer. Experiments with our\nimplementation show that AppSwitch model also effectively removes the\nperformance penalty associated with unnecessary data path processing that is\ntypical in those application environments.\n", "versions": [{"version": "v1", "created": "Tue, 7 Nov 2017 05:41:15 GMT"}, {"version": "v2", "created": "Wed, 8 Nov 2017 19:08:26 GMT"}], "update_date": "2017-11-10", "authors_parsed": [["Subhraveti", "Dinesh", ""], ["Goli", "Sri", ""], ["Hallyn", "Serge", ""], ["Chamarthy", "Ravi", ""], ["Kozyrakis", "Christos", ""]]}, {"id": "1711.04030", "submitter": "Zhen Huang", "authors": "Zhen Huang and David Lie", "title": "Ocasta: Clustering Configuration Settings For Error Recovery", "comments": "Published in Proceedings of the 44th Annual IEEE/IFIP International\n  Conference on Dependable Systems and Networks (DSN 2014)", "journal-ref": "44th Annual IEEE/IFIP International Conference on Dependable\n  Systems and Networks, 2014, pages={479-490}", "doi": "10.1109/DSN.2014.51", "report-no": null, "categories": "cs.SE cs.LG cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Effective machine-aided diagnosis and repair of configuration errors\ncontinues to elude computer systems designers. Most of the literature targets\nerrors that can be attributed to a single erroneous configuration setting.\nHowever, a recent study found that a significant amount of configuration errors\nrequire fixing more than one setting together. To address this limitation,\nOcasta statistically clusters dependent configuration settings based on the\napplication's accesses to its configuration settings and utilizes the extracted\nclustering of configuration settings to fix configuration errors involving more\nthan one configuration settings. Ocasta treats applications as black-boxes and\nonly relies on the ability to observe application accesses to their\nconfiguration settings.\n  We collected traces of real application usage from 24 Linux and 5 Windows\ndesktops computers and found that Ocasta is able to correctly identify clusters\nwith 88.6% accuracy. To demonstrate the effectiveness of Ocasta, we evaluated\nit on 16 real-world configuration errors of 11 Linux and Windows applications.\nOcasta is able to successfully repair all evaluated configuration errors in 11\nminutes on average and only requires the user to examine an average of 3\nscreenshots of the output of the application to confirm that the error is\nrepaired. A user study we conducted shows that Ocasta is easy to use by both\nexpert and non-expert users and is more efficient than manual configuration\nerror troubleshooting.\n", "versions": [{"version": "v1", "created": "Thu, 2 Nov 2017 15:45:05 GMT"}], "update_date": "2017-11-15", "authors_parsed": [["Huang", "Zhen", ""], ["Lie", "David", ""]]}, {"id": "1711.04808", "submitter": "Monowar Hasan", "authors": "Monowar Hasan, Sibin Mohan, Rodolfo Pellizzoni, Rakesh B. Bobba", "title": "A Design-Space Exploration for Allocating Security Tasks in Multicore\n  Real-Time Systems", "comments": "Accepted for publication, 21st DATE (Design, Automation & Test in\n  Europe) conference, 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The increased capabilities of modern real-time systems (RTS) expose them to\nvarious security threats. Recently, frameworks that integrate security tasks\nwithout perturbing the real-time tasks have been proposed, but they only target\nsingle core systems. However, modern RTS are migrating towards multicore\nplatforms. This makes the problem of integrating security mechanisms more\ncomplex, as designers now have multiple choices for where to allocate the\nsecurity tasks. In this paper we propose HYDRA, a design space exploration\nalgorithm that finds an allocation of security tasks for multicore RTS using\nthe concept of opportunistic execution. HYDRA allows security tasks to operate\nwith existing real-time tasks without perturbing system parameters or normal\nexecution patterns, while still meeting the desired monitoring frequency for\nintrusion detection. Our evaluation uses a representative real-time control\nsystem (along with synthetic task sets for a broader exploration) to illustrate\nthe efficacy of HYDRA.\n", "versions": [{"version": "v1", "created": "Mon, 13 Nov 2017 19:30:22 GMT"}], "update_date": "2017-11-15", "authors_parsed": [["Hasan", "Monowar", ""], ["Mohan", "Sibin", ""], ["Pellizzoni", "Rodolfo", ""], ["Bobba", "Rakesh B.", ""]]}, {"id": "1711.07278", "submitter": "Benjamin Hof", "authors": "Benjamin Hof and Georg Carle", "title": "Software Distribution Transparency and Auditability", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A large user base relies on software updates provided through package\nmanagers. This provides a unique lever for improving the security of the\nsoftware update process. We propose a transparency system for software updates\nand implement it for a widely deployed Linux package manager, namely APT. Our\nsystem is capable of detecting targeted backdoors without producing overhead\nfor maintainers. In addition, in our system, the availability of source code is\nensured, the binding between source and binary code is verified using\nreproducible builds, and the maintainer responsible for distributing a specific\npackage can be identified. We describe a novel \"hidden version\" attack against\ncurrent software transparency systems and propose as well as integrate a\nsuitable defense. To address equivocation attacks by the transparency log\nserver, we introduce tree root cross logging, where the log's Merkle tree root\nis submitted into a separately operated log server. This significantly relaxes\nthe inter-operator cooperation requirements compared to other systems. Our\nimplementation is evaluated by replaying over 3000 updates of the Debian\noperating system over the course of two years, demonstrating its viability and\nidentifying numerous irregularities.\n", "versions": [{"version": "v1", "created": "Mon, 20 Nov 2017 12:17:23 GMT"}], "update_date": "2017-11-21", "authors_parsed": [["Hof", "Benjamin", ""], ["Carle", "Georg", ""]]}, {"id": "1711.08139", "submitter": "Magnus Jahnen", "authors": "Magnus Jahnen", "title": "Implementation of an Android Framework for USB storage access without\n  root rights", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This bachelor thesis describes the implementation of an Android framework to\naccess mass storage devices over the USB interface of a smartphone. First the\nbasics of USB (i.e. interfaces, endpoints and USB On the go) and accessing USB\ndevices via the official Android API are discussed. Next the USB mass storage\nclass is explained, which was de- signed by the USB-IF to access mobile mass\nstorage like USB pen drives or external HDDs. For communication with mass\nstorage devices, most important are the bulk-only transfer and the SCSI\ntransparent command set. Furthermore file systems, for accessing directo- ries\nand files, are described. This thesis focuses on the FAT32 file system from\nMicrosoft, because it is the most commonly used file system on such devices.\nAfter the theory part it is time to look at the implementation of the\nframework. In this section, the first concern is the purpose in general. Then\nthe architecture of the framework and the actual implementation are presented.\nImportant parts are discussed in detail. The thesis finishes with an overview\nof the test results on various Android devices, a short conclusion and an\noutlook to future developments. Moreover the current status of the developed\nframework is visualized.\n", "versions": [{"version": "v1", "created": "Wed, 22 Nov 2017 05:47:15 GMT"}], "update_date": "2017-11-23", "authors_parsed": [["Jahnen", "Magnus", ""]]}, {"id": "1711.08495", "submitter": "Harini Dananjani Kolamunna Ms", "authors": "Harini Kolamunna, Kanchana Thilakarathna, Diego Perino, Dwight\n  Makaroff, Aruna Seneviratne", "title": "Seamless Resources Sharing in Wearable Networks by Application Function\n  Virtualization", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS cs.NI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The prevalence of smart wearable devices is increasing exponentially and we\nare witnessing a wide variety of fascinating new services that leverage the\ncapabilities of these wearables. Wearables are truly changing the way mobile\ncomputing is deployed and mobile applications are being developed. It is\npossible to leverage the capabilities such as connectivity, processing, and\nsensing of wearable devices in an adaptive manner for efficient resource usage\nand information accuracy within the personal area network. We show that\napplication developers are not yet taking advantage of these cross-device\ncapabilities, however, instead using wearables as passive sensors or simple end\ndisplays to provide notifications to the user. We thus design AFV (Application\nFunction Virtualization), an architecture enabling automated dynamic function\nvirtualization and scheduling across devices in a personal area network,\nsimplifying the development of the apps that are adaptive to context changes.\nAFV provides a simple set of APIs hiding complex architectural tasks from app\ndevelopers whilst continuously monitoring the user, device and network context,\nto enable the adaptive invocation of functions across devices. We show the\nfeasibility of our design by implementing AFV on Android, and the benefits for\nthe user in terms of resource efficiency, especially in saving energy\nconsumption, and quality of experience with multiple use cases.\n", "versions": [{"version": "v1", "created": "Tue, 14 Nov 2017 21:28:19 GMT"}], "update_date": "2017-11-27", "authors_parsed": [["Kolamunna", "Harini", ""], ["Thilakarathna", "Kanchana", ""], ["Perino", "Diego", ""], ["Makaroff", "Dwight", ""], ["Seneviratne", "Aruna", ""]]}]