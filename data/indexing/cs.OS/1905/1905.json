[{"id": "1905.02529", "submitter": "Gabriel Radanne", "authors": "Gabriel Radanne, Thomas Gazagnaire, Anil Madhavapeddy, Jeremy Yallop,\n  Richard Mortier, Hannes Mehnert, Mindy Preston, David Scott", "title": "Programming Unikernels in the Large via Functor Driven Development", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compiling applications as unikernels allows them to be tailored to diverse\nexecution environments. Dependency on a monolithic operating system is replaced\nwith linkage against libraries that provide specific services. Doing so in\npractice has revealed a major barrier: managing the configuration matrix across\nheterogenous execution targets. A realistic unikernel application depends on\nhundreds of libraries, each of which may place different demands on the\ndifferent target execution platforms (e.g.,~cryptographic acceleration).\n  We propose a modular approach to structuring large scale codebases that\ncleanly separates configuration, application and operating system logic. Our\nimplementation is built on the \\mirage unikernel framework, using the \\ocaml\nlanguage's powerful abstraction and metaprogramming facilities. Leveraging\nmodules allows us to build many components independently, with only loose\ncoupling through a set of standardised signatures. Components can be\nparameterized by other components and composed. Our approach accounts for\nstate, dependency ordering, and error management, and our usage over the years\nhas demonstrated significant efficiency benefits by leveraging compiler\nfeatures such as global link-time optimisation during the configuration\nprocess. We describe our application architecture and experiences via some\npractical applications of our approach, and discuss how library development in\n\\mirage can facilitate adoption in other unikernel frameworks and programming\nlanguages.\n", "versions": [{"version": "v1", "created": "Tue, 7 May 2019 13:09:32 GMT"}], "update_date": "2019-05-08", "authors_parsed": [["Radanne", "Gabriel", ""], ["Gazagnaire", "Thomas", ""], ["Madhavapeddy", "Anil", ""], ["Yallop", "Jeremy", ""], ["Mortier", "Richard", ""], ["Mehnert", "Hannes", ""], ["Preston", "Mindy", ""], ["Scott", "David", ""]]}, {"id": "1905.05975", "submitter": "Salessawi Ferede Yitbarek", "authors": "Salessawi Ferede Yitbarek, Todd Austin", "title": "Neverland: Lightweight Hardware Extensions for Enforcing Operating\n  System Integrity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The security of applications hinges on the trustworthiness of the operating\nsystem, as applications rely on the OS to protect code and data. As a result,\nmultiple protections for safeguarding the integrity of kernel code and data are\nbeing continuously proposed and deployed. These existing protections, however,\nare far from ideal as they either provide partial protection, or require\ncomplex and high overhead hardware and software stacks.\n  In this work, we present Neverland: a low-overhead, hardware-assisted, memory\nprotection scheme that safeguards the operating system from rootkits and\nkernel-mode malware. Once the system is done booting, Neverland's hardware\ntakes away the operating system's ability to overwrite certain configuration\nregisters, as well as portions of its own physical address space that contain\nkernel code and security-critical data. Furthermore, it prohibits the CPU from\nfetching privileged code from any memory region lying outside the physical\naddresses assigned to the OS kernel and drivers (regardless of virtual page\npermissions). This combination of protections makes it extremely hard for an\nattacker to tamper with the kernel or introduce new privileged code into the\nsystem -- even in the presence of kernel vulnerabilities. Our evaluations show\nthat the extra hardware required to support these protections incurs minimal\nsilicon and energy overheads. Neverland enables operating systems to reduce\ntheir attack surface without having to rely on complex integrity monitoring\nsoftware or hardware.\n", "versions": [{"version": "v1", "created": "Wed, 15 May 2019 06:54:55 GMT"}], "update_date": "2019-05-16", "authors_parsed": [["Yitbarek", "Salessawi Ferede", ""], ["Austin", "Todd", ""]]}, {"id": "1905.09543", "submitter": "Igor Korkin", "authors": "Igor Korkin", "title": "MemoryRanger Prevents Hijacking FILE_OBJECT Structures in Windows Kernel", "comments": "10 pages, 5 figures. Korkin, I. (2019, May 15-16). MemoryRanger\n  Prevents Hijacking FILE_OBJECT Structures in Windows Kernel. Paper presented\n  at the Proceedings of the 14th annual Conference on Digital Forensics,\n  Security and Law (CDFSL), Embry-Riddle Aeronautical University, Daytona\n  Beach, Florida, USA. Retrieved from\n  https://commons.erau.edu/adfsl/2019/paper-presentation/7/", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Windows OS kernel memory is one of the main targets of cyber-attacks. By\nlaunching such attacks, hackers are succeeding in process privilege escalation\nand tampering with users data by accessing kernel mode memory. This paper\nconsiders a new example of such an attack, which results in access to the files\nopened in an exclusive mode. Windows built-in security features prevent such\nlegal access, but attackers can circumvent them by patching dynamically\nallocated objects. The research shows that the Windows 10, version 1809 x64 is\nvulnerable to this attack. The paper provides an example of using MemoryRanger,\na hypervisor-based solution to prevent such attack by running kernel-mode\ndrivers in isolated kernel memory enclaves.\n", "versions": [{"version": "v1", "created": "Thu, 23 May 2019 08:57:45 GMT"}], "update_date": "2019-05-31", "authors_parsed": [["Korkin", "Igor", ""]]}, {"id": "1905.10141", "submitter": "Enis Ulqinaku", "authors": "Enis Ulqinaku and Julinda Stefa and Alessandro Mei", "title": "Scan-and-Pay on Android is Dangerous", "comments": "Published in Infocom MobiSec Workshop 2019, Paris, France", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.HC cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Mobile payments have increased significantly in the recent years and\none-to-one money transfers are offered by a wide variety of smartphone\napplications. These applications usually support scan-and-pay -- a technique\nthat allows a payer to easily scan the destination address of the payment\ndirectly from the payee's smartphone screen. This technique is pervasive\nbecause it does not require any particular hardware, only the camera, which is\npresent on all modern smartphones. However, in this work we show that a\nmalicious application can exploit the overlay feature on Android to compromise\nthe integrity of transactions that make use of the scan-and-pay technique. We\nimplement Malview, a proof-of-concept malicious application that runs in the\nbackground on the payee's smartphone and show that it succeeds in redirecting\npayments to a malicious wallet. We analyze the weaknesses of the current\ndefense mechanisms and discuss possible countermeasures against the attack.\n", "versions": [{"version": "v1", "created": "Fri, 24 May 2019 10:49:49 GMT"}], "update_date": "2019-05-27", "authors_parsed": [["Ulqinaku", "Enis", ""], ["Stefa", "Julinda", ""], ["Mei", "Alessandro", ""]]}, {"id": "1905.10818", "submitter": "David Dice", "authors": "Dave Dice and Alex Kogan", "title": "Avoiding Scalability Collapse by Restricting Concurrency", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Saturated locks often degrade the performance of a multithreaded application,\nleading to a so-called scalability collapse problem. This problem arises when a\ngrowing number of threads circulating through a saturated lock causes the\noverall application performance to fade or even drop abruptly. This problem is\nparticularly (but not solely) acute on oversubscribed systems (systems with\nmore threads than available hardware cores). In this paper, we introduce GCR\n(generic concurrency restriction), a mechanism that aims to avoid the\nscalability collapse. GCR, designed as a generic, lock-agnostic wrapper,\nintercepts lock acquisition calls, and decides when threads would be allowed to\nproceed with the acquisition of the underlying lock. Furthermore, we present\nGCR-NUMA, a non-uniform memory access (NUMA)-aware extension of GCR, that\nstrives to ensure that threads allowed to acquire the lock are those that run\non the same socket. The extensive evaluation that includes more than two dozen\nlocks, three machines and three benchmarks shows that GCR brings substantial\nspeedup (in many cases, up to three orders of magnitude) in case of contention\nand growing thread counts, while introducing nearly negligible slowdown when\nthe underlying lock is not contended. GCR-NUMA brings even larger performance\ngains starting at even lighter lock contention.\n", "versions": [{"version": "v1", "created": "Sun, 26 May 2019 15:38:30 GMT"}, {"version": "v2", "created": "Thu, 11 Jul 2019 23:15:30 GMT"}], "update_date": "2019-07-15", "authors_parsed": [["Dice", "Dave", ""], ["Kogan", "Alex", ""]]}, {"id": "1905.11788", "submitter": "Andreas Schmidt", "authors": "Stefan Reif and Andreas Schmidt and Timo H\\\"onig and Thorsten Herfet\n  and Wolfgang Schr\\\"oder-Preikschat", "title": "$\\Delta$elta: Differential Energy-Efficiency, Latency, and Timing\n  Analysis for Real-Time Networks", "comments": null, "journal-ref": null, "doi": "10.1145/3314206.3314211", "report-no": null, "categories": "cs.NI cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The continuously increasing degree of automation in many areas (e.g.\nmanufacturing engineering, public infrastructure) lead to the construction of\ncyber-physical systems and cyber-physical networks. To both, time and energy\nare the most critical operating resources. Considering for instance the Tactile\nInternet specification, end-to-end latencies in these systems must be below\n1ms, which means that both communication and system latencies are in the same\norder of magnitude and must be predictably low. As control loops are commonly\nhandled over different variants of network infrastructure (e.g. mobile and\nfibre links) particular attention must be payed to the design of reliable, yet\nfast and energy-efficient data-transmission channels that are robust towards\nunexpected transmission failures. As design goals are often conflicting (e.g.\nhigh performance vs. low energy), it is necessary to analyze and investigate\ntrade-offs with regards to design decisions during the construction of\ncyber-physical networks. In this paper, we present $\\Delta$elta, an approach\ntowards a tool-supported construction process for cyber-physical networks.\n$\\Delta$elta extends the previously presented X-Lap tool by new analysis\nfeatures, but keeps the original measurements facilities unchanged.\n$\\Delta$elta jointly analyzes and correlates the runtime behavior (i.e.\nperformance, latency) and energy demand of individual system components. It\nprovides an automated analysis with precise thread-local time interpolation,\ncontrol-flow extraction, and examination of latency criticality. We further\ndemonstrate the applicability of $\\Delta$elta with an evaluation of a\nprototypical implementation.\n", "versions": [{"version": "v1", "created": "Tue, 28 May 2019 13:09:06 GMT"}], "update_date": "2019-05-29", "authors_parsed": [["Reif", "Stefan", ""], ["Schmidt", "Andreas", ""], ["H\u00f6nig", "Timo", ""], ["Herfet", "Thorsten", ""], ["Schr\u00f6der-Preikschat", "Wolfgang", ""]]}, {"id": "1905.12974", "submitter": "Anirban Chakraborty", "authors": "Anirban Chakraborty and Sarani Bhattacharya and Sayandeep Saha and\n  Debdeep Mukhopadhyay", "title": "ExplFrame: Exploiting Page Frame Cache for Fault Analysis of Block\n  Ciphers", "comments": "7 pages, 4 figues", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Page Frame Cache (PFC) is a purely software cache, present in modern Linux\nbased operating systems (OS), which stores the page frames that are recently\nbeing released by the processes running on a particular CPU. In this paper, we\nshow that the page frame cache can be maliciously exploited by an adversary to\nsteer the pages of a victim process to some pre-decided attacker-chosen\nlocations in the memory. We practically demonstrate an end-to-end attack,\nExplFrame, where an attacker having only user-level privilege is able to force\na victim process's memory pages to vulnerable locations in DRAM and\ndeterministically conduct Rowhammer to induce faults. We further show that\nthese faults can be exploited for extracting the secret key of table-based\nblock cipher implementations. As a case study, we perform a full-key recovery\non OpenSSL AES by Rowhammer-induced single bit faults in the T-tables. We\npropose an improvised fault analysis technique which can exploit any\nRowhammer-induced bit-flips in the AES T-tables.\n", "versions": [{"version": "v1", "created": "Thu, 30 May 2019 11:37:37 GMT"}, {"version": "v2", "created": "Thu, 13 Jun 2019 10:22:45 GMT"}, {"version": "v3", "created": "Wed, 12 Feb 2020 10:51:12 GMT"}], "update_date": "2020-02-13", "authors_parsed": [["Chakraborty", "Anirban", ""], ["Bhattacharya", "Sarani", ""], ["Saha", "Sayandeep", ""], ["Mukhopadhyay", "Debdeep", ""]]}]