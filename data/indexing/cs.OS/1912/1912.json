[{"id": "1912.00580", "submitter": "Pulkit Misra", "authors": "Pulkit A. Misra and Jeffrey S. Chase and Johannes Gehrke and Alvin R.\n  Lebeck", "title": "Multi-version Indexing in Flash-based Key-Value Stores", "comments": "7 pages, 6 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Maintaining multiple versions of data is popular in key-value stores since it\nincreases concurrency and improves performance. However, designing a\nmulti-version key-value store entails several challenges, such as additional\ncapacity for storing extra versions and an indexing mechanism for mapping\nversions of a key to their values. We present SkimpyFTL, a FTL-integrated\nmulti-version key-value store that exploits the remap-on-write property of\nflash-based SSDs for multi-versioning and provides a tradeoff between memory\ncapacity and lookup latency for indexing.\n", "versions": [{"version": "v1", "created": "Mon, 2 Dec 2019 05:05:39 GMT"}], "update_date": "2019-12-03", "authors_parsed": [["Misra", "Pulkit A.", ""], ["Chase", "Jeffrey S.", ""], ["Gehrke", "Johannes", ""], ["Lebeck", "Alvin R.", ""]]}, {"id": "1912.01161", "submitter": "Werner Grass", "authors": "Thi Huyen Chau Nguyen, Werner Grass, and Klaus Jansen", "title": "Exact Polynomial Time Algorithm for the Response Time Analysis of\n  Harmonic Tasks with Constrained Release Jitter", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In some important application areas of hard real-time systems, preemptive\nsporadic tasks with harmonic periods and constraint deadlines running upon a\nuni-processor platform play an important role. We propose a new algorithm for\ndetermining the exact worst-case response time for a task that has a lower\ncomputational complexity (linear in the number of tasks) than the known\nalgorithm developed for the same system class. We also allow the task\nexecutions to start delayed due to release jitter if they are within certain\nvalue ranges. For checking if these constraints are met we define a constraint\nprogramming problem that has a special structure and can be solved with\nheuristic components in a time that is linear in the task number. If the check\ndetermines the admissibility of the jitter values, the linear time algorithm\ncan be used to determine the worst-case response time also for jitter-aware\nsystems.\n", "versions": [{"version": "v1", "created": "Sat, 30 Nov 2019 09:12:12 GMT"}], "update_date": "2019-12-04", "authors_parsed": [["Nguyen", "Thi Huyen Chau", ""], ["Grass", "Werner", ""], ["Jansen", "Klaus", ""]]}, {"id": "1912.03490", "submitter": "Roberto Natella", "authors": "Domenico Cotroneo, Antonio Ken Iannillo, Roberto Natella, Stefano\n  Rosiello", "title": "Dependability Assessment of the Android OS through Fault Injection", "comments": null, "journal-ref": "IEEE Transactions on Reliability, 2019", "doi": "10.1109/TR.2019.2954384", "report-no": null, "categories": "cs.SE cs.OS", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  The reliability of mobile devices is a challenge for vendors, since the\nmobile software stack has significantly grown in complexity. In this paper, we\nstudy how to assess the impact of faults on the quality of user experience in\nthe Android mobile OS through fault injection. We first address the problem of\nidentifying a realistic fault model for the Android OS, by providing to\ndevelopers a set of lightweight and systematic guidelines for fault modeling.\nThen, we present an extensible fault injection tool (AndroFIT) to apply such\nfault model on actual, commercial Android devices. Finally, we present a large\nfault injection experimentation on three Android products from major vendors,\nand point out several reliability issues and opportunities for improving the\nAndroid OS.\n", "versions": [{"version": "v1", "created": "Sat, 7 Dec 2019 11:44:37 GMT"}], "update_date": "2019-12-10", "authors_parsed": [["Cotroneo", "Domenico", ""], ["Iannillo", "Antonio Ken", ""], ["Natella", "Roberto", ""], ["Rosiello", "Stefano", ""]]}, {"id": "1912.03923", "submitter": "Gabriel Moreau", "authors": "Nicolas Gibelin (GRICAD), R\\'emi Cailletaud (OSUG), Gabriel Moreau\n  (LEGI), Jean-Fran\\c{c}ois Scariot, Gabrielle Feltin (GRICAD), Anthony Defize\n  (GRICAD)", "title": "Nova -- A rainbow cloud over the Alps", "comments": "Vid{\\'e}o\n  https://replay.jres.org/videos/watch/c0ce8c10-fc41-4cf7-9069-9d2c225f9e0a ,\n  in French, Congr\\`es JRES : Les Journ\\'ees R\\'eseaux de l'Enseignement et de\n  la Recherche, RENATER, Dec 2019, Dijon, France", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A pooled and shared on-demand Infrastructure as a Service (IaaS), based on\nthe Openstack software suite, was rolled out on the Grenoble university campus\nin 2018 and updated in 2019.We present the methods used to deploy and manage\nthe infrastructure: racadm and preseed for basic system installation, then\nKolla for Openstack deployment. This latter solution, based on containers for\neach service, enables a centralised and logged configuration (GitLab) of\ncontrollers and calculation nodes. The solution is the benchmark solution for a\nreproducible deployment of Openstack. We have been able to expand our cloud\neasily with new nodes. The change in version of the basic OS was also\nsuccessfully tested despite a few small hitches... As security is a key element\nin the proper operation of this type of shared service, each project has been\nmade watertight and its data perfectly isolated from other projects, thanks to\nthe encryption of all network flows in VXLANs.This OpenStack infotainment\nplatform is operational. What is it all for? For example, our first users use\nthe Jupyter Notebook through the provision of Jupyterhub servers (web portal);\nthe Distributed Health Assessment IT System (SIDES project); the continuous\nintegration in connection with the GitLab platform; the test for the Kubernetes\ncontainer scheduler or the calculation and visualisation software, etc. Highly\nvaried uses that other platforms had difficulty offering.Nova, a new platform,\nwas born.\n", "versions": [{"version": "v1", "created": "Mon, 9 Dec 2019 09:39:31 GMT"}], "update_date": "2019-12-10", "authors_parsed": [["Gibelin", "Nicolas", "", "GRICAD"], ["Cailletaud", "R\u00e9mi", "", "OSUG"], ["Moreau", "Gabriel", "", "LEGI"], ["Scariot", "Jean-Fran\u00e7ois", "", "GRICAD"], ["Feltin", "Gabrielle", "", "GRICAD"], ["Defize", "Anthony", "", "GRICAD"]]}, {"id": "1912.06863", "submitter": "Ronny Chevalier", "authors": "Ronny Chevalier, David Plaquin, Chris Dalton, Guillaume Hiet", "title": "Survivor: A Fine-Grained Intrusion Response and Recovery Approach for\n  Commodity Operating Systems", "comments": "The final version of this paper has been published in the Proceedings\n  of the 35th Annual Computer Security Applications Conference (ACSAC), 2019.\n  14 pages, 5 figures, 6 tables", "journal-ref": "Proceedings of the 35th Annual Computer Security Applications\n  Conference. ACM, 2019. p. 762-775", "doi": "10.1145/3359789.3359792", "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Despite the deployment of preventive security mechanisms to protect the\nassets and computing platforms of users, intrusions eventually occur. We\npropose a novel intrusion survivability approach to withstand ongoing\nintrusions. Our approach relies on an orchestration of fine-grained recovery\nand per-service responses (e.g., privileges removal). Such an approach may put\nthe system into a degraded mode. This degraded mode prevents attackers to\nreinfect the system or to achieve their goals if they managed to reinfect it.\nIt maintains the availability of core functions while waiting for patches to be\ndeployed. We devised a cost-sensitive response selection process to ensure that\nwhile the service is in a degraded mode, its core functions are still\noperating. We built a Linux-based prototype and evaluated the effectiveness of\nour approach against different types of intrusions. The results show that our\nsolution removes the effects of the intrusions, that it can select appropriate\nresponses, and that it allows services to survive when reinfected. In terms of\nperformance overhead, in most cases, we observed a small overhead, except in\nthe rare case of services that write many small files asynchronously in a\nburst, where we observed a higher but acceptable overhead.\n", "versions": [{"version": "v1", "created": "Sat, 14 Dec 2019 15:17:00 GMT"}], "update_date": "2019-12-17", "authors_parsed": [["Chevalier", "Ronny", ""], ["Plaquin", "David", ""], ["Dalton", "Chris", ""], ["Hiet", "Guillaume", ""]]}, {"id": "1912.06998", "submitter": "Myoungsoo Jung", "authors": "Sungjoon Koh, Junhyeok Jang, Changrim Lee, Miryeong Kwon, Jie Zhang\n  and Myoungsoo Jung", "title": "Faster than Flash: An In-Depth Study of System Challenges for Emerging\n  Ultra-Low Latency SSDs", "comments": "12 pages, 23 figures, 2019 IEEE International Symposium on Workload\n  Characterization", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Emerging storage systems with new flash exhibit ultra-low latency (ULL) that\ncan address performance disparities between DRAM and conventional solid state\ndrives (SSDs) in the memory hierarchy. Considering the advanced low-latency\ncharacteristics, different types of I/O completion methods (polling/hybrid) and\nstorage stack architecture (SPDK) are proposed. While these new techniques are\nexpected to take costly software interventions off the critical path in\nULL-applied systems, unfortunately no study exists to quantitatively analyze\nsystem-level characteristics and challenges of combining such newly-introduced\ntechniques with real ULL SSDs. In this work, we comprehensively perform\nempirical evaluations with 800GB ULL SSD prototypes and characterize ULL\nbehaviors by considering a wide range of I/O path parameters, such as different\nqueues and access patterns. We then analyze the efficiencies and challenges of\nthe polled-mode and hybrid polling I/O completion methods (added into Linux\nkernels 4.4 and 4.10, respectively) and compare them with the efficiencies of a\nconventional interrupt-based I/O path. In addition, we revisit the common\nexpectations of SPDK by examining all the system resources and parameters.\nFinally, we demonstrate the challenges of ULL SSDs in a real SPDK-enabled\nserver-client system. Based on the performance behaviors that this study\nuncovers, we also discuss several system implications, which are required to\ntake a full advantage of ULL SSD in the future.\n", "versions": [{"version": "v1", "created": "Sun, 15 Dec 2019 08:09:31 GMT"}], "update_date": "2019-12-17", "authors_parsed": [["Koh", "Sungjoon", ""], ["Jang", "Junhyeok", ""], ["Lee", "Changrim", ""], ["Kwon", "Miryeong", ""], ["Zhang", "Jie", ""], ["Jung", "Myoungsoo", ""]]}, {"id": "1912.10367", "submitter": "Vincent Gramoli", "authors": "Gauthier Voron and Vincent Gramoli", "title": "Dispel: Byzantine SMR with Distributed Pipelining", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.DC cs.OS", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Byzantine State Machine Replication (SMR) is a long studied topic that\nreceived increasing attention recently with the advent of blockchains as\ncompanies are trying to scale them to hundreds of nodes. Byzantine SMRs try to\nincrease throughput by either reducing the latency of consensus instances that\nthey run sequentially or by reducing the number of replicas that send messages\nto others in order to reduce the network usage. Unfortunately, the former\napproach makes use of resources in burst whereas the latter requires\nCPU-intensive authentication mechanisms.\n  In this paper, we propose a new Byzantine SMR called Dispel (Distributed\nPipeline) that allows any node to distributively start new consensus instances\nwhenever they detect sufficient resources locally. We evaluate the performance\nof Dispel within a single datacenter and across up to 380 machines over 3\ncontinents by comparing it against four other SMRs. On 128 nodes, Dispel speeds\nup HotStuff, the Byzantine fault tolerant SMR being integrated within\nFacebook's blockchain, by more than 12 times. In addition, we also test Dispel\nunder isolated and correlated failures and show that the Dispel distributed\ndesign is more robust than HotStuff. Finally, we evaluate Dispel in a\ncryptocurrency application with Bitcoin transactions and show that this SMR is\nnot the bottleneck.\n", "versions": [{"version": "v1", "created": "Sun, 22 Dec 2019 00:58:54 GMT"}, {"version": "v2", "created": "Fri, 12 Jun 2020 09:57:12 GMT"}], "update_date": "2020-06-15", "authors_parsed": [["Voron", "Gauthier", ""], ["Gramoli", "Vincent", ""]]}, {"id": "1912.10666", "submitter": "Yutian Yang", "authors": "Yutian Yang, Songbo Zhu, Wenbo Shen, Yajin Zhou, Jiadong Sun, and Kui\n  Ren", "title": "ARM Pointer Authentication based Forward-Edge and Backward-Edge Control\n  Flow Integrity for Kernels", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Code reuse attacks are still big threats to software and system security.\nControl flow integrity is a promising technique to defend against such attacks.\nHowever, its effectiveness has been weakened due to the inaccurate control flow\ngraph and practical strategy to trade security for performance. In recent\nyears, CPU vendors have integrated hardware features as countermeasures. For\ninstance, ARM Pointer Authentication (PA in short) was introduced in ARMV8-A\narchitecture. It can efficiently generate an authentication code for an\naddress, which is encoded in the unused bits of the address. When the address\nis de-referenced, the authentication code is checked to ensure its integrity.\nThough there exist systems that adopt PA to harden user programs, how to\neffectively use PA to protect OS kernels is still an open research question.\n  In this paper, we shed lights on how to leverage PA to protect control flows,\nincluding function pointers and return addresses, of Linux kernel.\nSpecifically, to protect function pointers, we embed authentication code into\nthem, track their propagation and verify their values when loading from memory\nor branching to targets. To further defend against the pointer substitution\nattack, we use the function pointer address as its context, and take a clean\ndesign to propagate the address by piggybacking it into the pointer value. We\nhave implemented a prototype system with LLVM to identify function pointers,\nadd authentication code and verify function pointers by emitting new machine\ninstructions. We applied this system to Linux kernel, and solved numerous\npractical issues, e.g., function pointer comparison and arithmetic operations.\nThe security analysis shows that our system can protect all function pointers\nand return addresses in Linux kernel.\n", "versions": [{"version": "v1", "created": "Mon, 23 Dec 2019 07:58:04 GMT"}, {"version": "v2", "created": "Mon, 12 Oct 2020 06:33:43 GMT"}], "update_date": "2020-10-13", "authors_parsed": [["Yang", "Yutian", ""], ["Zhu", "Songbo", ""], ["Shen", "Wenbo", ""], ["Zhou", "Yajin", ""], ["Sun", "Jiadong", ""], ["Ren", "Kui", ""]]}, {"id": "1912.10959", "submitter": "Waqar Ali", "authors": "Waqar Ali and Rodolfo Pellizzoni and Heechul Yun", "title": "Virtual Gang based Scheduling of Real-Time Tasks on Multicore Platforms", "comments": "23 pages, 9 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a virtual-gang based parallel real-time task scheduling approach\nfor multicore platforms. Our approach is based on the notion of a virtual-gang,\nwhich is a group of parallel real-time tasks that are statically linked and\nscheduled together by a gang scheduler. We present a light-weight intra-gang\nsynchronization framework, called RTG-Sync, and virtual gang formation\nalgorithms that provide strong temporal isolation and high real-time\nschedulability in scheduling real-time tasks on multicore. We evaluate our\napproach both analytically, with generated tasksets against state-of-the-art\napproaches, and empirically with a case-study involving real-world workloads on\na real embedded multicore platform. The results show that our approach provides\nsimple but powerful compositional analysis framework, achieves better analytic\nschedulability, especially when the effect of interference is considered, and\nis a practical solution for COTS multicore platforms.\n", "versions": [{"version": "v1", "created": "Mon, 23 Dec 2019 16:36:23 GMT"}, {"version": "v2", "created": "Thu, 27 Feb 2020 19:48:02 GMT"}], "update_date": "2020-03-02", "authors_parsed": [["Ali", "Waqar", ""], ["Pellizzoni", "Rodolfo", ""], ["Yun", "Heechul", ""]]}]