[{"id": "1508.04753", "submitter": "Gerhard Dueck", "authors": "Kim T. Briggs, Baoguo Zhou, Gerhard W. Dueck", "title": "Cold Object Identification in the Java Virtual Machine", "comments": "For submission to `Software: Practice and Experience'", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many Java applications instantiate objects within the Java heap that are\npersistent but seldom if ever referenced by the application. Examples include\nstrings, such as error messages, and collections of value objects that are\npreloaded for fast access but they may include objects that are seldom\nreferenced. This paper describes a stack-based framework for detecting these\n\"cold\" objects at runtime, with a view to marshaling and sequestering them in\ndesignated regions of the heap where they may be preferentially paged out to a\nbacking store, thereby freeing physical memory pages for occupation by more\nactive objects. Furthermore, we evaluate the correctness and efficiency of\nstack-based approach with an Access Barrier. The experimental results from a\nseries of SPECjvm2008 benchmarks are presented.\n", "versions": [{"version": "v1", "created": "Tue, 18 Aug 2015 19:50:17 GMT"}], "update_date": "2015-08-20", "authors_parsed": [["Briggs", "Kim T.", ""], ["Zhou", "Baoguo", ""], ["Dueck", "Gerhard W.", ""]]}, {"id": "1508.05228", "submitter": "Michael Hanspach", "authors": "Wolfgang Schmidt, Michael Hanspach, J\\\"org Keller", "title": "A Case Study on Covert Channel Establishment via Software Caches in\n  High-Assurance Computing Systems", "comments": "12 pages, based upon the master's thesis of Schmidt", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Covert channels can be utilized to secretly deliver information from high\nprivileged processes to low privileged processes in the context of a\nhigh-assurance computing system. In this case study, we investigate the\npossibility of covert channel establishment via software caches in the context\nof a framework for component-based operating systems. While component-based\noperating systems offer security through the encapsulation of system service\nprocesses, complete isolation of these processes is not reasonably feasible.\nThis limitation is practically demonstrated with our concept of a specific\ncovert timing channel based on file system caching. The stability of the covert\nchannel is evaluated and a methodology to disrupt the covert channel\ntransmission is presented. While these kinds of attacks are not limited to\nhigh-assurance computing systems, our study practically demonstrates that even\nsecurity-focused computing systems with a minimal trusted computing base are\nvulnerable for such kinds of attacks and careful design decisions are necessary\nfor secure operating system architectures.\n", "versions": [{"version": "v1", "created": "Fri, 21 Aug 2015 09:59:27 GMT"}], "update_date": "2015-08-24", "authors_parsed": [["Schmidt", "Wolfgang", ""], ["Hanspach", "Michael", ""], ["Keller", "J\u00f6rg", ""]]}, {"id": "1508.06356", "submitter": "Yan Cui", "authors": "Yan Cui, Quan Chen and Junfeng Yang", "title": "EOS: Automatic In-vivo Evolution of Kernel Policies for Better\n  Performance", "comments": "14 pages, technique report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Today's monolithic kernels often implement a small, fixed set of policies\nsuch as disk I/O scheduling policies, while exposing many parameters to let\nusers select a policy or adjust the specific setting of the policy. Ideally,\nthe parameters exposed should be flexible enough for users to tune for good\nperformance, but in practice, users lack domain knowledge of the parameters and\nare often stuck with bad, default parameter settings.\n  We present EOS, a system that bridges the knowledge gap between kernel\ndevelopers and users by automatically evolving the policies and parameters in\nvivo on users' real, production workloads. It provides a simple policy\nspecification API for kernel developers to programmatically describe how the\npolicies and parameters should be tuned, a policy cache to make in-vivo tuning\neasy and fast by memorizing good parameter settings for past workloads, and a\nhierarchical search engine to effectively search the parameter space.\nEvaluation of EOS on four main Linux subsystems shows that it is easy to use\nand effectively improves each subsystem's performance.\n", "versions": [{"version": "v1", "created": "Wed, 26 Aug 2015 03:43:38 GMT"}, {"version": "v2", "created": "Sun, 18 Oct 2015 04:50:29 GMT"}], "update_date": "2015-10-20", "authors_parsed": [["Cui", "Yan", ""], ["Chen", "Quan", ""], ["Yang", "Junfeng", ""]]}, {"id": "1508.06367", "submitter": "Sorav Bansal", "authors": "Piyus Kedia and Sorav Bansal", "title": "A Software-only Mechanism for Device Passthrough and Sharing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Network processing elements in virtual machines, also known as Network\nFunction Virtualization (NFV) often face CPU bottlenecks at the virtualization\ninterface. Even highly optimized paravirtual device interfaces fall short of\nthe throughput requirements of modern devices. Passthrough devices, together\nwith SR-IOV support for multiple device virtual functions (VF) and IOMMU\nsupport, mitigate this problem somewhat, by allowing a VM to directly control a\ndevice partition bypassing the virtualization stack. However, device\npassthrough requires high-end (expensive and power-hungry) hardware, places\nscalability limits on consolidation ratios, and does not support efficient\nswitching between multiple VMs on the same host.\n  We present a paravirtual interface that securely exposes an I/O device\ndirectly to the guest OS running inside the VM, and yet allows that device to\nbe securely shared among multiple VMs and the host. Compared to the best-known\nparavirtualization interfaces, our paravirtual interface supports up to 2x\nhigher throughput, and is closer in performance to device passthrough. Unlike\ndevice passthrough however, we do not require SR-IOV or IOMMU support, and\nallow fine-grained dynamic resource allocation, significantly higher\nconsolidation ratios, and seamless VM migration. Our security mechanism is\nbased on a novel approach called dynamic binary opcode subtraction.\n", "versions": [{"version": "v1", "created": "Wed, 26 Aug 2015 05:20:50 GMT"}, {"version": "v2", "created": "Thu, 22 Sep 2016 10:38:29 GMT"}], "update_date": "2016-09-23", "authors_parsed": [["Kedia", "Piyus", ""], ["Bansal", "Sorav", ""]]}, {"id": "1508.07127", "submitter": "Chun-Hsian Huang", "authors": "Chun-Hsian Huang, Kwuan-Wei Tseng, Chih-Cheng Lin, Fang-Yu Lin,\n  Pao-Ann Hsiung", "title": "Virtualization Architecture for NoC-based Reconfigurable Systems", "comments": "Presented at Second International Workshop on FPGAs for Software\n  Programmers (FSP 2015) (arXiv:1508.06320)", "journal-ref": null, "doi": null, "report-no": "FSP/2015/14", "categories": "cs.AR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a virtualization architecture for NoC-based reconfigurable\nsystems. The motivation of this work is to develop a service-oriented\narchitecture that includes Partial Reconfigurable Region as a Service (PRRaaS)\nand Processing Element as a Service (PEaaS) for software applications.\nAccording to the requirements of software applications, new PEs can be created\non-demand by (re)configuring the logic resource of the PRRs in the FPGA, while\nthe configured PEs can also be virtualized to support multiple application\ntasks at the same time. As a result, such a two-level virtualization mechanism,\nincluding the gate-level virtualization and the PE-level virtualization,\nenables an SoC to be dynamically adapted to changing application requirements.\nTherefore, more software applications can be performed, and system performance\ncan be further enhanced.\n", "versions": [{"version": "v1", "created": "Fri, 28 Aug 2015 08:45:35 GMT"}], "update_date": "2015-08-31", "authors_parsed": [["Huang", "Chun-Hsian", ""], ["Tseng", "Kwuan-Wei", ""], ["Lin", "Chih-Cheng", ""], ["Lin", "Fang-Yu", ""], ["Hsiung", "Pao-Ann", ""]]}]