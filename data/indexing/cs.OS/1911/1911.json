[{"id": "1911.08367", "submitter": "Reto Achermann", "authors": "Simon Gerber, Gerd Zellweger, Reto Achermann, Moritz Hoffmann,\n  Kornilios Kourtis, Timothy Roscoe, Dejan Milojicic", "title": "Cichlid: Explicit physical memory management for large machines", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we rethink how an OS supports virtual memory. Classical VM is\nan opaque abstraction of RAM, backed by demand paging. However, most systems\ntoday (from phones to data-centers) do not page, and indeed may require the\nperformance benefits of non-paged physical memory, precise NUMA allocation,\netc. Moreover, MMU hardware is now useful for other purposes, such as detecting\npage access or providing large page translation. Accordingly, the venerable VM\nabstraction in OSes like Windows and Linux has acquired a plethora of extra\nAPIs to poke at the policy behind the illusion of a virtual address space.\n  Instead, we present Cichlid, a memory system which inverts this model.\nApplications explicitly manage their physical RAM of different types, and\ndirectly (though safely) program the translation hardware. Cichlid is\nimplemented in Barrelfish, requires no virtualization support, and outperforms\nVMM-based approaches for all but the smallest working sets. We show that\nCichlid enables use-cases for virtual memory not possible in Linux today, and\nother use-cases are simple to program and significantly faster.\n", "versions": [{"version": "v1", "created": "Tue, 19 Nov 2019 15:56:46 GMT"}], "update_date": "2019-11-20", "authors_parsed": [["Gerber", "Simon", ""], ["Zellweger", "Gerd", ""], ["Achermann", "Reto", ""], ["Hoffmann", "Moritz", ""], ["Kourtis", "Kornilios", ""], ["Roscoe", "Timothy", ""], ["Milojicic", "Dejan", ""]]}, {"id": "1911.08773", "submitter": "Roni Haecki", "authors": "Roni Haecki, Lukas Humbel, Reto Achermann, David Cock, Daniel Schwyn,\n  Timothy Roscoe", "title": "CleanQ: a lightweight, uniform, formally specified interface for\n  intra-machine data transfer", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present CleanQ, a high-performance operating-system interface for\ndescriptor-based data transfer with rigorous formal semantics, based on a\nsimple, formally-verified notion of ownership transfer, with a fast reference\nimplementation. CleanQ aims to replace the current proliferation of similar,\nbut subtly diverse, and loosely specified, descriptor-based interfaces in OS\nkernels and device drivers. CleanQ has strict semantics that not only clarify\nboth the implementation of the interface for different hardware devices and\nsoftware usecases, but also enable composition of modules as in more\nheavyweight frameworks like Unix streams. We motivate CleanQ by showing that\nloose specifications derived from implementation lead to security and\ncorrectness bugs in production systems that a clean, formal, and\neasilyunderstandable abstraction helps eliminate. We further demonstrate by\nexperiment that there is negligible performance cost for a clean design: we\nshow overheads in the tens of cycles for operations, and comparable end-to-end\nperformance to the highly-tuned Virtio and DPDK implementations on Linux.\n", "versions": [{"version": "v1", "created": "Wed, 20 Nov 2019 08:57:09 GMT"}], "update_date": "2019-11-21", "authors_parsed": [["Haecki", "Roni", ""], ["Humbel", "Lukas", ""], ["Achermann", "Reto", ""], ["Cock", "David", ""], ["Schwyn", "Daniel", ""], ["Roscoe", "Timothy", ""]]}, {"id": "1911.09829", "submitter": "Hasan Al Maruf", "authors": "Hasan Al Maruf, Mosharaf Chowdhury", "title": "Effectively Prefetching Remote Memory with Leap", "comments": null, "journal-ref": "2020 USENIX Annual Technical Conference, USENIX ATC 2020, July\n  15-17, pages: 843--857", "doi": null, "report-no": null, "categories": "cs.DC cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Memory disaggregation over RDMA can improve the performance of\nmemory-constrained applications by replacing disk swapping with remote memory\naccesses. However, state-of-the-art memory disaggregation solutions still use\ndata path components designed for slow disks. As a result, applications\nexperience remote memory access latency significantly higher than that of the\nunderlying low-latency network, which itself is too high for many applications.\n  In this paper, we propose Leap, a prefetching solution for remote memory\naccesses due to memory disaggregation. At its core, Leap employs an online,\nmajority-based prefetching algorithm, which increases the page cache hit rate.\nWe complement it with a lightweight and efficient data path in the kernel that\nisolates each application's data path to the disaggregated memory and mitigates\nlatency bottlenecks arising from legacy throughput-optimizing operations.\nIntegration of Leap in the Linux kernel improves the median and tail remote\npage access latencies of memory-bound applications by up to 104.04x and 22.62x,\nrespectively, over the default data path. This leads to up to 10.16x\nperformance improvements for applications using disaggregated memory in\ncomparison to the state-of-the-art solutions.\n", "versions": [{"version": "v1", "created": "Fri, 22 Nov 2019 03:29:52 GMT"}], "update_date": "2020-10-20", "authors_parsed": [["Maruf", "Hasan Al", ""], ["Chowdhury", "Mosharaf", ""]]}, {"id": "1911.11937", "submitter": "Monowar Hasan", "authors": "Monowar Hasan, Sibin Mohan, Rodolfo Pellizzoni, Rakesh B. Bobba", "title": "Period Adaptation for Continuous Security Monitoring in Multicore\n  Real-Time Systems", "comments": "Accepted for publication DATE 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a design-time framework (named HYDRA-C) for integrating security\ntasks into partitioned real-time systems (RTS) running on multicore platforms.\nOur goal is to opportunistically execute security monitoring mechanisms in a\n'continuous' manner -- i.e., as often as possible, across cores, to ensure that\nsecurity tasks run with as few interruptions as possible. Our framework will\nallow designers to integrate security mechanisms without perturbing existing\nreal-time (RT) task properties or execution order. We demonstrate the framework\nusing a proof-of-concept implementation with intrusion detection mechanisms as\nsecurity tasks. We develop and use both, (a) a custom intrusion detection\nsystem (IDS), as well as (b) Tripwire -- an open source data integrity checking\ntool. These are implemented on a realistic rover platform designed using an ARM\nmulticore chip. We compare the performance of HYDRA-C with a state-of-the-art\nRT security integration approach for multicore-based RTS and find that our\nmethod can, on average, detect intrusions 19.05% faster without impacting the\nperformance of RT tasks.\n", "versions": [{"version": "v1", "created": "Wed, 27 Nov 2019 03:52:34 GMT"}, {"version": "v2", "created": "Sat, 14 Mar 2020 14:58:13 GMT"}], "update_date": "2020-03-17", "authors_parsed": [["Hasan", "Monowar", ""], ["Mohan", "Sibin", ""], ["Pellizzoni", "Rodolfo", ""], ["Bobba", "Rakesh B.", ""]]}, {"id": "1911.13208", "submitter": "Lei Liu", "authors": "Lei Liu", "title": "QoS-Aware Machine Learning-based Multiple Resources Scheduling for\n  Microservices in Cloud Environment", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.LG cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Microservices have been dominating in the modern cloud environment. To\nimprove cost efficiency, multiple microservices are normally co-located on a\nserver. Thus, the run-time resource scheduling becomes the pivot for QoS\ncontrol. However, the scheduling exploration space enlarges rapidly with the\nincreasing server resources - cores, cache, bandwidth, etc. - and the diversity\nof microservices. Consequently, the existing schedulers might not meet the\nrapid changes in service demands. Besides, we observe that there exist resource\ncliffs in the scheduling space. It not only impacts the exploration efficiency,\nmaking it difficult to converge to the optimal scheduling solution, but also\nresults in severe QoS fluctuation. To overcome these problems, we propose a\nnovel machine learning-based scheduling mechanism called OSML. It uses\nresources and runtime states as the input and employs two MLP models and a\nreinforcement learning model to perform scheduling space exploration. Thus,\nOSML can reach an optimal solution much faster than traditional approaches.\nMore importantly, it can automatically detect the resource cliff and avoid them\nduring exploration. To verify the effectiveness of OSML and obtain a\nwell-generalized model, we collect a dataset containing over 2-billion samples\nfrom 11 typical microservices running on real servers over 9 months. Under the\nsame QoS constraint, experimental results show that OSML outperforms the\nstate-of-the-art work, and achieves around 5 times scheduling speed.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 21:05:00 GMT"}, {"version": "v2", "created": "Mon, 2 Dec 2019 08:29:41 GMT"}], "update_date": "2019-12-03", "authors_parsed": [["Liu", "Lei", ""]]}]