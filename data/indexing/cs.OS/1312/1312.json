[{"id": "1312.1810", "submitter": "Brijender Kahanwal Dr.", "authors": "Brijender Kahanwal, Tejinder Pal Singh, Ruchira Bhargava, and Girish\n  Pal Singh", "title": "File System - A Component of Operating System", "comments": "5 pages, 3 figures, 1 table", "journal-ref": "Asian Journal of Computer Science and Information Technology 2(5),\n  pp. 124-128, 2012", "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The file system provides the mechanism for online storage and access to file\ncontents, including data and programs. This paper covers the high-level details\nof file systems, as well as related topics such as the disk cache, the file\nsystem interface to the kernel, and the user-level APIs that use the features\nof the file system. It will give you a thorough understanding of how a file\nsystem works in general. The main component of the operating system is the file\nsystem. It is used to create, manipulate, store, and retrieve data. At the\nhighest level, a file system is a way to manage information on a secondary\nstorage medium. There are so many layers under and above the file system. All\nthe layers are to be fully described here. This paper will give the explanatory\nknowledge of the file system designers and the researchers in the area. The\ncomplete path from the user process to secondary storage device is to be\nmentioned. File system is the area where the researchers are doing lot of job\nand there is always a need to do more work. The work is going on for the\nefficient, secure, energy saving techniques for the file systems. As we know\nthat the hardware is going to be fast in performance and low-priced day by day.\nThe software is not built to comeback with the hardware technology. So there is\na need to do research in this area to bridge the technology gap.\n", "versions": [{"version": "v1", "created": "Fri, 6 Dec 2013 09:18:04 GMT"}], "update_date": "2013-12-09", "authors_parsed": [["Kahanwal", "Brijender", ""], ["Singh", "Tejinder Pal", ""], ["Bhargava", "Ruchira", ""], ["Singh", "Girish Pal", ""]]}, {"id": "1312.1822", "submitter": "Brijender Kahanwal Dr.", "authors": "Brijender Kahanwal, Tejinder Pal Singh", "title": "Towards the Framework of the File Systems Performance Evaluation\n  Techniques and the Taxonomy of Replay Traces", "comments": "7 pages", "journal-ref": "International Journal of Advanced Research in Computer Science,\n  2(6) pp. 224-229, 2011", "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is the era of High Performance Computing (HPC). There is a great demand\nof the best performance evaluation techniques for the file and storage systems.\nThe task of evaluation is both necessary and hard. It gives in depth analysis\nof the target system and that becomes the decision points for the users. That\nis also helpful for the inventors or developers to find out the bottleneck in\ntheir systems. In this paper many performance evaluation techniques are\ndescribed for file and storage system evaluation and the main stress is given\non the important one that is replay traces. A survey has been done for the\nperformance evaluation techniques used by the researchers and on the replay\ntraces. And the taxonomy of the replay traces is described. The some of the\npopular replay traces are just like, Tracefs [1], //Trace [2], Replayfs [3] and\nVFS Interceptor [12]. At last we have concluded all the features that must be\nconsidered when we are going to develop the new tool for the replay traces. The\ncomplete work of this paper shows that the storage system developers must care\nabout all the techniques which can be used for the performance evaluation of\nthe file systems. So they can develop highly efficient future file and storage\nsystems.\n", "versions": [{"version": "v1", "created": "Fri, 6 Dec 2013 10:20:38 GMT"}], "update_date": "2013-12-09", "authors_parsed": [["Kahanwal", "Brijender", ""], ["Singh", "Tejinder Pal", ""]]}, {"id": "1312.3665", "submitter": "David Wolinsky", "authors": "David Isaac Wolinsky and Bryan Ford", "title": "Managing NymBoxes for Identity and Tracking Protection", "comments": "16 pages, 7 figure, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Despite the attempts of well-designed anonymous communication tools to\nprotect users from tracking or identification, flaws in surrounding software\n(such as web browsers) and mistakes in configuration may leak the user's\nidentity. We introduce Nymix, an anonymity-centric operating system\narchitecture designed \"top-to-bottom\" to strengthen identity- and\ntracking-protection. Nymix's core contribution is OS support for nym-browsing:\nindependent, parallel, and ephemeral web sessions. Each web session, or\npseudonym, runs in a unique virtual machine (VM) instance evolving from a\ncommon base state with support for long-lived sessions which can be anonymously\nstored to the cloud, avoiding de-anonymization despite potential confiscation\nor theft. Nymix allows a user to safely browse the Web using various different\ntransports simultaneously through a pluggable communication model that supports\nTor, Dissent, and a private browsing mode. In evaluations, Nymix consumes 600\nMB per nymbox and loads within 15 to 25 seconds.\n", "versions": [{"version": "v1", "created": "Thu, 12 Dec 2013 22:38:08 GMT"}, {"version": "v2", "created": "Mon, 5 May 2014 16:05:35 GMT"}], "update_date": "2014-05-06", "authors_parsed": [["Wolinsky", "David Isaac", ""], ["Ford", "Bryan", ""]]}, {"id": "1312.3938", "submitter": "Jiajun Cao", "authors": "Jiajun Cao, Gregory Kerr, Kapil Arya, Gene Cooperman", "title": "Transparent Checkpoint-Restart over InfiniBand", "comments": "22 pages, 2 figures, 9 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  InfiniBand is widely used for low-latency, high-throughput cluster computing.\nSaving the state of the InfiniBand network as part of distributed checkpointing\nhas been a long-standing challenge for researchers. Because of a lack of a\nsolution, typical MPI implementations have included custom checkpoint-restart\nservices that \"tear down\" the network, checkpoint each node as if the node were\na standalone computer, and then re-connect the network again. We present the\nfirst example of transparent, system-initiated checkpoint-restart that directly\nsupports InfiniBand. The new approach is independent of any particular Linux\nkernel, thus simplifying the current practice of using a kernel-based module,\nsuch as BLCR. This direct approach results in checkpoints that are found to be\nfaster than with the use of a checkpoint-restart service. The generality of\nthis approach is shown not only by checkpointing an MPI computation, but also a\nnative UPC computation (Berkeley Unified Parallel C), which does not use MPI.\nScalability is shown by checkpointing 2,048 MPI processes across 128 nodes\n(with 16 cores per node). In addition, a cost-effective debugging approach is\nalso enabled, in which a checkpoint image from an InfiniBand-based production\ncluster is copied to a local Ethernet-based cluster, where it can be restarted\nand an interactive debugger can be attached to it. This work is based on a\nplugin that extends the DMTCP (Distributed MultiThreaded CheckPointing)\ncheckpoint-restart package.\n", "versions": [{"version": "v1", "created": "Fri, 13 Dec 2013 20:53:39 GMT"}, {"version": "v2", "created": "Mon, 16 Dec 2013 07:41:11 GMT"}, {"version": "v3", "created": "Thu, 30 Jan 2014 21:39:39 GMT"}], "update_date": "2014-02-03", "authors_parsed": [["Cao", "Jiajun", ""], ["Kerr", "Gregory", ""], ["Arya", "Kapil", ""], ["Cooperman", "Gene", ""]]}, {"id": "1312.4509", "submitter": "Mathieu Jan", "authors": "Lilia Zaourar (LIST), Mathieu Jan (LIST), Maurice Pitel", "title": "Cache-aware static scheduling for hard real-time multicore systems based\n  on communication affinities", "comments": null, "journal-ref": "34th IEEE Real-Time Systems Symposium (RTSS'13), WiP session,\n  Vancouver : Canada (2013)", "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The growing need for continuous processing capabilities has led to the\ndevelopment of multicore systems with a complex cache hierarchy. Such multicore\nsystems are generally designed for improving the performance in average case,\nwhile hard real-time systems must consider worst-case scenarios. An open\nchallenge is therefore to efficiently schedule hard real-time tasks on a\nmulticore architecture. In this work, we propose a mathematical formulation for\ncomputing a static scheduling that minimize L1 data cache misses between hard\nreal-time tasks on a multicore architecture using communication affinities.\n", "versions": [{"version": "v1", "created": "Mon, 16 Dec 2013 20:32:52 GMT"}], "update_date": "2013-12-17", "authors_parsed": [["Zaourar", "Lilia", "", "LIST"], ["Jan", "Mathieu", "", "LIST"], ["Pitel", "Maurice", ""]]}, {"id": "1312.4931", "submitter": "Ardalan Amiri Sani", "authors": "Ardalan Amiri Sani, Kevin Boos, Min Hong Yun, Lin Zhong", "title": "Rio: A System Solution for Sharing I/O between Mobile Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": "Rice University ECE Technical Report 2013-12-17", "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Mobile systems are equipped with a diverse collection of I/O devices,\nincluding cameras, microphones, sensors, and modems. There exist many novel use\ncases for allowing an application on one mobile system to utilize I/O devices\nfrom another. This paper presents Rio, an I/O sharing solution that supports\nunmodified applications and exposes all the functionality of an I/O device for\nsharing. Rio's design is common to many classes of I/O devices, thus\nsignificantly reducing the engineering effort to support new I/O devices. Our\nimplementation of Rio on Android consists of 6700 total lines of code and\nsupports four I/O classes with fewer than 450 class-specific lines of code. Rio\nalso supports I/O sharing between mobile systems of different form factors,\nincluding smartphones and tablets. We show that Rio achieves performance close\nto that of local I/O for audio, sensors, and modems, but suffers noticeable\nperformance degradation for camera due to network throughput limitations\nbetween the two systems, which is likely to be alleviated by emerging wireless\nstandards.\n", "versions": [{"version": "v1", "created": "Tue, 17 Dec 2013 20:43:33 GMT"}], "update_date": "2013-12-18", "authors_parsed": [["Sani", "Ardalan Amiri", ""], ["Boos", "Kevin", ""], ["Yun", "Min Hong", ""], ["Zhong", "Lin", ""]]}, {"id": "1312.5892", "submitter": "Florian Schmidt", "authors": "Florian Schmidt, David Orlea, Klaus Wehrle", "title": "Support for Error Tolerance in the Real-Time Transport Protocol", "comments": "18 pages, 9 figures, published as technical report of the Department\n  of Computer Science of RWTH Aachen University", "journal-ref": null, "doi": null, "report-no": "AIB-2013-19", "categories": "cs.NI cs.IT cs.OS math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Streaming applications often tolerate bit errors in their received data well.\nThis is contrasted by the enforcement of correctness of the packet headers and\npayload by network protocols. We investigate a solution for the Real-time\nTransport Protocol (RTP) that is tolerant to errors by accepting erroneous\ndata. It passes potentially corrupted stream data payloads to the codecs. If\nerrors occur in the header, our solution recovers from these by leveraging the\nknown state and expected header values for each stream. The solution is fully\nreceiver-based and incrementally deployable, and as such requires neither\nsupport from the sender nor changes to the RTP specification. Evaluations show\nthat our header error recovery scheme can recover from almost all errors, with\nvirtually no erroneous recoveries, up to bit error rates of about 10%.\n", "versions": [{"version": "v1", "created": "Fri, 20 Dec 2013 11:11:54 GMT"}], "update_date": "2013-12-23", "authors_parsed": [["Schmidt", "Florian", ""], ["Orlea", "David", ""], ["Wehrle", "Klaus", ""]]}, {"id": "1312.6650", "submitter": "Samaneh Kazemi Nafchi", "authors": "Samaneh Kazemi Nafchi, Rohan Garg, Gene Cooperman", "title": "Transparent Checkpoint-Restart for Hardware-Accelerated 3D Graphics", "comments": "20 pages, 6 figures, 4 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Providing fault-tolerance for long-running GPU-intensive jobs requires\napplication-specific solutions, and often involves saving the state of complex\ndata structures spread among many graphics libraries. This work describes a\nmechanism for transparent GPU-independent checkpoint-restart of 3D graphics.\nThe approach is based on a record-prune-replay paradigm: all OpenGL calls\nrelevant to the graphics driver state are recorded; calls not relevant to the\ninternal driver state as of the last graphics frame prior to checkpoint are\ndiscarded; and the remaining calls are replayed on restart. A previous approach\nfor OpenGL 1.5, based on a shadow device driver, required more than 78,000\nlines of OpenGL-specific code. In contrast, the new approach, based on\nrecord-prune-replay, is used to implement the same case in just 4,500 lines of\ncode. The speed of this approach varies between 80 per cent and nearly 100 per\ncent of the speed of the native hardware acceleration for OpenGL 1.5, as\nmeasured when running the ioquake3 game under Linux. This approach has also\nbeen extended to demonstrate checkpointing of OpenGL 3.0 for the first time,\nwith a demonstration for PyMol, for molecular visualization.\n", "versions": [{"version": "v1", "created": "Mon, 23 Dec 2013 19:19:40 GMT"}, {"version": "v2", "created": "Mon, 3 Feb 2014 23:01:55 GMT"}], "update_date": "2014-02-05", "authors_parsed": [["Nafchi", "Samaneh Kazemi", ""], ["Garg", "Rohan", ""], ["Cooperman", "Gene", ""]]}]