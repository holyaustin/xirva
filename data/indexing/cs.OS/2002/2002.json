[{"id": "2002.06512", "submitter": "Vinod Ganapathy", "authors": "Rakesh Rajan Beck and Abhishek Vijeev and Vinod Ganapathy", "title": "Privaros: A Framework for Privacy-Compliant Delivery Drones", "comments": null, "journal-ref": null, "doi": "10.1145/3372297.3417858", "report-no": null, "categories": "cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present Privaros, a framework to enforce privacy policies on drones.\nPrivaros is designed for commercial delivery drones, such as the ones that will\nlikely be used by Amazon Prime Air. Such drones visit a number of host\nairspaces, each of which may have different privacy requirements. Privaros\nprovides an information flow control framework to enforce the policies of these\nhosts on the guest delivery drones. The mechanisms in Privaros are built on top\nof ROS, a middleware popular in many drone platforms. This paper presents the\ndesign and implementation of these mechanisms, describes how policies are\nspecified, and shows that Privaros's policy specification can be integrated\nwith India's Digital Sky portal. Our evaluation shows that a drone running\nPrivaros can robustly enforce various privacy policies specified by hosts, and\nthat its core mechanisms only marginally increase communication latency and\npower consumption.\n", "versions": [{"version": "v1", "created": "Sun, 16 Feb 2020 05:51:41 GMT"}, {"version": "v2", "created": "Wed, 5 Aug 2020 04:42:57 GMT"}, {"version": "v3", "created": "Thu, 13 Aug 2020 18:00:46 GMT"}], "update_date": "2020-08-17", "authors_parsed": [["Beck", "Rakesh Rajan", ""], ["Vijeev", "Abhishek", ""], ["Ganapathy", "Vinod", ""]]}, {"id": "2002.07515", "submitter": "Gustavo Maciel Dias Vieira", "authors": "William B. Mingardi, Gustavo M. D. Vieira", "title": "Characterizing Synchronous Writes in Stable Memory Devices", "comments": "14 pages", "journal-ref": "WPerformance '19: Proceedings of the XVIII Computer and\n  Communication Systems Workshop, SBC, 2019", "doi": "10.5753/wperformance.2019.6458", "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Distributed algorithms that operate in the fail-recovery model rely on the\nstate stored in stable memory to guarantee the irreversibility of operations\neven in the presence of failures. The performance of these algorithms lean\nheavily on the performance of stable memory. Current storage technologies have\na defined performance profile: data is accessed in blocks of hundreds or\nthousands of bytes, random access to these blocks is expensive and sequential\naccess is somewhat better. File system implementations hide some of the\nperformance limitations of the underlying storage devices using buffers and\ncaches. However, fail-recovery distributed algorithms bypass some of these\ntechniques and perform synchronous writes to be able to tolerate a failure\nduring the write itself. Assuming the distributed system designer is able to\nbuffer the algorithm's writes, we ask how buffer size and latency complement\neach other. In this paper we start to answer this question by characterizing\nthe performance (throughput and latency) of typical stable memory devices using\na representative set of current file systems.\n", "versions": [{"version": "v1", "created": "Tue, 18 Feb 2020 12:26:24 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Mingardi", "William B.", ""], ["Vieira", "Gustavo M. D.", ""]]}, {"id": "2002.08454", "submitter": "Arun Ravindran", "authors": "Anusha Bableshwar and Arun Ravindran and Manoj Iyer", "title": "A Recurrent Neural Network Based Patch Recommender for Linux Kernel Bugs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.CR cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Software bugs in a production environment have an undesirable impact on\nquality of service, unplanned system downtime, and disruption in good customer\nexperience, resulting in loss of revenue and reputation. Existing approaches to\nautomated software bug repair focuses on known bug templates detected using\nstatic code analysis tools and test suites, and in automatic generation of\npatch code for these bugs. We describe the typical bug fixing process employed\nin the Linux kernel, and motivate the need for a new automated tool flow to fix\nbugs. We present an initial design of such an automated tool that uses\nRecurrent Neural Network (RNN) based Natural Language Processing to generate\npatch recommendations from user generated bug reports. At the 50th percentile\nof the test bugs, the correct patch occurs within the top 11.5 patch\nrecommendations output by the model. Further, we present a Linux kernel\ndeveloper's assessment of the quality of patches recommended for new unresolved\nkernel bugs.\n", "versions": [{"version": "v1", "created": "Wed, 19 Feb 2020 21:35:51 GMT"}], "update_date": "2020-02-21", "authors_parsed": [["Bableshwar", "Anusha", ""], ["Ravindran", "Arun", ""], ["Iyer", "Manoj", ""]]}, {"id": "2002.08928", "submitter": "Ruslan Nikolaev", "authors": "Ruslan Nikolaev, Mincheol Sung, Binoy Ravindran", "title": "LibrettOS: A Dynamically Adaptable Multiserver-Library OS", "comments": "16th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution\n  Environments (VEE '20), March 17, 2020, Lausanne, Switzerland", "journal-ref": null, "doi": "10.1145/3381052.3381316", "report-no": null, "categories": "cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present LibrettOS, an OS design that fuses two paradigms to simultaneously\naddress issues of isolation, performance, compatibility, failure\nrecoverability, and run-time upgrades. LibrettOS acts as a microkernel OS that\nruns servers in an isolated manner. LibrettOS can also act as a library OS\nwhen, for better performance, selected applications are granted exclusive\naccess to virtual hardware resources such as storage and networking.\nFurthermore, applications can switch between the two OS modes with no\ninterruption at run-time. LibrettOS has a uniquely distinguishing advantage in\nthat, the two paradigms seamlessly coexist in the same OS, enabling users to\nsimultaneously exploit their respective strengths (i.e., greater isolation,\nhigh performance). Systems code, such as device drivers, network stacks, and\nfile systems remain identical in the two modes, enabling dynamic mode switching\nand reducing development and maintenance costs.\n  To illustrate these design principles, we implemented a prototype of\nLibrettOS using rump kernels, allowing us to reuse existent, hardened NetBSD\ndevice drivers and a large ecosystem of POSIX/BSD-compatible applications. We\nuse hardware (VM) virtualization to strongly isolate different rump kernel\ninstances from each other. Because the original rumprun unikernel targeted a\nmuch simpler model for uniprocessor systems, we redesigned it to support\nmulticore systems. Unlike kernel-bypass libraries such as DPDK, applications\nneed not be modified to benefit from direct hardware access. LibrettOS also\nsupports indirect access through a network server that we have developed.\nApplications remain uninterrupted even when network components fail or need to\nbe upgraded. Finally, to efficiently use hardware resources, applications can\ndynamically switch between the indirect and direct modes based on their I/O\nload at run-time.\n  [full abstract is in the paper]\n", "versions": [{"version": "v1", "created": "Thu, 20 Feb 2020 18:25:42 GMT"}], "update_date": "2020-02-21", "authors_parsed": [["Nikolaev", "Ruslan", ""], ["Sung", "Mincheol", ""], ["Ravindran", "Binoy", ""]]}, {"id": "2002.11528", "submitter": "Nikolas Ioannou", "authors": "Kornilios Kourtis, Animesh Trivedi, Nikolas Ioannou", "title": "Safe and Efficient Remote Application Code Execution on Disaggregated\n  NVM Storage with eBPF", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  With rapid improvements in NVM storage devices, the performance bottleneck is\ngradually shifting to the network, thus giving rise to the notion of \"data\nmovement wall\". To reduce the amount of data movement over the network,\nresearchers have proposed near-data computing by shipping operations and\ncompute-extensions closer to storage devices. However, running arbitrary,\nuser-provided extensions in a shared, disaggregated storage environment\npresents multiple challenges regarding safety, isolation, and performance.\nInstead of approaching this problem from scratch, in this work we make a case\nfor leveraging the Linux kernel eBPF framework to program disaggregated NVM\nstorage devices. eBPF offers a safe, verifiable, and high-performance way of\nexecuting untrusted, user-defined code in a shared runtime. In this paper, we\ndescribe our experiences building a first prototype that supports remote\noperations on storage using eBPF, discuss the limitations of our approach, and\ndirections for addressing them.\n", "versions": [{"version": "v1", "created": "Tue, 25 Feb 2020 13:43:53 GMT"}], "update_date": "2020-02-27", "authors_parsed": [["Kourtis", "Kornilios", ""], ["Trivedi", "Animesh", ""], ["Ioannou", "Nikolas", ""]]}, {"id": "2002.12516", "submitter": "Corey Tessler", "authors": "Corey Tessler, Venkata P. Modekurthy, Nathan Fisher, Abusayeed\n  Saifullah", "title": "Bringing Inter-Thread Cache Benefits to Federated Scheduling -- Extended\n  Results & Technical Report", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.OS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multiprocessor scheduling of hard real-time tasks modeled by directed acyclic\ngraphs (DAGs) exploits the inherent parallelism presented by the model. For DAG\ntasks, a node represents a request to execute an object on one of the available\nprocessors. In one DAG task, there may be multiple execution requests for one\nobject, each represented by a distinct node. These distinct execution requests\noffer an opportunity to reduce their combined cache overhead through\ncoordinated scheduling of objects as threads within a parallel task. The goal\nof this work is to realize this opportunity by incorporating the cache-aware\nBUNDLE-scheduling algorithm into federated scheduling of sporadic DAG task\nsets.\n  This is the first work to incorporate instruction cache sharing into\nfederated scheduling. The result is a modification of the DAG model named the\nDAG with objects and threads (DAG-OT). Under the DAG-OT model, descriptions of\nnodes explicitly include their underlying executable object and number of\nthreads. When possible, nodes assigned the same executable object are collapsed\ninto a single node; joining their threads when BUNDLE-scheduled. Compared to\nthe DAG model, the DAG-OT model with cache-aware scheduling reduces the number\nof cores allocated to individual tasks by approximately 20 percent in the\nsynthetic evaluation and up to 50 percent on a novel parallel computing\nplatform implementation. By reducing the number of allocated cores, the DAG-OT\nmodel is able to schedule a subset of previously infeasible task sets.\n", "versions": [{"version": "v1", "created": "Fri, 28 Feb 2020 02:37:26 GMT"}], "update_date": "2020-03-02", "authors_parsed": [["Tessler", "Corey", ""], ["Modekurthy", "Venkata P.", ""], ["Fisher", "Nathan", ""], ["Saifullah", "Abusayeed", ""]]}]