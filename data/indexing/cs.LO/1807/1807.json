[{"id": "1807.00331", "submitter": "Michael Blondin", "authors": "Michael Blondin, Javier Esparza, Anton\\'in Ku\\v{c}era", "title": "Automatic Analysis of Expected Termination Time for Population Protocols", "comments": "Extended version of CONCUR 2018 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Population protocols are a formal model of sensor networks consisting of\nidentical mobile devices. Two devices can interact and thereby change their\nstates. Computations are infinite sequences of interactions in which the\ninteracting devices are chosen uniformly at random.\n  In well designed population protocols, for every initial configuration of\ndevices, and for every computation starting at this configuration, all devices\neventually agree on a consensus value. We address the problem of automatically\ncomputing a parametric bound on the expected time the protocol needs to reach\nthis consensus. We present the first algorithm that, when successful, outputs a\nfunction f(n) such that the expected time to consensus is bound by O(f(n)),\nwhere n is the number of devices executing the protocol. We experimentally show\nthat our algorithm terminates and provides good bounds for many of the\nprotocols found in the literature.\n", "versions": [{"version": "v1", "created": "Sun, 1 Jul 2018 13:49:05 GMT"}], "update_date": "2018-07-03", "authors_parsed": [["Blondin", "Michael", ""], ["Esparza", "Javier", ""], ["Ku\u010dera", "Anton\u00edn", ""]]}, {"id": "1807.00614", "submitter": "Pedro Zuidberg Dos Martires", "authors": "Pedro Zuidberg Dos Martires, Anton Dries, Luc De Raedt", "title": "Knowledge Compilation with Continuous Random Variables and its\n  Application in Hybrid Probabilistic Logic Programming", "comments": "8 pages, 2 figures, StarAI", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In probabilistic reasoning, the traditionally discrete domain has been\nelevated to the hybrid domain encompassing additionally continuous random\nvariables. Inference in the hybrid domain, however, usually necessitates to\ncondone trade-offs on either the inference on discrete or continuous random\nvariables. We introduce a novel approach based on weighted model integration\nand algebraic model counting that circumvents these trade-offs. We then show\nhow it supports knowledge compilation and exact probabilistic inference.\nMoreover, we introduce the hybrid probabilistic logic programming language\nHAL-ProbLog, an extension of ProbLog, to which we apply our inference approach.\n", "versions": [{"version": "v1", "created": "Mon, 2 Jul 2018 12:04:59 GMT"}, {"version": "v2", "created": "Thu, 12 Jul 2018 13:34:35 GMT"}], "update_date": "2018-07-13", "authors_parsed": [["Martires", "Pedro Zuidberg Dos", ""], ["Dries", "Anton", ""], ["De Raedt", "Luc", ""]]}, {"id": "1807.00669", "submitter": "Cheng Su", "authors": "Yan Xiong, Cheng Su, Wenchao Huang, Fuyou Miao, Wansen Wang, Hengyi\n  Ouyang", "title": "Verifying Security Protocols using Dynamic Strategies", "comments": "arXiv admin note: text overlap with arXiv:1403.1142, arXiv:1703.00426\n  by other authors", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Current formal approaches have been successfully used to find design flaws in\nmany security protocols. However, it is still challenging to automatically\nanalyze protocols due to their large or infinite state spaces. In this paper,\nwe propose a novel framework that can automatically verifying security\nprotocols without any human intervention. Experimental results show that\nSmartVerif automatically verifies security protocols that cannot be\nautomatically verified by existing approaches. The case study also validates\nthe effectiveness of our dynamic strategy.\n", "versions": [{"version": "v1", "created": "Wed, 27 Jun 2018 00:58:10 GMT"}, {"version": "v2", "created": "Wed, 4 Jul 2018 12:07:32 GMT"}, {"version": "v3", "created": "Wed, 15 Aug 2018 06:37:26 GMT"}, {"version": "v4", "created": "Sat, 3 Nov 2018 03:03:57 GMT"}, {"version": "v5", "created": "Thu, 13 Dec 2018 09:20:02 GMT"}, {"version": "v6", "created": "Thu, 7 Mar 2019 08:48:55 GMT"}, {"version": "v7", "created": "Mon, 26 Aug 2019 02:55:04 GMT"}], "update_date": "2019-08-27", "authors_parsed": [["Xiong", "Yan", ""], ["Su", "Cheng", ""], ["Huang", "Wenchao", ""], ["Miao", "Fuyou", ""], ["Wang", "Wansen", ""], ["Ouyang", "Hengyi", ""]]}, {"id": "1807.00758", "submitter": "Christopher Hahn", "authors": "Bernd Finkbeiner, Christopher Hahn, Marvin Stenger and Leander Tentrup", "title": "Monitoring Hyperproperties", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hyperproperties, such as non-interference and observational determinism,\nrelate multiple system executions to each other. They are not expressible in\nstandard temporal logics, like LTL, CTL, and CTL*, and thus cannot be monitored\nwith standard runtime verification techniques. HyperLTL extends linear-time\ntemporal logic (LTL) with explicit quantification over traces in order to\nexpress Hyperproperties. We investigate the runtime verification problem of\nHyperLTL formulas for three different input models: (1) The parallel model,\nwhere a fixed number of system executions is processed in parallel. (2) The\nunbounded sequential model, where system executions are processed sequentially,\none execution at a time. In this model, the number of incoming executions may\ngrow forever. (3) The bounded sequential model where the traces are processed\nsequentially and the number of incoming executions is bounded. We show that\ndeciding monitorability of HyperLTL formulas is PSPACE-complete for input\nmodels (1) and (3). Deciding monitorability is PSPACE-complete for\nalternation-free HyperLTL formulas in input model (2). For every input model,\nwe provide practical monitoring algorithms. We also present various\noptimization techniques. By recognizing properties of specifications such as\nreflexivity, symmetry, and transitivity, we reduce the number of comparisons\nbetween traces. For the sequential models, we present a technique that\nminimized the number of traces that need to be stored. Finally, we provide an\noptimization that succinctly represents the stored traces by sharing common\nprefixes. We evaluate our optimizations, showing that this leads to much more\nscalable monitoring, in particular, significantly lower memory consumption.\n", "versions": [{"version": "v1", "created": "Mon, 2 Jul 2018 15:54:05 GMT"}], "update_date": "2018-07-03", "authors_parsed": [["Finkbeiner", "Bernd", ""], ["Hahn", "Christopher", ""], ["Stenger", "Marvin", ""], ["Tentrup", "Leander", ""]]}, {"id": "1807.00785", "submitter": "Nicolas Behr", "authors": "Nicolas Behr and Pawel Sobocinski", "title": "Rule Algebras for Adhesive Categories", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 3 (July 3,\n  2020) lmcs:6615", "doi": "10.23638/LMCS-16(3:2)2020", "report-no": null, "categories": "cs.LO cs.DM math.CO math.CT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We demonstrate that the most well-known approach to rewriting graphical\nstructures, the Double-Pushout (DPO) approach, possesses a notion of sequential\ncompositions of rules along an overlap that is associative in a natural sense.\nNotably, our results hold in the general setting of $\\mathcal{M}$-adhesive\ncategories. This observation complements the classical Concurrency Theorem of\nDPO rewriting. We then proceed to define rule algebras in both settings, where\nthe most general categories permissible are the finitary (or finitary\nrestrictions of) $\\mathcal{M}$-adhesive categories with $\\mathcal{M}$-effective\nunions. If in addition a given such category possess an $\\mathcal{M}$-initial\nobject, the resulting rule algebra is unital (in addition to being\nassociative). We demonstrate that in this setting a canonical representation of\nthe rule algebras is obtainable, which opens the possibility of applying the\nconcept to define and compute the evolution of statistical moments of\nobservables in stochastic DPO rewriting systems.\n", "versions": [{"version": "v1", "created": "Mon, 2 Jul 2018 16:57:33 GMT"}, {"version": "v2", "created": "Mon, 4 Feb 2019 17:17:41 GMT"}, {"version": "v3", "created": "Fri, 7 Feb 2020 13:53:28 GMT"}, {"version": "v4", "created": "Thu, 2 Jul 2020 12:54:28 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Behr", "Nicolas", ""], ["Sobocinski", "Pawel", ""]]}, {"id": "1807.00884", "submitter": "Michael Mislove", "authors": "Michael Mislove", "title": "Domains and Stochastic Processes", "comments": "arXiv admin note: substantial text overlap with arXiv:1607.07698", "journal-ref": "Theoretical Computer Science, Volume 807, 6 February 2020, Pages\n  284-297", "doi": "10.1016/j.tcs.2019.05.002", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Domain theory has a long history of applications in theoretical computer\nscience and mathematics. In this article, we explore the relation of domain\ntheory to probability theory and stochastic processes. The goal is to establish\na theory in which Polish spaces are replaced by domains, and measurable maps\nare replaced by Scott-continuous functions. We illustrate the approach by\nrecasting one of the fundamental results of stochastic process theory --\nSkorohod's Representation Theorem -- in domain-theoretic terms. We anticipate\nthe domain-theoretic version of results like Skorohod's Theorem will improve\nour understanding of probabilistic choice in computational models, and help\ndevise models of probabilistic programming, with its focus on programming\nlanguages that support sampling from distributions where the results are\napplied to Bayesian reasoning.\n", "versions": [{"version": "v1", "created": "Thu, 28 Jun 2018 01:51:14 GMT"}], "update_date": "2020-02-06", "authors_parsed": [["Mislove", "Michael", ""]]}, {"id": "1807.00940", "submitter": "Takahito Aoto", "authors": "Takahito Aoto and Yoshihito Toyama", "title": "Automated Proofs of Unique Normal Forms w.r.t. Conversion for Term\n  Rewriting Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The notion of normal forms is ubiquitous in various equivalent\ntransformations. Confluence (CR), one of the central properties of term\nrewriting systems (TRSs), concerns uniqueness of normal forms. Yet another such\nproperty, which is weaker than confluence, is the property of unique normal\nforms w.r.t. conversion (UNC). Famous examples having UNC but not CR include\nthe TRSs consisting of S,K,I-rules for the combinatory logic supplemented with\nvarious pairing rules (de Vrijer, 1999). Recently, automated confluence proof\nof TRSs has caught attentions leading to investigations of automatable methods\nfor (dis)proving CR of TRSs; some powerful confluence tools have been developed\nas well. In contrast, there have been little efforts on (dis)proving UNC\nautomatically yet. Indeed, there are few tools that are capable of (dis)proving\nUNC; furthermore, only few UNC criteria have been elaborated in these tools. In\nthis paper, we address automated methods to prove or disprove UNC of given\nTRSs. We report automation of some criteria known so far, and also present some\nnew criteria and methods for proving or disproving UNC. Presented methods are\nimplemented over the confluence prover ACP (Aoto et al., 2009) and an\nexperimental evaluation is reported.\n", "versions": [{"version": "v1", "created": "Tue, 3 Jul 2018 00:55:39 GMT"}], "update_date": "2018-07-04", "authors_parsed": [["Aoto", "Takahito", ""], ["Toyama", "Yoshihito", ""]]}, {"id": "1807.01004", "submitter": "Ian Cassar", "authors": "Luca Aceto, Ian Cassar, Adrian Francalanza, Anna Ingolfsdottir", "title": "On Runtime Enforcement via Suppressions", "comments": "38 pages", "journal-ref": null, "doi": "10.4230/LIPIcs.CONCUR.2018.34", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Runtime enforcement is a dynamic analysis technique that uses monitors to\nenforce the behaviour specified by some correctness property on an executing\nsystem. The enforceability of a logic captures the extent to which the\nproperties expressible via the logic can be enforced at runtime. We study the\nenforceability of Hennessy-Milner Logic with Recursion (muHML) with respect to\nsuppression enforcement. We develop an operational framework for enforcement\nwhich we then use to formalise when a monitor enforces a muHML property. We\nalso show that the safety syntactic fragment of the logic, sHML, is enforceable\nby providing an automated synthesis function that generates correct suppression\nmonitors from sHML formulas.\n", "versions": [{"version": "v1", "created": "Tue, 3 Jul 2018 07:47:03 GMT"}], "update_date": "2018-07-04", "authors_parsed": [["Aceto", "Luca", ""], ["Cassar", "Ian", ""], ["Francalanza", "Adrian", ""], ["Ingolfsdottir", "Anna", ""]]}, {"id": "1807.01053", "submitter": "Sergey Goncharov", "authors": "Sergey Goncharov, Julian Jakob, Renato Neves", "title": "A Semantics for Hybrid Iteration", "comments": "Corrected version of a CONCUR'18 paper; more proof details", "journal-ref": null, "doi": "10.4230/LIPIcs.CONCUR.2018.22", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The recently introduced notions of guarded traced (monoidal) category and\nguarded (pre-)iterative monad aim at unifying different instances of partial\niteration whilst keeping in touch with the established theory of total\niteration and preserving its merits. In this paper we use these notions and the\ncorresponding stock of results to examine different types of iteration for\nhybrid computations. As a starting point we use an available notion of hybrid\nmonad restricted to the category of sets, and modify it in order to obtain a\nsuitable notion of guarded iteration with guardedness interpreted as\nprogressiveness in time - we motivate this modification by our intention to\ncapture Zeno behaviour in an arguably general and feasible way. We illustrate\nour results with a simple programming language for hybrid computations and\ninterpret it over the developed semantic foundations.\n", "versions": [{"version": "v1", "created": "Tue, 3 Jul 2018 09:47:52 GMT"}, {"version": "v2", "created": "Tue, 5 Feb 2019 15:59:02 GMT"}], "update_date": "2019-02-07", "authors_parsed": [["Goncharov", "Sergey", ""], ["Jakob", "Julian", ""], ["Neves", "Renato", ""]]}, {"id": "1807.01183", "submitter": "V\\'ictor Guti\\'errez-Basulto", "authors": "V\\'ictor Guti\\'errez-Basulto, Jean Christoph Jung, Ondrej Kuzelka", "title": "Quantified Markov Logic Networks", "comments": "Paper accepted at the 16th International Conference on Principles of\n  Knowledge Representation and Reasoning (KR 2018). This work was also\n  presented in the Eighth International Workshop on Statistical Relational AI\n  (StarAI 2018) under the title \"Markov Logic Networks with Statistical\n  Quantifiers\"", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Markov Logic Networks (MLNs) are well-suited for expressing statistics such\nas \"with high probability a smoker knows another smoker\" but not for expressing\nstatements such as \"there is a smoker who knows most other smokers\", which is\nnecessary for modeling, e.g. influencers in social networks. To overcome this\nshortcoming, we study quantified MLNs which generalize MLNs by introducing\nstatistical universal quantifiers, allowing to express also the latter type of\nstatistics in a principled way. Our main technical contribution is to show that\nthe standard reasoning tasks in quantified MLNs, maximum a posteriori and\nmarginal inference, can be reduced to their respective MLN counterparts in\npolynomial time.\n", "versions": [{"version": "v1", "created": "Tue, 3 Jul 2018 13:39:19 GMT"}, {"version": "v2", "created": "Thu, 9 Aug 2018 16:47:24 GMT"}, {"version": "v3", "created": "Tue, 21 Aug 2018 14:18:47 GMT"}], "update_date": "2018-08-22", "authors_parsed": [["Guti\u00e9rrez-Basulto", "V\u00edctor", ""], ["Jung", "Jean Christoph", ""], ["Kuzelka", "Ondrej", ""]]}, {"id": "1807.01352", "submitter": "EPTCS", "authors": "Fr\\'ed\\'eric Blanqui (INRIA), Giselle Reis (CMU)", "title": "Proceedings of the 13th International Workshop on Logical Frameworks and\n  Meta-Languages: Theory and Practice", "comments": null, "journal-ref": "EPTCS 274, 2018", "doi": "10.4204/EPTCS.274", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains a selection of papers presented at LFMTP 2018, the 13th\ninternational Workshop on Logical Frameworks and Meta-Languages: Theory and\nPractice (LFMTP), held on July 7, 2018, in Oxford, UK. The workshop was\naffiliated with the 3rd international conference on Formal Structures for\nComputation and Deduction (FSCD) within the 7th Federated Logic Conference\n(FLoC).\n", "versions": [{"version": "v1", "created": "Tue, 3 Jul 2018 19:31:12 GMT"}], "update_date": "2018-07-05", "authors_parsed": [["Blanqui", "Fr\u00e9d\u00e9ric", "", "INRIA"], ["Reis", "Giselle", "", "CMU"]]}, {"id": "1807.01369", "submitter": "Michael Fiske S", "authors": "Michael Stephen Fiske", "title": "Quantum Random Self-Modifiable Computation", "comments": "50 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Among the fundamental questions in computer science, at least two have a deep\nimpact on mathematics. What can computation compute? How many steps does a\ncomputation require to solve an instance of the 3-SAT problem? Our work\naddresses the first question, by introducing a new model called the ex-machine.\nThe ex-machine executes Turing machine instructions and two special types of\ninstructions. Quantum random instructions are physically realizable with a\nquantum random number generator. Meta instructions can add new states and add\nnew instructions to the ex-machine. A countable set of ex-machines is\nconstructed, each with a finite number of states and instructions; each\nex-machine can compute a Turing incomputable language, whenever the quantum\nrandomness measurements behave like unbiased Bernoulli trials. In 1936, Alan\nTuring posed the halting problem for Turing machines and proved that this\nproblem is unsolvable for Turing machines. Consider an enumeration E_a(i) =\n(M_i, T_i) of all Turing machines M_i and initial tapes T_i. Does there exist\nan ex-machine X that has at least one evolutionary path X --> X_1 --> X_2 --> .\n. . --> X_m, so at the mth stage ex-machine X_m can correctly determine for 0\n<= i <= m whether M_i's execution on tape T_i eventually halts? We demonstrate\nan ex-machine Q(x) that has one such evolutionary path. The existence of this\nevolutionary path suggests that David Hilbert was not misguided to propose in\n1900 that mathematicians search for finite processes to help construct\nmathematical proofs. Our refinement is that we cannot use a fixed computer\nprogram that behaves according to a fixed set of mechanical rules. We must\npursue methods that exploit randomness and self-modification so that the\ncomplexity of the program can increase as it computes.\n", "versions": [{"version": "v1", "created": "Tue, 26 Jun 2018 22:45:10 GMT"}, {"version": "v2", "created": "Thu, 5 Jul 2018 02:34:17 GMT"}, {"version": "v3", "created": "Fri, 6 Jul 2018 21:16:50 GMT"}, {"version": "v4", "created": "Sat, 22 Sep 2018 00:04:38 GMT"}, {"version": "v5", "created": "Wed, 5 Dec 2018 18:46:36 GMT"}, {"version": "v6", "created": "Thu, 6 Dec 2018 18:49:34 GMT"}, {"version": "v7", "created": "Mon, 31 Dec 2018 15:37:44 GMT"}, {"version": "v8", "created": "Fri, 3 May 2019 19:55:40 GMT"}], "update_date": "2019-05-07", "authors_parsed": [["Fiske", "Michael Stephen", ""]]}, {"id": "1807.01494", "submitter": "Andre Kornell", "authors": "Andre Kornell", "title": "A complete system of deduction for Sigma formulas", "comments": "19 pages, 11 figures; deleted stray sentence fragment", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Sigma formulas of the language of arithmetic express semidecidable\nrelations on the natural numbers. More generally, whenever a totality of\nobjects is regarded as incomplete, the Sigma formulas express relations that\nare witnessed in a completed portion of that totality when they hold. In this\nsense, the Sigma formulas are more concrete semantically than other first-order\nformulas.\n  We describe a system of deduction that uses only Sigma formulas. Each axiom,\nan implication between two Sigma formulas, is implemented as a rewriting rule\nfor subformulas. We exhibit a complete class of logical axioms for this system,\nand we observe that a distributive law distinguishes classical reasoning from\nintuitionistic reasoning in this setting.\n  Skolem's theory PRA of primitive recursive arithmetic can be formulated in\nour deductive system. In Skolem's system, free variables are universally\nquantified implicitly, but in our formulation, free variables act as parameters\nto the deduction. In this sense, our formulation is more explicitly finitistic.\nFurthermore, most of our results are themselves finistic, being theorems of\nPRA. In particular, appending our main theorem to a celebrated chain of\nreductions from reverse mathematics, we find that an implication of Sigma\nformulas is derivable in WKL_0 if and only if there is a deduction from the\nantecedent to the consequent in our formulation of PRA.\n", "versions": [{"version": "v1", "created": "Wed, 4 Jul 2018 09:24:45 GMT"}, {"version": "v2", "created": "Mon, 3 Dec 2018 04:36:57 GMT"}], "update_date": "2018-12-04", "authors_parsed": [["Kornell", "Andre", ""]]}, {"id": "1807.01620", "submitter": "Dominique Duval", "authors": "Dominique Duval (LJK)", "title": "Logical rules as fractions and logics as sketches", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this short paper, using category theory, we argue that logical rules can\nbe seen as fractions and logics as limit sketches.\n", "versions": [{"version": "v1", "created": "Wed, 4 Jul 2018 14:44:44 GMT"}], "update_date": "2018-07-05", "authors_parsed": [["Duval", "Dominique", "", "LJK"]]}, {"id": "1807.01869", "submitter": "EPTCS", "authors": "Carlo Angiuli, Evan Cavallo, Kuen-Bang Hou (Favonia), Robert Harper,\n  Jonathan Sterling", "title": "The RedPRL Proof Assistant (Invited Paper)", "comments": "In Proceedings LFMTP 2018, arXiv:1807.01352", "journal-ref": "EPTCS 274, 2018, pp. 1-10", "doi": "10.4204/EPTCS.274.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  RedPRL is an experimental proof assistant based on Cartesian cubical\ncomputational type theory, a new type theory for higher-dimensional\nconstructions inspired by homotopy type theory. In the style of Nuprl, RedPRL\nusers employ tactics to establish behavioral properties of cubical functional\nprograms embodying the constructive content of proofs. Notably, RedPRL\nimplements a two-level type theory, allowing an extensional, proof-irrelevant\nnotion of exact equality to coexist with a higher-dimensional proof-relevant\nnotion of paths.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2018 07:08:44 GMT"}], "update_date": "2018-07-06", "authors_parsed": [["Angiuli", "Carlo", "", "Favonia"], ["Cavallo", "Evan", "", "Favonia"], ["Hou", "Kuen-Bang", "", "Favonia"], ["Harper", "Robert", ""], ["Sterling", "Jonathan", ""]]}, {"id": "1807.01870", "submitter": "EPTCS", "authors": "Ernesto Copello (1), Nora Szasz (2), \\'Alvaro Tasistro (2) ((1)\n  University of Iowa, (2) Universidad ORT Uruguay)", "title": "Formalisation in Constructive Type Theory of Barendregt's Variable\n  Convention for Generic Structures with Binders", "comments": "In Proceedings LFMTP 2018, arXiv:1807.01352", "journal-ref": "EPTCS 274, 2018, pp. 11-26", "doi": "10.4204/EPTCS.274.2", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a universe of regular datatypes with variable binding\ninformation, for which we define generic formation and elimination (i.e.\ninduction /recursion) operators. We then define a generic alpha-equivalence\nrelation over the types of the universe based on name-swapping, and derive\niteration and induction principles which work modulo alpha-conversion capturing\nBarendregt's Variable Convention. We instantiate the resulting framework so as\nto obtain the Lambda Calculus and System F, for which we derive substitution\noperations and substitution lemmas for alpha-conversion and substitution\ncomposition. The whole work is carried out in Constructive Type Theory and\nmachine-checked by the system Agda.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2018 07:09:02 GMT"}], "update_date": "2018-07-06", "authors_parsed": [["Copello", "Ernesto", ""], ["Szasz", "Nora", ""], ["Tasistro", "\u00c1lvaro", ""]]}, {"id": "1807.01871", "submitter": "EPTCS", "authors": "Mart\\'in Copes, Nora Szasz (Universidad ORT Uruguay), \\'Alvaro\n  Tasistro (Universidad ORT Uruguay)", "title": "Formalization in Constructive Type Theory of the Standardization Theorem\n  for the Lambda Calculus using Multiple Substitution", "comments": "In Proceedings LFMTP 2018, arXiv:1807.01352", "journal-ref": "EPTCS 274, 2018, pp. 27-41", "doi": "10.4204/EPTCS.274.3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a full formalization in Martin-L\\\"of's Constructive Type Theory of\nthe Standardization Theorem for the Lambda Calculus using first-order syntax\nwith one sort of names for both free and bound variables and Stoughton's\nmultiple substitution. Our formalization is based on a proof by Ryo Kashima, in\nwhich a notion of beta-reducibility with a standard sequence is captured by an\ninductive relation. The proof uses only structural induction over the syntax\nand the relations defined, which is possible due to the specific formulation of\nsubstitution that we employ. The whole development has been machine-checked\nusing the system Agda.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2018 07:09:24 GMT"}], "update_date": "2018-07-06", "authors_parsed": [["Copes", "Mart\u00edn", "", "Universidad ORT Uruguay"], ["Szasz", "Nora", "", "Universidad ORT Uruguay"], ["Tasistro", "\u00c1lvaro", "", "Universidad ORT Uruguay"]]}, {"id": "1807.01873", "submitter": "EPTCS", "authors": "Fran\\c{c}ois Thir\\'e (ENS Paris-Saclay, LSV, CNRS, Universit\\'e\n  Paris-Saclay, INRIA, LIX)", "title": "Sharing a Library between Proof Assistants: Reaching out to the HOL\n  Family", "comments": "In Proceedings LFMTP 2018, arXiv:1807.01352", "journal-ref": "EPTCS 274, 2018, pp. 57-71", "doi": "10.4204/EPTCS.274.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We observe today a large diversity of proof systems. This diversity has the\nnegative consequence that a lot of theorems are proved many times. Unlike\nprogramming languages, it is difficult for these systems to co-operate because\nthey do not implement the same logic. Logical frameworks are a class of theorem\nprovers that overcome this issue by their capacity of implementing various\nlogics. In this work, we study the STTforall logic, an extension of Simple Type\nTheory that has been encoded in the logical framework Dedukti. We present a\ntranslation from this logic to OpenTheory, a proof system and interoperability\ntool between provers of the HOL family. We have used this translation to export\nan arithmetic library containing Fermat's little theorem to OpenTheory and to\ntwo other proof systems that are Coq and Matita.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2018 07:10:03 GMT"}], "update_date": "2018-07-06", "authors_parsed": [["Thir\u00e9", "Fran\u00e7ois", "", "ENS Paris-Saclay, LSV, CNRS, Universit\u00e9\n  Paris-Saclay, INRIA, LIX"]]}, {"id": "1807.02058", "submitter": "Marius Buliga", "authors": "Marius Buliga", "title": "The em-convex rewrite system", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO math.MG", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce and study em (or \"emergent\"), a lambda calculus style rewrite\nsystem inspired from dilations structures in metric geometry. Then we add a new\naxiom (convex) and explore its consequences. Although (convex) forces\ncommutativity of the infinitesimal operations, Theorems 6.2, 8.9 and\nProposition 8.7 appear as a lambda calculus style version of Gleason and\nMontgomery-Zippin solution to the Hilbert 5th problem.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2018 15:40:55 GMT"}], "update_date": "2018-07-06", "authors_parsed": [["Buliga", "Marius", ""]]}, {"id": "1807.02081", "submitter": "Ignacio F\\'abregas", "authors": "Luca Aceto, Ignacio F\\'abregas, \\'Alvaro Garc\\'ia-P\\'erez, Anna\n  Ing\\'olfsd\\'ottir and Yolanda Ortega-Mall\\'en", "title": "Rule Formats for Nominal Process Calculi", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 4 (October\n  14, 2019) lmcs:5834", "doi": "10.23638/LMCS-15(4:2)2019", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The nominal transition systems (NTSs) of Parrow et al. describe the\noperational semantics of nominal process calculi. We study NTSs in terms of the\nnominal residual transition systems (NRTSs) that we introduce. We provide rule\nformats for the specifications of NRTSs that ensure that the associated NRTS is\nan NTS and apply them to the operational specifications of the early and late\npi-calculus. We also explore alternative specifications of the NTSs in which we\nallow residuals of abstraction sort, and introduce translations between the\nsystems with and without residuals of abstraction sort. Our study stems from\nthe Nominal SOS of Cimini et al. and from earlier works in nominal sets and\nnominal logic by Gabbay, Pitts and their collaborators.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2018 16:41:40 GMT"}, {"version": "v2", "created": "Sat, 7 Jul 2018 19:36:07 GMT"}, {"version": "v3", "created": "Fri, 22 Mar 2019 16:05:58 GMT"}, {"version": "v4", "created": "Tue, 3 Sep 2019 14:52:08 GMT"}, {"version": "v5", "created": "Wed, 4 Sep 2019 10:21:35 GMT"}, {"version": "v6", "created": "Fri, 11 Oct 2019 08:36:41 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Aceto", "Luca", ""], ["F\u00e1bregas", "Ignacio", ""], ["Garc\u00eda-P\u00e9rez", "\u00c1lvaro", ""], ["Ing\u00f3lfsd\u00f3ttir", "Anna", ""], ["Ortega-Mall\u00e9n", "Yolanda", ""]]}, {"id": "1807.02358", "submitter": "Beniamino Accattoli", "authors": "Beniamino Accattoli, St\\'ephane Graham-Lengrand, Delia Kesner", "title": "Tight Typings and Split Bounds", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multi types---aka non-idempotent intersection types---have been used to\nobtain quantitative bounds on higher-order programs, as pioneered by de\nCarvalho. Notably, they bound at the same time the number of evaluation steps\nand the size of the result. Recent results show that the number of steps can be\ntaken as a reasonable time complexity measure. At the same time, however, these\nresults suggest that multi types provide quite lax complexity bounds, because\nthe size of the result can be exponentially bigger than the number of steps.\n  Starting from this observation, we refine and generalise a technique\nintroduced by Bernadet & Graham-Lengrand to provide exact bounds for the\nmaximal strategy. Our typing judgements carry two counters, one measuring\nevaluation lengths and the other measuring result sizes. In order to emphasise\nthe modularity of the approach, we provide exact bounds for four evaluation\nstrategies, both in the lambda-calculus (head, leftmost-outermost, and maximal\nevaluation) and in the linear substitution calculus (linear head evaluation).\n  Our work aims at both capturing the results in the literature and extending\nthem with new outcomes. Concerning the literature, it unifies de Carvalho and\nBernadet & Graham-Lengrand via a uniform technique and a complexity-based\nperspective. The two main novelties are exact split bounds for the leftmost\nstrategy---the only known strategy that evaluates terms to full normal forms\nand provides a reasonable complexity measure---and the observation that the\ncomputing device hidden behind multi types is the notion of substitution at a\ndistance, as implemented by the linear substitution calculus.\n", "versions": [{"version": "v1", "created": "Fri, 6 Jul 2018 11:20:52 GMT"}], "update_date": "2018-07-09", "authors_parsed": [["Accattoli", "Beniamino", ""], ["Graham-Lengrand", "St\u00e9phane", ""], ["Kesner", "Delia", ""]]}, {"id": "1807.02566", "submitter": "Barbara K\\\"onig", "authors": "Benjamin Cabrera and Tobias Heindel and Reiko Heckel and Barbara\n  K\\\"onig", "title": "Updating Probabilistic Knowledge on Condition/Event Nets using Bayesian\n  Networks", "comments": "Accepted at CONCUR '18", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper extends Bayesian networks (BNs) by a mechanism for dynamic changes\nto the probability distributions represented by BNs. One application scenario\nis the process of knowledge acquisition of an observer interacting with a\nsystem. In particular, the paper considers condition/event nets where the\nobserver's knowledge about the current marking is a probability distribution\nover markings. The observer can interact with the net to deduce information\nabout the marking by requesting certain transitions to fire and observing their\nsuccess or failure.\n  Aiming for an efficient implementation of dynamic changes to probability\ndistributions of BNs, we consider a modular form of networks that form the\narrows of a free PROP with a commutative comonoid structure, also known as term\ngraphs. The algebraic structure of such PROPs supplies us with a compositional\nsemantics that functorially maps BNs to their underlying probability\ndistribution and, in particular, it provides a convenient means to describe\nstructural updates of networks.\n", "versions": [{"version": "v1", "created": "Fri, 29 Jun 2018 15:00:02 GMT"}], "update_date": "2018-07-10", "authors_parsed": [["Cabrera", "Benjamin", ""], ["Heindel", "Tobias", ""], ["Heckel", "Reiko", ""], ["K\u00f6nig", "Barbara", ""]]}, {"id": "1807.02735", "submitter": "Matvey Soloviev", "authors": "Dexter Kozen and Matvey Soloviev", "title": "Coalgebraic Tools for Randomness-Conserving Protocols", "comments": "25 pages, including references. In submission to RAMiCS 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.IT math.IT math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a coalgebraic model for constructing and reasoning about\nstate-based protocols that implement efficient reductions among random\nprocesses. We provide basic tools that allow efficient protocols to be\nconstructed in a compositional way and analyzed in terms of the tradeoff\nbetween latency and loss of entropy. We show how to use these tools to\nconstruct various entropy-conserving reductions between processes.\n", "versions": [{"version": "v1", "created": "Sun, 8 Jul 2018 01:43:12 GMT"}], "update_date": "2018-07-10", "authors_parsed": [["Kozen", "Dexter", ""], ["Soloviev", "Matvey", ""]]}, {"id": "1807.02957", "submitter": "Ariyam Das", "authors": "Tyson Condie, Ariyam Das, Matteo Interlandi, Alexander Shkapsky, Mohan\n  Yang, Carlo Zaniolo", "title": "Scaling-Up Reasoning and Advanced Analytics on BigData", "comments": "Under consideration in Theory and Practice of Logic Programming\n  (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  BigDatalog is an extension of Datalog that achieves performance and\nscalability on both Apache Spark and multicore systems to the point that its\ngraph analytics outperform those written in GraphX. Looking back, we see how\nthis realizes the ambitious goal pursued by deductive database researchers\nbeginning forty years ago: this is the goal of combining the rigor and power of\nlogic in expressing queries and reasoning with the performance and scalability\nby which relational databases managed Big Data. This goal led to Datalog which\nis based on Horn Clauses like Prolog but employs implementation techniques,\nsuch as Semi-naive Fixpoint and Magic Sets, that extend the bottom-up\ncomputation model of relational systems, and thus obtain the performance and\nscalability that relational systems had achieved, as far back as the 80s, using\ndata-parallelization on shared-nothing architectures. But this goal proved\ndifficult to achieve because of major issues at (i) the language level and (ii)\nat the system level. The paper describes how (i) was addressed by simple rules\nunder which the fixpoint semantics extends to programs using count, sum and\nextrema in recursion, and (ii) was tamed by parallel compilation techniques\nthat achieve scalability on multicore systems and Apache Spark. This paper is\nunder consideration for acceptance in Theory and Practice of Logic Programming\n(TPLP).\n", "versions": [{"version": "v1", "created": "Mon, 9 Jul 2018 06:40:08 GMT"}], "update_date": "2018-07-10", "authors_parsed": [["Condie", "Tyson", ""], ["Das", "Ariyam", ""], ["Interlandi", "Matteo", ""], ["Shkapsky", "Alexander", ""], ["Yang", "Mohan", ""], ["Zaniolo", "Carlo", ""]]}, {"id": "1807.02973", "submitter": "Silvano Dal Zilio", "authors": "Bernard Berthomieu (LAAS-VERTICS), Didier Le Botlan (LAAS-VERTICS),\n  Silvano Dal Zilio (LAAS-VERTICS)", "title": "Petri Net Reductions for Counting Markings", "comments": null, "journal-ref": "International Symposium on Model Checking Software, SPIN 2018, Jun\n  2018, Malaga, Spain. Springer, 10869, Lecture Notes in Computer Science", "doi": "10.1007/978-3-319-94111-0_4", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a method to count the number of reachable markings of a Petri net\nwithout having to enumerate these rst. The method relies on a structural\nreduction system that reduces the number of places and transitions of the net\nin such a way that we can faithfully compute the number of reachable markings\nof the original net from the reduced net and the reduction history. The method\nhas been implemented and computing experiments show that reductions are eective\non a large benchmark of models.\n", "versions": [{"version": "v1", "created": "Mon, 9 Jul 2018 07:51:04 GMT"}], "update_date": "2018-07-10", "authors_parsed": [["Berthomieu", "Bernard", "", "LAAS-VERTICS"], ["Botlan", "Didier Le", "", "LAAS-VERTICS"], ["Zilio", "Silvano Dal", "", "LAAS-VERTICS"]]}, {"id": "1807.03002", "submitter": "Linda Brodo", "authors": "Chiara Bodei, Linda Brodo, Roberto Bruni", "title": "A Formal Approach to Open Multiparty Interactions", "comments": "62 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a process algebra aimed at describing interactions that are\nmultiparty, i.e. that may involve more than two processes and that are open,\ni.e. the number of the processes they involve is not fixed or known a priori.\nHere we focus on the theory of a core version of a process calculus, without\nmessage passing, called Core Network Algebra (CNA). In CNA communication\nactions are given not in terms of channels but in terms of chains of links that\nrecord the source and the target ends of each hop of interactions. The\noperational semantics of our calculus mildly extends the one of CCS. The\nabstract semantics is given in the style of bisimulation but requires some\ningenuity. Remarkably, the abstract semantics is a congruence for all operators\nof CNA and also with respect to substitutions, which is not the case for strong\nbisimilarity in CCS. As a motivating and running example, we illustrate the\nmodel of a simple software defined network infrastructure.\n", "versions": [{"version": "v1", "created": "Mon, 9 Jul 2018 09:25:12 GMT"}, {"version": "v2", "created": "Mon, 21 Jan 2019 12:24:51 GMT"}], "update_date": "2019-01-23", "authors_parsed": [["Bodei", "Chiara", ""], ["Brodo", "Linda", ""], ["Bruni", "Roberto", ""]]}, {"id": "1807.03197", "submitter": "Daniel Ritter", "authors": "Daniel Ritter, Stefanie Rinderle-Ma, Marco Montali, Andrey Rivkin,\n  Aman Sinha", "title": "Catalog of Formalized Application Integration Patterns", "comments": "5 pages, example implementations (correct and incorrect) can be found\n  in https://github.com/dritter-hd/db-net-eip-patterns", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Enterprise application integration (EAI) solutions are the centrepiece of\ncurrent enterprise IT architectures (e.g., cloud and mobile computing, business\nnetworks), however, require the formalization of their building blocks,\nrepresented by integration patterns, verification and optimization. This work\nserves as an instructive pattern formalization catalog that leads to the\nformalization of all currently known integration patterns. Therefore, we\nexplain the classification of the underlying requirements of the pattern\nsemantics and formalize representative patterns from the different categories,\nby realizing them in timed db-net. In this way, the catalog will allow for the\naddition of future patterns by assigning them to a category and applying the\ndescribed formalism.\n", "versions": [{"version": "v1", "created": "Fri, 6 Jul 2018 12:05:05 GMT"}, {"version": "v2", "created": "Sat, 13 Oct 2018 08:19:33 GMT"}, {"version": "v3", "created": "Thu, 12 Sep 2019 06:21:55 GMT"}], "update_date": "2019-09-13", "authors_parsed": [["Ritter", "Daniel", ""], ["Rinderle-Ma", "Stefanie", ""], ["Montali", "Marco", ""], ["Rivkin", "Andrey", ""], ["Sinha", "Aman", ""]]}, {"id": "1807.03296", "submitter": "Jan K\\v{r}et\\'insk\\'y", "authors": "Jan K\\v{r}et\\'insk\\'y and Tobias Meggendorfer and Salomon Sickert", "title": "LTL Store: Repository of LTL formulae from literature and case studies", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This continuously extended technical report collects and compares commonly\nused formulae from the literature and provides them in a machine readable way.\n", "versions": [{"version": "v1", "created": "Fri, 29 Jun 2018 14:41:32 GMT"}], "update_date": "2018-07-10", "authors_parsed": [["K\u0159et\u00ednsk\u00fd", "Jan", ""], ["Meggendorfer", "Tobias", ""], ["Sickert", "Salomon", ""]]}, {"id": "1807.03732", "submitter": "EPTCS", "authors": "Robert Atkey (University of Strathclyde), Sam Lindley (University of\n  Edinburgh)", "title": "Proceedings of the 7th Workshop on Mathematically Structured Functional\n  Programming", "comments": null, "journal-ref": "EPTCS 275, 2018", "doi": "10.4204/EPTCS.275", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The seventh workshop on Mathematically Structured Functional Programming is\ndevoted to the derivation of functionality from structure. It is a celebration\nof the direct impact of Theoretical Computer Science on programs as we write\nthem today. Modern programming languages, and in particular functional\nlanguages, support the direct expression of mathematical structures, equipping\nprogrammers with tools of remarkable power and abstraction. Where would Haskell\nbe without monads? Functional reactive programming without arrows?\nCall-by-push-value without adjunctions? The list goes on. This workshop is a\nforum for researchers who seek to reflect mathematical phenomena in data and\ncontrol.\n  The seventh workshop on Mathematically Structured Functional Programming was\nheld on 8th July 2018 affiliated with FSCD 2018 as part of FLoC 2018 in Oxford,\nUK.\n  There were two invited talks. In addition four full papers and two extended\nabstracts were selected by the programme committee for presentation.\n", "versions": [{"version": "v1", "created": "Tue, 10 Jul 2018 16:07:51 GMT"}], "update_date": "2018-07-11", "authors_parsed": [["Atkey", "Robert", "", "University of Strathclyde"], ["Lindley", "Sam", "", "University of\n  Edinburgh"]]}, {"id": "1807.03865", "submitter": "Caleb Stanford", "authors": "Rajeev Alur, Dana Fisman, Konstantinos Mamouras, Mukund Raghothaman,\n  Caleb Stanford", "title": "Streamable Regular Transductions", "comments": "53 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Motivated by real-time monitoring and data processing applications, we\ndevelop a formal theory of quantitative queries for streaming data that can be\nevaluated efficiently. We consider the model of unambiguous Cost Register\nAutomata (CRAs), which are machines that combine finite-state control (for\nidentifying regular patterns) with a finite set of data registers (for\ncomputing numerical aggregates). The definition of CRAs is parameterized by the\ncollection of numerical operations that can be applied to the registers. These\nmachines give rise to the class of streamable regular transductions (SR), and\nto the class of streamable linear regular transductions (SLR) when the register\nupdates are copyless, i.e. every register appears at most once the\nright-hand-side expressions of the updates. We give a logical characterization\nof the class SR (resp., SLR) using MSO-definable transformations from strings\nto DAGs (resp., trees) without backward edges. Additionally, we establish that\nthe two classes SR and SLR are closed under operations that are relevant for\ndesigning query languages. Finally, we study the relationship with weighted\nautomata (WA), and show that CRAs over a suitably chosen set of operations\ncorrespond to WA, thus establishing that WA are a special case of CRAs.\n", "versions": [{"version": "v1", "created": "Tue, 10 Jul 2018 21:11:24 GMT"}, {"version": "v2", "created": "Sun, 3 Nov 2019 21:13:50 GMT"}], "update_date": "2019-11-05", "authors_parsed": [["Alur", "Rajeev", ""], ["Fisman", "Dana", ""], ["Mamouras", "Konstantinos", ""], ["Raghothaman", "Mukund", ""], ["Stanford", "Caleb", ""]]}, {"id": "1807.04083", "submitter": "EPTCS", "authors": "Jeremy Pope (University of Gothenburg)", "title": "Formalizing Constructive Quantifier Elimination in Agda", "comments": "In Proceedings MSFP 2018, arXiv:1807.03732", "journal-ref": "EPTCS 275, 2018, pp. 2-17", "doi": "10.4204/EPTCS.275.2", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper a constructive formalization of quantifier elimination is\npresented, based on a classical formalization by Tobias Nipkow. The\nformalization is implemented and verified in the programming language/proof\nassistant Agda. It is shown that, as in the classical case, the ability to\neliminate a single existential quantifier may be generalized to full quantifier\nelimination and consequently a decision procedure. The latter is shown to have\nstrong properties under a constructive metatheory, such as the generation of\nwitnesses and counterexamples. Finally, this is demonstrated on a minimal\ntheory on the natural numbers.\n", "versions": [{"version": "v1", "created": "Wed, 11 Jul 2018 11:38:50 GMT"}], "update_date": "2018-07-12", "authors_parsed": [["Pope", "Jeremy", "", "University of Gothenburg"]]}, {"id": "1807.04084", "submitter": "EPTCS", "authors": "Exequiel Rivas (INRIA)", "title": "Relating Idioms, Arrows and Monads from Monoidal Adjunctions", "comments": "In Proceedings MSFP 2018, arXiv:1807.03732", "journal-ref": "EPTCS 275, 2018, pp. 18-33", "doi": "10.4204/EPTCS.275.3", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We revisit once again the connection between three notions of computation:\nmonads, arrows and idioms (also called applicative functors). We employ\nmonoidal categories of finitary functors and profunctors on finite sets as\nmodels of these notions of computation, and develop the connections between\nthem through adjunctions. As a result, we obtain a categorical version of\nLindley, Yallop and Wadler's characterisation of monads and idioms as arrows\nsatisfying an isomorphism.\n", "versions": [{"version": "v1", "created": "Wed, 11 Jul 2018 11:39:07 GMT"}], "update_date": "2018-07-12", "authors_parsed": [["Rivas", "Exequiel", "", "INRIA"]]}, {"id": "1807.04085", "submitter": "EPTCS", "authors": "Conor McBride (University of Strathclyde)", "title": "Everybody's Got To Be Somewhere", "comments": "In Proceedings MSFP 2018, arXiv:1807.03732", "journal-ref": "EPTCS 275, 2018, pp. 53-69", "doi": "10.4204/EPTCS.275.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The key to any nameless representation of syntax is how it indicates the\nvariables we choose to use and thus, implicitly, those we discard. Standard de\nBruijn representations delay discarding maximally till the leaves of terms\nwhere one is chosen from the variables in scope at the expense of the rest.\nConsequently, introducing new but unused variables requires term traversal.\nThis paper introduces a nameless 'co-de-Bruijn' representation which makes the\nopposite canonical choice, delaying discarding minimally, as near as possible\nto the root. It is literate Agda: dependent types make it a practical joy to\nexpress and be driven by strong intrinsic invariants which ensure that scope is\naggressively whittled down to just the support of each subterm, in which every\nremaining variable occurs somewhere. The construction is generic, delivering a\nuniverse of syntaxes with higher-order metavariables, for which the appropriate\nnotion of substitution is hereditary. The implementation of simultaneous\nsubstitution exploits tight scope control to avoid busywork and shift terms\nwithout traversal. Surprisingly, it is also intrinsically terminating, by\nstructural recursion alone.\n", "versions": [{"version": "v1", "created": "Wed, 11 Jul 2018 11:39:29 GMT"}], "update_date": "2018-07-12", "authors_parsed": [["McBride", "Conor", "", "University of Strathclyde"]]}, {"id": "1807.04557", "submitter": "Yanis Sellami", "authors": "Mnacho Echenim, Nicolas Peltier, Yanis Sellami", "title": "A Generic Framework for Implicate Generation Modulo Theories", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The clausal logical consequences of a formula are called its implicates. The\ngeneration of these implicates has several applications, such as the\nidentification of missing hypotheses in a logical specification. We present a\nprocedure that generates the implicates of a quantifier-free formula modulo a\ntheory. No assumption is made on the considered theory, other than the\nexistence of a decision procedure. The algorithm has been implemented (using\nthe solvers MiniSat, CVC4 and Z3) and experimental results show evidence of the\npractical relevance of the proposed approach.\n", "versions": [{"version": "v1", "created": "Thu, 12 Jul 2018 11:56:15 GMT"}], "update_date": "2018-07-13", "authors_parsed": [["Echenim", "Mnacho", ""], ["Peltier", "Nicolas", ""], ["Sellami", "Yanis", ""]]}, {"id": "1807.05174", "submitter": "Pedro S\\'anchez Terraf", "authors": "Emmanuel Gunther, Miguel Pagano, Pedro S\\'anchez Terraf", "title": "First steps towards a formalization of Forcing", "comments": "18 pages. Isabelle proofs can be found among the source files of this\n  submission. v2: Added discussion of related work and of details of\n  implementation. Proof that G belongs to M[G] and that the latter is\n  transitive", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We lay the ground for an Isabelle/ZF formalization of Cohen's technique of\nforcing. We formalize the definition of forcing notions as preorders with top,\ndense subsets, and generic filters. We formalize the definition of forcing\nnotions as preorders with top, dense subsets, and generic filters. We formalize\na version of the principle of Dependent Choices and using it we prove the\nRasiowa-Sikorski lemma on the existence of generic filters.\n  Given a transitive set $M$, we define its generic extension $M[G]$, the\ncanonical names for elements of $M$, and finally show that if $M$ satisfies the\naxiom of pairing, then $M[G]$ also does. We also prove $M[G]$ is transitive.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jul 2018 16:49:28 GMT"}, {"version": "v2", "created": "Tue, 27 Nov 2018 17:37:59 GMT"}], "update_date": "2018-11-28", "authors_parsed": [["Gunther", "Emmanuel", ""], ["Pagano", "Miguel", ""], ["Terraf", "Pedro S\u00e1nchez", ""]]}, {"id": "1807.05194", "submitter": "Joshua Brakensiek", "authors": "Joshua Brakensiek and Venkatesan Guruswami", "title": "An Algorithmic Blend of LPs and Ring Equations for Promise CSPs", "comments": "41 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.DS cs.LO math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Promise CSPs are a relaxation of constraint satisfaction problems where the\ngoal is to find an assignment satisfying a relaxed version of the constraints.\nSeveral well-known problems can be cast as promise CSPs including approximate\ngraph coloring, discrepancy minimization, and interesting variants of\nsatisfiability. Similar to CSPs, the tractability of promise CSPs can be tied\nto the structure of operations on the solution space called polymorphisms,\nthough in the promise world these operations are much less constrained. Under\nthe thesis that non-trivial polymorphisms govern tractability, promise CSPs\ntherefore provide a fertile ground for the discovery of novel algorithms.\n  In previous work, we classified Boolean promise CSPs when the constraint\npredicates are symmetric. In this work, we vastly generalize these algorithmic\nresults. Specifically, we show that promise CSPs that admit a family of\n\"regional-periodic\" polymorphisms are in P, assuming that determining which\nregion a point is in can be computed in polynomial time. Such polymorphisms are\nquite general and are obtained by gluing together several functions that are\nperiodic in the Hamming weights in different blocks of the input.\n  Our algorithm is based on a novel combination of linear programming and\nsolving linear systems over rings. We also abstract a framework based on\nreducing a promise CSP to a CSP over an infinite domain, solving it there, and\nthen rounding the solution to an assignment for the promise CSP instance. The\nrounding step is intimately tied to the family of polymorphisms and clarifies\nthe connection between polymorphisms and algorithms in this context. As a key\ningredient, we introduce the technique of finding a solution to a linear\nprogram with integer coefficients that lies in a different ring (such as\n$\\mathbb Z[\\sqrt{2}]$) to bypass ad-hoc adjustments for lying on a rounding\nboundary.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jul 2018 17:29:50 GMT"}], "update_date": "2018-07-16", "authors_parsed": [["Brakensiek", "Joshua", ""], ["Guruswami", "Venkatesan", ""]]}, {"id": "1807.05263", "submitter": "Andrew Polonsky", "authors": "Patricia Johann and Andrew Polonsky", "title": "On local presentability of T/A", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO math.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We prove that if $\\mathcal{A}$ is a locally $\\lambda$-presentable category\nand $T : \\mathcal{A} \\to \\mathcal{A}$ is a $\\lambda$-accessible functor then\n$T/\\mathcal{A}$ is locally $\\lambda$-presentable.\n", "versions": [{"version": "v1", "created": "Fri, 6 Jul 2018 12:46:23 GMT"}], "update_date": "2018-07-17", "authors_parsed": [["Johann", "Patricia", ""], ["Polonsky", "Andrew", ""]]}, {"id": "1807.05923", "submitter": "Andrej Bauer", "authors": "Andrej Bauer", "title": "What is algebraic about algebraic effects and handlers?", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This note recapitulates and expands the contents of a tutorial on the\nmathematical theory of algebraic effects and handlers which I gave at the\nDagstuhl seminar 18172 \"Algebraic effect handlers go mainstream\". It is\ntargeted roughly at the level of a doctoral student with some amount of\nmathematical training, or at anyone already familiar with algebraic effects and\nhandlers as programming concepts who would like to know what they have to do\nwith algebra. We draw an uninterrupted line of thought between algebra and\ncomputational effects. We begin on the mathematical side of things, by\nreviewing the classic notions of universal algebra: signatures, algebraic\ntheories, and their models. We then generalize and adapt the theory so that it\napplies to computational effects. In the last step we replace traditional\nmathematical notation with one that is closer to programming languages.\n", "versions": [{"version": "v1", "created": "Mon, 16 Jul 2018 15:34:07 GMT"}, {"version": "v2", "created": "Tue, 12 Mar 2019 09:25:25 GMT"}], "update_date": "2019-03-13", "authors_parsed": [["Bauer", "Andrej", ""]]}, {"id": "1807.06051", "submitter": "Fran\\c{c}ois Bry", "authors": "Fran\\c{c}ois Bry", "title": "In Praise of Impredicativity: A Contribution to the Formalisation of\n  Meta-Programming", "comments": "Under consideration for publication in Theory and Practice of Logic\n  Programming", "journal-ref": "Theory and Practice of Logic Programming, pages 1-48, 25 February\n  2019", "doi": "10.1017/S1471068419000024", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Processing programs as data is one of the successes of functional and logic\nprogramming. Higher-order functions, as program-processing programs are called\nin functional programming, and meta-programs, as they are called in logic\nprogramming, are widespread declarative programming techniques. In logic\nprogramming, there is a gap between the meta-programming practice and its\ntheory: The formalisations of meta-programming do not explicitly address its\nimpredicativity and are not fully adequate. This article aims at overcoming\nthis unsatisfactory situation by discussing the relevance of impredicativity to\nmeta-programming, by revisiting former formalisations of meta-programming and\nby defining Reflective Predicate Logic, a conservative extension of first-order\nlogic, which provides a simple formalisation of meta-programming.\n", "versions": [{"version": "v1", "created": "Mon, 16 Jul 2018 18:36:46 GMT"}, {"version": "v2", "created": "Mon, 26 Nov 2018 13:40:56 GMT"}, {"version": "v3", "created": "Fri, 11 Jan 2019 16:49:05 GMT"}, {"version": "v4", "created": "Sat, 18 Apr 2020 07:54:33 GMT"}], "update_date": "2020-04-21", "authors_parsed": [["Bry", "Fran\u00e7ois", ""]]}, {"id": "1807.06071", "submitter": "Pierre Ganty", "authors": "Javier Esparza and Pierre Ganty and Rupak Majumdar and Chana\n  Weil-Kennedy", "title": "Verification of Immediate Observation Population Protocols", "comments": "18 pages", "journal-ref": "Proceedings of 29th International Conference on Concurrency Theory\n  (CONCUR 2018)", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Population protocols (Angluin et al., PODC, 2004) are a formal model of\nsensor networks consisting of identical mobile devices. Two devices can\ninteract and thereby change their states. Computations are infinite sequences\nof interactions satisfying a strong fairness constraint.\n  A population protocol is well-specified if for every initial configuration\n$C$ of devices, and every computation starting at $C$, all devices eventually\nagree on a consensus value depending only on $C$. If a protocol is\nwell-specified, then it is said to compute the predicate that assigns to each\ninitial configuration its consensus value.\n  In a previous paper we have shown that the problem whether a given protocol\nis well-specified and the problem whether it computes a given predicate are\ndecidable. However, in the same paper we prove that both problems are at least\nas hard as the reachability problem for Petri nets. Since all known algorithms\nfor Petri net reachability have non-primitive recursive complexity, in this\npaper we restrict attention to immediate observation (IO) population protocols,\na class introduced and studied in (Angluin et al., PODC, 2006). We show that\nboth problems are solvable in exponential space for IO protocols. This is the\nfirst syntactically defined, interesting class of protocols for which an\nalgorithm not requiring Petri net reachability is found.\n", "versions": [{"version": "v1", "created": "Mon, 16 Jul 2018 19:32:13 GMT"}, {"version": "v2", "created": "Mon, 13 Aug 2018 20:50:42 GMT"}], "update_date": "2018-08-15", "authors_parsed": [["Esparza", "Javier", ""], ["Ganty", "Pierre", ""], ["Majumdar", "Rupak", ""], ["Weil-Kennedy", "Chana", ""]]}, {"id": "1807.06091", "submitter": "Tetsuya Sato", "authors": "Tetsuya Sato, Alejandro Aguirre, Gilles Barthe, Marco Gaboardi, Deepak\n  Garg, Justin Hsu", "title": "Formal verification of higher-order probabilistic programs", "comments": null, "journal-ref": null, "doi": "10.1145/3290351", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Probabilistic programming provides a convenient lingua franca for writing\nsuccinct and rigorous descriptions of probabilistic models and inference tasks.\nSeveral probabilistic programming languages, including Anglican, Church or\nHakaru, derive their expressiveness from a powerful combination of continuous\ndistributions, conditioning, and higher-order functions. Although very\nimportant for practical applications, these combined features raise fundamental\nchallenges for program semantics and verification. Several recent works offer\npromising answers to these challenges, but their primary focus is on semantical\nissues.\n  In this paper, we take a step further and we develop a set of program logics,\nnamed PPV, for proving properties of programs written in an expressive\nprobabilistic higher-order language with continuous distributions and operators\nfor conditioning distributions by real-valued functions. Pleasingly, our\nprogram logics retain the comfortable reasoning style of informal proofs thanks\nto carefully selected axiomatizations of key results from probability theory.\nThe versatility of our logics is illustrated through the formal verification of\nseveral intricate examples from statistics, probabilistic inference, and\nmachine learning. We further show the expressiveness of our logics by giving\nsound embeddings of existing logics. In particular, we do this in a parametric\nway by showing how the semantics idea of (unary and relational) TT-lifting can\nbe internalized in our logics. The soundness of PPV follows by interpreting\nprograms and assertions in quasi-Borel spaces (QBS), a recently proposed\nvariant of Borel spaces with a good structure for interpreting higher order\nprobabilistic programs.\n", "versions": [{"version": "v1", "created": "Mon, 16 Jul 2018 20:20:20 GMT"}, {"version": "v2", "created": "Tue, 18 Sep 2018 14:06:47 GMT"}, {"version": "v3", "created": "Tue, 25 Feb 2020 03:34:29 GMT"}], "update_date": "2020-02-26", "authors_parsed": [["Sato", "Tetsuya", ""], ["Aguirre", "Alejandro", ""], ["Barthe", "Gilles", ""], ["Gaboardi", "Marco", ""], ["Garg", "Deepak", ""], ["Hsu", "Justin", ""]]}, {"id": "1807.06149", "submitter": "Tom Hanika", "authors": "Daniel Borchmann, Tom Hanika, Sergei Obiedkov", "title": "Probably approximately correct learning of Horn envelopes from queries", "comments": "21 pages, 1 figure", "journal-ref": "Discrete Applied Mathematics Volume 273 (2020), Pages 30-42", "doi": "10.1016/j.dam.2019.02.036", "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose an algorithm for learning the Horn envelope of an arbitrary domain\nusing an expert, or an oracle, capable of answering certain types of queries\nabout this domain. Attribute exploration from formal concept analysis is a\nprocedure that solves this problem, but the number of queries it may ask is\nexponential in the size of the resulting Horn formula in the worst case. We\nrecall a well-known polynomial-time algorithm for learning Horn formulas with\nmembership and equivalence queries and modify it to obtain a polynomial-time\nprobably approximately correct algorithm for learning the Horn envelope of an\narbitrary domain.\n", "versions": [{"version": "v1", "created": "Mon, 16 Jul 2018 23:24:03 GMT"}], "update_date": "2020-02-28", "authors_parsed": [["Borchmann", "Daniel", ""], ["Hanika", "Tom", ""], ["Obiedkov", "Sergei", ""]]}, {"id": "1807.06305", "submitter": "Roberto Bruni", "authors": "Roberto Bruni and Hern\\'an Melgratti and Ugo Montanari", "title": "Unifying Inference for Bayesian and Petri Nets", "comments": "27 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent work by the authors equips Petri occurrence nets (PN) with probability\ndistributions which fully replace nondeterminism. To avoid the so-called\nconfusion problem, the construction imposes additional causal dependencies\nwhich restrict choices within certain subnets called structural branching cells\n(s-cells). Bayesian nets (BN) are usually structured as partial orders where\nnodes define conditional probability distributions. In the paper, we unify the\ntwo structures in terms of Symmetric Monoidal Categories (SMC), so that we can\napply to PN ordinary analysis techniques developed for BN. Interestingly, it\nturns out that PN which cannot be SMC-decomposed are exactly s-cells. This\nresult confirms the importance for Petri nets of both SMC and s-cells.\n", "versions": [{"version": "v1", "created": "Tue, 17 Jul 2018 09:48:37 GMT"}], "update_date": "2018-07-18", "authors_parsed": [["Bruni", "Roberto", ""], ["Melgratti", "Hern\u00e1n", ""], ["Montanari", "Ugo", ""]]}, {"id": "1807.06397", "submitter": "Ronald de Haan", "authors": "Ronald de Haan", "title": "Expressing Linear Orders Requires Exponential-Size DNNFs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that any DNNF circuit that expresses the set of linear orders over a\nset of $n$ candidates must be of size $2^{\\Omega(n)}$. Moreover, we show that\nthere exist DNNF circuits of size $2^{O(n)}$ expressing linear orders over $n$\ncandidates.\n", "versions": [{"version": "v1", "created": "Tue, 17 Jul 2018 13:02:55 GMT"}, {"version": "v2", "created": "Wed, 18 Jul 2018 15:45:40 GMT"}, {"version": "v3", "created": "Thu, 30 May 2019 12:15:48 GMT"}], "update_date": "2019-05-31", "authors_parsed": [["de Haan", "Ronald", ""]]}, {"id": "1807.06685", "submitter": "Till Mossakowski", "authors": "Till Mossakowski, Fabian Neuhaus", "title": "Modular Semantics and Characteristics for Bipolar Weighted Argumentation\n  Graphs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper addresses the semantics of weighted argumentation graphs that are\nbipolar, i.e. contain both attacks and supports for arguments. It builds on\nprevious work by Amgoud, Ben-Naim et. al. We study the various characteristics\nof acceptability semantics that have been introduced in these works, and\nintroduce the notion of a modular acceptability semantics. A semantics is\nmodular if it cleanly separates aggregation of attacking and supporting\narguments (for a given argument $a$) from the computation of their influence on\n$a$'s initial weight.\n  We show that the various semantics for bipolar argumentation graphs from the\nliterature may be analysed as a composition of an aggregation function with an\ninfluence function. Based on this modular framework, we prove general\nconvergence and divergence theorems. We demonstrate that all well-behaved\nmodular acceptability semantics converge for all acyclic graphs and that no\nsum-based semantics can converge for all graphs. In particular, we show\ndivergence of Euler-based semantics (Amgoud et al.) for certain cyclic graphs.\nFurther, we provide the first semantics for bipolar weighted graphs that\nconverges for all graphs.\n", "versions": [{"version": "v1", "created": "Tue, 17 Jul 2018 21:54:49 GMT"}, {"version": "v2", "created": "Wed, 26 Sep 2018 19:33:13 GMT"}], "update_date": "2018-09-28", "authors_parsed": [["Mossakowski", "Till", ""], ["Neuhaus", "Fabian", ""]]}, {"id": "1807.06777", "submitter": "Sasha Rubin", "authors": "Benjamin Aminof, Giuseppe De Giacomo, Aniello Murano, Sasha Rubin", "title": "Planning and Synthesis Under Assumptions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In Reasoning about Action and Planning, one synthesizes the agent plan by\ntaking advantage of the assumption on how the environment works (that is, one\nexploits the environment's effects, its fairness, its trajectory constraints).\nIn this paper we study this form of synthesis in detail. We consider\nassumptions as constraints on the possible strategies that the environment can\nhave in order to respond to the agent's actions. Such constraints may be given\nin the form of a planning domain (or action theory), as linear-time formulas\nover infinite or finite runs, or as a combination of the two. We argue though\nthat not all assumption specifications are meaningful: they need to be\nconsistent, which means that there must exist an environment strategy\nfulfilling the assumption in spite of the agent actions. For such assumptions,\nwe study how to do synthesis/planning for agent goals, ranging from a classical\nreachability to goal on traces specified in \\LTL and \\LTLf/\\LDLf,\ncharacterizing the problem both mathematically and algorithmically.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jul 2018 05:23:43 GMT"}, {"version": "v2", "created": "Tue, 21 May 2019 22:42:13 GMT"}], "update_date": "2019-05-23", "authors_parsed": [["Aminof", "Benjamin", ""], ["De Giacomo", "Giuseppe", ""], ["Murano", "Aniello", ""], ["Rubin", "Sasha", ""]]}, {"id": "1807.06862", "submitter": "Luigi Santocanale", "authors": "Maria Jo\\~ao Gouveia (ULISBOA), Luigi Santocanale (LIS)", "title": "Mix $\\star$-autonomous quantales and the continuous weak order", "comments": null, "journal-ref": "RAMICS 2018, Oct 2018, Groningen, Netherlands", "doi": null, "report-no": null, "categories": "math.LO cs.LO math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The set of permutations on a finite set can be given a lattice structure\n(known as the weak Bruhat order). The lattice structure is generalized to the\nset of words on a fixed alphabet $\\Sigma = \\{ x, y, z, ... \\}$, where each\nletter has a fixed number of occurrences (these lattices are known as\nmultinomial lattices and, in dimension 2, as lattices of lattice paths). By\ninterpreting the letters $x, y, z, ...$ as axes, these words can be interpreted\nas discrete increasing paths on a grid of a $d$-dimensional cube, where $d =\n{\\rm card}(\\Sigma)$. We show in this paper how to extend this order to images\nof continuous monotone paths from the unit interval to a $d$-dimensional cube.\nThe key tool used to realize this construction is the quantale\n$\\mathsf{L}_{\\vee}(\\mathbb{I})$ of join-continuous functions from the unit\ninterval to itself; the construction relies on a few algebraic properties of\nthis quantale: it is $\\star$-autonomous and it satisfies the mix rule. We begin\ndeveloping a structural theory of these lattices by characterizing\njoin-irreducible elements, and by proving these lattices are generated from\ntheir join-irreducible elements under infinite joins.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jul 2018 11:06:14 GMT"}], "update_date": "2018-07-19", "authors_parsed": [["Gouveia", "Maria Jo\u00e3o", "", "ULISBOA"], ["Santocanale", "Luigi", "", "LIS"]]}, {"id": "1807.07091", "submitter": "Thorsten Wissmann", "authors": "\\'Etienne Andr\\'e, Didier Lime and Nicolas Markey", "title": "Language Preservation Problems in Parametric Timed Automata", "comments": "Extended version of the paper of the name published in the\n  proceedings of FORMATS 2015", "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 1 (January\n  22, 2020) lmcs:6042", "doi": "10.23638/LMCS-16(1:5)2020", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Parametric timed automata (PTA) are a powerful formalism to model and reason\nabout concurrent systems with some unknown timing delays. In this paper, we\naddress the (untimed) language- and trace-preservation problems: given a\nreference parameter valuation, does there exist another parameter valuation\nwith the same untimed language, or with the same set of traces? We show that\nthese problems are undecidable both for general PTA and for the restricted\nclass of L/U-PTA, even for integer-valued parameters, or over bounded time. On\nthe other hand, we exhibit decidable subclasses: 1-clock PTA, and 1-parameter\ndeterministic L-PTA and U-PTA. We also consider robust versions of these\nproblems, where we additionally require that the language be preserved for all\nvaluations between the reference valuation and the new valuation.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jul 2018 18:16:22 GMT"}, {"version": "v2", "created": "Thu, 31 Jan 2019 11:01:27 GMT"}, {"version": "v3", "created": "Mon, 20 Jan 2020 20:08:56 GMT"}], "update_date": "2020-06-17", "authors_parsed": [["Andr\u00e9", "\u00c9tienne", ""], ["Lime", "Didier", ""], ["Markey", "Nicolas", ""]]}, {"id": "1807.07159", "submitter": "Arnaud Spiwack", "authors": "Arnaud Spiwack", "title": "Circuits via topoi", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Leveraging topos theory a semantics can be given to sequential circuits where\ntime-sensitive gates, such as unit delay, are treated uniformly with\ncombinational gates. Both kinds of gates are functions in a particular topos:\nthe topos of presheaves over the natural ordering of $\\mathbb{N}$. This is used\nto show that sequential circuits validate the equational theory of traced\ncategories.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jul 2018 21:19:09 GMT"}], "update_date": "2018-07-20", "authors_parsed": [["Spiwack", "Arnaud", ""]]}, {"id": "1807.07378", "submitter": "Adnan Rashid", "authors": "Adnan Rashid and Osman Hasan", "title": "Formal Modeling of Robotic Cell Injection Systems in Higher-order Logic", "comments": "Formal Verification of Physical Systems (FVPS-2018), co-located with\n  Conference on Intelligent Computer Mathematics (CICM-2018). arXiv admin note:\n  text overlap with arXiv:1805.02858", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Robotic cell injection is used for automatically delivering substances into a\ncell and is an integral component of drug development, genetic engineering and\nmany other areas of cell biology. Traditionally, the correctness of\nfunctionality of these systems is ascertained using paper-and-pencil proof and\ncomputer simulation methods. However, the paper based proofs can be human-error\nprone and the simulation provides an incomplete analysis due to its sampling\nbased nature and the inability to capture continuous behaviors in computer\nbased models. Model checking has been recently advocated for the analysis of\ncell injection systems as well. However, it involves the discretization of the\ndifferential equations that are used for modeling the dynamics of the system\nand thus compromises on the completeness of the analysis as well. In this\npaper, we propose to use higher-order-logic theorem proving for the modeling\nand analysis of the dynamical behaviour of the robotic cell injection systems.\nThe high expressiveness of the underlying logic allows us to capture the\ncontinuous details of the model in their true form. Then, the model can be\nanalyzed using deductive reasoning within the sound core of a proof assistant.\n", "versions": [{"version": "v1", "created": "Wed, 18 Jul 2018 16:50:54 GMT"}], "update_date": "2018-07-20", "authors_parsed": [["Rashid", "Adnan", ""], ["Hasan", "Osman", ""]]}, {"id": "1807.07794", "submitter": "Ghislain Fourny", "authors": "Ghislain Fourny", "title": "Kripke Semantics of the Perfectly Transparent Equilibrium", "comments": "Working paper", "journal-ref": null, "doi": "10.3929/ethz-b-000277118", "report-no": null, "categories": "cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Perfectly Transparent Equilibrium is algorithmically defined, for any\ngame in normal form with perfect information and no ties, as the iterated\ndeletion of non-individually-rational strategy profiles until at most one\nremains. In this paper, we characterize the Perfectly Transparent Equilibrium\nwith adapted Kripke models having necessary rationality, necessary knowledge of\nstrategies as well as eventual logical omniscience.\n  Eventual logical omniscience is introduced as a weaker version of perfect\nlogical omniscience, with logical omniscience being quantized and fading away\ncounterfactually. It is the price to pay for necessary factual omniscience and\nnecessary rationality: we conjecture that epistemic omniscience, logical\nomniscience and necessary rationality form an impossibility triangle.\n  We consider multimodal classes of Kripke structures, with respect to agents,\nbut also in the sense that we have both epistemic and logical accessibility\nrelations. Knowledge is defined in terms of the former, while necessity is\ndefined in terms of the latter. Lewisian closest-state functions, which are not\nrestricted to unilateral deviations, model counterfactuals.\n  We use impossible possible worlds \\`a la Rantala to model that some strategy\nprofiles cannot possibly be reached in some situations. Eventual logical\nomniscience is then bootstrapped with the agents' considering that, at\nlogically possible, but non-normal worlds \\`a la Kripke, any world is logically\naccessible and thus any deviation of strategy is possible. As in known in\nliterature, under rationality and knowledge of strategies, these worlds\ncharacterize individual rationality. Then, in normal worlds, higher levels of\nlogical omniscience characterize higher levels of individual rationality, and a\nhigh-enough level of logical omniscience characterizes, when it exists, the\nPerfectly Transparent Equilibrium.\n", "versions": [{"version": "v1", "created": "Fri, 20 Jul 2018 11:27:44 GMT"}], "update_date": "2018-07-23", "authors_parsed": [["Fourny", "Ghislain", ""]]}, {"id": "1807.07828", "submitter": "EPTCS", "authors": "Jules Hedges (University of Oxford), Martha Lewis (ILLC, University of\n  Amsterdam)", "title": "Towards Functorial Language-Games", "comments": "In Proceedings CAPNS 2018, arXiv:1811.02701", "journal-ref": "EPTCS 283, 2018, pp. 89-102", "doi": "10.4204/EPTCS.283.7", "report-no": null, "categories": "cs.LO cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In categorical compositional semantics of natural language one studies\nfunctors from a category of grammatical derivations (such as a Lambek pregroup)\nto a semantic category (such as real vector spaces). We compositionally build\ngame-theoretic semantics of sentences by taking the semantic category to be the\ncategory whose morphisms are open games. This requires some modifications to\nthe grammar category to compensate for the failure of open games to form a\ncompact closed category. We illustrate the theory using simple examples of\nWittgenstein's language-games.\n", "versions": [{"version": "v1", "created": "Fri, 20 Jul 2018 13:18:15 GMT"}, {"version": "v2", "created": "Thu, 8 Nov 2018 05:12:27 GMT"}], "update_date": "2018-11-09", "authors_parsed": [["Hedges", "Jules", "", "University of Oxford"], ["Lewis", "Martha", "", "ILLC, University of\n  Amsterdam"]]}, {"id": "1807.08058", "submitter": "Markus N Rabe", "authors": "Gil Lederman and Markus N. Rabe and Edward A. Lee and Sanjit A. Seshia", "title": "Learning Heuristics for Quantified Boolean Formulas through Deep\n  Reinforcement Learning", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We demonstrate how to learn efficient heuristics for automated reasoning\nalgorithms for quantified Boolean formulas through deep reinforcement learning.\nWe focus on a backtracking search algorithm, which can already solve formulas\nof impressive size - up to hundreds of thousands of variables. The main\nchallenge is to find a representation of these formulas that lends itself to\nmaking predictions in a scalable way. For a family of challenging problems, we\nlearned a heuristic that solves significantly more formulas compared to the\nexisting handwritten heuristics.\n", "versions": [{"version": "v1", "created": "Fri, 20 Jul 2018 23:59:36 GMT"}, {"version": "v2", "created": "Fri, 12 Apr 2019 07:23:14 GMT"}, {"version": "v3", "created": "Wed, 30 Oct 2019 19:38:45 GMT"}], "update_date": "2019-11-01", "authors_parsed": [["Lederman", "Gil", ""], ["Rabe", "Markus N.", ""], ["Lee", "Edward A.", ""], ["Seshia", "Sanjit A.", ""]]}, {"id": "1807.08117", "submitter": "L\\'eo Stefanesco", "authors": "Paul-Andr\\'e Melli\\`es and L\\'eo Stefanesco", "title": "An Asynchronous soundness theorem for concurrent separation logic", "comments": "Full version of an extended abstract published at LICS 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Concurrent separation logic (CSL) is a specification logic for concurrent\nimperative programs with shared memory and locks. In this paper, we develop a\nconcurrent and interactive account of the logic inspired by asynchronous game\nsemantics. To every program $C$, we associate a pair of asynchronous transition\nsystems $[C]_S$ and $[C]_L$ which describe the operational behavior of the Code\nwhen confronted to its Environment or Frame --- both at the level of machine\nstates ($S$) and of machine instructions and locks ($L$). We then establish\nthat every derivation tree $\\pi$ of a judgment $\\Gamma\\vdash\\{P\\}C\\{Q\\}$\ndefines a winning and asynchronous strategy $[\\pi]_{Sep}$ with respect to both\nasynchronous semantics $[C]_S$ and $[C]_L$. From this, we deduce an\nasynchronous soundness theorem for CSL, which states that the canonical map\n$\\mathcal{L}:[C]_S\\to[C]_L$ from the stateful semantics $[C]_S$ to the\nstateless semantics $[C]_L$ satisfies a basic fibrational property. We advocate\nthat this provides a clean and conceptual explanation for the usual soundness\ntheorem of CSL, including the absence of data races.\n", "versions": [{"version": "v1", "created": "Sat, 21 Jul 2018 10:01:36 GMT"}], "update_date": "2018-07-24", "authors_parsed": [["Melli\u00e8s", "Paul-Andr\u00e9", ""], ["Stefanesco", "L\u00e9o", ""]]}, {"id": "1807.08137", "submitter": "Soonho Kong", "authors": "Soonho Kong, Armando Solar-Lezama, Sicun Gao", "title": "Delta-Decision Procedures for Exists-Forall Problems over the Reals", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Solving nonlinear SMT problems over real numbers has wide applications in\nrobotics and AI. While significant progress is made in solving quantifier-free\nSMT formulas in the domain, quantified formulas have been much less\ninvestigated. We propose the first delta-complete algorithm for solving\nsatisfiability of nonlinear SMT over real numbers with universal quantification\nand a wide range of nonlinear functions. Our methods combine ideas from\ncounterexample-guided synthesis, interval constraint propagation, and local\noptimization. In particular, we show how special care is required in handling\nthe interleaving of numerical and symbolic reasoning to ensure\ndelta-completeness. In experiments, we show that the proposed algorithms can\nhandle many new problems beyond the reach of existing SMT solvers.\n", "versions": [{"version": "v1", "created": "Sat, 21 Jul 2018 12:14:59 GMT"}], "update_date": "2018-07-24", "authors_parsed": [["Kong", "Soonho", ""], ["Solar-Lezama", "Armando", ""], ["Gao", "Sicun", ""]]}, {"id": "1807.08203", "submitter": "Martin Zimmermann", "authors": "Corto Mascle, Daniel Neider, Maximilian Schwenger, Paulo Tabuada,\n  Alexander Weinert, Martin Zimmermann", "title": "From LTL to rLTL Monitoring: Improved Monitorability through Robust\n  Semantics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Runtime monitoring is commonly used to detect the violation of desired\nproperties in safety critical cyber-physical systems by observing its\nexecutions. Bauer et al. introduced an influential framework for monitoring\nLinear Temporal Logic (LTL) properties based on a three-valued semantics: the\nformula is already satisfied by the given prefix, it is already violated, or it\nis still undetermined, i.e., it can still be satisfied and violated by\nappropriate extensions. However, a wide range of formulas are not monitorable\nunder this approach, meaning that they have a prefix for which satisfaction and\nviolation will always remain undetermined no matter how it is extended. In\nparticular, Bauer et al. report that 44% of the formulas they consider in their\nexperiments fall into this category.\n  Recently, a robust semantics for LTL was introduced to capture different\ndegrees by which a property can be violated. In this paper we introduce a\nrobust semantics for finite strings and show its potential in monitoring: every\nformula considered by Bauer et al. is monitorable under our approach.\nFurthermore, we discuss which properties that come naturally in LTL monitoring\n- such as the realizability of all truth values - can be transferred to the\nrobust setting. Lastly, we show that LTL formulas with robust semantics can be\nmonitored by deterministic automata and report on a prototype implementation.\n", "versions": [{"version": "v1", "created": "Sat, 21 Jul 2018 20:23:03 GMT"}, {"version": "v2", "created": "Mon, 20 May 2019 09:03:30 GMT"}, {"version": "v3", "created": "Fri, 20 Mar 2020 16:43:56 GMT"}, {"version": "v4", "created": "Mon, 6 Apr 2020 09:02:38 GMT"}], "update_date": "2020-04-07", "authors_parsed": [["Mascle", "Corto", ""], ["Neider", "Daniel", ""], ["Schwenger", "Maximilian", ""], ["Tabuada", "Paulo", ""], ["Weinert", "Alexander", ""], ["Zimmermann", "Martin", ""]]}, {"id": "1807.08267", "submitter": "Florin Stoica", "authors": "Florin Stoica, Laura Florentina Stoica", "title": "Generating an ATL Model Checker using an Attribute Grammar", "comments": "18 pages, 7 figures, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB cs.DC cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we use attribute grammars as a formal approach for model\ncheckers development. Our aim is to design an ATL (Alternating-Time Temporal\nLogic) model checker from a context-free grammar which generates the language\nof the ATL formulas. An attribute grammar may be informally defined as a\ncontext-free grammar which is extended with a set of attributes and a\ncollection of semantic rules. We use an ATL attribute grammar for specifying an\noperational semantics of the language of the ATL formulas by defining a\ntranslation into the language which describes the set of states from the ATL\nmodel where the corresponding ATL formulas are satisfied. We provide a formal\ndefinition for an attribute grammar used as input for Another Tool for Language\nRecognition (ANTLR) to generate an ATL model checker. Also, the technique of\nimplementing the semantic actions in ANTLR is presented, which is the concept\nof connection between attribute evaluation in the grammar that generates the\nlanguage of ATL formulas and algebraic compiler implementation that represents\nthe ATL model checker. The original implementation of the model checking\nalgorithm is based on Relational Databases and Web Services. Several database\nsystems and Web Services technologies were used for evaluating the system\nperformance in verification of large ATL models.\n", "versions": [{"version": "v1", "created": "Sun, 22 Jul 2018 10:18:12 GMT"}, {"version": "v2", "created": "Tue, 5 Feb 2019 15:54:54 GMT"}], "update_date": "2019-02-06", "authors_parsed": [["Stoica", "Florin", ""], ["Stoica", "Laura Florentina", ""]]}, {"id": "1807.08487", "submitter": "Ond\\v{r}ej Leng\\'al", "authors": "Luk\\'a\\v{s} Hol\\'ik, Ond\\v{r}ej Leng\\'al, Juraj S\\'i\\v{c}, Margus\n  Veanes, Tom\\'a\\v{s} Vojnar", "title": "Simulation Algorithms for Symbolic Automata (Technical Report)", "comments": "To appear in ATVA'18", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate means of efficient computation of the simulation relation over\nsymbolic finite automata (SFAs), i.e., finite automata with transitions labeled\nby predicates over alphabet symbols. In one approach, we build on the algorithm\nby Ilie, Navaro, and Yu proposed originally for classical finite automata,\nmodifying it using the so-called mintermisation of the transition predicates.\nThis solution, however, generates all Boolean combinations of the predicates,\nwhich easily causes an exponential blowup in the number of transitions.\nTherefore, we propose two more advanced solutions. The first one still applies\nmintermisation but in a local way, mitigating the size of the exponential\nblowup. The other one focuses on a novel symbolic way of dealing with\ntransitions, for which we need to sacrifice the counting technique of the\noriginal algorithm (counting is used to decrease the dependency of the running\ntime on the number of transitions from quadratic to linear). We perform a\nthorough experimental evaluation of all the algorithms, together with several\nfurther alternatives, showing that all of them have their merits in practice,\nbut with the clear indication that in most of the cases, efficient treatment of\nsymbolic transitions is more beneficial than counting.\n", "versions": [{"version": "v1", "created": "Mon, 23 Jul 2018 08:59:11 GMT"}, {"version": "v2", "created": "Fri, 27 Jul 2018 14:20:21 GMT"}], "update_date": "2018-07-30", "authors_parsed": [["Hol\u00edk", "Luk\u00e1\u0161", ""], ["Leng\u00e1l", "Ond\u0159ej", ""], ["S\u00ed\u010d", "Juraj", ""], ["Veanes", "Margus", ""], ["Vojnar", "Tom\u00e1\u0161", ""]]}, {"id": "1807.08506", "submitter": "Thorsten Wissmann", "authors": "Miko{\\l}aj Boja\\'nczyk, Laure Daviaud, Bruno Guillon, Vincent Penelle,\n  A. V. Sreejith", "title": "Undecidability of a weak version of MSO+U", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 1 (February\n  11, 2020) lmcs:6084", "doi": "10.23638/LMCS-16(1:12)2020", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We prove the undecidability of MSO on $\\omega$-words extended with the\nsecond-order predicate $U_1(X)$ which says that the distance between\nconsecutive positions in a set $X \\subseteq \\mathbb{N}$ is unbounded. This is\nachieved by showing that adding $U_1$ to MSO gives a logic with the same\nexpressive power as $MSO+U$, a logic on $\\omega$-words with undecidable\nsatisfiability. As a corollary, we prove that MSO on $\\omega$-words becomes\nundecidable if allowing to quantify over sets of positions that are ultimately\nperiodic, i.e., sets $X$ such that for some positive integer $p$, ultimately\neither both or none of positions $x$ and $x+p$ belong to $X$.\n", "versions": [{"version": "v1", "created": "Mon, 23 Jul 2018 09:49:40 GMT"}, {"version": "v2", "created": "Mon, 31 Dec 2018 05:03:55 GMT"}, {"version": "v3", "created": "Wed, 5 Jun 2019 15:01:19 GMT"}, {"version": "v4", "created": "Thu, 6 Jun 2019 14:36:00 GMT"}, {"version": "v5", "created": "Mon, 10 Feb 2020 10:42:58 GMT"}], "update_date": "2020-06-17", "authors_parsed": [["Boja\u0144czyk", "Miko\u0142aj", ""], ["Daviaud", "Laure", ""], ["Guillon", "Bruno", ""], ["Penelle", "Vincent", ""], ["Sreejith", "A. V.", ""]]}, {"id": "1807.08588", "submitter": "Simon Foster", "authors": "Simon Foster, James Baxter, Ana Cavalcanti, Alvaro Miyazawa, Jim\n  Woodcock", "title": "Automating Verification of State Machines with Reactive Designs and\n  Isabelle/UTP", "comments": "18 pages, 16th Intl. Conf. on Formal Aspects of Component Software\n  (FACS 2018), October 2018, Pohang, South Korea", "journal-ref": null, "doi": "10.1007/978-3-030-02146-7_7", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  State-machine based notations are ubiquitous in the description of component\nsystems, particularly in the robotic domain. To ensure these systems are safe\nand predictable, formal verification techniques are important, and can be\ncost-effective if they are both automated and scalable. In this paper, we\npresent a verification approach for a diagrammatic state machine language that\nutilises theorem proving and a denotational semantics based on Unifying\nTheories of Programming (UTP). We provide the necessary theory to underpin\nstate machines (including induction theorems for iterative processes),\nmechanise an action language for states and transitions, and use these to\nformalise the semantics. We then describe the verification approach, which\nsupports infinite state systems, and exemplify it with a fully automated\ndeadlock-freedom check. The work has been mechanised in our proof tool,\nIsabelle/UTP, and so also illustrates the use of UTP to build practical\nverification tools.\n", "versions": [{"version": "v1", "created": "Mon, 23 Jul 2018 13:13:11 GMT"}, {"version": "v2", "created": "Fri, 24 Aug 2018 10:35:42 GMT"}], "update_date": "2018-10-11", "authors_parsed": [["Foster", "Simon", ""], ["Baxter", "James", ""], ["Cavalcanti", "Ana", ""], ["Miyazawa", "Alvaro", ""], ["Woodcock", "Jim", ""]]}, {"id": "1807.08964", "submitter": "Vedad Hadzic", "authors": "Roderick Bloem, Nicolas Braud-Santoni, Vedad Hadzic, Uwe Egly, Florian\n  Lonsing, Martina Seidl", "title": "Expansion-Based QBF Solving Without Recursion", "comments": "To appear in proceedings of FMCAD 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In recent years, expansion-based techniques have been shown to be very\npowerful in theory and practice for solving quantified Boolean formulas (QBF),\nthe extension of propositional formulas with existential and universal\nquantifiers over Boolean variables. Such approaches partially expand one type\nof variable (either existential or universal) and pass the obtained formula to\na SAT solver for deciding the QBF. State-of-the-art expansion-based solvers\nprocess the given formula quantifier-block wise and recursively apply expansion\nuntil a solution is found.\n  In this paper, we present a novel algorithm for expansion-based QBF solving\nthat deals with the whole quantifier prefix at once. Hence recursive\napplications of the expansion principle are avoided. Experiments indicate that\nthe performance of our simple approach is comparable with the state of the art\nof QBF solving, especially in combination with other solving techniques.\n", "versions": [{"version": "v1", "created": "Tue, 24 Jul 2018 08:56:09 GMT"}, {"version": "v2", "created": "Fri, 5 Oct 2018 00:03:59 GMT"}], "update_date": "2018-10-08", "authors_parsed": [["Bloem", "Roderick", ""], ["Braud-Santoni", "Nicolas", ""], ["Hadzic", "Vedad", ""], ["Egly", "Uwe", ""], ["Lonsing", "Florian", ""], ["Seidl", "Martina", ""]]}, {"id": "1807.09047", "submitter": "Felix Klein", "authors": "Carsten Gerstacker, Felix Klein, and Bernd Finkbeiner", "title": "Bounded Synthesis of Reactive Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most algorithms for the synthesis of reactive systems focus on the\nconstruction of finite-state machines rather than actual programs. This often\nleads to badly structured, unreadable code. In this paper, we present a bounded\nsynthesis approach that automatically constructs, from a given specification in\nlinear-time temporal logic (LTL), a program in Madhusudan's simple imperative\nlanguage for reactive programs. We develop and compare two principal approaches\nfor the reduction of the synthesis problem to a Boolean constraint satisfaction\nproblem. The first reduction is based on a generalization of bounded synthesis\nto two-way alternating automata, the second reduction is based on a direct\nencoding of the program syntax in the constraint system. We report on\npreliminary experience with a prototype implementation, which indicates that\nthe direct encoding outperforms the automata approach.\n", "versions": [{"version": "v1", "created": "Tue, 24 Jul 2018 11:36:31 GMT"}], "update_date": "2018-07-25", "authors_parsed": [["Gerstacker", "Carsten", ""], ["Klein", "Felix", ""], ["Finkbeiner", "Bernd", ""]]}, {"id": "1807.09175", "submitter": "Antonina Nepeivoda", "authors": "Antonina Nepeivoda", "title": "Supercompiling String Programs Using Word Equations as Constraints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a general parameterized scheme of program and constraint analyses\nallowing us to specify both the program specialization method known as\nTurchin's supercompilation and Hmelevskii's algorithm solving the quadratic\nword equations. The scheme is specified for both sorts of the analysis and\nworks in a joint algorithm in which these two sorts of the analysis are used\ntogether. The word equations and the inequalities on regular patterns are used\nas the string constraint language in the algorithm.\n", "versions": [{"version": "v1", "created": "Fri, 29 Jun 2018 13:50:53 GMT"}], "update_date": "2018-07-25", "authors_parsed": [["Nepeivoda", "Antonina", ""]]}, {"id": "1807.09339", "submitter": "Anna Philippou", "authors": "Panagiotis Kouvaros, Dimitris Kouzapas, Anna Philippou, Julius\n  Georgiou, Loukas Petrou, and Andreas Pitsillides", "title": "Formal Verification of a Programmable Hypersurface", "comments": "13 pages. The paper has been accepted at FMICS 2018 and will be\n  published by Springer", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A metasurface is a surface that consists of artificial material, called\nmetamaterial, with configurable electromagnetic properties. This paper presents\nwork in progress on the design and formal verification of a programmable\nmetasurface, the Hypersurface, as part of the requirements of the VISORSURF\nresearch program (HORIZON 2020 FET-OPEN). The Hypersurface design is concerned\nwith the development of a network of switch controllers that are responsible\nfor configuring the metamaterial. The design of the Hypersurface, however, has\ndemanding requirements that need to be delivered within a context of limited\nresources. This paper shares the experience of a rigorous design procedure for\nthe Hypersurface network, that involves iterations between designing a network\nand its protocols and the formal evaluation of each design. Formal evaluation\nhas provided results that, so far, drive the development team in a more robust\ndesign and overall aid in reducing the cost of the Hypersurface manufacturing.\nThis paper presents work in progress on the design and formal verification of a\nprogrammable Hypersurface as part of the requirements of the VISORSURF research\nprogramme (HORIZON 2020 FET-OPEN).\n", "versions": [{"version": "v1", "created": "Tue, 17 Jul 2018 06:53:15 GMT"}], "update_date": "2018-07-26", "authors_parsed": [["Kouvaros", "Panagiotis", ""], ["Kouzapas", "Dimitris", ""], ["Philippou", "Anna", ""], ["Georgiou", "Julius", ""], ["Petrou", "Loukas", ""], ["Pitsillides", "Andreas", ""]]}, {"id": "1807.09466", "submitter": "Mingsheng Ying", "authors": "Mingsheng Ying and Yuan Feng", "title": "Model Checking Quantum Systems --- A Survey", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article discusses the essential difficulties in developing\nmodel-checking techniques for quantum systems that are never present in model\nchecking classical systems. It further reviews some early researches on\nchecking quantum communication protocols as well as a new line of researches\npursued by the authors and their collaborators on checking general quantum\nsystems, applicable to both physical systems and quantum programs.\n", "versions": [{"version": "v1", "created": "Wed, 25 Jul 2018 07:58:14 GMT"}], "update_date": "2018-07-26", "authors_parsed": [["Ying", "Mingsheng", ""], ["Feng", "Yuan", ""]]}, {"id": "1807.09641", "submitter": "Pranav Ashok", "authors": "Pranav Ashok, Yuliya Butkova, Holger Hermanns, Jan K\\v{r}et\\'insk\\'y", "title": "Continuous-Time Markov Decisions based on Partial Exploration", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide a framework for speeding up algorithms for time-bounded\nreachability analysis of continuous-time Markov decision processes. The\nprinciple is to find a small, but almost equivalent subsystem of the original\nsystem and only analyse the subsystem. Candidates for the subsystem are\nidentified through simulations and iteratively enlarged until runs are\nrepresented in the subsystem with high enough probability. The framework is\nthus dual to that of abstraction refinement. We instantiate the framework in\nseveral ways with several traditional algorithms and experimentally confirm\norders-of-magnitude speed ups in many cases.\n", "versions": [{"version": "v1", "created": "Wed, 25 Jul 2018 14:45:13 GMT"}], "update_date": "2018-07-26", "authors_parsed": [["Ashok", "Pranav", ""], ["Butkova", "Yuliya", ""], ["Hermanns", "Holger", ""], ["K\u0159et\u00ednsk\u00fd", "Jan", ""]]}, {"id": "1807.09873", "submitter": "Mnacho Echenim Mr", "authors": "Mnacho Echenim, Herv\\'e Guiol, Nicolas Peltier", "title": "Formalizing the Cox-Ross-Rubinstein pricing of European derivatives in\n  Isabelle/HOL", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO q-fin.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We formalize in the proof assistant Isabelle essential basic notions and\nresults in financial mathematics. We provide generic formal definitions of\nconcepts such as markets, portfolios, derivative products, arbitrages or fair\nprices, and we show that, under the usual no-arbitrage condition, the existence\nof a replicating portfolio for a derivative implies that the latter admits a\nunique fair price. Then, we provide a formalization of the Cox-Rubinstein model\nand we show that the market is complete in this model, i.e., that every\nderivative product admits a replicating portfolio. This entails that in this\nmodel, every derivative product admits a unique fair price.\n", "versions": [{"version": "v1", "created": "Wed, 25 Jul 2018 21:39:33 GMT"}, {"version": "v2", "created": "Fri, 10 Aug 2018 15:37:55 GMT"}], "update_date": "2018-08-13", "authors_parsed": [["Echenim", "Mnacho", ""], ["Guiol", "Herv\u00e9", ""], ["Peltier", "Nicolas", ""]]}, {"id": "1807.10015", "submitter": "David Purser", "authors": "Dmitry Chistikov, Andrzej S. Murawski, David Purser", "title": "Bisimilarity Distances for Approximate Differential Privacy", "comments": "To appear International Symposium on Automated Technology for\n  Verification and Analysis // October 7-10, 2018", "journal-ref": null, "doi": "10.1007/978-3-030-01090-4_12", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Differential privacy is a widely studied notion of privacy for various models\nof computation. Technically, it is based on measuring differences between\nprobability distributions. We study $\\epsilon,\\delta$-differential privacy in\nthe setting of labelled Markov chains. While the exact differences relevant to\n$\\epsilon,\\delta$-differential privacy are not computable in this framework, we\npropose a computable bisimilarity distance that yields a sound technique for\nmeasuring $\\delta$, the parameter that quantifies deviation from pure\ndifferential privacy. We show this bisimilarity distance is always rational,\nthe associated threshold problem is in NP, and the distance can be computed\nexactly with polynomially many calls to an NP oracle.\n", "versions": [{"version": "v1", "created": "Thu, 26 Jul 2018 08:52:17 GMT"}, {"version": "v2", "created": "Thu, 13 Sep 2018 15:52:28 GMT"}], "update_date": "2020-07-16", "authors_parsed": [["Chistikov", "Dmitry", ""], ["Murawski", "Andrzej S.", ""], ["Purser", "David", ""]]}, {"id": "1807.10210", "submitter": "EPTCS", "authors": "Tom van Dijk (University of Twente)", "title": "A Parity Game Tale of Two Counters", "comments": "In Proceedings GandALF 2019, arXiv:1909.05979", "journal-ref": "EPTCS 305, 2019, pp. 107-122", "doi": "10.4204/EPTCS.305.8", "report-no": null, "categories": "cs.LO cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parity games are simple infinite games played on finite graphs with a winning\ncondition that is expressive enough to capture nested least and greatest\nfixpoints. Through their tight relationship to the modal mu-calculus, they are\nused in practice for the model-checking and synthesis problems of the\nmu-calculus and related temporal logics like LTL and CTL. Solving parity games\nis a compelling complexity theoretic problem, as the problem lies in the\nintersection of UP and co-UP and is believed to admit a polynomial-time\nsolution, motivating researchers to either find such a solution or to find\nsuperpolynomial lower bounds for existing algorithms to improve the\nunderstanding of parity games. We present a parameterized parity game called\nthe Two Counters game, which provides an exponential lower bound for a wide\nrange of attractor-based parity game solving algorithms. We are the first to\nprovide an exponential lower bound to priority promotion with the delayed\npromotion policy, and the first to provide such a lower bound to tangle\nlearning.\n", "versions": [{"version": "v1", "created": "Thu, 26 Jul 2018 15:52:51 GMT"}, {"version": "v2", "created": "Thu, 2 Aug 2018 15:42:44 GMT"}, {"version": "v3", "created": "Tue, 17 Sep 2019 09:01:18 GMT"}], "update_date": "2019-09-18", "authors_parsed": [["van Dijk", "Tom", "", "University of Twente"]]}, {"id": "1807.10248", "submitter": "Anupam Das", "authors": "Anupam Das", "title": "On the logical complexity of cyclic arithmetic", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 1 (January\n  6, 2020) lmcs:6008", "doi": "10.23638/LMCS-16(1:1)2020", "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study the logical complexity of proofs in cyclic arithmetic\n($\\mathsf{CA}$), as introduced in Simpson '17, in terms of quantifier\nalternations of formulae occurring. Writing $C\\Sigma_n$ for (the logical\nconsequences of) cyclic proofs containing only $\\Sigma_n$ formulae, our main\nresult is that $I\\Sigma_{n+1}$ and $C\\Sigma_n$ prove the same $\\Pi_{n+1}$\ntheorems, for all $n\\geq 0$. Furthermore, due to the 'uniformity' of our\nmethod, we also show that $\\mathsf{CA}$ and Peano Arithmetic ($\\mathsf{PA}$)\nproofs of the same theorem differ only exponentially in size.\n  The inclusion $I\\Sigma_{n+1} \\subseteq C\\Sigma_n$ is obtained by proof\ntheoretic techniques, relying on normal forms and structural manipulations of\n$\\mathsf{PA}$ proofs. It improves upon the natural result that $I\\Sigma_n$ is\ncontained in $C\\Sigma_n$. The converse inclusion, $C\\Sigma_n \\subseteq\nI\\Sigma_{n+1}$, is obtained by calibrating the approach of Simpson '17 with\nrecent results on the reverse mathematics of B\\\"uchi's theorem in\nKo{\\l}odziejczyk, Michalewski, Pradic & Skrzypczak '16 (KMPS'16), and\nspecialising to the case of cyclic proofs. These results improve upon the\nbounds on proof complexity and logical complexity implicit in Simpson '17 and\nalso an alternative approach due to Berardi & Tatsuta '17.\n  The uniformity of our method also allows us to recover a metamathematical\naccount of fragments of $\\mathsf{CA}$; in particular we show that, for $n\\geq\n0$, the consistency of $C\\Sigma_n$ is provable in $I\\Sigma_{n+2}$ but not\n$I\\Sigma_{n+1}$. As a result, we show that certain versions of McNaughton's\ntheorem (the determinisation of $\\omega$-word automata) are not provable in\n$\\mathsf{RCA}_0$, partially resolving an open problem from KMPS '16.\n", "versions": [{"version": "v1", "created": "Thu, 26 Jul 2018 17:12:28 GMT"}, {"version": "v2", "created": "Fri, 27 Jul 2018 09:05:14 GMT"}, {"version": "v3", "created": "Tue, 11 Sep 2018 16:06:49 GMT"}, {"version": "v4", "created": "Wed, 10 Jul 2019 12:05:07 GMT"}, {"version": "v5", "created": "Mon, 21 Oct 2019 11:53:19 GMT"}, {"version": "v6", "created": "Fri, 3 Jan 2020 14:07:50 GMT"}], "update_date": "2020-06-17", "authors_parsed": [["Das", "Anupam", ""]]}, {"id": "1807.10268", "submitter": "Andrzej Kucik", "authors": "Andrzej Stanis{\\l}aw Kucik, Konstantin Korovin", "title": "Premise selection with neural networks and distributed representation of\n  features", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present the problem of selecting relevant premises for a proof of a given\nstatement. When stated as a binary classification task for pairs (conjecture,\naxiom), it can be efficiently solved using artificial neural networks. The key\ndifference between our advance to solve this problem and previous approaches is\nthe use of just functional signatures of premises. To further improve the\nperformance of the model, we use dimensionality reduction technique, to replace\nlong and sparse signature vectors with their compact and dense embedded\nversions. These are obtained by firstly defining the concept of a context for\neach functor symbol, and then training a simple neural network to predict the\ndistribution of other functor symbols in the context of this functor. After\ntraining the network, the output of its hidden layer is used to construct a\nlower dimensional embedding of a functional signature (for each premise) with a\ndistributed representation of features. This allows us to use 512-dimensional\nembeddings for conjecture-axiom pairs, containing enough information about the\noriginal statements to reach the accuracy of 76.45% in premise selection task,\nonly with simple two-layer densely connected neural networks.\n", "versions": [{"version": "v1", "created": "Thu, 26 Jul 2018 17:54:58 GMT"}], "update_date": "2018-07-27", "authors_parsed": [["Kucik", "Andrzej Stanis\u0142aw", ""], ["Korovin", "Konstantin", ""]]}, {"id": "1807.10414", "submitter": "Yuri Gurevich", "authors": "Andreas Blass and Yuri Gurevich", "title": "Witness Algebra and Anyon Braiding", "comments": "Added arXiv reference for the companion paper [3]", "journal-ref": "Math. Struct. Comp. Sci. 30 (2020) 234-270", "doi": "10.1017/S0960129520000055", "report-no": null, "categories": "quant-ph cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Topological quantum computation employs two-dimensional quasiparticles called\nanyons. The generally accepted mathematical basis for the theory of anyons is\nthe framework of modular tensor categories. That framework involves a\nsubstantial amount of category theory and is, as a result, considered rather\ndifficult to understand. Is the complexity of the present framework necessary?\nThe computations of associativity and braiding matrices can be based on a much\nsimpler framework, which looks less like category theory and more like familiar\nalgebra. We introduce that framework here.\n", "versions": [{"version": "v1", "created": "Fri, 27 Jul 2018 01:55:42 GMT"}, {"version": "v2", "created": "Thu, 2 Aug 2018 22:00:36 GMT"}], "update_date": "2020-04-15", "authors_parsed": [["Blass", "Andreas", ""], ["Gurevich", "Yuri", ""]]}, {"id": "1807.10492", "submitter": "Franziskus Wiesnet", "authors": "Franziskus Wiesnet", "title": "Limits with Signed Digit Streams", "comments": "17 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We work with the signed digit representation of abstract real numbers, which\nroughly is the binary representation enriched by the additional digit -1. The\nmain objective of this paper is an algorithm which takes a sequence of signed\ndigit representations of reals and returns the signed digit representation of\ntheir limit, if the sequence converges. As a first application we use this\nalgorithm together with Heron's method to build up an algorithm which converts\nthe signed digit representation of a non-negative real number into the signed\ndigit representation of its square root. Instead of writing the algorithms\nfirst and proving their correctness afterwards, we work the other way round, in\nthe tradition of program extraction from proofs. In fact we first give\nconstructive proofs, and from these proofs we then compute the extracted terms,\nwhich is the desired algorithm. The correctness of the extracted term follows\ndirectly by the Soundness Theorem of program extraction. In order to get the\nextracted term from some proofs which are often quite long, we use the proof\nassistant Minlog. However, to apply the extracted terms, the programming\nlanguage Haskell is useful. Therefore after each proof we show a notation of\nthe extracted term, which can be easily rewritten as a definition in Haskell.\n", "versions": [{"version": "v1", "created": "Fri, 27 Jul 2018 08:40:53 GMT"}], "update_date": "2018-07-30", "authors_parsed": [["Wiesnet", "Franziskus", ""]]}, {"id": "1807.10546", "submitter": "Marcin Jurdzi\\'nski", "authors": "Wojciech Czerwi\\'nski, Laure Daviaud, Nathana\\\"el Fijalkow, Marcin\n  Jurdzi\\'nski, Ranko Lazi\\'c, Pawe{\\l} Parys", "title": "Universal trees grow inside separating automata: Quasi-polynomial lower\n  bounds for parity games", "comments": "To appear in SODA 2019", "journal-ref": null, "doi": "10.1137/1.9781611975482.142", "report-no": null, "categories": "cs.FL cs.CC cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Several distinct techniques have been proposed to design quasi-polynomial\nalgorithms for solving parity games since the breakthrough result of Calude,\nJain, Khoussainov, Li, and Stephan (2017): play summaries, progress measures\nand register games. We argue that all those techniques can be viewed as\ninstances of the separation approach to solving parity games, a key technical\ncomponent of which is constructing (explicitly or implicitly) an automaton that\nseparates languages of words encoding plays that are (decisively) won by either\nof the two players. Our main technical result is a quasi-polynomial lower bound\non the size of such separating automata that nearly matches the current best\nupper bounds. This forms a barrier that all existing approaches must overcome\nin the ongoing quest for a polynomial-time algorithm for solving parity games.\nThe key and fundamental concept that we introduce and study is a universal\nordered tree. The technical highlights are a quasi-polynomial lower bound on\nthe size of universal ordered trees and a proof that every separating safety\nautomaton has a universal tree hidden in its state space.\n", "versions": [{"version": "v1", "created": "Fri, 27 Jul 2018 12:05:29 GMT"}, {"version": "v2", "created": "Fri, 2 Nov 2018 12:02:01 GMT"}], "update_date": "2020-01-15", "authors_parsed": [["Czerwi\u0144ski", "Wojciech", ""], ["Daviaud", "Laure", ""], ["Fijalkow", "Nathana\u00ebl", ""], ["Jurdzi\u0144ski", "Marcin", ""], ["Lazi\u0107", "Ranko", ""], ["Parys", "Pawe\u0142", ""]]}, {"id": "1807.10566", "submitter": "Paige Randall North", "authors": "Paige Randall North", "title": "Towards a directed homotopy type theory", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present a directed homotopy type theory for reasoning\nsynthetically about (higher) categories, directed homotopy theory, and its\napplications to concurrency. We specify a new `homomorphism' type former for\nMartin-L\\\"of type theory which is roughly analogous to the identity type former\noriginally introduced by Martin-L\\\"of. The homomorphism type former is meant to\ncapture the notions of morphism (from the theory of categories) and directed\npath (from directed homotopy theory) just as the identity type former is known\nto capture the notions of isomorphism (from the theory of groupoids) and path\n(from homotopy theory). Our main result is an interpretation of these\nhomomorphism types into Cat, the category of small categories. There, the\ninterpretation of each homomorphism type hom(a,b) is indeed the set of\nmorphisms between the objects a and b of a category C. We end the paper with an\nanalysis of the interpretation in Cat with which we argue that our homomorphism\ntypes are indeed the directed version of Martin-L\\\"of's identity types.\n", "versions": [{"version": "v1", "created": "Fri, 27 Jul 2018 13:05:36 GMT"}], "update_date": "2018-07-30", "authors_parsed": [["North", "Paige Randall", ""]]}, {"id": "1807.11061", "submitter": "Fan Xiao", "authors": "Chu-Min Li, Fan Xiao, Mao Luo, Felip Many\\`a, Zhipeng L\\\"u, Yu Li", "title": "Clause Vivification by Unit Propagation in CDCL SAT Solvers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Original and learnt clauses in Conflict-Driven Clause Learning (CDCL) SAT\nsolvers often contain redundant literals. This may have a negative impact on\nperformance because redundant literals may deteriorate both the effectiveness\nof Boolean constraint propagation and the quality of subsequent learnt clauses.\nTo overcome this drawback, we propose a clause vivification approach that\neliminates redundant literals by applying unit propagation. The proposed clause\nvivification is activated before the SAT solver triggers some selected\nrestarts, and only affects a subset of original and learnt clauses, which are\nconsidered to be more relevant according to metrics like the literal block\ndistance (LBD). Moreover, we conducted an empirical investigation with\ninstances coming from the hard combinatorial and application categories of\nrecent SAT competitions. The results show that a remarkable number of\nadditional instances are solved when the proposed approach is incorporated into\nfive of the best performing CDCL SAT solvers (Glucose, TC_Glucose, COMiniSatPS,\nMapleCOMSPS and MapleCOMSPS_LRB). More importantly, the empirical investigation\nincludes an in-depth analysis of the effectiveness of clause vivification. It\nis worth mentioning that one of the SAT solvers described here was ranked first\nin the main track of SAT Competition 2017 thanks to the incorporation of the\nproposed clause vivification. That solver was further improved in this paper\nand won the bronze medal in the main track of SAT Competition 2018.\n", "versions": [{"version": "v1", "created": "Sun, 29 Jul 2018 14:05:55 GMT"}], "update_date": "2018-07-31", "authors_parsed": [["Li", "Chu-Min", ""], ["Xiao", "Fan", ""], ["Luo", "Mao", ""], ["Many\u00e0", "Felip", ""], ["L\u00fc", "Zhipeng", ""], ["Li", "Yu", ""]]}, {"id": "1807.11103", "submitter": "Heinz Riener", "authors": "Heinz Riener and R\\\"udiger Ehlers and Bruno Schmitt and Giovanni De\n  Micheli", "title": "Exact Synthesis of ESOP Forms", "comments": "16 pages, accepted at 13th Int'l Workshop on Boolean Problems", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an exact synthesis approach for computing Exclusive-or\nSum-of-Products (ESOP) forms with a minimum number of product terms using\nBoolean satisfiability. Our approach finds one or more ESOP forms for a given\nBoolean function. The approach can deal with incompletely-specified Boolean\nfunctions defined over many Boolean variables and is particularly fast if the\nBoolean function can be expressed with only a few product terms. We describe\nthe formalization of the ESOP synthesis problem with a fixed number of terms as\na decision problem and present search procedures for determining ESOP forms of\nminimum size. We further discuss how the search procedures can be relaxed to\nfind ESOP forms of small sizes in reasonable time. We experimentally evaluate\nthe performance of the SAT-based synthesis procedures on completely- and\nincompletely-specified Boolean functions.\n", "versions": [{"version": "v1", "created": "Sun, 29 Jul 2018 19:36:26 GMT"}], "update_date": "2018-07-31", "authors_parsed": [["Riener", "Heinz", ""], ["Ehlers", "R\u00fcdiger", ""], ["Schmitt", "Bruno", ""], ["De Micheli", "Giovanni", ""]]}, {"id": "1807.11137", "submitter": "EPTCS", "authors": "Richard Whyman (The University of Leeds)", "title": "An Atemporal Model of Physical Complexity", "comments": "In Proceedings PC 2018, arXiv:1807.10563", "journal-ref": "EPTCS 273, 2018, pp. 39-51", "doi": "10.4204/EPTCS.273.4", "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present the finite first-order theory (FFOT) machine, which provides an\natemporal description of computation. We then develop a concept of complexity\nfor the FFOT machine, and prove that the class of problems decidable by a FFOT\nmachine with polynomial resources is NP intersect co-NP.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jul 2018 01:30:33 GMT"}], "update_date": "2018-07-31", "authors_parsed": [["Whyman", "Richard", "", "The University of Leeds"]]}, {"id": "1807.11139", "submitter": "Duligur Ibeling", "authors": "Duligur Ibeling", "title": "Causal Modeling with Probabilistic Simulation Models", "comments": "PLP 2018 (The 5th Workshop on Probabilistic Logic Programming)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent authors have proposed analyzing conditional reasoning through a notion\nof intervention on a simulation program, and have found a sound and complete\naxiomatization of the logic of conditionals in this setting. Here we extend\nthis setting to the case of probabilistic simulation models. We give a natural\ndefinition of probability on formulas of the conditional language, allowing for\nthe expression of counterfactuals, and prove foundational results about this\ndefinition. We also find an axiomatization for reasoning about linear\ninequalities involving probabilities in this setting. We prove soundness,\ncompleteness, and NP-completeness of the satisfiability problem for this logic.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jul 2018 01:38:58 GMT"}], "update_date": "2018-07-31", "authors_parsed": [["Ibeling", "Duligur", ""]]}, {"id": "1807.11256", "submitter": "Christoph Rauch", "authors": "Sergey Goncharov, Christoph Rauch and Lutz Schr\\\"oder", "title": "A Metalanguage for Guarded Iteration", "comments": "extended version for the special issue", "journal-ref": null, "doi": "10.1016/j.tcs.2021.04.005", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Notions of guardedness serve to delineate admissible recursive definitions in\nvarious settings in a compositional manner. In recent work, we have introduced\nan axiomatic notion of guardedness in symmetric monoidal categories, which\nserves as a unifying framework for various examples from program semantics,\nprocess algebra, and beyond. In the present paper, we propose a generic\nmetalanguage for guarded iteration based on combining this notion with the\nfine-grain call-by-value paradigm, which we intend as a unifying programming\nlanguage for guarded and unguarded iteration in the presence of computational\neffects. We give a generic (categorical) semantics of this language over a\nsuitable class of strong monads supporting guarded iteration, and show it to be\nin touch with the standard operational behaviour of iteration by giving a\nconcrete big-step operational semantics for a certain specific instance of the\nmetalanguage and establishing soundness and (computational) adequacy for this\ncase.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jul 2018 09:46:40 GMT"}, {"version": "v2", "created": "Mon, 25 Feb 2019 17:09:36 GMT"}, {"version": "v3", "created": "Mon, 24 May 2021 14:49:50 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Goncharov", "Sergey", ""], ["Rauch", "Christoph", ""], ["Schr\u00f6der", "Lutz", ""]]}, {"id": "1807.11399", "submitter": "Yuri Gurevich", "authors": "Andreas Blass and Yuri Gurevich", "title": "Who needs category theory?", "comments": null, "journal-ref": "The Bulletin of the European Association for Theoretical Computer\n  Science Vol. 124 February 2018", "doi": null, "report-no": null, "categories": "cs.LO quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In mathematical applications, category theory remains a contentious issue,\nwith enthusiastic fans and a skeptical majority. In a muted form this split\napplies to the authors of this note. When we learned that the only\nmathematically sound foundation of topological quantum computing in the\nliterature is based on category theory, the skeptical author suggested to\n\"decategorize\" the foundation. But we discovered, to our surprise, that\ncategory theory (or something like it) is necessary for the purpose, for\ncomputational reasons. The goal of this note is to give a high-level\nexplanation of that necessity, which avoids details and which suggests that the\ncase of topological quantum computing is far from unique.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jul 2018 15:41:11 GMT"}, {"version": "v2", "created": "Sat, 30 Mar 2019 14:32:48 GMT"}, {"version": "v3", "created": "Mon, 21 Oct 2019 21:20:56 GMT"}], "update_date": "2019-10-23", "authors_parsed": [["Blass", "Andreas", ""], ["Gurevich", "Yuri", ""]]}, {"id": "1807.11403", "submitter": "Yuri Gurevich", "authors": "Andreas Blass and Yuri Gurevich", "title": "Braided distributivity", "comments": "This is a companion paper for article \"Witness algebra and anyon\n  braiding,\" arXiv:1807.10414, proving results used there", "journal-ref": "Theoretical Computer Science 807 (2020) 73-94", "doi": "10.1016/j.tcs.2019.11.027", "report-no": null, "categories": "math.CT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In category-theoretic models for the anyon systems proposed for topological\nquantum computing, the essential ingredients are two monoidal structures,\n$\\oplus$ and $\\otimes$. The former is symmetric but the latter is only braided,\nand $\\otimes$ is required to distribute over $\\oplus$. What are the appropriate\ncoherence conditions for the distributivity isomorphisms? We came to this\nquestion working on a simplification of the category-theoretical foundation of\ntopological quantum computing, which is the intended application of the\nresearch reported here.\n  This question was answered by Laplaza when both monoidal structures are\nsymmetric, but topological quantum computation depends crucially on $\\otimes$\nbeing only braided, not symmetric. We propose coherence conditions for\ndistributivity in this situation, and we prove that our conditions are (a)\nstrong enough to imply Laplaza's when the latter are suitably formulated, and\n(b) weak enough to hold when --- as in the categories used to model anyons ---\nthe additive structure is that of an abelian category and the braided $\\otimes$\nis additive. Working on these results, we found a new redundancy in Laplaza's\nconditions.\n", "versions": [{"version": "v1", "created": "Mon, 30 Jul 2018 15:51:32 GMT"}, {"version": "v2", "created": "Mon, 25 Nov 2019 16:29:02 GMT"}], "update_date": "2020-03-03", "authors_parsed": [["Blass", "Andreas", ""], ["Gurevich", "Yuri", ""]]}, {"id": "1807.11570", "submitter": "EPTCS", "authors": "Pujie Han (Northwestern Polytechnical University), Zhengjun Zhai\n  (Northwestern Polytechnical University), Brian Nielsen (Aalborg University),\n  Ulrik Nyman (Aalborg University)", "title": "A Compositional Approach for Schedulability Analysis of Distributed\n  Avionics Systems", "comments": "In Proceedings MeTRiD 2018, arXiv:1806.09330. arXiv admin note: text\n  overlap with arXiv:1803.11050", "journal-ref": "EPTCS 272, 2018, pp. 39-51", "doi": "10.4204/EPTCS.272.4", "report-no": null, "categories": "cs.LO cs.FL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This work presents a compositional approach for schedulability analysis of\nDistributed Integrated Modular Avionics (DIMA) systems that consist of\nspatially distributed ARINC-653 modules connected by a unified AFDX network. We\nmodel a DIMA system as a set of stopwatch automata in UPPAAL to verify its\nschedulability by model checking. However, direct model checking is infeasible\ndue to the large state space. Therefore, we introduce the compositional\nanalysis that checks each partition including its communication environment\nindividually. Based on a notion of message interfaces, a number of message\nsender automata are built to model the environment for a partition. We define a\ntimed selection simulation relation, which supports the construction of\ncomposite message interfaces. By using assume-guarantee reasoning, we ensure\nthat each task meets the deadline and that communication constraints are also\nfulfilled globally. The approach is applied to the analysis of a concrete DIMA\nsystem.\n", "versions": [{"version": "v1", "created": "Tue, 26 Jun 2018 08:52:55 GMT"}], "update_date": "2018-08-01", "authors_parsed": [["Han", "Pujie", "", "Northwestern Polytechnical University"], ["Zhai", "Zhengjun", "", "Northwestern Polytechnical University"], ["Nielsen", "Brian", "", "Aalborg University"], ["Nyman", "Ulrik", "", "Aalborg University"]]}, {"id": "1807.11576", "submitter": "Yassmeen Elderhalli", "authors": "Yassmeen Elderhalli, Waqar Ahmad, Osman Hasan and Sofiene Tahar", "title": "Formal Probabilistic Analysis of Dynamic Fault Trees in HOL4", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dynamic Fault Trees (DFTs) is a widely used failure modeling technique that\nallows capturing the dynamic failure characteristics of systems in a very\neffective manner. Simulation and model checking have been traditionally used\nfor the probabilistic analysis of DFTs. Simulation is usually based on sampling\nand thus its results are not guaranteed to be complete, whereas model checking\nemploys computer arithmetic and numerical algorithms to compute the exact\nvalues of probabilities, which contain many round-off errors. Leveraging upon\nthe expressive and sound nature of higher-order-logic (HOL) theorem proving, we\npropose, in this work, a formalization of DFT gates and their probabilistic\nbehavior as well as some of their simplification properties in HOL. This\nformalization would allow us to conduct the probabilistic analysis of DFTs by\nverifying generic mathematical expressions about their behavior in HOL. In\nparticular, we formalize the AND, OR, Priority-AND, Functional DEPendency, Hot\nSPare, Cold SPare and the Warm SPare gates and also verify their corresponding\nprobabilistic expressions in HOL. Moreover, we formally verify an important\nproperty, Pr(X<Y), using the Lebesgue integral as this relationship allows us\nto reason about the probabilistic properties of Priority-AND gate and the\nBefore operator. We also formalize the notion of conditional densities in order\nto formally verify the probabilistic expressions of the Cold SPare and the Warm\nSPare gates. For illustrating the usefulness of our formalization, we use it to\nformally analyze the DFT of a Cardiac Assist System.\n", "versions": [{"version": "v1", "created": "Tue, 24 Jul 2018 13:31:26 GMT"}], "update_date": "2018-08-01", "authors_parsed": [["Elderhalli", "Yassmeen", ""], ["Ahmad", "Waqar", ""], ["Hasan", "Osman", ""], ["Tahar", "Sofiene", ""]]}, {"id": "1807.11610", "submitter": "Mingsheng Ying", "authors": "Mingsheng Ying", "title": "Toward Automatic Verification of Quantum Programs", "comments": null, "journal-ref": "Formal Aspect of Computing 2018", "doi": "10.1007/s00165-018-0465-3", "report-no": null, "categories": "quant-ph cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper summarises the results obtained by the author and his\ncollaborators in a program logic approach to the verification of quantum\nprograms, including quantum Hoare logic, invariant generation and termination\nanalysis for quantum programs. It also introduces the notion of proof outline\nand several auxiliary rules for more conveniently reasoning about quantum\nprograms. Some problems for future research are proposed at the end of the\npaper.\n", "versions": [{"version": "v1", "created": "Tue, 31 Jul 2018 00:00:12 GMT"}], "update_date": "2018-08-01", "authors_parsed": [["Ying", "Mingsheng", ""]]}, {"id": "1807.11800", "submitter": "Claudio Mezzina", "authors": "Doriana Medic, Claudio Antares Mezzina, Iain Phillips and Nobuko\n  Yoshida", "title": "A Parametric Framework for Reversible $\\pi$-Calculi", "comments": "Extended version of the EXPRESS2018 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper presents a study of causality in a reversible, concurrent setting.\nThere exist various notions of causality in pi-calculus, which differ in the\ntreatment of parallel extrusions of the same name. In this paper we present a\nuniform framework for reversible pi-calculi that is parametric with respect to\na data structure that stores information about an extrusion of a name.\nDifferent data structures yield different approaches to the parallel extrusion\nproblem. We map three well-known causal semantics into our framework. We show\nthat the (parametric) reversibility induced by our framework is causally-\nconsistent and prove a causal correspondence between an appropriate instance of\nthe framework and Boreale and Sangiorgi's causal semantics.\n", "versions": [{"version": "v1", "created": "Tue, 31 Jul 2018 13:10:44 GMT"}], "update_date": "2018-08-01", "authors_parsed": [["Medic", "Doriana", ""], ["Mezzina", "Claudio Antares", ""], ["Phillips", "Iain", ""], ["Yoshida", "Nobuko", ""]]}]