[{"id": "0805.0202", "submitter": "Joao Marques-Silva", "authors": "Antonio Morgado, Joao Marques-Silva", "title": "A Pseudo-Boolean Solution to the Maximum Quartet Consistency Problem", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Determining the evolutionary history of a given biological data is an\nimportant task in biological sciences. Given a set of quartet topologies over a\nset of taxa, the Maximum Quartet Consistency (MQC) problem consists of\ncomputing a global phylogeny that satisfies the maximum number of quartets. A\nnumber of solutions have been proposed for the MQC problem, including Dynamic\nProgramming, Constraint Programming, and more recently Answer Set Programming\n(ASP). ASP is currently the most efficient approach for optimally solving the\nMQC problem. This paper proposes encoding the MQC problem with pseudo-Boolean\n(PB) constraints. The use of PB allows solving the MQC problem with efficient\nPB solvers, and also allows considering different modeling approaches for the\nMQC problem. Initial results are promising, and suggest that PB can be an\neffective alternative for solving the MQC problem.\n", "versions": [{"version": "v1", "created": "Fri, 2 May 2008 10:06:27 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Morgado", "Antonio", ""], ["Marques-Silva", "Joao", ""]]}, {"id": "0805.0330", "submitter": "Ranko Lazic", "authors": "Marcin Jurdzinski and Ranko Lazic", "title": "Alternating Automata on Data Trees and XPath Satisfiability", "comments": "23 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A data tree is an unranked ordered tree whose every node is labelled by a\nletter from a finite alphabet and an element (\"datum\") from an infinite set,\nwhere the latter can only be compared for equality. The article considers\nalternating automata on data trees that can move downward and rightward, and\nhave one register for storing data. The main results are that nonemptiness over\nfinite data trees is decidable but not primitive recursive, and that\nnonemptiness of safety automata is decidable but not elementary. The proofs use\nnondeterministic tree automata with faulty counters. Allowing upward moves,\nleftward moves, or two registers, each causes undecidability. As corollaries,\ndecidability is obtained for two data-sensitive fragments of the XPath query\nlanguage.\n", "versions": [{"version": "v1", "created": "Sat, 3 May 2008 00:12:15 GMT"}, {"version": "v2", "created": "Tue, 23 Jun 2009 13:21:17 GMT"}, {"version": "v3", "created": "Mon, 1 Mar 2010 15:20:58 GMT"}, {"version": "v4", "created": "Mon, 14 Jun 2010 14:13:49 GMT"}], "update_date": "2010-06-15", "authors_parsed": [["Jurdzinski", "Marcin", ""], ["Lazic", "Ranko", ""]]}, {"id": "0805.0498", "submitter": "Martin Mundhenk", "authors": "Michael Bauland (Knipp GmbH, Germany), Martin Mundhenk (Univ. Jena,\n  Germany), Thomas Schneider (Univ. of Manchester, UK), Henning Schnoor (Univ.\n  Kiel, Germany), Ilka Schnoor (Univ. Luebeck, Germany), Heribert Vollmer\n  (Univ. Hannover, Germany)", "title": "The Tractability of Model-Checking for LTL: The Good, the Bad, and the\n  Ugly Fragments", "comments": "27 pages, 7 figures", "journal-ref": null, "doi": null, "report-no": "ECCC Report TR08-028", "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a seminal paper from 1985, Sistla and Clarke showed that the\nmodel-checking problem for Linear Temporal Logic (LTL) is either NP-complete or\nPSPACE-complete, depending on the set of temporal operators used. If, in\ncontrast, the set of propositional operators is restricted, the complexity may\ndecrease. This paper systematically studies the model-checking problem for LTL\nformulae over restricted sets of propositional and temporal operators. For\nalmost all combinations of temporal and propositional operators, we determine\nwhether the model-checking problem is tractable (in P) or intractable\n(NP-hard). We then focus on the tractable cases, showing that they all are\nNL-complete or even logspace solvable. This leads to a surprising gap in\ncomplexity between tractable and intractable cases. It is worth noting that our\nanalysis covers an infinite set of problems, since there are infinitely many\nsets of propositional operators.\n", "versions": [{"version": "v1", "created": "Mon, 5 May 2008 09:48:23 GMT"}], "update_date": "2016-09-08", "authors_parsed": [["Bauland", "Michael", "", "Knipp GmbH, Germany"], ["Mundhenk", "Martin", "", "Univ. Jena,\n  Germany"], ["Schneider", "Thomas", "", "Univ. of Manchester, UK"], ["Schnoor", "Henning", "", "Univ.\n  Kiel, Germany"], ["Schnoor", "Ilka", "", "Univ. Luebeck, Germany"], ["Vollmer", "Heribert", "", "Univ. Hannover, Germany"]]}, {"id": "0805.0585", "submitter": "Jean Gallier", "authors": "Jean Gallier", "title": "Discrete Mathematics for Computer Science, Some Notes", "comments": "255 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  These are notes on discrete mathematics for computer scientists. The\npresentation is somewhat unconventional. Indeed I begin with a discussion of\nthe basic rules of mathematical reasoning and of the notion of proof formalized\nin a natural deduction system ``a la Prawitz''. The rest of the material is\nmore or less traditional but I emphasize partial functions more than usual\n(after all, programs may not terminate for all input) and I provide a fairly\ncomplete account of the basic concepts of graph theory.\n", "versions": [{"version": "v1", "created": "Mon, 5 May 2008 18:52:00 GMT"}], "update_date": "2008-05-06", "authors_parsed": [["Gallier", "Jean", ""]]}, {"id": "0805.0783", "submitter": "Lars Birkedal", "authors": "Lars Birkedal and Hongseok Yang", "title": "Relational Parametricity and Separation Logic", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 2 (May 15,\n  2008) lmcs:825", "doi": "10.2168/LMCS-4(2:6)2008", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Separation logic is a recent extension of Hoare logic for reasoning about\nprograms with references to shared mutable data structures. In this paper, we\nprovide a new interpretation of the logic for a programming language with\nhigher types. Our interpretation is based on Reynolds's relational\nparametricity, and it provides a formal connection between separation logic and\ndata abstraction.\n", "versions": [{"version": "v1", "created": "Tue, 6 May 2008 19:27:14 GMT"}, {"version": "v2", "created": "Thu, 15 May 2008 12:44:50 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Birkedal", "Lars", ""], ["Yang", "Hongseok", ""]]}, {"id": "0805.0845", "submitter": "Samuel Mimram", "authors": "Samuel Mimram (PPS)", "title": "Presentation of a Game Semantics for First-Order Propositional Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Game semantics aim at describing the interactive behaviour of proofs by\ninterpreting formulas as games on which proofs induce strategies. In this\narticle, we introduce a game semantics for a fragment of first order\npropositional logic. One of the main difficulties that has to be faced when\nconstructing such semantics is to make them precise by characterizing definable\nstrategies - that is strategies which actually behave like a proof. This\ncharacterization is usually done by restricting to the model to strategies\nsatisfying subtle combinatory conditions such as innocence, whose preservation\nunder composition is often difficult to show. Here, we present an original\nmethodology to achieve this task which requires to combine tools from game\nsemantics, rewriting theory and categorical algebra. We introduce a\ndiagrammatic presentation of definable strategies by the means of generators\nand relations: those strategies can be generated from a finite set of\n``atomic'' strategies and that the equality between strategies generated in\nsuch a way admits a finite axiomatization. These generators satisfy laws which\nare a variation of bialgebras laws, thus bridging algebra and denotational\nsemantics in a clean and unexpected way.\n", "versions": [{"version": "v1", "created": "Wed, 7 May 2008 06:53:47 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Mimram", "Samuel", "", "PPS"]]}, {"id": "0805.1386", "submitter": "Jeremy Avigad", "authors": "Steven Kieffer, Jeremy Avigad, and Harvey Friedman", "title": "A language for mathematical knowledge management", "comments": null, "journal-ref": "Studies in Logic, Grammar and Rhetoric, 18:51-66, 2009", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We argue that the language of Zermelo Fraenkel set theory with definitions\nand partial functions provides the most promising bedrock semantics for\ncommunicating and sharing mathematical knowledge. We then describe a syntactic\nsugaring of that language that provides a way of writing remarkably readable\nassertions without straying far from the set-theoretic semantics. We illustrate\nwith some examples of formalized textbook definitions from elementary set\ntheory and point-set topology. We also present statistics concerning the\ncomplexity of these definitions, under various complexity measures.\n", "versions": [{"version": "v1", "created": "Fri, 9 May 2008 17:16:50 GMT"}, {"version": "v2", "created": "Tue, 26 Aug 2008 21:29:54 GMT"}, {"version": "v3", "created": "Mon, 3 Jan 2011 18:55:35 GMT"}], "update_date": "2011-01-04", "authors_parsed": [["Kieffer", "Steven", ""], ["Avigad", "Jeremy", ""], ["Friedman", "Harvey", ""]]}, {"id": "0805.1391", "submitter": "Krishnendu Chatterjee", "authors": "Krishnendu Chatterjee", "title": "Linear Time Algorithm for Weak Parity Games", "comments": "7 pages, EECS UC Berkeley Technical Report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider games played on graphs with the winning conditions for the\nplayers specified as weak-parity conditions. In weak-parity conditions the\nwinner of a play is decided by looking into the set of states appearing in the\nplay, rather than the set of states appearing infinitely often in the play. A\nnaive analysis of the classical algorithm for weak-parity games yields a\nquadratic time algorithm. We present a linear time algorithm for solving\nweak-parity games.\n", "versions": [{"version": "v1", "created": "Fri, 9 May 2008 19:12:30 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Chatterjee", "Krishnendu", ""]]}, {"id": "0805.1457", "submitter": "Nicolas Markey", "authors": "Patricia Bouyer, Kim G. Larsen, and Nicolas Markey", "title": "Model Checking One-clock Priced Timed Automata", "comments": "28 pages", "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 2 (June 20,\n  2008) lmcs:828", "doi": "10.2168/LMCS-4(2:9)2008", "report-no": null, "categories": "cs.LO cs.CC cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the model of priced (a.k.a. weighted) timed automata, an\nextension of timed automata with cost information on both locations and\ntransitions, and we study various model-checking problems for that model based\non extensions of classical temporal logics with cost constraints on modalities.\nWe prove that, under the assumption that the model has only one clock,\nmodel-checking this class of models against the logic WCTL, CTL with\ncost-constrained modalities, is PSPACE-complete (while it has been shown\nundecidable as soon as the model has three clocks). We also prove that\nmodel-checking WMTL, LTL with cost-constrained modalities, is decidable only if\nthere is a single clock in the model and a single stopwatch cost variable\n(i.e., whose slopes lie in {0,1}).\n", "versions": [{"version": "v1", "created": "Sat, 10 May 2008 08:56:07 GMT"}, {"version": "v2", "created": "Fri, 20 Jun 2008 10:43:10 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Bouyer", "Patricia", ""], ["Larsen", "Kim G.", ""], ["Markey", "Nicolas", ""]]}, {"id": "0805.1464", "submitter": "Guillaume Burel", "authors": "Guillaume Burel (Max Planck Institute for Informatics)", "title": "Efficiently Simulating Higher-Order Arithmetic by a First-Order Theory\n  Modulo", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 1 (March 17,\n  2011) lmcs:861", "doi": "10.2168/LMCS-7(1:3)2011", "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In deduction modulo, a theory is not represented by a set of axioms but by a\ncongruence on propositions modulo which the inference rules of standard\ndeductive systems---such as for instance natural deduction---are applied.\nTherefore, the reasoning that is intrinsic of the theory does not appear in the\nlength of proofs. In general, the congruence is defined through a rewrite\nsystem over terms and propositions. We define a rigorous framework to study\nproof lengths in deduction modulo, where the congruence must be computed in\npolynomial time. We show that even very simple rewrite systems lead to\narbitrary proof-length speed-ups in deduction modulo, compared to using axioms.\nAs higher-order logic can be encoded as a first-order theory in deduction\nmodulo, we also study how to reinterpret, thanks to deduction modulo, the\nspeed-ups between higher-order and first-order arithmetics that were stated by\nG\\\"odel. We define a first-order rewrite system with a congruence decidable in\npolynomial time such that proofs of higher-order arithmetic can be linearly\ntranslated into first-order arithmetic modulo that system. We also present the\nwhole higher-order arithmetic as a first-order system without resorting to any\naxiom, where proofs have the same length as in the axiomatic presentation.\n", "versions": [{"version": "v1", "created": "Sat, 10 May 2008 10:42:54 GMT"}, {"version": "v2", "created": "Thu, 15 Apr 2010 10:12:20 GMT"}, {"version": "v3", "created": "Wed, 13 Oct 2010 13:08:40 GMT"}, {"version": "v4", "created": "Thu, 13 Jan 2011 08:25:47 GMT"}, {"version": "v5", "created": "Wed, 16 Mar 2011 20:55:57 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Burel", "Guillaume", "", "Max Planck Institute for Informatics"]]}, {"id": "0805.1473", "submitter": "Manuel Bodirsky", "authors": "Manuel Bodirsky and Jan Kara", "title": "A Fast Algorithm and Datalog Inexpressibility for Temporal Reasoning", "comments": "19 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new tractable temporal constraint language, which strictly\ncontains the Ord-Horn language of Buerkert and Nebel and the class of AND/OR\nprecedence constraints. The algorithm we present for this language decides\nwhether a given set of constraints is consistent in time that is quadratic in\nthe input size. We also prove that (unlike Ord-Horn) this language cannot be\nsolved by Datalog or by establishing local consistency.\n", "versions": [{"version": "v1", "created": "Sat, 10 May 2008 13:49:45 GMT"}, {"version": "v2", "created": "Sat, 11 Apr 2009 13:42:13 GMT"}], "update_date": "2009-04-11", "authors_parsed": [["Bodirsky", "Manuel", ""], ["Kara", "Jan", ""]]}, {"id": "0805.1798", "submitter": "Pierre Lescanne", "authors": "Pierre Lescanne (LIP)", "title": "(Mechanical) Reasoning on Infinite Extensive Games", "comments": "11 p", "journal-ref": null, "doi": null, "report-no": "LIP (UMR5668) RR2008-16", "categories": "cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In order to better understand reasoning involved in analyzing infinite games\nin extensive form, we performed experiments in the proof assistant Coq that are\nreported here.\n", "versions": [{"version": "v1", "created": "Tue, 13 May 2008 08:09:51 GMT"}, {"version": "v2", "created": "Tue, 20 May 2008 06:44:06 GMT"}, {"version": "v3", "created": "Thu, 22 May 2008 06:37:33 GMT"}, {"version": "v4", "created": "Wed, 28 May 2008 14:55:37 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Lescanne", "Pierre", "", "LIP"]]}, {"id": "0805.1806", "submitter": "Mark van der Zwaag", "authors": "J.A. Bergstra, S. Nolst Trenite, M.B. van der Zwaag", "title": "Tuplix Calculus Specifications of Financial Transfer Networks", "comments": null, "journal-ref": null, "doi": null, "report-no": "PRG0807", "categories": "cs.CE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the application of Tuplix Calculus in modular financial budget\ndesign. We formalize organizational structure using financial transfer\nnetworks. We consider the notion of flux of money over a network, and a way to\nenforce the matching of influx and outflux for parts of a network. We exploit\nso-called signed attribute notation to make internal streams visible through\nencapsulations. Finally, we propose a Tuplix Calculus construct for the\ndefinition of data functions.\n", "versions": [{"version": "v1", "created": "Tue, 13 May 2008 09:05:41 GMT"}], "update_date": "2008-05-14", "authors_parsed": [["Bergstra", "J. A.", ""], ["Trenite", "S. Nolst", ""], ["van der Zwaag", "M. B.", ""]]}, {"id": "0805.1974", "submitter": "Aiswarya Cyriac", "authors": "Aiswarya Cyriac, K. Murali Krishnan", "title": "Lower Bound for the Communication Complexity of the Russian Cards\n  Problem", "comments": "5 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper it is shown that no public announcement scheme that can be\nmodeled in Dynamic Epistemic Logic (DEL) can solve the Russian Cards Problem\n(RCP) in one announcement. Since DEL is a general model for any public\nannouncement scheme we conclude that there exist no single announcement\nsolution to the RCP. The proof demonstrates the utility of DEL in proving lower\nbounds for communication protocols. It is also shown that a general version of\nRCP has no two announcement solution when the adversary has sufficiently large\nnumber of cards.\n", "versions": [{"version": "v1", "created": "Wed, 14 May 2008 06:31:48 GMT"}, {"version": "v2", "created": "Wed, 24 Dec 2008 05:15:01 GMT"}], "update_date": "2008-12-24", "authors_parsed": [["Cyriac", "Aiswarya", ""], ["Krishnan", "K. Murali", ""]]}, {"id": "0805.2015", "submitter": "Christos Dimitrakakis", "authors": "Christos Dimitrakakis and Michail G. Lagoudakis", "title": "Algorithms and Bounds for Rollout Sampling Approximate Policy Iteration", "comments": "14 pages, presented at EWRL'08", "journal-ref": null, "doi": null, "report-no": "IAS-UVA-08-03", "categories": "stat.ML cs.LO math.ST stat.TH", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Several approximate policy iteration schemes without value functions, which\nfocus on policy representation using classifiers and address policy learning as\na supervised learning problem, have been proposed recently. Finding good\npolicies with such methods requires not only an appropriate classifier, but\nalso reliable examples of best actions, covering the state space sufficiently.\nUp to this time, little work has been done on appropriate covering schemes and\non methods for reducing the sample complexity of such methods, especially in\ncontinuous state spaces. This paper focuses on the simplest possible covering\nscheme (a discretized grid over the state space) and performs a\nsample-complexity comparison between the simplest (and previously commonly\nused) rollout sampling allocation strategy, which allocates samples equally at\neach state under consideration, and an almost as simple method, which allocates\nsamples only as needed and requires significantly fewer samples.\n", "versions": [{"version": "v1", "created": "Wed, 14 May 2008 11:20:29 GMT"}, {"version": "v2", "created": "Fri, 18 Jul 2008 14:26:35 GMT"}], "update_date": "2009-12-30", "authors_parsed": [["Dimitrakakis", "Christos", ""], ["Lagoudakis", "Michail G.", ""]]}, {"id": "0805.2063", "submitter": "Genta Ito", "authors": "Genta Ito", "title": "Replication via Invalidating the Applicability of the Fixed Point\n  Theorem", "comments": "26 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a construction of a certain infinite complete partial order (CPO)\nthat differs from the standard construction used in Scott's denotational\nsemantics. In addition, we construct several other infinite CPO's. For some of\nthose, we apply the usual Fixed Point Theorem (FPT) to yield a fixed point for\nevery continuous function $\\mu:2\\to 2$ (where 2 denotes the set $\\{0,1\\}$),\nwhile for the other CPO's we cannot invoke that theorem to yield such fixed\npoints. Every element of each of these CPO's is a binary string in the\nmonotypic form and we show that invalidation of the applicability of the FPT to\nthe CPO that Scott's constructed yields the concept of replication.\n", "versions": [{"version": "v1", "created": "Wed, 14 May 2008 13:45:16 GMT"}, {"version": "v2", "created": "Wed, 28 May 2008 16:41:37 GMT"}], "update_date": "2008-05-28", "authors_parsed": [["Ito", "Genta", ""]]}, {"id": "0805.2179", "submitter": "Gilles Champenois", "authors": "Gilles Champenois", "title": "Mnesors for databases", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We add commutativity to axioms defining mnesors and substitute a bitrop for\nthe lattice. We show that it can be applied to relational database querying:\nset union, intersection and selection are redifined only from the mnesor\naddition and the granular multiplication. Union-compatibility is not required.\n", "versions": [{"version": "v1", "created": "Wed, 14 May 2008 22:01:31 GMT"}, {"version": "v2", "created": "Wed, 21 May 2008 13:52:24 GMT"}, {"version": "v3", "created": "Sun, 24 May 2009 17:22:02 GMT"}, {"version": "v4", "created": "Tue, 15 Dec 2009 16:45:10 GMT"}], "update_date": "2009-12-15", "authors_parsed": [["Champenois", "Gilles", ""]]}, {"id": "0805.2438", "submitter": "Russell O'Connor", "authors": "Russell O'Connor", "title": "Certified Exact Transcendental Real Number Computation in Coq", "comments": "This paper is to be part of the proceedings of the 21st International\n  Conference on Theorem Proving in Higher Order Logics (TPHOLs 2008)", "journal-ref": "Ait Mohamed, C. Munoz, and S. Tahar (Eds.): TPHOLs 2008, LNCS\n  5170, pp. 246-261, 2008", "doi": "10.1007/978-3-540-71067-7_21", "report-no": null, "categories": "cs.LO cs.MS cs.NA", "license": "http://creativecommons.org/licenses/publicdomain/", "abstract": "  Reasoning about real number expressions in a proof assistant is challenging.\nSeveral problems in theorem proving can be solved by using exact real number\ncomputation. I have implemented a library for reasoning and computing with\ncomplete metric spaces in the Coq proof assistant and used this library to\nbuild a constructive real number implementation including elementary real\nnumber functions and proofs of correctness. Using this library, I have created\na tactic that automatically proves strict inequalities over closed elementary\nreal number expressions by computation.\n", "versions": [{"version": "v1", "created": "Fri, 16 May 2008 18:02:24 GMT"}], "update_date": "2010-08-04", "authors_parsed": [["O'Connor", "Russell", ""]]}, {"id": "0805.2620", "submitter": "Krishnendu Chatterjee", "authors": "Krishnendu Chatterjee, Thomas A. Henzinger and Nir Piterman", "title": "Algorithms for B\\\"uchi Games", "comments": "11 Pages, Published in GDV 06 (Games in Design and Verification)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The classical algorithm for solving B\\\"uchi games requires time $O(n\\cdot m)$\nfor game graphs with $n$ states and $m$ edges. For game graphs with constant\noutdegree, the best known algorithm has running time $O(n^2/\\log n)$. We\npresent two new algorithms for B\\\"uchi games. First, we give an algorithm that\nperforms at most $O(m)$ more work than the classical algorithm, but runs in\ntime O(n) on infinitely many graphs of constant outdegree on which the\nclassical algorithm requires time $O(n^2)$. Second, we give an algorithm with\nrunning time $O(n\\cdot m\\cdot\\log\\delta(n)/\\log n)$, where $1\\le\\delta(n)\\le n$\nis the outdegree of the game graph. Note that this algorithm performs\nasymptotically better than the classical algorithm if $\\delta(n)=O(\\log n)$.\n", "versions": [{"version": "v1", "created": "Fri, 16 May 2008 20:38:54 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Henzinger", "Thomas A.", ""], ["Piterman", "Nir", ""]]}, {"id": "0805.2785", "submitter": "Alwen Tiu", "authors": "Alwen Tiu and Dale Miller", "title": "Proof Search Specifications of Bisimulation and Modal Logics for the\n  pi-Calculus", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We specify the operational semantics and bisimulation relations for the\nfinite pi-calculus within a logic that contains the nabla quantifier for\nencoding generic judgments and definitions for encoding fixed points. Since we\nrestrict to the finite case, the ability of the logic to unfold fixed points\nallows this logic to be complete for both the inductive nature of operational\nsemantics and the coinductive nature of bisimulation. The nabla quantifier\nhelps with the delicate issues surrounding the scope of variables within\npi-calculus expressions and their executions (proofs). We illustrate several\nmerits of the logical specifications permitted by this logic: they are natural\nand declarative; they contain no side-conditions concerning names of variables\nwhile maintaining a completely formal treatment of such variables; differences\nbetween late and open bisimulation relations arise from familar logic\ndistinctions; the interplay between the three quantifiers (for all, exists, and\nnabla) and their scopes can explain the differences between early and late\nbisimulation and between various modal operators based on bound input and\noutput actions; and proof search involving the application of inference rules,\nunification, and backtracking can provide complete proof systems for one-step\ntransitions, bisimulation, and satisfaction in modal logic. We also illustrate\nhow one can encode the pi-calculus with replications, in an extended logic with\ninduction and co-induction.\n", "versions": [{"version": "v1", "created": "Mon, 19 May 2008 04:33:28 GMT"}, {"version": "v2", "created": "Thu, 4 Dec 2008 06:03:46 GMT"}, {"version": "v3", "created": "Mon, 16 Feb 2009 03:50:01 GMT"}], "update_date": "2009-02-16", "authors_parsed": [["Tiu", "Alwen", ""], ["Miller", "Dale", ""]]}, {"id": "0805.3256", "submitter": "Paulo Matos", "authors": "Paulo J. Matos, Joao Marques-Silva", "title": "Model Checking Event-B by Encoding into Alloy", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As systems become ever more complex, verification becomes more main stream.\nEvent-B and Alloy are two formal specification languages based on fairly\ndifferent methodologies. While Event-B uses theorem provers to prove that\ninvariants hold for a given specification, Alloy uses a SAT-based model finder.\nIn some settings, Event-B invariants may not be proved automatically, and so\nthe often difficult step of interactive proof is required. One solution for\nthis problem is to validate invariants with model checking. This work studies\nthe encoding of Event-B machines and contexts to Alloy in order to perform\ntemporal model checking with Alloy's SAT-based engine.\n", "versions": [{"version": "v1", "created": "Wed, 21 May 2008 11:35:25 GMT"}, {"version": "v2", "created": "Fri, 30 May 2008 09:28:43 GMT"}], "update_date": "2008-05-30", "authors_parsed": [["Matos", "Paulo J.", ""], ["Marques-Silva", "Joao", ""]]}, {"id": "0805.3261", "submitter": "Simone Bova", "authors": "Simone Bova", "title": "k-Hyperarc Consistency for Soft Constraints over Divisible Residuated\n  Lattices", "comments": "15 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the applicability of divisible residuated lattices (DRLs) as a\ngeneral evaluation framework for soft constraint satisfaction problems (soft\nCSPs). DRLs are in fact natural candidates for this role, since they form the\nalgebraic semantics of a large family of substructural and fuzzy logics.\n  We present the following results. (i) We show that DRLs subsume important\nvaluation structures for soft constraints, such as commutative idempotent\nsemirings and fair valuation structures, in the sense that the last two are\nmembers of certain subvarieties of DRLs (namely, Heyting algebras and\nBL-algebras respectively). (ii) In the spirit of previous work of J. Larrosa\nand T. Schiex [2004], and S. Bistarelli and F. Gadducci [2006] we describe a\npolynomial-time algorithm that enforces k-hyperarc consistency on soft CSPs\nevaluated over DRLs. Observed that, in general, DRLs are neither idempotent nor\ntotally ordered, this algorithm amounts to a generalization of the available\nalgorithms that enforce k-hyperarc consistency.\n", "versions": [{"version": "v1", "created": "Wed, 21 May 2008 11:54:51 GMT"}, {"version": "v2", "created": "Thu, 22 May 2008 07:35:02 GMT"}], "update_date": "2008-05-22", "authors_parsed": [["Bova", "Simone", ""]]}, {"id": "0805.3462", "submitter": "Aniello Murano", "authors": "Alessandro Ferrante, Aniello Murano and Mimmo Parente", "title": "Enriched MU-Calculi Module Checking", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 3 (July 29,\n  2008) lmcs:829", "doi": "10.2168/LMCS-4(3:1)2008", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The model checking problem for open systems has been intensively studied in\nthe literature, for both finite-state (module checking) and infinite-state\n(pushdown module checking) systems, with respect to Ctl and Ctl*. In this\npaper, we further investigate this problem with respect to the \\mu-calculus\nenriched with nominals and graded modalities (hybrid graded Mu-calculus), in\nboth the finite-state and infinite-state settings. Using an automata-theoretic\napproach, we show that hybrid graded \\mu-calculus module checking is solvable\nin exponential time, while hybrid graded \\mu-calculus pushdown module checking\nis solvable in double-exponential time. These results are also tight since they\nmatch the known lower bounds for Ctl. We also investigate the module checking\nproblem with respect to the hybrid graded \\mu-calculus enriched with inverse\nprograms (Fully enriched \\mu-calculus): by showing a reduction from the domino\nproblem, we show its undecidability. We conclude with a short overview of the\nmodel checking problem for the Fully enriched Mu-calculus and the fragments\nobtained by dropping at least one of the additional constructs.\n", "versions": [{"version": "v1", "created": "Thu, 22 May 2008 13:29:44 GMT"}, {"version": "v2", "created": "Tue, 29 Jul 2008 21:53:41 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Ferrante", "Alessandro", ""], ["Murano", "Aniello", ""], ["Parente", "Mimmo", ""]]}, {"id": "0805.3521", "submitter": "Giorgi Japaridze", "authors": "Giorgi Japaridze", "title": "Towards applied theories based on computability logic", "comments": "To appear in 2010 in the Journal of Symbolic Logic", "journal-ref": "Journal of Symbolic Logic 75 (2010), pp. 565-601", "doi": "10.2178/jsl/1268917495", "report-no": null, "categories": "cs.LO cs.AI math.LO math.NT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computability logic (CL) (see http://www.cis.upenn.edu/~giorgi/cl.html) is a\nrecently launched program for redeveloping logic as a formal theory of\ncomputability, as opposed to the formal theory of truth that logic has more\ntraditionally been. Formulas in it represent computational problems, \"truth\"\nmeans existence of an algorithmic solution, and proofs encode such solutions.\nWithin the line of research devoted to finding axiomatizations for ever more\nexpressive fragments of CL, the present paper introduces a new deductive system\nCL12 and proves its soundness and completeness with respect to the semantics of\nCL. Conservatively extending classical predicate calculus and offering\nconsiderable additional expressive and deductive power, CL12 presents a\nreasonable, computationally meaningful, constructive alternative to classical\nlogic as a basis for applied theories. To obtain a model example of such\ntheories, this paper rebuilds the traditional, classical-logic-based Peano\narithmetic into a computability-logic-based counterpart. Among the purposes of\nthe present contribution is to provide a starting point for what, as the author\nwishes to hope, might become a new line of research with a potential of\ninteresting findings -- an exploration of the presumably quite unusual\nmetatheory of CL-based arithmetic and other CL-based applied systems.\n", "versions": [{"version": "v1", "created": "Thu, 22 May 2008 18:18:02 GMT"}, {"version": "v2", "created": "Thu, 25 Jun 2009 15:10:26 GMT"}, {"version": "v3", "created": "Tue, 7 Jul 2009 18:09:22 GMT"}, {"version": "v4", "created": "Tue, 17 Nov 2009 04:49:51 GMT"}], "update_date": "2011-04-15", "authors_parsed": [["Japaridze", "Giorgi", ""]]}, {"id": "0805.4072", "submitter": "Michael Thomas", "authors": "Pierre McKenzie, Michael Thomas and Heribert Vollmer", "title": "Extensional Uniformity for Boolean Circuits", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Imposing an extensional uniformity condition on a non-uniform circuit\ncomplexity class C means simply intersecting C with a uniform class L. By\ncontrast, the usual intensional uniformity conditions require that a\nresource-bounded machine be able to exhibit the circuits in the circuit family\ndefining C. We say that (C,L) has the \"Uniformity Duality Property\" if the\nextensionally uniform class C \\cap L can be captured intensionally by means of\nadding so-called \"L-numerical predicates\" to the first-order descriptive\ncomplexity apparatus describing the connection language of the circuit family\ndefining C.\n  This paper exhibits positive instances and negative instances of the\nUniformity Duality Property.\n", "versions": [{"version": "v1", "created": "Tue, 27 May 2008 08:49:36 GMT"}, {"version": "v2", "created": "Wed, 28 May 2008 07:31:01 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["McKenzie", "Pierre", ""], ["Thomas", "Michael", ""], ["Vollmer", "Heribert", ""]]}, {"id": "0805.4167", "submitter": "Krishnendu Chatterjee", "authors": "Krishnendu Chatterjee, Thomas A. Henzinger and Barbara Jobstmann", "title": "Environment Assumptions for Synthesis", "comments": "15 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The synthesis problem asks to construct a reactive finite-state system from\nan $\\omega$-regular specification. Initial specifications are often\nunrealizable, which means that there is no system that implements the\nspecification. A common reason for unrealizability is that assumptions on the\nenvironment of the system are incomplete. We study the problem of correcting an\nunrealizable specification $\\phi$ by computing an environment assumption $\\psi$\nsuch that the new specification $\\psi\\to\\phi$ is realizable. Our aim is to\nconstruct an assumption $\\psi$ that constrains only the environment and is as\nweak as possible. We present a two-step algorithm for computing assumptions.\nThe algorithm operates on the game graph that is used to answer the\nrealizability question. First, we compute a safety assumption that removes a\nminimal set of environment edges from the graph. Second, we compute a liveness\nassumption that puts fairness conditions on some of the remaining environment\nedges. We show that the problem of finding a minimal set of fair edges is\ncomputationally hard, and we use probabilistic games to compute a locally\nminimal fairness assumption.\n", "versions": [{"version": "v1", "created": "Tue, 27 May 2008 16:17:34 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Henzinger", "Thomas A.", ""], ["Jobstmann", "Barbara", ""]]}, {"id": "0805.4745", "submitter": "Juan de Lara", "authors": "Juan de Lara and Esther Guerra", "title": "Pattern-based Model-to-Model Transformation: Long Version", "comments": "extended version of the paper from the ICGT'2008 conference\n  (Leicester)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new, high-level approach for the specification of model-to-model\ntransformations based on declarative patterns. These are (atomic or composite)\nconstraints on triple graphs declaring the allowed or forbidden relationships\nbetween source and target models. In this way, a transformation is defined by\nspecifying a set of triple graph constraints that should be satisfied by the\nresult of the transformation.\n  The description of the transformation is then compiled into lower-level\noperational mechanisms to perform forward or backward transformations, as well\nas to establish mappings between two existent models. In this paper we study\none of such mechanisms based on the generation of operational triple graph\ngrammar rules. Moreover, we exploit deduction techniques at the specification\nlevel to generate more specialized constraints (preserving the specification\nsemantics) reflecting pattern dependencies, from which additional rules can be\nderived.\n  This is an extended version of the paper submitted to ICGT'08, with\nadditional definitions and proofs.\n", "versions": [{"version": "v1", "created": "Fri, 30 May 2008 12:48:16 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["de Lara", "Juan", ""], ["Guerra", "Esther", ""]]}]