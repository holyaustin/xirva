[{"id": "0812.0659", "submitter": "Chitta Baral", "authors": "Chitta Baral, Michael Gelfond and Nelson Rushton", "title": "Probabilistic reasoning with answer sets", "comments": "77 pages. To appear in Theory and Practice of Logic Programming\n  (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper develops a declarative language, P-log, that combines logical and\nprobabilistic arguments in its reasoning. Answer Set Prolog is used as the\nlogical foundation, while causal Bayes nets serve as a probabilistic\nfoundation. We give several non-trivial examples and illustrate the use of\nP-log for knowledge representation and updating of knowledge. We argue that our\napproach to updates is more appealing than existing approaches. We give\nsufficiency conditions for the coherency of P-log programs and show that Bayes\nnets can be easily mapped to coherent P-log programs.\n", "versions": [{"version": "v1", "created": "Wed, 3 Dec 2008 06:36:16 GMT"}], "update_date": "2008-12-04", "authors_parsed": [["Baral", "Chitta", ""], ["Gelfond", "Michael", ""], ["Rushton", "Nelson", ""]]}, {"id": "0812.1291", "submitter": "Anthony Widjaja To", "authors": "Anthony Widjaja To", "title": "Unary finite automata vs. arithmetic progressions", "comments": "Journal paper submitted", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We point out a subtle error in the proof of Chrobak's theorem that every\nunary NFA can be represented as a union of arithmetic progressions that is at\nmost quadratically large. We propose a correction for this and show how\nMartinez's polynomial time algorithm, which realizes Chrobak's theorem, can be\nmade correct accordingly. We also show that Martinez's algorithm cannot be\nimproved to have logarithmic space, unless L = NL.\n", "versions": [{"version": "v1", "created": "Sat, 6 Dec 2008 14:18:05 GMT"}], "update_date": "2008-12-09", "authors_parsed": [["To", "Anthony Widjaja", ""]]}, {"id": "0812.1364", "submitter": "Johann Makowsky", "authors": "Benny Godlin, Emilia Katz, Johann A. Makowsky", "title": "Graph Polynomials: From Recursive Definitions To Subset Expansion\n  Formulas", "comments": "25 pages, 2 figures", "journal-ref": "Journal of Logic and Computation, Volume 22(2), (2012) Pages\n  237-265", "doi": null, "report-no": null, "categories": "cs.LO cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many graph polynomials, such as the Tutte polynomial, the interlace\npolynomial and the matching polynomial, have both a recursive definition and a\ndefining subset expansion formula. In this paper we present a general,\nlogic-based framework which gives a precise meaning to recursive definitions of\ngraph polynomials. We then prove that in this framework every recursive\ndefinition of a graph polynomial can be converted into a subset expansion\nformula.\n", "versions": [{"version": "v1", "created": "Sun, 7 Dec 2008 16:50:53 GMT"}], "update_date": "2013-09-10", "authors_parsed": [["Godlin", "Benny", ""], ["Katz", "Emilia", ""], ["Makowsky", "Johann A.", ""]]}, {"id": "0812.1729", "submitter": "Filip Murlak", "authors": "Filip Murlak", "title": "The Wadge Hierarchy of Deterministic Tree Languages", "comments": "44 pages, 8 figures; extended abstract presented at ICALP 2006,\n  Venice, Italy; full version appears in LMCS special issue", "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (December\n  23, 2008) lmcs:994", "doi": "10.2168/LMCS-4(4:15)2008", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide a complete description of the Wadge hierarchy for\ndeterministically recognisable sets of infinite trees. In particular we give an\nelementary procedure to decide if one deterministic tree language is\ncontinuously reducible to another. This extends Wagner's results on the\nhierarchy of omega-regular languages of words to the case of trees.\n", "versions": [{"version": "v1", "created": "Tue, 9 Dec 2008 16:14:05 GMT"}, {"version": "v2", "created": "Tue, 23 Dec 2008 22:12:11 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Murlak", "Filip", ""]]}, {"id": "0812.1915", "submitter": "Marcel Marquardt", "authors": "Wouter Gelade, Marcel Marquardt, Thomas Schwentick", "title": "Dynamic Complexity of Formal Languages", "comments": "Contains the material presenten at STACS 2009, extendes with proofs\n  and examples which were omitted due lack of space", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper investigates the power of the dynamic complexity classes DynFO,\nDynQF and DynPROP over string languages. The latter two classes contain\nproblems that can be maintained using quantifier-free first-order updates, with\nand without auxiliary functions, respectively. It is shown that the languages\nmaintainable in DynPROP exactly are the regular languages, even when allowing\narbitrary precomputation. This enables lower bounds for DynPROP and separates\nDynPROP from DynQF and DynFO. Further, it is shown that any context-free\nlanguage can be maintained in DynFO and a number of specific context-free\nlanguages, for example all Dyck-languages, are maintainable in DynQF.\nFurthermore, the dynamic complexity of regular tree languages is investigated\nand some results concerning arbitrary structures are obtained: there exist\nfirst-order definable properties which are not maintainable in DynPROP. On the\nother hand any existential first-order property can be maintained in DynQF when\nallowing precomputation.\n", "versions": [{"version": "v1", "created": "Wed, 10 Dec 2008 14:13:57 GMT"}], "update_date": "2008-12-11", "authors_parsed": [["Gelade", "Wouter", ""], ["Marquardt", "Marcel", ""], ["Schwentick", "Thomas", ""]]}, {"id": "0812.1951", "submitter": "Jerome Leroux", "authors": "Alain Finkel (LSV), J\\'er\\^ome Leroux (LaBRI)", "title": "The convex hull of a regular set of integer vectors is polyhedral and\n  effectively computable", "comments": null, "journal-ref": "Information Processing Letters 96, 1 (2005) 30 - 35", "doi": "10.1016/j.ipl.2005.04.004", "report-no": null, "categories": "cs.CG cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Number Decision Diagrams (NDD) provide a natural finite symbolic\nrepresentation for regular set of integer vectors encoded as strings of digit\nvectors (least or most significant digit first). The convex hull of the set of\nvectors represented by a NDD is proved to be an effectively computable convex\npolyhedron.\n", "versions": [{"version": "v1", "created": "Wed, 10 Dec 2008 16:26:36 GMT"}], "update_date": "2008-12-13", "authors_parsed": [["Finkel", "Alain", "", "LSV"], ["Leroux", "J\u00e9r\u00f4me", "", "LaBRI"]]}, {"id": "0812.1967", "submitter": "Jerome Leroux", "authors": "Florent Bouchy (LSV), Alain Finkel (LSV), J\\'er\\^ome Leroux (LaBRI)", "title": "Decomposition of Decidable First-Order Logics over Integers and Reals", "comments": null, "journal-ref": "Temporal Representation and Reasoning, 2008. TIME '08. 15th\n  International Symposium on, Montreal, QC : Canada (2008)", "doi": "10.1109/TIME.2008.22", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We tackle the issue of representing infinite sets of real- valued vectors.\nThis paper introduces an operator for combining integer and real sets. Using\nthis operator, we decompose three well-known logics extending Presburger with\nreals. Our decomposition splits a logic into two parts : one integer, and one\ndecimal (i.e. on the interval [0,1]). We also give a basis for an\nimplementation of our representation.\n", "versions": [{"version": "v1", "created": "Wed, 10 Dec 2008 17:08:45 GMT"}], "update_date": "2008-12-11", "authors_parsed": [["Bouchy", "Florent", "", "LSV"], ["Finkel", "Alain", "", "LSV"], ["Leroux", "J\u00e9r\u00f4me", "", "LaBRI"]]}, {"id": "0812.2390", "submitter": "Luigi Santocanale", "authors": "Luigi Santocanale (LIF), Yde Venema (ILLC)", "title": "Completeness for Flat Modal Fixpoint Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper exhibits a general and uniform method to prove completeness for\ncertain modal fixpoint logics. Given a set \\Gamma of modal formulas of the form\n\\gamma(x, p1, . . ., pn), where x occurs only positively in \\gamma, the\nlanguage L\\sharp (\\Gamma) is obtained by adding to the language of polymodal\nlogic a connective \\sharp\\_\\gamma for each \\gamma \\epsilon. The term\n\\sharp\\_\\gamma (\\varphi1, . . ., \\varphin) is meant to be interpreted as the\nleast fixed point of the functional interpretation of the term \\gamma(x,\n\\varphi 1, . . ., \\varphi n). We consider the following problem: given \\Gamma,\nconstruct an axiom system which is sound and complete with respect to the\nconcrete interpretation of the language L\\sharp (\\Gamma) on Kripke frames. We\nprove two results that solve this problem. First, let K\\sharp (\\Gamma) be the\nlogic obtained from the basic polymodal K by adding a Kozen-Park style fixpoint\naxiom and a least fixpoint rule, for each fixpoint connective \\sharp\\_\\gamma.\nProvided that each indexing formula \\gamma satisfies the syntactic criterion of\nbeing untied in x, we prove this axiom system to be complete. Second,\naddressing the general case, we prove the soundness and completeness of an\nextension K+ (\\Gamma) of K\\_\\sharp (\\Gamma). This extension is obtained via an\neffective procedure that, given an indexing formula \\gamma as input, returns a\nfinite set of axioms and derivation rules for \\sharp\\_\\gamma, of size bounded\nby the length of \\gamma. Thus the axiom system K+ (\\Gamma) is finite whenever\n\\Gamma is finite.\n", "versions": [{"version": "v1", "created": "Fri, 12 Dec 2008 15:04:57 GMT"}], "update_date": "2008-12-16", "authors_parsed": [["Santocanale", "Luigi", "", "LIF"], ["Venema", "Yde", "", "ILLC"]]}, {"id": "0812.2423", "submitter": "Benedikt Bollig", "authors": "Benedikt Bollig", "title": "On the Expressive Power of 2-Stack Visibly Pushdown Automata", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (December\n  24, 2008) lmcs:1101", "doi": "10.2168/LMCS-4(4:16)2008", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Visibly pushdown automata are input-driven pushdown automata that recognize\nsome non-regular context-free languages while preserving the nice closure and\ndecidability properties of finite automata. Visibly pushdown automata with\nmultiple stacks have been considered recently by La Torre, Madhusudan, and\nParlato, who exploit the concept of visibility further to obtain a rich\nautomata class that can even express properties beyond the class of\ncontext-free languages. At the same time, their automata are closed under\nboolean operations, have a decidable emptiness and inclusion problem, and enjoy\na logical characterization in terms of a monadic second-order logic over words\nwith an additional nesting structure. These results require a restricted\nversion of visibly pushdown automata with multiple stacks whose behavior can be\nsplit up into a fixed number of phases. In this paper, we consider 2-stack\nvisibly pushdown automata (i.e., visibly pushdown automata with two stacks) in\ntheir unrestricted form. We show that they are expressively equivalent to the\nexistential fragment of monadic second-order logic. Furthermore, it turns out\nthat monadic second-order quantifier alternation forms an infinite hierarchy\nwrt words with multiple nestings. Combining these results, we conclude that\n2-stack visibly pushdown automata are not closed under complementation.\nFinally, we discuss the expressive power of B\\\"{u}chi 2-stack visibly pushdown\nautomata running on infinite (nested) words. Extending the logic by an infinity\nquantifier, we can likewise establish equivalence to existential monadic\nsecond-order logic.\n", "versions": [{"version": "v1", "created": "Fri, 12 Dec 2008 16:43:48 GMT"}, {"version": "v2", "created": "Wed, 24 Dec 2008 12:06:52 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Bollig", "Benedikt", ""]]}, {"id": "0812.2702", "submitter": "Mladen Pavicic", "authors": "Mladen Pavicic and Norman D. Megill", "title": "Standard Logics Are Valuation-Nonmonotonic", "comments": "35 pages, 3 figures", "journal-ref": "Journal of Logic and Computation, 18 (6) 959-982 (2008)", "doi": null, "report-no": null, "categories": "cs.LO cs.AI quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It has recently been discovered that both quantum and classical propositional\nlogics can be modelled by classes of non-orthomodular and thus non-distributive\nlattices that properly contain standard orthomodular and Boolean classes,\nrespectively. In this paper we prove that these logics are complete even for\nthose classes of the former lattices from which the standard orthomodular\nlattices and Boolean algebras are excluded. We also show that neither quantum\nnor classical computers can be founded on the latter models. It follows that\nlogics are \"valuation-nonmonotonic\" in the sense that their possible models\n(corresponding to their possible hardware implementations) and the valuations\nfor them drastically change when we add new conditions to their defining\nconditions. These valuations can even be completely separated by putting them\ninto disjoint lattice classes by a technique presented in the paper.\n", "versions": [{"version": "v1", "created": "Mon, 15 Dec 2008 00:49:12 GMT"}], "update_date": "2008-12-17", "authors_parsed": [["Pavicic", "Mladen", ""], ["Megill", "Norman D.", ""]]}, {"id": "0812.3068", "submitter": "Bas Luttik", "authors": "Rob van Glabbeek, Bas Luttik and Nikola Trcka", "title": "Branching Bisimilarity with Explicit Divergence", "comments": null, "journal-ref": null, "doi": null, "report-no": "CS-R 08-25", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the relational characterisation of branching bisimilarity with\nexplicit divergence. We prove that it is an equivalence and that it coincides\nwith the original definition of branching bisimilarity with explicit divergence\nin terms of coloured traces. We also establish a correspondence with several\nvariants of an action-based modal logic with until- and divergence modalities.\n", "versions": [{"version": "v1", "created": "Tue, 16 Dec 2008 14:36:43 GMT"}], "update_date": "2008-12-17", "authors_parsed": [["van Glabbeek", "Rob", ""], ["Luttik", "Bas", ""], ["Trcka", "Nikola", ""]]}, {"id": "0812.3550", "submitter": "Pierre Genev\\`es", "authors": "Pierre Geneves and Nabil Layaida", "title": "XML Static Analyzer User Manual", "comments": null, "journal-ref": null, "doi": null, "report-no": "RR-6726", "categories": "cs.PL cs.DB cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This document describes how to use the XML static analyzer in practice. It\nprovides informal documentation for using the XML reasoning solver\nimplementation. The solver allows automated verification of properties that are\nexpressed as logical formulas over trees. A logical formula may for instance\nexpress structural constraints or navigation properties (like e.g. path\nexistence and node selection) in finite trees. Logical formulas can be\nexpressed using the syntax of XPath expressions, DTD, XML Schemas, and Relax NG\ndefinitions.\n", "versions": [{"version": "v1", "created": "Thu, 18 Dec 2008 15:22:46 GMT"}], "update_date": "2008-12-19", "authors_parsed": [["Geneves", "Pierre", ""], ["Layaida", "Nabil", ""]]}, {"id": "0812.3836", "submitter": "Lutz Schr\\\"oder", "authors": "Lutz Schr\\\"oder", "title": "Bootstrapping Inductive and Coinductive Types in HasCASL", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (December\n  25, 2008) lmcs:1166", "doi": "10.2168/LMCS-4(4:17)2008", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We discuss the treatment of initial datatypes and final process types in the\nwide-spectrum language HasCASL. In particular, we present specifications that\nillustrate how datatypes and process types arise as bootstrapped concepts using\nHasCASL's type class mechanism, and we describe constructions of types of\nfinite and infinite trees that establish the conservativity of datatype and\nprocess type declarations adhering to certain reasonable formats. The latter\namounts to modifying known constructions from HOL to avoid unique choice; in\ncategorical terminology, this means that we establish that quasitoposes with an\ninternal natural numbers object support initial algebras and final coalgebras\nfor a range of polynomial functors, thereby partially generalising\ncorresponding results from topos theory. Moreover, we present similar\nconstructions in categories of internal complete partial orders in\nquasitoposes.\n", "versions": [{"version": "v1", "created": "Fri, 19 Dec 2008 16:22:15 GMT"}, {"version": "v2", "created": "Thu, 25 Dec 2008 18:36:36 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Schr\u00f6der", "Lutz", ""]]}, {"id": "0812.4614", "submitter": "Paola Zizzi", "authors": "Paola Zizzi", "title": "I, Quantum Robot: Quantum Mind control on a Quantum Computer", "comments": "13 pages; revised version for publication, references added", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.AI cs.LO cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The logic which describes quantum robots is not orthodox quantum logic, but a\ndeductive calculus which reproduces the quantum tasks (computational processes,\nand actions) taking into account quantum superposition and quantum\nentanglement. A way toward the realization of intelligent quantum robots is to\nadopt a quantum metalanguage to control quantum robots. A physical\nimplementation of a quantum metalanguage might be the use of coherent states in\nbrain signals.\n", "versions": [{"version": "v1", "created": "Thu, 25 Dec 2008 16:31:05 GMT"}, {"version": "v2", "created": "Thu, 28 May 2009 05:39:23 GMT"}], "update_date": "2009-05-28", "authors_parsed": [["Zizzi", "Paola", ""]]}, {"id": "0812.4727", "submitter": "Alwen Tiu", "authors": "Alwen Tiu and Alberto Momigliano", "title": "Induction and Co-induction in Sequent Calculus", "comments": "This is an extended and revised version of an extended abstract which\n  appeared in the proceedings of TYPES 2003", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Proof search has been used to specify a wide range of computation systems. In\norder to build a framework for reasoning about such specifications, we make use\nof a sequent calculus involving induction and co-induction. These proof\nprinciples are based on a proof theoretic (rather than set-theoretic) notion of\ndefinition. Definitions are akin to (stratified) logic programs, where the left\nand right rules for defined atoms allow one to view theories as \"closed\" or\ndefining fixed points. The use of definitions makes it possible to reason\nintensionally about syntax, in particular enforcing free equality via\nunification. We add in a consistent way rules for pre and post fixed points,\nthus allowing the user to reason inductively and co-inductively about\nproperties of computational system making full use of higher-order abstract\nsyntax. Consistency is guaranteed via cut-elimination, where we give the first,\nto our knowledge, cut-elimination procedure in the presence of general\ninductive and co-inductive definitions.\n", "versions": [{"version": "v1", "created": "Sat, 27 Dec 2008 09:29:16 GMT"}, {"version": "v2", "created": "Wed, 14 Jan 2009 06:01:25 GMT"}, {"version": "v3", "created": "Wed, 30 Sep 2009 05:03:56 GMT"}], "update_date": "2009-09-30", "authors_parsed": [["Tiu", "Alwen", ""], ["Momigliano", "Alberto", ""]]}, {"id": "0812.4814", "submitter": "Joergen Villadsen", "authors": "J{\\o}rgen Villadsen", "title": "Nominalistic Logic (Extended Abstract)", "comments": "3 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Nominalistic Logic (NL) is a new presentation of Paul Gilmore's Intensional\nType Theory (ITT) as a sequent calculus together with a succinct nominalization\naxiom (N) that permits names of predicates as individuals in certain cases. The\nlogic has a flexible comprehension axiom, but no extensionality axiom and no\ninfinity axiom, although axiom N is the key to the derivation of Peano's\npostulates for the natural numbers.\n", "versions": [{"version": "v1", "created": "Sun, 28 Dec 2008 12:45:05 GMT"}], "update_date": "2008-12-31", "authors_parsed": [["Villadsen", "J\u00f8rgen", ""]]}, {"id": "0812.4848", "submitter": "Thomas Schneider", "authors": "Michael Bauland, Thomas Schneider, Henning Schnoor, Ilka Schnoor,\n  Heribert Vollmer", "title": "The Complexity of Generalized Satisfiability for Linear Temporal Logic", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 1 (January\n  26, 2009) lmcs:1158", "doi": "10.2168/LMCS-5(1:1)2009", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a seminal paper from 1985, Sistla and Clarke showed that satisfiability\nfor Linear Temporal Logic (LTL) is either NP-complete or PSPACE-complete,\ndepending on the set of temporal operators used. If, in contrast, the set of\npropositional operators is restricted, the complexity may decrease. This paper\nundertakes a systematic study of satisfiability for LTL formulae over\nrestricted sets of propositional and temporal operators. Since every\npropositional operator corresponds to a Boolean function, there exist\ninfinitely many propositional operators. In order to systematically cover all\npossible sets of them, we use Post's lattice. With its help, we determine the\ncomputational complexity of LTL satisfiability for all combinations of temporal\noperators and all but two classes of propositional functions. Each of these\ninfinitely many problems is shown to be either PSPACE-complete, NP-complete, or\nin P.\n", "versions": [{"version": "v1", "created": "Sun, 28 Dec 2008 21:10:06 GMT"}, {"version": "v2", "created": "Tue, 27 Jan 2009 13:14:33 GMT"}, {"version": "v3", "created": "Mon, 23 Mar 2009 11:56:18 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Bauland", "Michael", ""], ["Schneider", "Thomas", ""], ["Schnoor", "Henning", ""], ["Schnoor", "Ilka", ""], ["Vollmer", "Heribert", ""]]}, {"id": "0812.4852", "submitter": "Carl Hewitt", "authors": "Carl Hewitt", "title": "Formalizing common sense for scalable inconsistency-robust information\n  integration using Direct Logic(TM) reasoning and the Actor Model", "comments": "Corrected: all types are strict", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Because contemporary large software systems are pervasively inconsistent, it\nis not safe to reason about them using classical logic. The goal of Direct\nLogic is to be a minimal fix to classical mathematical logic that meets the\nrequirements of large-scale Internet applications (including sense making for\nnatural language) by addressing the following issues: inconsistency robustness,\ncontrapositive inference bug, and direct argumentation.\n  Direct Logic makes the following contributions over previous work:\n  * Direct Inference (no contrapositive bug for inference)\n  * Direct Argumentation (inference directly expressed)\n  * Inconsistency-robust deduction without artifices such as indices (labels)\non propositions or restrictions on reiteration\n  * Intuitive inferences hold including the following:\n  * Boolean Equivalences\n  * Reasoning by splitting for disjunctive cases\n  * Soundness\n  * Inconsistency-robust Proof by Contradiction\n  Since the global state model of computation (first formalized by Turing) is\ninadequate to the needs of modern large-scale Internet applications the Actor\nModel was developed to meet this need. Using, the Actor Model, this paper\nproves that Logic Programming is not computationally universal in that there\nare computations that cannot be implemented using logical inference.\nConsequently the Logic Programming paradigm is strictly less general than the\nProcedural Embedding of Knowledge paradigm.\n", "versions": [{"version": "v1", "created": "Sun, 28 Dec 2008 21:37:23 GMT"}, {"version": "v10", "created": "Fri, 12 Jun 2009 21:10:35 GMT"}, {"version": "v100", "created": "Wed, 5 Nov 2014 14:09:33 GMT"}, {"version": "v101", "created": "Sun, 23 Nov 2014 22:59:31 GMT"}, {"version": "v102", "created": "Mon, 29 Dec 2014 16:47:29 GMT"}, {"version": "v103", "created": "Mon, 2 Mar 2015 06:39:17 GMT"}, {"version": "v11", "created": "Tue, 14 Jul 2009 00:08:22 GMT"}, {"version": "v12", "created": "Fri, 17 Jul 2009 05:28:44 GMT"}, {"version": "v13", "created": "Fri, 14 Aug 2009 07:48:39 GMT"}, {"version": "v14", "created": "Thu, 20 Aug 2009 18:19:06 GMT"}, {"version": "v15", "created": "Sat, 26 Sep 2009 18:10:14 GMT"}, {"version": "v16", "created": "Sun, 8 Nov 2009 07:43:45 GMT"}, {"version": "v17", "created": "Fri, 20 Nov 2009 16:05:14 GMT"}, {"version": "v18", "created": "Tue, 24 Nov 2009 05:50:49 GMT"}, {"version": "v19", "created": "Thu, 3 Dec 2009 15:42:13 GMT"}, {"version": "v2", "created": "Tue, 30 Dec 2008 23:30:05 GMT"}, {"version": "v20", "created": "Thu, 3 Dec 2009 23:03:29 GMT"}, {"version": "v21", "created": "Thu, 10 Dec 2009 07:12:22 GMT"}, {"version": "v22", "created": "Tue, 29 Dec 2009 23:00:04 GMT"}, {"version": "v23", "created": "Thu, 31 Dec 2009 20:06:59 GMT"}, {"version": "v24", "created": "Sat, 9 Jan 2010 18:28:38 GMT"}, {"version": "v25", "created": "Wed, 13 Jan 2010 22:53:30 GMT"}, {"version": "v26", "created": "Sat, 16 Jan 2010 21:02:44 GMT"}, {"version": "v27", "created": "Sun, 31 Jan 2010 11:51:22 GMT"}, {"version": "v28", "created": "Sun, 7 Feb 2010 22:47:16 GMT"}, {"version": "v29", "created": "Thu, 11 Feb 2010 22:23:44 GMT"}, {"version": "v3", "created": "Mon, 26 Jan 2009 18:10:14 GMT"}, {"version": "v30", "created": "Wed, 17 Feb 2010 17:54:03 GMT"}, {"version": "v31", "created": "Wed, 24 Feb 2010 01:49:48 GMT"}, {"version": "v32", "created": "Sat, 27 Feb 2010 14:08:25 GMT"}, {"version": "v33", "created": "Sat, 6 Mar 2010 17:44:48 GMT"}, {"version": "v34", "created": "Thu, 11 Mar 2010 15:34:10 GMT"}, {"version": "v35", "created": "Mon, 22 Mar 2010 01:39:19 GMT"}, {"version": "v36", "created": "Sun, 4 Apr 2010 10:13:36 GMT"}, {"version": "v37", "created": "Tue, 13 Apr 2010 16:37:09 GMT"}, {"version": "v38", "created": "Mon, 19 Apr 2010 16:28:14 GMT"}, {"version": "v39", "created": "Thu, 22 Apr 2010 19:20:04 GMT"}, {"version": "v4", "created": "Fri, 20 Mar 2009 17:32:25 GMT"}, {"version": "v40", "created": "Mon, 26 Apr 2010 16:52:49 GMT"}, {"version": "v41", "created": "Tue, 27 Apr 2010 16:17:39 GMT"}, {"version": "v42", "created": "Tue, 25 May 2010 14:53:37 GMT"}, {"version": "v43", "created": "Thu, 1 Jul 2010 14:48:06 GMT"}, {"version": "v44", "created": "Mon, 12 Jul 2010 15:46:06 GMT"}, {"version": "v45", "created": "Mon, 2 Aug 2010 10:51:53 GMT"}, {"version": "v46", "created": "Mon, 9 Aug 2010 11:11:23 GMT"}, {"version": "v47", "created": "Mon, 30 Aug 2010 17:19:34 GMT"}, {"version": "v48", "created": "Mon, 13 Sep 2010 19:00:50 GMT"}, {"version": "v49", "created": "Thu, 23 Sep 2010 17:42:38 GMT"}, {"version": "v5", "created": "Mon, 30 Mar 2009 14:24:19 GMT"}, {"version": "v50", "created": "Sun, 3 Oct 2010 02:36:47 GMT"}, {"version": "v51", "created": "Sun, 17 Oct 2010 00:29:19 GMT"}, {"version": "v52", "created": "Mon, 15 Nov 2010 23:37:16 GMT"}, {"version": "v53", "created": "Tue, 23 Nov 2010 19:19:16 GMT"}, {"version": "v54", "created": "Thu, 9 Dec 2010 13:25:55 GMT"}, {"version": "v55", "created": "Wed, 29 Dec 2010 13:27:45 GMT"}, {"version": "v56", "created": "Thu, 20 Jan 2011 07:46:17 GMT"}, {"version": "v57", "created": "Wed, 26 Jan 2011 08:31:46 GMT"}, {"version": "v58", "created": "Mon, 31 Jan 2011 00:17:50 GMT"}, {"version": "v59", "created": "Thu, 10 Feb 2011 08:28:00 GMT"}, {"version": "v6", "created": "Mon, 30 Mar 2009 23:44:01 GMT"}, {"version": "v60", "created": "Tue, 15 Mar 2011 16:15:16 GMT"}, {"version": "v61", "created": "Wed, 23 Mar 2011 13:25:55 GMT"}, {"version": "v62", "created": "Wed, 30 Mar 2011 06:55:12 GMT"}, {"version": "v63", "created": "Mon, 11 Apr 2011 16:45:02 GMT"}, {"version": "v64", "created": "Sun, 17 Apr 2011 23:39:33 GMT"}, {"version": "v65", "created": "Wed, 27 Apr 2011 08:28:01 GMT"}, {"version": "v66", "created": "Mon, 2 May 2011 14:13:51 GMT"}, {"version": "v67", "created": "Mon, 9 May 2011 16:14:00 GMT"}, {"version": "v68", "created": "Mon, 16 May 2011 03:13:50 GMT"}, {"version": "v69", "created": "Tue, 31 May 2011 10:21:32 GMT"}, {"version": "v7", "created": "Mon, 27 Apr 2009 08:17:17 GMT"}, {"version": "v70", "created": "Mon, 6 Jun 2011 17:00:09 GMT"}, {"version": "v71", "created": "Thu, 16 Jun 2011 18:37:21 GMT"}, {"version": "v72", "created": "Mon, 27 Jun 2011 19:40:09 GMT"}, {"version": "v73", "created": "Thu, 7 Jul 2011 00:36:10 GMT"}, {"version": "v74", "created": "Mon, 1 Aug 2011 19:25:13 GMT"}, {"version": "v75", "created": "Mon, 22 Aug 2011 06:42:33 GMT"}, {"version": "v76", "created": "Thu, 25 Aug 2011 14:51:09 GMT"}, {"version": "v77", "created": "Sun, 18 Sep 2011 14:44:39 GMT"}, {"version": "v78", "created": "Mon, 26 Sep 2011 20:45:24 GMT"}, {"version": "v79", "created": "Tue, 15 Nov 2011 15:31:31 GMT"}, {"version": "v8", "created": "Sat, 30 May 2009 23:38:27 GMT"}, {"version": "v80", "created": "Mon, 21 Nov 2011 20:08:06 GMT"}, {"version": "v81", "created": "Sun, 1 Jan 2012 00:46:32 GMT"}, {"version": "v82", "created": "Tue, 31 Jan 2012 03:10:35 GMT"}, {"version": "v83", "created": "Mon, 13 Feb 2012 07:17:46 GMT"}, {"version": "v84", "created": "Mon, 27 Feb 2012 23:02:35 GMT"}, {"version": "v85", "created": "Mon, 2 Apr 2012 14:16:11 GMT"}, {"version": "v86", "created": "Tue, 4 Dec 2012 18:26:14 GMT"}, {"version": "v87", "created": "Mon, 11 Mar 2013 19:40:08 GMT"}, {"version": "v88", "created": "Fri, 2 Aug 2013 21:41:29 GMT"}, {"version": "v89", "created": "Tue, 27 Aug 2013 13:27:49 GMT"}, {"version": "v9", "created": "Wed, 10 Jun 2009 14:59:46 GMT"}, {"version": "v90", "created": "Tue, 24 Sep 2013 19:05:21 GMT"}, {"version": "v91", "created": "Sat, 2 Nov 2013 04:51:44 GMT"}, {"version": "v92", "created": "Tue, 18 Feb 2014 19:43:19 GMT"}, {"version": "v93", "created": "Mon, 3 Mar 2014 07:52:01 GMT"}, {"version": "v94", "created": "Thu, 19 Jun 2014 22:03:58 GMT"}, {"version": "v95", "created": "Sat, 5 Jul 2014 22:04:00 GMT"}, {"version": "v96", "created": "Mon, 21 Jul 2014 12:48:15 GMT"}, {"version": "v97", "created": "Mon, 28 Jul 2014 14:54:56 GMT"}, {"version": "v98", "created": "Mon, 4 Aug 2014 16:55:37 GMT"}, {"version": "v99", "created": "Mon, 18 Aug 2014 14:28:05 GMT"}], "update_date": "2015-03-03", "authors_parsed": [["Hewitt", "Carl", ""]]}]