[{"id": "1910.00039", "submitter": "Martin Otto", "authors": "Martin Otto", "title": "Graded modal logic and counting bisimulation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This note sketches the extension of the basic characterisation theorems as\nthe bisimulation-invariant fragment of first-order logic to modal logic with\ngraded modalities and matching adaptation of bisimulation. We focus on showing\nexpressive completeness of graded multi-modal logic for those first-order\nproperties of pointed Kripke structures that are preserved under counting\nbisimulation equivalence among all or among just all finite pointed Kripke\nstructures.\n", "versions": [{"version": "v1", "created": "Mon, 30 Sep 2019 18:15:27 GMT"}], "update_date": "2019-10-02", "authors_parsed": [["Otto", "Martin", ""]]}, {"id": "1910.00334", "submitter": "Ana Roxin", "authors": "Nicolas Bus (CSTB), Ana Roxin (Le2i), Guillaume Picinbono (CSTB),\n  Muhammad Fahad (CSTB)", "title": "Towards French Smart Building Code: Compliance Checking Based on\n  Semantic Rules", "comments": null, "journal-ref": "Linked Data for Architecture and Construction (LDAC'2018), Jun\n  2018, Londres, United Kingdom", "doi": null, "report-no": null, "categories": "cs.AI cs.CL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Manually checking models for compliance against building regulation is a\ntime-consuming task for architects and construction engineers. There is thus a\nneed for algorithms that process information from construction projects and\nreport non-compliant elements. Still automated code-compliance checking raises\nseveral obstacles. Building regulations are usually published as human readable\ntexts and their content is often ambiguous or incomplete. Also, the vocabulary\nused for expressing such regulations is very different from the vocabularies\nused to express Building Information Models (BIM). Furthermore, the high level\nof details associated to BIM-contained geometries induces complex calculations.\nFinally, the level of complexity of the IFC standard also hinders the\nautomation of IFC processing tasks. Model chart, formal rules and\npre-processors approach allows translating construction regulations into\nsemantic queries. We further demonstrate the usefulness of this approach\nthrough several use cases. We argue our approach is a step forward in bridging\nthe gap between regulation texts and automated checking algorithms. Finally\nwith the recent building ontology BOT recommended by the W3C Linked Building\nData Community Group, we identify perspectives for standardizing and extending\nour approach.\n", "versions": [{"version": "v1", "created": "Tue, 1 Oct 2019 12:18:42 GMT"}], "update_date": "2019-10-02", "authors_parsed": [["Bus", "Nicolas", "", "CSTB"], ["Roxin", "Ana", "", "Le2i"], ["Picinbono", "Guillaume", "", "CSTB"], ["Fahad", "Muhammad", "", "CSTB"]]}, {"id": "1910.00635", "submitter": "J\\'an Komara", "authors": "J\\'an Komara and Paul J. Voda", "title": "Extraction of Efficient Programs in $I\\Sigma_1$-arithmetic", "comments": "16 pages; reprint of the technical report from July, 2000", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Clausal Language (CL) is a declarative programming and verifying system used\nin our teaching of computer science. CL is an implementation of, what we call,\n$\\mathit{PR}{+}I\\Sigma_1$ paradigm (primitive recursive functions with\n$I\\Sigma_1$-arithmetic). This paper introduces an extension of\n$I\\Sigma_1$-proofs called extraction proofs where one can extract from the\nproofs of $\\Pi_2$-specifications primitive recursive programs as efficient as\nthe hand-coded ones. This is achieved by having the programming constructs\ncorrespond exactly to the proof rules with the computational content.\n", "versions": [{"version": "v1", "created": "Tue, 1 Oct 2019 19:47:29 GMT"}], "update_date": "2019-10-03", "authors_parsed": [["Komara", "J\u00e1n", ""], ["Voda", "Paul J.", ""]]}, {"id": "1910.00905", "submitter": "Dan Frumin", "authors": "Dan Frumin, Robbert Krebbers, Lars Birkedal", "title": "Compositional Non-Interference for Fine-Grained Concurrent Programs", "comments": "New example in Section 2 has been added. A simpler security condition\n  is now used in Section 3. Major editing in Sections 1, 2, and 7", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Non-interference is a program property that ensures the absence of\ninformation leaks. In the context of programming languages, there exist two\ncommon approaches for establishing non-interference: type systems and program\nlogics. Type systems provide strong automation (by means of type checking), but\nthey are inherently restrictive in the kind of programs they support. Program\nlogics support challenging programs, but they typically require significant\nhuman assistance, and cannot handle modules or higher-order programs.\n  To connect these two approaches, we present SeLoC---a separation logic for\nnon-interference, on top of which we build a type system using the technique of\nlogical relations. By building a type system on top of separation logic, we can\ncompositionally verify programs that consist of typed and untyped parts. The\nformer parts are verified through type checking, while the latter parts are\nverified through manual proof.\n  The core technical contribution of SeLoC is a relational form of weakest\npreconditions that can track information flow using separation logic resources.\nSeLoC is fully machine-checked, and built on top of the Iris framework for\nconcurrent separation logic in Coq. The integration with Iris provides seamless\nsupport for fine-grained concurrency, which was beyond the reach of prior type\nsystems and program logics for non-interference.\n", "versions": [{"version": "v1", "created": "Wed, 2 Oct 2019 12:25:28 GMT"}, {"version": "v2", "created": "Fri, 6 Mar 2020 13:51:09 GMT"}], "update_date": "2020-03-09", "authors_parsed": [["Frumin", "Dan", ""], ["Krebbers", "Robbert", ""], ["Birkedal", "Lars", ""]]}, {"id": "1910.00907", "submitter": "Martin Dieguez", "authors": "Joseph Boudou and Mart\\'in Di\\'eguez and David Fern\\'andez-Duque", "title": "Complete Intuitionistic Temporal Logics in Topological Dynamics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The language of linear temporal logic can be interpreted over the class of\ndynamic topological systems, giving rise to the intuitionistic temporal logic\n${{\\sf ITL}^{\\sf c}}_{\\Diamond,\\forall}$, recently shown to be decidable by\nFern\\'andez-Duque. In this article we axiomatize this logic, some fragments,\nand prove completeness for several familiar spaces.\n", "versions": [{"version": "v1", "created": "Wed, 2 Oct 2019 12:33:35 GMT"}], "update_date": "2019-10-03", "authors_parsed": [["Boudou", "Joseph", ""], ["Di\u00e9guez", "Mart\u00edn", ""], ["Fern\u00e1ndez-Duque", "David", ""]]}, {"id": "1910.01047", "submitter": "Markus Hecher", "authors": "Johannes Klaus Fichte, Markus Hecher, Andreas Pfandler", "title": "Lower Bounds for QBFs of Bounded Treewidth", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.AI cs.DM cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of deciding the validity (QSAT) of quantified Boolean formulas\n(QBF) is a vivid research area in both theory and practice. In the field of\nparameterized algorithmics, the well-studied graph measure treewidth turned out\nto be a successful parameter. A well-known result by Chen in parameterized\ncomplexity is that QSAT when parameterized by the treewidth of the primal graph\nof the input formula together with the quantifier depth of the formula is\nfixed-parameter tractable. More precisely, the runtime of such an algorithm is\npolynomial in the formula size and exponential in the treewidth, where the\nexponential function in the treewidth is a tower, whose height is the\nquantifier depth. A natural question is whether one can significantly improve\nthese results and decrease the tower while assuming the Exponential Time\nHypothesis (ETH). In the last years, there has been a growing interest in the\nquest of establishing lower bounds under ETH, showing mostly problem-specific\nlower bounds up to the third level of the polynomial hierarchy. Still, an\nimportant question is to settle this as general as possible and to cover the\nwhole polynomial hierarchy. In this work, we show lower bounds based on the ETH\nfor arbitrary QBFs parameterized by treewidth (and quantifier depth). More\nformally, we establish lower bounds for QSAT and treewidth, namely, that under\nETH there cannot be an algorithm that solves QSAT of quantifier depth i in\nruntime significantly better than i-fold exponential in the treewidth and\npolynomial in the input size. In doing so, we provide a versatile reduction\ntechnique to compress treewidth that encodes the essence of dynamic programming\non arbitrary tree decompositions. Further, we describe a general methodology\nfor a more fine-grained analysis of problems parameterized by treewidth that\nare at higher levels of the polynomial hierarchy.\n", "versions": [{"version": "v1", "created": "Wed, 2 Oct 2019 16:09:22 GMT"}, {"version": "v2", "created": "Thu, 2 Jul 2020 21:05:13 GMT"}], "update_date": "2020-07-06", "authors_parsed": [["Fichte", "Johannes Klaus", ""], ["Hecher", "Markus", ""], ["Pfandler", "Andreas", ""]]}, {"id": "1910.01100", "submitter": "Arnd Hartmanns", "authors": "Arnd Hartmanns, Benjamin Lucien Kaminski", "title": "Optimistic Value Iteration", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Markov decision processes are widely used for planning and verification in\nsettings that combine controllable or adversarial choices with probabilistic\nbehaviour. The standard analysis algorithm, value iteration, only provides a\nlower bound on unbounded probabilities or reward values. Two \"sound\"\nvariations, which also deliver an upper bound, have recently appeared. In this\npaper, we present optimistic value iteration, a new sound approach that\nleverages value iteration's ability to usually deliver tight lower bounds: we\nobtain a lower bound via standard value iteration, use the result to \"guess\" an\nupper bound, and prove the latter's correctness. Optimistic value iteration is\neasy to implement, does not require extra precomputations or a priori state\nspace transformations, and works for computing reachability probabilities as\nwell as expected rewards. It is also fast, as we show via an extensive\nexperimental evaluation using our publicly available implementation within the\nModest Toolset.\n", "versions": [{"version": "v1", "created": "Wed, 2 Oct 2019 17:36:24 GMT"}, {"version": "v2", "created": "Thu, 17 Oct 2019 18:17:34 GMT"}], "update_date": "2019-10-21", "authors_parsed": [["Hartmanns", "Arnd", ""], ["Kaminski", "Benjamin Lucien", ""]]}, {"id": "1910.01181", "submitter": "Ankit Kumar Shukla", "authors": "Ankit Shukla", "title": "Improving Reasoning on DQBF", "comments": "FMCAD'19 Student Forum", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The aim of this PhD project is to develop fast and robust reasoning tools for\ndependency quantified Boolean formulas (DQBF). In this paper, we outline two\nproperties, autarkies and symmetries, that potentially can be exploited for\npre- and in-processing in the DQBF solving process. DQBF extend quantified\nBoolean formulas (QBF) with non-linear dependencies between the quantified\nvariables. Automated testing and debugging techniques are an essential part of\nthe solvers tool-chain. For rigorous DQBF solver development, we are working on\nnovel automated testing and debugging techniques as successfully established in\nSAT and QBF solving. The tool is under development.\n", "versions": [{"version": "v1", "created": "Wed, 2 Oct 2019 19:35:27 GMT"}], "update_date": "2019-10-04", "authors_parsed": [["Shukla", "Ankit", ""]]}, {"id": "1910.01382", "submitter": "Zhe Hou", "authors": "Hadrien Bride, Zhe Hou, Jie Dong, Jin Song Dong and Ali Mirjalili", "title": "Silas: High Performance, Explainable and Verifiable Machine Learning", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.LO stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces a new classification tool named Silas, which is built\nto provide a more transparent and dependable data analytics service. A focus of\nSilas is on providing a formal foundation of decision trees in order to support\nlogical analysis and verification of learned prediction models. This paper\ndescribes the distinct features of Silas: The Model Audit module formally\nverifies the prediction model against user specifications, the Enforcement\nLearning module trains prediction models that are guaranteed correct, the Model\nInsight and Prediction Insight modules reason about the prediction model and\nexplain the decision-making of predictions. We also discuss implementation\ndetails ranging from programming paradigm to memory management that help\nachieve high-performance computation.\n", "versions": [{"version": "v1", "created": "Thu, 3 Oct 2019 10:17:50 GMT"}], "update_date": "2019-10-04", "authors_parsed": [["Bride", "Hadrien", ""], ["Hou", "Zhe", ""], ["Dong", "Jie", ""], ["Dong", "Jin Song", ""], ["Mirjalili", "Ali", ""]]}, {"id": "1910.01697", "submitter": "Bruno Bentzen", "authors": "Bruno Bentzen", "title": "A Henkin-style completeness proof for the modal logic S5", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a recent formalization of a Henkin-style completeness\nproof for the propositional modal logic S5 using the Lean theorem prover. The\nproof formalized is close to that of Hughes and Cresswell [9], except that it\nis given for a system based on a different choice of axioms. Here the proof is\nbased on a Hilbert-style presentation better described as a Mendelson system\naugmented with axiom schemes for K, T, S4, and B, and the necessitation rule as\nrule of inference. The language has the false and implication as the only\nprimitive logical connectives and necessity as the only primitive modal\noperator. The full source code is available online and has been typechecked\nwith Lean 3.4.1.\n", "versions": [{"version": "v1", "created": "Thu, 3 Oct 2019 19:23:30 GMT"}], "update_date": "2019-10-07", "authors_parsed": [["Bentzen", "Bruno", ""]]}, {"id": "1910.01775", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "Formula Transformers and Combinatorial Test Generators for Propositional\n  Intuitionistic Theorem Provers", "comments": "32 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop combinatorial test generation algorithms for progressively more\npowerful theorem provers, covering formula languages ranging from the\nimplicational fragment of intuitionistic logic to full intuitionistic\npropositional logic. Our algorithms support exhaustive and random generators\nfor formulas of these logics.\n  To provide known-to-be-provable formulas, via the Curry-Howard\nformulas-as-types correspondence, we use generators for typable lambda terms\nand combinator expressions. Besides generators for several classes of formulas,\nwe design algorithms that restrict formula generation to canonical\nrepresentatives among equiprovable formulas and introduce program\ntransformations that reduce formulas to equivalent formulas of a simpler\nstructure. The same transformations, when applied in reverse, create harder\nformulas that can catch soundness or incompleteness bugs.\n  To test the effectiveness of the testing framework itself, we describe use\ncases for deriving lightweight theorem provers for several of these logics and\nfor finding bugs in known theorem provers. Our Prolog implementation available\nat: https://github.com/ptarau/TypesAndProofs and a subset of formula generators\nand theorem provers, implemented in Python is available at:\nhttps://github.com/ptarau/PythonProvers.\n  Keywords: term and formula generation algorithms, Prolog-based theorem\nprovers, formulas-as-types, type inference and type inhabitation, combinatorial\ntesting, finding bugs in theorem provers.\n", "versions": [{"version": "v1", "created": "Fri, 4 Oct 2019 01:41:09 GMT"}], "update_date": "2019-10-07", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1910.01856", "submitter": "Ulrik Buchholtz", "authors": "Marc Bezem and Ulrik Buchholtz and Daniel R. Grayson and Michael\n  Shulman", "title": "Construction of the Circle in UniMath", "comments": "27 pages; many improvements thanks to referee comments; added Shulman\n  as co-author, who helped write a new section on the interpretation in higher\n  toposes", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO math.AT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that the type $\\mathrm{T}\\mathbb{Z}$ of $\\mathbb{Z}$-torsors has the\ndependent universal property of the circle, which characterizes it up to a\nunique homotopy equivalence. The construction uses Voevodsky's Univalence Axiom\nand propositional truncation, yielding a stand-alone construction of the circle\nnot using higher inductive types.\n", "versions": [{"version": "v1", "created": "Fri, 4 Oct 2019 10:18:33 GMT"}, {"version": "v2", "created": "Wed, 18 Nov 2020 12:23:22 GMT"}], "update_date": "2020-11-19", "authors_parsed": [["Bezem", "Marc", ""], ["Buchholtz", "Ulrik", ""], ["Grayson", "Daniel R.", ""], ["Shulman", "Michael", ""]]}, {"id": "1910.01879", "submitter": "Marta Fiori Carones", "authors": "Marta Fiori-Carones and Alberto Marcone", "title": "To reorient is easier than to orient: an on-line algorithm for\n  reorientation of graphs", "comments": "Only minor (non mathematical) changes introduced. To appear in\n  Computability", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define an on-line (incremental) algorithm that, given a (possibly\ninfinite) pseudo-transitive oriented graph, produces a transitive\nreorientation. This implies that a theorem of Ghouila-Houri is provable in\nRCA_0 and hence is computably true.\n", "versions": [{"version": "v1", "created": "Fri, 4 Oct 2019 11:35:42 GMT"}, {"version": "v2", "created": "Mon, 11 Jan 2021 09:24:36 GMT"}], "update_date": "2021-01-12", "authors_parsed": [["Fiori-Carones", "Marta", ""], ["Marcone", "Alberto", ""]]}, {"id": "1910.01996", "submitter": "Ond\\v{r}ej Leng\\'al", "authors": "Luk\\'a\\v{s} Hol\\'ik, Ond\\v{r}ej Leng\\'al, Olli Saarikivi, Lenka\n  Turo\\v{n}ov\\'a, Margus Veanes, Tom\\'a\\v{s} Vojnar", "title": "Succinct Determinisation of Counting Automata via Sphere Construction\n  (Technical Report)", "comments": "An extended version of a paper accepted at APLAS'19", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose an efficient algorithm for determinising counting automata (CAs),\ni.e., finite automata extended with bounded counters. The algorithm avoids\nunfolding counters into control states, unlike the na\\\"ive approach, and thus\nproduces much smaller deterministic automata. We also develop a simplified and\nfaster version of the general algorithm for the sub-class of so-called monadic\nCAs (MCAs), i.e., CAs with counting loops on character classes, which are\ncommon in practice. Our main motivation is (besides applications in\nverification and decision procedures of logics) the application of\ndeterministic (M)CAs in pattern matching regular expressions with counting,\nwhich are very common in e.g. network traffic processing and log analysis. We\nhave evaluated our algorithm against practical benchmarks from these\napplication domains and concluded that compared to the na\\\"ive approach, our\nalgorithm is much less prone to explode, produces automata that can be several\norders of magnitude smaller, and is overall faster.\n", "versions": [{"version": "v1", "created": "Fri, 4 Oct 2019 15:38:28 GMT"}], "update_date": "2019-10-07", "authors_parsed": [["Hol\u00edk", "Luk\u00e1\u0161", ""], ["Leng\u00e1l", "Ond\u0159ej", ""], ["Saarikivi", "Olli", ""], ["Turo\u0148ov\u00e1", "Lenka", ""], ["Veanes", "Margus", ""], ["Vojnar", "Tom\u00e1\u0161", ""]]}, {"id": "1910.02145", "submitter": "Alexis Ghyselen", "authors": "Patrick Baillot and Alexis Ghyselen", "title": "Types for Parallel Complexity in the Pi-calculus", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Type systems as a way to control or analyze programs have been largely\nstudied in the context of functional programming languages. Some of those work\nallow to extract from a typing derivation for a program a complexity bound on\nthis program. We present how to adapt this result for parallel complexity in\nthe pi-calculus, as a model of concurrency and parallel communication. We study\ntwo notions of time complexity: the total computation time without parallelism\n(the work) and the computation time under maximal parallelism (the span). We\ndefine reduction relations in the pi-calculus to capture those two notions, and\nwe present two type systems from which one can extract a complexity bound on a\nprocess. The type systems are inspired by input/output types and size types,\nwith temporal information about communications.\n", "versions": [{"version": "v1", "created": "Thu, 3 Oct 2019 10:43:43 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Baillot", "Patrick", ""], ["Ghyselen", "Alexis", ""]]}, {"id": "1910.02257", "submitter": "Dmitry Shkatov", "authors": "Mikhail Rybakov and Dmitry Shkatov", "title": "Complexity of finite-variable fragments of propositional modal logics of\n  symmetric frames", "comments": null, "journal-ref": "Logic Journal of the IGPL, Volume 27, Issue 1, February 2019,\n  Pages 60-68", "doi": "10.1093/jigpal/jzy018", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While finite-variable fragments of the propositional modal logic S5--complete\nwith respect to reflexive, symmetric and transitive frames--are polynomial-time\ndecidable, the restriction to finite-variable formulas for logics of reflexive\nand transitive frames yields fragments that remain \"intractable.\" The role of\nthe symmetry condition in this context has not been investigated. We show that\nsymmetry either by itself or in combination with reflexivity produces logics\nthat behave just like logics of reflexive and transitive frames, i.e. their\nfinite-variable fragments remain intractable, namely PSPACE-hard. This raises\nthe question of where exactly the borderline lies between modal logics whose\nfinite-variable fragments are tractable and the rest.\n", "versions": [{"version": "v1", "created": "Sat, 5 Oct 2019 12:46:08 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Rybakov", "Mikhail", ""], ["Shkatov", "Dmitry", ""]]}, {"id": "1910.02446", "submitter": "Xuefeng Wen", "authors": "Xuefeng Wen", "title": "Modal Logic via Global Consequence", "comments": "NCML 2019 Paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In modal logic, semantic consequence is usually defined locally by truth\npreservation at all worlds in all models (with respect to a class of frames).\nIt can also be defined globally by truth preservation in all models (with\nrespect to a class of frames). The latter is called global consequence, which\nis much less studied than the standard local one. In this paper we first study\nthe relationship between local and global consequence. Then we give some\ncorrespondence results for global consequence. Finally, we illustrate two\napplications of global consequence, connecting it with informational\nconsequence and update consequence proposed in formal semantics. Some results\nin the paper are already known, which are collected in the paper for the sake\nof completeness. The others appear to be new. We suggest that global\nconsequence is not only interesting theoretically, but also useful for\napplication.\n", "versions": [{"version": "v1", "created": "Sun, 6 Oct 2019 13:19:54 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Wen", "Xuefeng", ""]]}, {"id": "1910.02453", "submitter": "Karl Schlechta", "authors": "Karl Schlechta", "title": "A Short Remark on Analogical Reasoning", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We discuss the problem of defining a logic for analogical reasoning, and\nsketch a solution in the style of the semantics for Counterfactual\nConditionals, Preferential Structures, etc.\n", "versions": [{"version": "v1", "created": "Sun, 6 Oct 2019 14:14:04 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Schlechta", "Karl", ""]]}, {"id": "1910.02521", "submitter": "Thorsten Wissmann", "authors": "G. Michele Pinna", "title": "Representing Dependencies in Event Structures", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 2 (May 13,\n  2020) lmcs:6470", "doi": "10.23638/LMCS-16(2:3)2020", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Event structures where the causality may explicitly change during a\ncomputation have recently gained the stage. In this kind of event structures\nthe changes in the set of the causes of an event are triggered by modifiers\nthat may add or remove dependencies, thus making the happening of an event\ncontextual. Still the focus is always on the dependencies of the event. In this\npaper we promote the idea that the context determined by the modifiers plays a\nmajor role, and the context itself determines not only the causes but also what\ncausality should be. Modifiers are then used to understand when an event (or a\nset of events) can be added to a configuration, together with a set of events\nmodeling dependencies, which will play a less important role. We show that most\nof the notions of Event Structure presented in literature can be translated\ninto this new kind of event structure, preserving the main notion, namely the\none of configuration.\n", "versions": [{"version": "v1", "created": "Sun, 6 Oct 2019 20:39:58 GMT"}, {"version": "v2", "created": "Mon, 17 Feb 2020 14:49:33 GMT"}, {"version": "v3", "created": "Mon, 11 May 2020 14:40:12 GMT"}, {"version": "v4", "created": "Tue, 12 May 2020 06:49:58 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Pinna", "G. Michele", ""]]}, {"id": "1910.02732", "submitter": "Etienne Miquey", "authors": "\\'Etienne Miquey (GALLINETTE, LS2N)", "title": "Revisiting the duality of computation: an algebraic analysis of\n  classical realizability models", "comments": "CSL 2020, Jan 2020, Barcelone, Spain", "journal-ref": null, "doi": "10.4230/LIPIcs.CSL.2020.30", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In an impressive series of papers, Krivine showed at the edge of the last\ndecade how classical realizability provides a surprising technique to build\nmodels for classical theories. In particular, he proved that classical\nrealizability subsumes Cohen's forcing, and even more, gives rise to unexpected\nmodels of set theories. Pursuing the algebraic analysis of these models that\nwas first undertaken by Streicher, Miquel recently proposed to lay the\nalgebraic foundation of classical realizability and forcing within new\nstructures which he called implicative algebras. These structures are a\ngeneralization of Boolean algebras based on an internal law representing the\nimplication. Notably, implicative algebras allow for the adequate\ninterpretation of both programs (i.e. proofs) and their types (i.e. formulas)\nin the same structure. The very definition of implicative algebras takes\nposition on a presentation of logic through universal quantification and the\nimplication and, computationally, relies on the call-by-name\n$\\lambda$-calculus. In this paper, we investigate the relevance of this choice,\nby introducing two similar structures. On the one hand, we define disjunctive\nalgebras, which rely on internal laws for the negation and the disjunction and\nwhich we show to be particular cases of implicative algebras. On the other\nhand, we introduce conjunctive algebras, which rather put the focus on\nconjunctions and on the call-by-value evaluation strategy. We finally show how\ndisjunctive and conjunctive algebras algebraically reflect the well-known\nduality of computation between call-by-name and call-by-value.\n", "versions": [{"version": "v1", "created": "Mon, 7 Oct 2019 11:35:23 GMT"}, {"version": "v2", "created": "Mon, 13 Jan 2020 15:09:39 GMT"}], "update_date": "2020-07-16", "authors_parsed": [["Miquey", "\u00c9tienne", "", "GALLINETTE, LS2N"]]}, {"id": "1910.02736", "submitter": "Ekanshdeep Gupta", "authors": "Alain Finkel (LSV), Ekanshdeep Gupta", "title": "The Well Structured Problem for Presburger Counter Machines", "comments": null, "journal-ref": "39th IARCS Annual Conference on Foundations of Software Technology\n  and Theoretical Computer Science (FSTTCS 2019), Arkadev Chattopadhyay; Paul\n  Gastin, Dec 2019, Mumbai, India", "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce the well structured problem as the question of whether a model\n(here a counter machine) is well structured (here for the usual ordering on\nintegers). We show that it is undecidable for most of the (Presburger-defined)\ncounter machines except for Affine VASS of dimension one. However, the strong\nwell structured problem is decidable for all Presburger counter machines. While\nAffine VASS of dimension one are not, in general, well structured, we give an\nalgorithm that computes the set of predecessors of a configuration; as a\nconsequence this allows to decide the well structured problem for 1-Affine\nVASS.\n", "versions": [{"version": "v1", "created": "Mon, 7 Oct 2019 11:43:20 GMT"}], "update_date": "2019-10-08", "authors_parsed": [["Finkel", "Alain", "", "LSV"], ["Gupta", "Ekanshdeep", ""]]}, {"id": "1910.02874", "submitter": "Thorsten Wissmann", "authors": "Giorgio Audrito, Jacob Beal, Ferruccio Damiani, Danilo Pianini, Mirko\n  Viroli", "title": "Field-based Coordination with the Share Operator", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 4 (October\n  2, 2020) lmcs:6816", "doi": "10.23638/LMCS-16(4:1)2020", "report-no": null, "categories": "cs.DC cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Field-based coordination has been proposed as a model for coordinating\ncollective adaptive systems, promoting a view of distributed computations as\nfunctions manipulating data structures spread over space and evolving over\ntime, called computational fields. The field calculus is a formal foundation\nfor field computations, providing specific constructs for evolution (time) and\nneighbor interaction (space), which are handled by separate operators (called\nrep and nbr, respectively). This approach, however, intrinsically limits the\nspeed of information propagation that can be achieved by their combined use. In\nthis paper, we propose a new field-based coordination operator called share,\nwhich captures the space-time nature of field computations in a single operator\nthat declaratively achieves: (i) observation of neighbors' values; (ii)\nreduction to a single local value; and (iii) update and converse sharing to\nneighbors of a local variable. We show that for an important class of\nself-stabilising computations, share can replace all occurrences of rep and nbr\nconstructs. In addition to conceptual economy, use of the share operator also\nallows many prior field calculus algorithms to be greatly accelerated, which we\nvalidate empirically with simulations of frequently used network propagation\nand collection algorithms.\n", "versions": [{"version": "v1", "created": "Mon, 7 Oct 2019 15:54:03 GMT"}, {"version": "v2", "created": "Thu, 23 Apr 2020 16:15:57 GMT"}, {"version": "v3", "created": "Sat, 12 Sep 2020 08:33:19 GMT"}, {"version": "v4", "created": "Wed, 30 Sep 2020 19:45:45 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Audrito", "Giorgio", ""], ["Beal", "Jacob", ""], ["Damiani", "Ferruccio", ""], ["Pianini", "Danilo", ""], ["Viroli", "Mirko", ""]]}, {"id": "1910.03121", "submitter": "Evan Cavallo", "authors": "Evan Cavallo", "title": "Stable factorization from a fibred algebraic weak factorization system", "comments": "11 pages. v2: correct typos", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a construction of stable diagonal factorizations, used to define\ncategorical models of type theory with identity types, from a family of\nalgebraic weak factorization systems on the slices of a category. Inspired by a\ncomputational interpretation of indexed inductive types in cubical type theory\ndue to Cavallo and Harper, it can be read as a refactoring of a construction of\nvan den Berg and Garner, and is a new alternative among a variety of approaches\nto modeling identity types in the literature.\n", "versions": [{"version": "v1", "created": "Mon, 7 Oct 2019 22:50:55 GMT"}, {"version": "v2", "created": "Mon, 18 Nov 2019 20:39:54 GMT"}], "update_date": "2019-11-20", "authors_parsed": [["Cavallo", "Evan", ""]]}, {"id": "1910.03217", "submitter": "Martin Lester", "authors": "Martin Lester", "title": "Understanding the Expressive Power of Unhygienic Substitution in\n  Metaprogramming via Combinatory Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Recent work on combinatory logic demonstrates a compositional translation\nfrom lambda calculus that gives meaning to open terms. As the meaning of open\nterms is a key difficulty in the study of metaprogramming, we investigate\nwhether this idea can be extended to metaprogramming systems with hygienic and\nunhygienic substitution, specifically $\\lambda_{e}^{\\rightarrow \\Box}$ and\n$\\lambda_{\\mathcal{S}}$. We conclude that there is quantitative evidence to\nsupport the claim that metaprogramming with unhygienic substitution is more\npowerful than metaprogramming with hygienic substitution.\n", "versions": [{"version": "v1", "created": "Tue, 8 Oct 2019 05:15:32 GMT"}], "update_date": "2019-10-09", "authors_parsed": [["Lester", "Martin", ""]]}, {"id": "1910.03542", "submitter": "Tom\\'a\\v{s} Jakl", "authors": "Tom\\'a\\v{s} Jakl", "title": "Canonical extensions of locally compact frames", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Canonical extension of finitary ordered structures such as lattices, posets,\nproximity lattices, etc., is a certain completion which entirely describes the\ntopological dual of the ordered structure and it does so in a purely algebraic\nand choice-free way. We adapt the general algebraic technique that constructs\nthem to the theory of frames.\n  As a result, we show that every locally compact frame embeds into a\ncompletely distributive lattice by a construction which generalises, among\nothers, the canonical extensions for distributive lattices and proximity\nlattices. This construction also provides a new description of a construction\nby Marcel Ern\\'e. Moreover, canonical extensions of frames enable us to\nframe-theoretically represent monotone maps with respect to the specialisation\norder.\n", "versions": [{"version": "v1", "created": "Tue, 8 Oct 2019 17:00:58 GMT"}], "update_date": "2019-10-09", "authors_parsed": [["Jakl", "Tom\u00e1\u0161", ""]]}, {"id": "1910.03740", "submitter": "Joshua Brakensiek", "authors": "Joshua Brakensiek, Marijn Heule, John Mackey, David Narv\\'aez", "title": "The Resolution of Keller's Conjecture", "comments": "25 pages, 9 figures, 3 tables; IJCAR 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.LO math.MG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider three graphs, $G_{7,3}$, $G_{7,4}$, and $G_{7,6}$, related to\nKeller's conjecture in dimension 7. The conjecture is false for this dimension\nif and only if at least one of the graphs contains a clique of size $2^7 =\n128$. We present an automated method to solve this conjecture by encoding the\nexistence of such a clique as a propositional formula. We apply satisfiability\nsolving combined with symmetry-breaking techniques to determine that no such\nclique exists. This result implies that every unit cube tiling of\n$\\mathbb{R}^7$ contains a facesharing pair of cubes. Since a faceshare-free\nunit cube tiling of $\\mathbb{R}^8$ exists (which we also verify), this\ncompletely resolves Keller's conjecture.\n", "versions": [{"version": "v1", "created": "Wed, 9 Oct 2019 01:35:06 GMT"}, {"version": "v2", "created": "Tue, 22 Oct 2019 01:16:25 GMT"}, {"version": "v3", "created": "Tue, 7 Apr 2020 14:24:53 GMT"}, {"version": "v4", "created": "Wed, 2 Dec 2020 01:01:17 GMT"}], "update_date": "2020-12-03", "authors_parsed": [["Brakensiek", "Joshua", ""], ["Heule", "Marijn", ""], ["Mackey", "John", ""], ["Narv\u00e1ez", "David", ""]]}, {"id": "1910.03752", "submitter": "Paolo Perrone", "authors": "Tobias Fritz, Paolo Perrone and Sharwin Rezagholi", "title": "Probability, valuations, hyperspace: Three monads on Top and the support\n  as a morphism", "comments": "65 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GN cs.LO math.CT math.FA math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider three monads on Top, the category of topological spaces, which\nformalize topological aspects of probability and possibility in categorical\nterms. The first one is the Hoare hyperspace monad H, which assigns to every\nspace its space of closed subsets equipped with the lower Vietoris topology.\nThe second is the monad V of continuous valuations, also known as the extended\nprobabilistic powerdomain. We construct both monads in a unified way in terms\nof double dualization. This reveals a close analogy between them, and allows us\nto prove that the operation of taking the support of a continuous valuation is\na morphism of monads from V to H. In particular, this implies that every\nH-algebra (topological complete semilattice) is also a V-algebra. Third, we\nshow that V can be restricted to a submonad of tau-smooth probability measures\non Top. By composing these two morphisms of monads, we obtain that taking the\nsupport of a $\\tau$-smooth probability measure is also a morphism of monads.\n", "versions": [{"version": "v1", "created": "Wed, 9 Oct 2019 02:12:17 GMT"}, {"version": "v2", "created": "Mon, 19 Apr 2021 11:53:09 GMT"}], "update_date": "2021-04-20", "authors_parsed": [["Fritz", "Tobias", ""], ["Perrone", "Paolo", ""], ["Rezagholi", "Sharwin", ""]]}, {"id": "1910.03917", "submitter": "Thorsten Wissmann", "authors": "Stefan Hetzl, Jannik Vierling", "title": "Clause Set Cycles and Induction", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 4 (November\n  30, 2020) lmcs:6932", "doi": "10.23638/LMCS-16(4:11)2020", "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this article we relate a family of methods for automated inductive theorem\nproving based on cycle detection in saturation-based provers to well-known\ntheories of induction. To this end we introduce the notion of clause set cycles\n-- a formalism abstracting a certain type of cyclic dependency between clause\nsets. We first show that the formalism of clause set cycles is contained in the\ntheory of $\\exists_1$ induction. Secondly we consider the relation between\nclause set cycles and the theory of open induction. By providing a finite\naxiomatization of a theory of triangular numbers with open induction we show\nthat the formalism of clause set cycles is not contained in the theory of open\ninduction. Furthermore we conjecture that open induction and clause set cycles\nare incomparable. Finally, we transfer these results to a concrete method of\nautomated inductive theorem proving called the n-clause calculus.\n", "versions": [{"version": "v1", "created": "Wed, 9 Oct 2019 12:02:04 GMT"}, {"version": "v2", "created": "Fri, 12 Jun 2020 15:45:48 GMT"}, {"version": "v3", "created": "Wed, 30 Sep 2020 13:12:14 GMT"}, {"version": "v4", "created": "Fri, 9 Oct 2020 09:36:47 GMT"}, {"version": "v5", "created": "Fri, 27 Nov 2020 16:55:37 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Hetzl", "Stefan", ""], ["Vierling", "Jannik", ""]]}, {"id": "1910.04010", "submitter": "Marcos Cramer", "authors": "Diego Agust\\'in Ambrossio, Marcos Cramer", "title": "A Query-Driven Decision Procedure for Distributed Autoepistemic Logic\n  with Inductive Definitions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Distributed Autoepistemic Logic with Inductive Definitions (dAEL(ID)) is a\nrecently proposed non-monotonic logic for says-based access control. We define\na query-driven decision procedure for dAEL(ID) that is implemented in the\nknowledge-base system IDP. The decision procedure is designed in such a way\nthat it allows one to determine access rights while avoiding redundant\ninformation flow between principals in order to enhance security and reduce\nprivacy concerns. Given that the decision procedure has in the worst case an\nexponential runtime, it is to be regarded as a proof of concept that increases\nour understanding of dAEL(ID), rather than being deployed for an access control\nsystem.\n", "versions": [{"version": "v1", "created": "Wed, 9 Oct 2019 14:15:06 GMT"}], "update_date": "2019-10-10", "authors_parsed": [["Ambrossio", "Diego Agust\u00edn", ""], ["Cramer", "Marcos", ""]]}, {"id": "1910.04137", "submitter": "Rohit Chadha", "authors": "Gilles Barthe, Rohit Chadha, Vishal Jagannath, A. Prasad Sistla and\n  Mahesh Viswanathan", "title": "Deciding Differential Privacy for Programs with Finite Inputs and\n  Outputs", "comments": null, "journal-ref": null, "doi": "10.1145/3373718.339479", "report-no": null, "categories": "cs.CR cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Differential privacy is a de facto standard for statistical computations over\ndatabases that contain private data. The strength of differential privacy lies\nin a rigorous mathematical definition that guarantees individual privacy and\nyet allows for accurate statistical results. Thanks to its mathematical\ndefinition, differential privacy is also a natural target for formal analysis.\nA broad line of work uses logical methods for proving privacy. However, these\nmethods are not complete, and only partially automated. A recent and\ncomplementary line of work uses statistical methods for finding privacy\nviolations. However, the methods only provide statistical guarantees (but no\nproofs).\n  We propose the first decision procedure for checking the differential privacy\nof a non-trivial class of probabilistic computations. Our procedure takes as\ninput a program P parametrized by a privacy budget $\\epsilon$, and either\nproves differential privacy for all possible values of $\\epsilon$ or generates\na counterexample. In addition, our procedure applies both to\n$\\epsilon$-differential privacy and $(\\epsilon,\\delta)$-differential privacy.\nTechnically, the decision procedure is based on a novel and judicious encoding\nof the semantics of programs in our class into a decidable fragment of the\nfirst-order theory of the reals with exponentiation. We implement our procedure\nand use it for (dis)proving privacy bounds for many well-known examples,\nincluding randomized response, histogram, report noisy max and sparse vector.\n", "versions": [{"version": "v1", "created": "Wed, 9 Oct 2019 17:23:39 GMT"}, {"version": "v2", "created": "Fri, 1 May 2020 22:05:28 GMT"}], "update_date": "2020-05-05", "authors_parsed": [["Barthe", "Gilles", ""], ["Chadha", "Rohit", ""], ["Jagannath", "Vishal", ""], ["Sistla", "A. Prasad", ""], ["Viswanathan", "Mahesh", ""]]}, {"id": "1910.04216", "submitter": "Nima Roohi", "authors": "Nima Roohi and Mahesh Viswanathan", "title": "Revisiting MITL to Fix Decision Procedures", "comments": "Presented at the 19th International Conference on Verification, Model\n  Checking, and Abstract Interpretation (VMCAI'18)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Metric Interval Temporal Logic (MITL) is a well studied real-time, temporal\nlogic that has decidable satisfiability and model checking problems. The\ndecision procedures for MITL rely on the automata theoretic approach, where\nlogic formulas are translated into equivalent timed automata. Since timed\nautomata are not closed under complementation, decision procedures for MITL\nfirst convert a formula into negated normal form before translating to a timed\nautomaton. We show that, unfortunately, these 20-year-old procedures are\nincorrect, because they rely on an incorrect semantics of the R operator. We\npresent the right semantics of R and give new, correct decision procedures for\nMITL. We show that both satisfiability and model checking for MITL are\nEXPSPACE-complete, as was previously claimed. We also identify a fragment of\nMITL that we call MITL_{WI} that is richer than MITL_{0,\\infty}, for which we\nshow that both satisfiability and model checking are PSPACE-complete. Many of\nour results have been formally proved in PVS.\n", "versions": [{"version": "v1", "created": "Wed, 9 Oct 2019 19:41:54 GMT"}], "update_date": "2019-10-11", "authors_parsed": [["Roohi", "Nima", ""], ["Viswanathan", "Mahesh", ""]]}, {"id": "1910.04266", "submitter": "Thorsten Wissmann", "authors": "Hern\\'an Melgratti, Claudio Antares Mezzina, Irek Ulidowski", "title": "Reversing Place Transition Nets", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 4 (October\n  16, 2020) lmcs:6843", "doi": "10.23638/LMCS-16(4:5)2020", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Petri nets are a well-known model of concurrency and provide an ideal setting\nfor the study of fundamental aspects in concurrent systems. Despite their\nsimplicity, they still lack a satisfactory causally reversible semantics. We\ndevelop such semantics for Place/Transitions Petri nets (P/T nets) based on two\nobservations. Firstly, a net that explicitly expresses causality and conflict\namong events, for example an occurrence net, can be straightforwardly reversed\nby adding a reverse transition for each of its forward transitions. Secondly,\ngiven a P/T net the standard unfolding construction associates with it an\noccurrence net that preserves all of its computation. Consequently, the\nreversible semantics of a P/T net can be obtained as the reversible semantics\nof its unfolding. We show that such reversible behaviour can be expressed as a\nfinite net whose tokens are coloured by causal histories. Colours in our\nencoding resemble the causal memories that are typical in reversible process\ncalculi.\n", "versions": [{"version": "v1", "created": "Wed, 9 Oct 2019 21:38:19 GMT"}, {"version": "v2", "created": "Mon, 20 Apr 2020 12:51:59 GMT"}, {"version": "v3", "created": "Mon, 21 Sep 2020 15:11:20 GMT"}, {"version": "v4", "created": "Thu, 15 Oct 2020 11:24:18 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Melgratti", "Hern\u00e1n", ""], ["Mezzina", "Claudio Antares", ""], ["Ulidowski", "Irek", ""]]}, {"id": "1910.04489", "submitter": "Pavel Naumov", "authors": "Pavel Naumov, Kevin Ros", "title": "Strategic Coalitions in Stochastic Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The article introduces a notion of a stochastic game with failure states and\nproposes two logical systems with modality \"coalition has a strategy to\ntransition to a non-failure state with a given probability while achieving a\ngiven goal.\" The logical properties of this modality depend on whether the\nmodal language allows the empty coalition. The main technical results are a\ncompleteness theorem for a logical system with the empty coalition, a strong\ncompleteness theorem for the logical system without the empty coalition, and an\nincompleteness theorem which shows that there is no strongly complete logical\nsystem in the language with the empty coalition.\n", "versions": [{"version": "v1", "created": "Thu, 10 Oct 2019 11:33:15 GMT"}], "update_date": "2019-10-11", "authors_parsed": [["Naumov", "Pavel", ""], ["Ros", "Kevin", ""]]}, {"id": "1910.04600", "submitter": "Martin Helfrich", "authors": "Michael Blondin, Javier Esparza, Blaise Genest, Martin Helfrich and\n  Stefan Jaax", "title": "Succinct Population Protocols for Presburger Arithmetic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.CC cs.LO cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Angluin et al. proved that population protocols compute exactly the\npredicates definable in Presburger arithmetic (PA), the first-order theory of\naddition. As part of this result, they presented a procedure that translates\nany formula $\\varphi$ of quantifier-free PA with remainder predicates (which\nhas the same expressive power as full PA) into a population protocol with\n$2^{O(\\text{poly}(|\\varphi|))}$ states that computes $\\varphi$. More precisely,\nthe number of states of the protocol is exponential in both the bit length of\nthe largest coefficient in the formula, and the number of nodes of its syntax\ntree.\n  In this paper, we prove that every formula $\\varphi$ of quantifier-free PA\nwith remainder predicates is computable by a leaderless population protocol\nwith $O(\\text{poly}(|\\varphi|))$ states. Our proof is based on several new\nconstructions, which may be of independent interest. Given a formula $\\varphi$\nof quantifier-free PA with remainder predicates, a first construction produces\na succinct protocol (with $O(|\\varphi|^3)$ leaders) that computes $\\varphi$;\nthis completes the work initiated in [STACS'18], where we constructed such\nprotocols for a fragment of PA. For large enough inputs, we can get rid of\nthese leaders. If the input is not large enough, then it is small, and we\ndesign another construction producing a succinct protocol with one leader that\ncomputes $\\varphi$. Our last construction gets rid of this leader for small\ninputs.\n", "versions": [{"version": "v1", "created": "Thu, 10 Oct 2019 14:28:13 GMT"}, {"version": "v2", "created": "Mon, 13 Jan 2020 15:07:23 GMT"}], "update_date": "2020-01-14", "authors_parsed": [["Blondin", "Michael", ""], ["Esparza", "Javier", ""], ["Genest", "Blaise", ""], ["Helfrich", "Martin", ""], ["Jaax", "Stefan", ""]]}, {"id": "1910.04643", "submitter": "Saurabh Joshi", "authors": "Ruben Martins and Saurabh Joshi and Vasco Manquinho and Ines Lynce", "title": "Reflections on \"Incremental Cardinality Constraints for MaxSAT\"", "comments": "10 pages, 1 algorithm, 1 table, 4 figures, article invited as part of\n  \"Virtual Volume\" for 25th anniversary of CP", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  To celebrate the first 25 years of the International Conference on Principles\nand Practice of Constraint Programming (CP) the editors invited the authors of\nthe most cited paper of each year to write a commentary on their paper. This\nreport describes our reflections on the CP 2014 paper \"Incremental Cardinality\nConstraints for MaxSAT\" and its impact on the Maximum Satisfiability community\nand beyond.\n", "versions": [{"version": "v1", "created": "Thu, 10 Oct 2019 15:26:47 GMT"}], "update_date": "2019-10-11", "authors_parsed": [["Martins", "Ruben", ""], ["Joshi", "Saurabh", ""], ["Manquinho", "Vasco", ""], ["Lynce", "Ines", ""]]}, {"id": "1910.04891", "submitter": "Eike Neumann", "authors": "Michal Kone\\v{c}n\\'y and Eike Neumann", "title": "Implementing evaluation strategies for continuous real functions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give a technical overview of our exact-real implementation of various\nrepresentations of the space of continuous unary real functions over the unit\ndomain and a family of associated (partial) operations, including integration,\nrange computation, as well as pointwise addition, multiplication, division,\nsine, cosine, square root and maximisation.\n  We use several representations close to the usual theoretical model, based on\nan oracle that evaluates the function at a point or over an interval. We also\ninclude several representations based on an oracle that computes a converging\nsequence of rigorous (piecewise or one-piece) polynomial and rational\napproximations over the whole unit domain. Finally, we describe \"local\"\nrepresentations that combine both approaches, i.e. oracle-like representations\nthat return a rigorous symbolic approximation of the function over a requested\ninterval sub-domain with a requested effort.\n  See also our paper \"Representations and evaluation strategies for feasibly\napproximable functions\" which compares the efficiency of these representations\nand algorithms and also formally describes and analyses one of the key\nalgorithms, namely a polynomial-time division of functions in a\npiecewise-polynomial representation. We do not reproduce this division\nalgorithm here.\n", "versions": [{"version": "v1", "created": "Thu, 10 Oct 2019 22:05:52 GMT"}], "update_date": "2019-10-14", "authors_parsed": [["Kone\u010dn\u00fd", "Michal", ""], ["Neumann", "Eike", ""]]}, {"id": "1910.04948", "submitter": "Thorsten Wissmann", "authors": "Dirk Pattinson, Mina Mohammadian", "title": "Constructive Domains with Classical Witnesses", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 17, Issue 1 (March 2,\n  2021) lmcs:7231", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We develop a constructive theory of continuous domains from the perspective\nof program extraction. Our goal that programs represent (provably correct)\ncomputation without witnesses of correctness is achieved by formulating\ncorrectness assertions classically. Technically, we start from a predomain base\nand construct a completion. We then investigate continuity with respect to the\nScott topology, and present a construction of the function space. We then\ndiscuss our main motivating example in detail, and instantiate our theory to\nreal numbers that we conceptualise as the total elements of the completion of\nthe predomain of rational intervals, and prove a representation theorem that\nprecisely delineates the class of representable continuous functions.\n", "versions": [{"version": "v1", "created": "Fri, 11 Oct 2019 02:36:50 GMT"}, {"version": "v2", "created": "Mon, 22 Jun 2020 14:02:53 GMT"}, {"version": "v3", "created": "Wed, 24 Jun 2020 11:44:26 GMT"}, {"version": "v4", "created": "Sun, 5 Jul 2020 12:59:22 GMT"}, {"version": "v5", "created": "Wed, 25 Nov 2020 02:28:56 GMT"}, {"version": "v6", "created": "Tue, 9 Feb 2021 08:36:18 GMT"}, {"version": "v7", "created": "Mon, 1 Mar 2021 17:46:50 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Pattinson", "Dirk", ""], ["Mohammadian", "Mina", ""]]}, {"id": "1910.05016", "submitter": "Alessio Mansutti", "authors": "St\\'ephane Demri, Etienne Lozes, Alessio Mansutti", "title": "Internal Calculi for Separation Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a general approach to axiomatise separation logics with heaplet\nsemantics with no external features such as nominals/labels. To start with, we\ndesign the first (internal) Hilbert-style axiomatisation for the\nquantifier-free separation logic. We instantiate the method by introducing a\nnew separation logic with essential features: it is equipped with the\nseparating conjunction, the predicate ls, and a natural guarded form of\nfirst-order quantification. We apply our approach for its axiomatisation. As a\nby-product of our method, we also establish the exact expressive power of this\nnew logic and we show PSpace-completeness of its satisfiability problem.\n", "versions": [{"version": "v1", "created": "Fri, 11 Oct 2019 08:05:27 GMT"}], "update_date": "2019-10-14", "authors_parsed": [["Demri", "St\u00e9phane", ""], ["Lozes", "Etienne", ""], ["Mansutti", "Alessio", ""]]}, {"id": "1910.05172", "submitter": "Cl\\'ement Aubert", "authors": "Cl\\'ement Aubert", "title": "Categories for Me, and You?", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A non-self-contained gathering of notes on category theory, including the\ndefinition of locally cartesian closed category, of the cartesian structure in\nslice categories, or of the pseudo-cartesian structure on Eilenberg-Moore\ncategories. References and proofs are provided, sometimes, to my knowledge, for\nthe first time.\n", "versions": [{"version": "v1", "created": "Fri, 11 Oct 2019 13:28:39 GMT"}, {"version": "v2", "created": "Tue, 15 Oct 2019 08:06:21 GMT"}], "update_date": "2019-10-16", "authors_parsed": [["Aubert", "Cl\u00e9ment", ""]]}, {"id": "1910.05208", "submitter": "Viorica  Sofronie-Stokkermans", "authors": "Viorica Sofronie-Stokkermans", "title": "Parametric Systems: Verification and Synthesis", "comments": "39 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we study possibilities of using hierarchical reasoning, symbol\nelimination and model generation for the verification of parametric systems,\nwhere the parameters can be constants or functions. Our goal is to\nautomatically provide guarantees that such systems satisfy certain safety or\ninvariance conditions. We analyze the possibility of automatically generating\nsuch guarantees in the form of constraints on parameters. We illustrate our\nmethods on several examples\n", "versions": [{"version": "v1", "created": "Fri, 11 Oct 2019 14:18:29 GMT"}], "update_date": "2019-10-14", "authors_parsed": [["Sofronie-Stokkermans", "Viorica", ""]]}, {"id": "1910.05215", "submitter": "Tim Lyon", "authors": "Tim Lyon, Alwen Tiu, Rajeev Gor\\'e, Ranald Clouston", "title": "Syntactic Interpolation for Tense Logics and Bi-Intuitionistic Logic via\n  Nested Sequents", "comments": "Appended version of the paper \"Syntactic Interpolation for Tense\n  Logics and Bi-Intuitionistic Logic via Nested Sequents\", accepted to the 28th\n  International Conference on Computer Science Logic (CSL 2020)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide a direct method for proving Craig interpolation for a range of\nmodal and intuitionistic logics, including those containing a \"converse\"\nmodality. We demonstrate this method for classical tense logic, its extensions\nwith path axioms, and for bi-intuitionistic logic. These logics do not have\nstraightforward formalisations in the traditional Gentzen-style sequent\ncalculus, but have all been shown to have cut-free nested sequent calculi. The\nproof of the interpolation theorem uses these calculi and is purely syntactic,\nwithout resorting to embeddings, semantic arguments, or interpreted connectives\nexternal to the underlying logical language. A novel feature of our proof\nincludes an orthogonality condition for defining duality between interpolants.\n", "versions": [{"version": "v1", "created": "Fri, 11 Oct 2019 14:32:27 GMT"}, {"version": "v2", "created": "Tue, 15 Oct 2019 19:40:06 GMT"}], "update_date": "2019-10-17", "authors_parsed": [["Lyon", "Tim", ""], ["Tiu", "Alwen", ""], ["Gor\u00e9", "Rajeev", ""], ["Clouston", "Ranald", ""]]}, {"id": "1910.05556", "submitter": "Dmitry Shkatov", "authors": "Dmitry Shkatov and C. J. Van Alten", "title": "Complexity of the universal theory of bounded residuated distributive\n  lattice-ordered groupoids", "comments": null, "journal-ref": "Algebra Universalis, 80(3), 2019, article 36", "doi": "10.1007/s00012-019-0609-1", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the universal theory and the quasi-equational theory of bounded\nresiduated distributive lattice-orderegroupoids are both EXPTIME-complete.\nSimilar results areproven for bounded distributive lattices with a unary or\nbinary operator and for some special classes of bounded residuated distributive\nlattice-ordered groupoids.\n", "versions": [{"version": "v1", "created": "Sat, 12 Oct 2019 12:07:25 GMT"}], "update_date": "2019-10-17", "authors_parsed": [["Shkatov", "Dmitry", ""], ["Van Alten", "C. J.", ""]]}, {"id": "1910.05558", "submitter": "Davide Giacomo Cavezza", "authors": "Davide G. Cavezza, Dalal Alrajeh, Andras Gyorgy", "title": "Minimal Assumptions Refinement for GR(1) Specifications", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reactive synthesis is concerned with finding a correct-by-construction\ncontroller from formal specifications, typically expressed in Linear Temporal\nLogic (LTL). The specifications describe assumptions about an environment and\nguarantees to be achieved by the controller operating in that environment. If a\ncontroller exists, given the assumptions, the specification is said to be\nrealizable. This paper focuses on finding a minimal set of assumptions that\nguarantee realizability in the context of counterstrategy-guided assumption\nrefinement procedures. Specifically, we introduce the notion of minimal\nassumptions refinements and provide an algorithm that provably computes these\nwith little time overhead. We show experimentally, using common benchmarks,\nthat embedding our algorithm in state-of-the-art approaches for assumption\nrefinement results in consistently shorter solutions than without such\nembedding, and allows to explore a higher number of candidate solutions. We\nalso propose a hybrid variant for dealing with the higher sparsity of solutions\nin the space of minimal refinements and show that its application speeds up the\nidentification of a solution.\n", "versions": [{"version": "v1", "created": "Sat, 12 Oct 2019 12:44:15 GMT"}], "update_date": "2019-10-15", "authors_parsed": [["Cavezza", "Davide G.", ""], ["Alrajeh", "Dalal", ""], ["Gyorgy", "Andras", ""]]}, {"id": "1910.06004", "submitter": "Nils Vortmeier", "authors": "Nils Vortmeier, Thomas Zeume", "title": "Dynamic Complexity of Parity Exists Queries", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a graph whose nodes may be coloured red, the parity of the number of\nred nodes can easily be maintained with first-order update rules in the dynamic\ncomplexity framework DynFO of Patnaik and Immerman. Can this be generalised to\nother or even all queries that are definable in first-order logic extended by\nparity quantifiers? We consider the query that asks whether the number of nodes\nthat have an edge to a red node is odd. Already this simple query of quantifier\nstructure parity-exists is a major roadblock for dynamically capturing\nextensions of first-order logic.\n  We show that this query cannot be maintained with quantifier-free first-order\nupdate rules, and that variants induce a hierarchy for such update rules with\nrespect to the arity of the maintained auxiliary relations. Towards maintaining\nthe query with full first-order update rules, it is shown that\ndegree-restricted variants can be maintained.\n", "versions": [{"version": "v1", "created": "Mon, 14 Oct 2019 09:24:16 GMT"}, {"version": "v2", "created": "Mon, 13 Jul 2020 08:18:58 GMT"}, {"version": "v3", "created": "Fri, 5 Mar 2021 17:04:55 GMT"}], "update_date": "2021-03-08", "authors_parsed": [["Vortmeier", "Nils", ""], ["Zeume", "Thomas", ""]]}, {"id": "1910.06057", "submitter": "Matthias Hoelzel", "authors": "Matthias Hoelzel and Richard Wilke", "title": "On the Union Closed Fragment of Existential Second-Order Logic and\n  Logics with Team Semantics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present syntactic characterisations for the union closed fragments of\nexistential second-order logic and of logics with team semantics. Since union\nclosure is a semantical and undecidable property, the normal form we introduce\nenables the handling and provides a better understanding of this fragment. We\nalso introduce inclusion-exclusion games that turn out to be precisely the\ncorresponding model-checking games. These games are not only interesting in\ntheir own right, but they also are a key factor towards building a bridge\nbetween the semantic and syntactic fragments. On the level of logics with team\nsemantics we additionally present restrictions of inclusion-exclusion logic to\ncapture the union closed fragment. Moreover, we define a team based atom that\nwhen adding it to first-order logic also precisely captures the union closed\nfragment of existential second-order logic which answers an open question by\nGalliani and Hella.\n", "versions": [{"version": "v1", "created": "Mon, 14 Oct 2019 11:53:22 GMT"}, {"version": "v2", "created": "Thu, 21 May 2020 22:19:28 GMT"}, {"version": "v3", "created": "Mon, 11 Jan 2021 11:00:22 GMT"}, {"version": "v4", "created": "Thu, 29 Jul 2021 07:27:10 GMT"}], "update_date": "2021-07-30", "authors_parsed": [["Hoelzel", "Matthias", ""], ["Wilke", "Richard", ""]]}, {"id": "1910.06097", "submitter": "Bernhard Kragl", "authors": "Thomas Ferr\\`ere, Thomas A. Henzinger, Bernhard Kragl", "title": "Monitoring Event Frequencies", "comments": "This is an extended version of a paper presented at the 28th EACSL\n  Annual Conference on Computer Science Logic (CSL 2020), which provides\n  missing proofs in the appendix", "journal-ref": null, "doi": "10.4230/LIPIcs.CSL.2020.20", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The monitoring of event frequencies can be used to recognize behavioral\nanomalies, to identify trends, and to deduce or discard hypotheses about the\nunderlying system. For example, the performance of a web server may be\nmonitored based on the ratio of the total count of requests from the least and\nmost active clients. Exact frequency monitoring, however, can be prohibitively\nexpensive; in the above example it would require as many counters as there are\nclients. In this paper, we propose the efficient probabilistic monitoring of\ncommon frequency properties, including the mode (i.e., the most common event)\nand the median of an event sequence. We define a logic to express composite\nfrequency properties as a combination of atomic frequency properties. Our main\ncontribution is an algorithm that, under suitable probabilistic assumptions,\ncan be used to monitor these important frequency properties with four counters,\nindependent of the number of different events. Our algorithm samples longer and\nlonger subwords of an infinite event sequence. We prove the almost-sure\nconvergence of our algorithm by generalizing ergodic theory from\nincreasing-length prefixes to increasing-length subwords of an infinite\nsequence. A similar algorithm could be used to learn a connected Markov chain\nof a given structure from observing its outputs, to arbitrary precision, for a\ngiven confidence.\n", "versions": [{"version": "v1", "created": "Mon, 14 Oct 2019 12:35:04 GMT"}, {"version": "v2", "created": "Fri, 10 Jan 2020 13:59:43 GMT"}], "update_date": "2020-01-13", "authors_parsed": [["Ferr\u00e8re", "Thomas", ""], ["Henzinger", "Thomas A.", ""], ["Kragl", "Bernhard", ""]]}, {"id": "1910.06145", "submitter": "Yuri Gurevich", "authors": "Andreas Blass and Yuri Gurevich", "title": "Circuit pedantry", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Boolean and quantum circuits have commonalities and differences. To formalize\nthe syntactical commonality we introduce syntactic circuits where the gates are\nblack boxes. Syntactic circuits support various semantics. One semantics is\nprovided by Boolean circuits, another by quantum circuits. Quantum semantics is\na generalization of Boolean but, because of entanglement, the generalization is\nnot straightforward. We consider only unitary quantum circuits here.\n", "versions": [{"version": "v1", "created": "Mon, 14 Oct 2019 13:58:24 GMT"}], "update_date": "2019-10-15", "authors_parsed": [["Blass", "Andreas", ""], ["Gurevich", "Yuri", ""]]}, {"id": "1910.06202", "submitter": "Xuefeng Wen", "authors": "Xuefeng Wen", "title": "On Axiomatization of Lewis' Conditional Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper first shows that the popular axiomatic systems proposed by Nute\nfor Lewis' conditional logics are not equivalent to Lewis' original systems. In\nparticular, the axiom CA which is derivable in Lewis' systems is not derivable\nin Nute's systems. Then the paper proposes a new set of axiomatizations for\nLewis' conditional logics, without using CSO, or RCEA, or the rule of\ninterchange of logical equivalents. Instead, the new axiomatizations adopt two\naxioms which correspond to cautious monotonicity and cautious cut in\nnonmonotonic logics, respectively. Finally, the paper gives a simple resolution\nto a puzzle about the controversial axiom of simplification of disjunctive\nantecedents, using a long neglected axiom in one of Lewis' systems for\nconditional logics.\n", "versions": [{"version": "v1", "created": "Mon, 14 Oct 2019 15:19:53 GMT"}], "update_date": "2019-10-15", "authors_parsed": [["Wen", "Xuefeng", ""]]}, {"id": "1910.06281", "submitter": "Jonas Schmidt", "authors": "Jonas Schmidt, Thomas Schwentick, Nils Vortmeier, Thomas Zeume,\n  Ioannis Kokkinis", "title": "Dynamic Complexity Meets Parameterised Algorithms", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dynamic Complexity studies the maintainability of queries with logical\nformulas in a setting where the underlying structure or database changes over\ntime. Most often, these formulas are from first-order logic, giving rise to the\ndynamic complexity class DynFO. This paper investigates extensions of DynFO in\nthe spirit of parameterised algorithms. In this setting structures come with a\nparameter $k$ and the extensions allow additional \"space\" of size $f(k)$ (in\nthe form of an additional structure of this size) or additional time $f(k)$ (in\nthe form of iterations of formulas) or both. The resulting classes are compared\nwith their non-dynamic counterparts and other classes. The main part of the\npaper explores the applicability of methods for parameterised algorithms to\nthis setting through case studies for various well-known parameterised\nproblems.\n", "versions": [{"version": "v1", "created": "Mon, 14 Oct 2019 17:05:14 GMT"}, {"version": "v2", "created": "Tue, 15 Oct 2019 12:56:05 GMT"}], "update_date": "2019-10-16", "authors_parsed": [["Schmidt", "Jonas", ""], ["Schwentick", "Thomas", ""], ["Vortmeier", "Nils", ""], ["Zeume", "Thomas", ""], ["Kokkinis", "Ioannis", ""]]}, {"id": "1910.06576", "submitter": "Tim Lyon", "authors": "Tim Lyon", "title": "On Deriving Nested Calculi for Intuitionistic Logics from Semantic\n  Systems", "comments": "Appended version of the paper \"On Deriving Nested Calculi for\n  Intuitionistic Logics from Semantic Systems\", accepted to the International\n  Symposium on Logical Foundations of Computer Science (LFCS 2020)", "journal-ref": null, "doi": "10.1007/978-3-030-36755-8_12", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper shows how to derive nested calculi from labelled calculi for\npropositional intuitionistic logic and first-order intuitionistic logic with\nconstant domains, thus connecting the general results for labelled calculi with\nthe more refined formalism of nested sequents. The extraction of nested calculi\nfrom labelled calculi obtains via considerations pertaining to the elimination\nof structural rules in labelled derivations. Each aspect of the extraction\nprocess is motivated and detailed, showing that each nested calculus inherits\nfavorable proof-theoretic properties from its associated labelled calculus.\n", "versions": [{"version": "v1", "created": "Tue, 15 Oct 2019 07:54:34 GMT"}, {"version": "v2", "created": "Mon, 21 Oct 2019 09:06:36 GMT"}, {"version": "v3", "created": "Mon, 3 Feb 2020 18:26:43 GMT"}], "update_date": "2020-02-04", "authors_parsed": [["Lyon", "Tim", ""]]}, {"id": "1910.06657", "submitter": "Tim Lyon", "authors": "Tim Lyon", "title": "Syntactic Cut-Elimination for Intuitionistic Fuzzy Logic via Linear\n  Nested Sequents", "comments": "Appended version of the paper \"Syntactic Cut-Elimination for\n  Intuitionistic Fuzzy Logic via Linear Nested Sequents\", accepted to the\n  International Symposium on Logical Foundations of Computer Science (LFCS\n  2020)", "journal-ref": null, "doi": "10.1007/978-3-030-36755-8_11", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper employs the linear nested sequent framework to design a new\ncut-free calculus LNIF for intuitionistic fuzzy logic--the first-order G\\\"odel\nlogic characterized by linear relational frames with constant domains. Linear\nnested sequents--which are nested sequents restricted to linear\nstructures--prove to be a well-suited proof-theoretic formalism for\nintuitionistic fuzzy logic. We show that the calculus LNIF possesses highly\ndesirable proof-theoretic properties such as invertibility of all rules,\nadmissibility of structural rules, and syntactic cut-elimination.\n", "versions": [{"version": "v1", "created": "Tue, 15 Oct 2019 11:16:13 GMT"}, {"version": "v2", "created": "Mon, 21 Oct 2019 09:04:35 GMT"}, {"version": "v3", "created": "Mon, 3 Feb 2020 18:22:39 GMT"}, {"version": "v4", "created": "Sun, 4 Oct 2020 21:51:32 GMT"}], "update_date": "2020-10-06", "authors_parsed": [["Lyon", "Tim", ""]]}, {"id": "1910.07065", "submitter": "Geoffrey Cruttwell", "authors": "Robin Cockett, Geoffrey Cruttwell, Jonathan Gallagher, Jean-Simon\n  Pacaud Lemay, Benjamin MacAdam, Gordon Plotkin, Dorette Pronk", "title": "Reverse derivative categories", "comments": "Extended version of paper to appear at CSL 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The reverse derivative is a fundamental operation in machine learning and\nautomatic differentiation. This paper gives a direct axiomatization of a\ncategory with a reverse derivative operation, in a similar style to that given\nby Cartesian differential categories for a forward derivative. Intriguingly, a\ncategory with a reverse derivative also has a forward derivative, but the\nconverse is not true. In fact, we show explicitly what a forward derivative is\nmissing: a reverse derivative is equivalent to a forward derivative with a\ndagger structure on its subcategory of linear maps. Furthermore, we show that\nthese linear maps form an additively enriched category with dagger biproducts.\n", "versions": [{"version": "v1", "created": "Tue, 15 Oct 2019 21:46:07 GMT"}], "update_date": "2019-10-17", "authors_parsed": [["Cockett", "Robin", ""], ["Cruttwell", "Geoffrey", ""], ["Gallagher", "Jonathan", ""], ["Lemay", "Jean-Simon Pacaud", ""], ["MacAdam", "Benjamin", ""], ["Plotkin", "Gordon", ""], ["Pronk", "Dorette", ""]]}, {"id": "1910.07275", "submitter": "Evan Piermont", "authors": "Evan Piermont", "title": "Algebraic Semantics for Propositional Awareness Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper puts forth a class of algebraic structures, relativized Boolean\nalgebras (RBAs), that provide semantics for propositional logic in which\ntruth/validity is only defined relative to a local domain. In particular, the\njoin of an event and its complement need not be the top element. Nonetheless,\nbehavior is locally governed by the laws of propositional logic. By further\nendowing these structures with operators (akin to the theory of modal Algebras)\nRBAs serve as models of modal logics in which truth is relative. In particular,\nmodal RBAs provide semantics for various well known awareness logics.\n", "versions": [{"version": "v1", "created": "Wed, 16 Oct 2019 10:46:57 GMT"}], "update_date": "2019-10-17", "authors_parsed": [["Piermont", "Evan", ""]]}, {"id": "1910.07278", "submitter": "Jorge Fandinno", "authors": "Emmanuelle-Anna Dietz Saldanha and Jorge Fandinno", "title": "On the Relation between Weak Completion Semantics and Answer Set\n  Semantics", "comments": "12th Workshop on Answer Set Programming and Other Computing\n  Paradigms, Philadelphia, PA (USA)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Weak Completion Semantics (WCS) is a computational cognitive theory that\nhas shown to be successful in modeling episodes of human reasoning. As the WCS\nis a recently developed logic programming approach, this paper investigates the\ncorrespondence of the WCS with respect to the well-established Answer Set\nSemantics (ASP). The underlying three-valued logic of both semantics is\ndifferent and their models are evaluated with respect to different program\ntransformations. We first illustrate these differences by the formal\nrepresentation of some examples of a well-known psychological experiment, the\nsuppression task. After that, we will provide a translation from logic programs\nunderstood under the WCS into logic programs understood under the ASP. In\nparticular, we will show that logic programs under the WCS can be represented\nas logic programs under the ASP by means of a definition completion, where all\ndefined atoms in a program must be false when their definitions are false.\n", "versions": [{"version": "v1", "created": "Wed, 16 Oct 2019 10:54:46 GMT"}], "update_date": "2019-10-17", "authors_parsed": [["Saldanha", "Emmanuelle-Anna Dietz", ""], ["Fandinno", "Jorge", ""]]}, {"id": "1910.07298", "submitter": "Pavel Naumov", "authors": "Pavel Naumov and Yuan Yuan", "title": "Intelligence in Strategic Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.LO cs.MA math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The article considers strategies of coalitions that are based on intelligence\ninformation about moves of some of the other agents. The main technical result\nis a sound and complete logical system that describes the interplay between\ncoalition power modality with intelligence and distributed knowledge modality\nin games with imperfect information.\n", "versions": [{"version": "v1", "created": "Wed, 16 Oct 2019 11:42:50 GMT"}], "update_date": "2019-10-17", "authors_parsed": [["Naumov", "Pavel", ""], ["Yuan", "Yuan", ""]]}, {"id": "1910.07299", "submitter": "Pac\\^ome Perrotin", "authors": "K\\'evin Perrot, Pac\\^ome Perrotin and Sylvain Sen\\'e", "title": "On the complexity of acyclic modules in automata networks", "comments": "21 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modules were introduced as an extension of Boolean automata networks. They\nhave inputs which are used in the computation said modules perform, and can be\nused to wire modules with each other. In the present paper we extend this new\nformalism and study the specific case of acyclic modules. These modules prove\nto be well described in their limit behavior by functions called output\nfunctions. We provide other results that offer an upper bound on the number of\nattractors in an acyclic module when wired recursively into an automata\nnetwork, alongside a diversity of complexity results around the difficulty of\ndeciding the existence of cycles depending on the number of inputs and the size\nof said cycle.\n", "versions": [{"version": "v1", "created": "Wed, 16 Oct 2019 11:47:53 GMT"}, {"version": "v2", "created": "Fri, 18 Oct 2019 12:58:33 GMT"}, {"version": "v3", "created": "Sat, 8 Feb 2020 13:33:56 GMT"}, {"version": "v4", "created": "Tue, 11 Feb 2020 14:20:43 GMT"}], "update_date": "2020-02-12", "authors_parsed": [["Perrot", "K\u00e9vin", ""], ["Perrotin", "Pac\u00f4me", ""], ["Sen\u00e9", "Sylvain", ""]]}, {"id": "1910.07750", "submitter": "Sebastiaan Terwijn", "authors": "H. P. Barendregt and S. A. Terwijn", "title": "Partial combinatory algebra and generalized numberings", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Generalized numberings are an extension of Ershov's notion of numbering,\nbased on partial combinatory algebra (pca) instead of the natural numbers. We\nstudy various algebraic properties of generalized numberings, relating\nproperties of the numbering to properties of the pca. As in the lambda\ncalculus, extensionality is a key notion here.\n", "versions": [{"version": "v1", "created": "Thu, 17 Oct 2019 07:45:26 GMT"}, {"version": "v2", "created": "Tue, 12 Nov 2019 10:58:28 GMT"}, {"version": "v3", "created": "Wed, 29 Apr 2020 12:01:31 GMT"}], "update_date": "2020-04-30", "authors_parsed": [["Barendregt", "H. P.", ""], ["Terwijn", "S. A.", ""]]}, {"id": "1910.07910", "submitter": "Matthias Naaf", "authors": "Katrin M. Dannert, Erich Gr\\\"adel, Matthias Naaf, Val Tannen", "title": "Generalized Absorptive Polynomials and Provenance Semantics for\n  Fixed-Point Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB math.LO", "license": "http://creativecommons.org/publicdomain/zero/1.0/", "abstract": "  Semiring provenance is a successful approach to provide detailed information\non the combinations of atomic facts that are responsible for the result of a\nquery. In particular, interpretations in general provenance semirings of\npolynomials or formal power series give precise descriptions of the successful\nevaluation strategies for the query. While provenance analysis in databases\nhas, for a long time, been largely confined to negation-free query languages, a\nrecent approach extends this to model checking problems for logics with full\nnegation. Algebraically this relies on new quotient semirings of\ndual-indeterminate polynomials or power series. So far, this approach has been\ndeveloped mainly for first-order logic and for the positive fragment of least\nfixed-point logic. What has remained open is an adequate treatment for\nfixed-point calculi that admit arbitrary interleavings of least and greatest\nfixed points. We show that an adequate framework for the provenance analysis of\nfull fixed-point logics is provided by semirings that are (1) fully continuous,\n(2) absorptive, and (3) chain-positive. Full continuity guarantees that\nprovenance values of least and greatest fixed-points are well-defined.\nAbsorptive semirings provide a symmetry between least and greatest fixed-point\ncomputations and make sure that provenance values of greatest fixed points are\ninformative. Finally, chain-positivity is responsible for having\ntruth-preserving interpretations, which give non-zero values to all true\nformulae. We further identify semirings of generalized absorptive polynomials\nand prove universal properties that make them the most general appropriate\nsemirings for LFP. We illustrate the power of provenance interpretations in\nthese semirings by relating them to provenance values of plays and strategies\nin the associated model-checking games.\n", "versions": [{"version": "v1", "created": "Thu, 17 Oct 2019 13:44:37 GMT"}, {"version": "v2", "created": "Thu, 6 Feb 2020 15:55:33 GMT"}, {"version": "v3", "created": "Fri, 10 Jul 2020 10:11:57 GMT"}], "update_date": "2020-07-13", "authors_parsed": [["Dannert", "Katrin M.", ""], ["Gr\u00e4del", "Erich", ""], ["Naaf", "Matthias", ""], ["Tannen", "Val", ""]]}, {"id": "1910.07936", "submitter": "Giulio Guerrieri", "authors": "Giulio Guerrieri (1), Luc Pellissier (2), Lorenzo Tortora de Falco (3)\n  ((1) University of Bath, Department of Computer Science, (2) Universit\\'e de\n  Paris, IRIF, (3) Universit\\`a Roma Tre, Dipartimento di Matematica e Fisica)", "title": "Glueability of resource proof-structures: inverting the Taylor expansion\n  (long version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A Multiplicative-Exponential Linear Logic (MELL) proof-structure can be\nexpanded into a set of resource proof-structures: its Taylor expansion. We\nintroduce a new criterion characterizing those sets of resource\nproof-structures that are part of the Taylor expansion of some MELL\nproof-structure, through a rewriting system acting both on resource and MELL\nproof-structures.\n", "versions": [{"version": "v1", "created": "Thu, 17 Oct 2019 14:26:06 GMT"}], "update_date": "2019-10-18", "authors_parsed": [["Guerrieri", "Giulio", ""], ["Pellissier", "Luc", ""], ["de Falco", "Lorenzo Tortora", ""]]}, {"id": "1910.08416", "submitter": "Narciso Mart\\'i-Oliet", "authors": "Francisco Dur\\'an, Steven Eker, Santiago Escobar, Narciso\n  Mart\\'i-Oliet, Jos\\'e Meseguer, Rub\\'en Rubio, Carolyn Talcott", "title": "Programming and Symbolic Computation in Maude", "comments": "Journal of Logical and Algebraic Methods in Programming, 2019", "journal-ref": null, "doi": "10.1016/j.jlamp.2019.100497", "report-no": null, "categories": "cs.LO cs.PL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Rewriting logic is both a flexible semantic framework within which widely\ndifferent concurrent systems can be naturally specified and a logical framework\nin which widely different logics can be specified. Maude programs are exactly\nrewrite theories. Maude has also a formal environment of verification tools.\nSymbolic computation is a powerful technique for reasoning about the\ncorrectness of concurrent systems and for increasing the power of formal tools.\nWe present several new symbolic features of Maude that enhance formal reasoning\nabout Maude programs and the effectiveness of formal tools. They include: (i)\nvery general unification modulo user-definable equational theories, and (ii)\nsymbolic reachability analysis of concurrent systems using narrowing. The paper\ndoes not focus just on symbolic features: it also describes several other new\nMaude features, including: (iii) Maude's strategy language for controlling\nrewriting, and (iv) external objects that allow flexible interaction of Maude\nobject-based concurrent systems with the external world. In particular,\nmeta-interpreters are external objects encapsulating Maude interpreters that\ncan interact with many other objects. To make the paper self-contained and give\na reasonably complete language overview, we also review the basic Maude\nfeatures for equational rewriting and rewriting with rules, Maude programming\nof concurrent object systems, and reflection. Furthermore, we include many\nexamples illustrating all the Maude notions and features described in the\npaper.\n", "versions": [{"version": "v1", "created": "Fri, 18 Oct 2019 13:38:57 GMT"}], "update_date": "2019-10-21", "authors_parsed": [["Dur\u00e1n", "Francisco", ""], ["Eker", "Steven", ""], ["Escobar", "Santiago", ""], ["Mart\u00ed-Oliet", "Narciso", ""], ["Meseguer", "Jos\u00e9", ""], ["Rubio", "Rub\u00e9n", ""], ["Talcott", "Carolyn", ""]]}, {"id": "1910.08503", "submitter": "Anupam Das", "authors": "Sam Buss, Anupam Das and Alexander Knop", "title": "Proof complexity of systems of (non-deterministic) decision trees and\n  branching programs", "comments": "36 pages, 1 figure, full version of CSL 2020 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies propositional proof systems in which lines are sequents of\ndecision trees or branching programs - deterministic and nondeterministic. The\nsystems LDT and LNDT are propositional proof systems in which lines represent\ndeterministic or non-deterministic decision trees. Branching programs are\nmodeled as decision dags. Adding extension to LDT and LNDT gives systems eLDT\nand eLNDT in which lines represent deterministic and non-deterministic\nbranching programs, respectively.\n  Deterministic and non-deterministic branching programs correspond to\nlog-space (L) and nondeterministic log-space (NL). Thus the systems eLDT and\neLNDT are propositional proof systems that reason with (nonuniform) L and NL\nproperties.\n  The main results of the paper are simulation and non-simulation results for\ntree-like and dag-like proofs in the systems LDT, LNDT, eLDT, and eLNDT. These\nsystems are also compared with Frege systems, constantdepth Frege systems and\nextended Frege systems\n", "versions": [{"version": "v1", "created": "Fri, 18 Oct 2019 16:54:33 GMT"}], "update_date": "2019-10-21", "authors_parsed": [["Buss", "Sam", ""], ["Das", "Anupam", ""], ["Knop", "Alexander", ""]]}, {"id": "1910.08571", "submitter": "Titus Dose", "authors": "Titus Dose", "title": "$\\mathrm{P}$-Optimal Proof Systems for Each $\\mathrm{coNP}$-Complete Set\n  and no Complete Problems in $\\mathrm{NP}\\cap\\mathrm{coNP}$ Relative to an\n  Oracle", "comments": "arXiv admin note: substantial text overlap with arXiv:1904.06175,\n  arXiv:1909.02839", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We build on a working program initiated by Pudl\\'ak [Pud17] and construct an\noracle relative to which each $\\mathrm{coNP}$-complete set has\n$\\mathrm{P}$-optimal proof systems and $\\mathrm{NP}\\cap\\mathrm{coNP}$ does not\nhave complete problems.\n", "versions": [{"version": "v1", "created": "Fri, 18 Oct 2019 18:06:19 GMT"}, {"version": "v2", "created": "Thu, 9 Jan 2020 15:30:25 GMT"}], "update_date": "2020-01-10", "authors_parsed": [["Dose", "Titus", ""]]}, {"id": "1910.08647", "submitter": "Pavel Naumov", "authors": "Pavel Naumov and Jia Tao", "title": "Blameworthiness in Security Games", "comments": "34th AAAI Conference on Artificial Intelligence (AAAI-20), February\n  7-12, 2020, New York, New York, USA", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.GT cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Security games are an example of a successful real-world application of game\ntheory. The paper defines blameworthiness of the defender and the attacker in\nsecurity games using the principle of alternative possibilities and provides a\nsound and complete logical system for reasoning about blameworthiness in such\ngames. Two of the axioms of this system capture the asymmetry of information in\nsecurity games.\n", "versions": [{"version": "v1", "created": "Fri, 18 Oct 2019 22:22:35 GMT"}, {"version": "v2", "created": "Mon, 11 Nov 2019 20:50:51 GMT"}], "update_date": "2019-11-13", "authors_parsed": [["Naumov", "Pavel", ""], ["Tao", "Jia", ""]]}, {"id": "1910.08712", "submitter": "EPTCS", "authors": "Dale Miller (Inria-Saclay and LIX Ecole Polytechnique, France), Ivan\n  Scagnetto (University of Udine, Italy)", "title": "Proceedings of the Fourteenth Workshop on Logical Frameworks and\n  Meta-Languages: Theory and Practice", "comments": null, "journal-ref": "EPTCS 307, 2019", "doi": "10.4204/EPTCS.307", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains a selection of papers presented at LFMTP 2019, the 14th\nInternational Workshop on Logical Frameworks and Meta-Languages: Theory and\nPractice (LFMTP), held on June 22, 2019, in Vancouver, Canada. The workshop was\naffiliated with the Thirty-Fourth Annual ACM/IEEE Symposium on Logic in\nComputer Science (LICS).\n  Logical frameworks and meta-languages form a common substrate for\nrepresenting, implementing and reasoning about a wide variety of deductive\nsystems of interest in logic and computer science. Their design, implementation\nand their use in reasoning tasks, ranging from the correctness of software to\nthe properties of formal systems, have been the focus of considerable research\nover the last two decades. This workshop will bring together designers,\nimplementors and practitioners to discuss various aspects impinging on the\nstructure and utility of logical frameworks, including the treatment of\nvariable binding, inductive and co-inductive reasoning techniques and the\nexpressiveness and lucidity of the reasoning process.\n", "versions": [{"version": "v1", "created": "Sat, 19 Oct 2019 06:46:14 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Miller", "Dale", "", "Inria-Saclay and LIX Ecole Polytechnique, France"], ["Scagnetto", "Ivan", "", "University of Udine, Italy"]]}, {"id": "1910.08875", "submitter": "Yassmeen Elderhalli", "authors": "Yassmeen Elderhalli, Osman Hasan and Sofiene Tahar", "title": "Integrating DFT and DRBD Formalizations in HOL4", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dynamic Fault Trees (DFT) and Dynamic Reliability Block Diagrams (DRBD) are\ntwo modeling approaches that capture the dynamic failure behavior of\nengineering systems for their reliability analysis. Recently, two independent\nhigher-order logic (HOL) formalizations of DFT and DRBD algebras have been\ndeveloped in the HOL4 theorem prover. In this work, we propose to integrate\nthese two modeling approaches for the efficient formal reliability analysis of\ncomplex systems by leveraging upon the advantages of each method. The soundness\nof this integration is provided through a formal proof of equivalence between\nthe DFT and DRBD algebras. We show the efficiency of the proposed integrated\nformal reliability analysis on a drive-by-wire system as a case study.\n", "versions": [{"version": "v1", "created": "Sun, 20 Oct 2019 02:15:04 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Elderhalli", "Yassmeen", ""], ["Hasan", "Osman", ""], ["Tahar", "Sofiene", ""]]}, {"id": "1910.08943", "submitter": "Uli Fahrenberg", "authors": "Uli Fahrenberg, Axel Legay, Karin Quaas", "title": "Computing Branching Distances Using Quantitative Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We lay out a general method for computing branching distances between labeled\ntransition systems. We translate the quantitative games used for defining these\ndistances to other, path-building games which are amenable to methods from the\ntheory of quantitative games. We then show for all common types of branching\ndistances how the resulting path-building games can be solved. In the end, we\nachieve a method which can be used to compute all branching distances in the\nlinear-time--branching-time spectrum.\n", "versions": [{"version": "v1", "created": "Sun, 20 Oct 2019 10:13:34 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Fahrenberg", "Uli", ""], ["Legay", "Axel", ""], ["Quaas", "Karin", ""]]}, {"id": "1910.08955", "submitter": "Christoph Benzm\\\"uller", "authors": "Christoph Benzm\\\"uller and David Fuenmayor", "title": "Computer-supported Analysis of Positive Properties, Ultrafilters and\n  Modal Collapse in Variants of G\\\"odel's Ontological Argument", "comments": "21 pages, 6 figures; to appear in the Bulletin of the Section of\n  Logic", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.CL math.GN math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Three variants of Kurt G\\\"odel's ontological argument, proposed by Dana\nScott, C. Anthony Anderson and Melvin Fitting, are encoded and rigorously\nassessed on the computer. In contrast to Scott's version of G\\\"odel's argument\nthe two variants contributed by Anderson and Fitting avoid modal collapse.\nAlthough they appear quite different on a cursory reading they are in fact\nclosely related. This has been revealed in the computer-supported formal\nanalysis presented in this article. Key to our formal analysis is the\nutilization of suitably adapted notions of (modal) ultrafilters, and a careful\ndistinction between extensions and intensions of positive properties.\n", "versions": [{"version": "v1", "created": "Sun, 20 Oct 2019 11:54:05 GMT"}, {"version": "v2", "created": "Mon, 13 Jan 2020 12:32:15 GMT"}], "update_date": "2020-01-14", "authors_parsed": [["Benzm\u00fcller", "Christoph", ""], ["Fuenmayor", "David", ""]]}, {"id": "1910.08992", "submitter": "Lars Luthmann M.Sc.", "authors": "Lars Luthmann (1), Hendrik G\\\"ottmann (1), Isabelle Bacher (1), Malte\n  Lochau (2) ((1) Real-Time Systems Lab, TU Darmstadt, (2) Model-based\n  Engineering Group, University of Siegen)", "title": "Checking Timed Bisimulation with Bounded Zone-History Graphs --\n  Technical Report", "comments": "23 pages, 7 figures, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Timed automata (TA) are a well-established formalism for specifying\ndiscrete-state/continuous-time behavior of time-critical reactive systems.\nConcerning the fundamental analysis problem of comparing a candidate\nimplementation against a specification, both given as TA, it has been shown\nthat timed trace equivalence is undecidable, whereas timed bisimulation\nequivalence is decidable. The corresponding proof utilizes region graphs, a\nfinite, but generally very space-consuming characterization of TA semantics.\nHence, most practical TA tools utilize zone graphs instead, a symbolic and\ngenerally more efficient representation of TA semantics, to automate analysis\ntasks. However, zone graphs only produce sound results for analysis tasks being\nreducible to plain reachability problems thus being too imprecise for checking\ntimed bisimilarity. In this paper, we propose bounded zone-history graphs, a\nnovel characterization of TA semantics facilitating an adjustable trade-off\nbetween precision and scalability of timed-bisimilarity checking. Our tool\nTimBrCheck is, to the best of our knowledge, the only currently available tool\nfor effectively checking timed bisimilarity and even supports non-deterministic\nTA with silent moves. We further present experimental results gained from\napplying our tool to a collection of community benchmarks, providing insights\ninto trade-offs between precision and efficiency, depending on the bound value.\n", "versions": [{"version": "v1", "created": "Sun, 20 Oct 2019 14:33:42 GMT"}, {"version": "v2", "created": "Fri, 25 Oct 2019 14:56:51 GMT"}, {"version": "v3", "created": "Wed, 16 Sep 2020 16:19:32 GMT"}], "update_date": "2020-09-17", "authors_parsed": [["Luthmann", "Lars", ""], ["G\u00f6ttmann", "Hendrik", ""], ["Bacher", "Isabelle", ""], ["Lochau", "Malte", ""]]}, {"id": "1910.09068", "submitter": "Alexander Weigl", "authors": "Alexander Weigl and Mattias Ulbrich and Suhyun Cha and Bernhard\n  Beckert and Birgit Vogel-Heuser", "title": "Relational Test Tables: A Practical Specification Language for Evolution\n  and Security", "comments": null, "journal-ref": null, "doi": "10.5445/IR/1000099122", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A wide range of interesting program properties are intrinsically relational,\ni.e., they relate two or more program traces. Two prominent relational\nproperties are secure information flow and conditional program equivalence. By\nshowing the absence of illegal information flow, confidentiality and integrity\nproperties can be proved. Equivalence proofs allow using an existing (trusted)\nsoftware release as specification for new revisions. Currently, the\nverification of relational properties is hardly accessible to practitioners due\nto the lack of appropriate relational specification languages. In previous\nwork, we introduced the concept of generalised test tables: a table-based\nspecification language for functional (non-relational) properties of reactive\nsystems. In this paper, we present relational test tables -- a canonical\nextension of generalised test tables for the specification of relational\nproperties, which refer to two or more program runs or traces. Regression test\ntables support asynchronous program runs via stuttering. We show the\napplicability of relational test tables, using them for the specification and\nverification of two examples from the domain of automated product systems.\n", "versions": [{"version": "v1", "created": "Sun, 20 Oct 2019 21:42:09 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Weigl", "Alexander", ""], ["Ulbrich", "Mattias", ""], ["Cha", "Suhyun", ""], ["Beckert", "Bernhard", ""], ["Vogel-Heuser", "Birgit", ""]]}, {"id": "1910.09072", "submitter": "Taylor Dohmen", "authors": "Vrunda Dave, Taylor Dohmen, Shankara Narayana Krishna, Ashutosh\n  Trivedi", "title": "Regular Model Checking with Regular Relations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Regular model checking is an exploration technique for infinite state systems\nwhere state spaces are represented as regular languages and transition\nrelations are expressed using rational relations over infinite (or finite)\nstrings. We extend the regular model checking paradigm to permit the use of\nmore powerful transition relations: the class of regular relations, of which\nthe rational relations are a strict subset. We use the language of monadic\nsecond-order logic on infinite strings to specify such relations and adopt\nstreaming string transducers (SSTs) as a suitable computational model. We\nintroduce nondeterministic SSTs over infinite strings and show that they\nprecisely capture the relations definable in MSO. We further explore\ntheoretical properties of omega-NSSTs required to effectively carry out regular\nmodel checking. In particular, we establish that the regular type checking\nproblem for omega-NSSTs is decidable in PSPACE. Since the post-image of a\nregular language under a regular relation may not be regular (or even\ncontext-free), approaches that iteratively compute the image can not be\neffectively carried out in this setting. Instead, we utilize the fact that\nregular relations are closed under composition, which, together with our\ndecidability result, provides a foundation for regular model checking with\nregular relations.\n", "versions": [{"version": "v1", "created": "Sun, 20 Oct 2019 22:11:23 GMT"}, {"version": "v2", "created": "Mon, 12 Jul 2021 02:03:08 GMT"}], "update_date": "2021-07-13", "authors_parsed": [["Dave", "Vrunda", ""], ["Dohmen", "Taylor", ""], ["Krishna", "Shankara Narayana", ""], ["Trivedi", "Ashutosh", ""]]}, {"id": "1910.09118", "submitter": "Maximiliano Cristia", "authors": "Maximiliano Cristi\\'a and Gianfranco Rossi", "title": "Automated Reasoning with Restricted Intensional Sets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/publicdomain/zero/1.0/", "abstract": "  Intensional sets, i.e., sets given by a property rather than by enumerating\nelements, are widely recognized as a key feature to describe complex problems\n(see, e.g., specification languages such as B and Z). Notwithstanding, very few\ntools exist supporting high-level automated reasoning on general formulas\ninvolving intensional sets. In this paper we present a decision procedure for a\nfirst-order logic language offering both extensional and (a restricted form of)\nintensional sets (RIS). RIS are introduced as first-class citizens of the\nlanguage and set-theoretical operators on RIS are dealt with as constraints.\nSyntactic restrictions on RIS guarantee that the denoted sets are finite,\nthough unbounded. The language of RIS, called L_RIS , is parametric with\nrespect to any first-order theory X providing at least equality and a decision\nprocedure for X-formulas. In particular, we consider the instance of L_RIS when\nX is the theory of hereditarily finite sets and binary relations. We also\npresent a working implementation of this instance as part of the {log} tool and\nwe show through a number of examples and two case studies that, although RIS\nare a subclass of general intensional sets, they are still sufficiently\nexpressive as to encode and solve many interesting problems. Finally, an\nextensive empirical evaluation provides evidence that the tool can be used in\npractice.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 02:27:31 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Cristi\u00e1", "Maximiliano", ""], ["Rossi", "Gianfranco", ""]]}, {"id": "1910.09162", "submitter": "Ambroise Lafont", "authors": "Ambroise Lafont", "title": "Signatures and models for syntax and operational semantics in the\n  presence of variable binding", "comments": "doctoral thesis", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This thesis deals with the specification and construction of syntax and\noperational semantics of a programming language. We work with a general notion\nof signature for specifying objects of a given category as initial objects in a\nsuitable category of models.This characterization, in the spirit of Initial\nSemantics, gives a justification of the recursion principle. Languages with\nvariable binding, such as the pure lambda calculus, are monads on the category\nof sets specified through the classical algebraic signatures. The first\nextensions to syntaxes with equations that we consider are quotients of these\nalgebraic signatures. They allow, for example, to specify a binary commutative\noperation. But some equations, such as associativity, seem to remain out of\nreach. We thus introduce the notion of 2-signature, consisting in two parts: a\nspecification of operations through a usual signature as before, and a set of\nequations among them. We identify the class of algebraic 2-signatures for which\nthe existence of the associated syntax is guaranteed. Finally, we takle the\nspecification of the operational semantics of a programming language such as\nlambda calculus with beta-reduction. To this end, we introduce the notion of\nreduction monad and their signatures, then we generalize them to get the notion\nof operational monad.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 06:13:19 GMT"}, {"version": "v2", "created": "Tue, 22 Oct 2019 13:55:24 GMT"}, {"version": "v3", "created": "Tue, 5 Nov 2019 07:26:29 GMT"}, {"version": "v4", "created": "Wed, 18 Dec 2019 09:07:22 GMT"}], "update_date": "2019-12-19", "authors_parsed": [["Lafont", "Ambroise", ""]]}, {"id": "1910.09254", "submitter": "Paulo Guilherme Santos", "authors": "Ant\\'onio Malheiro and Paulo Guilherme Santos", "title": "A Note on a Unifying Proof of the Undecidability of Several Diagrammatic\n  Properties of Term Rewriting Systems", "comments": "4 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this note we give a simple unifying proof of the undecidability of several\ndiagrammatic properties of term rewriting systems that include: local\nconfluence, strong confluence, diamond property, subcommutative property, and\nthe existence of successor. The idea is to code configurations of Turing\nMachines into terms, and then define a suitable relation on those terms such\nthat the termination of the Turing Machine becomes equivalent to the\nsatisfiability of the diagrammatic property.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 10:19:26 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Malheiro", "Ant\u00f3nio", ""], ["Santos", "Paulo Guilherme", ""]]}, {"id": "1910.09258", "submitter": "Sebastiaan Terwijn", "authors": "S. A. Terwijn", "title": "Computability in partial combinatory algebras", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove a number of elementary facts about computability in partial\ncombinatory algebras (pca's). We disprove a suggestion made by Kreisel about\nusing Friedberg numberings to construct extensional pca's. We then discuss\nseparability and elements without total extensions. We relate this to Ershov's\nnotion of precompleteness, and we show that precomplete numberings are not 1-1\nin general.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 10:30:45 GMT"}, {"version": "v2", "created": "Tue, 5 Nov 2019 09:22:36 GMT"}, {"version": "v3", "created": "Wed, 5 Feb 2020 12:24:00 GMT"}], "update_date": "2020-02-06", "authors_parsed": [["Terwijn", "S. A.", ""]]}, {"id": "1910.09326", "submitter": "Alexander Chunikhin", "authors": "Alexander Yu. Chunikhin", "title": "On Concept of Creative Petri Nets", "comments": "8 pages", "journal-ref": null, "doi": null, "report-no": "PIBNASU-2019/10-2", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A new formalism of Petri nets, based on the adoption of the\n\"position-arc-transition\" triad and \"transition-arc-position\" triad as\nstructure-forming units is introduced. In accordance with the Fusion principle,\nan analytical representation of Petri nets is developed. We propose the concept\nof Creative Petri Nets, which allows to implement structural changes in Petri\nnet by procreation/deletion of structural units or complexes.\n", "versions": [{"version": "v1", "created": "Thu, 17 Oct 2019 17:06:01 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Chunikhin", "Alexander Yu.", ""]]}, {"id": "1910.09327", "submitter": "Michele Chiari", "authors": "Michele Chiari, Dino Mandrioli and Matteo Pradella", "title": "POTL: A First-Order Complete Temporal Logic for Operator Precedence\n  Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The problem of model checking procedural programs has fostered much research\ntowards the definition of temporal logics for reasoning on context-free\nstructures. The most notable of such results are temporal logics on Nested\nWords, such as CaRet and NWTL. Recently, the logic OPTL was introduced, based\non the class of Operator Precedence Languages (OPL), more powerful than Nested\nWords. We define the new OPL-based logic POTL, prove its FO-completeness, and\nprovide a model checking procedure for it. POTL improves on NWTL by enabling\nthe formulation of requirements involving pre/post-conditions, stack\ninspection, and others in the presence of exception-like constructs. It\nimproves on OPTL by being FO-complete, and by expressing more easily stack\ninspection and function-local properties.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 12:59:01 GMT"}, {"version": "v2", "created": "Sat, 31 Oct 2020 15:14:56 GMT"}], "update_date": "2020-11-03", "authors_parsed": [["Chiari", "Michele", ""], ["Mandrioli", "Dino", ""], ["Pradella", "Matteo", ""]]}, {"id": "1910.09336", "submitter": "Robert Y. Lewis", "authors": "The mathlib Community", "title": "The Lean mathematical library", "comments": null, "journal-ref": null, "doi": "10.1145/3372885.3373824", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes mathlib, a community-driven effort to build a unified\nlibrary of mathematics formalized in the Lean proof assistant. Among proof\nassistant libraries, it is distinguished by its dependently typed foundations,\nfocus on classical mathematics, extensive hierarchy of structures, use of\nlarge- and small-scale automation, and distributed organization. We explain the\narchitecture and design decisions of the library and the social organization\nthat has led us here.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 13:08:24 GMT"}, {"version": "v2", "created": "Mon, 16 Dec 2019 20:37:52 GMT"}], "update_date": "2020-01-28", "authors_parsed": [["Community", "The mathlib", ""]]}, {"id": "1910.09339", "submitter": "Samuel Huang", "authors": "Samuel Huang, Rance Cleaveland", "title": "A Tableau Construction for Finite Linear-Time Temporal Logic", "comments": "29 pages, 2 tables 1 figure, 8 page appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes a method for converting formulas in finite propositional\nlinear-time temporal logic (Finite LTL) into finite-state automata whose\nlanguages are the models of the given formula. Finite LTL differs from\ntraditional LTL in that formulas are interpreted with respect to finite, rather\nthan infinite, sequences of states; this fact means that traditional\nfinite-state automata, rather than {\\omega}-automata such as those developed by\nB\\\"uchi and others, suffice for recognizing models of such formulas. The\napproach considered is based on well-known tableau-construction techniques\ndeveloped for LTL, which we adapt here for the setting of Finite LTL. The\nresulting automata may be used as a basis for model checking, satisfiability\ntesting, and model synthesis.\n", "versions": [{"version": "v1", "created": "Wed, 16 Oct 2019 16:33:02 GMT"}, {"version": "v2", "created": "Mon, 22 Jun 2020 01:03:35 GMT"}], "update_date": "2020-06-23", "authors_parsed": [["Huang", "Samuel", ""], ["Cleaveland", "Rance", ""]]}, {"id": "1910.09401", "submitter": "Stefan Milius", "authors": "Ji\\v{r}\\'i Ad\\'amek and Stefan Milius and Lawrence S. Moss", "title": "On Well-Founded and Recursive Coalgebras", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies fundamental questions concerning category-theoretic models\nof induction and recursion. We are concerned with the relationship between\nwell-founded and recursive coalgebras for an endofunctor. For monomorphism\npreserving endofunctors on complete and well-powered categories every coalgebra\nhas a well-founded part, and we provide a new, shorter proof that this is the\ncoreflection in the category of all well-founded coalgebras. We present a new\nmore general proof of Taylor's General Recursion Theorem that every\nwell-founded coalgebra is recursive, and we study under which hypothesis the\nconverse holds. In addition, we present a new equivalent characterization of\nwell-foundedness: a coalgebra is well-founded iff it admits a\ncoalgebra-to-algebra morphism to the initial algebra.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 14:23:47 GMT"}, {"version": "v2", "created": "Sun, 16 Feb 2020 15:18:26 GMT"}], "update_date": "2020-02-18", "authors_parsed": [["Ad\u00e1mek", "Ji\u0159\u00ed", ""], ["Milius", "Stefan", ""], ["Moss", "Lawrence S.", ""]]}, {"id": "1910.09472", "submitter": "Giorgio Terracina", "authors": "Francesco Calimeri, Francesco Cauteruccio, Luca Cinelli, Aldo\n  Marzullo, Claudio Stamile, Giorgio Terracina, Francoise Durand-Dubief,\n  Dominique Sappey-Marinier", "title": "A Logic-Based Framework Leveraging Neural Networks for Studying the\n  Evolution of Neurological Disorders", "comments": "Under consideration in Theory and Practice of Logic Programming\n  (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deductive formalisms have been strongly developed in recent years; among\nthem, Answer Set Programming (ASP) gained some momentum, and has been lately\nfruitfully employed in many real-world scenarios. Nonetheless, in spite of a\nlarge number of success stories in relevant application areas, and even in\nindustrial contexts, deductive reasoning cannot be considered the ultimate,\ncomprehensive solution to AI; indeed, in several contexts, other approaches\nresult to be more useful. Typical Bioinformatics tasks, for instance\nclassification, are currently carried out mostly by Machine Learning (ML) based\nsolutions. In this paper, we focus on the relatively new problem of analyzing\nthe evolution of neurological disorders. In this context, ML approaches already\ndemonstrated to be a viable solution for classification tasks; here, we show\nhow ASP can play a relevant role in the brain evolution simulation task. In\nparticular, we propose a general and extensible framework to support physicians\nand researchers at understanding the complex mechanisms underlying neurological\ndisorders. The framework relies on a combined use of ML and ASP, and is general\nenough to be applied in several other application scenarios, which are outlined\nin the paper.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 16:01:48 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Calimeri", "Francesco", ""], ["Cauteruccio", "Francesco", ""], ["Cinelli", "Luca", ""], ["Marzullo", "Aldo", ""], ["Stamile", "Claudio", ""], ["Terracina", "Giorgio", ""], ["Durand-Dubief", "Francoise", ""], ["Sappey-Marinier", "Dominique", ""]]}, {"id": "1910.09633", "submitter": "Vladimir Zamdzhiev", "authors": "Romain P\\'echoux, Simon Perdrix, Mathys Rennela, Vladimir Zamdzhiev", "title": "Quantum Programming with Inductive Datatypes: Causality and Affine Type\n  Theory", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-45231-5_29", "report-no": null, "categories": "cs.LO cs.PL math.CT quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Inductive datatypes in programming languages allow users to define useful\ndata structures such as natural numbers, lists, trees, and others. In this\npaper we show how inductive datatypes may be added to the quantum programming\nlanguage QPL. We construct a sound categorical model for the language and by\ndoing so we provide the first detailed semantic treatment of user-defined\ninductive datatypes in quantum programming. We also show our denotational\ninterpretation is invariant with respect to big-step reduction, thereby\nestablishing another novel result for quantum programming. Compared to\nclassical programming, this property is considerably more difficult to prove\nand we demonstrate its usefulness by showing how it immediately implies\ncomputational adequacy at all types. To further cement our results, our\nsemantics is entirely based on a physically natural model of von Neumann\nalgebras, which are mathematical structures used by physicists to study quantum\nmechanics.\n", "versions": [{"version": "v1", "created": "Mon, 21 Oct 2019 20:12:43 GMT"}], "update_date": "2021-03-19", "authors_parsed": [["P\u00e9choux", "Romain", ""], ["Perdrix", "Simon", ""], ["Rennela", "Mathys", ""], ["Zamdzhiev", "Vladimir", ""]]}, {"id": "1910.09744", "submitter": "Umang Mathur", "authors": "Paul Krogmeier, Umang Mathur, Adithya Murali, P. Madhusudan, Mahesh\n  Viswanathan", "title": "Decidable Synthesis of Programs with Uninterpreted Functions", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-030-53291-8_32", "report-no": null, "categories": "cs.PL cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We identify a decidable synthesis problem for a class of programs of\nunbounded size with conditionals and iteration that work over infinite data\ndomains. The programs in our class use uninterpreted functions and relations,\nand abide by a restriction called coherence that was recently identified to\nyield decidable verification. We formulate a powerful grammar-restricted\n(syntax-guided) synthesis problem for coherent uninterpreted programs, and we\nshow the problem to be decidable, identify its precise complexity, and also\nstudy several variants of the problem.\n", "versions": [{"version": "v1", "created": "Tue, 22 Oct 2019 03:06:11 GMT"}, {"version": "v2", "created": "Wed, 22 Jul 2020 21:36:15 GMT"}], "update_date": "2020-07-24", "authors_parsed": [["Krogmeier", "Paul", ""], ["Mathur", "Umang", ""], ["Murali", "Adithya", ""], ["Madhusudan", "P.", ""], ["Viswanathan", "Mahesh", ""]]}, {"id": "1910.09829", "submitter": "Thomas Neele", "authors": "Thomas Neele and Antti Valmari and Tim A.C. Willemse", "title": "The Inconsistent Labelling Problem of Stutter-Preserving Partial-Order\n  Reduction", "comments": null, "journal-ref": "FoSSaCS 2020, vol. 12077 of LNCS, pp. 482-501", "doi": "10.1007/978-3-030-45231-5_25", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In model checking, partial-order reduction (POR) is an effective technique to\nreduce the size of the state space. Stubborn sets are an established variant of\nPOR and have seen many applications over the past 31 years. One of the early\nworks on stubborn sets shows that a combination of several conditions on the\nreduction is sufficient to preserve stutter trace equivalence, making stubborn\nsets suitable for model checking of linear-time properties. In this paper, we\nidentify a flaw in the reasoning and show with a counter-example that stutter\ntrace equivalence is not necessarily preserved. We propose a solution together\nwith an updated correctness proof. Furthermore, we analyse in which formalisms\nthis problem may occur. The impact on practical implementations is limited,\nsince they all compute a correct approximation of the theory.\n", "versions": [{"version": "v1", "created": "Tue, 22 Oct 2019 08:29:12 GMT"}, {"version": "v2", "created": "Sat, 2 Nov 2019 14:27:33 GMT"}], "update_date": "2020-04-29", "authors_parsed": [["Neele", "Thomas", ""], ["Valmari", "Antti", ""], ["Willemse", "Tim A. C.", ""]]}, {"id": "1910.10176", "submitter": "Rene Haberland", "authors": "Ren\\'e Haberland", "title": "Review of Recent Techniques on Heap Specification and Verification", "comments": "preprint/draft/short version (6 pages in English); final journal\n  paper 26 pages (full paper in Russian)", "journal-ref": "Computer Tools in Education Journal, ISSN 2071-2359, ISSN\n  2071-2340", "doi": "10.32603/2071-2340-2019-2-5-30", "report-no": null, "categories": "cs.LO cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This review article provides an overview of recent approaches and techniques\nin specifying and verifying dynamic memory with class objects. Dynamic memory\nverification may be used in order to show, for instance, the absence of memory\nleaks or the validity of memory access.\n", "versions": [{"version": "v1", "created": "Tue, 22 Oct 2019 18:01:33 GMT"}], "update_date": "2019-10-24", "authors_parsed": [["Haberland", "Ren\u00e9", ""]]}, {"id": "1910.10346", "submitter": "Yanhong Annie Liu", "authors": "Yanhong A. Liu and Scott D. Stoller", "title": "Knowledge of Uncertain Worlds: Programming with Logical Constraints", "comments": null, "journal-ref": "Journal of Logic and Computation. 2021", "doi": "10.1093/logcom/exaa077", "report-no": null, "categories": "cs.LO cs.AI cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Programming with logic for sophisticated applications must deal with\nrecursion and negation, which together have created significant challenges in\nlogic, leading to many different, conflicting semantics of rules. This paper\ndescribes a unified language, DA logic, for design and analysis logic, based on\nthe unifying founded semantics and constraint semantics, that support the power\nand ease of programming with different intended semantics. The key idea is to\nprovide meta-constraints, supports the use of uncertain information in the form\nof either undefined values or possible combinations of values or both, and\npromote the use of knowledge units that can be instantiated by any new\npredicates, including predicates with additional arguments.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2019 04:30:51 GMT"}, {"version": "v2", "created": "Sat, 27 Jun 2020 03:49:52 GMT"}, {"version": "v3", "created": "Fri, 11 Dec 2020 03:44:58 GMT"}], "update_date": "2020-12-25", "authors_parsed": [["Liu", "Yanhong A.", ""], ["Stoller", "Scott D.", ""]]}, {"id": "1910.10507", "submitter": "Ra\\'ul E. Monti", "authors": "Raul E. Monti and Pedro R. D'Argenio and Carlos E. Budde", "title": "A compositional semantics for Repairable Fault Trees with general\n  distributions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Fault Tree Analysis (FTA) is a prominent technique in industrial and\nscientific risk assessment. Repairable Fault Trees (RFT) enhance the classical\nFault Tree (FT) model by introducing the possibility to describe complex\ndependent repairs of system components. Usual frameworks for analyzing FTs such\nas BDD, SBDD, and Markov chains fail to assess the desired properties over RFT\ncomplex models, either because these become too large, or due to cyclic\nbehaviour introduced by dependent repairs. Simulation is another way to carry\nout this kind of analysis. In this paper we review the RFT model with Repair\nBoxes as introduced by Daniele Codetta-Raiteri. We present compositional\nsemantics for this model in terms of Input/Output Stochastic Automata, which\nallows for the modelling of events occurring according to general continuous\ndistribution. Moreover, we prove that the semantics generates (weakly)\ndeterministic models, hence suitable for discrete event simulation, and\nprominently for Rare Event Simulation using the FIG tool.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2019 12:05:25 GMT"}], "update_date": "2019-10-24", "authors_parsed": [["Monti", "Raul E.", ""], ["D'Argenio", "Pedro R.", ""], ["Budde", "Carlos E.", ""]]}, {"id": "1910.10546", "submitter": "Christoph Ohrem", "authors": "Jens Oliver Gutsfeld, Markus M\\\"uller-Olm, Christoph Ohrem", "title": "Propositional Dynamic Logic for Hyperproperties", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Information security properties of reactive systems like non-interference\noften require relating different executions of the system to each other and\nfollowing them simultaneously. Such hyperproperties can also be useful in other\ncontexts, e.g., when analysing properties of distributed systems like\nlinearizability. Since common logics like LTL, CTL, or the modal mu-calculus\ncannot express hyperproperties, the hyperlogics HyperLTL and HyperCTL* were\ndeveloped to cure this defect. However, these logics are not able to express\narbitrary omega-regular properties. In this paper, we introduce HyperPDL-Delta,\nan adaptation of the Propositional Dynamic Logic of Fischer and Ladner for\nhyperproperties, in order to remove this limitation. Using an elegant\nautomata-theoretic framework, we show that HyperPDL-Delta model checking is\nasymptotically not more expensive than HyperCTL* model checking, despite its\nvastly increased expressive power. We further investigate fragments of\nHyperPDL-Delta with regard to satisfiability checking.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2019 13:13:55 GMT"}, {"version": "v2", "created": "Fri, 17 Jul 2020 11:08:32 GMT"}], "update_date": "2020-07-20", "authors_parsed": [["Gutsfeld", "Jens Oliver", ""], ["M\u00fcller-Olm", "Markus", ""], ["Ohrem", "Christoph", ""]]}, {"id": "1910.10636", "submitter": "Florian Funke", "authors": "Florian Funke, Simon Jantsch, and Christel Baier", "title": "Farkas certificates and minimal witnesses for probabilistic reachability\n  constraints", "comments": "41 pages, 7 figures (including appendix), to appear in TACAS 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces Farkas certificates for lower and upper bounds on\nminimal and maximal reachability probabilities in Markov decision processes\n(MDP), which we derive using an MDP-variant of Farkas' Lemma. The set of all\nsuch certificates is shown to form a polytope whose points correspond to\nwitnessing subsystems of the model and the property. Using this correspondence\nwe can translate the problem of finding minimal witnesses to the problem of\nfinding vertices with a maximal number of zeros. While computing such vertices\nis computationally hard in general, we derive new heuristics from our\nformulations that exhibit competitive performance compared to state-of-the-art\ntechniques. As an argument that asymptotically better algorithms cannot be\nhoped for, we show that the decision version of finding minimal witnesses is\nNP-complete even for acyclic Markov chains.\n", "versions": [{"version": "v1", "created": "Wed, 23 Oct 2019 15:59:40 GMT"}, {"version": "v2", "created": "Wed, 5 Feb 2020 10:08:04 GMT"}], "update_date": "2020-02-06", "authors_parsed": [["Funke", "Florian", ""], ["Jantsch", "Simon", ""], ["Baier", "Christel", ""]]}, {"id": "1910.10703", "submitter": "Mario Carneiro", "authors": "Mario Carneiro", "title": "Metamath Zero: The Cartesian Theorem Prover", "comments": "34 pages, 4 figures, extended version of a paper submitted to CICM\n  2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As the usage of theorem prover technology expands, so too does the reliance\non correctness of the tools. Metamath Zero is a verification system that aims\nfor simplicity of logic and implementation, without compromising on efficiency\nof verification. It is formally specified in its own language, and supports a\nnumber of translations to and from other proof languages. This paper describes\nthe abstract logic of Metamath Zero, essentially a multi-sorted first order\nlogic, as well as the binary proof format and the way in which it can ensure\nessentially linear time verification while still being concise and efficient at\nscale. Metamath Zero currently holds the record for fastest verification of the\n$\\mathtt{set .mm}$ Metamath library of proofs in ZFC (including 71 of Wiedijk's\n100 formalization targets), at less than 200 ms. Ultimately, we intend to use\nit to verify the correctness of the implementation of the verifier down to\nbinary executable, so it can be used as a root of trust for more complex proof\nsystems.\n", "versions": [{"version": "v1", "created": "Tue, 22 Oct 2019 14:40:23 GMT"}, {"version": "v2", "created": "Fri, 25 Oct 2019 01:09:36 GMT"}, {"version": "v3", "created": "Mon, 30 Mar 2020 03:44:48 GMT"}], "update_date": "2020-03-31", "authors_parsed": [["Carneiro", "Mario", ""]]}, {"id": "1910.10848", "submitter": "EPTCS", "authors": "Fabio Alessi (Department of Mathematics, Computer Science and Physics\n  - University of Udine, Italy), Alberto Ciaffaglione (Department of\n  Mathematics, Computer Science and Physics - University of Udine, Italy),\n  Pietro Di Gianantonio (Department of Mathematics, Computer Science and\n  Physics - University of Udine, Italy), Furio Honsell (Department of\n  Mathematics, Computer Science and Physics - University of Udine, Italy),\n  Marina Lenisa (Department of Mathematics, Computer Science and Physics -\n  University of Udine, Italy)", "title": "A Definitional Implementation of the Lax Logical Framework LLFP in Coq,\n  for Supporting Fast and Loose Reasoning", "comments": "In Proceedings LFMTP 2019, arXiv:1910.08712", "journal-ref": "EPTCS 307, 2019, pp. 8-23", "doi": "10.4204/EPTCS.307.3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Lax Logical Framework, LLFP, was introduced, by a team including the last\ntwo authors, to provide a conceptual framework for integrating different proof\ndevelopment tools, thus allowing for external evidence and for postponing,\ndelegating, or factoring-out side conditions. In particular, LLFP allows for\nreducing the number of times a proof-irrelevant check is performed. In this\npaper we give a shallow, actually definitional, implementation of LLFP in Coq,\ni.e. we use Coq both as host framework and oracle for LLFP. This illuminates\nthe principles underpinning the mechanism of Lock-types and also suggests how\nto possibly extend Coq with the features of LLFP. The derived proof editor is\nthen put to use for developing case-studies on an emerging paradigm, both at\nlogical and implementation level, which we call fast and loose reasoning\nfollowing Danielsson et alii [6]. This paradigm trades off efficiency for\ncorrectness and amounts to postponing, or running in parallel, tedious or\ncomputationally demanding checks, until we are really sure that the intended\ngoal can be achieved. Typical examples are branch-prediction in CPUs and\noptimistic concurrency control.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 00:22:24 GMT"}], "update_date": "2019-10-25", "authors_parsed": [["Alessi", "Fabio", "", "Department of Mathematics, Computer Science and Physics\n  - University of Udine, Italy"], ["Ciaffaglione", "Alberto", "", "Department of\n  Mathematics, Computer Science and Physics - University of Udine, Italy"], ["Di Gianantonio", "Pietro", "", "Department of Mathematics, Computer Science and\n  Physics - University of Udine, Italy"], ["Honsell", "Furio", "", "Department of\n  Mathematics, Computer Science and Physics - University of Udine, Italy"], ["Lenisa", "Marina", "", "Department of Mathematics, Computer Science and Physics -\n  University of Udine, Italy"]]}, {"id": "1910.10849", "submitter": "EPTCS", "authors": "Michael Kohlhase (Computer Science, FAU Erlangen-N\\\"urnberg), Jan\n  Frederik Schaefer (Computer Science, FAU Erlangen-N\\\"urnberg)", "title": "GF + MMT = GLF -- From Language to Semantics through LF", "comments": "In Proceedings LFMTP 2019, arXiv:1910.08712", "journal-ref": "EPTCS 307, 2019, pp. 24-39", "doi": "10.4204/EPTCS.307.4", "report-no": null, "categories": "cs.CL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  These days, vast amounts of knowledge are available online, most of it in\nwritten form. Search engines help us access this knowledge, but aggregating,\nrelating and reasoning with it is still a predominantly human effort. One of\nthe key challenges for automated reasoning based on natural-language texts is\nthe need to extract meaning (semantics) from texts. Natural language\nunderstanding (NLU) systems describe the conversion from a set of natural\nlanguage utterances to terms in a particular logic. Tools for the\nco-development of grammar and target logic are currently largely missing.\n  We will describe the Grammatical Logical Framework (GLF), a combination of\ntwo existing frameworks, in which large parts of a symbolic, rule-based NLU\nsystem can be developed and implemented: the Grammatical Framework (GF) and\nMMT. GF is a tool for syntactic analysis, generation, and translation with\ncomplex natural language grammars and MMT can be used to specify logical\nsystems and to represent knowledge in them. Combining these tools is possible,\nbecause they are based on compatible logical frameworks: Martin-L\\\"of type\ntheory and LF. The flexibility of logical frameworks is needed, as NLU research\nhas not settled on a particular target logic for meaning representation.\nInstead, new logics are developed all the time to handle various language\nphenomena. GLF allows users to develop the logic and the language parsing\ncomponents in parallel, and to connect them for experimentation with the entire\npipeline.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 00:22:43 GMT"}], "update_date": "2019-10-25", "authors_parsed": [["Kohlhase", "Michael", "", "Computer Science, FAU Erlangen-N\u00fcrnberg"], ["Schaefer", "Jan Frederik", "", "Computer Science, FAU Erlangen-N\u00fcrnberg"]]}, {"id": "1910.10850", "submitter": "EPTCS", "authors": "Dennis M\\\"uller (Computer Science, FAU Erlangen-N\\\"urnberg, Germany),\n  Florian Rabe (Computer Science, FAU Erlangen-N\\\"urnberg, Germany and LRI\n  Paris, France)", "title": "Rapid Prototyping Formal Systems in MMT: 5 Case Studies", "comments": "In Proceedings LFMTP 2019, arXiv:1910.08712", "journal-ref": "EPTCS 307, 2019, pp. 40-54", "doi": "10.4204/EPTCS.307.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logical frameworks are meta-formalisms in which the syntax and semantics of\nobject logics and related formal systems can be defined. This allows object\nlogics to inherit implementations from the framework including, e.g., parser,\ntype checker, or module system. But if the desired object logic falls outside\nthe comfort zone of the logical framework, these definitions may become\ncumbersome or infeasible.\n  Therefore, the MMT system abstracts even further than previous frameworks: it\nassumes no type system or logic at all and allows its kernel algorithms to be\ncustomized by almost arbitrary sets of rules. In particular, this allows\nimplementing standard logical frameworks like LF in MMT. But it does so without\nchaining users to one particular meta-formalism: users can flexibly adapt MMT\nwhenever the object logic demands it.\n  In this paper, we present a series of case studies that do just that,\ndefining increasingly complex object logics in MMT. We use elegant declarative\nlogic definitions wherever possible, but inject entirely new rules into the\nkernel when necessary. Our experience shows that the MMT approach allows\nderiving prototype implementations of very diverse formal systems very easily\nand quickly.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 00:23:07 GMT"}], "update_date": "2019-10-25", "authors_parsed": [["M\u00fcller", "Dennis", "", "Computer Science, FAU Erlangen-N\u00fcrnberg, Germany"], ["Rabe", "Florian", "", "Computer Science, FAU Erlangen-N\u00fcrnberg, Germany and LRI\n  Paris, France"]]}, {"id": "1910.10851", "submitter": "EPTCS", "authors": "Aaron Stump (The University of Iowa)", "title": "A Weakly Initial Algebra for Higher-Order Abstract Syntax in Cedille", "comments": "In Proceedings LFMTP 2019, arXiv:1910.08712", "journal-ref": "EPTCS 307, 2019, pp. 55-67", "doi": "10.4204/EPTCS.307.6", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cedille is a relatively recent tool based on a Curry-style pure type theory,\nwithout a primitive datatype system. Using novel techniques based on dependent\nintersection types, inductive datatypes with their induction principles are\nderived. One benefit of this approach is that it allows exploration of new or\nadvanced forms of inductive datatypes. This paper reports work in progress on\none such form, namely higher-order abstract syntax (HOAS). We consider the\nnature of HOAS in the setting of pure type theory, comparing with the\ntraditional concept of environment models for lambda calculus. We see an\nalternative, based on what we term Kripke function-spaces, for which we can\nderive a weakly initial algebra in Cedille. Several examples are given using\nthe encoding.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 00:23:26 GMT"}], "update_date": "2019-10-25", "authors_parsed": [["Stump", "Aaron", "", "The University of Iowa"]]}, {"id": "1910.10889", "submitter": "Umang Mathur", "authors": "Umang Mathur, P. Madhusudan, Mahesh Viswanathan", "title": "What's Decidable About Program Verification Modulo Axioms?", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the decidability of the verification problem of programs\n\\emph{modulo axioms} --- that is, verifying whether programs satisfy their\nassertions, when the functions and relations it uses are assumed to interpreted\nby arbitrary functions and relations that satisfy a set of first-order axioms.\nUnfortunately, verification of entirely uninterpreted programs (with the empty\nset of axioms) is already undecidable. A recent work introduced a subclass of\n\\emph{coherent} uninterpreted programs, and showed that they admit decidable\nverification \\cite{coherence2019}. We undertake a systematic study of various\nnatural axioms for relations and functions, and study the decidability of the\ncoherent verification problem. Axioms include relations being reflexive,\nsymmetric, transitive, or total order relations, %and their combinations,\nfunctions restricted to being associative, idempotent or commutative, and\ncombinations of such axioms as well. Our comprehensive results unearth a rich\nlandscape that shows that though several axiom classes admit decidability for\ncoherent programs, coherence is not a panacea as several others continue to be\nundecidable.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 02:40:49 GMT"}, {"version": "v2", "created": "Mon, 28 Oct 2019 21:29:14 GMT"}], "update_date": "2019-10-30", "authors_parsed": [["Mathur", "Umang", ""], ["Madhusudan", "P.", ""], ["Viswanathan", "Mahesh", ""]]}, {"id": "1910.10987", "submitter": "Claudio Mezzina", "authors": "Hern\\'an Melgratti, Claudio Antares Mezzina, Iain Phillips, G. Michele\n  Pinna, Irek Ulidowski", "title": "Reversible Causal Nets and Reversible Event Structures", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One of the well-known results in concurrency theory concerns the relationship\nbetween event structures and occurrence nets: an occurrence net can be\nassociated with a prime event structure, and vice versa. More generally, the\nrelationships between various forms of event structures and suitable forms of\nnets have been long established. Good examples are the close relationship\nbetween inhibitor event structures and inhibitor occurrence nets, or between\nasymmetric event structures and asymmetric occurrence nets. Several forms of\nevent structures suited for the modelling of reversible computation have\nrecently been developed; also a method for reversing occurrence nets has been\nproposed. This paper bridges the gap between reversible event structures and\nreversible nets. We introduce the notion of reversible causal net, which is a\ngeneralisation of the notion of reversible unfolding. We show that reversible\ncausal nets correspond precisely to a subclass of reversible prime event\nstructures, the causal reversible prime event structures.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 09:26:21 GMT"}], "update_date": "2019-10-25", "authors_parsed": [["Melgratti", "Hern\u00e1n", ""], ["Mezzina", "Claudio Antares", ""], ["Phillips", "Iain", ""], ["Pinna", "G. Michele", ""], ["Ulidowski", "Irek", ""]]}, {"id": "1910.11024", "submitter": "Tim Quatmann", "authors": "Florent Delgrange, Joost-Pieter Katoen, Tim Quatmann, Mickael Randour", "title": "Simple Strategies in Multi-Objective MDPs (Technical Report)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the verification of multiple expected reward objectives at once\non Markov decision processes (MDPs). This enables a trade-off analysis among\nmultiple objectives by obtaining the Pareto front. We focus on strategies that\nare easy to employ and implement. That is, strategies that are pure (no\nrandomization) and have bounded memory. We show that checking whether a point\nis achievable by a pure stationary strategy is NP-complete, even for two\nobjectives, and we provide an MILP encoding to solve the corresponding problem.\nThe bounded memory case can be reduced to the stationary one by a product\nconstruction. Experimental results using \\Storm and Gurobi show the feasibility\nof our algorithms.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 10:48:21 GMT"}, {"version": "v2", "created": "Fri, 25 Oct 2019 02:42:06 GMT"}, {"version": "v3", "created": "Mon, 17 Feb 2020 18:01:29 GMT"}], "update_date": "2020-02-18", "authors_parsed": [["Delgrange", "Florent", ""], ["Katoen", "Joost-Pieter", ""], ["Quatmann", "Tim", ""], ["Randour", "Mickael", ""]]}, {"id": "1910.11203", "submitter": "Yassmeen Elderhalli", "authors": "Yassmeen Elderhalli, Osman Hasan, Sofiene Tahar", "title": "Dynamic Dependability Analysis of Shuffle-exchange Networks using HOL\n  Theorem Proving", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dynamic dependability models, such as dynamic fault trees (DFTs) and dynamic\nreliability block diagrams (DRBDs), are introduced to overcome the modeling\nlimitations of traditional models. Recently, higher-order logic (HOL)\nformalizations of both models have been conducted, which allow the analysis of\nthese models formally, within a theorem prover. In this report, we provide the\nformal dynamic dependability analysis of shuffle-exchange networks, which are\nmultistage interconnection networks that are commonly used in multiprocessor\nsystems. We use DFTs and DRBDs to model the terminal, broadcast and network\nreliability with dynamic spare gates and constructs in several generic\nversions. We verify generic expressions of probability of failure and\nreliability of these systems, which can be instantiated with any number of\nsystem components and failure rates to reason about the failure behavior of\nthese networks.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 15:01:53 GMT"}], "update_date": "2019-10-25", "authors_parsed": [["Elderhalli", "Yassmeen", ""], ["Hasan", "Osman", ""], ["Tahar", "Sofiene", ""]]}, {"id": "1910.11232", "submitter": "Andr\\'e Platzer", "authors": "Andr\\'e Platzer", "title": "Overview of Logical Foundations of Cyber-Physical Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": "In Helmut Seidl, editor, Post-proceedings of the Summer School\n  Marktoberdorf: Safety and Security of Software Systems - Logics, Proofs,\n  Applications, TUM University Press, 2020", "categories": "cs.LO cs.PL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cyber-physical systems (CPSs) are important whenever computer technology\ninterfaces with the physical world as it does in self-driving cars or aircraft\ncontrol support systems. Due to their many subtleties, controllers for\ncyber-physical systems deserve to be held to the highest correctness standards.\nTheir correct functioning is crucial, which explains the broad interest in\nsafety analysis technology for their mathematical models, which are called\nhybrid systems because they combine discrete dynamics with continuous dynamics.\nDifferential dynamic logic (dL) provides logical specification and rigorous\nreasoning techniques for hybrid systems. The logic dL is implemented in the\ntheorem prover KeYmaera X, which has been instrumental in verifying ground\nrobot controllers, railway systems, and the next-generation airborne collision\navoidance system ACAS X. This chapter provides an informal overview of this\nlogical approach to CPS safety that is detailed in a recent textbook on Logical\nFoundations of Cyber-Physical Systems. It also explains how safety guarantees\nobtained in the land of verified models reach the level of CPS execution\nunharmed.\n", "versions": [{"version": "v1", "created": "Thu, 24 Oct 2019 15:38:12 GMT"}], "update_date": "2021-02-15", "authors_parsed": [["Platzer", "Andr\u00e9", ""]]}, {"id": "1910.11588", "submitter": "J\\\"urgen Giesl", "authors": "Florian Frohn, Marcel Hark, J\\\"urgen Giesl", "title": "On the Decidability of Termination for Polynomial Loops", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the termination problem for triangular weakly non-linear loops\n(twn-loops) over some ring $\\mathcal{S}$ like $\\mathbb{Z}$, $\\mathbb{Q}$, or\n$\\mathbb{R}$. Essentially, the guard of such a loop is an arbitrary Boolean\nformula over (possibly non-linear) polynomial inequations, and the body is a\nsingle assignment $(x_1, \\ldots, x_d) \\longleftarrow (c_1 \\cdot x_1 + p_1,\n\\ldots, c_d \\cdot x_d + p_d)$ where each $x_i$ is a variable, $c_i \\in\n\\mathcal{S}$, and each $p_i$ is a (possibly non-linear) polynomial over\n$\\mathcal{S}$ and the variables $x_{i+1},\\ldots,x_{d}$. We present a reduction\nfrom the question of termination to the existential fragment of the first-order\ntheory of $\\mathcal{S}$ and $\\mathbb{R}$. For loops over $\\mathbb{R}$, our\nreduction entails decidability of termination. For loops over $\\mathbb{Z}$ and\n$\\mathbb{Q}$, it proves semi-decidability of non-termination.\n  Furthermore, we present a transformation to convert certain non-twn-loops\ninto twn-form. Then the original loop terminates iff the transformed loop\nterminates over a specific subset of $\\mathbb{R}$, which can also be checked\nvia our reduction. This transformation also allows us to prove tight complexity\nbounds for the termination problem for two important classes of loops which can\nalways be transformed into twn-loops.\n", "versions": [{"version": "v1", "created": "Fri, 25 Oct 2019 09:18:15 GMT"}, {"version": "v2", "created": "Thu, 10 Sep 2020 09:53:42 GMT"}, {"version": "v3", "created": "Tue, 15 Sep 2020 16:30:01 GMT"}], "update_date": "2020-09-16", "authors_parsed": [["Frohn", "Florian", ""], ["Hark", "Marcel", ""], ["Giesl", "J\u00fcrgen", ""]]}, {"id": "1910.11594", "submitter": "Jens Oliver Gutsfeld", "authors": "Jens Oliver Gutsfeld, Markus M\\\"uller-Olm and Christian Dielitz", "title": "Temporal Logics with Language Parameters", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computation Tree Logic (CTL) and its extensions CTL* and CTL+ are widely used\nin automated verification as a basis for common model checking tools. But while\nthey can express many properties of interest like reachability, even simple\nregular properties like \"Every other index is labelled a cannot be expressed in\nthese logics. While many extensions were developed to include regular or even\nnon-regular (e.g. visibly pushdown) languages, the first generic framework,\nExtended CTL, for CTL with arbitrary language classes was given by Axelsson et.\nal. and applied to regular, visibly pushdown and (deterministic) context-free\nlanguages. We extend this framework to CTL* and CTL+ and analyse it with regard\nto decidability, complexity, expressivity and satisfiability.\n", "versions": [{"version": "v1", "created": "Fri, 25 Oct 2019 09:32:53 GMT"}], "update_date": "2019-10-28", "authors_parsed": [["Gutsfeld", "Jens Oliver", ""], ["M\u00fcller-Olm", "Markus", ""], ["Dielitz", "Christian", ""]]}, {"id": "1910.11797", "submitter": "Thibault Gauthier", "authors": "Thibault Gauthier", "title": "Deep Reinforcement Learning for Synthesizing Functions in Higher-Order\n  Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper describes a deep reinforcement learning framework based on\nself-supervised learning within the proof assistant HOL4. A close interaction\nbetween the machine learning modules and the HOL4 library is achieved by the\nchoice of tree neural networks (TNNs) as machine learning models and the\ninternal use of HOL4 terms to represent tree structures of TNNs. Recursive\nimprovement is possible when a task is expressed as a search problem. In this\ncase, a Monte Carlo Tree Search (MCTS) algorithm guided by a TNN can be used to\nexplore the search space and produce better examples for training the next TNN.\nAs an illustration, term synthesis tasks on combinators and Diophantine\nequations are specified and learned. We achieve a success rate of 65% on\ncombinator synthesis problems outperforming state-of-the-art ATPs run with\ntheir best general set of strategies. We set a precedent for statistically\nguided synthesis of Diophantine equations by solving 78.5% of the generated\ntest problems.\n", "versions": [{"version": "v1", "created": "Fri, 25 Oct 2019 15:27:22 GMT"}, {"version": "v2", "created": "Fri, 28 Feb 2020 11:20:27 GMT"}, {"version": "v3", "created": "Fri, 24 Apr 2020 08:11:57 GMT"}], "update_date": "2020-04-27", "authors_parsed": [["Gauthier", "Thibault", ""]]}, {"id": "1910.12198", "submitter": "Kenta Cho", "authors": "Kenta Cho", "title": "Effectuses in Categorical Quantum Foundations", "comments": "PhD thesis, Radboud University (2019)", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This thesis develops the theory of effectuses as a categorical axiomatic\napproach to quantum theory. It provides a comprehensive introduction to\neffectus theory and reveals its connections with various other topics and\napproaches.\n", "versions": [{"version": "v1", "created": "Sun, 27 Oct 2019 07:01:17 GMT"}], "update_date": "2019-10-29", "authors_parsed": [["Cho", "Kenta", ""]]}, {"id": "1910.12282", "submitter": "Bhaskar Ramasubramanian", "authors": "Bhaskar Ramasubramanian, Luyao Niu, Andrew Clark, Linda Bushnell,\n  Radha Poovendran", "title": "Linear Temporal Logic Satisfaction in Adversarial Environments using\n  Secure Control Barrier Certificates", "comments": "Proc. of GameSec2019 (to appear). This version corrects a typo in the\n  simulation, and clarifies some ambiguous material from the Proceedings\n  version", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.GT cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies the satisfaction of a class of temporal properties for\ncyber-physical systems (CPSs) over a finite-time horizon in the presence of an\nadversary, in an environment described by discrete-time dynamics. The temporal\nlogic specification is given in safe-LTL_F, a fragment of linear temporal logic\nover traces of finite length. The interaction of the CPS with the adversary is\nmodeled as a two-player zero-sum discrete-time dynamic stochastic game with the\nCPS as defender. We formulate a dynamic programming based approach to determine\na stationary defender policy that maximized the probability of satisfaction of\na safe-LTL_F formula over a finite time-horizon under any stationary adversary\npolicy. We introduce secure control barrier certificates (S-CBCs), a\ngeneralization of barrier certificates and control barrier certificates that\naccounts for the presence of an adversary, and use S-CBCs to provide a lower\nbound on the above satisfaction probability. When the dynamics of the evolution\nof the system state has a specific underlying structure, we present a way to\ndetermine an S-CBC as a polynomial in the state variables using sum-of-squares\noptimization. An illustrative example demonstrates our approach.\n", "versions": [{"version": "v1", "created": "Sun, 27 Oct 2019 15:15:54 GMT"}], "update_date": "2019-10-29", "authors_parsed": [["Ramasubramanian", "Bhaskar", ""], ["Niu", "Luyao", ""], ["Clark", "Andrew", ""], ["Bushnell", "Linda", ""], ["Poovendran", "Radha", ""]]}, {"id": "1910.12320", "submitter": "Patrick Massot", "authors": "Kevin Buzzard, Johan Commelin, Patrick Massot", "title": "Formalising perfectoid spaces", "comments": "Final version, with small additions requested by referees. 22 pages.\n  See also https://leanprover-community.github.io/lean-perfectoid-spaces/", "journal-ref": "CPP 2020: Proceedings of the 9th ACM SIGPLAN International\n  Conference on Certified Programs and Proofs, Pages 299-312", "doi": "10.1145/3372885.3373830", "report-no": null, "categories": "cs.LO math.AG math.NT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Perfectoid spaces are sophisticated objects in arithmetic geometry introduced\nby Peter Scholze in 2012. We formalised enough definitions and theorems in\ntopology, algebra and geometry to define perfectoid spaces in the Lean theorem\nprover. This experiment confirms that a proof assistant can handle complexity\nin that direction, which is rather different from formalising a long proof\nabout simple objects. It also confirms that mathematicians with no computer\nscience training can become proficient users of a proof assistant in a\nrelatively short period of time. Finally, we observe that formalising a piece\nof mathematics that is a trending topic boosts the visibility of proof\nassistants amongst pure mathematicians.\n", "versions": [{"version": "v1", "created": "Sun, 27 Oct 2019 18:37:03 GMT"}, {"version": "v2", "created": "Thu, 28 May 2020 11:16:39 GMT"}], "update_date": "2020-05-29", "authors_parsed": [["Buzzard", "Kevin", ""], ["Commelin", "Johan", ""], ["Massot", "Patrick", ""]]}, {"id": "1910.12396", "submitter": "Guy Katz", "authors": "Sumathi Gokulanathan, Alexander Feldsher, Adi Malca, Clark Barrett,\n  Guy Katz", "title": "Simplifying Neural Networks using Formal Verification", "comments": "This paper appeared at NFM 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.LG cs.NE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deep neural network (DNN) verification is an emerging field, with diverse\nverification engines quickly becoming available. Demonstrating the\neffectiveness of these engines on real-world DNNs is an important step towards\ntheir wider adoption. We present a tool that can leverage existing verification\nengines in performing a novel application: neural network simplification,\nthrough the reduction of the size of a DNN without harming its accuracy. We\nreport on the work-flow of the simplification process, and demonstrate its\npotential significance and applicability on a family of real-world DNNs for\naircraft collision avoidance, whose sizes we were able to reduce by as much as\n10%.\n", "versions": [{"version": "v1", "created": "Fri, 25 Oct 2019 17:29:53 GMT"}, {"version": "v2", "created": "Mon, 10 Aug 2020 12:00:56 GMT"}], "update_date": "2020-08-11", "authors_parsed": [["Gokulanathan", "Sumathi", ""], ["Feldsher", "Alexander", ""], ["Malca", "Adi", ""], ["Barrett", "Clark", ""], ["Katz", "Guy", ""]]}, {"id": "1910.12634", "submitter": "Anne Schreuder", "authors": "Anne Schreuder, C.-H. Luke Ong", "title": "Polynomial Probabilistic Invariants and the Optional Stopping Theorem", "comments": "16 pages, 4 examples, submitted to TACAS 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present methods for the synthesis of polynomial invariants\nfor probabilistic transition systems. Our approach is based on martingale\ntheory. We construct invariants in the form of polynomials over program\nvariables, which give rise to martingales. These polynomials are program\ninvariants in the sense that their expected value upon termination is the same\nas their value at the start of the computation. In order to guarantee this we\napply the Optional Stopping Theorem. Concretely, we present two approaches. The\nfirst is restricted to linear systems. In this case under positive almost sure\ntermination there is a reduction to finding linear invariants for deterministic\ntransition systems. Secondly, by exploiting geometric persistence properties we\nconstruct martingale invariants for general polynomial transition system. We\nhave implemented this approach and it works on our examples.\n", "versions": [{"version": "v1", "created": "Fri, 25 Oct 2019 10:09:13 GMT"}], "update_date": "2019-10-29", "authors_parsed": [["Schreuder", "Anne", ""], ["Ong", "C. -H. Luke", ""]]}, {"id": "1910.12787", "submitter": "Thomas Kahl", "authors": "Thomas Kahl", "title": "Weak equivalence of higher-dimensional automata", "comments": null, "journal-ref": "Discrete Mathematics & Theoretical Computer Science, vol. 23 no.\n  1, Automata, Logic and Semantics (May 18, 2021) dmtcs:7490", "doi": null, "report-no": null, "categories": "cs.LO cs.FL math.AT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces a notion of equivalence for higher-dimensional\nautomata, called weak equivalence. Weak equivalence focuses mainly on a\ntraditional trace language and a new homology language, which captures the\noverall independence structure of an HDA. It is shown that weak equivalence is\ncompatible with both the tensor product and the coproduct of HDAs and that,\nunder certain conditions, HDAs may be reduced to weakly equivalent smaller ones\nby merging and collapsing cubes.\n", "versions": [{"version": "v1", "created": "Mon, 28 Oct 2019 16:30:42 GMT"}, {"version": "v2", "created": "Wed, 13 Jan 2021 12:14:47 GMT"}, {"version": "v3", "created": "Sun, 16 May 2021 16:53:31 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Kahl", "Thomas", ""]]}, {"id": "1910.12863", "submitter": "Christoph Benzm\\\"uller", "authors": "Lucca Tiemens and Dana S. Scott and Christoph Benzm\\\"uller and\n  Miroslav Benda", "title": "Computer-supported Exploration of a Categorical Axiomatization of\n  Modeloids", "comments": "24 pages; accepted for conference: Relational and Algebraic Methods\n  in Computer Science (RAMICS 2020)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.AT math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A modeloid, a certain set of partial bijections, emerges from the idea to\nabstract from a structure to the set of its partial automorphisms. It comes\nwith an operation, called the derivative, which is inspired by\nEhrenfeucht-Fra\\\"iss\\'e games. In this paper we develop a generalization of a\nmodeloid first to an inverse semigroup and then to an inverse category using an\naxiomatic approach to category theory. We then show that this formulation\nenables a purely algebraic view on Ehrenfeucht-Fra\\\"iss\\'e games.\n", "versions": [{"version": "v1", "created": "Sun, 27 Oct 2019 16:55:40 GMT"}, {"version": "v2", "created": "Mon, 13 Jan 2020 12:18:16 GMT"}], "update_date": "2020-01-14", "authors_parsed": [["Tiemens", "Lucca", ""], ["Scott", "Dana S.", ""], ["Benzm\u00fcller", "Christoph", ""], ["Benda", "Miroslav", ""]]}, {"id": "1910.13088", "submitter": "Tuhin Sahai", "authors": "Tuhin Sahai, Anurag Mishra, Jose Miguel Pasini, and Susmit Jha", "title": "Estimating the Density of States of Boolean Satisfiability Problems on\n  Classical and Quantum Computing Platforms", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.AI cs.LO quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a Boolean formula $\\phi(x)$ in conjunctive normal form (CNF), the\ndensity of states counts the number of variable assignments that violate\nexactly $e$ clauses, for all values of $e$. Thus, the density of states is a\nhistogram of the number of unsatisfied clauses over all possible assignments.\nThis computation generalizes both maximum-satisfiability (MAX-SAT) and model\ncounting problems and not only provides insight into the entire solution space,\nbut also yields a measure for the \\emph{hardness} of the problem instance.\nConsequently, in real-world scenarios, this problem is typically infeasible\neven when using state-of-the-art algorithms. While finding an exact answer to\nthis problem is a computationally intensive task, we propose a novel approach\nfor estimating density of states based on the concentration of measure\ninequalities. The methodology results in a quadratic unconstrained binary\noptimization (QUBO), which is particularly amenable to quantum annealing-based\nsolutions. We present the overall approach and compare results from the D-Wave\nquantum annealer against the best-known classical algorithms such as the\nHamze-de Freitas-Selby (HFS) algorithm and satisfiability modulo theory (SMT)\nsolvers.\n", "versions": [{"version": "v1", "created": "Tue, 29 Oct 2019 05:09:56 GMT"}], "update_date": "2019-10-30", "authors_parsed": [["Sahai", "Tuhin", ""], ["Mishra", "Anurag", ""], ["Pasini", "Jose Miguel", ""], ["Jha", "Susmit", ""]]}, {"id": "1910.13186", "submitter": "Vasco Brattka", "authors": "Vasco Brattka and Guido Gherardi", "title": "Completion of Choice", "comments": "30 pages", "journal-ref": "Annals of Pure and Applied Logic 172:3 (2021) 102914", "doi": "10.1016/j.apal.2020.102914", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We systematically study the completion of choice problems in the Weihrauch\nlattice. Choice problems play a pivotal role in Weihrauch complexity. For one,\nthey can be used as landmarks that characterize important equivalences classes\nin the Weihrauch lattice. On the other hand, choice problems also characterize\nseveral natural classes of computable problems, such as finite mind change\ncomputable problems, non-deterministically computable problems, Las Vegas\ncomputable problems and effectively Borel measurable functions. The closure\noperator of completion generates the concept of total Weihrauch reducibility,\nwhich is a variant of Weihrauch reducibility with total realizers. Logically\nspeaking, the completion of a problem is a version of the problem that is\nindependent of its premise. Hence, studying the completion of choice problems\nallows us to study simultaneously choice problems in the total Weihrauch\nlattice, as well as the question which choice problems can be made independent\nof their premises in the usual Weihrauch lattice. The outcome shows that many\nimportant choice problems that are related to compact spaces are complete,\nwhereas choice problems for unbounded spaces or closed sets of positive measure\nare typically not complete.\n", "versions": [{"version": "v1", "created": "Tue, 29 Oct 2019 10:45:03 GMT"}, {"version": "v2", "created": "Thu, 30 Apr 2020 11:56:35 GMT"}, {"version": "v3", "created": "Mon, 26 Oct 2020 09:25:59 GMT"}], "update_date": "2021-02-24", "authors_parsed": [["Brattka", "Vasco", ""], ["Gherardi", "Guido", ""]]}, {"id": "1910.13220", "submitter": "Victor Selivanov", "authors": "Victor Selivanov", "title": "Effective Wadge Hierarchy in Computable Quasi-Polish Spaces", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define and study an effective version of the Wadge hierarchy in computable\nquasi-Polish spaces which include most spaces of interest for computable\nanalysis. Along with hierarchies of sets we study hierarchies of k-partitions\nwhich are interesting on their own. We show that levels of such hierarchies are\npreserved by the computable effectively open surjections, that if the effective\nHausdorff-Kuratowski theorem holds in the Baire space then it holds in every\ncomputable quasi-Polish space, and we extend the effective Hausdorff theorem to\nk-partitions.\n", "versions": [{"version": "v1", "created": "Tue, 29 Oct 2019 12:11:45 GMT"}, {"version": "v2", "created": "Mon, 15 Feb 2021 09:49:21 GMT"}], "update_date": "2021-02-16", "authors_parsed": [["Selivanov", "Victor", ""]]}, {"id": "1910.13445", "submitter": "Jiaxuan You", "authors": "Jiaxuan You, Haoze Wu, Clark Barrett, Raghuram Ramanujan, Jure\n  Leskovec", "title": "G2SAT: Learning to Generate SAT Formulas", "comments": "Accepted by NeurIPS 2019. Equal contribution", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.LO cs.SI stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Boolean Satisfiability (SAT) problem is the canonical NP-complete problem\nand is fundamental to computer science, with a wide array of applications in\nplanning, verification, and theorem proving. Developing and evaluating\npractical SAT solvers relies on extensive empirical testing on a set of\nreal-world benchmark formulas. However, the availability of such real-world SAT\nformulas is limited. While these benchmark formulas can be augmented with\nsynthetically generated ones, existing approaches for doing so are heavily\nhand-crafted and fail to simultaneously capture a wide range of characteristics\nexhibited by real-world SAT instances. In this work, we present G2SAT, the\nfirst deep generative framework that learns to generate SAT formulas from a\ngiven set of input formulas. Our key insight is that SAT formulas can be\ntransformed into latent bipartite graph representations which we model using a\nspecialized deep generative neural network. We show that G2SAT can generate SAT\nformulas that closely resemble given real-world SAT instances, as measured by\nboth graph metrics and SAT solver behavior. Further, we show that our synthetic\nSAT formulas could be used to improve SAT solver performance on real-world\nbenchmarks, which opens up new opportunities for the continued development of\nSAT solvers and a deeper understanding of their performance.\n", "versions": [{"version": "v1", "created": "Tue, 29 Oct 2019 07:48:50 GMT"}], "update_date": "2019-10-31", "authors_parsed": [["You", "Jiaxuan", ""], ["Wu", "Haoze", ""], ["Barrett", "Clark", ""], ["Ramanujan", "Raghuram", ""], ["Leskovec", "Jure", ""]]}, {"id": "1910.13554", "submitter": "Jonathan Huerta Y Munive", "authors": "Simon Foster, Jonathan Juli\\'an Huerta y Munive, Georg Struth", "title": "Differential Hoare Logics and Refinement Calculi for Hybrid Systems with\n  Isabelle/HOL", "comments": "13 pages, no figures, conference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present simple new Hoare logics and refinement calculi for hybrid systems\nin the style of differential dynamic logic. (Refinement) Kleene algebra with\ntests is used for reasoning about the program structure and generating\nverification conditions at this level. Lenses capture hybrid program stores in\na generic algebraic way. The approach has been formalised with the Isabelle/HOL\nproof assistant. A number of examples explains the workflow with the resulting\nverification components.\n", "versions": [{"version": "v1", "created": "Tue, 29 Oct 2019 21:48:12 GMT"}], "update_date": "2019-10-31", "authors_parsed": [["Foster", "Simon", ""], ["Munive", "Jonathan Juli\u00e1n Huerta y", ""], ["Struth", "Georg", ""]]}, {"id": "1910.13620", "submitter": "Xiang Huang", "authors": "Xiang Huang, Jack H. Lutz, and Andrei N. Migunov", "title": "Algorithmic Randomness in Continuous-Time Markov Chains", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.IT cs.LO math.IT math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we develop the elements of the theory of algorithmic randomness\nin continuous-time Markov chains (CTMCs). Our main contribution is a rigorous,\nuseful notion of what it means for an $\\textit{ individual trajectory }$ of a\nCTMC to be ${ \\textit random }$. CTMCs have discrete state spaces and operate\nin continuous time. This, together with the fact that trajectories may or may\nnot halt, presents challenges not encountered in more conventional developments\nof algorithmic randomness.\n  Although we formulate algorithmic randomness in the general context of CTMCs,\nwe are primarily interested in the $\\textit{ computational }$ power of\nstochastic chemical reaction networks, which are special cases of CTMCs. This\nleads us to embrace situations in which the long-term behavior of a network\ndepends essentially on its initial state and hence to eschew assumptions that\nare frequently made in Markov chain theory to avoid such dependencies.\n  After defining the randomness of trajectories in terms of a new kind of\nmartingale (algorithmic betting strategy), we prove equivalent\ncharacterizations in terms of constructive measure theory and Kolmogorov\ncomplexity. As a preliminary application we prove that, in any stochastic\nchemical reaction network, $\\textit{ every }$ random trajectory with bounded\nmolecular counts has the $\\textit{ non-Zeno property }$ that infinitely many\nreactions do not occur in any finite interval of time.\n", "versions": [{"version": "v1", "created": "Wed, 30 Oct 2019 01:48:38 GMT"}], "update_date": "2019-10-31", "authors_parsed": [["Huang", "Xiang", ""], ["Lutz", "Jack H.", ""], ["Migunov", "Andrei N.", ""]]}, {"id": "1910.14138", "submitter": "Nerio Borges PhD", "authors": "Nerio Borges and Ram\\'on Pino P\\'erez", "title": "Belief revision and 3-valued logics: Characterization of 19,683 belief\n  change operators", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In most classical models of belief change, epistemic states are represented\nby theories (AGM) or formulas (Katsuno-Mendelzon) and the new pieces of\ninformation by formulas. The Representation Theorem for revision operators says\nthat operators are represented by total preorders. This important\nrepresentation is exploited by Darwiche and Pearl to shift the notion of\nepistemic state to a more abstract one, where the paradigm of epistemic state\nis indeed that of a total preorder over interpretations. In this work, we\nintroduce a 3-valued logic where the formulas can be identified with a\ngeneralisation of total preorders of three levels: a ranking function mapping\ninterpretations into the truth values. Then we analyse some sort of changes in\nthis kind of structures and give syntactical characterizations of them.\n", "versions": [{"version": "v1", "created": "Wed, 30 Oct 2019 21:10:39 GMT"}], "update_date": "2019-11-01", "authors_parsed": [["Borges", "Nerio", ""], ["P\u00e9rez", "Ram\u00f3n Pino", ""]]}, {"id": "1910.14219", "submitter": "EPTCS", "authors": "Robert K\\\"unnemann (CISPA Helmholtz Center for Information Security),\n  Deepak Garg (MPI-SWS), Michael Backes (CISPA Helmholtz Center for Information\n  Security)", "title": "Causality & Control Flow", "comments": "In Proceedings CREST 2019, arXiv:1910.13641", "journal-ref": "EPTCS 308, 2019, pp. 32-46", "doi": "10.4204/EPTCS.308.3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Causality has been the issue of philosophic debate since Hippocrates. It is\nused in formal verification and testing, e.g., to explain counterexamples or\nconstruct fault trees. Recent work defines actual causation in terms of Pearl's\ncausality framework, but most definitions brought forward so far struggle with\nexamples where one event preempts another one. A key point to capturing such\nexamples in the context of programs or distributed systems is a sound treatment\nof control flow. We discuss how causal models should incorporate control flow\nand discover that much of what Pearl/Halpern's notion of contingencies tries to\ncapture is captured better by an explicit modelling of the control flow in\nterms of structural equations and an arguably simpler definition. Inspired by\ncausality notions in the security domain, we bring forward a definition of\ncausality that takes these control-variables into account. This definition\nprovides a clear picture of the interaction between control flow and causality\nand captures these notoriously difficult preemption examples without secondary\nconcepts. We give convincing results on a benchmark of 34 examples from the\nliterature.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 02:30:26 GMT"}], "update_date": "2019-11-01", "authors_parsed": [["K\u00fcnnemann", "Robert", "", "CISPA Helmholtz Center for Information Security"], ["Garg", "Deepak", "", "MPI-SWS"], ["Backes", "Michael", "", "CISPA Helmholtz Center for Information\n  Security"]]}, {"id": "1910.14294", "submitter": "Benedikt Bollig", "authors": "B\\'eatrice B\\'erard, Benedikt Bollig, Mathieu Lehaut, Nathalie\n  Sznajder", "title": "Parameterized Synthesis for Fragments of First-Order Logic over Data\n  Words", "comments": "Technical report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the synthesis problem for systems with a parameterized number of\nprocesses. As in the classical case due to Church, the system selects actions\ndepending on the program run so far, with the aim of fulfilling a given\nspecification. The difficulty is that, at the same time, the environment\nexecutes actions that the system cannot control. In contrast to the case of\nfixed, finite alphabets, here we consider the case of parameterized alphabets.\nAn alphabet reflects the number of processes that are static but unknown. The\nsynthesis problem then asks whether there is a finite number of processes for\nwhich the system can satisfy the specification. This variant is already\nundecidable for very limited logics. Therefore, we consider a first-order logic\nwithout the order on word positions. We show that even in this restricted case\nsynthesis is undecidable if both the system and the environment have access to\nall processes. On the other hand, we prove that the problem is decidable if the\nenvironment only has access to a bounded number of processes. In that case,\nthere is even a cutoff meaning that it is enough to examine a bounded number of\nprocess architectures to solve the synthesis problem.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 08:11:10 GMT"}], "update_date": "2019-11-01", "authors_parsed": [["B\u00e9rard", "B\u00e9atrice", ""], ["Bollig", "Benedikt", ""], ["Lehaut", "Mathieu", ""], ["Sznajder", "Nathalie", ""]]}, {"id": "1910.14381", "submitter": "Paul Brunet", "authors": "Paul Brunet", "title": "A note on commutative Kleene algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present a detailed proof of an important result of algebraic\nlogic: namely that the free commutative Kleene algebra is the space of\nsemilinear sets. The first proof of this result was proposed by Redko in 1964,\nand simplified and corrected by Pilling in his 1970 thesis. However, we feel\nthat a new account of this proof is needed now. This result has acquired a\nparticular importance in recent years, since it is a key component in the\ncompleteness proofs of several algebraic models of concurrent computations\n(bi-Kleene algebra, concurrent Kleene algebra...). To that effect, we present a\nnew proof of this result.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 11:24:40 GMT"}], "update_date": "2019-11-01", "authors_parsed": [["Brunet", "Paul", ""]]}, {"id": "1910.14384", "submitter": "Paul Brunet", "authors": "Paul Brunet and David Pym", "title": "Pomsets with Boxes: Protection, Separation, and Locality in Concurrent\n  Kleene Algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Concurrent Kleene Algebra is an elegant tool for equational reasoning about\nconcurrent programs. An important feature of concurrent programs that is\nmissing from CKA is the ability to restrict legal interleavings. To remedy this\nwe extend the standard model of CKA, namely pomsets, with a new feature, called\nboxes, which can specify that part of the system is protected from outside\ninterference. We study the algebraic properties of this new model. Another\ndrawback of CKA is that the language used for expressing properties of programs\nis the same as that which is used to express programs themselves. This is often\ntoo restrictive for practical purposes. We provide a logic, 'pomset logic',\nthat is an assertion language for specifying such properties, and which is\ninterpreted on pomsets with boxes. In contrast with other approaches, this\nlogic is not state-based, but rather characterizes the runtime behaviour of a\nprogram. We develop the basic metatheory for the relationship between pomset\nlogic and CKA, including frame rules to support local reasoning, and illustrate\nthis relationship with simple examples.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 11:30:48 GMT"}, {"version": "v2", "created": "Wed, 6 May 2020 00:04:27 GMT"}], "update_date": "2020-05-07", "authors_parsed": [["Brunet", "Paul", ""], ["Pym", "David", ""]]}, {"id": "1910.14560", "submitter": "David Naumann", "authors": "Anindya Banerjee and Ramana Nagasamudram and David A. Naumann and\n  Mohammad Nikouei", "title": "A Relational Program Logic with Data Abstraction and Dynamic Framing", "comments": "Submitted for publication. Version 3: Revise exposition with more\n  examples; add case study; add author; revise title, add index, minor changes\n  throughout. Version 4: Improved relational second order frame rule; revised\n  and expanded examples and description of prototype; polish exposition", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a paper published in 1972 Hoare articulated the fundamental notions of\nhiding invariants and simulations. Hiding: invariants on encapsulated data\nrepresentations need not be mentioned in specifications that comprise the API\nof a module. Simulation: correctness of a new data representation and\nimplementation can be established by proving simulation between the old and new\nimplementations using a coupling relation defined on the encapsulated state.\nThese results were formalized semantically and for a simple model of state,\nthough the paper claimed this could be extended to encompass dynamically\nallocated objects. In recent years, progress has been made towards formalizing\nthe claim, for simulation, though mainly in semantic developments. In this\npaper, the ideas are combined with the idea in Hoare's 1969 paper: a logic of\nprograms. For a language with dynamically allocated shared mutable objects, we\nintroduce a relational Hoare logic that formalizes encapsulation, hiding of\ninvariants, and relating two implementations via coupling relations. Relations\nand other assertions are expressed in first order logic. Specifications can\nexpress a wide range of relational properties such as conditional equivalence\nand noninterference with declassification. The proof rules facilitate reasoning\nby means of convenient alignments and are shown sound with respect to a\nconventional operational semantics. Applicability to representative examples of\ndata abstraction is demonstrated using an SMT-based implementation.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 16:05:54 GMT"}, {"version": "v2", "created": "Fri, 1 Nov 2019 01:02:26 GMT"}, {"version": "v3", "created": "Fri, 30 Oct 2020 03:23:54 GMT"}, {"version": "v4", "created": "Sun, 30 May 2021 04:59:56 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Banerjee", "Anindya", ""], ["Nagasamudram", "Ramana", ""], ["Naumann", "David A.", ""], ["Nikouei", "Mohammad", ""]]}, {"id": "1910.14603", "submitter": "Antti Kuusisto", "authors": "Antti Kuusisto", "title": "On Games and Computation", "comments": "Changes to original version: restructuring and fixes, further\n  comments on related work, expanded and clarified work on modifiers", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce and investigate a range of general notions of a game. Our\nprincipal notion is based on a set of agents modifying a relational structure\nin a discrete evolution sequence. We also introduce and study a variety of ways\nto model partial and erroneous information in the setting. We discuss the\nconnection of the related general setting to logic and computation formalisms,\nwith emphasis on the recently introduced Turing-complete logic based on\ngame-theoretic semantics.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 16:53:54 GMT"}, {"version": "v2", "created": "Tue, 19 Nov 2019 13:26:47 GMT"}], "update_date": "2019-11-20", "authors_parsed": [["Kuusisto", "Antti", ""]]}]