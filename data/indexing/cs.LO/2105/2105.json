[{"id": "2105.00024", "submitter": "Matthieu Sozeau", "authors": "Antoine Allioux, Eric Finster and Matthieu Sozeau", "title": "Types are Internal $\\infty$-Groupoids", "comments": "Extended version of the LICS 2021 article", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  By extending type theory with a universe of definitionally associative and\nunital polynomial monads, we show how to arrive at a definition of opetopic\ntype which is able to encode a number of fully coherent algebraic structures.\nIn particular, our approach leads to a definition of $\\infty$-groupoid internal\nto type theory and we prove that the type of such $\\infty$-groupoids is\nequivalent to the universe of types. That is, every type admits the structure\nof an $\\infty$-groupoid internally, and this structure is unique.\n", "versions": [{"version": "v1", "created": "Fri, 30 Apr 2021 18:10:15 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Allioux", "Antoine", ""], ["Finster", "Eric", ""], ["Sozeau", "Matthieu", ""]]}, {"id": "2105.00188", "submitter": "Georg Struth", "authors": "Uli Fahrenberg, Christian Johnsen, Georg Struth and Krzysztof\n  Ziemia\\'nski", "title": "lr-Multisemigroups and Modal Convolution Algebras", "comments": "38 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.RA", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We show how modal quantales arise as convolution algebras of functions from\nlr-multisemigroups that is, multisemigroups with a source map l and a target\nmap r, into modal quantales which can be seen as weight or value algebras. In\nthe tradition of boolean algebras with operators we study modal correspondences\nbetween algebraic laws in the three algebras. The class of lr-multisemigroups\nintroduced in this article generalises Schweizer and Sklar's function systems\nand object-free categories to a setting isomorphic to algebras of ternary\nrelations as used in boolean algebras with operators and in substructural\nlogics. Our results provide a generic construction recipe for weighted modal\nquantales from such multisemigroups. This is illustrated by many examples,\nranging from modal algebras of weighted relations as used in fuzzy mathematics,\ncategory quantales in the tradition of category algebras or group rings,\nincidence algebras over partial orders, discrete and continuous weighted path\nalgebras, weighted languages of pomsets with interfaces, and weighted languages\nassociated with presimplicial and precubical sets. We also discuss how these\nresults can be combined with previous ones for concurrent quantales and\ngeneralised to a setting that supports reasoning with stochastic matrices or\nprobabilistic predicate transformers.\n", "versions": [{"version": "v1", "created": "Sat, 1 May 2021 08:09:55 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Fahrenberg", "Uli", ""], ["Johnsen", "Christian", ""], ["Struth", "Georg", ""], ["Ziemia\u0144ski", "Krzysztof", ""]]}, {"id": "2105.00208", "submitter": "Erwan Mahe", "authors": "Erwan Mahe, Christophe Gaston, Pascale Le Gall", "title": "A structural operational semantics for interactions with a look at loops", "comments": "14 pages of contents, 9 additional pages with 1 for references and 8\n  for appendices, 5 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Message Sequence Charts & Sequence Diagrams are graphical models that\nrepresent the behavior of distributed and concurrent systems via the scheduling\nof discrete and local emission and reception events. We propose an Interaction\nLanguage (IL) to formalize such models, defined as a term algebra which\nincludes strict and weak sequencing, alternative and parallel composition and\nfour kinds of loops. This IL is equipped with a denotational-style semantics\nassociating a set of traces (sequences of observed events) to each interaction.\nWe then define a structural operational semantics in the style of process\nalgebras and formally prove the equivalence of both semantics.\n", "versions": [{"version": "v1", "created": "Sat, 1 May 2021 10:15:29 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Mahe", "Erwan", ""], ["Gaston", "Christophe", ""], ["Gall", "Pascale Le", ""]]}, {"id": "2105.00274", "submitter": "Patrick Koopmann", "authors": "Patrick Koopmann", "title": "Signature-Based Abduction with Fresh Individuals and Complex Concepts\n  for Description Logics (Extended Version)", "comments": "Extended version of a paper accepted at IJCAI-2021, 20 pages, 3\n  figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a knowledge base and an observation as a set of facts, ABox abduction\naims at computing a hypothesis that, when added to the knowledge base, is\nsufficient to entail the observation. In signature-based ABox abduction, the\nhypothesis is further required to use only names from a given set. This form of\nabduction has applications such as diagnosis, KB repair, or explaining missing\nentailments. It is possible that hypotheses for a given observation only exist\nif we admit the use of fresh individuals and/or complex concepts built from the\ngiven signature, something most approaches for ABox abduction so far do not\nsupport or only support with restrictions. In this paper, we investigate the\ncomputational complexity of this form of abduction -- allowing either fresh\nindividuals, complex concepts, or both -- for various description logics, and\ngive size bounds on the hypotheses if they exist.\n", "versions": [{"version": "v1", "created": "Sat, 1 May 2021 14:55:46 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Koopmann", "Patrick", ""]]}, {"id": "2105.00283", "submitter": "Sean Moss", "authors": "Sean K. Moss, Tamara von Glehn", "title": "Dialectica models of type theory", "comments": null, "journal-ref": "LICS '18: Proceedings of the 33rd Annual ACM/IEEE Symposium on\n  Logic in Computer Science July 2018", "doi": "10.1145/3209108.3209207", "report-no": null, "categories": "math.CT cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We present two Dialectica-like constructions for models of intensional\nMartin-L\\\"of type theory based on G\\\"odel's original Dialectica interpretation\nand the Diller-Nahm variant, bringing dependent types to categorical proof\ntheory. We set both constructions within a logical predicates style theory for\ndisplay map categories where we show that 'quasifibred' versions of dependent\nproducts and universes suffice to construct their standard counterparts. To\nsupport the logic required for dependent products in the first construction, we\npropose a new semantic notion of finite sum for dependent types, generalizing\nfinitely-complete extensive categories. The second avoids extensivity\nassumptions using biproducts in a Kleisli category for a fibred additive monad.\n", "versions": [{"version": "v1", "created": "Sat, 1 May 2021 15:28:18 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Moss", "Sean K.", ""], ["von Glehn", "Tamara", ""]]}, {"id": "2105.00382", "submitter": "Ji Guan", "authors": "Ming Xu, Jingyi Mei, Ji Guan and Nengkun Yu", "title": "Model Checking Quantum Continuous-Time Markov Chains", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.LO math.NT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Verifying quantum systems has attracted a lot of interests in the last\ndecades. In this paper, we initialised the model checking of quantum\ncontinuous-time Markov chain (QCTMC). As a real-time system, we specify the\ntemporal properties on QCTMC by signal temporal logic (STL). To effectively\ncheck the atomic propositions in STL, we develop a state-of-art real root\nisolation algorithm under Schanuel's conjecture; further, we check the general\nSTL formula by interval operations with a bottom-up fashion, whose query\ncomplexity turns out to be linear in the size of the input formula by calling\nthe real root isolation algorithm. A running example of an open quantum walk is\nprovided to demonstrate our method.\n", "versions": [{"version": "v1", "created": "Sun, 2 May 2021 02:46:19 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Xu", "Ming", ""], ["Mei", "Jingyi", ""], ["Guan", "Ji", ""], ["Yu", "Nengkun", ""]]}, {"id": "2105.00564", "submitter": "Andr\\'es Ezequiel Viso", "authors": "Delia Kesner and Andr\\'es Viso", "title": "The Power of Tightness for Call-By-Push-Value", "comments": "arXiv admin note: text overlap with arXiv:2002.04011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We propose tight type systems for Call-by-Name (CBN) and Call-by-Value (CBV)\nthat can be both encoded in a tight type system for Call-by-Push-Value (CBPV).\nAll such systems are quantitative, in the sense that they provide exact\ninformation about the length of normalization sequences to normal form\n(discriminated between multiplicative and exponential steps) as well as the\nsize of these normal forms.\n", "versions": [{"version": "v1", "created": "Sun, 2 May 2021 22:27:57 GMT"}, {"version": "v2", "created": "Fri, 9 Jul 2021 13:53:22 GMT"}], "update_date": "2021-07-12", "authors_parsed": [["Kesner", "Delia", ""], ["Viso", "Andr\u00e9s", ""]]}, {"id": "2105.00663", "submitter": "Dimitri Justeau Allaire", "authors": "Dimitri Justeau-Allaire, Philippe Birnbaum, Xavier Lorca", "title": "Bounds of MIN_NCC and MAX_NCC and filtering scheme for graph domain\n  variables", "comments": "short note, 3 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Graph domain variables and constraints are an extension of constraint\nprogramming introduced by Dooms et al. This approach had been further\ninvestigated by Fages in its PhD thesis. On the other hand, Beldiceanu et al.\npresented a generic filtering scheme for global constraints based on graph\nproperties. This scheme strongly relies on the computation of graph properties'\nbounds and can be used in the context of graph domain variables and constraints\nwith a few adjustments. Bounds of MIN_NCC and MAX_NCC had been defined for the\ngraph-based representation of global constraint for the path_with_loops graph\nclass. In this note, we generalize those bounds for graph domain variables and\nfor any graph class. We also provide a filtering scheme for any graph class and\narbitrary bounds.\n", "versions": [{"version": "v1", "created": "Mon, 3 May 2021 07:35:15 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Justeau-Allaire", "Dimitri", ""], ["Birnbaum", "Philippe", ""], ["Lorca", "Xavier", ""]]}, {"id": "2105.00669", "submitter": "Thorsten Wi{\\ss}mann", "authors": "Thorsten Wi{\\ss}mann, Stefan Milius, Lutz Schr\\\"oder", "title": "Explaining Behavioural Inequivalence Generically in Quasilinear Time", "comments": "Full version with appendix containing all proofs", "journal-ref": null, "doi": "10.4230/LIPIcs.CONCUR.2021.32", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We provide a generic algorithm for constructing formulae that distinguish\nbehaviourally inequivalent states in systems of various transition types such\nas nondeterministic, probabilistic or weighted; genericity over the transition\ntype is achieved by working with coalgebras for a set functor in the paradigm\nof universal coalgebra. For every behavioural equivalence class in a given\nsystem, we construct a formula which holds precisely at the states in that\nclass. The algorithm instantiates to deterministic finite automata, transition\nsystems, labelled Markov chains, and systems of many other types. The ambient\nlogic is a modal logic featuring modalities that are generically extracted from\nthe functor; these modalities can be systematically translated into custom sets\nof modalities in a postprocessing step. The new algorithm builds on an existing\ncoalgebraic partition refinement algorithm. It runs in time $\\mathcal{O}((m+n)\n\\log n)$ on systems with $n$ states and $m$ transitions, and the same\nasymptotic bound applies to the dag size of the formulae it constructs. This\nimproves the bounds on run time and formula size compared to previous\nalgorithms even for previously known specific instances, viz. transition\nsystems and Markov chains; in particular, the best previous bound for\ntransition systems was $\\mathcal{O}(m n)$.\n", "versions": [{"version": "v1", "created": "Mon, 3 May 2021 07:57:17 GMT"}, {"version": "v2", "created": "Mon, 26 Jul 2021 17:27:59 GMT"}], "update_date": "2021-07-27", "authors_parsed": [["Wi\u00dfmann", "Thorsten", ""], ["Milius", "Stefan", ""], ["Schr\u00f6der", "Lutz", ""]]}, {"id": "2105.00735", "submitter": "Valentina Castiglioni", "authors": "Luca Aceto and Elli Anastasiadi and Valentina Castiglioni and Anna\n  Ingolfsdottir and Bas Luttik", "title": "In search of lost time: Axiomatising parallel composition in process\n  algebras", "comments": "arXiv admin note: text overlap with arXiv:2010.01943,\n  arXiv:2102.11166", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This survey reviews some of the most recent achievements in the saga of the\naxiomatisation of parallel composition, along with some classic results. We\nfocus on the recursion, relabelling and restriction free fragment of CCS and we\ndiscuss the solutions to three problems that were open for many years. The\nfirst problem concerns the status of Bergstra and Klop's auxiliary operators\nleft merge and communication merge in the finite axiomatisation of parallel\ncomposition modulo bisimiliarity: We argue that, under some natural\nassumptions, the addition of a single auxiliary binary operator to CCS does not\nyield a finite axiomatisation of bisimilarity. Then we delineate the boundary\nbetween finite and non-finite axiomatisability of the congruences in van\nGlabbeek's linear time-branching time spectrum over CCS. Finally, we present a\nnovel result to the effect that rooted weak bisimilarity has no finite complete\naxiomatisation over CCS.\n", "versions": [{"version": "v1", "created": "Mon, 3 May 2021 10:25:51 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Aceto", "Luca", ""], ["Anastasiadi", "Elli", ""], ["Castiglioni", "Valentina", ""], ["Ingolfsdottir", "Anna", ""], ["Luttik", "Bas", ""]]}, {"id": "2105.00748", "submitter": "Paolo Pistone", "authors": "Paolo Pistone, Luca Tranchini", "title": "What's Decidable about (Atomic) Polymorphism", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Due to the undecidability of most type-related properties of System F like\ntype inhabitation or type checking, restricted polymorphic systems have been\nwidely investigated (the most well-known being ML-polymorphism). In this paper\nwe investigate System Fat, or atomic System F, a very weak predicative fragment\nof System F whose typable terms coincide with the simply typable ones. We show\nthat the type-checking problem for Fat is decidable and we propose an algorithm\nwhich sheds some new light on the source of undecidability in full System F.\nMoreover, we investigate free theorems and contextual equivalence in this\nfragment, and we show that the latter, unlike in the simply typed\nlambda-calculus, is undecidable.\n", "versions": [{"version": "v1", "created": "Mon, 3 May 2021 10:56:05 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Pistone", "Paolo", ""], ["Tranchini", "Luca", ""]]}, {"id": "2105.00885", "submitter": "Randal E. Bryant", "authors": "Randal E. Bryant, Marijn J. H. Heule", "title": "Generating Extended Resolution Proofs with a BDD-Based SAT Solver", "comments": "Extended version of paper published at TACAS 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In 2006, Biere, Jussila, and Sinz made the key observation that the\nunderlying logic behind algorithms for constructing Reduced, Ordered Binary\nDecision Diagrams (BDDs) can be encoded as steps in a proof in the extended\nresolution logical framework. Through this, a BDD-based Boolean satisfiability\n(SAT) solver can generate a checkable proof of unsatisfiability for a set of\nclauses. Such a proof indicates that the formula is truly unsatisfiable without\nrequiring the user to trust the BDD package or the SAT solver built on top of\nit.\n  We extend their work to enable arbitrary existential quantification of the\nformula variables, a critical capability for BDD-based SAT solvers. We\ndemonstrate the utility of this approach by applying a prototype solver to\nseveral problems that are very challenging for search-based SAT solvers,\nobtaining polynomially sized proofs on benchmarks for parity formulas, as well\nas the Urquhart, mutilated chessboard, and pigeonhole problems.\n", "versions": [{"version": "v1", "created": "Mon, 3 May 2021 14:09:21 GMT"}, {"version": "v2", "created": "Mon, 14 Jun 2021 14:48:31 GMT"}], "update_date": "2021-06-15", "authors_parsed": [["Bryant", "Randal E.", ""], ["Heule", "Marijn J. H.", ""]]}, {"id": "2105.00969", "submitter": "Nathanael Arkor", "authors": "Nathanael Arkor, Dylan McDermott", "title": "Abstract clones for abstract syntax", "comments": "To appear in the proceedings of FSCD 2021; 16 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We give a formal treatment of simple type theories, such as the simply-typed\n$\\lambda$-calculus, using the framework of abstract clones. Abstract clones\ntraditionally describe first-order structures, but by equipping them with\nadditional algebraic structure, one can further axiomatize second-order,\nvariable-binding operators. This provides a syntax-independent representation\nof simple type theories. We describe multisorted second-order presentations,\nsuch as the presentation of the simply-typed $\\lambda$-calculus, and their\nclone-theoretic algebras; free algebras on clones abstractly describe the\nsyntax of simple type theories quotiented by equations such as $\\beta$- and\n$\\eta$-equality. We give a construction of free algebras and derive a\ncorresponding induction principle, which facilitates syntax-independent proofs\nof properties such as adequacy and normalization for simple type theories.\nWorking only with clones avoids some of the complexities inherent in\npresheaf-based frameworks for abstract syntax.\n", "versions": [{"version": "v1", "created": "Mon, 3 May 2021 16:09:55 GMT"}], "update_date": "2021-05-04", "authors_parsed": [["Arkor", "Nathanael", ""], ["McDermott", "Dylan", ""]]}, {"id": "2105.01112", "submitter": "Deivid Vale", "authors": "Deivid Vale and Cynthia Kop", "title": "Tuple Interpretations for Higher-Order Rewriting", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SC cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We develop a class of algebraic interpretations for many-sorted and\nhigher-order term rewriting systems that takes type information into account.\nSpecifically, base-type terms are mapped to \\emph{tuples} of natural numbers\nand higher-order terms to functions between those tuples. Tuples may carry\ninformation relevant to the type; for instance, a term of type $\\mathsf{nat}$\nmay be associated to a pair $(\\mathsf{cost}, \\mathsf{size})$ representing its\nevaluation cost and size. This class of interpretations results in a more\nfine-grained notion of complexity than runtime or derivational complexity,\nwhich makes it particularly useful to obtain complexity bounds for higher-order\nrewriting systems. We show that rewriting systems compatible with tuple\ninterpretations admit finite bounds on derivation height. Furthermore, we\ndemonstrate how to mechanically construct tuple interpretations and how to\norient $\\beta$ and $\\eta$ reductions within our technique. Finally, we relate\nour method to runtime complexity and prove that specific interpretation shapes\nimply certain runtime complexity bounds.\n", "versions": [{"version": "v1", "created": "Mon, 3 May 2021 18:34:37 GMT"}], "update_date": "2021-05-05", "authors_parsed": [["Vale", "Deivid", ""], ["Kop", "Cynthia", ""]]}, {"id": "2105.01382", "submitter": "Chris Barrett", "authors": "Chris Barrett, Alessio Guglielmi", "title": "A Subatomic Proof System for Decision Trees", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We design a proof system for propositional classical logic that integrates\ntwo languages for Boolean functions: standard conjunction-disjunction-negation\nand binary decision trees. We give two reasons to do so. The first is\nproof-theoretical naturalness: the system consists of all and only the\ninference rules generated by the single, simple, linear shape of the recently\nintroduced subatomic logic. Thanks to this regularity, cuts are eliminated via\na natural construction. The second reason is that the system generates\nefficient proofs. Indeed, we show that a certain class of tautologies due to\nStatman, which cannot have better than exponential cut-free proofs in the\nsequent calculus, have polynomial cut-free proofs in our system. We achieve\nthis by using the same construction that we use for cut elimination. In\nsummary, by expanding the language of propositional logic, we make its proof\ntheory more regular and generate more proofs, some of which are very efficient.\n  That design is made possible by considering propositional variables as\nsuperpositions of their truth values, which are connected by self-dual,\nnon-commutative connectives. A proof can then be projected via each\npropositional variable into two proofs, one for each truth value, without a\nneed for cuts. Those projections are semantically natural and are at the heart\nof all the constructions in this paper. To accommodate self-dual\nnon-commutativity, we compose proofs by deep inference.\n", "versions": [{"version": "v1", "created": "Tue, 4 May 2021 09:23:07 GMT"}], "update_date": "2021-05-05", "authors_parsed": [["Barrett", "Chris", ""], ["Guglielmi", "Alessio", ""]]}, {"id": "2105.01512", "submitter": "Antonio Abu Nassar", "authors": "Antonio Abu Nassar and Shaull Almagor", "title": "Simulation by Rounds of Letter-to-Letter Transducers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Letter-to-letter transducers are a standard formalism for modeling reactive\nsystems. Often, two transducers that model similar systems differ locally from\none another, by behaving similarly, up to permutations of the input and output\nletters within \"rounds\". In this work, we introduce and study notions of\nsimulation by rounds and equivalence by rounds of transducers. In our setting,\nwords are partitioned to consecutive subwords of a fixed length $k$, called\nrounds. Then, a transducer $\\mathcal{T}_1$ is $k$-round simulated by transducer\n$\\mathcal{T}_2$ if, intuitively, for every input word $x$, we can permute the\nletters within each round in $x$, such that the output of $\\mathcal{T}_2$ on\nthe permuted word is itself a permutation of the output of $\\mathcal{T}_1$ on\n$x$. Finally, two transducers are $k$-round equivalent if they simulate each\nother.\n  We solve two main decision problems, namely whether $\\mathcal{T}_2$ $k$-round\nsimulates $\\mathcal{T}_1$ (1) when $k$ is given as input, and (2) for an\nexistentially quantified $k$.\n  We demonstrate the usefulness of the definitions by applying them to process\nsymmetry: a setting in which a permutation in the identities of processes in a\nmulti-process system naturally gives rise to two transducers, whose $k$-round\nequivalence corresponds to stability against such permutations.\n", "versions": [{"version": "v1", "created": "Tue, 4 May 2021 14:14:16 GMT"}], "update_date": "2021-05-05", "authors_parsed": [["Nassar", "Antonio Abu", ""], ["Almagor", "Shaull", ""]]}, {"id": "2105.01724", "submitter": "Ulrik Buchholtz", "authors": "Ulrik Buchholtz and Jonathan Weinberger", "title": "Synthetic fibered $(\\infty,1)$-category theory", "comments": "Comments welcome; v3: fixed Def. B.1.1 (Transposing LARI adjunction)", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO math.AT math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study cocartesian fibrations in the setting of the synthetic\n$(\\infty,1)$-category theory developed in the simplicial type theory introduced\nby Riehl and Shulman. Our development culminates in a Yoneda Lemma for\ncocartesian fibrations.\n", "versions": [{"version": "v1", "created": "Tue, 4 May 2021 19:44:35 GMT"}, {"version": "v2", "created": "Thu, 6 May 2021 12:03:34 GMT"}, {"version": "v3", "created": "Thu, 13 May 2021 13:00:32 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Buchholtz", "Ulrik", ""], ["Weinberger", "Jonathan", ""]]}, {"id": "2105.01861", "submitter": "Pawe{\\l} Parys", "authors": "Pawe{\\l} Parys", "title": "Higher-Order Model Checking Step by Step", "comments": "This is an extended version of a paper published on the ICALP 2021\n  conference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show a new simple algorithm that solves the model-checking problem for\nrecursion schemes: check whether the tree generated by a given higher-order\nrecursion scheme is accepted by a given alternating parity automaton. The\nalgorithm amounts to a procedure that transforms a recursion scheme of order\n$n$ to a recursion scheme of order $n-1$, preserving acceptance, and increasing\nthe size only exponentially. After repeating the procedure $n$ times, we obtain\na recursion scheme of order $0$, for which the problem boils down to solving a\nfinite parity game. Since the size grows exponentially at each step, the\noverall complexity is $n$-EXPTIME, which is known to be optimal. More\nprecisely, the transformation is linear in the size of the recursion scheme,\nassuming that the arity of employed nonterminals and the size of the automaton\nare bounded by a constant; this results in an FPT algorithm for the\nmodel-checking problem.\n  Our transformation is a generalization of a previous transformation of the\nauthor (2020), working for reachability automata in place of parity automata.\nThe step-by-step approach can be opposed to previous algorithms solving the\nconsidered problem \"in one step\", being compulsorily more complicated.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 04:21:31 GMT"}], "update_date": "2021-05-06", "authors_parsed": [["Parys", "Pawe\u0142", ""]]}, {"id": "2105.01873", "submitter": "Jim de Groot", "authors": "Jim de Groot, Tadeusz Litak, Dirt Pattinson", "title": "G\\\"{o}del-McKinsey-Tarski and Blok-Esakia for Heyting-Lewis Implication", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Heyting-Lewis Logic is the extension of intuitionistic propositional logic\nwith a strict implication connective that satisfies the constructive\ncounterparts of axioms for strict implication provable in classical modal\nlogics. Variants of this logic are surprisingly widespread: they appear as\nCurry-Howard correspondents of (simple type theory extended with) Haskell-style\narrows, in preservativity logic of Heyting arithmetic, in the proof theory of\nguarded (co)recursion, and in the generalization of intuitionistic epistemic\nlogic.\n  Heyting-Lewis Logic can be interpreted in intuitionistic Kripke frames\nextended with a binary relation to account for strict implication. We use this\nsemantics to define descriptive frames (generalisations of Esakia spaces), and\nestablish a categorical duality between the algebraic interpretation and the\nframe semantics. We then adapt a transformation by Wolter and Zakharyaschev to\ntranslate Heyting-Lewis Logic to classical modal logic with two unary\noperators. This allows us to prove a Blok-Esakia theorem that we then use to\nobtain both known and new canonicity and correspondence theorems, and the\nfinite model property and decidability for a large family of Heyting-Lewis\nlogics.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 05:28:30 GMT"}], "update_date": "2021-05-06", "authors_parsed": [["de Groot", "Jim", ""], ["Litak", "Tadeusz", ""], ["Pattinson", "Dirt", ""]]}, {"id": "2105.02013", "submitter": "Ana Oliveira Da Costa", "authors": "Ezio Bartocci, Thomas Ferr\\`ere, Thomas A. Henzinger, Dejan Nickovic,\n  Ana Oliveira da Costa", "title": "Flavours of Sequential Information Flow", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Information-flow policies prescribe which information is available to a given\nuser or subsystem. We study the problem of specifying such properties in\nreactive systems, which may require dynamic changes in information-flow\nrestrictions between their states. We formalize several flavours of sequential\ninformation-flow, which cover different assumptions about the semantic relation\nbetween multiple observations of a system. Information-flow specification falls\ninto the category of hyperproperties. We define different variants of\nsequential information-flow specification using a first-order logic with both\ntrace quantifiers and temporal quantifiers called Hypertrace Logic. We prove\nthat HyperLTL, equivalent to a subset of Hypertrace Logic with restricted\nquantifier prefixes, cannot specify the majority of the studied two-state\nindependence variants. For our results, we introduce a notion of equivalence\nbetween sets of traces that cannot be distinguished by certain classes of\nformulas in Hypertrace Logic. This presents a new approach to proving\ninexpressiveness results for logics such as HyperLTL.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 12:17:42 GMT"}], "update_date": "2021-05-06", "authors_parsed": [["Bartocci", "Ezio", ""], ["Ferr\u00e8re", "Thomas", ""], ["Henzinger", "Thomas A.", ""], ["Nickovic", "Dejan", ""], ["da Costa", "Ana Oliveira", ""]]}, {"id": "2105.02156", "submitter": "Sean Moss", "authors": "Cristina Matache, Sean Moss, Sam Staton", "title": "Recursion and Sequentiality in Categories of Sheaves", "comments": null, "journal-ref": null, "doi": "10.4230/LIPIcs.FSCD.2021.25", "report-no": null, "categories": "cs.PL cs.LO math.CT", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We present a fully abstract model of a call-by-value language with\nhigher-order functions, recursion and natural numbers, as an exponential ideal\nin a topos. Our model is inspired by the fully abstract models of O'Hearn,\nRiecke and Sandholm, and Marz and Streicher. In contrast with semantics based\non cpo's, we treat recursion as just one feature in a model built by combining\na choice of modular components.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 16:10:06 GMT"}], "update_date": "2021-07-07", "authors_parsed": [["Matache", "Cristina", ""], ["Moss", "Sean", ""], ["Staton", "Sam", ""]]}, {"id": "2105.02264", "submitter": "Luca Buoncompagni", "authors": "Luca Buoncompagni, Syed Yusha Kareem and Fulvio Mastrogiovanni", "title": "Human Activity Recognition Models in Ontology Networks", "comments": "The paper has been accepted for publication in the IEEE Transactions\n  on Cybernetics journal on April 2021 and with DOI 10.1109/TCYB.2021.3073539.\n  It is an extension of arXiv:1707.03988v1 and it is related to the\n  arXiv:1809.08208v1 article. It contains 20 pages, 6 figures, 4 tables and 2\n  Appendices", "journal-ref": "IEEE Transactions on Cybernetics, 2021", "doi": "10.1109/TCYB.2021.3073539", "report-no": null, "categories": "cs.AI cs.LO cs.SE", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  We present Arianna+, a framework to design networks of ontologies for\nrepresenting knowledge enabling smart homes to perform human activity\nrecognition online. In the network, nodes are ontologies allowing for various\ndata contextualisation, while edges are general-purpose computational\nprocedures elaborating data. Arianna+ provides a flexible interface between the\ninputs and outputs of procedures and statements, which are atomic\nrepresentations of ontological knowledge. Arianna+ schedules procedures on the\nbasis of events by employing logic-based reasoning, i.e., by checking the\nclassification of certain statements in the ontologies. Each procedure involves\ninput and output statements that are differently contextualised in the\nontologies based on specific prior knowledge. Arianna+ allows to design\nnetworks that encode data within multiple contexts and, as a reference\nscenario, we present a modular network based on a spatial context shared among\nall activities and a temporal context specialised for each activity to be\nrecognised. In the paper, we argue that a network of small ontologies is more\nintelligible and has a reduced computational load than a single ontology\nencoding the same knowledge. Arianna+ integrates in the same architecture\nheterogeneous data processing techniques, which may be better suited to\ndifferent contexts. Thus, we do not propose a new algorithmic approach to\nactivity recognition, instead, we focus on the architectural aspects for\naccommodating logic-based and data-driven activity models in a context-oriented\nway. Also, we discuss how to leverage data contextualisation and reasoning for\nactivity recognition, and to support an iterative development process driven by\ndomain experts.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 18:23:56 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Buoncompagni", "Luca", ""], ["Kareem", "Syed Yusha", ""], ["Mastrogiovanni", "Fulvio", ""]]}, {"id": "2105.02283", "submitter": "Carmine Dodaro", "authors": "Carmine Dodaro, Giuseppe Galat\\`a, Muhammad Kamran Khan, Marco\n  Maratea, Ivan Porro", "title": "Operating Room (Re)Scheduling with Bed Management via ASP", "comments": "Under consideration in Theory and Practice of Logic Programming\n  (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Operating Room Scheduling (ORS) problem is the task of assigning patients\nto operating rooms, taking into account different specialties, lengths and\npriority scores of each planned surgery, operating room session durations, and\nthe availability of beds for the entire length of stay both in the Intensive\nCare Unit and in the wards. A proper solution to the ORS problem is of primary\nimportance for the healthcare service quality and the satisfaction of patients\nin hospital environments. In this paper we first present a solution to the\nproblem based on Answer Set Programming (ASP). The solution is tested on\nbenchmarks with realistic sizes and parameters, on three scenarios for the\ntarget length on 5-day scheduling, common in small-medium sized hospitals, and\nresults show that ASP is a suitable solving methodology for the ORS problem in\nsuch setting. Then, we also performed a scalability analysis on the schedule\nlength up to 15 days, which still shows the suitability of our solution also on\nlonger plan horizons. Moreover, we also present an ASP solution for the\nrescheduling problem, i.e. when the off-line schedule cannot be completed for\nsome reason. Finally, we introduce a web framework for managing ORS problems\nvia ASP that allows a user to insert the main parameters of the problem, solve\na specific instance, and show results graphically in real-time. Under\nconsideration in Theory and Practice of Logic Programming (TPLP).\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 18:51:22 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Dodaro", "Carmine", ""], ["Galat\u00e0", "Giuseppe", ""], ["Khan", "Muhammad Kamran", ""], ["Maratea", "Marco", ""], ["Porro", "Ivan", ""]]}, {"id": "2105.02309", "submitter": "Jens Kosiol", "authors": "Jens Kosiol and Gabriele Taentzer", "title": "A Generalized Concurrent Rule Construction for Double-Pushout Rewriting", "comments": "36 pages, 33 figures, accepted for publication at the 14th\n  International Conference on Graph Transformation (ICGT) 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Double-pushout rewriting is an established categorical approach to the\nrule-based transformation of graphs and graph-like objects. One of its standard\nresults is the construction of concurrent rules and the Concurrency Theorem\npertaining to it: The sequential application of two rules can equivalently be\nreplaced by the application of a concurrent rule and vice versa. We extend and\ngeneralize this result by introducing generalized concurrent rules (GCRs).\nTheir distinguishing property is that they allow identifying and preserving\nelements that are deleted by their first underlying rule and created by the\nsecond one. We position this new kind of composition of rules among the\nexisting ones and obtain a Generalized Concurrency Theorem for it. We conduct\nour work in the same generic framework in which the Concurrency Theorem has\nbeen presented, namely double-pushout rewriting in M-adhesive categories via\nrules equipped with application conditions.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 20:17:10 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Kosiol", "Jens", ""], ["Taentzer", "Gabriele", ""]]}, {"id": "2105.02352", "submitter": "Andrew Polonsky", "authors": "Richard Statman, Andrew Polonsky", "title": "Uniqueness typing for intersection types", "comments": "Superseded by arXiv:1809.08169v2", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Working in a variant of the intersection type assignment system of Coppo,\nDezani-Ciancaglini and Veneri [1981], we prove several facts about sets of\nterms having a given intersection type. Our main result is that every strongly\nnormalizing term $M$ admits a *uniqueness typing*, which is a pair $(\\Gamma,A)$\nsuch that\n  1) $\\Gamma \\vdash M : A$\n  2) $\\Gamma \\vdash N : A \\Longrightarrow M =_{\\beta\\eta} N$\n  We also discuss several presentations of intersection type algebras, and the\ncorresponding choices of type assignment rules.\n", "versions": [{"version": "v1", "created": "Wed, 5 May 2021 22:20:57 GMT"}, {"version": "v2", "created": "Sun, 9 May 2021 00:12:24 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Statman", "Richard", ""], ["Polonsky", "Andrew", ""]]}, {"id": "2105.02444", "submitter": "Robert Colvin", "authors": "Robert J. Colvin", "title": "Parallelized sequential composition, pipelines, and hardware weak memory\n  models", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Since the introduction of the CDC 6600 in 1965 and its `scoreboarding'\ntechnique processors have not (necessarily) executed instructions in program\norder. Programmers of high-level code may sequence independent instructions in\narbitrary order, and it is a matter of significant programming abstraction and\ncomputational efficiency that the processor can be relied upon to make sensible\nparallelizations/reorderings of low-level instructions to take advantage of,\neg., multiple ALUs. At the architectural level such reordering is typically\nimplemented via a per-processor pipeline, into which instructions are fetched\nin order, but possibly committed out of order depending on local\nconsiderations, provided any reordering preserves sequential semantics from\nthat processor's perspective. However multicore architectures, where several\npipelines run in parallel, can expose these processor-level reorderings as\nunexpected, or `weak', behaviours. Such weak behaviours are hard to reason\nabout, and (via speculative execution) underlie at least one class of\nwidespread security vulnerability.\n  In this paper we introduce a novel program operator, \\emph{parallelized\nsequential composition}, which can be instantiated with a function that\ncontrols the reordering of atomic instructions. It generalises both sequential\nand parallel composition, and when appropriately instantiated exhibits many of\nthe weak behaviours of well-known hardware weak memory models. Our framework\nadmits the application of established compositional techniques (eg.\nOwicki-Gries) for reasoning about weak behaviours, and is convenient for\nabstractly expressing properties from the literature. The semantics and theory\nis encoded and verified in a theorem prover, and we give an implementation of\nthe pipeline semantics which we use to empirically show conformance against\nestablished models of ARM and RISC-V.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 05:05:01 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Colvin", "Robert J.", ""]]}, {"id": "2105.02485", "submitter": "Pierre Clairambault", "authors": "Lison Blondeau-Patissier (ENS Lyon), Pierre Clairambault (LIP, PLUME)", "title": "Positional Injectivity for Innocent Strategies", "comments": null, "journal-ref": "6TH INTERNATIONAL CONFERENCE ON FORMAL STRUCTURES FOR COMPUTATION\n  AND DEDUCTION, Jul 2021, Buenos Aires, Argentina", "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In asynchronous games, Melli{\\`e}s proved that innocent strategies are\npositional: their behaviour only depends on the position, not the temporal\norder used to reach it. This insightful result shaped our understanding of the\nlink between dynamic (i.e. game) and static (i.e. relational) semantics. In\nthis paper, we investigate the positionality of innocent strategies in the\ntraditional setting of Hyland-Ong-Nickau-Coquand pointer games. We show that\nthough innocent strategies are not positional, total finite innocent strategies\nstill enjoy a key consequence of positionality, namely positional injectivity:\nthey are entirely determined by their positions. Unfortunately, this does not\nhold in general: we show a counterexample if finiteness and totality are\nlifted. For finite partial strategies we leave the problem open; we show\nhowever the partial result that two strategies with the same positions must\nhave the same P-views of maximal length.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 07:38:07 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Blondeau-Patissier", "Lison", "", "ENS Lyon"], ["Clairambault", "Pierre", "", "LIP, PLUME"]]}, {"id": "2105.02541", "submitter": "Vasileios Koutavas", "authors": "Vasileios Koutavas and Yu-Yang Lin and Nikos Tzevelekos", "title": "There and Back Again: From Bounded Checking to Verification of Program\n  Equivalence via Symbolic Up-to Techniques", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present a bounded equivalence verification technique for higher-order\nprograms with local state that combines fully abstract symbolic environmental\nbisimulations similar to symbolic game models, novel up-to techniques which are\neffective in practice even when terms diverge, and lightweight invariant\nannotations. The combination yields an equivalence checking technique with no\nfalse positives or negatives where all inequivalences can be automatically\ndetected, and many equivalences can be automatically or semi-automatically\nproved, including all classical Meyer and Sieber equivalences. We realise the\ntechnique in a tool prototype called Hobbit and benchmark it with an extensive\nset of new and existing examples.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 09:30:31 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Koutavas", "Vasileios", ""], ["Lin", "Yu-Yang", ""], ["Tzevelekos", "Nikos", ""]]}, {"id": "2105.02559", "submitter": "Blair Archibald", "authors": "Blair Archibald, Muffy Calder, Michele Sevegnani", "title": "Probablistic Bigraphs", "comments": "20 pages, 15 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Bigraphs are a universal computational modelling formalism for the spatial\nand temporal evolution of a system in which entities can be added and removed.\nWe extend bigraphs to probablistic bigraphs, and then again to action bigraphs,\nwhich include non-determinism and rewards. The extensions are implemented in\nthe BigraphER toolkit and illustrated through examples of virus spread in\ncomputer networks and data harvesting in wireless sensor systems. BigraphER\nalso supports the existing stochastic bigraphs extension of Krivine et al., and\nusing BigraphER we give, for the first time, a direct implementation of the\nmembrane budding model used to motivate stochastic bigraphs.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 10:13:41 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Archibald", "Blair", ""], ["Calder", "Muffy", ""], ["Sevegnani", "Michele", ""]]}, {"id": "2105.02611", "submitter": "Martin Zimmermann", "authors": "Shibashis Guha, Isma\\\"el Jecker, Karoliina Lehtinen, Martin Zimmermann", "title": "A Bit of Nondeterminism Makes Pushdown Automata Expressive and Succinct", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We study the expressiveness and succinctness of good-for-games pushdown\nautomata (GFG-PDA) over finite words, that is, pushdown automata whose\nnondeterminism can be resolved based on the run constructed so far, but\nindependently of the remainder of the input word.\n  We prove that GFG-PDA recognise more languages than deterministic PDA (DPDA)\nbut not all context-free languages (CFL). This class is orthogonal to\nunambiguous CFL. We further show that GFG-PDA can be exponentially more\nsuccinct than DPDA, while PDA can be double-exponentially more succinct than\nGFG-PDA. We also study GFGness in visibly pushdown automata (VPA), which enjoy\nbetter closure properties than PDA, and for which we show GFGness to be\nEXPTIME-complete. GFG-VPA can be exponentially more succinct than deterministic\nVPA, while VPA can be exponentially more succinct than GFG-VPA. Both of these\nlower bounds are tight.\n  Finally, we study the complexity of resolving nondeterminism in GFG-PDA.\nEvery GFG-PDA has a positional resolver, a function that resolves\nnondeterminism and that is only dependant on the current configuration.\nPushdown transducers are sufficient to implement the resolvers of GFG-VPA, but\nnot those of GFG-PDA. GFG-PDA with finite-state resolvers are determinisable.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 12:36:26 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Guha", "Shibashis", ""], ["Jecker", "Isma\u00ebl", ""], ["Lehtinen", "Karoliina", ""], ["Zimmermann", "Martin", ""]]}, {"id": "2105.02639", "submitter": "Tom\\'a\\v{s} Gonda", "authors": "Tobias Fritz, Tom\\'a\\v{s} Gonda, Paolo Perrone", "title": "De Finetti's Theorem in Categorical Probability", "comments": "31 pages, 1 figure. v2: More accurate abstract and some typos fixed", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.PR cs.LO math.CT math.ST stat.TH", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a novel proof of de Finetti's Theorem characterizing\npermutation-invariant probability measures of infinite sequences of variables,\nso-called exchangeable measures. The proof is phrased in the language of Markov\ncategories, which provide an abstract categorical framework for probability and\ninformation flow. The diagrammatic and abstract nature of the arguments makes\nthe proof intuitive and easy to follow. We also show how the usual\nmeasure-theoretic version of de Finetti's Theorem for standard Borel spaces is\nan instance of this result.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 13:19:07 GMT"}, {"version": "v2", "created": "Wed, 9 Jun 2021 15:56:30 GMT"}], "update_date": "2021-06-10", "authors_parsed": [["Fritz", "Tobias", ""], ["Gonda", "Tom\u00e1\u0161", ""], ["Perrone", "Paolo", ""]]}, {"id": "2105.02842", "submitter": "Nicolas Behr", "authors": "Nicolas Behr (Universit\\'e de Paris, CNRS, IRIF), Russ Harmer (Univ.\n  Lyon, EnsL, UCBL, CNRS, LIP, France), Jean Krivine (Universit\\'e de Paris,\n  CNRS, IRIF)", "title": "Concurrency Theorems for Non-linear Rewriting Theories", "comments": "19+14 pages, LNCS style; ICGT 2021 conference paper extended version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Sesqui-pushout (SqPO) rewriting along non-linear rules and for monic matches\nis well-known to permit the modeling of fusing and cloning of vertices and\nedges, yet to date, no construction of a suitable concurrency theorem was\navailable. The lack of such a theorem, in turn, rendered compositional\nreasoning for such rewriting systems largely infeasible. We develop in this\npaper a suitable concurrency theorem for non-linear SqPO-rewriting in\ncategories that are quasi-topoi (subsuming the example of adhesive categories)\nand with matches required to be regular monomorphisms of the given category.\nOur construction reveals an interesting \"backpropagation effect\" in computing\nrule compositions. We derive in addition a concurrency theorem for non-linear\ndouble pushout (DPO) rewriting in rm-adhesive categories. Our results open\nnon-linear SqPO and DPO semantics to the rich static analysis techniques\navailable from concurrency, rule algebra and tracelet theory.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 17:34:23 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Behr", "Nicolas", "", "Universit\u00e9 de Paris, CNRS, IRIF"], ["Harmer", "Russ", "", "Univ.\n  Lyon, EnsL, UCBL, CNRS, LIP, France"], ["Krivine", "Jean", "", "Universit\u00e9 de Paris,\n  CNRS, IRIF"]]}, {"id": "2105.03005", "submitter": "Maximiliano Cristia", "authors": "Maximiliano Cristi\\'a and Gianfranco Rossi", "title": "A Decision Procedure for a Theory of Finite Sets with Finite Integer\n  Intervals", "comments": "arXiv admin note: text overlap with arXiv:2102.05422", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SE", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper we extend a decision procedure for the Boolean algebra of\nfinite sets with cardinality constraints ($\\mathcal{L}_{\\lvert\\cdot\\rvert}$) to\na decision procedure for $\\mathcal{L}_{\\lvert\\cdot\\rvert}$ extended with set\nterms denoting finite integer intervals ($\\mathcal{L}_{[\\,]}$). In\n$\\mathcal{L}_{[\\,]}$ interval limits can be integer linear terms including\n\\emph{unbounded variables}. These intervals are a useful extension because they\nallow to express non-trivial set operators such as the minimum and maximum of a\nset, still in a quantifier-free logic. Hence, by providing a decision procedure\nfor $\\mathcal{L}_{[\\,]}$ it is possible to automatically reason about a new\nclass of quantifier-free formulas. The decision procedure is implemented as\npart of the $\\{log\\}$ tool. The paper includes a case study based on the\nelevator algorithm showing that $\\{log\\}$ can automatically discharge all its\ninvariance lemmas some of which involve intervals.\n", "versions": [{"version": "v1", "created": "Thu, 6 May 2021 23:35:41 GMT"}], "update_date": "2021-05-10", "authors_parsed": [["Cristi\u00e1", "Maximiliano", ""], ["Rossi", "Gianfranco", ""]]}, {"id": "2105.03038", "submitter": "Dusko Pavlovic", "authors": "Dusko Pavlovic", "title": "Lambek pregroups are Frobenius spiders in preorders", "comments": "21 pages, 16 diagrams, submitted. v2: corrected typos and style", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.CL cs.FL cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  \"Spider\" is a nickname of *special Frobenius algebras*, a fundamental\nstructure from mathematics, physics, and computer science. *Pregroups* are a\nfundamental structure from linguistics. Pregroups and spiders have been used\ntogether in natural language processing: one for syntax, the other for\nsemantics. It turns out that pregroups themselves can be characterized as\npointed spiders in the category of preordered relations, where they naturally\narise from grammars. The other way around preordered spider algebras in general\ncan be characterized as unions of pregroups. This extends the characterization\nof relational spider algebras as disjoint unions of groups. The compositional\nframework that emerged with the results suggests new ways to understand and\napply the basis structures in machine learning and data analysis.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 02:42:03 GMT"}, {"version": "v2", "created": "Mon, 10 May 2021 20:48:50 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Pavlovic", "Dusko", ""]]}, {"id": "2105.03252", "submitter": "Andrew Pitts", "authors": "Andrew M. Pitts and S. C. Steenkamp", "title": "Constructing Initial Algebras Using Inflationary Iteration", "comments": "15 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO math.CT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  An old theorem of Ad\\'amek constructs initial algebras for sufficiently\ncocontinuous endofunctors via transfinite iteration over ordinals in classical\nset theory. We prove a new version that works in constructive logic, using\n\"inflationary\" iteration over a notion of size that abstracts from limit\nordinals just their transitive, directed and well-founded properties. Borrowing\nfrom Taylor's constructive treatment of ordinals, we show that sizes exist with\nupper bounds for any given signature of indexes. From this it follows that\nthere is a rich class of endofunctors to which the new theorem applies,\nprovided one admits a weak form of choice (WISC) due to Streicher, Moerdijk,\nvan den Berg and Palmgren, and which is known to hold in the internal\nconstructive logic of many kinds of elementary topos.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 13:29:55 GMT"}, {"version": "v2", "created": "Sun, 27 Jun 2021 17:54:11 GMT"}], "update_date": "2021-06-29", "authors_parsed": [["Pitts", "Andrew M.", ""], ["Steenkamp", "S. C.", ""]]}, {"id": "2105.03274", "submitter": "Luca Reggio", "authors": "Anuj Dawar, Tom\\'a\\v{s} Jakl and Luca Reggio", "title": "Lov\\'asz-Type Theorems and Game Comonads", "comments": "23 pages. To appear in the Proceedings of the 36th Annual ACM/IEEE\n  Symposium on Logic in Computer Science (LICS 2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Lov\\'asz (1967) showed that two finite relational structures A and B are\nisomorphic if, and only if, the number of homomorphisms from C to A is the same\nas the number of homomorphisms from C to B for any finite structure C. Soon\nafter, Pultr (1973) proved a categorical generalisation of this fact. We\npropose a new categorical formulation, which applies to any locally finite\ncategory with pushouts and a proper factorisation system. As special cases of\nthis general theorem, we obtain two variants of Lov\\'asz' theorem: the result\nby Dvo\\v{r}\\'ak (2010) that characterises equivalence of graphs in the\nk-dimensional Weisfeiler-Leman equivalence by homomorphism counts from graphs\nof tree-width at most k, and the result of Grohe (2020) characterising\nequivalence with respect to first-order logic with counting and quantifier\ndepth k in terms of homomorphism counts from graphs of tree-depth at most k.\nThe connection of our categorical formulation with these results is obtained by\nmeans of the game comonads of Abramsky et al. We also present a novel\napplication to homomorphism counts in modal logic.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 14:01:49 GMT"}], "update_date": "2021-05-10", "authors_parsed": [["Dawar", "Anuj", ""], ["Jakl", "Tom\u00e1\u0161", ""], ["Reggio", "Luca", ""]]}, {"id": "2105.03389", "submitter": "Daniel Jeffries", "authors": "Patricia Johann, Enrico Ghiorzi, and Daniel Jeffries", "title": "GADTs, Functoriality, Parametricity: Pick Two", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  GADTs can be represented either as their Church encodings \\`a la Atkey, or as\nfixpoints \\`a la Johann and Polonsky. While a GADT represented as its Church\nencoding need not support a map function satisfying the functor laws, the\nfixpoint representation of a GADT must support such a map function even to be\nwell-defined. The two representations of a GADT thus need not be the same in\ngeneral. This observation forces a choice of representation of data types in\nlanguages supporting GADTs. In this paper we show that choosing whether to\nrepresent data types as their Church encodings or as fixpoints determines\nwhether or not a language supporting GADTs can have parametric models. This\nchoice thus has important consequences for how we can program with, and reason\nabout, these advanced data types.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 16:50:42 GMT"}], "update_date": "2021-05-20", "authors_parsed": [["Johann", "Patricia", ""], ["Ghiorzi", "Enrico", ""], ["Jeffries", "Daniel", ""]]}, {"id": "2105.03522", "submitter": "Andrea Colledan", "authors": "Andrea Colledan", "title": "On Abstract Machine Semantics for Proto-Quipper-M", "comments": "72 pages (34 without appendix), 5 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO quant-ph", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Quipper is a domain-specific programming language for the description of\nquantum circuits. Because it is implemented as an embedded language in Haskell,\nQuipper is a very practical functional language. However, for the same reason,\nit lacks a formal semantics and it is limited by Haskell's type system. In\nparticular, because Haskell lacks linear types, it is easy to write Quipper\nprograms that violate the non-cloning property of quantum states. In order to\nformalize relevant fragments of Quipper in a type-safe way, the Proto-Quipper\nfamily of research languages has been introduced over the last years. In this\npaper we first review Proto-Quipper-M, an instance of the Proto-Quipper family\nbased on a categorical model for quantum circuits, which features a linear type\nsystem that guarantees that the non-cloning property holds at compile time. We\nthen derive a tentative small-step operational semantics from the big-step\nsemantics of Proto-Quipper-M and we prove that the two are equivalent. After\nproving subject reduction and progress results for the tentative semantics, we\nbuild upon it to obtain a truly small-step semantics in the style of an\nabstract machine, which we eventually prove to be equivalent to the original\nsemantics.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 22:16:11 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Colledan", "Andrea", ""]]}, {"id": "2105.03531", "submitter": "Tajana Ban Kirigin", "authors": "Max Kanovich, Tajana Ban Kirigin, Vivek Nigam, Andre Scedrov, and\n  Carolyn Talcott", "title": "On the Complexity of Verification of Time-Sensitive Distributed Systems:\n  Technical Report", "comments": "This Technical Report updates and subsumes the technical report\n  arXiv:1606.07886", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper develops a Multiset Rewriting language with explicit time for\nspecifying and analyzing Time-Sensitive Distributed Systems (TSDS). Goals are\noften specified using explicit time constraints. A good trace is an infinite\ntrace in which goals are perpetually satisfied, in spite of a possible\nenvironment interference. In our previous work (FORMATS 2016) we discussed two\ndesirable properties of TSDSes, realizability (there exists a good trace) and\nsurvivability (where, in addition, all admissible traces are good). Here we\nconsider two further properties, recoverability (all compliant traces do not\nreach points-of-no-return) and reliability (system can always continue\nfunctioning using a good trace). Following our previous work (FORMATS 2016), we\nfocus on a class of systems called Progressing Timed Systems (PTS), where\nintuitively only a finite number of actions can be carried out in a bounded\ntime period. We prove that for this class of systems the properties of\nrecoverability and reliability coincide and are PSPACE-complete. Furthermore,\nif we impose a bound on time (as in bounded model-checking), we show that for\nPTS, the reliability property is in the $\\Delta_2^p$ class of the polynomial\nhierarchy, a subclass of PSPACE. We also show that bounded survivability is\nboth NP-hard and coNP-hard.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 22:44:23 GMT"}, {"version": "v2", "created": "Fri, 4 Jun 2021 17:23:36 GMT"}], "update_date": "2021-06-07", "authors_parsed": [["Kanovich", "Max", ""], ["Kirigin", "Tajana Ban", ""], ["Nigam", "Vivek", ""], ["Scedrov", "Andre", ""], ["Talcott", "Carolyn", ""]]}, {"id": "2105.03693", "submitter": "Sebastian Siebertz", "authors": "Mario Grobler and Patrice Ossona de Mendez and Sebastian Siebertz and\n  Alexandre Vigny", "title": "On set systems definable in sparse graph classes, discrepancy, and\n  quantifier elimination", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.LO math.CO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study the (hereditary) discrepancy of definable set systems, which is a\nnatural measure for their inherent complexity and approximability. We establish\na strong connection between the hereditary discrepancy and quantifier\nelimination over signatures with only unary relation and function symbols. We\nprove that set systems definable in theories (over such signatures) with\nquantifier elimination have constant hereditary discrepancy. We derive that set\nsystems definable in bounded expansion classes, which are very general classes\nof uniformly sparse graphs, have bounded hereditary discrepancy. We also derive\nthat nowhere dense classes, which are more general than bounded expansion\nclasses, in general do not admit quantifier elimination over a signature\nextended by an arbitrary number of unary function symbols. We show that the set\nsystems on a ground set $U$ definable on a monotone nowhere dense class of\ngraphs $\\mathscr C$ have hereditary discrepancy at most $|U|^{c}$ (for\nsome~$c<1/2$) and that, on the contrary, for every monotone somewhere dense\nclass $\\mathscr C$ and for every positive integer $d$ there is a set system of\n$d$-tuples definable in $\\mathscr C$ with discrepancy $\\Omega(|U|^{1/2})$.\n  We further prove that if $\\mathscr C$ is a class of graphs with bounded\nexpansion and $\\phi(\\bar x;\\bar y)$ is a first-order formula, then we can\ncompute in polynomial time, for an input graph $G\\in\\mathscr C$, a mapping\n$\\chi:V(G)^{|\\bar x|}\\rightarrow\\{-1,1\\}$ witnessing the boundedness of the\ndiscrepancy of the set-system defined by~$\\phi$, an $\\varepsilon$-net of size\n$\\mathcal{O}(1/\\varepsilon)$, and an $\\varepsilon$-approximation of size\n$\\mathcal{O}(1/\\varepsilon)$.\n", "versions": [{"version": "v1", "created": "Sat, 8 May 2021 13:05:31 GMT"}, {"version": "v2", "created": "Tue, 13 Jul 2021 08:19:28 GMT"}], "update_date": "2021-07-14", "authors_parsed": [["Grobler", "Mario", ""], ["de Mendez", "Patrice Ossona", ""], ["Siebertz", "Sebastian", ""], ["Vigny", "Alexandre", ""]]}, {"id": "2105.04057", "submitter": "Jonathan Gorard", "authors": "Jonathan Gorard, Manojna Namuduri and Xerxes D. Arsiwalla", "title": "Fast Automated Reasoning over String Diagrams using Multiway Causal\n  Structure", "comments": "Submitted to Applied Category Theory 2021. 14 pages, 9 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce an intuitive algorithmic methodology for enacting automated\nrewriting of string diagrams within a general double-pushout (DPO) framework,\nin which the sequence of rewrites is chosen in accordance with the causal\nstructure of the underlying diagrammatic calculus. The combination of the\nrewriting structure and the causal structure may be elegantly formulated as a\nweak 2-category equipped with both total and partial monoidal bifunctors, thus\nproviding a categorical semantics for the full multiway evolution causal graph\nof a generic Wolfram model hypergraph rewriting system. As an illustrative\nexample, we show how a special case of this algorithm enables highly efficient\nautomated simplification of quantum circuits, as represented in the\nZX-calculus.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 00:45:23 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Gorard", "Jonathan", ""], ["Namuduri", "Manojna", ""], ["Arsiwalla", "Xerxes D.", ""]]}, {"id": "2105.04110", "submitter": "Mary Southern", "authors": "Mary Southern", "title": "A Framework for Reasoning About LF Specifications", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This thesis develops a framework for formalizing reasoning about\nspecifications of systems written in LF. This formalization centers around the\ndevelopment of a reasoning logic that can express the sorts of properties which\narise in reasoning about such specifications. In this logic, type inhabitation\njudgements in LF serve as atomic formulas, and quantification is permitted over\nboth contexts and terms in these judgements. The logic permits arbitrary\nrelations over derivations of LF judgements to be expressed using a collection\nof logical connectives, in contrast to other systems for reasoning about LF\nspecifications. Defining a semantics for these formulas raises issues which we\nmust address, such as how to interpret both term and context quantification as\nwell as the relation between atomic formulas and the LF judgements they are\nmeant to encode.\n  This thesis also develops a proof system which captures informal reasoning\nsteps as sound inference rules for the logic. To achieve this we develop a\ncollection of proof rules including mechanisms for both case analysis and\ninductive reasoning over the derivations of judgements in LF. The proof system\nalso supports applying LF meta-theorems through proof rules that enforce\nrequirements of the LF meta-theorem that cannot be expressed in the logic.\n  We also implement a proof assistant called Adelfa that provides a means for\nmechanizing this approach to reasoning about specifications written in LF. A\ncharacteristic of this proof assistant is that it uses the proof rules that\ncomplement the logic to describe a collection of tactics that are used to\ndevelop proofs in goal-driven fashion. The Adelfa system is used to develop a\ncollection of examples which demonstrate the effectiveness of the framework and\nshowcase how informal reasoning about specifications written in LF can be\nformalized using the logic and associated proof system.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 04:53:39 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Southern", "Mary", ""]]}, {"id": "2105.04176", "submitter": "Patrick Totzke", "authors": "Marie Fortin, Louwe B. Kuijer, Patrick Totzke, Martin Zimmermann", "title": "HyperLTL Satisfiability is $\\Sigma_1^1$-complete, HyperCTL*\n  Satisfiability is $\\Sigma_1^2$-complete", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Temporal logics for the specification of information-flow properties are able\nto express relations between multiple executions of a system. The two most\nimportant such logics are HyperLTL and HyperCTL*, which generalise LTL and CTL*\nby trace quantification. It is known that this expressiveness comes at a price,\ni.e. satisfiability is undecidable for both logics.\n  In this paper we settle the exact complexity of these problems, showing that\nboth are in fact highly undecidable: we prove that HyperLTL satisfiability is\n$\\Sigma_1^1$-complete and HyperCTL* satisfiability is $\\Sigma_1^2$-complete.\nThese are significant increases over the previously known lower bounds and the\nfirst upper bounds. To prove $\\Sigma_1^2$-membership for HyperCTL*, we prove\nthat every satisfiable HyperCTL* sentence has a model that is equinumerous to\nthe continuum, the first upper bound of this kind. We prove this bound to be\ntight. Finally, we show that the membership problem for every level of the\nHyperLTL quantifier alternation hierarchy is $\\Pi_1^1$-complete.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 08:09:46 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Fortin", "Marie", ""], ["Kuijer", "Louwe B.", ""], ["Totzke", "Patrick", ""], ["Zimmermann", "Martin", ""]]}, {"id": "2105.04355", "submitter": "Chad Nester", "authors": "Chad Nester", "title": "Situated Transition Sytems", "comments": "Preprint. 18 pages including bibliography and appendix. In peer\n  review", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We construct a monoidal category of open transition systems that generate\nmaterial history as transitions unfold, which we call situated transition\nsystems. The material history generated by a composite system is composed of\nthe material history generated by each component. The construction is\nparameterized by a symmetric strict monoidal category, understood as a resource\ntheory, from which material histories are drawn. We pay special attention to\nthe case in which this category is compact closed. In particular, if we begin\nwith a compact closed category of integers then the resulting situated\ntransition systems can be understood as systems of double-entry bookkeeping\naccounts.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 13:42:04 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Nester", "Chad", ""]]}, {"id": "2105.04501", "submitter": "Christopher M. Poskitt", "authors": "Christopher M. Poskitt", "title": "Incorrectness Logic for Graph Programs", "comments": "Accepted by the 14th International Conference on Graph Transformation\n  (ICGT 2021)", "journal-ref": "Proc. ICGT 2021, volume 12741 of LNCS, pages 81-101. Springer,\n  2021", "doi": "10.1007/978-3-030-78946-6_5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program logics typically reason about an over-approximation of program\nbehaviour to prove the absence of bugs. Recently, program logics have been\nproposed that instead prove the presence of bugs by means of under-approximate\nreasoning, which has the promise of better scalability. In this paper, we\npresent an under-approximate program logic for a nondeterministic graph\nprogramming language, and show how it can be used to reason deductively about\nprogram incorrectness, whether defined by the presence of forbidden graph\nstructure or by finitely failing executions. We prove this incorrectness logic\nto be sound and complete, and speculate on some possible future applications of\nit.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 16:50:35 GMT"}, {"version": "v2", "created": "Thu, 13 May 2021 06:09:41 GMT"}], "update_date": "2021-06-22", "authors_parsed": [["Poskitt", "Christopher M.", ""]]}, {"id": "2105.04692", "submitter": "Pavel Naumov", "authors": "Lia Bozzone and Pavel Naumov", "title": "Budget-Constrained Coalition Strategies with Discounting", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.GT cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Discounting future costs and rewards is a common practice in accounting, game\ntheory, and machine learning. In spite of this, existing logics for reasoning\nabout strategies with cost and resource constraints do not account for\ndiscounting. The paper proposes a sound and complete logical system for\nreasoning about budget-constrained strategic abilities that incorporates\ndiscounting into its semantics.\n", "versions": [{"version": "v1", "created": "Mon, 10 May 2021 22:21:43 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Bozzone", "Lia", ""], ["Naumov", "Pavel", ""]]}, {"id": "2105.04817", "submitter": "Mayuko Kori", "authors": "Mayuko Kori, Ichiro Hasuo, Shin-ya Katsumata", "title": "Fibrational Initial Algebra-Final Coalgebra Coincidence over Initial\n  Algebras: Turning Verification Witnesses Upside Down", "comments": "38 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The coincidence between initial algebras (IAs) and final coalgebras (FCs) is\na phenomenon that underpins various important results in theoretical computer\nscience. In this paper, we identify a general fibrational condition for the\nIA-FC coincidence, namely in the fiber over an initial algebra in the base\ncategory. Identifying (co)algebras in a fiber as (co)inductive predicates, our\nfibrational IA-FC coincidence allows one to use coinductive witnesses (such as\ninvariants) for verifying inductive properties (such as liveness). Our general\nfibrational theory features the technical condition of stability of chain\ncolimits; we extend the framework to the presence of a monadic effect, too,\nrestricting to fibrations of complete lattice-valued predicates. Practical\nbenefits of our categorical theory are exemplified by new \"upside-down\" witness\nnotions for three verification problems: probabilistic liveness, and acceptance\nand model-checking with respect to bottom-up tree automata.\n", "versions": [{"version": "v1", "created": "Tue, 11 May 2021 07:10:13 GMT"}, {"version": "v2", "created": "Wed, 7 Jul 2021 07:11:05 GMT"}], "update_date": "2021-07-08", "authors_parsed": [["Kori", "Mayuko", ""], ["Hasuo", "Ichiro", ""], ["Katsumata", "Shin-ya", ""]]}, {"id": "2105.04929", "submitter": "Paul-Andr\\'e Melli\\`es", "authors": "Melli\\`es Paul-Andr\\'e", "title": "Asynchronous Template Games and the Gray Tensor Product of 2-Categories", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In his recent and exploratory work on template games and linear logic,\nMelli\\`es defines sequential and concurrent games as categories with positions\nas objects and trajectories as morphisms, labelled by a specific\nsynchronization template. In the present paper, we bring the idea one dimension\nhigher and advocate that template games should not be just defined as\n1-dimensional categories but as 2-dimensional categories of positions,\ntrajectories and reshufflings (or reschedulings) as 2-cells. In order to\nachieve the purpose, we take seriously the parallel between asynchrony in\nconcurrency and the Gray tensor product of 2-categories. One technical\ndifficulty on the way is that the category S=2-Cat of small 2-categories\nequipped with the Gray tensor product is monoidal, and not cartesian. This\nprompts us to extend the framework of template games originally formulated by\nMelli\\`es in a category S with finite limits, and to upgrade it in the style of\nAguiar's work on quantum groups to the more general situation of a monoidal\ncategory S with coreflexive equalizers, preserved by the tensor product\ncomponentwise. We construct in this way an asynchronous template game semantics\nof multiplicative additive linear logic (MALL) where every formula and every\nproof is interpreted as a labelled 2-category equipped, respectively, with the\nstructure of Gray comonoid for asynchronous template games, and of Gray\nbicomodule for asynchronous strategies.\n", "versions": [{"version": "v1", "created": "Tue, 11 May 2021 10:33:04 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Paul-Andr\u00e9", "Melli\u00e8s", ""]]}, {"id": "2105.04958", "submitter": "Chad Nester", "authors": "Chad Nester", "title": "A Variety Theorem for Relational Universal Algebra", "comments": "14 pages including bibliography and appendix. Rejected from LICS2021,\n  currently searching for a conference to call home", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop an analogue of universal algebra in which generating symbols are\ninterpreted as relations. We prove a variety theorem for these relational\nalgebraic theories, in which we find that their categories of models are\nprecisely the definable categories. The syntax of our relational algebraic\ntheories is string-diagrammatic, and can be seen as an extension of the usual\nterm syntax for algebraic theories.\n", "versions": [{"version": "v1", "created": "Tue, 11 May 2021 11:53:22 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Nester", "Chad", ""]]}, {"id": "2105.05133", "submitter": "Simon Foster", "authors": "Simon Foster, Chung-Kil Hur, Jim Woodcock", "title": "Formally Verified Simulations of State-Rich Processes using Interaction\n  Trees in Isabelle/HOL", "comments": "14 pages, submitted to CONCUR 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Simulation and formal verification are important complementary techniques\nnecessary in high assurance model-based systems development. In order to\nsupport coherent results, it is necessary to provide unifying semantics and\nautomation for both activities. In this paper we apply Interaction Trees in\nIsabelle/HOL to produce a verification and simulation framework for state-rich\nprocess languages. We develop the core theory and verification techniques for\nInteraction Trees, use them to give a semantics to the CSP and Circus\nlanguages, and formally link our new semantics with the failures-divergences\nsemantic model. We also show how the Isabelle code generator can be used to\ngenerate verified executable simulations for reactive and concurrent programs.\n", "versions": [{"version": "v1", "created": "Tue, 11 May 2021 15:43:39 GMT"}], "update_date": "2021-05-12", "authors_parsed": [["Foster", "Simon", ""], ["Hur", "Chung-Kil", ""], ["Woodcock", "Jim", ""]]}, {"id": "2105.05626", "submitter": "Yuri Gurevich", "authors": "Yuri Gurevich", "title": "Reversify any sequential algorithm", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.DS cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  To reversify an arbitrary sequential algorithm $A$, we gently instrument $A$\nwith bookkeeping machinery. The result is a step-for-step reversible algorithm\nthat mimics $A$ step-for-step and stops exactly when $A$ does.\n  Without loss of generality, we presume that algorithm $A$ is presented as an\nabstract state machine that is behaviorally identical to $A$. The existence of\nsuch representation has been proven theoretically, and the practicality of such\nrepresentation has been amply demonstrated.\n", "versions": [{"version": "v1", "created": "Wed, 12 May 2021 12:48:24 GMT"}, {"version": "v2", "created": "Fri, 25 Jun 2021 22:27:49 GMT"}], "update_date": "2021-06-29", "authors_parsed": [["Gurevich", "Yuri", ""]]}, {"id": "2105.05763", "submitter": "Marko Schmellenkamp", "authors": "Gaetano Geck, Christine Quenkert, Marko Schmellenkamp, Jonas Schmidt,\n  Felix Tschirbs, Fabian Vehlken, Thomas Zeume", "title": "Iltis: Teaching Logic in the Web", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The Iltis project provides an interactive, web-based system for teaching the\nfoundations of formal methods. It is designed to allow modular addition of\neducational tasks as well as to provide immediate and comprehensive feedback.\nCurrently, exercises for various aspects of typical automated reasoning\nworkflows for propositional logic, modal logic, and first-order logic are\ncovered.\n  Recently, Iltis has reached a level of maturity where large parts of\nintroductory logic courses can be supplemented with interactive exercises.\nSample interactive course material has been designed and used in such courses\nwith more than 200 students.\n  We invite all readers to give it a try!\n", "versions": [{"version": "v1", "created": "Wed, 12 May 2021 16:30:53 GMT"}], "update_date": "2021-05-13", "authors_parsed": [["Geck", "Gaetano", ""], ["Quenkert", "Christine", ""], ["Schmellenkamp", "Marko", ""], ["Schmidt", "Jonas", ""], ["Tschirbs", "Felix", ""], ["Vehlken", "Fabian", ""], ["Zeume", "Thomas", ""]]}, {"id": "2105.06001", "submitter": "Niku Gorji", "authors": "Niku Gorji, Sasha Rubin", "title": "Sufficient reasons for classifier decisions in the presence of\n  constraints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent work has unveiled a theory for reasoning about the decisions made by\nbinary classifiers: a classifier describes a Boolean function, and the reasons\nbehind an instance being classified as positive are the prime-implicants of the\nfunction that are satisfied by the instance. One drawback of these works is\nthat they do not explicitly treat scenarios where the underlying data is known\nto be constrained, e.g., certain combinations of features may not exist, may\nnot be observable, or may be required to be disregarded. We propose a more\ngeneral theory, also based on prime-implicants, tailored to taking constraints\ninto account. The main idea is to view classifiers in the presence of\nconstraints as describing partial Boolean functions, i.e., that are undefined\non instances that do not satisfy the constraints. We prove that this simple\nidea results in reasons that are no less (and sometimes more) succinct. That\nis, not taking constraints into account (e.g., ignored, or taken as negative\ninstances) results in reasons that are subsumed by reasons that do take\nconstraints into account. We illustrate this improved parsimony on synthetic\nclassifiers and classifiers learned from real data.\n", "versions": [{"version": "v1", "created": "Wed, 12 May 2021 23:36:12 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Gorji", "Niku", ""], ["Rubin", "Sasha", ""]]}, {"id": "2105.06009", "submitter": "Franck Cassez", "authors": "Franck Cassez", "title": "Verification of the Incremental Merkle Tree Algorithm with Dafny", "comments": "16 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The Deposit Smart Contract (DSC) is an instrumental component of the Ethereum\n2.0 Phase 0 infrastructure. We have developed the first machine-checkable\nversion of the incremental Merkle tree algorithm used in the DSC. We present\nour new and original correctness proof of the algorithm along with the Dafny\nmachine-checkable version. The main results are: 1) a new proof of total\ncorrectness; 2) a software artefact with the proof in the form of the complete\nDafny code base and 3) new provably correct optimisations of the algorithm.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 00:32:38 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Cassez", "Franck", ""]]}, {"id": "2105.06024", "submitter": "Siva Somayyajula", "authors": "Siva Somayyajula, Frank Pfenning", "title": "Circular Proofs as Processes: Type-Based Termination via Arithmetic\n  Refinements", "comments": "14 pages. Submitted to CONCUR 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Type systems for concurrent programs guarantee such desirable properties as\ncommunication safety and type refinements facilitate the verification of\nprogram invariants. Yet, type-based termination of recursive concurrent\nprograms has been largely unexplored. On the other hand, sized types enable\ntermination checking of functional programs with complex patterns of recursion\nin the presence of mixed inductive and coinductive types. In this paper, we\nadapt sized types to the concurrent setting. In particular, we extend a core\nlanguage for persistent shared memory concurrency based on the semi-axiomatic\nsequent calculus with recursive types and arithmetic refinements to express\nsize indexing. To prove termination of program reduction, we first define a\nnovel semantic model that reflects persistence in the type system and admits a\nstraightforward generalization to substructural typing. We then develop a\ncompositional validity condition for recursive concurrent programs viewed as\ncircular proofs that guarantees termination.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 01:21:30 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Somayyajula", "Siva", ""], ["Pfenning", "Frank", ""]]}, {"id": "2105.06186", "submitter": "Nicolas Behr", "authors": "Nicolas Behr (Universit\\'e de Paris, CNRS, IRIF) and Joachim Kock\n  (Universitat Aut\\`onoma de Barcelona)", "title": "Tracelet Hopf algebras and decomposition spaces", "comments": "15+9 pages; Applied Category Theory 2021 pre-proceedings version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Tracelets are the intrinsic carriers of causal information in categorical\nrewriting systems. In this work, we assemble tracelets into a symmetric\nmonoidal decomposition space, inducing a cocommutative Hopf algebra of\ntracelets. This Hopf algebra captures important combinatorial and algebraic\naspects of rewriting theory, and is motivated by applications of its\nrepresentation theory to stochastic rewriting systems such as chemical reaction\nnetworks.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 10:59:16 GMT"}, {"version": "v2", "created": "Tue, 13 Jul 2021 17:36:49 GMT"}], "update_date": "2021-07-14", "authors_parsed": [["Behr", "Nicolas", "", "Universit\u00e9 de Paris, CNRS, IRIF"], ["Kock", "Joachim", "", "Universitat Aut\u00f2noma de Barcelona"]]}, {"id": "2105.06194", "submitter": "Vincenzo Ciancia", "authors": "Nick Bezhanishvili and Vincenzo Ciancia and David Gabelaia and\n  Gianluca Grilletti and Diego Latella and Mieke Massink", "title": "Geometric Model Checking of Continuous Space", "comments": "26 pages, 7 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.CV cs.GR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Topological Spatial Model Checking is a recent paradigm that combines Model\nChecking with the topological interpretation of Modal Logic. The Spatial Logic\nof Closure Spaces, SLCS, extends Modal Logic with reachability connectives\nthat, in turn, can be used for expressing interesting spatial properties, such\nas \"being near to\" or \"being surrounded by\". SLCS constitutes the kernel of a\nsolid logical framework for reasoning about discrete space, such as graphs and\ndigital images, interpreted as quasi discrete closure spaces. In particular,\nthe spatial model checker VoxLogicA, that uses an extended version of SLCS, has\nbeen used successfully in the domain of medical imaging. However, SLCS is not\nrestricted to discrete space. Following a recently developed geometric\nsemantics of Modal Logic, we show that it is possible to assign an\ninterpretation to SLCS in continuous space, admitting a model checking\nprocedure, by resorting to models based on polyhedra. In medical imaging such\nrepresentations of space are increasingly relevant, due to recent developments\nof 3D scanning and visualisation techniques that exploit mesh processing. We\ndemonstrate feasibility of our approach via a new tool, PolyLogicA, aimed at\nefficient verification of SLCS formulas on polyhedra, while inheriting some\nwell-established optimization techniques already adopted in VoxLogicA. Finally,\nwe cater for a geometric definition of bisimilarity, proving that it\ncharacterises logical equivalence.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 11:25:25 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Bezhanishvili", "Nick", ""], ["Ciancia", "Vincenzo", ""], ["Gabelaia", "David", ""], ["Grilletti", "Gianluca", ""], ["Latella", "Diego", ""], ["Massink", "Mieke", ""]]}, {"id": "2105.06202", "submitter": "Agi Kurucz", "authors": "Agi Kurucz, Vladislav Ryzhikov, Yury Savateev, and Michael\n  Zakharyaschev", "title": "Deciding FO-definability of Regular Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that, similarly to known PSpace-completeness of recognising\nFO(<)-definability of the language L(A) of a DFA A, deciding both FO(<,C)- and\nFO(<,MOD)-definability are PSpace-complete. (Here, FO(<,C) extends the\nfirst-order logic FO(<) with the standard congruence modulo n relation, and\nFO(<,MOD) with the quantifiers checking whether the number of positions\nsatisfying a given formula is divisible by a given n>1. These FO-languages are\nknown to define regular languages that are decidable in AC0 and ACC0,\nrespectively.) We obtain these results by first showing that known algebraic\ncharacterisations of FO-definability of L(A) can be captured by `localisable'\nproperties of the transition monoid of A. Using our criterion, we then\ngeneralise the known proof of PSpace-hardness of FO(<)-definability, and\nestablish the upper bounds not only for arbitrary DFAs but also for two-way\nNFAs.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 11:45:07 GMT"}, {"version": "v2", "created": "Fri, 21 May 2021 09:43:39 GMT"}, {"version": "v3", "created": "Tue, 25 May 2021 10:38:14 GMT"}, {"version": "v4", "created": "Thu, 3 Jun 2021 12:56:27 GMT"}], "update_date": "2021-06-04", "authors_parsed": [["Kurucz", "Agi", ""], ["Ryzhikov", "Vladislav", ""], ["Savateev", "Yury", ""], ["Zakharyaschev", "Michael", ""]]}, {"id": "2105.06244", "submitter": "Cole Comfort", "authors": "Cole Comfort, Aleks Kissinger", "title": "A Graphical Calculus for Lagrangian Relations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math-ph math.CT math.MP quant-ph", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Symplectic vector spaces are the phase space of linear mechanical systems.\nThe symplectic form describes, for example, the relation between position and\nmomentum as well as current and voltage. The category of linear Lagrangian\nrelations between symplectic vector spaces is a symmetric monoidal subcategory\nof relations which gives a semantics for the evolution -- and more generally\nlinear constraints on the evolution -- of various physical systems.\n  We give a new presentation of the category of Lagrangian relations over an\narbitrary field as a `doubled' category of linear relations. More precisely, we\nshow that it arises as a variation of Selinger's CPM construction applied to\nlinear relations, where the covariant orthogonal complement functor plays of\nthe role of conjugation. Furthermore, for linear relations over prime fields,\nthis corresponds exactly to the CPM construction for a suitable choice of\ndagger. We can furthermore extend this construction by a single affine shift\noperator to obtain a category of affine Lagrangian relations. Using this new\npresentation, we prove the equivalence of the prop of affine Lagrangian\nrelations with the prop of qudit stabilizer theory in odd prime dimensions. We\nhence obtain a unified graphical language for several disparate process\ntheories, including electrical circuits, Spekkens' toy theory, and\nodd-prime-dimensional stabilizer quantum circuits.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 12:46:52 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Comfort", "Cole", ""], ["Kissinger", "Aleks", ""]]}, {"id": "2105.06319", "submitter": "Lawrence Paulson", "authors": "Lawrence C. Paulson", "title": "The Inductive Approach to Verifying Cryptographic Protocols", "comments": null, "journal-ref": "J. Computer Security 6 (1998), 85-128", "doi": "10.3233/JCS-1998-61-205", "report-no": null, "categories": "cs.CR cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Informal arguments that cryptographic protocols are secure can be made\nrigorous using inductive definitions. The approach is based on ordinary\npredicate calculus and copes with infinite-state systems. Proofs are generated\nusing Isabelle/HOL. The human effort required to analyze a protocol can be as\nlittle as a week or two, yielding a proof script that takes a few minutes to\nrun.\n  Protocols are inductively defined as sets of traces. A trace is a list of\ncommunication events, perhaps comprising many interleaved protocol runs.\nProtocol descriptions incorporate attacks and accidental losses. The model spy\nknows some private keys and can forge messages using components decrypted from\nprevious traffic. Three protocols are analyzed below: Otway-Rees (which uses\nshared-key encryption), Needham-Schroeder (which uses public-key encryption),\nand a recursive protocol by Bull and Otway (which is of variable length).\n  One can prove that event $ev$ always precedes event $ev'$ or that property\n$P$ holds provided $X$ remains secret. Properties can be proved from the\nviewpoint of the various principals: say, if $A$ receives a final message from\n$B$ then the session key it conveys is good.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 14:17:05 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Paulson", "Lawrence C.", ""]]}, {"id": "2105.06424", "submitter": "Viktor Toman", "authors": "Pratyush Agarwal, Krishnendu Chatterjee, Shreya Pathak, Andreas\n  Pavlogiannis, Viktor Toman", "title": "Stateless Model Checking under a Reads-Value-From Equivalence", "comments": "Full technical report of the CAV2021 work", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Stateless model checking (SMC) is one of the standard approaches to the\nverification of concurrent programs. As scheduling non-determinism creates\nexponentially large spaces of thread interleavings, SMC attempts to partition\nthis space into equivalence classes and explore only a few representatives from\neach class. The efficiency of this approach depends on two factors: (a) the\ncoarseness of the partitioning, and (b) the time to generate representatives in\neach class. For this reason, the search for coarse partitionings that are\nefficiently explorable is an active research challenge.\n  In this work we present RVF-SMC, a new SMC algorithm that uses a novel\n\\emph{reads-value-from (RVF)} partitioning. Intuitively, two interleavings are\ndeemed equivalent if they agree on the value obtained in each read event, and\nread events induce consistent causal orderings between them. The RVF\npartitioning is provably coarser than recent approaches based on Mazurkiewicz\nand \"reads-from\" partitionings. Our experimental evaluation reveals that RVF is\nquite often a very effective equivalence, as the underlying partitioning is\nexponentially coarser than other approaches. Moreover, RVF-SMC generates\nrepresentatives very efficiently, as the reduction in the partitioning is often\nmet with significant speed-ups in the model checking task.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 17:00:07 GMT"}], "update_date": "2021-05-14", "authors_parsed": [["Agarwal", "Pratyush", ""], ["Chatterjee", "Krishnendu", ""], ["Pathak", "Shreya", ""], ["Pavlogiannis", "Andreas", ""], ["Toman", "Viktor", ""]]}, {"id": "2105.06575", "submitter": "Daniel Larraz", "authors": "Daniel Larraz, Micka\\\"el Laurent, Cesare Tinelli", "title": "Merit and Blame Assignment with Kind 2", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We introduce two new major features of the open-source model checker Kind 2\nwhich provide traceability information between specification and design\nelements such as assumptions, guarantees, or other behavioral constraints in\nsynchronous reactive system models. This new version of Kind 2 can identify\nminimal sets of design elements, known as Minimal Inductive Validity Cores,\nwhich are sufficient to prove a given set of safety properties, and also\ndetermine the set of MUST elements, design elements that are necessary to prove\nthe given properties. In addition, Kind 2 is able to find minimal sets of\ndesign constraints, known as Minimal Cut Sets, whose violation leads the system\nto an unsafe state. The computed information can be used for several purposes,\nincluding assessing the quality of a system specification, tracking the safety\nimpact of model changes, and analyzing the tolerance and resilience of a system\nagainst faults or cyber-attacks. We describe these new capabilities in some\ndetail and report on an initial experimental evaluation of some of them.\n", "versions": [{"version": "v1", "created": "Thu, 13 May 2021 22:40:09 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Larraz", "Daniel", ""], ["Laurent", "Micka\u00ebl", ""], ["Tinelli", "Cesare", ""]]}, {"id": "2105.06686", "submitter": "James C. A. Main", "authors": "James C. A. Main, Mickael Randour, Jeremy Sproston", "title": "Time Flies When Looking out of the Window: Timed Games with Window\n  Parity Objectives", "comments": "Full version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The window mechanism was introduced by Chatterjee et al. to reinforce\nmean-payoff and total-payoff objectives with time bounds in two-player\nturn-based games on graphs. It has since proved useful in a variety of\nsettings, including parity objectives in games and both mean-payoff and parity\nobjectives in Markov decision processes.\n  We study window parity objectives in timed automata and timed games: given a\nbound on the window size, a path satisfies such an objective if, in all states\nalong the path, we see a sufficiently small window in which the smallest\npriority is even. We show that checking that all time-divergent paths of a\ntimed automaton satisfy such a window parity objective can be done in\npolynomial space, and that the corresponding timed games can be solved in\nexponential time. This matches the complexity class of timed parity games,\nwhile adding the ability to reason about time bounds. We also consider\nmulti-dimensional objectives and show that the complexity class does not\nincrease. To the best of our knowledge, this is the first study of the window\nmechanism in a real-time setting.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 07:52:50 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Main", "James C. A.", ""], ["Randour", "Mickael", ""], ["Sproston", "Jeremy", ""]]}, {"id": "2105.06690", "submitter": "Diego Latella", "authors": "Vincenzo Ciancia and Diego Latella and Mieke Massink Erik de Vink", "title": "On Bisimilarities for Closure Spaces - Preliminary Version", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Closure spaces are a generalisation of topological spaces obtained by\nremoving the idempotence requirement on the closure operator. We adapt the\nstandard notion of bisimilarity for topological models, namely\nTopo-bisimilarity, to closure models -- we call the resulting equivalence\nCM-bisimilarity -- and refine it for quasi-discrete closure models. We also\ndefine two additional notions of bisimilarity that are based on paths on space,\nnamely Path-bisimilarity and Compatible Path-bisimilarity, CoPa-bisimilarity\nfor short. The former expresses (unconditional) reachability, the latter\nrefines it in a way that is reminishent of Stuttering Equivalence on transition\nsystems. For each bisimilarity we provide a logical characterisation, using\nvariants of the Spatial Logic for Closure Spaces (SLCS). We also address the\nissue of (space) minimisation via the three equivalences.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 08:07:50 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Ciancia", "Vincenzo", ""], ["Latella", "Diego", ""], ["de Vink", "Mieke Massink Erik", ""]]}, {"id": "2105.06723", "submitter": "Amrita Suresh", "authors": "Benedikt Bollig, Alain Finkel, Amrita Suresh", "title": "Bounded Reachability Problems are Decidable in FIFO Machines", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The undecidability of basic decision problems for general FIFO machines such\nas reachability and unboundedness is well-known. In this paper, we provide an\nunderapproximation for the general model by considering only runs that are\ninput-bounded (i.e.\\ the sequence of messages sent through a particular channel\nbelongs to a given bounded language). We prove, by reducing this model to a\ncounter machine with restricted zero tests, that the rational-reachability\nproblem (and by extension, control-state reachability, unboundedness, deadlock,\netc.) is decidable. This class of machines subsumes input-letter-bounded\nmachines, flat machines, linear FIFO nets, and monogeneous machines, for which\nsome of these problems were already shown to be decidable. These theoretical\nresults can form the foundations to build a tool to verify general FIFO\nmachines based on the analysis of input-bounded machines.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 09:13:33 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Bollig", "Benedikt", ""], ["Finkel", "Alain", ""], ["Suresh", "Amrita", ""]]}, {"id": "2105.06744", "submitter": "Navid Talebanfard", "authors": "Michal Kouck\\'y, Vojt\\v{e}ch R\\\"odl, Navid Talebanfard", "title": "A Separator Theorem for Hypergraphs and a CSP-SAT Algorithm", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We show that for every $r \\ge 2$ there exists $\\epsilon_r > 0$ such that any\n$r$-uniform hypergraph on $m$ edges with bounded vertex degree has a set of at\nmost $(\\frac{1}{2} - \\epsilon_r)m$ edges the removal of which breaks the\nhypergraph into connected components with at most $m/2$ edges. We use this to\ngive an algorithm running in time $d^{(1 - \\epsilon_r)m}$ that decides\nsatisfiability of $m$-variable $(d, k)$-CSPs in which every variable appears in\nat most $r$ constraints, where $\\epsilon_r$ depends only on $r$ and $k\\in\no(\\sqrt{m})$. Furthermore our algorithm solves the corresponding #CSP-SAT and\nMax-CSP-SAT of these CSPs. We also show that CNF representations of\nunsatisfiable $(2, k)$-CSPs with variable frequency $r$ can be refuted in\ntree-like resolution in size $2^{(1 - \\epsilon_r)m}$. Furthermore for Tseitin\nformulas on graphs with degree at most $k$ (which are $(2, k)$-CSPs) we give a\ndeterministic algorithm finding such a refutation.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 10:09:18 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Kouck\u00fd", "Michal", ""], ["R\u00f6dl", "Vojt\u011bch", ""], ["Talebanfard", "Navid", ""]]}, {"id": "2105.06782", "submitter": "Alexey Ignatiev", "authors": "Alexey Ignatiev and Joao Marques-Silva", "title": "SAT-Based Rigorous Explanations for Decision Lists", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Decision lists (DLs) find a wide range of uses for classification problems in\nMachine Learning (ML), being implemented in a number of ML frameworks. DLs are\noften perceived as interpretable. However, building on recent results for\ndecision trees (DTs), we argue that interpretability is an elusive goal for\nsome DLs. As a result, for some uses of DLs, it will be important to compute\n(rigorous) explanations. Unfortunately, and in clear contrast with the case of\nDTs, this paper shows that computing explanations for DLs is computationally\nhard. Motivated by this result, the paper proposes propositional encodings for\ncomputing abductive explanations (AXps) and contrastive explanations (CXps) of\nDLs. Furthermore, the paper investigates the practical efficiency of a\nMARCO-like approach for enumerating explanations. The experimental results\ndemonstrate that, for DLs used in practical settings, the use of SAT oracles\noffers a very efficient solution, and that complete enumeration of explanations\nis most often feasible.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 12:06:12 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Ignatiev", "Alexey", ""], ["Marques-Silva", "Joao", ""]]}, {"id": "2105.06787", "submitter": "Ja\\v{s} \\v{S}emrl", "authors": "Robin Hirsch and Ja\\v{s} \\v{S}emrl", "title": "Demonic Lattices and Semilattices in Relational Semigroups with Ordinary\n  Composition", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Relation algebra and its reducts provide us with a strong tool for reasoning\nabout nondeterministic programs and their partial correctness. Demonic\ncalculus, introduced to model the behaviour of a machine where the demon is in\ncontrol of nondeterminism, has also provided us with an extension of that\nreasoning to total correctness.\n  We formalise the framework for relational reasoning about total correctness\nin nondeterministic programs using semigroups with ordinary composition and\ndemonic lattice operations. We show that the class of representable demonic\njoin semigroups is not finitely axiomatisable and that the representation class\nof demonic meet semigroups does not have the finite representation property for\nits finite members.\n  For lattice semigroups (with composition, demonic join and demonic meet) we\nshow that the representation problem for finite algebras is undecidable,\nmoreover the finite representation problem is also undecidable. It follows that\nthe representation class is not finitely axiomatisable, furthermore the finite\nrepresentation property fails.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 12:09:51 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Hirsch", "Robin", ""], ["\u0160emrl", "Ja\u0161", ""]]}, {"id": "2105.06908", "submitter": "Bart Jacobs", "authors": "Bart Jacobs", "title": "From Multisets over Distributions to Distributions over Multisets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A well-known challenge in the semantics of programming languages is how to\ncombine non-determinism and probability. At a technical level, the problem\narises from the fact that there is a no distributive law between the powerset\nmonad and the distribution monad - as noticed some twenty years ago by Plotkin.\nMore recently, it has become clear that there is a distributive law of the\nmultiset monad over the distribution monad. This article elaborates the details\nof this distributivity and shows that there is a rich underlying theory\nrelating multisets and probability distributions. It is shown that the new\ndistributive law, called parallel multinomial law, can be defined in (at least)\nfour equivalent ways. It involves putting multinomial distributions in parallel\nand commutes with hypergeometric distributions. Further, it is shown that this\ndistributive law commutes with a new form of zipping for multisets. Abstractly,\nthis can be described in terms of monoidal structure for a fixed-size multiset\nfunctor, when lifted to the Kleisli category of the distribution monad.\nConcretely, an application of the theory to sampling semantics is included.\n", "versions": [{"version": "v1", "created": "Fri, 14 May 2021 15:47:37 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Jacobs", "Bart", ""]]}, {"id": "2105.07525", "submitter": "Tuomas Hakoniemi", "authors": "Tuomas Hakoniemi", "title": "Monomial-size vs. Bit-complexity in Sums-of-Squares and Polynomial\n  Calculus", "comments": "To appear in the Proceedings of the 36th Annual ACM/IEEE Symposium on\n  Logic in Computer Science (LICS 2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper we consider the relationship between monomial-size and\nbit-complexity in Sums-of-Squares (SOS) in Polynomial Calculus Resolution over\nrationals (PCR/$\\mathbb{Q}$). We show that there is a set of polynomial\nconstraints $Q_n$ over Boolean variables that has both SOS and PCR/$\\mathbb{Q}$\nrefutations of degree 2 and thus with only polynomially many monomials, but for\nwhich any SOS or PCR/$\\mathbb{Q}$ refutation must have exponential\nbit-complexity, when the rational coefficients are represented with their\nreduced fractions written in binary.\n", "versions": [{"version": "v1", "created": "Sun, 16 May 2021 21:50:31 GMT"}], "update_date": "2021-05-18", "authors_parsed": [["Hakoniemi", "Tuomas", ""]]}, {"id": "2105.07531", "submitter": "Iddo Tzameret", "authors": "Fedor Part, Neil Thapen, Iddo Tzameret", "title": "First-Order Reasoning and Efficient Semi-Algebraic Proofs", "comments": "A preliminary version of this work appears in 36th Ann. Symp. Logic\n  Comput. Science (LICS) 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Semi-algebraic proof systems such as sum-of-squares (SoS) have attracted a\nlot of attention recently due to their relation to approximation algorithms:\nconstant degree semi-algebraic proofs lead to conjecturally optimal\npolynomial-time approximation algorithms for important NP-hard optimization\nproblems. Motivated by the need to allow a more streamlined and uniform\nframework for working with SoS proofs than the restrictive propositional level,\nwe initiate a systematic first-order logical investigation into the kinds of\nreasoning possible in algebraic and semi-algebraic proof systems. Specifically,\nwe develop first-order theories that capture in a precise manner constant\ndegree algebraic and semi-algebraic proof systems: every statement of a certain\nform that is provable in our theories translates into a family of constant\ndegree polynomial calculus or SoS refutations, respectively; and using a\nreflection principle, the converse also holds.\n  This places algebraic and semi-algebraic proof systems in the established\nframework of bounded arithmetic, while providing theories corresponding to\nsystems that vary quite substantially from the usual propositional-logic ones.\n  We give examples of how our semi-algebraic theory proves statements such as\nthe pigeonhole principle, we provide a separation between algebraic and\nsemi-algebraic theories, and we describe initial attempts to go beyond these\ntheories by introducing extensions that use the inequality symbol, identifying\nalong the way which extensions lead outside the scope of constant degree SoS.\nMoreover, we prove new results for propositional proofs, and specifically\nextend Berkholz's dynamic-by-static simulation of polynomial calculus (PC) by\nSoS to PC with the radical rule.\n", "versions": [{"version": "v1", "created": "Sun, 16 May 2021 22:20:55 GMT"}, {"version": "v2", "created": "Tue, 18 May 2021 23:23:58 GMT"}], "update_date": "2021-05-20", "authors_parsed": [["Part", "Fedor", ""], ["Thapen", "Neil", ""], ["Tzameret", "Iddo", ""]]}, {"id": "2105.07595", "submitter": "Xinxin Liu", "authors": "Xinxin Liu and Tingting Yu", "title": "A Complete Axiomatisation for Divergence Preserving Branching Congruence\n  of Finite-State Behaviours", "comments": "13 pages. To be published in LICS2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We present an equational inference system for finite-state expressions, and\nprove that the system is sound and complete with respect to divergence\npreserving branching congruence, closing a problem that has been open since\n1993. The inference system refines Rob van Glabbeek's simple and elegant\ncomplete axiomatisation for branching bisimulation congruence of finite-state\nbehaviours by joining four simple axioms after dropping one axiom which is\nunsound under the more refined divergence sensitive semantics.\n", "versions": [{"version": "v1", "created": "Mon, 17 May 2021 03:57:14 GMT"}], "update_date": "2021-05-18", "authors_parsed": [["Liu", "Xinxin", ""], ["Yu", "Tingting", ""]]}, {"id": "2105.07648", "submitter": "Jieting Luo", "authors": "Jieting Luo, Beishui Liao, John-Jules Meyer", "title": "A Formal Framework for Reasoning about Agents' Independence in\n  Self-organizing Multi-agent Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Self-organization is a process where a stable pattern is formed by the\ncooperative behavior between parts of an initially disordered system without\nexternal control or influence. It has been introduced to multi-agent systems as\nan internal control process or mechanism to solve difficult problems\nspontaneously. However, because a self-organizing multi-agent system has\nautonomous agents and local interactions between them, it is difficult to\npredict the behavior of the system from the behavior of the local agents we\ndesign. This paper proposes a logic-based framework of self-organizing\nmulti-agent systems, where agents interact with each other by following their\nprescribed local rules. The dependence relation between coalitions of agents\nregarding their contributions to the global behavior of the system is reasoned\nabout from the structural and semantic perspectives. We show that the\ncomputational complexity of verifying such a self-organizing multi-agent system\nis in exponential time. We then combine our framework with graph theory to\ndecompose a system into different coalitions located in different layers, which\nallows us to verify agents' full contributions more efficiently. The resulting\ninformation about agents' full contributions allows us to understand the\ncomplex link between local agent behavior and system level behavior in a\nself-organizing multi-agent system. Finally, we show how we can use our\nframework to model a constraint satisfaction problem.\n", "versions": [{"version": "v1", "created": "Mon, 17 May 2021 07:32:43 GMT"}, {"version": "v2", "created": "Fri, 21 May 2021 11:50:42 GMT"}, {"version": "v3", "created": "Wed, 26 May 2021 06:20:35 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Luo", "Jieting", ""], ["Liao", "Beishui", ""], ["Meyer", "John-Jules", ""]]}, {"id": "2105.07663", "submitter": "Sophie Rain", "authors": "Neta Elad, Sophie Rain, Neil Immerman, Laura Kov\\'acs and Mooly Sagiv", "title": "Summing Up Smart Transitions", "comments": "This submission is an extended version of the CAV 2021 paper \"Summing\n  Up Smart Transitions\", by N. Elad, S. Rain, N. Immerman, L. Kov\\'acs and M.\n  Sagiv", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/publicdomain/zero/1.0/", "abstract": "  Some of the most significant high-level properties of currencies are the sums\nof certain account balances. Properties of such sums can ensure the integrity\nof currencies and transactions. For example, the sum of balances should not be\nchanged by a transfer operation. Currencies manipulated by code present a\nverification challenge to mathematically prove their integrity by reasoning\nabout computer programs that operate over them, e.g., in Solidity. The ability\nto reason about sums is essential: even the simplest ERC-20 token standard of\nthe Ethereum community provides a way to access the total supply of balances.\n  Unfortunately, reasoning about code written against this interface is\nnon-trivial: the number of addresses is unbounded, and establishing global\ninvariants like the preservation of the sum of the balances by operations like\ntransfer requires higher-order reasoning. In particular, automated reasoners do\nnot provide ways to specify summations of arbitrary length.\n  In this paper, we present a generalization of first-order logic which can\nexpress the unbounded sum of balances. We prove the decidablity of one of our\nextensions and the undecidability of a slightly richer one. We introduce\nfirst-order encodings to automate reasoning over software transitions with\nsummations. We demonstrate the applicability of our results by using SMT\nsolvers and first-order provers for validating the correctness of common\ntransitions in smart contracts.\n", "versions": [{"version": "v1", "created": "Mon, 17 May 2021 08:26:14 GMT"}], "update_date": "2021-05-18", "authors_parsed": [["Elad", "Neta", ""], ["Rain", "Sophie", ""], ["Immerman", "Neil", ""], ["Kov\u00e1cs", "Laura", ""], ["Sagiv", "Mooly", ""]]}, {"id": "2105.07734", "submitter": "Stefan Hetzl", "authors": "Stefan Hetzl, Jannik Vierling", "title": "Induction and Skolemization in saturation theorem proving", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We consider a typical integration of induction in saturation-based theorem\nprovers and investigate the effects of Skolem symbols occurring in the\ninduction formulas. In a practically relevant setting we establish a\nSkolem-free characterization of refutation in saturation-based proof systems\nwith induction. Finally, we use this characterization to obtain unprovability\nresults for a concrete saturation-based induction prover.\n", "versions": [{"version": "v1", "created": "Mon, 17 May 2021 11:06:16 GMT"}], "update_date": "2021-05-18", "authors_parsed": [["Hetzl", "Stefan", ""], ["Vierling", "Jannik", ""]]}, {"id": "2105.08155", "submitter": "Daniel Jeffries", "authors": "Patricia Johann, Enrico Ghiorzi, Daniel Jeffries", "title": "(Deep) Induction Rules for GADTs", "comments": "13 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deep data types are those that are defined in terms of other such data types,\nincluding, possibly, themselves. In that case, they are said to be truly\nnested. Deep induction is an extension of structural induction that traverses\nall of the structure in a deep data type, propagating predicates on its\nprimitive data throughout the entire structure. Deep induction can be used to\nprove properties of nested types, including truly nested types, that cannot be\nproved via structural induction. In this paper we show how to extend deep\ninduction to deep GADTs that are not truly nested. We also show that deep\ninduction cannot be extended to truly nested GADTs.\n", "versions": [{"version": "v1", "created": "Mon, 17 May 2021 20:49:56 GMT"}], "update_date": "2021-05-19", "authors_parsed": [["Johann", "Patricia", ""], ["Ghiorzi", "Enrico", ""], ["Jeffries", "Daniel", ""]]}, {"id": "2105.08231", "submitter": "David Fern\\'andez-Duque", "authors": "Alexandru Baltag, Nick Bezhanishvili, David Fern\\'andez-Duque", "title": "The Topological Mu-Calculus: completeness and decidability", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the topological $\\mu$-calculus, based on both Cantor derivative and\nclosure modalities, proving completeness, decidability and FMP over general\ntopological spaces, as well as over $T_0$ and $T_D$ spaces. We also investigate\nrelational $\\mu$-calculus, providing general completeness results for all\nnatural fragments of $\\mu$-calculus over many different classes of relational\nframes. Unlike most other such proofs for $\\mu$-calculus, ours is\nmodel-theoretic, making an innovative use of a known Modal Logic method (--the\n'final' submodel of the canonical model), that has the twin advantages of great\ngenerality and essential simplicity.\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 02:16:47 GMT"}], "update_date": "2021-05-19", "authors_parsed": [["Baltag", "Alexandru", ""], ["Bezhanishvili", "Nick", ""], ["Fern\u00e1ndez-Duque", "David", ""]]}, {"id": "2105.08353", "submitter": "N. Ege Sara\\c{c}", "authors": "Thomas A. Henzinger and N. Ege Sara\\c{c}", "title": "Quantitative and Approximate Monitoring", "comments": "To appear in LICS 2021; corrected a reference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In runtime verification, a monitor watches a trace of a system and, if\npossible, decides after observing each finite prefix whether or not the unknown\ninfinite trace satisfies a given specification. We generalize the theory of\nruntime verification to monitors that attempt to estimate numerical values of\nquantitative trace properties (instead of attempting to conclude boolean values\nof trace specifications), such as maximal or average response time along a\ntrace. Quantitative monitors are approximate: with every finite prefix, they\ncan improve their estimate of the infinite trace's unknown property value.\nConsequently, quantitative monitors can be compared with regard to a\nprecision-cost trade-off: better approximations of the property value require\nmore monitor resources, such as states (in the case of finite-state monitors)\nor registers, and additional resources yield better approximations. We\nintroduce a formal framework for quantitative and approximate monitoring, show\nhow it conservatively generalizes the classical boolean setting for monitoring,\nand give several precision-cost trade-offs for monitors. For example, we prove\nthat there are quantitative properties for which every additional register\nimproves monitoring precision.\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 08:24:31 GMT"}, {"version": "v2", "created": "Wed, 16 Jun 2021 08:22:44 GMT"}], "update_date": "2021-06-17", "authors_parsed": [["Henzinger", "Thomas A.", ""], ["Sara\u00e7", "N. Ege", ""]]}, {"id": "2105.08422", "submitter": "Hugo Moeneclaey", "authors": "Hugo Moeneclaey", "title": "Parametricity and Semi-Cubical Types", "comments": "25 pages, to be presented at LICS 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We construct a model of type theory enjoying parametricity from an arbitrary\none. A type in the new model is a semi-cubical type in the old one,\nillustrating the correspondence between parametricity and cubes.\n  Our construction works not only for parametricity, but also for similar\ninterpretations of type theory and in fact similar interpretations of any\ngeneralized algebraic theory. To be precise we consider a functor forgetting\nunary operations and equations defining them recursively in a generalized\nalgebraic theory. We show that it has a right adjoint.\n  We use techniques from locally presentable category theory, as well as from\nquotient inductive-inductive types.\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 10:19:47 GMT"}], "update_date": "2021-05-19", "authors_parsed": [["Moeneclaey", "Hugo", ""]]}, {"id": "2105.08473", "submitter": "Renato Neves", "authors": "Fredrik Dahlqvist, Renato Neves", "title": "An Internal Language for Categories Enriched over Generalised Metric\n  Spaces", "comments": "Draft", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Programs with a continuous state space or that interact with physical\nprocesses often require notions of equivalence going beyond the standard binary\nsetting in which equivalence either holds or does not hold. In this paper we\nexplore the idea of equivalence taking values in a quantale V, which covers\ne.g. the cases of inequations and (ultra)metric equations.\n  Our main result is the development of a V-equational deductive system for\nlinear lambda-calculus together with a proof that it is sound and complete (in\nfact, an internal language) for a class of enriched autonomous categories. In\nthe case of inequations, we get an internal language for autonomous categories\nenriched over partial orders. In the case of (ultra)metric equations, we get an\ninternal language for autonomous categories enriched over (ultra)metric spaces.\n  We use our results to obtain examples of inequational and metric equational\nsystems for higher-order programs that contain real-time and probabilistic\nbehaviour.\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 12:31:43 GMT"}], "update_date": "2021-05-19", "authors_parsed": [["Dahlqvist", "Fredrik", ""], ["Neves", "Renato", ""]]}, {"id": "2105.08490", "submitter": "Noleen K\\\"ohler", "authors": "Isolde Adler, Noleen K\\\"ohler and Pan Peng", "title": "GSF-locality is not sufficient for proximity-oblivious testing", "comments": "28 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.DM cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In Property Testing, proximity-oblivious testers (POTs) form a class of\nparticularly simple testing algorithms, where a basic test is performed a\nnumber of times that may depend on the proximity parameter, but the basic test\nitself is independent of the proximity parameter. In their seminal work,\nGoldreich and Ron [STOC 2009; SICOMP 2011] show that the graph properties that\nallow constant-query proximity-oblivious testing in the bounded-degree model\nare precisely the properties that can be expressed as a generalised subgraph\nfreeness (GSF) property that satisfies the non-propagation condition. It is\nleft open whether the non-propagation condition is necessary. Indeed, calling\nproperties expressible as a generalised subgraph freeness property GSF-local\nproperties, they ask whether all GSF-local properties are non-propagating. We\ngive a negative answer by exhibiting a property of graphs that is GSF-local and\npropagating. Hence in particular, our property does not admit a POT, despite\nbeing GSF-local. We prove our result by exploiting a recent work of the authors\nwhich constructed a first-order (FO) property that is not testable [SODA 2021],\nand a new connection between FO properties and GSF-local properties via\nneighbourhood profiles.\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 13:08:35 GMT"}], "update_date": "2021-05-19", "authors_parsed": [["Adler", "Isolde", ""], ["K\u00f6hler", "Noleen", ""], ["Peng", "Pan", ""]]}, {"id": "2105.08619", "submitter": "Ryan Sheatsley", "authors": "Ryan Sheatsley and Blaine Hoak and Eric Pauley and Yohan Beugin and\n  Michael J. Weisman and Patrick McDaniel", "title": "On the Robustness of Domain Constraints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Machine learning is vulnerable to adversarial examples-inputs designed to\ncause models to perform poorly. However, it is unclear if adversarial examples\nrepresent realistic inputs in the modeled domains. Diverse domains such as\nnetworks and phishing have domain constraints-complex relationships between\nfeatures that an adversary must satisfy for an attack to be realized (in\naddition to any adversary-specific goals). In this paper, we explore how domain\nconstraints limit adversarial capabilities and how adversaries can adapt their\nstrategies to create realistic (constraint-compliant) examples. In this, we\ndevelop techniques to learn domain constraints from data, and show how the\nlearned constraints can be integrated into the adversarial crafting process. We\nevaluate the efficacy of our approach in network intrusion and phishing\ndatasets and find: (1) up to 82% of adversarial examples produced by\nstate-of-the-art crafting algorithms violate domain constraints, (2) domain\nconstraints are robust to adversarial examples; enforcing constraints yields an\nincrease in model accuracy by up to 34%. We observe not only that adversaries\nmust alter inputs to satisfy domain constraints, but that these constraints\nmake the generation of valid adversarial examples far more challenging.\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 15:49:55 GMT"}], "update_date": "2021-05-19", "authors_parsed": [["Sheatsley", "Ryan", ""], ["Hoak", "Blaine", ""], ["Pauley", "Eric", ""], ["Beugin", "Yohan", ""], ["Weisman", "Michael J.", ""], ["McDaniel", "Patrick", ""]]}, {"id": "2105.08708", "submitter": "Michele Loreti", "authors": "Michele Loreti and Michela Quadrini", "title": "A Spatial Logic for a Simplicial Complex Model", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Collective adaptive systems (CAS) consist of many heterogeneous components\ntypically organised in groups. These entities interact with each other by\nadapting their behaviour to pursue individual or collective goals. The\ndistribution of system entities determines a space that can be either physical\nor logical. The former is defined in terms of a physical relation among\ncomponents. The latter depends on some logical relations such as being part of\nthe same group. For these systems, specification and verification of spatial\nproperties play a fundamental role to understand their behaviour and to support\ntheir design. Recently, different tools and languages have been introduced to\nspecify and verify the properties of space. However, these formalisms are\nmainly based on graphs. This does not permit considering higher-order relations\nsuch as surfaces or volumes. In this work, we propose a spatial logic\ninterpreted on simplicial complexes. These are topological objects able to\nrepresent surfaces and volumes efficiently and that generalise graphs with\nhigher-order edges. The expressiveness of the proposed spatial logic is studied\nin terms of bisimulation and branching bisimulation relations defined over\nsimplicial complexes. Finally, we discuss how the satisfaction of logical\nformulas can be verified by a correct and complete algorithm.\n", "versions": [{"version": "v1", "created": "Tue, 18 May 2021 17:47:13 GMT"}], "update_date": "2021-05-19", "authors_parsed": [["Loreti", "Michele", ""], ["Quadrini", "Michela", ""]]}, {"id": "2105.08951", "submitter": "Hugo Herbelin", "authors": "Nuria Brede, Hugo Herbelin (PI.R2)", "title": "On the logical structure of choice and bar induction principles", "comments": "LICS 2021 - 36th Annual Symposium on Logic in Computer Science, Jun\n  2021, Rome / Virtual, Italy", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop an approach to choice principles and their contrapositive\nbar-induction principles as extensionality schemes connecting an \"intensional\"\nor \"effective\" view of respectively ill-and well-foundedness properties to an\n\"extensional\" or \"ideal\" view of these properties. After classifying and\nanalysing the relations between different intensional definitions of\nill-foundedness and well-foundedness, we introduce, for a domain $A$, a\ncodomain $B$ and a \"filter\" $T$ on finite approximations of functions from $A$\nto $B$, a generalised form GDC$_{A,B,T}$ of the axiom of dependent choice and\ndually a generalised bar induction principle GBI$_{A,B,T}$ such that:\n  GDC$_{A,B,T}$ intuitionistically captures the strength of\n  $\\bullet$ the general axiom of choice expressed as $\\forall a\\exists b R(a,\nb) \\Rightarrow\\exists\\alpha\\forall \\alpha R(\\alpha,\\alpha(a))$ when $T$ is a\nfilter that derives point-wise from a relation $R$ on $A \\times B$ without\nintroducing further constraints,\n  $\\bullet$ the Boolean Prime Filter Theorem / Ultrafilter Theorem if $B$ is\nthe two-element set $\\mathbb{B}$ (for a constructive definition of prime\nfilter),\n  $\\bullet$ the axiom of dependent choice if $A = \\mathbb{N}$,\n  $\\bullet$ Weak K{\\\"o}nig's Lemma if $A = \\mathbb{N}$ and $B = \\mathbb{B}$ (up\nto weak classical reasoning)\n  GBI$_{A,B,T}$ intuitionistically captures the strength of\n  $\\bullet$ G{\\\"o}del's completeness theorem in the form validity implies\nprovability for entailment relations if $B = \\mathbb{B}$,\n  $\\bullet$ bar induction when $A = \\mathbb{N}$,\n  $\\bullet$ the Weak Fan Theorem when $A = \\mathbb{N}$ and $B = \\mathbb{B}$.\n  Contrastingly, even though GDC$_{A,B,T}$ and GBI$_{A,B,T}$ smoothly capture\nseveral variants of choice and bar induction, some instances are inconsistent,\ne.g. when $A$ is $\\mathbb{B}^\\mathbb{N}$ and $B$ is $\\mathbb{N}$.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 06:51:58 GMT"}, {"version": "v2", "created": "Mon, 28 Jun 2021 14:40:53 GMT"}], "update_date": "2021-06-29", "authors_parsed": [["Brede", "Nuria", "", "PI.R2"], ["Herbelin", "Hugo", "", "PI.R2"]]}, {"id": "2105.09129", "submitter": "Florian Funke", "authors": "Christel Baier, Florian Funke, Rupak Majumdar", "title": "A Game-Theoretic Account of Responsibility Allocation", "comments": "20 pages, 3 figures, technical report associated with an IJCAI'21\n  publication", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  When designing or analyzing multi-agent systems, a fundamental problem is\nresponsibility ascription: to specify which agents are responsible for the\njoint outcome of their behaviors and to which extent. We model strategic\nmulti-agent interaction as an extensive form game of imperfect information and\ndefine notions of forward (prospective) and backward (retrospective)\nresponsibility. Forward responsibility identifies the responsibility of a group\nof agents for an outcome along all possible plays, whereas backward\nresponsibility identifies the responsibility along a given play. We further\ndistinguish between strategic and causal backward responsibility, where the\nformer captures the epistemic knowledge of players along a play, while the\nlatter formalizes which players -- possibly unknowingly -- caused the outcome.\nA formal connection between forward and backward notions is established in the\ncase of perfect recall. We further ascribe quantitative responsibility through\ncooperative game theory. We show through a number of examples that our approach\nencompasses several prior formal accounts of responsibility attribution.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 13:45:18 GMT"}], "update_date": "2021-05-20", "authors_parsed": [["Baier", "Christel", ""], ["Funke", "Florian", ""], ["Majumdar", "Rupak", ""]]}, {"id": "2105.09169", "submitter": "Tobias Seufert", "authors": "Tobias Seufert, Felix Winterer, Christoph Scholl, Karsten Scheibler,\n  Tobias Paxian, Bernd Becker", "title": "Everything You Always Wanted to Know About Generalization of Proof\n  Obligations in PDR", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we revisit the topic of generalizing proof obligations in\nbit-level Property Directed Reachability (PDR). We provide a comprehensive\nstudy which (1) determines the complexity of the problem, (2) thoroughly\nanalyzes limitations of existing methods, (3) introduces approaches to proof\nobligation generalization that have never been used in the context of PDR, (4)\ncompares the strengths of different methods from a theoretical point of view,\nand (5) intensively evaluates the methods on various benchmarks from hardware\nmodel checking as well as from AI planning.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 14:39:17 GMT"}, {"version": "v2", "created": "Thu, 20 May 2021 14:05:07 GMT"}], "update_date": "2021-05-21", "authors_parsed": [["Seufert", "Tobias", ""], ["Winterer", "Felix", ""], ["Scholl", "Christoph", ""], ["Scheibler", "Karsten", ""], ["Paxian", "Tobias", ""], ["Becker", "Bernd", ""]]}, {"id": "2105.09221", "submitter": "Priyanka Golia", "authors": "Priyanka Golia, Subhajit Roy, and Kuldeep S. Meel", "title": "Program Synthesis as Dependency Quantified Formula Modulo Theory", "comments": "12 page excluding reference. To be published in 30th International\n  Joint Conference on Artificial Intelligence (IJCAI-21)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a specification $\\varphi(X,Y)$ over inputs $X$ and output $Y$, defined\nover a background theory $\\mathbb{T}$, the problem of program synthesis is to\ndesign a program $f$ such that $Y=f(X)$ satisfies the specification $\\varphi$.\nOver the past decade, syntax-guided synthesis (SyGuS) has emerged as a dominant\napproach for program synthesis where in addition to the specification\n$\\varphi$, the end-user also specifies a grammar $L$ to aid the underlying\nsynthesis engine. This paper investigates the feasibility of synthesis\ntechniques without grammar, a sub-class defined as $\\mathbb{T}$-constrained\nsynthesis.\n  We show that $\\mathbb{T}$-constrained synthesis can be reduced to\nDQF($\\mathbb{T}$), i.e., to the problem of finding a witness of a Dependency\nQuantified Formula Modulo Theory. When the underlying theory is the theory of\nbitvectors, the corresponding DQF(BV) problem can be further reduced to\nDependency Quantified Boolean Formulas (DQBF). We rely on the progress in DQBF\nsolving to design DQBF-based synthesizers that outperform the domain-specific\nprogram synthesis techniques, thereby positioning DQBF as a core representation\nlanguage for program synthesis. Our empirical analysis shows that\n$\\mathbb{T}$-constrained synthesis can achieve significantly better performance\nthan syntax-guided approaches. Furthermore, the general-purpose DQBF solvers\nperform on par with domain-specific synthesis techniques.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 16:05:20 GMT"}], "update_date": "2021-05-20", "authors_parsed": [["Golia", "Priyanka", ""], ["Roy", "Subhajit", ""], ["Meel", "Kuldeep S.", ""]]}, {"id": "2105.09291", "submitter": "Viktor Henriksson", "authors": "Viktor Henriksson, Manfred Kufleitner", "title": "Deciding FO2 Alternation for Automata over Finite and Infinite Words", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We consider two-variable first-order logic $\\text{FO}^2$ and its quantifier\nalternation hierarchies over both finite and infinite words. Our main results\nare forbidden patterns for deterministic automata (finite words) and for\nCarton-Michel automata (infinite words). In order to give concise patterns, we\nallow the use of subwords on paths in finite graphs. This concept is formalized\nas subword patterns. Deciding the presence or absence of such a pattern in a\ngiven automaton is in $\\mathbf{NL}$. In particular, this leads to $\\mathbf{NL}$\nalgorithms for deciding the levels of the $\\text{FO}^2$ quantifier alternation\nhierarchies. This applies to both full and half levels, each over finite and\ninfinite words. Moreover, we show that these problems are $\\mathbf{NL}$-hard\nand, hence, $\\mathbf{NL}$-complete.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 17:51:00 GMT"}, {"version": "v2", "created": "Sat, 5 Jun 2021 09:18:24 GMT"}], "update_date": "2021-06-08", "authors_parsed": [["Henriksson", "Viktor", ""], ["Kufleitner", "Manfred", ""]]}, {"id": "2105.09368", "submitter": "Dhruv Nevatia", "authors": "Amaldev Manuel and Dhruv Nevatia", "title": "An Algebraic Characterisation of First-Order Logic with Neighbour", "comments": "13 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We give an algebraic characterisation of first-order logic with the neighbour\nrelation, on finite words. For this, we consider languages of finite words over\nalphabets with an involution on them. The natural algebras for such languages\nare involution semigroups. To characterise the logic, we define a special kind\nof semidirect product of involution semigroups, called the locally hermitian\nproduct. The characterisation theorem for FO with neighbour states that a\nlanguage is definable in the logic if and only if it is recognised by a locally\nhermitian product of an aperiodic commutative involution semigroup, and a\nlocally trivial involution semigroup. We then define the notion of involution\nvarieties of languages, namely classes of languages closed under Boolean\noperations, quotients, involution, and inverse images of involutory morphisms.\nAn Eilenberg-type correspondence is established between involution varieties of\nlanguages and pseudovarieties of involution semigroups.\n", "versions": [{"version": "v1", "created": "Wed, 19 May 2021 19:19:35 GMT"}], "update_date": "2021-05-21", "authors_parsed": [["Manuel", "Amaldev", ""], ["Nevatia", "Dhruv", ""]]}, {"id": "2105.09533", "submitter": "Florian Funke", "authors": "Christel Baier, Clemens Dubslaff, Florian Funke, Simon Jantsch, Rupak\n  Majumdar, Jakob Piribauer, Robin Ziemek", "title": "From Verification to Causality-based Explications", "comments": "20 pages, to appear in Proceedings of ICALP'21", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In view of the growing complexity of modern software architectures, formal\nmodels are increasingly used to understand why a system works the way it does,\nopposed to simply verifying that it behaves as intended. This paper surveys\napproaches to formally explicate the observable behavior of reactive systems.\nWe describe how Halpern and Pearl's notion of actual causation inspired\nverification-oriented studies of cause-effect relationships in the evolution of\na system. A second focus lies on applications of the Shapley value to\nresponsibility ascriptions, aimed to measure the influence of an event on an\nobservable effect. Finally, formal approaches to probabilistic causation are\ncollected and connected, and their relevance to the understanding of\nprobabilistic systems is discussed.\n", "versions": [{"version": "v1", "created": "Thu, 20 May 2021 06:21:36 GMT"}], "update_date": "2021-05-21", "authors_parsed": [["Baier", "Christel", ""], ["Dubslaff", "Clemens", ""], ["Funke", "Florian", ""], ["Jantsch", "Simon", ""], ["Majumdar", "Rupak", ""], ["Piribauer", "Jakob", ""], ["Ziemek", "Robin", ""]]}, {"id": "2105.09534", "submitter": "Shankara Narayanan Krishna", "authors": "Shankara Narayanan Krishna and Khushraj Madnani and Manuel Mazo Jr.\n  and Paritosh K. Pandya", "title": "Generalizing Non-Punctuality for Timed Temporal Logic with Freeze\n  Quantifiers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Metric Temporal Logic (MTL) and Timed Propositional Temporal Logic (TPTL) are\nprominent real-time extensions of Linear Temporal Logic (LTL). In general, the\nsatisfiability checking problem for these extensions is undecidable when both\nthe future U and the past S modalities are used. In a classical result, the\nsatisfiability checking for MITL[U,S], a non punctual fragment of MTL[U,S], is\nshown to be decidable with EXPSPACE complete complexity. Given that this notion\nof non punctuality does not recover decidability in the case of TPTL[U,S], we\npropose a generalization of non punctuality called \\emph{non adjacency} for\nTPTL[U,S], and focus on its 1-variable fragment, 1-TPTL[U,S]. While non\nadjacent 1-TPTL[U,S] appears to be be a very small fragment, it is strictly\nmore expressive than MITL. As our main result, we show that the satisfiability\nchecking problem for non adjacent 1-TPTL[U,S] is decidable with EXPSPACE\ncomplete complexity.\n", "versions": [{"version": "v1", "created": "Thu, 20 May 2021 06:22:04 GMT"}, {"version": "v2", "created": "Wed, 9 Jun 2021 01:31:21 GMT"}], "update_date": "2021-06-10", "authors_parsed": [["Krishna", "Shankara Narayanan", ""], ["Madnani", "Khushraj", ""], ["Mazo", "Manuel", "Jr."], ["Pandya", "Paritosh K.", ""]]}, {"id": "2105.09743", "submitter": "Yoni Zohar", "authors": "Yoni Zohar, Ahmed Irfan, Makai Mann, Andres Notzli, Andrew Reynolds,\n  Clark Barrett", "title": "lazybvtoint at the SMT Competition 2020", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  lazybvtoint is a new prototype SMT-solver, that will participate in the\nincremental and non-incremental tracks of the \\qfbv logic.\n", "versions": [{"version": "v1", "created": "Fri, 7 May 2021 20:34:51 GMT"}], "update_date": "2021-05-21", "authors_parsed": [["Zohar", "Yoni", ""], ["Irfan", "Ahmed", ""], ["Mann", "Makai", ""], ["Notzli", "Andres", ""], ["Reynolds", "Andrew", ""], ["Barrett", "Clark", ""]]}, {"id": "2105.09929", "submitter": "Mathys Rennela", "authors": "Robin Kaarsgaard and Mathys Rennela", "title": "Join inverse rig categories for reversible functional programming, and\n  beyond", "comments": "15 pages, 8 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL math.CT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Reversible computing is a computational paradigm in which computations are\ndeterministic in both the forward and backward direction, so that programs have\nwell-defined forward and backward semantics. We investigate the formal\nsemantics of the reversible functional programming language Rfun. For this\npurpose, we introduce join inverse rig categories, the natural marriage of join\ninverse categories and rig categories, which we show can be used to model the\nlanguage Rfun, under reasonable assumptions. These categories turn out to be a\nparticularly natural fit for reversible computing as a whole, as they encompass\nmodels for other reversible programming languages, notably Theseus and\nreversible flowcharts. This suggests that join inverse rig categories really\nare the categorical models of reversible computing.\n", "versions": [{"version": "v1", "created": "Thu, 20 May 2021 17:44:23 GMT"}], "update_date": "2021-05-21", "authors_parsed": [["Kaarsgaard", "Robin", ""], ["Rennela", "Mathys", ""]]}, {"id": "2105.09976", "submitter": "Gaia Belardinelli", "authors": "Gaia Belardinelli and Rasmus K. Rendsvig", "title": "Epistemic Planning with Attention as a Bounded Resource", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.MA econ.TH math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Where information grows abundant, attention becomes a scarce resource. As a\nresult, agents must plan wisely how to allocate their attention in order to\nachieve epistemic efficiency. Here, we present a framework for multi-agent\nepistemic planning with attention, based on Dynamic Epistemic Logic (DEL, a\npowerful formalism for epistemic planning). We identify the framework as a\nfragment of standard DEL, and consider its plan existence problem. While in the\ngeneral case undecidable, we show that when attention is required for learning,\nall instances of the problem are decidable.\n", "versions": [{"version": "v1", "created": "Thu, 20 May 2021 18:14:41 GMT"}], "update_date": "2021-05-24", "authors_parsed": [["Belardinelli", "Gaia", ""], ["Rendsvig", "Rasmus K.", ""]]}, {"id": "2105.10164", "submitter": "Yuichi Komorida", "authors": "Yuichi Komorida, Shin-ya Katsumata, Clemens Kupke, Jurriaan Rot, and\n  Ichiro Hasuo", "title": "Expressivity of Quantitative Modal Logics: Categorical Foundations via\n  Codensity and Approximation", "comments": "14 pages + 9 page appendix, to appear in Proceedings of the 36th\n  Annual ACM/IEEE Symposium on Logic in Computer Science (LICS 2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A modal logic that is strong enough to fully characterize the behavior of a\nsystem is called expressive. Recently, with the growing diversity of systems to\nbe reasoned about (probabilistic, cyber-physical, etc.), the focus shifted to\nquantitative settings which resulted in a number of expressivity results for\nquantitative logics and behavioral metrics. Each of these quantitative\nexpressivity results uses a tailor-made argument; distilling the essence of\nthese arguments is non-trivial, yet important to support the design of\nexpressive modal logics for new quantitative settings. In this paper, we\npresent the first categorical framework for deriving quantitative expressivity\nresults, based on the new notion of approximating family. A key ingredient is\nthe codensity lifting -- a uniform observation-centric construction of various\nbisimilarity-like notions such as bisimulation metrics. We show that several\nrecent quantitative expressivity results (e.g. by K\\\"onig et al. and by\nFijalkow et al.) are accommodated in our framework; a new expressivity result\nis derived, too, for what we call bisimulation uniformity.\n", "versions": [{"version": "v1", "created": "Fri, 21 May 2021 07:10:06 GMT"}], "update_date": "2021-05-24", "authors_parsed": [["Komorida", "Yuichi", ""], ["Katsumata", "Shin-ya", ""], ["Kupke", "Clemens", ""], ["Rot", "Jurriaan", ""], ["Hasuo", "Ichiro", ""]]}, {"id": "2105.10362", "submitter": "Stanis{\\l}aw Ambroszkiewicz", "authors": "Stanislaw Ambroszkiewicz, Waldemar Bartyna and Stanislaw Bylka", "title": "Functionals in the Clouds: An abstract architecture of serverless\n  Cloud-Native Apps", "comments": "Work in progress. Three figures (related to functionals) were added", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CL cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Cloud Native Application CNApp (as a distributed system) is a collection of\nindependent components (micro-services) interacting via communication\nprotocols. This gives rise to present an abstract architecture of CNApp as\ndynamically re-configurable acyclic directed multi graph where vertices are\nmicroservices, and edges are the protocols. Generic mechanisms for such\nreconfigurations evidently correspond to higher-level functions (functionals).\nThis implies also internal abstract architecture of microservice as a\ncollection of event-triggered serverless functions (including functions\nimplementing the protocols) that are dynamically composed into event-dependent\ndata-flow graphs. Again, generic mechanisms for such compositions correspond to\ncalculus of functionals and relations.\n", "versions": [{"version": "v1", "created": "Fri, 21 May 2021 15:28:49 GMT"}, {"version": "v2", "created": "Wed, 2 Jun 2021 19:10:02 GMT"}], "update_date": "2021-06-04", "authors_parsed": [["Ambroszkiewicz", "Stanislaw", ""], ["Bartyna", "Waldemar", ""], ["Bylka", "Stanislaw", ""]]}, {"id": "2105.10542", "submitter": "Jan Hubi\\v{c}ka", "authors": "Martin Balko, David Chodounsk\\'y, Natasha Dobrinen, Jan Hubi\\v{c}ka,\n  Mat\\v{e}j Kone\\v{c}n\\'y, Lluis Vena, Andy Zucker", "title": "Big Ramsey degrees of the generic partial order", "comments": "6 pages, extended abstract accepted to EUROCOMB 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As a result of 33 intercontinental Zoom calls, we characterise big Ramsey\ndegrees of the generic partial order in a similar way as Devlin characterised\nbig Ramsey degrees of the generic linear order (the order of rationals).\n", "versions": [{"version": "v1", "created": "Fri, 21 May 2021 19:11:43 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Balko", "Martin", ""], ["Chodounsk\u00fd", "David", ""], ["Dobrinen", "Natasha", ""], ["Hubi\u010dka", "Jan", ""], ["Kone\u010dn\u00fd", "Mat\u011bj", ""], ["Vena", "Lluis", ""], ["Zucker", "Andy", ""]]}, {"id": "2105.10687", "submitter": "Rathnakar Madhukar Yerraguntla", "authors": "Sanjiva Prasad, R. Madhukar Yerraguntla", "title": "Normalising Lustre Preserves Security", "comments": "Submitted version. 27 Pages including appendix and references", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The synchronous reactive data flow language LUSTRE is an expressive language,\nequipped with a suite of tools for modelling, simulating and model-checking a\nwide variety of safety-critical systems. A critical intermediate step in the\nformally certified compilation of LUSTRE involves translation to a well-behaved\nsub-language called \"Normalised LUSTRE\" (NLUSTRE). Recently, we proposed a\nsimple Denning-style lattice-based secure information flow type system for\nNLUSTRE, and proved its soundness by establishing that security-typed programs\nare non-interfering with respect to the co-inductive stream semantics.\n  In this paper, we propose a similar security type system for unrestricted\nLUSTRE, and show that Bourke et al.'s semantics-preserving normalisation\ntransformations from LUSTRE to NLUSTRE are security-preserving as well. A\nnovelty is the use of refinement security types for node calls. The main result\nis the preservation of security types by the normalisation transformations. The\nsoundness of our security typing rules is shown by establishing that\nwell-security-typed programs are non-interfering, via a reduction to\ntype-preservation (here), semantics-preservation (Bourke et al.) and our\nprevious result of non-interference for NLUSTRE.\n", "versions": [{"version": "v1", "created": "Sat, 22 May 2021 10:57:01 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Prasad", "Sanjiva", ""], ["Yerraguntla", "R. Madhukar", ""]]}, {"id": "2105.10740", "submitter": "Michele Chiari", "authors": "Michele Chiari, Dino Mandrioli, Matteo Pradella", "title": "A First-Order Complete Temporal Logic for Structured Context-Free\n  Languages", "comments": "arXiv admin note: text overlap with arXiv:1910.09327", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The problem of model checking procedural programs has fostered much research\ntowards the definition of temporal logics for reasoning on context-free\nstructures. The most notable of such results are temporal logics on Nested\nWords, such as CaRet and NWTL. Recently, the logic OPTL was introduced, based\non the class of Operator Precedence Languages (OPLs), more powerful than Nested\nWords. We define the new OPL-based logic POTL and prove its FO-completeness.\nPOTL improves on NWTL by enabling the formulation of requirements involving\npre/post-conditions, stack inspection, and others in the presence of\nexception-like constructs. It improves on OPTL too, which instead we show not\nto be FO-complete; it also allows to express more easily stack inspection and\nfunction-local properties. In a separate paper we report a model checking\nprocedure for POTL and experimental results based on a prototype tool developed\ntherefor. For completeness a short summary of this complementary result is\nprovided in this paper too.\n", "versions": [{"version": "v1", "created": "Sat, 22 May 2021 14:36:00 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Chiari", "Michele", ""], ["Mandrioli", "Dino", ""], ["Pradella", "Matteo", ""]]}, {"id": "2105.10822", "submitter": "Xerxes D. Arsiwalla", "authors": "Xerxes D. Arsiwalla, Jonathan Gorard, Hatem Elshatlawy", "title": "Homotopies in Multiway (Non-Deterministic) Rewriting Systems as $n$-Fold\n  Categories", "comments": "18 pages, 7 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.DM cs.LO math-ph math.CO math.MP", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We investigate the algebraic and compositional properties of multiway\n(non-deterministic) abstract rewriting systems, which are the archetypical\nstructures underlying the formalism of the so-called Wolfram model. We\ndemonstrate the existence of higher homotopies in this class of rewriting\nsystems, where these homotopic maps are induced by the inclusion of appropriate\nrewriting rules taken from an abstract rulial space of all possible such rules.\nFurthermore, we show that a multiway rewriting system with homotopies up to\norder $n$ may naturally be formalized as an $n$-fold category, such that (upon\ninclusion of appropriate inverse morphisms via invertible rewriting relations)\nthe infinite limit of this structure yields an ${\\infty}$-groupoid. Via\nGrothendieck's homotopy hypothesis, this ${\\infty}$-groupoid thus inherits the\nstructure of a formal homotopy space. We conclude with some comments on how\nthis computational framework of multiway rewriting systems may potentially be\nused for making formal connections to homotopy spaces upon which models of\nphysics can be instantiated.\n", "versions": [{"version": "v1", "created": "Sat, 22 May 2021 22:37:37 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Arsiwalla", "Xerxes D.", ""], ["Gorard", "Jonathan", ""], ["Elshatlawy", "Hatem", ""]]}, {"id": "2105.10853", "submitter": "Thomas Sturm", "authors": "Hamid Rahkooy and Thomas Sturm", "title": "Parametric Toricity of Steady State Varieties of Reaction Networks", "comments": "Computations available as ancillary files", "journal-ref": null, "doi": null, "report-no": null, "categories": "q-bio.MN cs.LO cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study real steady state varieties of the dynamics of chemical reaction\nnetworks. The dynamics are derived using mass action kinetics with parametric\nreaction rates. The models studied are not inherently parametric in nature.\nRather, our interest in parameters is motivated by parameter uncertainty, as\nreaction rates are typically either measured with limited precision or\nestimated. We aim at detecting toricity and shifted toricity, using a framework\nthat has been recently introduced and studied for the non-parametric case over\nboth the real and the complex numbers. While toricity requires that the variety\nspecifies a subgroup of the direct power of the multiplicative group of the\nunderlying field, shifted toricity requires only a coset. In the non-parametric\ncase these requirements establish real decision problems. In the presence of\nparameters we must go further and derive necessary and sufficient conditions in\nthe parameters for toricity or shifted toricity to hold. Technically, we use\nreal quantifier elimination methods. Our computations on biological networks\nhere once more confirm shifted toricity as a relevant concept, while toricity\nholds only for degenerate parameter choices.\n", "versions": [{"version": "v1", "created": "Sun, 23 May 2021 04:09:21 GMT"}, {"version": "v2", "created": "Mon, 5 Jul 2021 06:42:35 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["Rahkooy", "Hamid", ""], ["Sturm", "Thomas", ""]]}, {"id": "2105.10908", "submitter": "David Tuckey", "authors": "David Tuckey, Alessandra Russo, Krysia Broda", "title": "PASOCS: A Parallel Approximate Solver for Probabilistic Logic Programs\n  under the Credal Semantics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  The Credal semantics is a probabilistic extension of the answer set semantics\nwhich can be applied to programs that may or may not be stratified. It assigns\nto atoms a set of acceptable probability distributions characterised by its\nlower and upper bounds. Performing exact probabilistic inference in the Credal\nsemantics is computationally intractable. This paper presents a first solver,\nbased on sampling, for probabilistic inference under the Credal semantics\ncalled PASOCS (Parallel Approximate SOlver for the Credal Semantics). PASOCS\nperforms both exact and approximate inference for queries given evidence.\nApproximate solutions can be generated using any of the following sampling\nmethods: naive sampling, Metropolis-Hastings and Gibbs Markov Chain\nMonte-Carlo. We evaluate the fidelity and performance of our system when\napplied to both stratified and non-stratified programs. We perform a sanity\ncheck by comparing PASOCS to available systems for stratified programs, where\nthe semantics agree, and show that our system is competitive on unstratified\nprograms.\n", "versions": [{"version": "v1", "created": "Sun, 23 May 2021 10:35:19 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Tuckey", "David", ""], ["Russo", "Alessandra", ""], ["Broda", "Krysia", ""]]}, {"id": "2105.10914", "submitter": "Dominique Unruh", "authors": "Dominique Unruh", "title": "Quantum and classical registers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO quant-ph", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present a generic theory of \"registers\" in imperative programs and\ninstantiate it in the classical and quantum setting. Roughly speaking, a\nregister is some mutable part of the program state, e.g., mutable classical\nvariables and quantum registers and wires in quantum circuits are examples of\nthis. However, registers in our setting can also refer to subparts of other\nregisters, or combinations of parts from different registers, or quantum\nregisters seen in a different basis, etc. Our formalization is intended to be\nwell suited for formalization in theorem provers and as a foundation for\nmodeling quantum/classical variables in imperative programs.\n  We implemented most results (including a minimal quantum Hoare logic and an\nanalysis of quantum teleportation) in the Isabelle/HOL theorem prover.\n", "versions": [{"version": "v1", "created": "Sun, 23 May 2021 11:11:03 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Unruh", "Dominique", ""]]}, {"id": "2105.10930", "submitter": "Roman Kuznets", "authors": "Iris van der Giessen and Raheleh Jalali and Roman Kuznets", "title": "Uniform interpolation via nested sequents and hypersequents", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A modular proof-theoretic framework was recently developed to prove Craig\ninterpolation for normal modal logics based on generalizations of sequent\ncalculi (e.g., nested sequents, hypersequents, and labelled sequents). In this\npaper, we turn to uniform interpolation, which is stronger than Craig\ninterpolation. We develop a constructive method for proving uniform\ninterpolation via nested sequents and apply it to reprove the uniform\ninterpolation property for normal modal logics $\\mathsf{K}$, $\\mathsf{D}$, and\n$\\mathsf{T}$. We then use the know-how developed for nested sequents to apply\nthe same method to hypersequents and obtain the first direct proof of uniform\ninterpolation for $\\mathsf{S5}$ via a cut-free sequent-like calculus. While our\nmethod is proof-theoretic, the definition of uniform interpolation for nested\nsequents and hypersequents also uses semantic notions, including bisimulation\nmodulo an atomic proposition.\n", "versions": [{"version": "v1", "created": "Sun, 23 May 2021 13:14:31 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["van der Giessen", "Iris", ""], ["Jalali", "Raheleh", ""], ["Kuznets", "Roman", ""]]}, {"id": "2105.10946", "submitter": "Alessandro Di Giorgio", "authors": "Guillaume Boisseau, Filippo Bonchi, Alessandro Di Giorgio, Pawel\n  Sobocinski", "title": "Diagrammatic Polyhedral Algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We extend the theory of Interacting Hopf algebras with an order primitive,\nand give a sound and complete axiomatisation of the prop of polyhedral cones.\nNext, we axiomatise an affine extension and prove soundness and completeness\nfor the prop of polyhedra. Adding a register results in a concurrent extension\nof the calculus of signal flow graphs, powerful enough to capture continuous\nPetri nets.\n", "versions": [{"version": "v1", "created": "Sun, 23 May 2021 14:29:30 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Boisseau", "Guillaume", ""], ["Bonchi", "Filippo", ""], ["Di Giorgio", "Alessandro", ""], ["Sobocinski", "Pawel", ""]]}, {"id": "2105.11398", "submitter": "Peter Streufert", "authors": "Peter A. Streufert", "title": "A Category for Extensive-Form Games", "comments": "60 pages, 17 figures, formulation entirely different from\n  arXiv:2004.11196", "journal-ref": null, "doi": null, "report-no": "Western University (University of Western Ontario), Department of\n  Economics Research Report 2021-2", "categories": "econ.TH cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces Gm, which is a category for extensive-form games. It\nalso provides some applications.\n  The category's objects are games, which are understood to be sets of nodes\nwhich have been endowed with edges, information sets, actions, players, and\nutility functions. Its arrows are functions from source nodes to target nodes\nthat preserve the additional structure. For instance, a game's information-set\ncollection is newly regarded as a topological basis for the game's\ndecision-node set, and thus a morphism's continuity serves to preserve\ninformation sets. Given these definitions, a game monomorphism is characterized\nby the property of not mapping two source runs (plays) to the same target run.\nFurther, a game isomorphism is characterized as a bijection whose restriction\nto decision nodes is a homeomorphism, whose induced player transformation is\ninjective, and which strictly preserves the ordinal content of the utility\nfunctions.\n  The category is then applied to some game-theoretic concepts beyond the\ndefinition of a game. A Selten subgame is characterized as a special kind of\ncategorical subgame, and game isomorphisms are shown to preserve strategy sets,\nNash equilibria, Selten subgames, subgame-perfect equilibria,\nperfect-information, and no-absentmindedness. Further, it is shown that the\nfull subcategory for distinguished-action sequence games is essentially wide in\nthe category of all games, and that the full subcategory of action-set games is\nessentially wide in the full subcategory for games with no-absentmindedness.\n", "versions": [{"version": "v1", "created": "Mon, 24 May 2021 16:40:42 GMT"}], "update_date": "2021-06-08", "authors_parsed": [["Streufert", "Peter A.", ""]]}, {"id": "2105.11400", "submitter": "Laura Nenzi", "authors": "E. Bartocci, L. Bortolussi, L. Nenzi, M. Loreti", "title": "A Logic for Monitoring Dynamic Networks of Spatially-distributed\n  Cyber-Physical Systems", "comments": "32 pages, 6 figures. arXiv admin note: substantial text overlap with\n  arXiv:1904.08847", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cyber-Physical Systems (CPS) consist of inter-wined computational (cyber) and\nphysical components interacting through sensors and/or actuators. Computational\nelements are networked at every scale and can communicate with each others and\nwith humans. Nodes can join and leave the network at any time or they can move\nto different spatial locations. %operating at multiple spatial and temporal\nscales. In this scenario, monitoring spatial and temporal properties plays a\nkey role in understanding of how complex behaviors can emerge from local and\ndynamic interactions. We propose here the Spatio-Temporal Reach and Escape\nLogic, (STREL), a logic-based formal language designed to express and monitor\nspatio-temporal requirements over the execution of mobile and spatially\ndistributed CPS. STREL considers the physical space in which CPS entities\n(nodes of the graph) are arranged as a weighted graph representing their\ndynamic topological configuration. Both nodes and edges have attributes\nmodelling physical and logical quantities that can evolve over time. STREL\ncombines the Signal Temporal Logic with two spatial modalities reach and escape\nthat operate over the weighted graph. From these basic operators, we can derive\nother important spatial modalities such as everywhere, somewhere and surround.\nWe propose both a qualitative and quantitative semantics based on constraint\nsemirings, an algebraic structure suitable for constraint satisfaction and\noptimisation. We provide an offline monitoring algorithm for STREL and we show\nthe feasibility of our approach with the application to two case studies:\nmonitoring spatio-temporal requirements over a simulated mobile ad-hoc sensor\nnetwork and a simulated epidemic spreading model for COVID19.\n", "versions": [{"version": "v1", "created": "Mon, 24 May 2021 16:42:42 GMT"}], "update_date": "2021-05-25", "authors_parsed": [["Bartocci", "E.", ""], ["Bortolussi", "L.", ""], ["Nenzi", "L.", ""], ["Loreti", "M.", ""]]}, {"id": "2105.11763", "submitter": "Emilio Gamba", "authors": "Emilio Gamba, Bart Bogaerts and Tias Guns", "title": "Efficiently Explaining CSPs with Unsatisfiable Subset Optimization", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We build on a recently proposed method for explaining solutions of constraint\nsatisfaction problems. An explanation here is a sequence of simple inference\nsteps, where the simplicity of an inference step is measured by the number and\ntypes of constraints and facts used, and where the sequence explains all\nlogical consequences of the problem. We build on these formal foundations and\ntackle two emerging questions, namely how to generate explanations that are\nprovably optimal (with respect to the given cost metric) and how to generate\nthem efficiently. To answer these questions, we develop 1) an implicit hitting\nset algorithm for finding optimal unsatisfiable subsets; 2) a method to reduce\nmultiple calls for (optimal) unsatisfiable subsets to a single call that takes\nconstraints on the subset into account, and 3) a method for re-using relevant\ninformation over multiple calls to these algorithms. The method is also\napplicable to other problems that require finding cost-optimal unsatiable\nsubsets. We specifically show that this approach can be used to effectively\nfind sequences of optimal explanation steps for constraint satisfaction\nproblems like logic grid puzzles.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2021 08:57:43 GMT"}, {"version": "v2", "created": "Mon, 31 May 2021 15:32:09 GMT"}, {"version": "v3", "created": "Thu, 17 Jun 2021 15:45:09 GMT"}, {"version": "v4", "created": "Mon, 5 Jul 2021 08:39:04 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["Gamba", "Emilio", ""], ["Bogaerts", "Bart", ""], ["Guns", "Tias", ""]]}, {"id": "2105.11811", "submitter": "Dmitry Shkatov", "authors": "Mikhail Rybakov and Dmitry Shkatov", "title": "Algorithmic properties of first-order modal logics of linear Kripke\n  frames in restricted languages", "comments": null, "journal-ref": null, "doi": "10.1093/logcom/exab030", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study the algorithmic properties of first-order monomodal logics of frames\n$\\langle \\mathbb{N}, \\leq \\rangle$, $\\langle \\mathbb{N}, < \\rangle$, $\\langle\n\\mathbb{Q}, \\leq \\rangle$, $\\langle \\mathbb{Q}, < \\rangle$, $\\langle\n\\mathbb{R}, \\leq \\rangle$, $\\langle \\mathbb{R}, < \\rangle$, as well as some\nrelated logics, in languages with restrictions on the number of individual\nvariables as well as the number and arity of predicate letters. We show that\nthe logics of frames based on $\\mathbb{N}$ are $\\Pi^1_1$-hard -- thus, not\nrecursively enumerable -- in languages with two individual variables, one\nmonadic predicate letter and one proposition letter. We also show that the\nlogics of frames based on $\\mathbb{Q}$ and $\\mathbb{R}$ are $\\Sigma^0_1$-hard\nin languages with the same restrictions. Similar results are obtained for a\nnumber of related logics.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2021 10:29:34 GMT"}], "update_date": "2021-05-26", "authors_parsed": [["Rybakov", "Mikhail", ""], ["Shkatov", "Dmitry", ""]]}, {"id": "2105.12077", "submitter": "Elizabeth Dietrich", "authors": "Elizabeth Dietrich", "title": "A beginner guide to Iris, Coq and separation logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Creating safe concurrent algorithms is challenging and error-prone. For this\nreason, a formal verification framework is necessary especially when those\nconcurrent algorithms are used in safety-critical systems. The goal of this\nguide is to provide resources for beginners to get started in their journey of\nformal verification using the powerful tool Iris. The difference between this\nguide and many others is that it provides (i) an in-depth explanation of\nexamples and tactics, (ii) an explicit discussion of separation logic, and\n(iii) a thorough coverage of Iris and Coq. References to other guides and to\npapers are included throughout to provide readers with resources through which\nto continue their learning.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2021 16:57:25 GMT"}], "update_date": "2021-06-04", "authors_parsed": [["Dietrich", "Elizabeth", ""]]}, {"id": "2105.12185", "submitter": "Deacon Linkhorn", "authors": "Deacon Linkhorn", "title": "The Pseudofinite Monadic Second Order Theory of Linear Order", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Monadic second order logic is the expansion of first order logic by\nquantifiers ranging over unary relations. We study the shared monadic second\norder theory of finite linear orders, i.e. the pseudofinite monadic second\norder theory of linear order, using a first order setup . We give explicit (and\nrecursive) axioms and characterise the completions in terms of residue\nsequences. A connection with profinite algebra, in particular with the free\nprofinite monoid on one generator, is established via extended Stone duality.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2021 19:39:18 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Linkhorn", "Deacon", ""]]}, {"id": "2105.12251", "submitter": "Ricardo Monge", "authors": "Osvaldo Skliar and Sherry Gapper and Ricardo E. Monge", "title": "A Canonical Fuzzy Logic", "comments": "28 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  A presentation is provided of the basic notions and operations of a) the\npropositional calculus of a variant of fuzzy logic -- canonical fuzzy logic,\nCFL -- and in a more succinct and introductory way, of b) the theory of fuzzy\nsets according to that same logic. The propositional calculus of bivalent\nclassical logic and classical set theory can be considered as particular cases\nof the corresponding theories of CFL if the numerical value of a specific\nparameter $w$ is restricted to only two possibilities, 0 and 1.\n", "versions": [{"version": "v1", "created": "Tue, 25 May 2021 22:45:49 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Skliar", "Osvaldo", ""], ["Gapper", "Sherry", ""], ["Monge", "Ricardo E.", ""]]}, {"id": "2105.12322", "submitter": "Sebastian Junges", "authors": "Sebastian Junges, Hazem Torfah, Sanjit A. Seshia", "title": "Runtime Monitoring for Markov Decision Processes", "comments": "Technical report with appendix. Accepted at CAV", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.RO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We investigate the problem of monitoring partially observable systems with\nnondeterministic and probabilistic dynamics. In such systems, every state may\nbe associated with a risk, e.g., the probability of an imminent crash. During\nruntime, we obtain partial information about the system state in form of\nobservations. The monitor uses this information to estimate the risk of the\n(unobservable) current system state. Our results are threefold. First, we show\nthat extensions of state estimation approaches do not scale due the combination\nof nondeterminism and probabilities. While convex hull algorithms improve the\npractical runtime, they do not prevent an exponential memory blowup. Second, we\npresent a tractable algorithm based on model checking conditional reachability\nprobabilities. Third, we provide prototypical implementations and manifest the\napplicability of our algorithms to a range of benchmarks. The results highlight\nthe possibilities and boundaries of our novel algorithms.\n", "versions": [{"version": "v1", "created": "Wed, 26 May 2021 04:26:28 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Junges", "Sebastian", ""], ["Torfah", "Hazem", ""], ["Seshia", "Sanjit A.", ""]]}, {"id": "2105.12326", "submitter": "Sebastian Junges", "authors": "Steven Holtzen, Sebastian Junges, Marcell Vazquez-Chanlatte, Todd\n  Millstein, Sanjit A. Seshia, Guy Van Den Broeck", "title": "Model Checking Finite-Horizon Markov Chains with Probabilistic Inference", "comments": "Technical Report. Accepted at CAV 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We revisit the symbolic verification of Markov chains with respect to finite\nhorizon reachability properties. The prevalent approach iteratively computes\nstep-bounded state reachability probabilities. By contrast, recent advances in\nprobabilistic inference suggest symbolically representing all horizon-length\npaths through the Markov chain. We ask whether this perspective advances the\nstate-of-the-art in probabilistic model checking. First, we formally describe\nboth approaches in order to highlight their key differences. Then, using these\ninsights we develop Rubicon, a tool that transpiles Prism models to the\nprobabilistic inference tool Dice. Finally, we demonstrate better scalability\ncompared to probabilistic model checkers on selected benchmarks. All together,\nour results suggest that probabilistic inference is a valuable addition to the\nprobabilistic model checking portfolio -- with Rubicon as a first step towards\nintegrating both perspectives.\n", "versions": [{"version": "v1", "created": "Wed, 26 May 2021 04:54:31 GMT"}, {"version": "v2", "created": "Wed, 30 Jun 2021 04:23:28 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Holtzen", "Steven", ""], ["Junges", "Sebastian", ""], ["Vazquez-Chanlatte", "Marcell", ""], ["Millstein", "Todd", ""], ["Seshia", "Sanjit A.", ""], ["Broeck", "Guy Van Den", ""]]}, {"id": "2105.12588", "submitter": "Stefan Pranger", "authors": "Stefan Pranger, Bettina K\\\"onighofer, Lukas Posch and Roderick Bloem", "title": "TEMPEST -- Synthesis Tool for Reactive Systems and Shields in\n  Probabilistic Environments", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present Tempest, a synthesis tool to automatically create\ncorrect-by-construction reactive systems and shields from qualitative or\nquantitative specifications in probabilistic environments. A shield is a\nspecial type of reactive system used for run-time enforcement; i.e., a shield\nenforces a given qualitative or quantitative specification of a running system\nwhile interfering with its operation as little as possible. Shields that\nenforce a qualitative or quantitative specification are called safety-shields\nor optimal-shields, respectively. Safety-shields can be implemented as\npre-shields or as post-shields, optimal-shields are implemented as\npost-shields. Pre-shields are placed before the system and restrict the choices\nof the system. Post-shields are implemented after the system and are able to\noverwrite the system's output. Tempest is based on the probabilistic model\nchecker Storm, adding model checking algorithms for stochastic games with\nsafety and mean-payoff objectives. To the best of our knowledge, Tempest is the\nonly synthesis tool able to solve 2-1/2-player games with mean-payoff\nobjectives without restrictions on the state space. Furthermore, Tempest adds\nthe functionality to synthesize safe and optimal strategies that implement\nreactive systems and shields\n", "versions": [{"version": "v1", "created": "Wed, 26 May 2021 14:43:29 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Pranger", "Stefan", ""], ["K\u00f6nighofer", "Bettina", ""], ["Posch", "Lukas", ""], ["Bloem", "Roderick", ""]]}, {"id": "2105.12678", "submitter": "Bo-Yu Zhu", "authors": "Shih-Yi Yuan, Bo-Yu Zhu", "title": "A Flexible FPGA-Based ISA Configurable SoC platform", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We proposes a platform which can generate hardware/software description based\non flexible in-struction set architectures (ISAs). The platform takes advantage\nof the flexibility of field pro-grammable gate array (FPGA) to design many\nmicro control units (MCUs) based on different ISAs. The platform can generate\nmany ISAs, MCUs, and Assemblers according to a pre-defined ISA and user\napplications. Although the MCU performance is not optimized, the FPGA shows a\ngreat potential on resource reduction and enough performance at very low system\nclock rate. The flexible ISA has shown great importance for the design targeted\nto specific purpose. We also show a case study of the proposed flexible\nISA-based FPGA-MCU. It can control many specifi-cally designed hardware IPs and\na customized multi-task OS with tasks. Not only the case works correctly, but\nalso the proposed FPGA-MCU of the case is flexible with reduced FPGA resources,\nlow cost, and within time constraints.\n", "versions": [{"version": "v1", "created": "Wed, 26 May 2021 16:44:49 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Yuan", "Shih-Yi", ""], ["Zhu", "Bo-Yu", ""]]}, {"id": "2105.12801", "submitter": "Wilmer Leal", "authors": "Elena Di Lavore, Wilmer Leal, Valeria de Paiva", "title": "Dialectica Petri nets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The categorical modeling of Petri nets has received much attention recently.\nThe Dialectica construction has also had its fair share of attention. We\nrevisit the use of the Dialectica construction as a categorical model for Petri\nnets generalizing the original application to suggest that Petri nets with\ndifferent kinds of transitions can be modeled in the same categorical\nframework. Transitions representing truth-values, probabilities, rates or\nmultiplicities, evaluated in different algebraic structures called lineales are\nuseful and are modeled here in the same category. We investigate (categorical\ninstances of) this generalized model and its connections to more recent models\nof categorical nets.\n", "versions": [{"version": "v1", "created": "Wed, 26 May 2021 19:23:11 GMT"}], "update_date": "2021-05-28", "authors_parsed": [["Di Lavore", "Elena", ""], ["Leal", "Wilmer", ""], ["de Paiva", "Valeria", ""]]}, {"id": "2105.12911", "submitter": "Georgios Bakirtzis", "authors": "Georgios Bakirtzis and Eswaran Subrahmanian and Cody H. Fleming", "title": "Compositional Thinking in Cyber-Physical Systems Theory", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.LO cs.SY math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Engineering safe and secure cyber-physical systems requires system engineers\nto develop and maintain a number of model views, both dynamic and static, which\ncan be seen as algebras. We posit that verifying the composition of\nrequirement, behavioral, and architectural models using category theory gives\nrise to a strictly compositional interpretation of cyber-physical systems\ntheory, which can assist in the modeling and analysis of safety-critical\ncyber-physical systems.\n", "versions": [{"version": "v1", "created": "Thu, 27 May 2021 02:14:34 GMT"}], "update_date": "2021-05-28", "authors_parsed": [["Bakirtzis", "Georgios", ""], ["Subrahmanian", "Eswaran", ""], ["Fleming", "Cody H.", ""]]}, {"id": "2105.12986", "submitter": "Arianna Casanova", "authors": "Juerg Kohlas, Arianna Casanova, Marco Zaffalon", "title": "Algebras of Sets and Coherent Sets of Gambles", "comments": "Submitted to ECSQARU 2021. arXiv admin note: text overlap with\n  arXiv:2105.12037", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a recent work we have shown how to construct an information algebra of\ncoherent sets of gambles defined on general possibility spaces. Here we analyze\nthe connection of such an algebra with the set algebra of subsets of the\npossibility space on which gambles are defined and the set algebra of sets of\nits atoms. Set algebras are particularly important information algebras since\nthey are their prototypical structures. Furthermore, they are the algebraic\ncounterparts of classical propositional logic. As a consequence, this paper\nalso details how propositional logic is naturally embedded into the theory of\nimprecise probabilities.\n", "versions": [{"version": "v1", "created": "Thu, 27 May 2021 08:14:38 GMT"}], "update_date": "2021-05-28", "authors_parsed": [["Kohlas", "Juerg", ""], ["Casanova", "Arianna", ""], ["Zaffalon", "Marco", ""]]}, {"id": "2105.13071", "submitter": "Daniel Stan", "authors": "Oliver Markgraf, Daniel Stan, and Anthony W. Lin", "title": "Learning Union of Integer Hypercubes with Queries (Technical Report)", "comments": "Extended version (technical report) of a paper published in CAV 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the problem of learning a finite union of integer (axis-aligned)\nhypercubes over the d-dimensional integer lattice, i.e., whose edges are\nparallel to the coordinate axes. This is a natural generalization of the\nclassic problem in the computational learning theory of learning rectangles. We\nprovide a learning algorithm with access to a minimally adequate teacher (i.e.\nmembership and equivalence oracles) that solves this problem in\npolynomial-time, for any fixed dimension d. Over a non-fixed dimension, the\nproblem subsumes the problem of learning DNF boolean formulas, a central open\nproblem in the field. We have also provided extensions to handle infinite\nhypercubes in the union, as well as showing how subset queries could improve\nthe performance of the learning algorithm in practice. Our problem has a\nnatural application to the problem of monadic decomposition of quantifier-free\ninteger linear arithmetic formulas, which has been actively studied in recent\nyears. In particular, a finite union of integer hypercubes correspond to a\nfinite disjunction of monadic predicates over integer linear arithmetic\n(without modulo constraints). Our experiments suggest that our learning\nalgorithms substantially outperform the existing algorithms.\n", "versions": [{"version": "v1", "created": "Thu, 27 May 2021 11:39:10 GMT"}], "update_date": "2021-05-28", "authors_parsed": [["Markgraf", "Oliver", ""], ["Stan", "Daniel", ""], ["Lin", "Anthony W.", ""]]}, {"id": "2105.13217", "submitter": "Fredrik Dahlqvist", "authors": "George Constantinides and Fredrik Dahlqvist and Zvonimir Rakamaric and\n  Rocco Salvia", "title": "Rigorous Roundoff Error Analysis of Probabilistic Floating-Point\n  Computations", "comments": "Long version of the eponymous CAV 2021 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.NA math.NA", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present a detailed study of roundoff errors in probabilistic\nfloating-point computations. We derive closed-form expressions for the\ndistribution of roundoff errors associated with a random variable, and we prove\nthat roundoff errors are generally close to being uncorrelated with their\ngenerating distribution. Based on these theoretical advances, we propose a\nmodel of IEEE floating-point arithmetic for numerical expressions with\nprobabilistic inputs and an algorithm for evaluating this model. Our algorithm\nprovides rigorous bounds to the output and error distributions of arithmetic\nexpressions over random variables, evaluated in the presence of roundoff\nerrors. It keeps track of complex dependencies between random variables using\nan SMT solver, and is capable of providing sound but tight probabilistic bounds\nto roundoff errors using symbolic affine arithmetic. We implemented the\nalgorithm in the PAF tool, and evaluated it on FPBench, a standard benchmark\nsuite for the analysis of roundoff errors. Our evaluation shows that PAF\ncomputes tighter bounds than current state-of-the-art on almost all benchmarks.\n", "versions": [{"version": "v1", "created": "Thu, 27 May 2021 15:07:34 GMT"}], "update_date": "2021-05-28", "authors_parsed": [["Constantinides", "George", ""], ["Dahlqvist", "Fredrik", ""], ["Rakamaric", "Zvonimir", ""], ["Salvia", "Rocco", ""]]}, {"id": "2105.13583", "submitter": "Chelsea Edmonds Ms", "authors": "Chelsea Edmonds and Lawrence Paulson", "title": "A Modular First Formalisation of Combinatorial Design Theory", "comments": "This paper has been accepted to CICM 2021. The full formalisation\n  will be made available on the Isabelle AFP prior to the conference, and is\n  alternatively available here: https://github.com/cledmonds/design-theory", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Combinatorial design theory studies set systems with certain balance and\nsymmetry properties and has applications to computer science and elsewhere.\nThis paper presents a modular approach to formalising designs for the first\ntime using Isabelle and assesses the usability of a locale-centric approach to\nformalisations of mathematical structures. We demonstrate how locales can be\nused to specify numerous types of designs and their hierarchy. The resulting\nlibrary, which is concise and adaptable, includes formal definitions and proofs\nfor many key properties, operations, and theorems on the construction and\nexistence of designs.\n", "versions": [{"version": "v1", "created": "Fri, 28 May 2021 04:27:56 GMT"}], "update_date": "2021-05-31", "authors_parsed": [["Edmonds", "Chelsea", ""], ["Paulson", "Lawrence", ""]]}, {"id": "2105.13683", "submitter": "S. Akshay", "authors": "S. Akshay, Paul Gastin and Karthik R Prakash", "title": "Fast zone-based algorithms for reachability in pushdown timed automata", "comments": "Long version of conference paper accepted at CAV'2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Given the versatility of timed automata a huge body of work has evolved that\nconsiders extensions of timed automata. One extension that has received a lot\nof interest is timed automata with a, possibly unbounded, stack, also called\nthe pushdown timed automata (PDTA) model. While different algorithms have been\ngiven for reachability in different variants of this model, most of these\nresults are purely theoretical and do not give rise to efficient\nimplementations. One main reason for this is that none of these algorithms (and\nthe implementations that exist) use the so-called zone-based abstraction, but\nrely either on the region-abstraction or other approaches, which are\nsignificantly harder to implement.\n  In this paper, we show that a naive extension of the zone based reachability\nalgorithm for the control state reachability problem of timed automata is not\nsound in the presence of a stack. To understand this better we give an\ninductive rule based view of the zone reachability algorithm for timed\nautomata. This alternate view allows us to analyze and adapt the rules to also\nwork for pushdown timed automata. We obtain the first zone-based algorithm for\nPDTA which is terminating, sound and complete. We implement our algorithm in\nthe tool TChecker and perform experiments to show its efficacy, thus leading\nthe way for more practical approaches to the verification of pushdown timed\nsystems.\n", "versions": [{"version": "v1", "created": "Fri, 28 May 2021 09:07:12 GMT"}, {"version": "v2", "created": "Mon, 19 Jul 2021 09:46:48 GMT"}], "update_date": "2021-07-20", "authors_parsed": [["Akshay", "S.", ""], ["Gastin", "Paul", ""], ["Prakash", "Karthik R", ""]]}, {"id": "2105.14047", "submitter": "Xiaoning Bian", "authors": "Xiaoning Bian and Peter Selinger", "title": "Generators and relations for $U_n(\\mathbb Z [\\frac{1}{2}, i])$", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.ET cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Consider the universal gate set for quantum computing consisting of the gates\nX, CX, CCX, ${\\omega}{\\dagger}H$ and S. All of these gates have matrix entries\nin the ring $\\mathbb Z [\\frac{1}{2}, i]$, the smallest subring of the complex\nnumbers containing $\\frac{1}{2}$ and $i$. Amy, Glaudell, and Ross proved the\nconverse, i.e., any unitary matrix with entries in $\\mathbb Z [\\frac{1}{2}, i]$\ncan be realized by a quantum circuit over the above gate set using at most one\nancilla. In this paper, we give a finite presentation by generators and\nrelations of $U_n(\\mathbb Z [\\frac{1}{2}, i])$, the group of unitary $n\\times\nn$-matrices with entries in $\\mathbb Z [\\frac{1}{2}, i]$.\n", "versions": [{"version": "v1", "created": "Fri, 28 May 2021 18:26:23 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Bian", "Xiaoning", ""], ["Selinger", "Peter", ""]]}, {"id": "2105.14100", "submitter": "Kevin Batz", "authors": "Kevin Batz, Mingshuai Chen, Benjamin Lucien Kaminski, Joost-Pieter\n  Katoen, Christoph Matheja, Philipp Schr\\\"oer", "title": "Latticed $k$-Induction with an Application to Probabilistic Programs", "comments": "to be published in: CAV (2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  We revisit two well-established verification techniques, $k$-induction and\nbounded model checking (BMC), in the more general setting of fixed point theory\nover complete lattices. Our main theoretical contribution is latticed\n$k$-induction, which (i) generalizes classical $k$-induction for verifying\ntransition systems, (ii) generalizes Park induction for bounding fixed points\nof monotonic maps on complete lattices, and (iii) extends from naturals $k$ to\ntransfinite ordinals $\\kappa$, thus yielding $\\kappa$-induction. The\nlattice-theoretic understanding of $k$-induction and BMC enables us to apply\nboth techniques to the fully automatic verification of infinite-state\nprobabilistic programs. Our prototypical implementation manages to\nautomatically verify non-trivial specifications for probabilistic programs\ntaken from the literature that - using existing techniques - cannot be verified\nwithout synthesizing a stronger inductive invariant first.\n", "versions": [{"version": "v1", "created": "Fri, 28 May 2021 20:40:44 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Batz", "Kevin", ""], ["Chen", "Mingshuai", ""], ["Kaminski", "Benjamin Lucien", ""], ["Katoen", "Joost-Pieter", ""], ["Matheja", "Christoph", ""], ["Schr\u00f6er", "Philipp", ""]]}, {"id": "2105.14183", "submitter": "Katherine Cordwell", "authors": "Matias Scharager, Katherine Cordwell, Stefan Mitsch, Andr\\'e Platzer", "title": "Verified Quadratic Virtual Substitution for Real Arithmetic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a formally verified quantifier elimination (QE) algorithm\nfor first-order real arithmetic by linear and quadratic virtual substitution\n(VS) in Isabelle/HOL. The Tarski-Seidenberg theorem established that the\nfirst-order logic of real arithmetic is decidable by QE. However, in practice,\nQE algorithms are highly complicated and often combine multiple methods for\nperformance. VS is a practically successful method for QE that targets formulas\nwith low-degree polynomials. To our knowledge, this is the first work to\nformalize VS for quadratic real arithmetic including inequalities. The proofs\nnecessitate various contributions to the existing multivariate polynomial\nlibraries in Isabelle/HOL, including a method for re-indexing variables in a\npolynomial. Our framework is modularized and easily expandable (to facilitate\nintegrating future optimizations), and could serve as a basis for developing a\ngeneral-purpose QE algorithm. Further, as our formalization is designed with\npracticality in mind, we export our development to SML and test the resulting\ncode on 378 benchmarks from the literature, comparing to Redlog, Z3,\nMathematica, and SMT-RAT.\n", "versions": [{"version": "v1", "created": "Sat, 29 May 2021 02:49:41 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Scharager", "Matias", ""], ["Cordwell", "Katherine", ""], ["Mitsch", "Stefan", ""], ["Platzer", "Andr\u00e9", ""]]}, {"id": "2105.14247", "submitter": "Julian Siber", "authors": "Christel Baier, Norine Coenen, Bernd Finkbeiner, Florian Funke, Simon\n  Jantsch, and Julian Siber", "title": "Causality-Based Game Solving", "comments": "33rd International Conference on Computer-Aided Verification (CAV\n  2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a causality-based algorithm for solving two-player reachability\ngames represented by logical constraints. These games are a useful formalism to\nmodel a wide array of problems arising, e.g., in program synthesis. Our\ntechnique for solving these games is based on the notion of subgoals, which are\nslices of the game that the reachability player necessarily needs to pass\nthrough in order to reach the goal. We use Craig interpolation to identify\nthese necessary sets of moves and recursively slice the game along these\nsubgoals. Our approach allows us to infer winning strategies that are\nstructured along the subgoals. If the game is won by the reachability player,\nthis is a strategy that progresses through the subgoals towards the final goal;\nif the game is won by the safety player, it is a permissive strategy that\ncompletely avoids a single subgoal. We evaluate our prototype implementation on\na range of different games. On multiple benchmark families, our prototype\nscales dramatically better than previously available tools.\n", "versions": [{"version": "v1", "created": "Sat, 29 May 2021 08:24:32 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Baier", "Christel", ""], ["Coenen", "Norine", ""], ["Finkbeiner", "Bernd", ""], ["Funke", "Florian", ""], ["Jantsch", "Simon", ""], ["Siber", "Julian", ""]]}, {"id": "2105.14261", "submitter": "Dieter Spreen", "authors": "Dieter Spreen, Ulrich Berger", "title": "Computing with Infinite Objects: the Gray Code Case", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Infinite Gray code has been introduced by Tsuiki~\\cite{ts} as a\nredundancy-free representation of the reals. In applications the signed digit\nrepresentation is mostly used which has maximal redundancy. Tsuiki presented a\nfunctional program converting signed digit code into infinite Gray code.\nMoreover, he showed that infinite Gray code can effectively be converted into\nsigned digit code, but the program needs to have some non-deterministic\nfeatures (see also \\cite{tsug}). Berger and Tsuiki~\\cite{btifp,bt} reproved the\nresult in a system of formal first-order intuitionistic logic extended by\ninductive and co-inductive definitions, as well as some new logical connectives\ncapturing concurrent behaviour. The programs extracted from the proofs are\nexactly the ones given by Tsuiki. In order to do so, co-inductive predicates\n$\\bS$ and $\\bG$ are defined and the inclusion $\\bS \\subseteq \\bG$ is derived.\nFor the converse inclusion the new logical connectives are used to introduce a\nconcurrent version $\\S_{2}$ of $S$ and $\\bG \\subseteq \\bS_{2}$ is shown. What\none is looking for, however, is an equivalence proof of the involved concepts.\nOne of the main aims of the present paper is to close the gap. A concurrent\nversion $\\bG^{*}$ of $\\bG$ and a modification $\\bS^{*}$ of $\\bS_{2}$ are\npresented such that $\\bS^{*} = \\bG^{*}$. A crucial tool in \\cite{btifp} is a\nformulation of the Archimedean property of the real numbers as an induction\nprinciple. We introduce a concurrent version of this principle which allows us\nto prove that $\\bS^{*}$ and $\\bG^{*}$ coincide. A further central contribution\nis the extension of the above results to the hyperspace of non-empty compact\nsubsets of the reals.\n", "versions": [{"version": "v1", "created": "Sat, 29 May 2021 09:42:15 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Spreen", "Dieter", ""], ["Berger", "Ulrich", ""]]}, {"id": "2105.14311", "submitter": "Mingshuai Chen", "authors": "Qiuye Wang, Mingshuai Chen, Bai Xue, Naijun Zhan and Joost-Pieter\n  Katoen", "title": "Synthesizing Invariant Barrier Certificates via Difference-of-Convex\n  Programming", "comments": "To be published in Proc. of CAV 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  A barrier certificate often serves as an inductive invariant that isolates an\nunsafe region from the reachable set of states, and hence is widely used in\nproving safety of hybrid systems possibly over the infinite time horizon. We\npresent a novel condition on barrier certificates, termed the invariant\nbarrier-certificate condition, that witnesses unbounded-time safety of\ndifferential dynamical systems. The proposed condition is by far the least\nconservative one on barrier certificates, and can be shown as the weakest\npossible one to attain inductive invariance. We show that discharging the\ninvariant barrier-certificate condition -- thereby synthesizing invariant\nbarrier certificates -- can be encoded as solving an optimization problem\nsubject to bilinear matrix inequalities (BMIs). We further propose a synthesis\nalgorithm based on difference-of-convex programming, which approaches a local\noptimum of the BMI problem via solving a series of convex optimization\nproblems. This algorithm is incorporated in a branch-and-bound framework that\nsearches for the global optimum in a divide-and-conquer fashion. We present a\nweak completeness result of our method, in the sense that a barrier certificate\nis guaranteed to be found (under some mild assumptions) whenever there exists\nan inductive invariant (in the form of a given template) that suffices to\ncertify safety of the system. Experimental results on benchmark examples\ndemonstrate the effectiveness and efficiency of our approach.\n", "versions": [{"version": "v1", "created": "Sat, 29 May 2021 14:35:55 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Wang", "Qiuye", ""], ["Chen", "Mingshuai", ""], ["Xue", "Bai", ""], ["Zhan", "Naijun", ""], ["Katoen", "Joost-Pieter", ""]]}, {"id": "2105.14452", "submitter": "Xinghan Liu", "authors": "Xinghan Liu and Emiliano Lorini", "title": "A logic for binary classifiers and their explanation", "comments": "26 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent years have witnessed a renewed interest in Boolean function in\nexplaining binary classifiers in the field of explainable AI (XAI). The\nstandard approach of Boolean function is propositional logic. We present a\nmodal language of a ceteris paribus nature which supports reasoning about\nbinary classifiers and their properties. We study families of decision models\nfor binary classifiers, axiomatize them and show completeness of our\naxiomatics. Moreover, we prove that the variant of our modal language with\nfinite propositional atoms interpreted over these models is NP-complete. We\nleverage the language to formalize counterfactual conditional as well as a\nbunch of notions of explanation such as abductive, contrastive and\ncounterfactual explanations, and biases. Finally, we present two extensions of\nour language: a dynamic extension by the notion of assignment enabling\nclassifier change and an epistemic extension in which the classifier's\nuncertainty about the actual input can be represented.\n", "versions": [{"version": "v1", "created": "Sun, 30 May 2021 07:49:56 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Liu", "Xinghan", ""], ["Lorini", "Emiliano", ""]]}, {"id": "2105.14579", "submitter": "Francesco Ranzato", "authors": "Paolo Baldan and Francesco Ranzato and Linpeng Zhang", "title": "A Rice's Theorem for Abstract Semantics", "comments": "Full version of a conference paper presented at the 48th\n  International Colloquium on Automata, Languages, and Programming (ICALP 2021)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Classical results in computability theory, notably Rice's theorem, focus on\nthe extensional content of programs, namely, on the partial recursive functions\nthat programs compute. Later and more recent work investigated intensional\ngeneralisations of such results that take into account the way in which\nfunctions are computed, thus affected by the specific programs computing them.\nIn this paper, we single out a novel class of program semantics based on\nabstract domains of program properties that are able to capture nonextensional\naspects of program computations, such as their asymptotic complexity or logical\ninvariants, and allow us to generalise some foundational computability results\nsuch as Rice's Theorem and Kleene's Second Recursion Theorem to these\nsemantics. In particular, it turns out that for this class of abstract program\nsemantics, any nontrivial abstract property is undecidable and every decidable\noverapproximation necessarily includes an infinite set of false positives which\ncovers all values of the semantic abstract domain.\n", "versions": [{"version": "v1", "created": "Sun, 30 May 2021 16:39:55 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Baldan", "Paolo", ""], ["Ranzato", "Francesco", ""], ["Zhang", "Linpeng", ""]]}, {"id": "2105.14697", "submitter": "Emre Yolcu", "authors": "Emre Yolcu, Scott Aaronson, Marijn J.H. Heule", "title": "An Automated Approach to the Collatz Conjecture", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We explore the Collatz conjecture and its variants through the lens of\ntermination of string rewriting. We construct a rewriting system that simulates\nthe iterated application of the Collatz function on strings corresponding to\nmixed binary-ternary representations of positive integers. We prove that the\ntermination of this rewriting system is equivalent to the Collatz conjecture.\nWe also prove that a previously studied rewriting system that simulates the\nCollatz function using unary representations does not admit termination proofs\nvia matrix interpretations. To show the feasibility of our approach in proving\nmathematically interesting statements, we implement a minimal termination\nprover that uses matrix/arctic interpretations and we find automated proofs of\nnontrivial weakenings of the Collatz conjecture. Finally, we adapt our\nrewriting system to show that other open problems in mathematics can also be\napproached as termination problems for relatively small rewriting systems.\nAlthough we do not succeed in proving the Collatz conjecture, we believe that\nthe ideas here represent an interesting new approach.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 04:28:48 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["Yolcu", "Emre", ""], ["Aaronson", "Scott", ""], ["Heule", "Marijn J. H.", ""]]}, {"id": "2105.14706", "submitter": "Zsolt Zombori", "authors": "Zsolt Zombori, Josef Urban, Miroslav Ol\\v{s}\\'ak", "title": "The Role of Entropy in Guiding a Connection Prover", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work we study how to learn good algorithms for selecting reasoning\nsteps in theorem proving. We explore this in the connection tableau calculus\nimplemented by leanCoP where the partial tableau provides a clean and compact\nnotion of a state to which a limited number of inferences can be applied. We\nstart by incorporating a state-of-the-art learning algorithm -- a graph neural\nnetwork (GNN) -- into the plCoP theorem prover. Then we use it to observe the\nsystem's behaviour in a reinforcement learning setting, i.e., when learning\ninference guidance from successful Monte-Carlo tree searches on many problems.\nDespite its better pattern matching capability, the GNN initially performs\nworse than a simpler previously used learning algorithm. We observe that the\nsimpler algorithm is less confident, i.e., its recommendations have higher\nentropy. This leads us to explore how the entropy of the inference selection\nimplemented via the neural network influences the proof search. This is related\nto research in human decision-making under uncertainty, and in particular the\nprobability matching theory. Our main result shows that a proper entropy\nregularisation, i.e., training the GNN not to be overconfident, greatly\nimproves plCoP's performance on a large mathematical corpus.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 04:57:44 GMT"}, {"version": "v2", "created": "Fri, 16 Jul 2021 12:43:12 GMT"}], "update_date": "2021-07-19", "authors_parsed": [["Zombori", "Zsolt", ""], ["Urban", "Josef", ""], ["Ol\u0161\u00e1k", "Miroslav", ""]]}, {"id": "2105.14769", "submitter": "Petar Maksimovi\\'c", "authors": "Petar Maksimovi\\'c, Jos\\'e Fragoso Santos, Sacha-\\'Elie Ayoun,\n  Philippa Gardner", "title": "Gillian: A Multi-Language Platform for Unified Symbolic Analysis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This is an evolving document describing the meta-theory, the implementation,\nand the instantiations of Gillian, a multi-language symbolic analysis platform.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 08:01:45 GMT"}, {"version": "v2", "created": "Mon, 12 Jul 2021 15:09:11 GMT"}], "update_date": "2021-07-13", "authors_parsed": [["Maksimovi\u0107", "Petar", ""], ["Santos", "Jos\u00e9 Fragoso", ""], ["Ayoun", "Sacha-\u00c9lie", ""], ["Gardner", "Philippa", ""]]}, {"id": "2105.14887", "submitter": "Yasir Mahmood", "authors": "Yasir Mahmood and Jonni Virtema", "title": "Parameterised Complexity of Propositional Logic in Team Semantics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this work we analyse the parameterised complexity of propositional\ninclusion (PINC) and independence logic (PIND). The problems of interest are\nmodel checking (MC) and satisfiability (SAT). The complexity of these problems\nis well understood in the classical (non-parameterised) setting. Mahmood and\nMeier (FoIKS 2020) recently studied the parameterised complexity of\npropositional dependence logic (PDL). As a continuation of their work, we\nclassify inclusion and independence logic and thereby come closer to completing\nthe picture with respect to the parametrised complexity for the three most\nstudied logics in the propositional team semantics setting. We present results\nfor each problem with respect to 8 different parameterisations. It turns out\nthat for a team-based logic L such that L-atoms can be evaluated in polynomial\ntime, then MC parameterised by teamsize is FPT. As a corollary, we get an FPT\nmembership under the following parameterisations: formula-size, formula-depth,\ntreewidth, and number of variables. The parameter teamsize shows interesting\nbehavior for SAT. For PINC, the parameter teamsize is not meaningful, whereas\nfor PDL and PIND the satisfiability is paraNP-complete. Finally, we prove that\nwhen parameterised by arity, both MC and SAT are paraNP-complete for each of\nthe considered logics.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 11:21:06 GMT"}], "update_date": "2021-06-04", "authors_parsed": [["Mahmood", "Yasir", ""], ["Virtema", "Jonni", ""]]}, {"id": "2105.14894", "submitter": "Jan K\\v{r}et\\'insk\\'y", "authors": "Jan K\\v{r}et\\'insk\\'y", "title": "LTL-Constrained Steady-State Policy Synthesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.SY eess.SY", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Decision-making policies for agents are often synthesized with the constraint\nthat a formal specification of behaviour is satisfied. Here we focus on\ninfinite-horizon properties. On the one hand, Linear Temporal Logic (LTL) is a\npopular example of a formalism for qualitative specifications. On the other\nhand, Steady-State Policy Synthesis (SSPS) has recently received considerable\nattention as it provides a more quantitative and more behavioural perspective\non specifications, in terms of the frequency with which states are visited.\nFinally, rewards provide a classic framework for quantitative properties. In\nthis paper, we study Markov decision processes (MDP) with the specification\ncombining all these three types. The derived policy maximizes the reward among\nall policies ensuring the LTL specification with the given probability and\nadhering to the steady-state constraints. To this end, we provide a unified\nsolution reducing the multi-type specification to a multi-dimensional long-run\naverage reward. This is enabled by Limit-Deterministic B\\\"uchi Automata (LDBA),\nrecently studied in the context of LTL model checking on MDP, and allows for an\nelegant solution through a simple linear programme. The algorithm also extends\nto the general $\\omega$-regular properties and runs in time polynomial in the\nsizes of the MDP as well as the LDBA.\n", "versions": [{"version": "v1", "created": "Mon, 31 May 2021 11:35:42 GMT"}], "update_date": "2021-06-01", "authors_parsed": [["K\u0159et\u00ednsk\u00fd", "Jan", ""]]}]