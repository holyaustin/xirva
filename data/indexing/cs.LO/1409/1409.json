[{"id": "1409.0166", "submitter": "Carsten Fuhs", "authors": "Carsten Fuhs, Cynthia Kop, Naoki Nishida", "title": "Verifying Procedural Programs via Constrained Rewriting Induction", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper aims to develop a verification method for procedural programs via\na transformation into Logically Constrained Term Rewriting Systems (LCTRSs). To\nthis end, we extend transformation methods based on integer TRSs to handle\narbitrary data types, global variables, function calls and arrays, as well as\nencode safety checks. Then we adapt existing rewriting induction methods to\nLCTRSs and propose a simple yet effective method to generalize equations. We\nshow that we can automatically verify memory safety and prove correctness of\nrealistic functions. Our approach proves equivalence between two\nimplementations, so in contrast to other works, we do not require an explicit\nspecification in a separate specification language.\n", "versions": [{"version": "v1", "created": "Sat, 30 Aug 2014 22:30:03 GMT"}, {"version": "v2", "created": "Mon, 21 Dec 2015 20:58:21 GMT"}, {"version": "v3", "created": "Fri, 30 Sep 2016 19:13:14 GMT"}, {"version": "v4", "created": "Mon, 3 Oct 2016 19:35:28 GMT"}, {"version": "v5", "created": "Sat, 25 Feb 2017 21:24:13 GMT"}], "update_date": "2017-02-28", "authors_parsed": [["Fuhs", "Carsten", ""], ["Kop", "Cynthia", ""], ["Nishida", "Naoki", ""]]}, {"id": "1409.0194", "submitter": "Claudio Garola", "authors": "Claudio Garola", "title": "A Pragmatic Interpretation of Quantum Logic", "comments": "Third version: 20 pages. Sects. 1, 2, and 4 rewritten and improved.\n  Explanations added", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Scholars have wondered for a long time whether the language of quantum\nmechanics introduces a quantum notion of truth which is formalized by quantum\nlogic (QL) and is incompatible with the classical (Tarskian) notion. We show\nthat QL can be interpreted as a pragmatic language of assertive formulas which\nformalize statements about physical systems that are empirically justified or\nunjustified in the framework of quantum mechanics. According to this\ninterpretation, QL formalizes properties of the metalinguistic notion of\nempirical justification within quantum mechanics rather than properties of a\nquantum notion of truth. This conclusion agrees with a general integrationist\nperspective that interprets nonstandard logics as theories of metalinguistic\nnotions different from truth, thus avoiding incompatibility with classical\nnotions and preserving the globality of logic. By the way, some elucidations of\nthe standard notion of quantum truth are also obtained.\n  Key words: pragmatics, quantum logic, quantum mechanics, justifiability,\nglobal pluralism.\n", "versions": [{"version": "v1", "created": "Sun, 31 Aug 2014 08:43:14 GMT"}, {"version": "v2", "created": "Fri, 26 Sep 2014 17:15:46 GMT"}, {"version": "v3", "created": "Wed, 16 Dec 2015 17:28:43 GMT"}], "update_date": "2015-12-17", "authors_parsed": [["Garola", "Claudio", ""]]}, {"id": "1409.0266", "submitter": "Robert Constable", "authors": "Robert L. Constable", "title": "Virtual Evidence: A Constructive Semantics for Classical Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article presents a computational semantics for classical logic using\nconstructive type theory. Such semantics seems impossible because classical\nlogic allows the Law of Excluded Middle (LEM), not accepted in constructive\nlogic since it does not have computational meaning. However, the apparently\noracular powers expressed in the LEM, that for any proposition P either it or\nits negation, not P, is true can also be explained in terms of constructive\nevidence that does not refer to \"oracles for truth.\" Types with virtual\nevidence and the constructive impossibility of negative evidence provide\nsufficient semantic grounds for classical truth and have a simple computational\nmeaning. This idea is formalized using refinement types, a concept of\nconstructive type theory used since 1984 and explained here. A new axiom\ncreating virtual evidence fully retains the constructive meaning of the logical\noperators in classical contexts.\n  Key Words: classical logic, constructive logic, intuitionistic logic,\npropositions-as-types, constructive type theory, refinement types, double\nnegation translation, computational content, virtual evidence\n", "versions": [{"version": "v1", "created": "Sun, 31 Aug 2014 21:15:40 GMT"}], "update_date": "2014-09-02", "authors_parsed": [["Constable", "Robert L.", ""]]}, {"id": "1409.0309", "submitter": "Ron van der Meyden", "authors": "Stephen Chong and Ron van der Meyden", "title": "Using Architecture to Reason about Information Security", "comments": null, "journal-ref": null, "doi": "10.1145/2829949", "report-no": null, "categories": "cs.CR cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We demonstrate, by a number of examples, that information-flow security\nproperties can be proved from abstract architectural descriptions, that\ndescribe only the causal structure of a system and local properties of trusted\ncomponents. We specify these architectural descriptions of systems by\ngeneralizing intransitive noninterference policies to admit the ability to\nfilter information passed between communicating domains. A notion of refinement\nof such system architectures is developed that supports top-down development of\narchitectural specifications and proofs by abstraction of information security\nproperties. We also show that, in a concrete setting where the causal structure\nis enforced by access control, a static check of the access control setting\nplus local verification of the trusted components is sufficient to prove that a\ngeneralized intransitive noninterference policy is satisfied.\n", "versions": [{"version": "v1", "created": "Mon, 1 Sep 2014 07:25:54 GMT"}], "update_date": "2016-01-05", "authors_parsed": [["Chong", "Stephen", ""], ["van der Meyden", "Ron", ""]]}, {"id": "1409.0496", "submitter": "Marius Zimand", "authors": "Jason Teutsch and Marius Zimand", "title": "On approximate decidability of minimal programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An index $e$ in a numbering of partial-recursive functions is called minimal\nif every lesser index computes a different function from $e$. Since the 1960's\nit has been known that, in any reasonable programming language, no effective\nprocedure determines whether or not a given index is minimal. We investigate\nwhether the task of determining minimal indices can be solved in an approximate\nsense. Our first question, regarding the set of minimal indices, is whether\nthere exists an algorithm which can correctly label 1 out of $k$ indices as\neither minimal or non-minimal. Our second question, regarding the function\nwhich computes minimal indices, is whether one can compute a short list of\ncandidate indices which includes a minimal index for a given program. We give\nsome negative results and leave the possibility of positive results as open\nquestions.\n", "versions": [{"version": "v1", "created": "Mon, 1 Sep 2014 18:10:29 GMT"}], "update_date": "2014-09-02", "authors_parsed": [["Teutsch", "Jason", ""], ["Zimand", "Marius", ""]]}, {"id": "1409.0582", "submitter": "Tahiry  Rabehaja", "authors": "Annabelle McIver and Tahiry Rabehaja and Georg Struth", "title": "Probabilistic Rely-guarantee Calculus", "comments": "Preprint submitted to TCS-QAPL", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Jones' rely-guarantee calculus for shared variable concurrency is extended to\ninclude probabilistic behaviours. We use an algebraic approach which combines\nand adapts probabilistic Kleene algebras with concurrent Kleene algebra.\nSoundness of the algebra is shown relative to a general probabilistic event\nstructure semantics. The main contribution of this paper is a collection of\nrely-guarantee rules built on top of that semantics. In particular, we show how\nto obtain bounds on probabilities by deriving rely-guarantee rules within the\ntrue-concurrent denotational semantics. The use of these rules is illustrated\nby a detailed verification of a simple probabilistic concurrent program: a\nfaulty Eratosthenes sieve.\n", "versions": [{"version": "v1", "created": "Mon, 1 Sep 2014 23:33:55 GMT"}, {"version": "v2", "created": "Mon, 15 Sep 2014 15:02:32 GMT"}, {"version": "v3", "created": "Tue, 2 Jun 2015 07:31:15 GMT"}], "update_date": "2015-06-03", "authors_parsed": [["McIver", "Annabelle", ""], ["Rabehaja", "Tahiry", ""], ["Struth", "Georg", ""]]}, {"id": "1409.0731", "submitter": "Antti Kuusisto", "authors": "Emanuel Kiero\\'nski and Antti Kuusisto", "title": "Complexity and Expressivity of Uniform One-Dimensional Fragment with\n  Equality", "comments": "preprint", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Uniform one-dimensional fragment UF1^= is a formalism obtained from\nfirst-order logic by limiting quantification to applications of blocks of\nexistential (universal) quantifiers such that at most one variable remains free\nin the quantified formula. The fragment is closed under Boolean operations, but\nadditional restrictions (called uniformity conditions) apply to combinations of\natomic formulas with two or more variables. The fragment can be seen as a\ncanonical generalization of two-variable logic, defined in order to be able to\ndeal with relations of arbitrary arities. The fragment was introduced recently,\nand it was shown that the satisfiability problem of the equality-free fragment\nof UF1^= is decidable. In this article we establish that the satisfiability and\nfinite satisfiability problems of UF1^= are NEXPTIME-complete. We also show\nthat the corresponding problems for the extension of UF1^= with counting\nquantifiers are undecidable. In addition to decidability questions, we compare\nthe expressivities of UF1^= and two-variable logic with counting quantifiers\nFOC^2. We show that while the logics are incomparable in general, UF1^= is\nstrictly contained in FOC^2 when attention is restricted to vocabularies with\nthe arity bound two.\n", "versions": [{"version": "v1", "created": "Tue, 2 Sep 2014 14:40:43 GMT"}], "update_date": "2014-09-03", "authors_parsed": [["Kiero\u0144ski", "Emanuel", ""], ["Kuusisto", "Antti", ""]]}, {"id": "1409.0824", "submitter": "Daniel Osherson", "authors": "Daniel Osherson and Scott Weinstein", "title": "Deontic modality based on preference", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deontic modalities are here defined in terms of the preference relation\nexplored in our previous work (Osherson and Weinstein, 2012). Some consequences\nof the system are discussed.\n", "versions": [{"version": "v1", "created": "Tue, 2 Sep 2014 19:01:01 GMT"}], "update_date": "2014-09-03", "authors_parsed": [["Osherson", "Daniel", ""], ["Weinstein", "Scott", ""]]}, {"id": "1409.1544", "submitter": "Thomas Streicher", "authors": "Ingo Battenfeld, Klaus Keimel, Thomas Streicher", "title": "Observationally-induced algebras in Domain Theory", "comments": "26 pages", "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 3 (September\n  11, 2014) lmcs:963", "doi": "10.2168/LMCS-10(3:18)2014", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we revise and simplify the notion of observationally induced\nalgebra introduced by Simpson and Schroeder for the purpose of modelling\ncomputational effects in the particular case where the ambient category is\ngiven by classical domain theory. As examples of the general framework we\nconsider the various powerdomains. For the particular case of the Plotkin\npowerdomain the general recipe leads to a somewhat unexpected result which,\nhowever, makes sense from a Computer Science perspective. We analyze this\n\"deviation\" and show how to reobtain the original Plotkin powerdomain by\nimposing further conditions previously considered by R.~Heckmann and\nJ.~Goubault-Larrecq.\n", "versions": [{"version": "v1", "created": "Thu, 4 Sep 2014 19:09:12 GMT"}, {"version": "v2", "created": "Fri, 5 Sep 2014 10:41:07 GMT"}, {"version": "v3", "created": "Wed, 10 Sep 2014 14:57:23 GMT"}, {"version": "v4", "created": "Thu, 27 Oct 2016 15:29:15 GMT"}], "update_date": "2016-10-28", "authors_parsed": [["Battenfeld", "Ingo", ""], ["Keimel", "Klaus", ""], ["Streicher", "Thomas", ""]]}, {"id": "1409.1752", "submitter": "Willem Fouch\\'e", "authors": "Willem L. Fouche", "title": "Diophantine properties of Brownian motion: recursive aspects", "comments": "Appeared in: Logic, Computation, Hierarchies, (Brattka, Diener,\n  Spreen (Eds)), Ontos Verlag, 2014, pp 139-156. arXiv admin note: substantial\n  text overlap with arXiv:1409.1060", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We use recent results on the Fourier analysis of the zero sets of Brownian\nmotion to explore the diophantine properties of an algorithmically random\nBrownian motion (also known as a complex oscillation). We discuss the\nconstruction and definability of perfect sets which are linearly independent\nover the rationals directly from Martin-L\\\"of random reals. Finally we explore\nthe recent work of Tsirelson on countable dense sets to study the diophantine\nproperties of local minimisers of Brownian motion.\n", "versions": [{"version": "v1", "created": "Wed, 3 Sep 2014 12:42:11 GMT"}], "update_date": "2014-09-08", "authors_parsed": [["Fouche", "Willem L.", ""]]}, {"id": "1409.2193", "submitter": "Xiaowei Huang", "authors": "Xiaowei Huang and Ron van der Meyden", "title": "An Epistemic Strategy Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents an extension of temporal epistemic logic with operators\nthat quantify over agent strategies. Unlike previous work on alternating\ntemporal epistemic logic, the semantics works with systems whose states\nexplicitly encode the strategy being used by each of the agents. This provides\na natural way to express what agents would know were they to be aware of some\nof the strategies being used by other agents. A number of examples that rely\nupon the ability to express an agent's knowledge about the strategies being\nused by other agents are presented to motivate the framework, including\nreasoning about game theoretic equilibria, knowledge-based programs, and\ninformation theoretic computer security policies. Relationships to several\nvariants of alternating temporal epistemic logic are discussed. The\ncomputational complexity of model checking the logic and several of its\nfragments are also characterized.\n", "versions": [{"version": "v1", "created": "Mon, 8 Sep 2014 02:53:53 GMT"}, {"version": "v2", "created": "Fri, 24 Nov 2017 21:35:17 GMT"}, {"version": "v3", "created": "Wed, 11 Jul 2018 20:59:36 GMT"}], "update_date": "2018-07-13", "authors_parsed": [["Huang", "Xiaowei", ""], ["van der Meyden", "Ron", ""]]}, {"id": "1409.2294", "submitter": "EPTCS", "authors": "Maurice H. ter Beek (ISTI-CNR, Pisa, Italy), Ant\\'onio Ravara (New\n  University of Lisbon, Portugal)", "title": "Proceedings 10th International Workshop on Automated Specification and\n  Verification of Web Systems", "comments": null, "journal-ref": "EPTCS 163, 2014", "doi": "10.4204/EPTCS.163", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  These proceedings contain the papers presented at the 10th International\nWorkshop on Automated Specification and Verification of Web Systems (WWV 2014),\nwhich was held on 18 July 2014 in Vienna, Austria, as a satellite workshop of\nthe Federated Logic Conference (FLoC 2014), associated to the 7th International\nJoint Conference on Automated Reasoning (IJCAR 2014), as part of the Vienna\nSummer of Logic (VSL 2014).\n  WWV is a yearly workshop that aims at providing an interdisciplinary forum to\nfacilitate the cross-fertilization and the advancement of hybrid methods that\nexploit concepts and tools drawn from rule-based programming, formal methods,\nsoftware engineering and Web-oriented research.\n", "versions": [{"version": "v1", "created": "Mon, 8 Sep 2014 11:23:02 GMT"}], "update_date": "2014-09-09", "authors_parsed": [["ter Beek", "Maurice H.", "", "ISTI-CNR, Pisa, Italy"], ["Ravara", "Ant\u00f3nio", "", "New\n  University of Lisbon, Portugal"]]}, {"id": "1409.2408", "submitter": "B\\'eatrice B\\'erard", "authors": "B\\'eatrice B\\'erard, Serge Haddad, Aleksandra Jovanovi\\'c, Didier Lime", "title": "Interrupt Timed Automata with Auxiliary Clocks and Parameters", "comments": "26 pages, 6 figures, extended version from Reachability Problems 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Interrupt Timed Automata (ITA) is an expressive timed model, introduced to\ntake into account interruptions, according to levels. Due to this feature, this\nformalism is incomparable with Timed Automata. However several decidability\nresults related to reachability and model checking have been obtained. We add\nauxiliary clocks to ITA, thereby extending its expressive power while\npreserving decidability of reachability. Moreover, we define a parametrized\nversion of ITA, with polynomials of parameters appearing in guards and updates.\nWhile parametric reasoning is particularly relevant for timed models, it very\noften leads to undecidability results. We prove that various reachability\nproblems, including \"robust\" reachability, are decidable for this model, and we\ngive complexity upper bounds for a fixed or variable number of clocks, levels\nand parameters.\n", "versions": [{"version": "v1", "created": "Mon, 8 Sep 2014 15:56:45 GMT"}], "update_date": "2014-09-09", "authors_parsed": [["B\u00e9rard", "B\u00e9atrice", ""], ["Haddad", "Serge", ""], ["Jovanovi\u0107", "Aleksandra", ""], ["Lime", "Didier", ""]]}, {"id": "1409.2591", "submitter": "EPTCS", "authors": "R. Ramanujam (IMSc, Chennai), S. Sheerazuddin (SSNCE, Chennai)", "title": "A Local Logic for Realizability in Web Service Choreographies", "comments": "In Proceedings WWV 2014, arXiv:1409.2294", "journal-ref": "EPTCS 163, 2014, pp. 16-35", "doi": "10.4204/EPTCS.163.3", "report-no": null, "categories": "cs.LO cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Web service choreographies specify conditions on observable interactions\namong the services. An important question in this regard is realizability:\ngiven a choreography C, does there exist a set of service implementations I\nthat conform to C ? Further, if C is realizable, is there an algorithm to\nconstruct implementations in I ? We propose a local temporal logic in which\nchoreographies can be specified, and for specifications in the logic, we solve\nthe realizability problem by constructing service implementations (when they\nexist) as communicating automata. These are nondeterministic finite state\nautomata with a coupling relation. We also report on an implementation of the\nrealizability algorithm and discuss experimental results.\n", "versions": [{"version": "v1", "created": "Tue, 9 Sep 2014 04:12:49 GMT"}], "update_date": "2014-09-10", "authors_parsed": [["Ramanujam", "R.", "", "IMSc, Chennai"], ["Sheerazuddin", "S.", "", "SSNCE, Chennai"]]}, {"id": "1409.2593", "submitter": "EPTCS", "authors": "Paulo Oliva (Queen Mary University of London)", "title": "Proceedings Fifth International Workshop on Classical Logic and\n  Computation", "comments": null, "journal-ref": "EPTCS 164, 2014", "doi": "10.4204/EPTCS.164", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Classical Logic and Computation (CL&C) 2014 is the fifth edition of this\nworkshop series. The workshop series intends to cover all work aiming to\nexplore computational aspects of classical logic and mathematics. Its focus is\non the exploration of the computational content of mathematical and logical\nprinciples, aiming to bring together researchers from both fields and exchange\nideas. In this fifth edition we received 18 submissions of both short and full\npapers. Fourteen (14) of these were selected to present at the meeting in\nVienna, and six (6) full papers were accepted to appear at this ETPCS special\nvolume. Topics covered by this years submissions included: translations of\nclassical to intuitionistic proofs, witness extraction from classical proofs,\nconfluence properties for classical systems, linear logic, constructive\nsemantics for classical logic (game semantics, realizability), and the study of\ncalculi based on classical logic (lambda-mu-calculus, continuation calculus).\n", "versions": [{"version": "v1", "created": "Tue, 9 Sep 2014 04:26:39 GMT"}], "update_date": "2014-09-10", "authors_parsed": [["Oliva", "Paulo", "", "Queen Mary University of London"]]}, {"id": "1409.2612", "submitter": "Hans van Ditmarsch", "authors": "Philippe Balbiani and Hans van Ditmarsch", "title": "A simple proof of the completeness of APAL", "comments": null, "journal-ref": "Studies in Logic (ISSN 1674-32-4), volume 8(1), pages 65-78, 2015", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide a simple proof of the completeness of arbitrary public\nannouncement logic APAL. The proof is an improvement over the proof found in\nthe publication Knowable as Known after an Announcement.\n", "versions": [{"version": "v1", "created": "Tue, 9 Sep 2014 06:30:19 GMT"}, {"version": "v2", "created": "Wed, 10 Sep 2014 05:59:45 GMT"}], "update_date": "2018-02-06", "authors_parsed": [["Balbiani", "Philippe", ""], ["van Ditmarsch", "Hans", ""]]}, {"id": "1409.2711", "submitter": "Bastien Maubert", "authors": "Laura Bozzelli, Bastien Maubert and Sophie Pinchinat", "title": "Unifying Hyper and Epistemic Temporal Logic", "comments": "12 pages, plus 35 pages of appendix. Submitted to FSTTCS 2014", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the literature, two powerful temporal logic formalisms have been proposed\nfor expressing information flow security requirements, that in general, go\nbeyond regular properties. One is classic, based on the knowledge modalities of\nepistemic logic. The other one, the so called hyper logic, is more recent and\nsubsumes many proposals from the literature; it is based on explicit and\nsimultaneous quantification over multiple paths. In an attempt to better\nunderstand how these logics compare with each other, we consider the logic\nKCTL* (the extension of CTL* with knowledge modalities and synchronous perfect\nrecall semantics) and HyperCTL*. We first establish that KCTL* and HyperCTL*\nare expressively incomparable. Second, we introduce and study a natural linear\npast extension of HyperCTL* to unify KCTL* and HyperCTL*; indeed, we show that\nKCTL* can be easily translated in linear time into the proposed logic.\nMoreover, we show that the model-checking problem for this novel logic is\ndecidable, and we provide its exact computational complexity in terms of a new\nmeasure of path quantifiers' alternation. For this, we settle open complexity\nissues for unrestricted quantified propositional temporal logic.\n", "versions": [{"version": "v1", "created": "Tue, 9 Sep 2014 12:25:15 GMT"}], "update_date": "2014-09-10", "authors_parsed": [["Bozzelli", "Laura", ""], ["Maubert", "Bastien", ""], ["Pinchinat", "Sophie", ""]]}, {"id": "1409.2731", "submitter": "Jakob Nordstr\\\"om", "authors": "Albert Atserias, Massimo Lauria, Jakob Nordstr\\\"om", "title": "Narrow Proofs May Be Maximally Long", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that there are 3-CNF formulas over n variables that can be refuted\nin resolution in width w but require resolution proofs of size n^Omega(w). This\nshows that the simple counting argument that any formula refutable in width w\nmust have a proof in size n^O(w) is essentially tight. Moreover, our lower\nbound generalizes to polynomial calculus resolution (PCR) and Sherali-Adams,\nimplying that the corresponding size upper bounds in terms of degree and rank\nare tight as well. Our results do not extend all the way to Lasserre, however,\nwhere the formulas we study have proofs of constant rank and size polynomial in\nboth n and w.\n", "versions": [{"version": "v1", "created": "Tue, 9 Sep 2014 13:33:09 GMT"}], "update_date": "2014-09-10", "authors_parsed": [["Atserias", "Albert", ""], ["Lauria", "Massimo", ""], ["Nordstr\u00f6m", "Jakob", ""]]}, {"id": "1409.2778", "submitter": "Matteo Camilli M.Sc.", "authors": "Matteo Camilli", "title": "Verification of Reachability Problems for Time Basic Petri Nets", "comments": "21 pages. arXiv admin note: substantial text overlap with\n  arXiv:1107.1166 by other authors", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Time-Basic Petri nets, is a powerful formalism for model- ing real-time\nsystems where time constraints are expressed through time functions of\nmarking's time description associated with transition, representing possible\nfiring times. We introduce a technique for reachability analysis based on the\nbuilding of finite contraction of the infinite state space associated with such\na models. The technique constructs a finite symbolic reachability graph relying\non a sort of time coverage, and over- comes the limitations of the existing\navailable analyzers for Time-Basic nets, based in turn on a time-bounded\ninspection of a (possibly infinite) reachability-tree. A key feature of the\ntechnique is the introduction of the Time Anonymous concept, which allows the\nidentification of components not influencing the evolution of a model. A\nrunning example is used throughout the paper to sketch the symbolic graph\nconstruction. The graph construction algorithm has been automated by a Java\ntool-set, described in the paper together with its main functionality and\nanalysis capability. A use case describing a real-world example has been\nemployed to benchmark the technique and the tool-set. The main outcome of this\ntest are also presented in the paper.\n", "versions": [{"version": "v1", "created": "Tue, 9 Sep 2014 15:31:00 GMT"}], "update_date": "2014-09-10", "authors_parsed": [["Camilli", "Matteo", ""]]}, {"id": "1409.2978", "submitter": "Jakob Nordstr\\\"om", "authors": "Yuval Filmus, Massimo Lauria, Mladen Mik\\v{s}a, Jakob Nordstr\\\"om,\n  Marc Vinyals", "title": "From Small Space to Small Width in Resolution", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In 2003, Atserias and Dalmau resolved a major open question about the\nresolution proof system by establishing that the space complexity of CNF\nformulas is always an upper bound on the width needed to refute them. Their\nproof is beautiful but somewhat mysterious in that it relies heavily on tools\nfrom finite model theory. We give an alternative, completely elementary proof\nthat works by simple syntactic manipulations of resolution refutations. As a\nby-product, we develop a \"black-box\" technique for proving space lower bounds\nvia a \"static\" complexity measure that works against any resolution\nrefutation---previous techniques have been inherently adaptive. We conclude by\nshowing that the related question for polynomial calculus (i.e., whether space\nis an upper bound on degree) seems unlikely to be resolvable by similar\nmethods.\n", "versions": [{"version": "v1", "created": "Wed, 10 Sep 2014 07:49:54 GMT"}], "update_date": "2014-09-11", "authors_parsed": [["Filmus", "Yuval", ""], ["Lauria", "Massimo", ""], ["Mik\u0161a", "Mladen", ""], ["Nordstr\u00f6m", "Jakob", ""], ["Vinyals", "Marc", ""]]}, {"id": "1409.3290", "submitter": "Wenyan Xu", "authors": "Wenyan Xu", "title": "A cirquent calculus system with clustering and ranking", "comments": "arXiv admin note: substantial text overlap with arXiv:1402.4172", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cirquent calculus is a new proof-theoretic and semantic approach introduced\nby G.Japaridze for the needs of his theory of computability logic. The earlier\narticle \"From formulas to cirquents in computability logic\" by Japaridze\ngeneralized the concept of cirquents to the version with what are termed\nclusterng and ranking, and showed that, through cirquents with clustering and\nranking, one can capture, refine and generalize the so called extended IF\nlogic. Japaridze's treatment of extended IF logic, however, was purely\nsemantical, and no deductive system was proposed. The present paper\nsyntactically constructs a cirquent calculus system with clustering and\nranking, sound and complete w.r.t. the propositional fragment of cirquent-based\nsemantics. Such a system can be considered not only a conservative extension of\nclassical propositional logic but also, when limited to cirquents with no more\nthan 2 ranks, an axiomatization of purely propositional extended IF logic in\nits full generality.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 01:23:06 GMT"}], "update_date": "2014-09-12", "authors_parsed": [["Xu", "Wenyan", ""]]}, {"id": "1409.3313", "submitter": "EPTCS", "authors": "Herman Geuvers (Radboud Universiteit Nijmegen, Technical University\n  Eindhoven), Wouter Geraedts (Radboud Universiteit Nijmegen), Bram Geron\n  (University of Birmingham), Judith van Stegeren (Radboud Universiteit\n  Nijmegen)", "title": "A type system for Continuation Calculus", "comments": "In Proceedings CL&C 2014, arXiv:1409.2593", "journal-ref": "EPTCS 164, 2014, pp. 1-17", "doi": "10.4204/EPTCS.164.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Continuation Calculus (CC), introduced by Geron and Geuvers, is a simple\nfoundational model for functional computation. It is closely related to lambda\ncalculus and term rewriting, but it has no variable binding and no pattern\nmatching. It is Turing complete and evaluation is deterministic. Notions like\n\"call-by-value\" and \"call-by-name\" computation are available by choosing\nappropriate function definitions: e.g. there is a call-by-value and a\ncall-by-name addition function. In the present paper we extend CC with types,\nto be able to define data types in a canonical way, and functions over these\ndata types, defined by iteration. Data type definitions follow the so-called\n\"Scott encoding\" of data, as opposed to the more familiar \"Church encoding\".\nThe iteration scheme comes in two flavors: a call-by-value and a call-by-name\niteration scheme. The call-by-value variant is a double negation variant of\ncall-by-name iteration. The double negation translation allows to move between\ncall-by-name and call-by-value.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 03:41:53 GMT"}], "update_date": "2014-09-12", "authors_parsed": [["Geuvers", "Herman", "", "Radboud Universiteit Nijmegen, Technical University\n  Eindhoven"], ["Geraedts", "Wouter", "", "Radboud Universiteit Nijmegen"], ["Geron", "Bram", "", "University of Birmingham"], ["van Stegeren", "Judith", "", "Radboud Universiteit\n  Nijmegen"]]}, {"id": "1409.3314", "submitter": "EPTCS", "authors": "Steffen van Bakel (Imperial College London), Maria Grazia Vigliotti\n  (Adelard PLC)", "title": "A fully-abstract semantics of lambda-mu in the pi-calculus", "comments": "In Proceedings CL&C 2014, arXiv:1409.2593", "journal-ref": "EPTCS 164, 2014, pp. 33-47", "doi": "10.4204/EPTCS.164.3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the lambda-mu-calculus, extended with explicit substitution, and\ndefine a compositional output-based interpretation into a variant of the\npi-calculus with pairing that preserves single-step explicit head reduction\nwith respect to weak bisimilarity. We define four notions of weak equivalence\nfor lambda-mu -- one based on weak reduction, two modelling weak head-reduction\nand weak explicit head reduction (all considering terms without weak\nhead-normal form equivalent as well), and one based on weak approximation --\nand show they all coincide. We will then show full abstraction results for our\ninterpretation for the weak equivalences with respect to weak bisimilarity on\nprocesses.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 03:42:15 GMT"}], "update_date": "2016-02-22", "authors_parsed": [["van Bakel", "Steffen", "", "Imperial College London"], ["Vigliotti", "Maria Grazia", "", "Adelard PLC"]]}, {"id": "1409.3315", "submitter": "EPTCS", "authors": "Michele Basaldella (Universit\\'e d'Aix-Marseille, CNRS, I2M,\n  Marseille, France)", "title": "Infinitary Classical Logic: Recursive Equations and Interactive\n  Semantics", "comments": "In Proceedings CL&C 2014, arXiv:1409.2593", "journal-ref": "EPTCS 164, 2014, pp. 48-62", "doi": "10.4204/EPTCS.164.4", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present an interactive semantics for derivations in an\ninfinitary extension of classical logic. The formulas of our language are\npossibly infinitary trees labeled by propositional variables and logical\nconnectives. We show that in our setting every recursive formula equation has a\nunique solution. As for derivations, we use an infinitary variant of\nTait-calculus to derive sequents. The interactive semantics for derivations\nthat we introduce in this article is presented as a debate (interaction tree)\nbetween a test << T >> (derivation candidate, Proponent) and an environment <<\nnot S >> (negation of a sequent, Opponent). We show a completeness theorem for\nderivations that we call interactive completeness theorem: the interaction\nbetween << T >> (test) and << not S >> (environment) does not produce errors\n(i.e., Proponent wins) just in case << T >> comes from a syntactical derivation\nof << S >>.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 03:42:21 GMT"}], "update_date": "2014-09-12", "authors_parsed": [["Basaldella", "Michele", "", "Universit\u00e9 d'Aix-Marseille, CNRS, I2M,\n  Marseille, France"]]}, {"id": "1409.3316", "submitter": "EPTCS", "authors": "Jos\\'e Esp\\'irito Santo, Ralph Matthes, Koji Nakazawa, Lu\\'is Pinto", "title": "Confluence for classical logic through the distinction between values\n  and computations", "comments": "In Proceedings CL&C 2014, arXiv:1409.2593", "journal-ref": "EPTCS 164, 2014, pp. 63-77", "doi": "10.4204/EPTCS.164.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We apply an idea originated in the theory of programming languages - monadic\nmeta-language with a distinction between values and computations - in the\ndesign of a calculus of cut-elimination for classical logic. The\ncut-elimination calculus we obtain comprehends the call-by-name and\ncall-by-value fragments of Curien-Herbelin's lambda-bar-mu-mu-tilde-calculus\nwithout losing confluence, and is based on a distinction of \"modes\" in the\nproof expressions and \"mode\" annotations in types. Modes resemble colors and\npolarities, but are quite different: we give meaning to them in terms of a\nmonadic meta-language where the distinction between values and computations is\nfully explored. This meta-language is a refinement of the classical monadic\nlanguage previously introduced by the authors, and is also developed in the\npaper.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 03:42:32 GMT"}], "update_date": "2014-09-12", "authors_parsed": [["Santo", "Jos\u00e9 Esp\u00edrito", ""], ["Matthes", "Ralph", ""], ["Nakazawa", "Koji", ""], ["Pinto", "Lu\u00eds", ""]]}, {"id": "1409.3360", "submitter": "Martin Chmel\\'ik", "authors": "Krishnendu Chatterjee, Martin Chmel\\'ik, Raghav Gupta, Ayush Kanodia", "title": "Qualitative Analysis of POMDPs with Temporal Logic Specifications for\n  Robotics Applications", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider partially observable Markov decision processes (POMDPs), that are\na standard framework for robotics applications to model uncertainties present\nin the real world, with temporal logic specifications. All temporal logic\nspecifications in linear-time temporal logic (LTL) can be expressed as parity\nobjectives. We study the qualitative analysis problem for POMDPs with parity\nobjectives that asks whether there is a controller (policy) to ensure that the\nobjective holds with probability 1 (almost-surely). While the qualitative\nanalysis of POMDPs with parity objectives is undecidable, recent results show\nthat when restricted to finite-memory policies the problem is EXPTIME-complete.\nWhile the problem is intractable in theory, we present a practical approach to\nsolve the qualitative analysis problem. We designed several heuristics to deal\nwith the exponential complexity, and have used our implementation on a number\nof well-known POMDP examples for robotics applications. Our results provide the\nfirst practical approach to solve the qualitative analysis of robot motion\nplanning with LTL properties in the presence of uncertainty.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 09:16:49 GMT"}, {"version": "v2", "created": "Fri, 26 Sep 2014 12:24:45 GMT"}, {"version": "v3", "created": "Wed, 18 Feb 2015 15:36:43 GMT"}], "update_date": "2015-02-19", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Chmel\u00edk", "Martin", ""], ["Gupta", "Raghav", ""], ["Kanodia", "Ayush", ""]]}, {"id": "1409.3428", "submitter": "Arno Pauly", "authors": "Arno Pauly and Willem L. Fouch\\'e", "title": "How constructive is constructing measures?", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given some set, how hard is it to construct a measure supported by it? We\nclassify some variations of this task in the Weihrauch lattice. Particular\nattention is paid to Frostman measures on sets with positive Hausdorff\ndimension. As a side result, the Weihrauch degree of Hausdorff dimension itself\nis determined.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 13:17:44 GMT"}], "update_date": "2014-09-12", "authors_parsed": [["Pauly", "Arno", ""], ["Fouch\u00e9", "Willem L.", ""]]}, {"id": "1409.3560", "submitter": "Sicun Gao", "authors": "Sicun Gao", "title": "Descriptive Control Theory: A Proposal", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logic is playing an increasingly important role in the engineering of\nreal-time, hybrid, and cyber-physical systems, but mostly in the form of\nposterior verification and high-level analysis. The core methodology in the\ndesign of real-world systems consists mainly of control theory and numerical\nanalysis, and has remained mostly free of logic and formal approaches. As a\nresult, besides facing extreme difficulty in guaranteeing the reliability of\nthese systems, engineers are also missing out the computational power of\nlogic-based methods that has greatly advanced in the past decades. To change\nthis situation, we need a logical and computational foundation for control\ntheory. The name \"descriptive control theory\" emphasizes the overarching theme\nof using logic to express, analyze, and solve problems in control theory. If\nthe program is successfully carried out, logical approaches will significantly\nextend existing engineering methods towards a unified methodology for handling\nnonlinear and hybrid systems, and bring design automation and reliability to an\nunprecedented level in the broad field of engineering.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 19:55:22 GMT"}, {"version": "v2", "created": "Sun, 14 Sep 2014 04:11:44 GMT"}], "update_date": "2014-09-16", "authors_parsed": [["Gao", "Sicun", ""]]}, {"id": "1409.3696", "submitter": "Peter  Bezd\\u{e}k", "authors": "Peter Bezd\\v{e}k and Nikola Bene\\v{s} and Ji\\v{r}\\'i Barnat and Ivana\n  \\v{C}ern\\'a", "title": "LTL Parameter Synthesis of Parametric Timed Automata", "comments": "23 pages, extended version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The parameter synthesis problem for parametric timed automata is undecidable\nin general even for very simple reachability properties. In this paper we\nintroduce restrictions on parameter valuations under which the parameter\nsynthesis problem is decidable for LTL properties. The investigated bounded\ninteger parameter synthesis problem could be solved using an explicit\nenumeration of all possible parameter valuations. We propose an alternative\nsymbolic zone-based method for this problem which results in a faster\ncomputation. Our technique extends the ideas of the automata-based approach to\nLTL model checking of timed automata. To justify the usefulness of our\napproach, we provide experimental evaluation and compare our method with\nexplicit enumeration technique.\n", "versions": [{"version": "v1", "created": "Fri, 12 Sep 2014 10:53:32 GMT"}, {"version": "v2", "created": "Fri, 4 Mar 2016 17:03:49 GMT"}], "update_date": "2016-03-07", "authors_parsed": [["Bezd\u011bk", "Peter", ""], ["Bene\u0161", "Nikola", ""], ["Barnat", "Ji\u0159\u00ed", ""], ["\u010cern\u00e1", "Ivana", ""]]}, {"id": "1409.3804", "submitter": "Jiri Adamek", "authors": "Ji\\v{r}\\'i Ad\\'amek, Nathan Bowler, Paul B. Levy and Stefan Milius", "title": "Coproducts of Monads on Set", "comments": "Presented at the conference \"27th Annual Symposium on Logic in\n  Computer Science (LICS 2012)\". The current version contains proofs of some of\n  the results in the appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Coproducts of monads on Set have arisen in both the study of computational\neffects and universal algebra.\n  We describe coproducts of consistent monads on Set by an initial algebra\nformula, and prove also the converse: if the coproduct exists, so do the\nrequired initial algebras. That formula was, in the case of ideal monads, also\nused by Ghani and Uustalu. We deduce that coproduct embeddings of consistent\nmonads are injective; and that a coproduct of injective monad morphisms is\ninjective.\n  Two consistent monads have a coproduct iff either they have arbitrarily large\ncommon fixpoints, or one is an exception monad, possibly modified to preserve\nthe empty set. Hence a consistent monad has a coproduct with every monad iff it\nis an exception monad, possibly modified to preserve the empty set. We also\nshow other fixpoint results, including that a functor (not constant on nonempty\nsets) is finitary iff every sufficiently large cardinal is a fixpoint.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 10:03:32 GMT"}], "update_date": "2014-09-15", "authors_parsed": [["Ad\u00e1mek", "Ji\u0159\u00ed", ""], ["Bowler", "Nathan", ""], ["Levy", "Paul B.", ""], ["Milius", "Stefan", ""]]}, {"id": "1409.3805", "submitter": "Jiri Adamek", "authors": "Ji\\v{r}\\'i Ad\\'amek", "title": "Colimits of Monads", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The category of all monads over many-sorted sets (and over other \"set-like\"\ncategories) is proved to have coequalizers and strong cointersections. And a\ngeneral diagram has a colimit whenever all the monads involved preserve\nmonomorphisms and have arbitrarily large joint pre-fixpoints. In contrast,\ncoequalizers fail to exist e.g. for monads over the (presheaf) category of\ngraphs.\n  For more general categories we extend the results on coproducts of monads\nfrom [2]. We call a monad separated if, when restricted to monomorphisms, its\nunit has a complement. We prove that every collection of separated monads with\narbitrarily large joint pre-fixpoints has a coproduct. And a concrete formula\nfor these coproducts is presented.\n", "versions": [{"version": "v1", "created": "Thu, 11 Sep 2014 10:10:30 GMT"}], "update_date": "2014-09-15", "authors_parsed": [["Ad\u00e1mek", "Ji\u0159\u00ed", ""]]}, {"id": "1409.3819", "submitter": "Stephan Merz", "authors": "Damien Doligez (INRIA Paris-Rocquencourt), Jael Kriener (MSR - INRIA),\n  Leslie Lamport, Tomer Libal (MSR - INRIA), Stephan Merz (INRIA Nancy - Grand\n  Est / LORIA)", "title": "Coalescing: Syntactic Abstraction for Reasoning in First-Order Modal\n  Logics", "comments": "appears in Automated Reasoning in Quantified Non-Classical Logics\n  (2014)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a syntactic abstraction method to reason about first-order modal\nlogics by using theorem provers for standard first-order logic and for\npropositional modal logic.\n", "versions": [{"version": "v1", "created": "Fri, 12 Sep 2014 18:55:36 GMT"}], "update_date": "2014-09-15", "authors_parsed": [["Doligez", "Damien", "", "INRIA Paris-Rocquencourt"], ["Kriener", "Jael", "", "MSR - INRIA"], ["Lamport", "Leslie", "", "MSR - INRIA"], ["Libal", "Tomer", "", "MSR - INRIA"], ["Merz", "Stephan", "", "INRIA Nancy - Grand\n  Est / LORIA"]]}, {"id": "1409.3941", "submitter": "Victor Magron", "authors": "Assal\\'e Adj\\'e, Victor Magron", "title": "Polynomial Template Generation using Sum-of-Squares Programming", "comments": "23 pages, 3 figures, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Template abstract domains allow to express more interesting properties than\nclassical abstract domains. However, template generation is a challenging\nproblem when one uses template abstract domains for program analysis. In this\npaper, we relate template generation with the program properties that we want\nto prove. We focus on one-loop programs with nested conditional branches. We\nformally define the notion of well-representative template basis with respect\nto such programs and a given property. The definition relies on the fact that\ntemplate abstract domains produce inductive invariants. We show that these\ninvariants can be obtained by solving certain systems of functional\ninequalities. Then, such systems can be strengthened using a hierarchy of\nsum-of-squares (SOS) problems when we consider programs written in polynomial\narithmetic. Each step of the SOS hierarchy can possibly provide a solution\nwhich in turn yields an invariant together with a certificate that the desired\nproperty holds. The interest of this approach is illustrated on nontrivial\nprogram examples in polynomial arithmetic.\n", "versions": [{"version": "v1", "created": "Sat, 13 Sep 2014 12:34:10 GMT"}, {"version": "v2", "created": "Sat, 18 Oct 2014 14:14:26 GMT"}], "update_date": "2014-10-21", "authors_parsed": [["Adj\u00e9", "Assal\u00e9", ""], ["Magron", "Victor", ""]]}, {"id": "1409.4230", "submitter": "Rachid Rebiha", "authors": "Rachid Rebiha and Arnaldo Vieira Moura and Nadir Matringe", "title": "On the Termination of Linear and Affine Programs over the Integers", "comments": "arXiv admin note: substantial text overlap with arXiv:1407.4556", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The termination problem for affine programs over the integers was left open\nin\\cite{Braverman}. For more that a decade, it has been considered and cited as\na challenging open problem. To the best of our knowledge, we present here the\nmost complete response to this issue: we show that termination for affine\nprograms over Z is decidable under an assumption holding for almost all affine\nprograms, except for an extremely small class of zero Lesbegue measure. We use\nthe notion of asymptotically non-terminating initial variable values} (ANT, for\nshort) for linear loop programs over Z. Those values are directly associated to\ninitial variable values for which the corresponding program does not terminate.\nWe reduce the termination problem of linear affine programs over the integers\nto the emptiness check of a specific ANT set of initial variable values. For\nthis class of linear or affine programs, we prove that the corresponding ANT\nset is a semi-linear space and we provide a powerful computational methods\nallowing the automatic generation of these $ANT$ sets. Moreover, we are able to\naddress the conditional termination problem too. In other words, by taking ANT\nset complements, we obtain a precise under-approximation of the set of inputs\nfor which the program does terminate.\n", "versions": [{"version": "v1", "created": "Mon, 15 Sep 2014 12:41:26 GMT"}, {"version": "v2", "created": "Thu, 18 Sep 2014 06:27:03 GMT"}], "update_date": "2014-09-19", "authors_parsed": [["Rebiha", "Rachid", ""], ["Moura", "Arnaldo Vieira", ""], ["Matringe", "Nadir", ""]]}, {"id": "1409.4433", "submitter": "Jan Obdr", "authors": "Jakub Gajarsk\\'y (Masaryk University, Brno), Petr Hlin\\v{e}n\\'y\n  (Masaryk University, Brno), Jan Obdr\\v{z}\\'alek (Masaryk University, Brno),\n  Sebastian Ordyniak (Masaryk University, Brno)", "title": "Faster Existential FO Model Checking on Posets", "comments": "Paper as accepted to the LMCS journal. An extended abstract of an\n  earlier version of this paper has appeared at ISAAC'14. Main changes to the\n  previous version are improvements in the Multicoloured Clique part (Section\n  4)", "journal-ref": "Logical Methods in Computer Science, Volume 11, Issue 4 (December\n  11, 2015) lmcs:1609", "doi": "10.2168/LMCS-11(4:8)2015", "report-no": null, "categories": "cs.LO cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the model checking problem for the existential fragment of\nfirst-order (FO) logic on partially ordered sets is fixed-parameter tractable\n(FPT) with respect to the formula and the width of a poset (the maximum size of\nan antichain). While there is a long line of research into FO model checking on\ngraphs, the study of this problem on posets has been initiated just recently by\nBova, Ganian and Szeider (CSL-LICS 2014), who proved that the existential\nfragment of FO has an FPT algorithm for a poset of fixed width. We improve upon\ntheir result in two ways: (1) the runtime of our algorithm is\nO(f(|{\\phi}|,w).n^2) on n-element posets of width w, compared to O(g(|{\\phi}|).\nn^{h(w)}) of Bova et al., and (2) our proofs are simpler and easier to follow.\nWe complement this result by showing that, under a certain\ncomplexity-theoretical assumption, the existential FO model checking problem\ndoes not have a polynomial kernel.\n", "versions": [{"version": "v1", "created": "Mon, 15 Sep 2014 20:07:27 GMT"}, {"version": "v2", "created": "Wed, 12 Aug 2015 13:51:33 GMT"}, {"version": "v3", "created": "Thu, 10 Dec 2015 11:11:52 GMT"}], "update_date": "2017-01-11", "authors_parsed": [["Gajarsk\u00fd", "Jakub", "", "Masaryk University, Brno"], ["Hlin\u011bn\u00fd", "Petr", "", "Masaryk University, Brno"], ["Obdr\u017e\u00e1lek", "Jan", "", "Masaryk University, Brno"], ["Ordyniak", "Sebastian", "", "Masaryk University, Brno"]]}, {"id": "1409.4601", "submitter": "Michael Pinsker", "authors": "Manuel Bodirsky, Michael Pinsker, Andr\\'as Pongr\\'acz", "title": "Projective clone homomorphisms", "comments": "13 pages", "journal-ref": null, "doi": "10.1017/jsl.2019.23", "report-no": null, "categories": "math.LO cs.CC cs.LO math.RA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is known that a countable $\\omega$-categorical structure interprets all\nfinite structures primitively positively if and only if its polymorphism clone\nmaps to the clone of projections on a two-element set via a continuous clone\nhomomorphism. We investigate the relationship between the existence of a clone\nhomomorphism to the projection clone, and the existence of such a homomorphism\nwhich is continuous and thus meets the above criterion.\n", "versions": [{"version": "v1", "created": "Tue, 16 Sep 2014 12:06:50 GMT"}, {"version": "v2", "created": "Mon, 6 Jul 2020 13:24:00 GMT"}, {"version": "v3", "created": "Sun, 10 Jan 2021 19:25:23 GMT"}], "update_date": "2021-01-12", "authors_parsed": [["Bodirsky", "Manuel", ""], ["Pinsker", "Michael", ""], ["Pongr\u00e1cz", "Andr\u00e1s", ""]]}, {"id": "1409.4637", "submitter": "Robert Koenighofer", "authors": "Robert Koenighofer and Ronald Toegl and Roderick Bloem", "title": "Automatic Error Localization for Software using Deductive Verification", "comments": "This is an extended version of [8], featuring an additional appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Even competent programmers make mistakes. Automatic verification can detect\nerrors, but leaves the frustrating task of finding the erroneous line of code\nto the user. This paper presents an automatic approach for identifying\npotential error locations in software. It is based on a deductive verification\nengine, which detects errors in functions annotated with pre- and\npost-conditions. Using an automatic theorem prover, our approach finds\nexpressions in the code that can be modified such that the program satisfies\nits specification. Scalability is achieved by analyzing each function in\nisolation. We have implemented our approach in the widely used Frama-C\nframework and present first experimental results. This is an extended version\nof [8], featuring an additional appendix.\n", "versions": [{"version": "v1", "created": "Tue, 16 Sep 2014 13:29:14 GMT"}], "update_date": "2014-09-17", "authors_parsed": [["Koenighofer", "Robert", ""], ["Toegl", "Ronald", ""], ["Bloem", "Roderick", ""]]}, {"id": "1409.4925", "submitter": "Matt Lewis", "authors": "Cristina David and Daniel Kroening and Matt Lewis", "title": "Second-Order Propositional Satisfiability", "comments": "19 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Fundamentally, every static program analyser searches for a proof through a\ncombination of heuristics providing candidate solutions and a candidate\nvalidation technique. Essentially, the heuristic reduces a second-order problem\nto a first-order/propositional one, while the validation is often just a call\nto a SAT/SMT solver. This results in a monolithic design of such analyses that\nconflates the formulation of the problem with the solving process.\nConsequently, any change to the latter causes changes to the whole analysis.\nThis design is dictated by the state of the art in solver technology. While\nSAT/SMT solvers have experienced tremendous progress, there are barely any\nsecond-order solvers. This paper takes a step towards addressing this situation\nby proposing a decidable fragment of second-order logic that is still\nexpressive enough to capture numerous program analysis problems (e.g. safety\nproving, bug finding, termination and non-termination proving,\nsuperoptimisation). We refer to the satisfiability problem for this fragment as\nSecond-Order SAT and show it is NEXPTIME-complete. Finally, we build a decision\nprocedure for Second-Order SAT based on program synthesis and present\nexperimental evidence that our approach is tractable for program analysis\nproblems.\n", "versions": [{"version": "v1", "created": "Wed, 17 Sep 2014 09:44:43 GMT"}, {"version": "v2", "created": "Sun, 19 Oct 2014 16:33:56 GMT"}, {"version": "v3", "created": "Tue, 21 Oct 2014 11:47:35 GMT"}, {"version": "v4", "created": "Sat, 17 Jan 2015 14:29:58 GMT"}], "update_date": "2015-01-20", "authors_parsed": [["David", "Cristina", ""], ["Kroening", "Daniel", ""], ["Lewis", "Matt", ""]]}, {"id": "1409.5022", "submitter": "Cosimo Laneve", "authors": "Frank De Boer (CWI), Mahdi Jaghoori (Leiden University), Cosimo Laneve\n  (University of Bologna), Gianluigi Zavattaro (University of Bologna)", "title": "Decidability Problems for Actor Systems", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 4 (December\n  4, 2014) lmcs:1091", "doi": "10.2168/LMCS-10(4:5)2014", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a nominal actor-based language and study its expressive power.\nWe have identified the presence/absence of fields as a crucial feature: the\ndynamic creation of names in combination with fields gives rise to Turing\ncompleteness. On the other hand, restricting to stateless actors gives rise to\nsystems for which properties such as termination are decidable. This\ndecidability result still holds for actors with states when the number of\nactors is bounded and the state is read-only.\n", "versions": [{"version": "v1", "created": "Wed, 17 Sep 2014 15:13:02 GMT"}, {"version": "v2", "created": "Wed, 3 Dec 2014 14:42:47 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["De Boer", "Frank", "", "CWI"], ["Jaghoori", "Mahdi", "", "Leiden University"], ["Laneve", "Cosimo", "", "University of Bologna"], ["Zavattaro", "Gianluigi", "", "University of Bologna"]]}, {"id": "1409.5052", "submitter": "Philip Welch", "authors": "Philip Welch", "title": "Discrete Transfinite Computation", "comments": "A survey of transfinite computational models to appear as a chapter\n  in \" Turing's Ideas: their significance and impact \", Eds G. Sommaruga & T.\n  Strahm, Birkh\\\"auser, 2015", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe various computational models based initially, but not\nexclusively, on that of the Turing machine, that are generalized to allow for\ntransfinitely many computational steps. Variants of such machines are\nconsidered that have longer tapes than the standard model, or that work on\nordinals rather than numbers. We outline the connections between such models\nand the older theories of recursion in higher types, generalized recursion\ntheory, and recursion on ordinals such as $\\alpha$-recursion. We conclude that,\nin particular, polynomial time computation on $\\omega$-strings is well modelled\nby several convergent conceptions.\n", "versions": [{"version": "v1", "created": "Wed, 17 Sep 2014 16:21:39 GMT"}, {"version": "v2", "created": "Thu, 18 Sep 2014 05:06:01 GMT"}], "update_date": "2014-09-19", "authors_parsed": [["Welch", "Philip", ""]]}, {"id": "1409.5368", "submitter": "Bruno Courcelle", "authors": "Bruno Courcelle (LaBRI), Ir\\`ene A. Durand (LaBRI)", "title": "Fly-automata, model-checking and recognizability", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Recognizability Theorem states that if a set of finite graphs is\ndefinable by a monadic second-order (MSO) sentence, then it is recognizable\nwith respect to the graph algebra upon which the definition of clique-width is\nbased. Recognizability is an algebraic notion, defined in terms of congruences\nthat can also be formulated by means of finite automata on the terms that\ndescribe the considered graphs. This theorem entails that the verification of\nMSO graph properties, or equivalently, the model-checking problem for MSO logic\nover finite binary relational structures, is fixed-parameter tractable (FPT)\nfor the parameter consisting of the formula that expresses the property and the\nclique-width (or the tree-width) of the input graph or structure. The\ncorresponding algorithms can be implemented by means of fly-automata whose\ntransitions are computed on the fly and not tabulated. We review two versions\nof recognizability, we present fly-automata by means of examples showing that\nthey can also compute values attached to graphs. We show that fly-automata with\ninfinite sets of states yield a simple proof of the strong version of the\nRecognizability Theorem. This proof has not been published previously.\n", "versions": [{"version": "v1", "created": "Thu, 18 Sep 2014 16:40:09 GMT"}], "update_date": "2014-09-19", "authors_parsed": [["Courcelle", "Bruno", "", "LaBRI"], ["Durand", "Ir\u00e8ne A.", "", "LaBRI"]]}, {"id": "1409.5671", "submitter": "Ebru Aydin Gol", "authors": "Ebru Aydin Gol and Ezio Bartocci and Calin Belta", "title": "A Formal Methods Approach to Pattern Synthesis in Reaction Diffusion\n  Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.CE cs.LG cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a technique to detect and generate patterns in a network of\nlocally interacting dynamical systems. Central to our approach is a novel\nspatial superposition logic, whose semantics is defined over the quad-tree of a\npartitioned image. We show that formulas in this logic can be efficiently\nlearned from positive and negative examples of several types of patterns. We\nalso demonstrate that pattern detection, which is implemented as a model\nchecking algorithm, performs very well for test data sets different from the\nlearning sets. We define a quantitative semantics for the logic and integrate\nthe model checking algorithm with particle swarm optimization in a\ncomputational framework for synthesis of parameters leading to desired patterns\nin reaction-diffusion systems.\n", "versions": [{"version": "v1", "created": "Fri, 12 Sep 2014 05:21:06 GMT"}], "update_date": "2014-09-22", "authors_parsed": [["Gol", "Ebru Aydin", ""], ["Bartocci", "Ezio", ""], ["Belta", "Calin", ""]]}, {"id": "1409.5681", "submitter": "Steen Vester", "authors": "Steen Vester", "title": "Model-checking Quantitative Alternating-time Temporal Logic on\n  One-counter Game Models", "comments": "22 pages, 12 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider quantitative extensions of the alternating-time temporal logics\nATL/ATLs called quantitative alternating-time temporal logics (QATL/QATLs) in\nwhich the value of a counter can be compared to constants using equality,\ninequality and modulo constraints. We interpret these logics in one-counter\ngame models which are infinite duration games played on finite control graphs\nwhere each transition can increase or decrease the value of an unbounded\ncounter. That is, the state-space of these games are, generally, infinite. We\nconsider the model-checking problem of the logics QATL and QATLs on one-counter\ngame models with VASS semantics for which we develop algorithms and provide\nmatching lower bounds. Our algorithms are based on reductions of the\nmodel-checking problems to model-checking games. This approach makes it quite\nsimple for us to deal with extensions of the logical languages as well as the\ninfinite state spaces. The framework generalizes on one hand qualitative\nproblems such as ATL/ATLs model-checking of finite-state systems,\nmodel-checking of the branching-time temporal logics CTL and CTLs on\none-counter processes and the realizability problem of LTL specifications. On\nthe other hand the model-checking problem for QATL/QATLs generalizes\nquantitative problems such as the fixed-initial credit problem for energy games\n(in the case of QATL) and energy parity games (in the case of QATLs). Our\nresults are positive as we show that the generalizations are not too costly\nwith respect to complexity. As a byproduct we obtain new results on the\ncomplexity of model-checking CTLs in one-counter processes and show that\ndeciding the winner in one-counter games with LTL objectives is\n2ExpSpace-complete.\n", "versions": [{"version": "v1", "created": "Fri, 19 Sep 2014 14:41:57 GMT"}], "update_date": "2014-09-22", "authors_parsed": [["Vester", "Steen", ""]]}, {"id": "1409.5865", "submitter": "Uli Fahrenberg", "authors": "Uli Fahrenberg, Axel Legay", "title": "Homotopy Bisimilarity for Higher-Dimensional Automata", "comments": "Heavily revised version of arXiv:1209.4927", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new category of higher-dimensional automata in which the\nmorphisms are functional homotopy simulations, i.e. functional simulations up\nto concurrency of independent events. For this, we use unfoldings of\nhigher-dimensional automata into higher-dimensional trees. Using a notion of\nopen maps in this category, we define homotopy bisimilarity. We show that\nhomotopy bisimilarity is equivalent to a straight-forward generalization of\nstandard bisimilarity to higher dimensions, and that it is finer than split\nbisimilarity and incomparable with history-preserving bisimilarity.\n", "versions": [{"version": "v1", "created": "Sat, 20 Sep 2014 07:31:34 GMT"}], "update_date": "2014-09-23", "authors_parsed": [["Fahrenberg", "Uli", ""], ["Legay", "Axel", ""]]}, {"id": "1409.5944", "submitter": "Dan Gusfield", "authors": "Dan Gusfield", "title": "G\\\"odel for Goldilocks: A Rigorous, Streamlined Proof of (a variant of)\n  G\\\"odel's First Incompleteness Theorem", "comments": "Version 2 corrects typos and one definition in the first version, and\n  expands or contracts parts of the exposition, but the main content remains\n  the same. Version 3 removes an unnecessary comment in Version 2", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most discussions of G\\\"odel's theorems fall into one of two types: either\nthey emphasize perceived philosophical, cultural \"meanings\" of the theorems,\nand perhaps sketch some of the ideas of the proofs, usually relating G\\\"odel's\nproofs to riddles and paradoxes, but do not attempt to present rigorous,\ncomplete proofs; or they do present rigorous proofs, but in the traditional\nstyle of mathematical logic, with all of its heavy notation and difficult\ndefinitions, and technical issues which reflect G\\\"odel's original approach and\nbroader logical issues. Many non-specialists are frustrated by these two\nextreme types of expositions and want a complete, rigorous proof that they can\nunderstand. Such an exposition is possible, because many people have realized\nthat variants of G\\\"odel's first incompleteness theorem can be rigorously\nproved by a simpler middle approach, avoiding philosophical discussions and\nhand-waiving at one extreme; and also avoiding the heavy machinery of\ntraditional mathematical logic, and many of the harder detail's of G\\\"odel's\noriginal proof, at the other extreme. This is the just-right Goldilocks\napproach. In this exposition we give a short, self-contained Goldilocks\nexposition of G\\\"odel's first theorem, aimed at a broad, undergraduate\naudience.\n", "versions": [{"version": "v1", "created": "Sun, 21 Sep 2014 06:07:01 GMT"}, {"version": "v2", "created": "Sat, 15 Nov 2014 20:17:26 GMT"}, {"version": "v3", "created": "Wed, 19 Nov 2014 20:00:59 GMT"}], "update_date": "2014-11-20", "authors_parsed": [["Gusfield", "Dan", ""]]}, {"id": "1409.6253", "submitter": "Matteo Camilli M.Sc.", "authors": "Matteo Camilli", "title": "Constructing Coverability Graphs for Time Basic Petri Nets", "comments": "13 pages", "journal-ref": null, "doi": "10.1109/SYNASC.2016.036", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Time-Basic Petri nets, is a powerful formalism for modeling real-time systems\nwhere time constraints are expressed through time functions of marking's time\ndescription associated with transition, representing possible firing times. We\nintroduce a technique for coverability analysis based on the building of a\nfinite graph. This technique further exploits the time anonymous concept [5,6],\nin order to deal with topologically unbounded nets, exploits the concept of a\ncoverage of TA tokens, i.e., a sort of {\\omega} anonymous timestamp. Such a\ncoverability analysis technique is able to construct coverability trees/graphs\nfor unbounded Time-Basic Petri net models. The termination of the algorithm is\nguaranteed as long as, within the input model, tokens growing without limit,\ncan be anonymized. This means that we are able to manage models that do not\nexhibit Zeno behavior and do not express actions depending on infinite past\nevents. This is actually a reasonable limitation because, generally, real-world\nexamples do not exhibit such a behavior.\n", "versions": [{"version": "v1", "created": "Fri, 19 Sep 2014 10:59:38 GMT"}], "update_date": "2021-03-15", "authors_parsed": [["Camilli", "Matteo", ""]]}, {"id": "1409.6414", "submitter": "Sicun Gao", "authors": "Sicun Gao, Soonho Kong, Edmund Clarke", "title": "Proof Generation from Delta-Decisions", "comments": "Appeared in SYNASC'14", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show how to generate and validate logical proofs of unsatisfiability from\ndelta-complete decision procedures that rely on error-prone numerical\nalgorithms. Solving this problem is important for ensuring correctness of the\ndecision procedures. At the same time, it is a new approach for automated\ntheorem proving over real numbers. We design a first-order calculus, and\ntransform the computational steps of constraint solving into logic proofs,\nwhich are then validated using proof-checking algorithms. As an application, we\ndemonstrate how proofs generated from our solver can establish many nonlinear\nlemmas in the the formal proof of the Kepler Conjecture.\n", "versions": [{"version": "v1", "created": "Tue, 23 Sep 2014 05:04:48 GMT"}], "update_date": "2014-09-24", "authors_parsed": [["Gao", "Sicun", ""], ["Kong", "Soonho", ""], ["Clarke", "Edmund", ""]]}, {"id": "1409.6466", "submitter": "Yongming Li", "authors": "Yongming Li, Zhanyou Ma", "title": "Quantitative Computation Tree Logic Model Checking Based on Generalized\n  Possibility Measures", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study generalized possibilistic computation tree logic model checking in\nthis paper, which is an extension of possibilistic computation logic model\nchecking introduced by Y.Li, Y.Li and Z.Ma (2014). The system is modeled by\ngeneralized possibilistic Kripke structures (GPKS, in short), and the verifying\nproperty is specified by a generalized possibilistic computation tree logic\n(GPoCTL, in short) formula. Based on generalized possibility measures and\ngeneralized necessity measures, the method of generalized possibilistic\ncomputation tree logic model checking is discussed, and the corresponding\nalgorithm and its complexity are shown in detail. Furthermore, the comparison\nbetween PoCTL introduced in (2013) and GPoCTL is given. Finally, a thermostat\nexample is given to illustrate the GPoCTL model-checking method.\n", "versions": [{"version": "v1", "created": "Tue, 23 Sep 2014 10:00:04 GMT"}], "update_date": "2014-09-24", "authors_parsed": [["Li", "Yongming", ""], ["Ma", "Zhanyou", ""]]}, {"id": "1409.6856", "submitter": "Julia Padberg", "authors": "Julia Padberg", "title": "Reconfigurable Decorated PT Nets with Inhibitor Arcs and Transition\n  Priorities", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we deal with additional control structures for decorated PT\nNets. The main contribution are inhibitor arcs and priorities. The first ensure\nthat a marking can inhibit the firing of a transition. Inhibitor arcs force\nthat the transition may only fire when the place is empty. an order of\ntransitions restrict the firing, so that an transition may fire only if it has\nthe highest priority of all enabled transitions. This concept is shown to be\ncompatible with reconfigurable Petri nets.\n", "versions": [{"version": "v1", "created": "Wed, 24 Sep 2014 08:30:53 GMT"}], "update_date": "2014-09-25", "authors_parsed": [["Padberg", "Julia", ""]]}, {"id": "1409.6873", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Probabilistic thread algebra", "comments": "25 pages (arXiv admin note: text overlap with arXiv:1408.2955,\n  arXiv:1402.4950); some simplifications made; substantially revised", "journal-ref": "Scientific Annals of Computer Science 25(2):211--243, 2015", "doi": "10.7561/SACS.2015.2.211", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We add probabilistic features to basic thread algebra and its extensions with\nthread-service interaction and strategic interleaving. Here, threads represent\nthe behaviours produced by instruction sequences under execution and services\nrepresent the behaviours exhibited by the components of execution environments\nof instruction sequences. In a paper concerned with probabilistic instruction\nsequences, we proposed several kinds of probabilistic instructions and gave an\ninformal explanation for each of them. The probabilistic features added to the\nextension of basic thread algebra with thread-service interaction make it\npossible to give a formal explanation in terms of non-probabilistic\ninstructions and probabilistic services. The probabilistic features added to\nthe extensions of basic thread algebra with strategic interleaving make it\npossible to cover strategies corresponding to probabilistic scheduling\nalgorithms.\n", "versions": [{"version": "v1", "created": "Wed, 24 Sep 2014 09:43:39 GMT"}, {"version": "v2", "created": "Fri, 26 Sep 2014 10:54:08 GMT"}, {"version": "v3", "created": "Wed, 22 Jul 2015 10:06:30 GMT"}], "update_date": "2016-02-05", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "1409.6977", "submitter": "Mathieu Hoyrup", "authors": "Mathieu Hoyrup and Cristobal Rojas", "title": "On the information carried by programs about the objects they compute", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In computability theory and computable analysis, finite programs can compute\ninfinite objects. Presenting a computable object via any program for it,\nprovides at least as much information as presenting the object itself, written\non an infinite tape. What additional information do programs provide? We\ncharacterize this additional information to be any upper bound on the\nKolmogorov complexity of the object. Hence we identify the exact relationship\nbetween Markov-computability and Type-2-computability. We then use this\nrelationship to obtain several results characterizing the computational and\ntopological structure of Markov-semidecidable sets.\n", "versions": [{"version": "v1", "created": "Wed, 24 Sep 2014 14:47:17 GMT"}], "update_date": "2014-09-25", "authors_parsed": [["Hoyrup", "Mathieu", ""], ["Rojas", "Cristobal", ""]]}, {"id": "1409.7281", "submitter": "Jorge Fandinno", "authors": "Pedro Cabalar, Jorge Fandinno and Michael Fink", "title": "Causal Graph Justifications of Logic Programs", "comments": null, "journal-ref": "Theory and Practice of Logic Programming (2014), volume 14, issue\n  4-5, pp. 603-618", "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work we propose a multi-valued extension of logic programs under the\nstable models semantics where each true atom in a model is associated with a\nset of justifications. These justifications are expressed in terms of causal\ngraphs formed by rule labels and edges that represent their application\nordering. For positive programs, we show that the causal justifications\nobtained for a given atom have a direct correspon- dence to (relevant)\nsyntactic proofs of that atom using the program rules involved in the graphs.\nThe most interesting contribution is that this causal information is obtained\nin a purely semantic way, by algebraic op- erations (product, sum and\napplication) on a lattice of causal values whose ordering relation expresses\nwhen a justification is stronger than another. Finally, for programs with\nnegation, we define the concept of causal stable model by introducing an\nanalogous transformation to Gelfond and Lifschitz's program reduct. As a\nresult, default negation behaves as \"absence of proof\" and no justification is\nderived from negative liter\n", "versions": [{"version": "v1", "created": "Thu, 25 Sep 2014 14:56:57 GMT"}], "update_date": "2014-09-26", "authors_parsed": [["Cabalar", "Pedro", ""], ["Fandinno", "Jorge", ""], ["Fink", "Michael", ""]]}, {"id": "1409.7411", "submitter": "Paulo Oliva", "authors": "Jules Hedges, Paulo Oliva, Evguenia Winschel, Viktor Winschel, Philipp\n  Zahn", "title": "A Higher-order Framework for Decision Problems and Games", "comments": "45 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.GT math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new unified framework for modelling both decision problems and\nfinite games based on quantifiers and selection functions. We show that the\ncanonical utility maximisation is one special case of a quantifier and that our\nmore abstract framework provides several additional degrees of freedom in\nmodelling. In particular, incomplete preferences, non-maximising heuristics,\nand context-dependent motives can be taken into account when describing an\nagent's goal. We introduce a suitable generalisation of Nash equilibrium for\ngames in terms of quantifiers and selection functions. Moreover, we introduce a\nrefinement of Nash that captures context-dependency of goals. Modelling in our\nframework is compositional as the parts of the game are modular and can be\neasily exchanged. We provide an extended example where we illustrate concepts\nand highlight the benefits of our alternative modelling approach.\n", "versions": [{"version": "v1", "created": "Thu, 25 Sep 2014 20:19:52 GMT"}], "update_date": "2014-09-29", "authors_parsed": [["Hedges", "Jules", ""], ["Oliva", "Paulo", ""], ["Winschel", "Evguenia", ""], ["Winschel", "Viktor", ""], ["Zahn", "Philipp", ""]]}, {"id": "1409.7488", "submitter": "Yuguo He", "authors": "Yuguo He (School of Computer Science and Technology, Beijing Institute\n  of Technology, China)", "title": "On the strictness of the quantifier structure hierarchy in first-order\n  logic", "comments": "38 pages, 8 figures", "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 4 (November\n  13, 2014) lmcs:965", "doi": "10.2168/LMCS-10(4:3)2014", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study a natural hierarchy in first-order logic, namely the quantifier\nstructure hierarchy, which gives a systematic classification of first-order\nformulas based on structural quantifier resource. We define a variant of\nEhrenfeucht-Fraisse games that characterizes quantifier classes and use it to\nprove that this hierarchy is strict over finite structures, using strategy\ncompositions. Moreover, we prove that this hierarchy is strict even over\nordered finite structures, which is interesting in the context of descriptive\ncomplexity.\n", "versions": [{"version": "v1", "created": "Fri, 26 Sep 2014 07:51:37 GMT"}, {"version": "v2", "created": "Tue, 11 Nov 2014 20:31:09 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["He", "Yuguo", "", "School of Computer Science and Technology, Beijing Institute\n  of Technology, China"]]}, {"id": "1409.7542", "submitter": "Pierre Clairambault", "authors": "Simon Castellan (LIP), Pierre Clairambault (LIP, PLUME), Glynn Winskel", "title": "Thin Games with Symmetry and Concurrent Hyland-Ong Games", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 1 (March 4,\n  2019) lmcs:5248", "doi": "10.23638/LMCS-15(1:18)2019", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We build a cartesian closed category, called Cho, based on event structures.\nIt allows an interpretation of higher-order stateful concurrent programs that\nis refined and precise: on the one hand it is conservative with respect to\nstandard Hyland-Ong games when interpreting purely functional programs as\ninnocent strategies, while on the other hand it is much more expressive. The\ninterpretation of programs constructs compositionally a representation of their\nexecution that exhibits causal dependencies and remembers the points of\nnon-deterministic branching.The construction is in two stages. First, we build\na compact closed category Tcg. It is a variant of Rideau and Winskel's category\nCG, with the difference that games and strategies in Tcg are equipped with\nsymmetry to express that certain events are essentially the same. This is\nanalogous to the underlying category of AJM games enriching simple games with\nan equivalence relations on plays. Building on this category, we construct the\ncartesian closed category Cho as having as objects the standard arenas of\nHyland-Ong games, with strategies, represented by certain events structures,\nplaying on games with symmetry obtained as expanded forms of these arenas.To\nillustrate and give an operational light on these constructions, we interpret\n(a close variant of) Idealized Parallel Algol in Cho.\n", "versions": [{"version": "v1", "created": "Fri, 26 Sep 2014 11:39:59 GMT"}, {"version": "v2", "created": "Fri, 6 Jan 2017 15:32:10 GMT"}, {"version": "v3", "created": "Wed, 30 Aug 2017 09:05:16 GMT"}, {"version": "v4", "created": "Thu, 20 Dec 2018 09:48:49 GMT"}, {"version": "v5", "created": "Fri, 1 Mar 2019 15:33:48 GMT"}], "update_date": "2019-04-29", "authors_parsed": [["Castellan", "Simon", "", "LIP"], ["Clairambault", "Pierre", "", "LIP, PLUME"], ["Winskel", "Glynn", ""]]}, {"id": "1409.7687", "submitter": "Aurojit Panda", "authors": "Aurojit Panda, Ori Lahav, Katerina Argyraki, Mooly Sagiv, Scott\n  Shenker", "title": "Verifying Isolation Properties in the Presence of Middleboxes", "comments": "Under submission to NSDI", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Great progress has been made recently in verifying the correctness of router\nforwarding tables. However, these approaches do not work for networks\ncontaining middleboxes such as caches and firewalls whose forwarding behavior\ndepends on previously observed traffic. We explore how to verify isolation\nproperties in networks that include such \"dynamic datapath\" elements using\nmodel checking. Our work leverages recent advances in SMT solvers, and the main\nchallenge lies in scaling the approach to handle large and complicated\nnetworks. While the straightforward application of model checking to this\nproblem can only handle very small networks (if at all), our approach can\nverify simple realistic invariants on networks containing 30,000 middleboxes in\na few minutes.\n", "versions": [{"version": "v1", "created": "Fri, 26 Sep 2014 01:25:09 GMT"}], "update_date": "2014-09-30", "authors_parsed": [["Panda", "Aurojit", ""], ["Lahav", "Ori", ""], ["Argyraki", "Katerina", ""], ["Sagiv", "Mooly", ""], ["Shenker", "Scott", ""]]}, {"id": "1409.7777", "submitter": "Thomas Guyet", "authors": "Thomas Guyet (INRIA - IRISA), Yves Moinard (INRIA - IRISA), Ren\\'e\n  Quiniou (INRIA - IRISA)", "title": "Using Answer Set Programming for pattern mining", "comments": "Intelligence Artificielle Fondamentale (2014)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.DB cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Serial pattern mining consists in extracting the frequent sequential patterns\nfrom a unique sequence of itemsets. This paper explores the ability of a\ndeclarative language, such as Answer Set Programming (ASP), to solve this issue\nefficiently. We propose several ASP implementations of the frequent sequential\npattern mining task: a non-incremental and an incremental resolution. The\nresults show that the incremental resolution is more efficient than the\nnon-incremental one, but both ASP programs are less efficient than dedicated\nalgorithms. Nonetheless, this approach can be seen as a first step toward a\ngeneric framework for sequential pattern mining with constraints.\n", "versions": [{"version": "v1", "created": "Sat, 27 Sep 2014 07:27:17 GMT"}], "update_date": "2014-09-30", "authors_parsed": [["Guyet", "Thomas", "", "INRIA - IRISA"], ["Moinard", "Yves", "", "INRIA - IRISA"], ["Quiniou", "Ren\u00e9", "", "INRIA - IRISA"]]}, {"id": "1409.7922", "submitter": "Georg Zetzsche", "authors": "Georg Zetzsche", "title": "Computing downward closures for stacked counter automata", "comments": "34 pages, 1 figure; submitted", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  The downward closure of a language $L$ of words is the set of all (not\nnecessarily contiguous) subwords of members of $L$. It is well known that the\ndownward closure of any language is regular. Although the downward closure\nseems to be a promising abstraction, there are only few language classes for\nwhich an automaton for the downward closure is known to be computable.\n  It is shown here that for stacked counter automata, the downward closure is\ncomputable. Stacked counter automata are finite automata with a storage\nmechanism obtained by \\emph{adding blind counters} and \\emph{building stacks}.\nHence, they generalize pushdown and blind counter automata.\n  The class of languages accepted by these automata are precisely those in the\nhierarchy obtained from the context-free languages by alternating two closure\noperators: imposing semilinear constraints and taking the algebraic extension.\nThe main tool for computing downward closures is the new concept of Parikh\nannotations. As a second application of Parikh annotations, it is shown that\nthe hierarchy above is strict at every level.\n", "versions": [{"version": "v1", "created": "Sun, 28 Sep 2014 15:35:44 GMT"}], "update_date": "2014-09-30", "authors_parsed": [["Zetzsche", "Georg", ""]]}, {"id": "1409.8056", "submitter": "Tom Hirschowitz", "authors": "Tom Hirschowitz (CNRS, Universit\\'e de Savoie)", "title": "Full abstraction for fair testing in CCS (expanded version)", "comments": "80 pages", "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 4 (October\n  31, 2014) lmcs:1090", "doi": "10.2168/LMCS-10(4:2)2014", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In previous work with Pous, we defined a semantics for CCS which may both be\nviewed as an innocent form of presheaf semantics and as a concurrent form of\ngame semantics. We define in this setting an analogue of fair testing\nequivalence, which we prove fully abstract w.r.t. standard fair testing\nequivalence. The proof relies on a new algebraic notion called playground,\nwhich represents the `rule of the game'. From any playground, we derive two\nlanguages equipped with labelled transition systems, as well as a strong,\nfunctional bisimulation between them.\n", "versions": [{"version": "v1", "created": "Mon, 29 Sep 2014 10:14:56 GMT"}, {"version": "v2", "created": "Thu, 30 Oct 2014 06:51:10 GMT"}, {"version": "v3", "created": "Sun, 2 Nov 2014 13:30:45 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Hirschowitz", "Tom", "", "CNRS, Universit\u00e9 de Savoie"]]}, {"id": "1409.8228", "submitter": "Stefan Kiefer", "authors": "Christoph Haase and Stefan Kiefer", "title": "The Odds of Staying on Budget", "comments": "Technical report for an ICALP'15 paper. 30 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given Markov chains and Markov decision processes (MDPs) whose transitions\nare labelled with non-negative integer costs, we study the computational\ncomplexity of deciding whether the probability of paths whose accumulated cost\nsatisfies a Boolean combination of inequalities exceeds a given threshold. For\nacyclic Markov chains, we show that this problem is PP-complete, whereas it is\nhard for the PosSLP problem and in PSPACE for general Markov chains. Moreover,\nfor acyclic and general MDPs, we prove PSPACE- and EXP-completeness,\nrespectively. Our results have direct implications on the complexity of\ncomputing reward quantiles in succinctly represented stochastic systems.\n", "versions": [{"version": "v1", "created": "Sun, 21 Sep 2014 17:49:56 GMT"}, {"version": "v2", "created": "Tue, 21 Apr 2015 19:50:20 GMT"}], "update_date": "2015-04-22", "authors_parsed": [["Haase", "Christoph", ""], ["Kiefer", "Stefan", ""]]}, {"id": "1409.8404", "submitter": "Alexander Schulz", "authors": "Alexander Schulz", "title": "Converting Reconfigurable Petri Nets to Maude", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Model checking is an important aim of the theoretical computer science. It\nenables the verification of a model with a set of properties such as liveness,\ndeadlock or safety. One of the typical modelling techniques are Petri nets they\nare well understood and can be used for a model checking. Reconfigurable Petri\nnets are based on a Petri nets with a set of rules. These rules can be used\ndynamically to change the net. Missing is the possibility to verify a\nreconfigurable net and properties such as deadlocks or liveness. This paper\nintroduces a conversion from reconfigurable Petri net to Maude, that allows us\nto fill the gap. It presents a net transformation approach which is based on\nMaude's equation- and rewrite logic as well as the LTLR model checker.\n", "versions": [{"version": "v1", "created": "Tue, 30 Sep 2014 07:04:28 GMT"}, {"version": "v2", "created": "Mon, 6 Oct 2014 20:13:48 GMT"}, {"version": "v3", "created": "Mon, 13 Oct 2014 14:29:10 GMT"}, {"version": "v4", "created": "Sun, 2 Nov 2014 16:46:12 GMT"}, {"version": "v5", "created": "Wed, 12 Nov 2014 11:02:02 GMT"}], "update_date": "2014-11-13", "authors_parsed": [["Schulz", "Alexander", ""]]}]