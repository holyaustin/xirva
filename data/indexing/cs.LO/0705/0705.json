[{"id": "0705.0419", "submitter": "Luigi Santocanale", "authors": "Walid Belkhir (LIF), Luigi Santocanale (LIF)", "title": "Undirected Graphs of Entanglement Two", "comments": null, "journal-ref": "FSTTCS 2007: Foundations of Software Technology and Theoretical\n  Computer Science, Inde (2007)", "doi": "10.1007/978-3-540-77050-3_42", "report-no": null, "categories": "cs.LO cs.GT", "license": null, "abstract": "  Entanglement is a complexity measure of directed graphs that origins in fixed\npoint theory. This measure has shown its use in designing efficient algorithms\nto verify logical properties of transition systems. We are interested in the\nproblem of deciding whether a graph has entanglement at most k. As this measure\nis defined by means of games, game theoretic ideas naturally lead to design\npolynomial algorithms that, for fixed k, decide the problem. Known\ncharacterizations of directed graphs of entanglement at most 1 lead, for k = 1,\nto design even faster algorithms. In this paper we present an explicit\ncharacterization of undirected graphs of entanglement at most 2. With such a\ncharacterization at hand, we devise a linear time algorithm to decide whether\nan undirected graph has this property.\n", "versions": [{"version": "v1", "created": "Thu, 3 May 2007 08:07:11 GMT"}, {"version": "v2", "created": "Thu, 30 Aug 2007 09:04:14 GMT"}], "update_date": "2009-04-09", "authors_parsed": [["Belkhir", "Walid", "", "LIF"], ["Santocanale", "Luigi", "", "LIF"]]}, {"id": "0705.1367", "submitter": "Riccardo Pucella", "authors": "Riccardo Pucella", "title": "Logic Column 18: Alternative Logics: A Book Review", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": null, "abstract": "  This article discusses two books on the topic of alternative logics in\nscience: \"Deviant Logic\", by Susan Haack, and \"Alternative Logics: Do Sciences\nNeed Them?\", edited by Paul Weingartner.\n", "versions": [{"version": "v1", "created": "Wed, 9 May 2007 21:56:15 GMT"}], "update_date": "2007-05-23", "authors_parsed": [["Pucella", "Riccardo", ""]]}, {"id": "0705.1999", "submitter": "Camilla Schwind", "authors": "Camilla Schwind (LIF)", "title": "A first-order Temporal Logic for Actions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": null, "abstract": "  We present a multi-modal action logic with first-order modalities, which\ncontain terms which can be unified with the terms inside the subsequent\nformulas and which can be quantified. This makes it possible to handle\nsimultaneously time and states. We discuss applications of this language to\naction theory where it is possible to express many temporal aspects of actions,\nas for example, beginning, end, time points, delayed preconditions and results,\nduration and many others. We present tableaux rules for a decidable fragment of\nthis logic.\n", "versions": [{"version": "v1", "created": "Mon, 14 May 2007 18:36:25 GMT"}], "update_date": "2007-05-23", "authors_parsed": [["Schwind", "Camilla", "", "LIF"]]}, {"id": "0705.2205", "submitter": "Nir Piterman", "authors": "Nir Piterman", "title": "From Nondeterministic B\\\"uchi and Streett Automata to Deterministic\n  Parity Automata", "comments": "21 pages. To appear in Logical Methods in Computer Science (LMCS)", "journal-ref": "Logical Methods in Computer Science, Volume 3, Issue 3 (August 14,\n  2007) lmcs:1199", "doi": "10.2168/LMCS-3(3:5)2007", "report-no": null, "categories": "cs.LO cs.FL", "license": null, "abstract": "  In this paper we revisit Safra's determinization constructions for automata\non infinite words. We show how to construct deterministic automata with fewer\nstates and, most importantly, parity acceptance conditions. Determinization is\nused in numerous applications, such as reasoning about tree automata,\nsatisfiability of CTL*, and realizability and synthesis of logical\nspecifications. The upper bounds for all these applications are reduced by\nusing the smaller deterministic automata produced by our construction. In\naddition, the parity acceptance conditions allows to use more efficient\nalgorithms (when compared to handling Rabin or Streett acceptance conditions).\n", "versions": [{"version": "v1", "created": "Tue, 15 May 2007 18:08:15 GMT"}, {"version": "v2", "created": "Tue, 14 Aug 2007 13:15:08 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Piterman", "Nir", ""]]}, {"id": "0705.2229", "submitter": "Matthew Valeriote Dr.", "authors": "Emil Kiss, Matthew Valeriote", "title": "On tractability and congruence distributivity", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 3, Issue 2 (June 8,\n  2007) lmcs:1005", "doi": "10.2168/LMCS-3(2:6)2007", "report-no": null, "categories": "cs.CC cs.LO", "license": null, "abstract": "  Constraint languages that arise from finite algebras have recently been the\nobject of study, especially in connection with the Dichotomy Conjecture of\nFeder and Vardi. An important class of algebras are those that generate\ncongruence distributive varieties and included among this class are lattices,\nand more generally, those algebras that have near-unanimity term operations. An\nalgebra will generate a congruence distributive variety if and only if it has a\nsequence of ternary term operations, called Jonsson terms, that satisfy certain\nequations.\n  We prove that constraint languages consisting of relations that are invariant\nunder a short sequence of Jonsson terms are tractable by showing that such\nlanguages have bounded relational width.\n", "versions": [{"version": "v1", "created": "Tue, 15 May 2007 20:01:32 GMT"}, {"version": "v2", "created": "Fri, 8 Jun 2007 12:26:50 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Kiss", "Emil", ""], ["Valeriote", "Matthew", ""]]}, {"id": "0705.3227", "submitter": "H. Reiju Mihara", "authors": "Masahiro Kumabe, H. Reiju Mihara", "title": "Computability of simple games: A characterization and application to the\n  core", "comments": "35 pages; To appear in Journal of Mathematical Economics; Appendix\n  added, Propositions, Remarks, etc. are renumbered", "journal-ref": "Journal of Mathematical Economics, Volume 44, Issues 3-4, February\n  2008, Pages 348-366", "doi": "10.1016/j.jmateco.2007.05.012", "report-no": null, "categories": "cs.GT cs.CC cs.LO math.LO", "license": null, "abstract": "  The class of algorithmically computable simple games (i) includes the class\nof games that have finite carriers and (ii) is included in the class of games\nthat have finite winning coalitions. This paper characterizes computable games,\nstrengthens the earlier result that computable games violate anonymity, and\ngives examples showing that the above inclusions are strict. It also extends\nNakamura's theorem about the nonemptyness of the core and shows that computable\ngames have a finite Nakamura number, implying that the number of alternatives\nthat the players can deal with rationally is restricted.\n", "versions": [{"version": "v1", "created": "Tue, 22 May 2007 17:49:15 GMT"}, {"version": "v2", "created": "Wed, 8 Aug 2007 13:57:59 GMT"}], "update_date": "2011-11-09", "authors_parsed": [["Kumabe", "Masahiro", ""], ["Mihara", "H. Reiju", ""]]}, {"id": "0705.3316", "submitter": "Stephane Le Roux", "authors": "St\\'ephane Le Roux (LIP)", "title": "Acyclicity of Preferences, Nash Equilibria, and Subgame Perfect\n  Equilibria: a Formal and Constructive Equivalence", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.GT cs.LO", "license": null, "abstract": "  In 1953, Kuhn showed that every sequential game has a Nash equilibrium by\nshowing that a procedure, named ``backward induction'' in game theory, yields a\nNash equilibrium. It actually yields Nash equilibria that define a proper\nsubclass of Nash equilibria. In 1965, Selten named this proper subclass subgame\nperfect equilibria. In game theory, payoffs are rewards usually granted at the\nend of a game. Although traditional game theory mainly focuses on real-valued\npayoffs that are implicitly ordered by the usual total order over the reals,\nworks of Simon or Blackwell already involved partially ordered payoffs. This\npaper generalises the notion of sequential game by replacing real-valued payoff\nfunctions with abstract atomic objects, called outcomes, and by replacing the\nusual total order over the reals with arbitrary binary relations over outcomes,\ncalled preferences. This introduces a general abstract formalism where Nash\nequilibrium, subgame perfect equilibrium, and ``backward induction'' can still\nbe defined. This paper proves that the following three propositions are\nequivalent: 1) Preferences over the outcomes are acyclic. 2) Every sequential\ngame has a Nash equilibrium. 3) Every sequential game has a subgame perfect\nequilibrium. The result is fully computer-certified using Coq. Beside the\nadditional guarantee of correctness, the activity of formalisation using Coq\nalso helps clearly identify the useful definitions and the main articulations\nof the proof.\n", "versions": [{"version": "v1", "created": "Wed, 23 May 2007 09:30:08 GMT"}], "update_date": "2007-05-24", "authors_parsed": [["Roux", "St\u00e9phane Le", "", "LIP"]]}, {"id": "0705.3487", "submitter": "Antoine Meyer", "authors": "Arnaud Carayol (IRISA), Antoine Meyer (LIAFA)", "title": "Linearly bounded infinite graphs", "comments": null, "journal-ref": "Acta Informatica 43, 4 (25/08/2006) p. 265-292", "doi": "10.1007/s00236-006-0022-z", "report-no": null, "categories": "cs.LO", "license": null, "abstract": "  Linearly bounded Turing machines have been mainly studied as acceptors for\ncontext-sensitive languages. We define a natural class of infinite automata\nrepresenting their observable computational behavior, called linearly bounded\ngraphs. These automata naturally accept the same languages as the linearly\nbounded machines defining them. We present some of their structural properties\nas well as alternative characterizations in terms of rewriting systems and\ncontext-sensitive transductions. Finally, we compare these graphs to rational\ngraphs, which are another class of automata accepting the context-sensitive\nlanguages, and prove that in the bounded-degree case, rational graphs are a\nstrict sub-class of linearly bounded graphs.\n", "versions": [{"version": "v1", "created": "Thu, 24 May 2007 15:29:21 GMT"}], "update_date": "2007-05-25", "authors_parsed": [["Carayol", "Arnaud", "", "IRISA"], ["Meyer", "Antoine", "", "LIAFA"]]}, {"id": "0705.3503", "submitter": "Catuscia Palamidessi", "authors": "Konstantinos Chatzikokolakis and Catuscia Palamidessi", "title": "Making Random Choices Invisible to the Scheduler", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.LO", "license": null, "abstract": "  When dealing with process calculi and automata which express both\nnondeterministic and probabilistic behavior, it is customary to introduce the\nnotion of scheduler to solve the nondeterminism. It has been observed that for\ncertain applications, notably those in security, the scheduler needs to be\nrestricted so not to reveal the outcome of the protocol's random choices, or\notherwise the model of adversary would be too strong even for ``obviously\ncorrect'' protocols. We propose a process-algebraic framework in which the\ncontrol on the scheduler can be specified in syntactic terms, and we show how\nto apply it to solve the problem mentioned above. We also consider the\ndefinition of (probabilistic) may and must preorders, and we show that they are\nprecongruences with respect to the restricted schedulers. Furthermore, we show\nthat all the operators of the language, except replication, distribute over\nprobabilistic summation, which is a useful property for verification.\n", "versions": [{"version": "v1", "created": "Thu, 24 May 2007 04:28:47 GMT"}], "update_date": "2007-06-13", "authors_parsed": [["Chatzikokolakis", "Konstantinos", ""], ["Palamidessi", "Catuscia", ""]]}, {"id": "0705.3561", "submitter": "Lucas Bordeaux", "authors": "Lucas Bordeaux, Marco Cadoli, Toni Mancini", "title": "Generalizing Consistency and other Constraint Properties to Quantified\n  Constraints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": null, "abstract": "  Quantified constraints and Quantified Boolean Formulae are typically much\nmore difficult to reason with than classical constraints, because quantifier\nalternation makes the usual notion of solution inappropriate. As a consequence,\nbasic properties of Constraint Satisfaction Problems (CSP), such as consistency\nor substitutability, are not completely understood in the quantified case.\nThese properties are important because they are the basis of most of the\nreasoning methods used to solve classical (existentially quantified)\nconstraints, and one would like to benefit from similar reasoning methods in\nthe resolution of quantified constraints. In this paper, we show that most of\nthe properties that are used by solvers for CSP can be generalized to\nquantified CSP. This requires a re-thinking of a number of basic concepts; in\nparticular, we propose a notion of outcome that generalizes the classical\nnotion of solution and on which all definitions are based. We propose a\nsystematic study of the relations which hold between these properties, as well\nas complexity results regarding the decision of these properties. Finally, and\nsince these problems are typically intractable, we generalize the approach used\nin CSP and propose weaker, easier to check notions based on locality, which\nallow to detect these properties incompletely but in polynomial time.\n", "versions": [{"version": "v1", "created": "Thu, 24 May 2007 11:27:55 GMT"}], "update_date": "2007-05-25", "authors_parsed": [["Bordeaux", "Lucas", ""], ["Cadoli", "Marco", ""], ["Mancini", "Toni", ""]]}, {"id": "0705.3610", "submitter": "Antoine Meyer", "authors": "Greta Yorsh, Alexander Rabinovich, Mooly Sagiv, Antoine Meyer (LIAFA),\n  Ahmed Bouajjani (LIAFA)", "title": "A Logic of Reachable Patterns in Linked Data-Structures", "comments": null, "journal-ref": "Foundations of Software Science and Computation Structures\n  (29/03/2006) p. 94-110", "doi": "10.1007/11690634_7", "report-no": null, "categories": "cs.LO", "license": null, "abstract": "  We define a new decidable logic for expressing and checking invariants of\nprograms that manipulate dynamically-allocated objects via pointers and\ndestructive pointer updates. The main feature of this logic is the ability to\nlimit the neighborhood of a node that is reachable via a regular expression\nfrom a designated node. The logic is closed under boolean operations\n(entailment, negation) and has a finite model property. The key technical\nresult is the proof of decidability. We show how to express precondition,\npostconditions, and loop invariants for some interesting programs. It is also\npossible to express properties such as disjointness of data-structures, and\nlow-level heap mutations. Moreover, our logic can express properties of\narbitrary data-structures and of an arbitrary number of pointer fields. The\nlatter provides a way to naturally specify postconditions that relate the\nfields on entry to a procedure to the fields on exit. Therefore, it is possible\nto use the logic to automatically prove partial correctness of programs\nperforming low-level heap mutations.\n", "versions": [{"version": "v1", "created": "Thu, 24 May 2007 16:10:52 GMT"}], "update_date": "2007-06-13", "authors_parsed": [["Yorsh", "Greta", "", "LIAFA"], ["Rabinovich", "Alexander", "", "LIAFA"], ["Sagiv", "Mooly", "", "LIAFA"], ["Meyer", "Antoine", "", "LIAFA"], ["Bouajjani", "Ahmed", "", "LIAFA"]]}, {"id": "0705.3888", "submitter": "Antoine Meyer", "authors": "Ahmed Bouajjani (LIAFA), Antoine Meyer (LIAFA)", "title": "Symbolic Reachability Analysis of Higher-Order Context-Free Processes", "comments": null, "journal-ref": "FSTTCS 2004: Foundations of Software Technology and Theoretical\n  Computer Science (24/11/2004) 135-147", "doi": "10.1007/b104325", "report-no": null, "categories": "cs.LO", "license": null, "abstract": "  We consider the problem of symbolic reachability analysis of higher-order\ncontext-free processes. These models are generalizations of the context-free\nprocesses (also called BPA processes) where each process manipulates a data\nstructure which can be seen as a nested stack of stacks. Our main result is\nthat, for any higher-order context-free process, the set of all predecessors of\na given regular set of configurations is regular and effectively constructible.\nThis result generalizes the analogous result which is known for level 1\ncontext-free processes. We show that this result holds also in the case of\nbackward reachability analysis under a regular constraint on configurations. As\na corollary, we obtain a symbolic model checking algorithm for the temporal\nlogic E(U,X) with regular atomic predicates, i.e., the fragment of CTL\nrestricted to the EU and EX modalities.\n", "versions": [{"version": "v1", "created": "Mon, 28 May 2007 16:31:04 GMT"}], "update_date": "2007-05-29", "authors_parsed": [["Bouajjani", "Ahmed", "", "LIAFA"], ["Meyer", "Antoine", "", "LIAFA"]]}, {"id": "0705.3949", "submitter": "Yeb Havinga", "authors": "Yeb Havinga", "title": "Translating a first-order modal language to relational algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB", "license": null, "abstract": "  This paper is about Kripke structures that are inside a relational database\nand queried with a modal language. At first the modal language that is used is\nintroduced, followed by a definition of the database and relational algebra.\nBased on these definitions two things are presented: a mapping from components\nof the modal structure to a relational database schema and instance, and a\ntranslation from queries in the modal language to relational algebra queries.\n", "versions": [{"version": "v1", "created": "Sun, 27 May 2007 12:36:58 GMT"}], "update_date": "2007-05-29", "authors_parsed": [["Havinga", "Yeb", ""]]}, {"id": "0705.4064", "submitter": "Antoine Meyer", "authors": "Antoine Meyer (LIAFA)", "title": "On Term Rewriting Systems Having a Rational Derivation", "comments": null, "journal-ref": "Foundations of Software Science and Computation Structures\n  (05/03/2004) 378-392", "doi": "10.1007/b95995", "report-no": null, "categories": "cs.LO", "license": null, "abstract": "  Several types of term rewriting systems can be distinguished by the way their\nrules overlap. In particular, we define the classes of prefix, suffix,\nbottom-up and top-down systems, which generalize similar classes on words. Our\naim is to study the derivation relation of such systems (i.e. the reflexive and\ntransitive closure of their rewriting relation) and, if possible, to provide a\nfinite mechanism characterizing it. Using a notion of rational relations based\non finite graph grammars, we show that the derivation of any bottom-up,\ntop-down or suffix systems is rational, while it can be non recursive for\nprefix systems.\n", "versions": [{"version": "v1", "created": "Mon, 28 May 2007 16:30:27 GMT"}], "update_date": "2007-05-29", "authors_parsed": [["Meyer", "Antoine", "", "LIAFA"]]}, {"id": "0705.4226", "submitter": "Joachim De Lataillade", "authors": "Joachim De Lataillade (PPS)", "title": "Second-Order Type Isomorphisms Through Game Semantics", "comments": "accepted by Annals of Pure and Applied Logic, Special Issue on Game\n  Semantics", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": null, "abstract": "  The characterization of second-order type isomorphisms is a purely\nsyntactical problem that we propose to study under the enlightenment of game\nsemantics. We study this question in the case of second-order\n&#955;$\\mu$-calculus, which can be seen as an extension of system F to\nclassical logic, and for which we de&#64257;ne a categorical framework: control\nhyperdoctrines. Our game model of &#955;$\\mu$-calculus is based on polymorphic\narenas (closely related to Hughes' hyperforests) which evolve during the play\n(following the ideas of Murawski-Ong). We show that type isomorphisms coincide\nwith the \"equality\" on arenas associated with types. Finally we deduce the\nequational characterization of type isomorphisms from this equality. We also\nrecover from the same model Roberto Di Cosmo's characterization of type\nisomorphisms for system F. This approach leads to a geometrical comprehension\non the question of second order type isomorphisms, which can be easily extended\nto some other polymorphic calculi including additional programming features.\n", "versions": [{"version": "v1", "created": "Tue, 29 May 2007 14:26:26 GMT"}], "update_date": "2007-05-30", "authors_parsed": [["De Lataillade", "Joachim", "", "PPS"]]}, {"id": "0705.4228", "submitter": "Joachim De Lataillade", "authors": "Joachim De Lataillade (PPS)", "title": "Curry-style type Isomorphisms and Game Semantics", "comments": "Accept\\'e \\`a Mathematical Structures for Computer Science, Special\n  Issue on Type Isomorphisms", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": null, "abstract": "  Curry-style system F, ie. system F with no explicit types in terms, can be\nseen as a core presentation of polymorphism from the point of view of\nprogramming languages. This paper gives a characterisation of type isomorphisms\nfor this language, by using a game model whose intuitions come both from the\nsyntax and from the game semantics universe. The model is composed of: an\nuntyped part to interpret terms, a notion of game to interpret types, and a\ntyped part to express the fact that an untyped strategy plays on a game. By\nanalysing isomorphisms in the model, we prove that the equational system\ncorresponding to type isomorphisms for Curry-style system F is the extension of\nthe equational system for Church-style isomorphisms with a new, non-trivial\nequation: forall X.A = A[forall Y.Y/X] if X appears only positively in A.\n", "versions": [{"version": "v1", "created": "Tue, 29 May 2007 14:31:02 GMT"}], "update_date": "2007-05-30", "authors_parsed": [["De Lataillade", "Joachim", "", "PPS"]]}, {"id": "0705.4604", "submitter": "Henrik Reif Andersen", "authors": "Henrik Reif Andersen and Kaare J. Kristoffersen", "title": "Temporal Runtime Verification using Monadic Difference Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": null, "abstract": "  In this paper we present an algorithm for performing runtime verification of\na bounded temporal logic over timed runs. The algorithm consists of three\nelements. First, the bounded temporal formula to be verified is translated into\na monadic first-order logic over difference inequalities, which we call monadic\ndifference logic. Second, at each step of the timed run, the monadic difference\nformula is modified by computing a quotient with the state and time of that\nstep. Third, the resulting formula is checked for being a tautology or being\nunsatisfiable by a decision procedure for monadic difference logic.\n  We further provide a simple decision procedure for monadic difference logic\nbased on the data structure Difference Decision Diagrams. The algorithm is\ncomplete in a very strong sense on a subclass of temporal formulae\ncharacterized as homogeneously monadic and it is approximate on other formulae.\nThe approximation comes from the fact that not all unsatisfiable or\ntautological formulae are recognised at the earliest possible time of the\nruntime verification.\n  Contrary to existing approaches, the presented algorithms do not work by\nsyntactic rewriting but employ efficient decision structures which make them\napplicable in real applications within for instance business software.\n", "versions": [{"version": "v1", "created": "Thu, 31 May 2007 13:22:02 GMT"}], "update_date": "2007-06-01", "authors_parsed": [["Andersen", "Henrik Reif", ""], ["Kristoffersen", "Kaare J.", ""]]}, {"id": "0705.4618", "submitter": "Roberto Bagnara", "authors": "Roberto Bagnara, Patricia M. Hill, Enea Zaffanella", "title": "An Improved Tight Closure Algorithm for Integer Octagonal Constraints", "comments": "15 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.CG cs.LO", "license": null, "abstract": "  Integer octagonal constraints (a.k.a. ``Unit Two Variables Per Inequality''\nor ``UTVPI integer constraints'') constitute an interesting class of\nconstraints for the representation and solution of integer problems in the\nfields of constraint programming and formal analysis and verification of\nsoftware and hardware systems, since they couple algorithms having polynomial\ncomplexity with a relatively good expressive power. The main algorithms\nrequired for the manipulation of such constraints are the satisfiability check\nand the computation of the inferential closure of a set of constraints. The\nlatter is called `tight' closure to mark the difference with the (incomplete)\nclosure algorithm that does not exploit the integrality of the variables. In\nthis paper we present and fully justify an O(n^3) algorithm to compute the\ntight closure of a set of UTVPI integer constraints.\n", "versions": [{"version": "v1", "created": "Thu, 31 May 2007 14:32:46 GMT"}, {"version": "v2", "created": "Fri, 1 Jun 2007 08:17:11 GMT"}], "update_date": "2007-06-01", "authors_parsed": [["Bagnara", "Roberto", ""], ["Hill", "Patricia M.", ""], ["Zaffanella", "Enea", ""]]}]