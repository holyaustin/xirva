[{"id": "1112.0343", "submitter": "Giorgio Orsi PhD", "authors": "Georg Gottlob and Giorgio Orsi and Andreas Pieris", "title": "Ontological Queries: Rewriting and Optimization (Extended Version)", "comments": "Extended version of \"Ontological Queries: Rewriting and Optimization\"\n  presented at ICDE 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.LO", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Ontological queries are evaluated against an ontology rather than directly on\na database. The evaluation and optimization of such queries is an intriguing\nnew problem for database research.\n  In this paper we discuss two important aspects of this problem: query\nrewriting and query optimization. Query rewriting consists of the compilation\nof an ontological query into an equivalent query against the underlying\nrelational database. The focus here is on soundness and completeness. We review\nprevious results and present a new rewriting algorithm for rather general types\nof ontological constraints.\n  In particular, we show how a conjunctive query against an ontology can be\ncompiled into a union of conjunctive queries against the underlying database.\nOntological query optimization, in this context, attempts to improve this\nprocess so to produce possibly small and cost-effective UCQ rewritings for an\ninput query. We review existing optimization methods, and propose an effective\nnew method that works for linear Datalog+/-, a class of Datalog-based rules\nthat encompasses well-known description logics of the DL-Lite family.\n", "versions": [{"version": "v1", "created": "Thu, 1 Dec 2011 22:19:24 GMT"}], "update_date": "2011-12-05", "authors_parsed": [["Gottlob", "Georg", ""], ["Orsi", "Giorgio", ""], ["Pieris", "Andreas", ""]]}, {"id": "1112.0347", "submitter": "Samson Abramsky", "authors": "Samson Abramsky", "title": "Domain Theory and the Logic of Observable Properties", "comments": "235 pages. Ph.D thesis, 1988, Queen Mary College, University of\n  London", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The mathematical framework of Stone duality is used to synthesize a number of\nhitherto separate developments in Theoretical Computer Science: - Domain\nTheory, the mathematical theory of computation introduced by Scott as a\nfoundation for denotational semantics. - The theory of concurrency and systems\nbehaviour developed by Milner, Hennessy et al. based on operational semantics.\n- Logics of programs.\n  Stone duality provides a junction between semantics (spaces of points =\ndenotations of computational processes) and logics (lattices of properties of\nprocesses). Moreover, the underlying logic is geometric, which can be\ncomputationally interpreted as the logic of observable properties---i.e.\nproperties which can be determined to hold of a process on the basis of a\nfinite amount of information about its execution.\n  These ideas lead to the following programme:\n  1. A metalanguage is introduced, comprising\n  - types = universes of discourse for various computational situations.\n  - terms = programs = syntactic intensions for models or points.\n  2. A standard denotational interpretation of the metalanguage is given,\nassigning domains to types and domain elements to terms.\n  3. The metalanguage is also given a {\\em logical} interpretation, in which\ntypes are interpreted as propositional theories and terms are interpreted via a\nprogram logic, which axiomatizes the properties they satisfy.\n  4. The two interpretations are related by showing that they are Stone duals\nof each other. Hence, semantics and logic are guaranteed to be in harmony with\neach other, and in fact each determines the other up to isomorphism.\n  This opens the way to a whole range of applications. Given a denotational\ndescription of a computational situation in our meta-language, we can turn the\nhandle to obtain a logic for that situation.\n", "versions": [{"version": "v1", "created": "Thu, 1 Dec 2011 22:29:23 GMT"}], "update_date": "2011-12-05", "authors_parsed": [["Abramsky", "Samson", ""]]}, {"id": "1112.0427", "submitter": "Samson Abramsky", "authors": "Samson Abramsky", "title": "A Generalized Kahn Principle for Abstract Asynchronous Networks", "comments": "25 pages. Published in the Proceedings of the Symposium on\n  Mathematical Foundations of Programming Language Semantics, Springer Lecture\n  Notes in Computer Science vol. 442, pp. 1--21", "journal-ref": null, "doi": "10.1007/BFb0040252", "report-no": null, "categories": "cs.LO math.CT quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Our general motivation is to answer the question: \"What is a model of\nconcurrent computation?\". As a preliminary exercise, we study dataflow\nnetworks. We develop a very general notion of model for asynchronous networks.\nThe \"Kahn Principle\", which states that a network built from functional nodes\nis the least fixpoint of a system of equations associated with the network, has\nbecome a benchmark for the formal study of dataflow networks. We formulate a\ngeneralized version of the Kahn Principle, which applies to a large class of\nnon-deterministic systems, in the setting of abstract asynchronous networks;\nand prove that the Kahn Principle holds under certain natural assumptions on\nthe model. We also show that a class of models, which represent networks that\ncompute over arbitrary event structures, generalizing dataflow networks which\ncompute over streams, satisfy these assumptions.\n", "versions": [{"version": "v1", "created": "Fri, 2 Dec 2011 11:23:38 GMT"}], "update_date": "2011-12-05", "authors_parsed": [["Abramsky", "Samson", ""]]}, {"id": "1112.0643", "submitter": "Marek Zaionc", "authors": "Katarzyna Grygiel, Pawel M. Idziak, Marek Zaionc", "title": "How big is BCI fragment of BCK logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate quantitative properties of BCI and BCK logics. The first part\nof the paper compares the number of formulas provable in BCI versus BCK logics.\nWe consider formulas built on implication and a fixed set of $k$ variables. We\ninvestigate the proportion between the number of such formulas of a given\nlength $n$ provable in BCI logic against the number of formulas of length $n$\nprovable in richer BCK logic. We examine an asymptotic behavior of this\nfraction when length $n$ of formulas tends to infinity. This limit gives a\nprobability measure that randomly chosen BCK formula is also provable in BCI.\nWe prove that this probability tends to zero as the number of variables tends\nto infinity. The second part of the paper is devoted to the number of lambda\nterms representing proofs of BCI and BCK logics. We build a proportion between\nnumber of such proofs of the same length $n$ and we investigate asymptotic\nbehavior of this proportion when length of proofs tends to infinity. We\ndemonstrate that with probability 0 a randomly chosen BCK proof is also a proof\nof a BCI formula.\n", "versions": [{"version": "v1", "created": "Sat, 3 Dec 2011 11:05:40 GMT"}], "update_date": "2011-12-06", "authors_parsed": [["Grygiel", "Katarzyna", ""], ["Idziak", "Pawel M.", ""], ["Zaionc", "Marek", ""]]}, {"id": "1112.0791", "submitter": "Wolfgang Faber", "authors": "Wolfgang Faber, Miros{\\l}aw Truszczy\\'nski, Stefan Woltran", "title": "Strong Equivalence of Qualitative Optimization Problems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce the framework of qualitative optimization problems (or, simply,\noptimization problems) to represent preference theories. The formalism uses\nseparate modules to describe the space of outcomes to be compared (the\ngenerator) and the preferences on outcomes (the selector). We consider two\ntypes of optimization problems. They differ in the way the generator, which we\nmodel by a propositional theory, is interpreted: by the standard propositional\nlogic semantics, and by the equilibrium-model (answer-set) semantics. Under the\nlatter interpretation of generators, optimization problems directly generalize\nanswer-set optimization programs proposed previously. We study strong\nequivalence of optimization problems, which guarantees their interchangeability\nwithin any larger context. We characterize several versions of strong\nequivalence obtained by restricting the class of optimization problems that can\nbe used as extensions and establish the complexity of associated reasoning\ntasks. Understanding strong equivalence is essential for modular representation\nof optimization problems and rewriting techniques to simplify them without\nchanging their inherent properties.\n", "versions": [{"version": "v1", "created": "Sun, 4 Dec 2011 20:06:29 GMT"}], "update_date": "2011-12-06", "authors_parsed": [["Faber", "Wolfgang", ""], ["Truszczy\u0144ski", "Miros\u0142aw", ""], ["Woltran", "Stefan", ""]]}, {"id": "1112.0923", "submitter": "Murdoch Gabbay", "authors": "Murdoch J. Gabbay", "title": "Finite and infinite support in nominal algebra and logic: nominal\n  completeness theorems for free", "comments": null, "journal-ref": null, "doi": "10.2178/jsl/1344862164", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  By operations on models we show how to relate completeness with respect to\npermissive-nominal models to completeness with respect to nominal models with\nfinite support. Models with finite support are a special case of\npermissive-nominal models, so the construction hinges on generating from an\ninstance of the latter, some instance of the former in which sufficiently many\ninequalities are preserved between elements. We do this using an infinite\ngeneralisation of nominal atoms-abstraction.\n  The results are of interest in their own right, but also, we factor the\nmathematics so as to maximise the chances that it could be used off-the-shelf\nfor other nominal reasoning systems too. Models with infinite support can be\neasier to work with, so it is useful to have a semi-automatic theorem to\ntransfer results from classes of infinitely-supported nominal models to the\nmore restricted class of models with finite support.\n  In conclusion, we consider different permissive-nominal syntaxes and nominal\nmodels and discuss how they relate to the results proved here.\n", "versions": [{"version": "v1", "created": "Mon, 5 Dec 2011 13:54:00 GMT"}], "update_date": "2013-05-28", "authors_parsed": [["Gabbay", "Murdoch J.", ""]]}, {"id": "1112.1186", "submitter": "Olivier Finkel", "authors": "Olivier Finkel (ELM)", "title": "The Determinacy of Context-Free Games", "comments": "To appear in the Proceedings of the 29 th International Symposium on\n  Theoretical Aspects of Computer Science, STACS 2012", "journal-ref": null, "doi": "10.4230/LIPIcs.STACS.2012.555", "report-no": null, "categories": "cs.GT cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the determinacy of Gale-Stewart games whose winning sets are\naccepted by real-time 1-counter B\\\"uchi automata is equivalent to the\ndeterminacy of (effective) analytic Gale-Stewart games which is known to be a\nlarge cardinal assumption. We show also that the determinacy of Wadge games\nbetween two players in charge of omega-languages accepted by 1-counter B\\\"uchi\nautomata is equivalent to the (effective) analytic Wadge determinacy. Using\nsome results of set theory we prove that one can effectively construct a\n1-counter B\\\"uchi automaton A and a B\\\"uchi automaton B such that: (1) There\nexists a model of ZFC in which Player 2 has a winning strategy in the Wadge\ngame W(L(A), L(B)); (2) There exists a model of ZFC in which the Wadge game\nW(L(A), L(B)) is not determined. Moreover these are the only two possibilities,\ni.e. there are no models of ZFC in which Player 1 has a winning strategy in the\nWadge game W(L(A), L(B)).\n", "versions": [{"version": "v1", "created": "Tue, 6 Dec 2011 07:58:59 GMT"}], "update_date": "2012-03-08", "authors_parsed": [["Finkel", "Olivier", "", "ELM"]]}, {"id": "1112.1316", "submitter": "Emmanuel Polonowski", "authors": "Emmanuel Polonowski", "title": "Generic Environments in Coq", "comments": "6 pages; The Third Coq Workshop (Coq'3), 2011", "journal-ref": null, "doi": null, "report-no": "TR--LACL--2011--3", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a library which provides an abstract data type of environments,\nas a functor parameterized by a module defining variables, and a function which\nbuilds environments for such variables with any Type of type. Usual operations\nover environments are defined, along with an extensive set of basic and more\nadvanced properties. Moreover, we give an implementation using lists satisfying\nall the required properties.\n", "versions": [{"version": "v1", "created": "Tue, 6 Dec 2011 15:39:48 GMT"}], "update_date": "2011-12-07", "authors_parsed": [["Polonowski", "Emmanuel", ""]]}, {"id": "1112.1554", "submitter": "Tristan Crolard", "authors": "Tristan Crolard and Emmanuel Polonowski", "title": "A program logic for higher-order procedural variables and non-local\n  jumps", "comments": null, "journal-ref": null, "doi": null, "report-no": "TR-LACL-2011-4", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Relying on the formulae-as-types paradigm for classical logic, we define a\nprogram logic for an imperative language with higher-order procedural variables\nand non-local jumps. Then, we show how to derive a sound program logic for this\nprogramming language. As a by-product, we obtain a non-dependent type system\nwhich is more permissive than what is usually found in statically typed\nimperative languages. As a generic example, we encode imperative versions of\ndelimited continuations operators shift and reset.\n", "versions": [{"version": "v1", "created": "Wed, 7 Dec 2011 13:23:37 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Crolard", "Tristan", ""], ["Polonowski", "Emmanuel", ""]]}, {"id": "1112.1783", "submitter": "Chih-Hong Cheng", "authors": "Chih-Hong Cheng, Saddek Bensalem, Rongjie Yan, Harald Ruess, Christian\n  Buckl, Alois Knoll", "title": "Distributed Priority Synthesis and its Applications", "comments": "1. Timestamp the joint work \"Distributed Priority Synthesis\" from\n  four institutes (Verimag, TUM, ISCAS, fortiss). 2. This version (v.2) updates\n  related work in distributed synthesis", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a set of interacting components with non-deterministic variable update\nand given safety requirements, the goal of priority synthesis is to restrict,\nby means of priorities, the set of possible interactions in such a way as to\nguarantee the given safety conditions for all possible runs. In distributed\npriority synthesis we are interested in obtaining local sets of priorities,\nwhich are deployed in terms of local component controllers sharing intended\nnext moves between components in local neighborhoods only. These possible\ncommunication paths between local controllers are specified by means of a\ncommunication architecture. We formally define the problem of distributed\npriority synthesis in terms of a multi-player safety game between players for\n(angelically) selecting the next transition of the components and an\nenvironment for (demonically) updating uncontrollable variables; this problem\nis NP-complete. We propose several optimizations including a solution-space\nexploration based on a diagnosis method using a nested extension of the usual\nattractor computation in games together with a reduction to corresponding SAT\nproblems. When diagnosis fails, the method proposes potential candidates to\nguide the exploration. These optimized algorithms for solving distributed\npriority synthesis problems have been integrated into our VissBIP framework. An\nexperimental validation of this implementation is performed using a range of\ncase studies including scheduling in multicore processors and modular robotics.\n", "versions": [{"version": "v1", "created": "Thu, 8 Dec 2011 09:07:53 GMT"}, {"version": "v2", "created": "Fri, 27 Jan 2012 17:28:37 GMT"}], "update_date": "2012-01-30", "authors_parsed": [["Cheng", "Chih-Hong", ""], ["Bensalem", "Saddek", ""], ["Yan", "Rongjie", ""], ["Ruess", "Harald", ""], ["Buckl", "Christian", ""], ["Knoll", "Alois", ""]]}, {"id": "1112.1795", "submitter": "Francois Clement", "authors": "Sylvie Boldo (INRIA Saclay - Ile de France, LRI), Francois Clement\n  (INRIA Rocquencourt), Jean-Christophe Filli\\^atre (INRIA Saclay - Ile de\n  France, LRI), Micaela Mayero (LIPN, Inria Grenoble Rh\\^one-Alpes / LIP\n  Laboratoire de l'Informatique du Parall\\'elisme), Guillaume Melquiond (INRIA\n  Saclay - Ile de France, LRI), Pierre Weis (INRIA Rocquencourt)", "title": "Wave Equation Numerical Resolution: a Comprehensive Mechanized Proof of\n  a C Program", "comments": "No. RR-7826 (2011)", "journal-ref": "Journal of Automated Reasoning 50, 4 (2013) 423-456", "doi": "10.1007/s10817-012-9255-4", "report-no": null, "categories": "cs.LO math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We formally prove correct a C program that implements a numerical scheme for\nthe resolution of the one-dimensional acoustic wave equation. Such an\nimplementation introduces errors at several levels: the numerical scheme\nintroduces method errors, and floating-point computations lead to round-off\nerrors. We annotate this C program to specify both method error and round-off\nerror. We use Frama-C to generate theorems that guarantee the soundness of the\ncode. We discharge these theorems using SMT solvers, Gappa, and Coq. This\ninvolves a large Coq development to prove the adequacy of the C program to the\nnumerical scheme and to bound errors. To our knowledge, this is the first time\nsuch a numerical analysis program is fully machine-checked.\n", "versions": [{"version": "v1", "created": "Thu, 8 Dec 2011 09:45:56 GMT"}, {"version": "v2", "created": "Wed, 16 May 2012 06:57:05 GMT"}, {"version": "v3", "created": "Thu, 12 Jul 2012 13:32:53 GMT"}], "update_date": "2013-03-27", "authors_parsed": [["Boldo", "Sylvie", "", "INRIA Saclay - Ile de France, LRI"], ["Clement", "Francois", "", "INRIA Rocquencourt"], ["Filli\u00e2tre", "Jean-Christophe", "", "INRIA Saclay - Ile de\n  France, LRI"], ["Mayero", "Micaela", "", "LIPN, Inria Grenoble Rh\u00f4ne-Alpes / LIP\n  Laboratoire de l'Informatique du Parall\u00e9lisme"], ["Melquiond", "Guillaume", "", "INRIA\n  Saclay - Ile de France, LRI"], ["Weis", "Pierre", "", "INRIA Rocquencourt"]]}, {"id": "1112.1848", "submitter": "Tristan Crolard", "authors": "Tristan Crolard", "title": "A Formally Specified Program Logic for Higher-Order Procedural Variables\n  and non-local Jumps", "comments": null, "journal-ref": null, "doi": null, "report-no": "TR-LACL-2011-5", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We formally specified a program logic for higher-order procedural variables\nand non-local jumps with Ott and Twelf. Moreover, the dependent type systems\nand the translation are both executable specifications thanks to Twelf's logic\nprogramming engine. In particular, relying on Filinski's encoding of\nshift/reset using callcc/throw and a global meta-continuation (simulated in\nstate passing style), we have mechanically checked the correctness of a few\nexamples (all source files are available on request).\n", "versions": [{"version": "v1", "created": "Thu, 8 Dec 2011 14:36:59 GMT"}], "update_date": "2011-12-09", "authors_parsed": [["Crolard", "Tristan", ""]]}, {"id": "1112.2141", "submitter": "Joseph Norman", "authors": "Joseph W. Norman", "title": "Resolving G\\\"odel's Incompleteness Myth: Polynomial Equations and\n  Dynamical Systems for Algebraic Logic", "comments": "45 pages; revised to clarify some general notation and specific\n  points on polynomials, remove extraneous material, fix typos, and introduce\n  the Pythagorean fallacy", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A new computational method that uses polynomial equations and dynamical\nsystems to evaluate logical propositions is introduced and applied to Goedel's\nincompleteness theorems. The truth value of a logical formula subject to a set\nof axioms is computed from the solution to the corresponding system of\npolynomial equations. A reference by a formula to its own provability is shown\nto be a recurrence relation, which can be either interpreted as such to\ngenerate a discrete dynamical system, or interpreted in a static way to create\nan additional simultaneous equation. In this framework the truth values of\nlogical formulas and other polynomial objectives have complex data structures:\nsets of elementary values, or dynamical systems that generate sets of infinite\nsequences of such solution-value sets. Besides the routine result that a\nformula has a definite elementary value, these data structures encode several\nexceptions: formulas that are ambiguous, unsatisfiable, unsteady, or\ncontingent. These exceptions represent several semantically different types of\nundecidability; none causes any fundamental problem for mathematics. It is\nsimple to calculate that Goedel's formula, which asserts that it cannot be\nproven, is exceptional in specific ways: interpreted statically, the formula\ndefines an inconsistent system of equations (thus it is called unsatisfiable);\ninterpreted dynamically, it defines a dynamical system that has a periodic\norbit and no fixed point (thus it is called unsteady). These exceptions are not\ncatastrophic failures of logic; they are accurate mathematical descriptions of\nGoedel's self-referential construction. Goedel's analysis does not reveal any\nessential incompleteness in formal reasoning systems, nor any barrier to\nproving the consistency of such systems by ordinary mathematical means.\n", "versions": [{"version": "v1", "created": "Wed, 30 Nov 2011 18:29:13 GMT"}, {"version": "v2", "created": "Mon, 12 Dec 2011 17:03:12 GMT"}, {"version": "v3", "created": "Wed, 21 Dec 2011 23:39:55 GMT"}], "update_date": "2011-12-23", "authors_parsed": [["Norman", "Joseph W.", ""]]}, {"id": "1112.2313", "submitter": "Huan Chen", "authors": "Huan Chen, Mikolas Janota, Joao Marques-Silva", "title": "QBF-Based Boolean Function Bi-Decomposition", "comments": "This paper is an extension of the DATE'2012 paper \"QBF-Based Boolean\n  Function Bi-Decomposition\" by Huan Chen, Mikolas Janota, Joao Marques-Silva", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Boolean function bi-decomposition is ubiquitous in logic synthesis. It\nentails the decomposition of a Boolean function using two-input simple logic\ngates. Existing solutions for bi-decomposition are often based on BDDs and,\nmore recently, on Boolean Satisfiability. In addition, the partition of the\ninput set of variables is either assumed, or heuristic solutions are considered\nfor finding good partitions. In contrast to earlier work, this paper proposes\nthe use of Quantified Boolean Formulas (QBF) for computing bi- decompositions.\nThese bi-decompositions are optimal in terms of the achieved disjointness and\nbalancedness of the input set of variables. Experimental results, obtained on\nrepresentative benchmarks, demonstrate clear improvements in the quality of\ncomputed decompositions, but also the practical feasibility of QBF-based\nbi-decomposition.\n", "versions": [{"version": "v1", "created": "Sun, 11 Dec 2011 00:41:04 GMT"}, {"version": "v2", "created": "Wed, 14 Dec 2011 00:40:48 GMT"}], "update_date": "2011-12-15", "authors_parsed": [["Chen", "Huan", ""], ["Janota", "Mikolas", ""], ["Marques-Silva", "Joao", ""]]}, {"id": "1112.2394", "submitter": "Dominique Duval", "authors": "Jean-Guillaume Dumas (LJK), Dominique Duval (LJK), Laurent Fousse\n  (LJK), Jean-Claude Reynaud (RC)", "title": "A duality between exceptions and states", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this short note we study the semantics of two basic computational effects,\nexceptions and states, from a new point of view. In the handling of exceptions\nwe dissociate the control from the elementary operation which recovers from the\nexception. In this way it becomes apparent that there is a duality, in the\ncategorical sense, between exceptions and states.\n", "versions": [{"version": "v1", "created": "Sun, 11 Dec 2011 20:27:55 GMT"}], "update_date": "2011-12-14", "authors_parsed": [["Dumas", "Jean-Guillaume", "", "LJK"], ["Duval", "Dominique", "", "LJK"], ["Fousse", "Laurent", "", "LJK"], ["Reynaud", "Jean-Claude", "", "RC"]]}, {"id": "1112.2396", "submitter": "EPTCS", "authors": "Jean-Guillaume Dumas (LJK, Universit\\'e de Grenoble, France),\n  Dominique Duval (LJK, Universit\\'e de Grenoble, France), Laurent Fousse (LJK,\n  Universit\\'e de Grenoble, France), Jean-Claude Reynaud (LJK, Universit\\'e de\n  Grenoble, France)", "title": "Decorated proofs for computational effects: States", "comments": "In Proceedings ACCAT 2012, arXiv:1208.4301", "journal-ref": "EPTCS 93, 2012, pp. 45-59", "doi": "10.4204/EPTCS.93.3", "report-no": null, "categories": "cs.PL cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The syntax of an imperative language does not mention explicitly the state,\nwhile its denotational semantics has to mention it. In this paper we show that\nthe equational proofs about an imperative language may hide the state, in the\nsame way as the syntax does.\n", "versions": [{"version": "v1", "created": "Sun, 11 Dec 2011 20:29:40 GMT"}, {"version": "v2", "created": "Tue, 20 Dec 2011 15:38:36 GMT"}, {"version": "v3", "created": "Fri, 7 Sep 2012 01:22:05 GMT"}], "update_date": "2012-09-10", "authors_parsed": [["Dumas", "Jean-Guillaume", "", "LJK, Universit\u00e9 de Grenoble, France"], ["Duval", "Dominique", "", "LJK, Universit\u00e9 de Grenoble, France"], ["Fousse", "Laurent", "", "LJK,\n  Universit\u00e9 de Grenoble, France"], ["Reynaud", "Jean-Claude", "", "LJK, Universit\u00e9 de\n  Grenoble, France"]]}, {"id": "1112.2795", "submitter": "Luke Mathieson", "authors": "Bernard Mans and Luke Mathieson", "title": "On the Treewidth of Dynamic Graphs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dynamic graph theory is a novel, growing area that deals with graphs that\nchange over time and is of great utility in modelling modern wireless, mobile\nand dynamic environments. As a graph evolves, possibly arbitrarily, it is\nchallenging to identify the graph properties that can be preserved over time\nand understand their respective computability.\n  In this paper we are concerned with the treewidth of dynamic graphs. We focus\non metatheorems, which allow the generation of a series of results based on\ngeneral properties of classes of structures. In graph theory two major\nmetatheorems on treewidth provide complexity classifications by employing\nstructural graph measures and finite model theory. Courcelle's Theorem gives a\ngeneral tractability result for problems expressible in monadic second order\nlogic on graphs of bounded treewidth, and Frick & Grohe demonstrate a similar\nresult for first order logic and graphs of bounded local treewidth.\n  We extend these theorems by showing that dynamic graphs of bounded (local)\ntreewidth where the length of time over which the graph evolves and is observed\nis finite and bounded can be modelled in such a way that the (local) treewidth\nof the underlying graph is maintained. We show the application of these results\nto problems in dynamic graph theory and dynamic extensions to static problems.\nIn addition we demonstrate that certain widely used dynamic graph classes\nnaturally have bounded local treewidth.\n", "versions": [{"version": "v1", "created": "Tue, 13 Dec 2011 05:13:24 GMT"}, {"version": "v2", "created": "Fri, 25 May 2012 04:55:40 GMT"}], "update_date": "2012-05-28", "authors_parsed": [["Mans", "Bernard", ""], ["Mathieson", "Luke", ""]]}, {"id": "1112.2950", "submitter": "Emmanuel Polonowski", "authors": "Tristan Crolard (LACL), Emmanuel Polonowski (LACL)", "title": "Deriving a Hoare-Floyd logic for non-local jumps from a\n  formulae-as-types notion of control", "comments": "The 22nd Nordic Workshop on Programming Theory, Turku : Finland\n  (2010)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We derive a Hoare-Floyd logic for non-local jumps and mutable higher-order\nprocedural variables from a formul{\\ae}-as-types notion of control for\nclassical logic. The main contribution of this work is the design of an\nimperative dependent type system for non-local jumps which corresponds to\nclassical logic but where the famous consequence rule is still derivable.\n", "versions": [{"version": "v1", "created": "Tue, 13 Dec 2011 16:44:27 GMT"}], "update_date": "2011-12-14", "authors_parsed": [["Crolard", "Tristan", "", "LACL"], ["Polonowski", "Emmanuel", "", "LACL"]]}, {"id": "1112.3053", "submitter": "Pierre Clairambault", "authors": "Pierre Clairambault", "title": "Estimation of the length of interactions in arena game semantics", "comments": "Foundations of Software Science and Computational Structures 14th\n  International Conference, FOSSACS 2011, Saarbr\\\"ucken : Germany (2011)", "journal-ref": null, "doi": "10.1007/978-3-642-19805-2_23", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We estimate the maximal length of interactions between strategies in HO/N\ngame semantics, in the spirit of the work by Schwichtenberg and Beckmann for\nthe length of reduction in simply typed lambdacalculus. Because of the\noperational content of game semantics, the bounds presented here also apply to\nhead linear reduction on lambda-terms and to the execution of programs by\nabstract machines (PAM/KAM), including in presence of computational effects\nsuch as non-determinism or ground type references. The proof proceeds by\nextracting from the games model a combinatorial rewriting rule on trees of\nnatural numbers, which can then be analyzed independently of game semantics or\nlambda-calculus.\n", "versions": [{"version": "v1", "created": "Tue, 13 Dec 2011 21:47:07 GMT"}], "update_date": "2011-12-15", "authors_parsed": [["Clairambault", "Pierre", ""]]}, {"id": "1112.3198", "submitter": "Pierre Clairambault", "authors": "Pierre Clairambault", "title": "Isomorphisms of types in the presence of higher-order references", "comments": "Twenty-Sixth Annual IEEE Symposium on Logic In Computer Science (LICS\n  2011), Toronto : Canada (2011)", "journal-ref": null, "doi": "10.1109/LICS.2011.32", "report-no": null, "categories": "cs.LO cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the problem of type isomorphisms in a programming language\nwith higher-order references. We first recall the game-theoretic model of\nhigher-order references by Abramsky, Honda and McCusker. Solving an open\nproblem by Laurent, we show that two finitely branching arenas are isomorphic\nif and only if they are geometrically the same, up to renaming of moves\n(Laurent's forest isomorphism). We deduce from this an equational theory\ncharacterizing isomorphisms of types in a finitary language with higher order\nreferences. We show however that Laurent's conjecture does not hold on\ninfinitely branching arenas, yielding a non-trivial type isomorphism in the\nextension of this language with natural numbers.\n", "versions": [{"version": "v1", "created": "Wed, 14 Dec 2011 13:14:30 GMT"}], "update_date": "2011-12-15", "authors_parsed": [["Clairambault", "Pierre", ""]]}, {"id": "1112.3455", "submitter": "Pierre Lescanne", "authors": "Silvia Ghilezan, Jelena Ivetic, Pierre Lescanne (LIP), Silvia Likavec", "title": "Resource control and strong normalisation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce the \\emph{resource control cube}, a system consisting of eight\nintuitionistic lambda calculi with either implicit or explicit control of\nresources and with either natural deduction or sequent calculus. The four\ncalculi of the cube that correspond to natural deduction have been proposed by\nKesner and Renaud and the four calculi that correspond to sequent lambda\ncalculi are introduced in this paper. The presentation is parameterized with\nthe set of resources (weakening or contraction), which enables a uniform\ntreatment of the eight calculi of the cube. The simply typed resource control\ncube, on the one hand, expands the Curry-Howard correspondence to\nintuitionistic natural deduction and intuitionistic sequent logic with implicit\nor explicit structural rules and, on the other hand, is related to\nsubstructural logics. We propose a general intersection type system for the\nresource control cube calculi. Our main contribution is a characterisation of\nstrong normalisation of reductions in this cube. First, we prove that\ntypeability implies strong normalisation in the ''natural deduction base\" of\nthe cube by adapting the reducibility method. We then prove that typeability\nimplies strong normalisation in the ''sequent base\" of the cube by using a\ncombination of well-orders and a suitable embedding in the ''natural deduction\nbase\". Finally, we prove that strong normalisation implies typeability in the\ncube using head subject expansion. All proofs are general and can be made\nspecific to each calculus of the cube by instantiating the set of resources.\n", "versions": [{"version": "v1", "created": "Thu, 15 Dec 2011 09:24:47 GMT"}, {"version": "v2", "created": "Tue, 20 Mar 2012 17:50:24 GMT"}, {"version": "v3", "created": "Fri, 17 May 2013 14:13:24 GMT"}], "update_date": "2013-05-20", "authors_parsed": [["Ghilezan", "Silvia", "", "LIP"], ["Ivetic", "Jelena", "", "LIP"], ["Lescanne", "Pierre", "", "LIP"], ["Likavec", "Silvia", ""]]}, {"id": "1112.3456", "submitter": "Pierre Clairambault", "authors": "Pierre Clairambault, Peter Dybjer (CSE)", "title": "The Biequivalence of Locally Cartesian Closed Categories and\n  Martin-L\\\"of Type Theories", "comments": "TLCA 2011 - 10th Typed Lambda Calculi and Applications, Novi Sad :\n  Serbia (2011)", "journal-ref": "Math. Struct. Comp. Sci. 24 (2014) e240606", "doi": "10.1017/S0960129513000881", "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Seely's paper \"Locally cartesian closed categories and type theory\" contains\na well-known result in categorical type theory: that the category of locally\ncartesian closed categories is equivalent to the category of Martin-L\\\"of type\ntheories with Pi-types, Sigma-types and extensional identity types. However,\nSeely's proof relies on the problematic assumption that substitution in types\ncan be interpreted by pullbacks. Here we prove a corrected version of Seely's\ntheorem: that the B\\'enabou-Hofmann interpretation of Martin-L\\\"of type theory\nin locally cartesian closed categories yields a biequivalence of 2-categories.\nTo facilitate the technical development we employ categories with families as a\nsubstitute for syntactic Martin-L\\\"of type theories. As a second result we\nprove that if we remove Pi-types the resulting categories with families are\nbiequivalent to left exact categories.\n", "versions": [{"version": "v1", "created": "Thu, 15 Dec 2011 09:32:25 GMT"}], "update_date": "2019-02-20", "authors_parsed": [["Clairambault", "Pierre", "", "CSE"], ["Dybjer", "Peter", "", "CSE"]]}, {"id": "1112.3756", "submitter": "Mohamed El-Zawawy Dr.", "authors": "Mohamed A. El-Zawawy", "title": "Probabilistic pointer analysis for multithreaded programs", "comments": "12 pages", "journal-ref": "ScienceAsia 37 (2011): 344-354", "doi": "10.2306/scienceasia1513-1874.2011.37.344", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The use of pointers and data-structures based on pointers results in circular\nmemory references that are interpreted by a vital compiler analysis, namely\npointer analysis. For a pair of memory references at a program point, a typical\npointer analysis specifies if the points-to relation between them may exist,\ndefinitely does not exist, or definitely exists. The \"may be\" case, which\ndescribes the points-to relation for most of the pairs, cannot be dealt with by\nmost compiler optimizations. This is so to guarantee the soundness of these\noptimizations. However, the \"may be\" case can be capitalized by the modern\nclass of speculative optimizations if the probability that two memory\nreferences alias can be measured. Focusing on multithreading, a prevailing\ntechnique of programming, this paper presents a new flow-sensitive technique\nfor probabilistic pointer analysis of multithreaded programs. The proposed\ntechnique has the form of a type system and calculates the probability of every\npoints-to relation at each program point. The key to our approach is to\ncalculate the points-to information via a post-type derivation. The use of type\nsystems has the advantage of associating each analysis results with a\njustification (proof) for the correctness of the results. This justification\nhas the form of a type derivation and is very much required in applications\nlike certified code.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 10:52:35 GMT"}], "update_date": "2011-12-19", "authors_parsed": [["El-Zawawy", "Mohamed A.", ""]]}, {"id": "1112.3925", "submitter": "Emil Je\\v{r}\\'abek", "authors": "Emil Je\\v{r}\\'abek", "title": "Root finding with threshold circuits", "comments": "19 pages, 1 figure", "journal-ref": "Theoretical Computer Science 462 (2012), pp. 59--69", "doi": "10.1016/j.tcs.2012.09.001", "report-no": null, "categories": "cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that for any constant d, complex roots of degree d univariate\nrational (or Gaussian rational) polynomials---given by a list of coefficients\nin binary---can be computed to a given accuracy by a uniform TC^0 algorithm (a\nuniform family of constant-depth polynomial-size threshold circuits). The basic\nidea is to compute the inverse function of the polynomial by a power series. We\nalso discuss an application to the theory VTC^0 of bounded arithmetic.\n", "versions": [{"version": "v1", "created": "Fri, 16 Dec 2011 19:20:03 GMT"}, {"version": "v2", "created": "Tue, 23 Oct 2012 14:56:21 GMT"}], "update_date": "2012-10-24", "authors_parsed": [["Je\u0159\u00e1bek", "Emil", ""]]}, {"id": "1112.4428", "submitter": "Ido Ben-Zvi", "authors": "Ido Ben-Zvi", "title": "Causality, Knowledge and Coordination in Distributed Systems", "comments": "PhD Dissertation", "journal-ref": null, "doi": null, "report-no": "PHD-2011-09", "categories": "cs.LO cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Effecting coordination across remote sites in a distributed system is an\nessential part of distributed computing, and also an inherent challenge. In\n1978, an analysis of communication in asynchronous systems was suggested by\nLeslie Lamport. Lamport's analysis determines a notion of temporal precedence,\na sort of weak notion of time, which is otherwise missing in asynchronous\nsystems. This notion has been extensively utilized in various applications.\n  Yet the analysis is limited to systems that are asynchronous. In this thesis\nwe go beyond by investigating causality in synchronous systems. In such\nsystems, the boundaries of causal influence are not charted out exclusively by\nmessage passing. Here time itself, passing at a uniform (or almost uniform)\nrate for all processes, is also a medium by which causal influence may fan out.\nThis thesis studies, and characterizes, the combinations of time and message\npassing that govern causal influence in synchronous systems.\n  It turns out that knowledge based analysis [FHMV] provides a well tailored\nformal framework within which causal notions can be studied. As we show, the\nformal notion of knowledge is highly appropriate for characterizing causal\ninfluence in terms of information flow, broadening the analysis of Chandy and\nMisra in [ChM].\n  We define several generic classes of coordination problems that pose various\ntemporal ordering requirements on the participating processes. These\ncoordination problems provide natural generalizations of real life\nrequirements. We then analyze the causal conditions that underlie suitable\nsolutions to these problems. The analysis is conducted in two stages: first,\nthe temporal ordering requirements are reduced to epistemic conditions. Then,\nthese epistemic conditions are characterized in terms of the causal\ncommunication patterns that are necessary and sufficient to bring them about.\n", "versions": [{"version": "v1", "created": "Mon, 19 Dec 2011 18:27:05 GMT"}], "update_date": "2011-12-20", "authors_parsed": [["Ben-Zvi", "Ido", ""]]}, {"id": "1112.5096", "submitter": "Vladimir Anashin", "authors": "Vladimir Anashin", "title": "The Non-Archimedean Theory of Discrete Systems", "comments": "The extended version of the talk given at MACIS-2011", "journal-ref": "Mathematics in Computer Science, 2012, vol. 6, no. 4, p. 375--393", "doi": "10.1007/s11786-012-0132-7", "report-no": null, "categories": "math.DS cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the paper, we study behavior of discrete dynamical systems (automata)\nw.r.t. transitivity; that is, speaking loosely, we consider how diverse may be\nbehavior of the system w.r.t. variety of word transformations performed by the\nsystem: We call a system completely transitive if, given arbitrary pair $a,b$\nof finite words that have equal lengths, the system $\\mathfrak A$, while\nevolution during (discrete) time, at a certain moment transforms $a$ into $b$.\nTo every system $\\mathfrak A$, we put into a correspondence a family $\\mathcal\nF_{\\mathfrak A}$ of continuous maps of a suitable non-Archimedean metric space\nand show that the system is completely transitive if and only if the family\n$\\mathcal F_{\\mathfrak A}$ is ergodic w.r.t. the Haar measure; then we find\neasy-to-verify conditions the system must satisfy to be completely transitive.\nThe theory can be applied to analyze behavior of straight-line computer\nprograms (in particular, pseudo-random number generators that are used in\ncryptography and simulations) since basic CPU instructions (both numerical and\nlogical) can be considered as continuous maps of a (non-Archimedean) metric\nspace $\\mathbb Z_2$ of 2-adic integers.\n", "versions": [{"version": "v1", "created": "Wed, 21 Dec 2011 17:10:32 GMT"}, {"version": "v2", "created": "Fri, 26 Oct 2012 10:44:27 GMT"}], "update_date": "2014-03-05", "authors_parsed": [["Anashin", "Vladimir", ""]]}, {"id": "1112.5671", "submitter": "Jan  Strejcek", "authors": "Jan Strej\\v{c}ek, Marek Trt\\'ik", "title": "Abstracting Path Conditions", "comments": "a shorter version published at ISSTA 2012. arXiv admin note: text\n  overlap with arXiv:1112.4703", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a symbolic-execution-based algorithm that for a given program and\na given program location produces a nontrivial necessary condition on input\nvalues to drive the program execution to the given location. We also propose an\napplication of necessary conditions in contemporary bug-finding and\ntest-generation tools. Experimental results show that the presented technique\ncan significantly improve performance of the tools.\n", "versions": [{"version": "v1", "created": "Fri, 23 Dec 2011 23:17:10 GMT"}, {"version": "v2", "created": "Sun, 11 Dec 2016 00:18:33 GMT"}], "update_date": "2016-12-13", "authors_parsed": [["Strej\u010dek", "Jan", ""], ["Trt\u00edk", "Marek", ""]]}, {"id": "1112.5761", "submitter": "Grigore Rosu", "authors": "Grigore Rosu (University of Illinois at Urbana-Champaign), Feng Chen\n  (University of Illinois at Urbana-Champaign)", "title": "Semantics and Algorithms for Parametric Monitoring", "comments": "This paper will appear in LMCS. It is an extended version of a paper\n  presented in TACAS'09", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 1 (February\n  23, 2012) lmcs:710", "doi": "10.2168/LMCS-8(1:9)2012", "report-no": null, "categories": "cs.PL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Analysis of execution traces plays a fundamental role in many program\nanalysis approaches, such as runtime verification, testing, monitoring, and\nspecification mining. Execution traces are frequently parametric, i.e., they\ncontain events with parameter bindings. Each parametric trace usually consists\nof many meaningful trace slices merged together, each slice corresponding to\none parameter binding. This gives a semantics-based solution to parametric\ntrace analysis. A general-purpose parametric trace slicing technique is\nintroduced, which takes each event in the parametric trace and dispatches it to\nits corresponding trace slices. This parametric trace slicing technique can be\nused in combination with any conventional, non-parametric trace analysis\ntechnique, by applying the later on each trace slice. As an instance, a\nparametric property monitoring technique is then presented. The presented\nparametric trace slicing and monitoring techniques have been implemented and\nextensively evaluated. Measurements of runtime overhead confirm that the\ngenerality of the discussed techniques does not come at a performance expense\nwhen compared with existing parametric trace monitoring systems.\n", "versions": [{"version": "v1", "created": "Sun, 25 Dec 2011 00:02:26 GMT"}, {"version": "v2", "created": "Tue, 21 Feb 2012 21:58:42 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Rosu", "Grigore", "", "University of Illinois at Urbana-Champaign"], ["Chen", "Feng", "", "University of Illinois at Urbana-Champaign"]]}, {"id": "1112.5908", "submitter": "Leopoldo Bertossi", "authors": "Jaffer Gardezi and Leopoldo Bertossi", "title": "Query Answering under Matching Dependencies for Data Cleaning:\n  Complexity and Algorithms", "comments": "Conference submission, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Matching dependencies (MDs) have been recently introduced as declarative\nrules for entity resolution (ER), i.e. for identifying and resolving duplicates\nin relational instance $D$. A set of MDs can be used as the basis for a\npossibly non-deterministic mechanism that computes a duplicate-free instance\nfrom $D$. The possible results of this process are the clean, \"minimally\nresolved instances\" (MRIs). There might be several MRIs for $D$, and the\n\"resolved answers\" to a query are those that are shared by all the MRIs. We\ninvestigate the problem of computing resolved answers. We look at various sets\nof MDs, developing syntactic criteria for determining (in)tractability of the\nresolved answer problem, including a dichotomy result. For some tractable\nclasses of MDs and conjunctive queries, we present a query rewriting\nmethodology that can be used to retrieve the resolved answers. We also\ninvestigate connections with \"consistent query answering\", deriving further\ntractability results for MD-based ER.\n", "versions": [{"version": "v1", "created": "Tue, 27 Dec 2011 02:40:28 GMT"}], "update_date": "2011-12-30", "authors_parsed": [["Gardezi", "Jaffer", ""], ["Bertossi", "Leopoldo", ""]]}, {"id": "1112.6265", "submitter": "Iddo Tzameret", "authors": "Pavel Hrubes and Iddo Tzameret", "title": "Short Proofs for the Determinant Identities", "comments": "46 pages; Revision and corrections to Section 7. Addition of short\n  proofs for the Cayley-Hamilton theorem. Other minor changes", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study arithmetic proof systems P_c(F) and P_f(F) operating with arithmetic\ncircuits and arithmetic formulas, respectively, that prove polynomial\nidentities over a field F. We establish a series of structural theorems about\nthese proof systems, the main one stating that P_c(F) proofs can be balanced:\nif a polynomial identity of syntactic degree d and depth k has a P_c(F) proof\nof size s, then it also has a P_c(F) proof of size poly(s,d) and depth\nO(k+\\log^2 d + \\log d\\cd \\log s). As a corollary, we obtain a quasipolynomial\nsimulation of P_c(F) by P_f(F), for identities of a polynomial syntactic\ndegree.\n  Using these results we obtain the following: consider the identities det(XY)\n= det(X)det(Y) and det(Z)= z_{11}... z_{nn}, where X,Y and Z are nxn square\nmatrices and Z is a triangular matrix with z_{11},..., z_{nn} on the diagonal\n(and det is the determinant polynomial). Then we can construct a\npolynomial-size arithmetic circuit det such that the above identities have\nP_c(F) proofs of polynomial-size and O(\\log^2 n) depth. Moreover, there exists\nan arithmetic formula det of size n^{O(\\log n)} such that the above identities\nhave P_f(F) proofs of size n^{O(\\log n)}.\n  This yields a solution to a basic open problem in propositional proof\ncomplexity, namely, whether there are polynomial-size NC^2-Frege proofs for the\ndeterminant identities and the hard matrix identities, as considered, e.g., in\nSoltys and Cook (2004) (cf., Beame and Pitassi (1998)). We show that matrix\nidentities like AB=I {\\to} BA=I (for matrices over the two element field) as\nwell as basic properties of the determinant have polynomial-size NC^2-Frege\nproofs, and quasipolynomial-size Frege proofs.\n", "versions": [{"version": "v1", "created": "Thu, 29 Dec 2011 10:18:16 GMT"}, {"version": "v2", "created": "Mon, 22 Apr 2013 11:30:21 GMT"}], "update_date": "2013-04-23", "authors_parsed": [["Hrubes", "Pavel", ""], ["Tzameret", "Iddo", ""]]}, {"id": "1112.6275", "submitter": "Fabio Mogavero PhD", "authors": "Fabio Mogavero, Aniello Murano, Giuseppe Perelli, and Moshe Y. Vardi", "title": "Reasoning About Strategies: On the Model-Checking Problem", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.MA math.LO", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  In open systems verification, to formally check for reliability, one needs an\nappropriate formalism to model the interaction between agents and express the\ncorrectness of the system no matter how the environment behaves. An important\ncontribution in this context is given by modal logics for strategic ability, in\nthe setting of multi-agent games, such as ATL, ATL\\star, and the like.\nRecently, Chatterjee, Henzinger, and Piterman introduced Strategy Logic, which\nwe denote here by CHP-SL, with the aim of getting a powerful framework for\nreasoning explicitly about strategies. CHP-SL is obtained by using first-order\nquantifications over strategies and has been investigated in the very specific\nsetting of two-agents turned-based games, where a non-elementary model-checking\nalgorithm has been provided. While CHP-SL is a very expressive logic, we claim\nthat it does not fully capture the strategic aspects of multi-agent systems. In\nthis paper, we introduce and study a more general strategy logic, denoted SL,\nfor reasoning about strategies in multi-agent concurrent games. We prove that\nSL includes CHP-SL, while maintaining a decidable model-checking problem. In\nparticular, the algorithm we propose is computationally not harder than the\nbest one known for CHP-SL. Moreover, we prove that such a problem for SL is\nNonElementarySpace-hard. This negative result has spurred us to investigate\nhere syntactic fragments of SL, strictly subsuming ATL\\star, with the hope of\nobtaining an elementary model-checking problem. Among the others, we study the\nsublogics SL[NG], SL[BG], and SL[1G]. They encompass formulas in a special\nprenex normal form having, respectively, nested temporal goals, Boolean\ncombinations of goals and, a single goal at a time. About these logics, we\nprove that the model-checking problem for SL[1G] is 2ExpTime-complete, thus not\nharder than the one for ATL\\star.\n", "versions": [{"version": "v1", "created": "Thu, 29 Dec 2011 11:12:19 GMT"}, {"version": "v2", "created": "Mon, 6 Feb 2012 00:00:59 GMT"}], "update_date": "2014-02-13", "authors_parsed": [["Mogavero", "Fabio", ""], ["Murano", "Aniello", ""], ["Perelli", "Giuseppe", ""], ["Vardi", "Moshe Y.", ""]]}]