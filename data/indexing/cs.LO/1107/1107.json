[{"id": "1107.0063", "submitter": "EPTCS", "authors": "Peter Csaba \\\"Olveczky (University of Oslo)", "title": "Formal Model Engineering for Embedded Systems Using Real-Time Maude", "comments": "In Proceedings AMMSE 2011, arXiv:1106.5962", "journal-ref": "EPTCS 56, 2011, pp. 3-13", "doi": "10.4204/EPTCS.56.1", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper motivates why Real-Time Maude should be well suited to provide a\nformal semantics and formal analysis capabilities to modeling languages for\nembedded systems. One can then use the code generation facilities of the tools\nfor the modeling languages to automatically synthesize Real-Time Maude\nverification models from design models, enabling a formal model engineering\nprocess that combines the convenience of modeling using an informal but\nintuitive modeling language with formal verification. We give a brief overview\nsix fairly different modeling formalisms for which Real-Time Maude has provided\nthe formal semantics and (possibly) formal analysis. These models include\nbehavioral subsets of the avionics modeling standard AADL, Ptolemy II\ndiscrete-event models, two EMF-based timed model transformation systems, and a\nmodeling language for handset software.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2011 21:44:31 GMT"}], "update_date": "2011-07-04", "authors_parsed": [["\u00d6lveczky", "Peter Csaba", "", "University of Oslo"]]}, {"id": "1107.0065", "submitter": "EPTCS", "authors": "Bertrand Boisvert, Louis F\\'eraud, Sergei Soloviev", "title": "Typed lambda-terms in categorical attributed graph transformation", "comments": "In Proceedings AMMSE 2011, arXiv:1106.5962", "journal-ref": "EPTCS 56, 2011, pp. 33-47", "doi": "10.4204/EPTCS.56.3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper deals with model transformation based on attributed graph\nrewriting. Our contribution investigates a single pushout approach for applying\nthe rewrite rules. The computation of graph attributes is obtained through the\nuse of typed lambda-calculus with inductive types. In this paper we present\nsolutions to cope with single pushout construction for the graph structure and\nthe computations functions. As this rewrite system uses inductive types, the\nexpressiveness of attribute computations is facilitated and appears more\nefficient than the one based on Sigma-algebras. Some examples showing the\ninterest of our computation approach are described in this paper.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2011 21:44:46 GMT"}], "update_date": "2011-07-04", "authors_parsed": [["Boisvert", "Bertrand", ""], ["F\u00e9raud", "Louis", ""], ["Soloviev", "Sergei", ""]]}, {"id": "1107.0066", "submitter": "EPTCS", "authors": "Francisco Dur\\'an (Universidad de M\\'alaga), Peter Csaba \\\"Olveczky\n  (University of Oslo), Jos\\'e E. Rivera (Universidad de M\\'alaga)", "title": "Formal Visual Modeling of Real-Time Systems in e-Motions: Two Case\n  Studies", "comments": "In Proceedings AMMSE 2011, arXiv:1106.5962", "journal-ref": "EPTCS 56, 2011, pp. 49-63", "doi": "10.4204/EPTCS.56.4", "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  e-Motions is an Eclipse-based visual timed model transformation framework\nwith a Real-Time Maude semantics that supports the usual Maude formal analysis\nmethods, including simulation, reachability analysis, and LTL model checking.\ne-Motions is characterized by a novel and powerful set of constructs for\nexpressing timed behaviors. In this paper we illustrate the use of these\nconstructs --- and thereby implicitly investigate their suitability to define\nreal-time systems in an intuitive way --- to define and formally analyze two\nprototypical and very different real-time systems: (i) a simple round trip time\nprotocol for computing the time it takes a message to travel from one node to\nanother, and back; and (ii) the EDF scheduling algorithm.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2011 21:44:53 GMT"}], "update_date": "2011-07-04", "authors_parsed": [["Dur\u00e1n", "Francisco", "", "Universidad de M\u00e1laga"], ["\u00d6lveczky", "Peter Csaba", "", "University of Oslo"], ["Rivera", "Jos\u00e9 E.", "", "Universidad de M\u00e1laga"]]}, {"id": "1107.0068", "submitter": "EPTCS", "authors": "Francisco Dur\\'an (Universidad de M\\'alaga), Martin Gogolla\n  (University of Bremen), Manuel Rold\\'an (Universidad de M\\'alaga)", "title": "Tracing Properties of UML and OCL Models with Maude", "comments": "In Proceedings AMMSE 2011, arXiv:1106.5962", "journal-ref": "EPTCS 56, 2011, pp. 81-97", "doi": "10.4204/EPTCS.56.6", "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The starting point of this paper is a system described in form of a UML class\ndiagram where system states are characterized by OCL invariants and system\ntransitions are defined by OCL pre- and postconditions. The aim of our approach\nis to assist the developer in learning about the consequences of the described\nsystem states and transitions and about the formal implications of the\nproperties that are explicitly given. We propose to draw conclusions about the\nstated constraints by translating the UML and OCL model into the algebraic\nspecification language and system Maude, which is based on rewrite logic. We\nwill concentrate in this paper on employing Maude's capabilities for state\nsearch. Maude's state search offers the possibility to describe a start\nconfiguration of the system and then explore all configurations reachable by\nrewriting. The search can be adjusted by formulating requirements for the\nallowed states and the allowed transitions.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2011 21:45:07 GMT"}], "update_date": "2011-07-04", "authors_parsed": [["Dur\u00e1n", "Francisco", "", "Universidad de M\u00e1laga"], ["Gogolla", "Martin", "", "University of Bremen"], ["Rold\u00e1n", "Manuel", "", "Universidad de M\u00e1laga"]]}, {"id": "1107.0278", "submitter": "Natasha Alechina", "authors": "Thomas {\\AA}gotnes and Natasha Alechina", "title": "Completeness of Epistemic Coalition Logic with Group Knowledge", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Coalition logic is one of the most popular logics for multi-agent systems.\nWhile epistemic extensions of coalition logic have received much attention,\nexistence of their complete axiomatisations has so far been an open problem. In\nthis paper we settle several of those problems. We prove completeness for\nepistemic coalition logic with common knowledge, with distributed knowledge,\nand with both common and distributed knowledge, respectively.\n", "versions": [{"version": "v1", "created": "Fri, 1 Jul 2011 17:20:32 GMT"}], "update_date": "2011-07-04", "authors_parsed": [["\u00c5gotnes", "Thomas", ""], ["Alechina", "Natasha", ""]]}, {"id": "1107.0349", "submitter": "Alexei Lisitsa", "authors": "Alexei Lisitsa", "title": "First-order finite satisfiability vs tree automata in safety\n  verification", "comments": "16 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we deal with verification of safety properties of\nterm-rewriting systems. The verification problem is translated to a purely\nlogical problem of finding a finite countermodel for a first-order formula,\nwhich further resolved by a generic finite model finding procedure. A finite\ncountermodel produced during successful verification provides with a concise\ndescription of the system invariant sufficient to demonstrate a specific safety\nproperty.\n  We show the relative completeness of this approach with respect to the tree\nautomata completion technique. On a set of examples taken from the literature\nwe demonstrate the efficiency of finite model finding approach as well as its\nexplanatory power.\n", "versions": [{"version": "v1", "created": "Sat, 2 Jul 2011 00:45:24 GMT"}], "update_date": "2011-07-05", "authors_parsed": [["Lisitsa", "Alexei", ""]]}, {"id": "1107.0439", "submitter": "H. Reiju Mihara", "authors": "Masahiro Kumabe, H. Reiju Mihara", "title": "The Nakamura numbers for computable simple games", "comments": "24+1 pages", "journal-ref": "Social Choice and Welfare (2008) 31:621-640", "doi": "10.1007/s00355-008-0300-5", "report-no": null, "categories": "cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Nakamura number of a simple game plays a critical role in preference\naggregation (or multi-criterion ranking): the number of alternatives that the\nplayers can always deal with rationally is less than this number. We\ncomprehensively study the restrictions that various properties for a simple\ngame impose on its Nakamura number. We find that a computable game has a finite\nNakamura number greater than three only if it is proper, nonstrong, and\nnonweak, regardless of whether it is monotonic or whether it has a finite\ncarrier. The lack of strongness often results in alternatives that cannot be\nstrictly ranked.\n", "versions": [{"version": "v1", "created": "Sun, 3 Jul 2011 09:03:44 GMT"}], "update_date": "2011-07-05", "authors_parsed": [["Kumabe", "Masahiro", ""], ["Mihara", "H. Reiju", ""]]}, {"id": "1107.0666", "submitter": "Patrick Bahr", "authors": "Patrick Bahr", "title": "Infinitary Term Graph Rewriting", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Term graph rewriting provides a formalism for implementing term rewriting in\nan efficient manner by avoiding duplication. Infinitary term rewriting has been\nintroduced to study infinite term reduction sequences. Such infinite reductions\ncan be used to reason about lazy evaluation. In this paper, we combine term\ngraph rewriting and infinitary term rewriting thereby addressing both\ncomponents of lazy evaluation: non-strictness and sharing. Moreover, we show\nhow our theoretical underpinnings, based on a metric space and a complete\nsemilattice, provides a unified framework for both term rewriting and term\ngraph rewriting. This makes it possible to study the correspondences between\nthese two worlds. As an example, we show how the soundness of term graph\nrewriting w.r.t. term rewriting can be extended to the infinitary setting.\n", "versions": [{"version": "v1", "created": "Mon, 4 Jul 2011 15:48:50 GMT"}], "update_date": "2011-07-05", "authors_parsed": [["Bahr", "Patrick", ""]]}, {"id": "1107.0746", "submitter": "EPTCS", "authors": "Mieke Massink (CNR-ISTI, Pisa, Italy), Gethin Norman (University of\n  Glasgow, UK)", "title": "Proceedings Ninth Workshop on Quantitative Aspects of Programming\n  Languages", "comments": null, "journal-ref": "EPTCS 57, 2011", "doi": "10.4204/EPTCS.57", "report-no": null, "categories": "cs.PL cs.LO cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Ninth Workshop on Quantitative\nAspects of Programming Languages (QAPL 2011), held in Saarbrucken, Germany,\nApril 1--3, 2011. QAPL 2011 is a satellite event of the European Joint\nConferences on Theory and Practice of Software (ETAPS 2011).\n  The workshop theme is on quantitative aspects of computation. These aspects\nare related to the use of physical quantities (storage space, time, bandwidth,\netc.) as well as mathematical quantities (e.g. probability and measures for\nreliability, security and trust), and play an important (sometimes essential)\nrole in characterising the behavior and determining the properties of systems.\nSuch quantities are central to the definition of both the model of systems\n(architecture, language design, semantics) and the methodologies and tools for\nthe analysis and verification of the systems properties. The aim of this\nworkshop is to discuss the explicit use of quantitative information such as\ntime and probabilities either directly in the model or as a tool for the\nanalysis of systems.\n", "versions": [{"version": "v1", "created": "Mon, 4 Jul 2011 21:44:01 GMT"}], "update_date": "2011-07-06", "authors_parsed": [["Massink", "Mieke", "", "CNR-ISTI, Pisa, Italy"], ["Norman", "Gethin", "", "University of\n  Glasgow, UK"]]}, {"id": "1107.0919", "submitter": "Markus Lohrey", "authors": "Stefan G\\\"oller (University of Bremen), Markus Lohrey (University of\n  Leipzig)", "title": "The First-Order Theory of Ground Tree Rewrite Graphs", "comments": "accepted for Logical Methods in Computer Science", "journal-ref": "Logical Methods in Computer Science, Volume 10, Issue 1 (February\n  12, 2014) lmcs:1223", "doi": "10.2168/LMCS-10(1:7)2014", "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the complexity of the uniform first-order theory of ground tree\nrewrite graphs is in ATIME(2^{2^{poly(n)}},O(n)). Providing a matching lower\nbound, we show that there is some fixed ground tree rewrite graph whose\nfirst-order theory is hard for ATIME(2^{2^{poly(n)}},poly(n)) with respect to\nlogspace reductions. Finally, we prove that there exists a fixed ground tree\nrewrite graph together with a single unary predicate in form of a regular tree\nlanguage such that the resulting structure has a non-elementary first-order\ntheory.\n", "versions": [{"version": "v1", "created": "Tue, 5 Jul 2011 16:32:12 GMT"}, {"version": "v2", "created": "Wed, 6 Jul 2011 22:30:54 GMT"}, {"version": "v3", "created": "Wed, 8 Jan 2014 09:22:16 GMT"}, {"version": "v4", "created": "Mon, 10 Feb 2014 10:39:12 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["G\u00f6ller", "Stefan", "", "University of Bremen"], ["Lohrey", "Markus", "", "University of\n  Leipzig"]]}, {"id": "1107.1201", "submitter": "EPTCS", "authors": "Yuxin Deng (Shanghai Jiao Tong University), Rob van Glabbeek (NICTA),\n  Matthew Hennessy (Trinity College Dublin), Carroll Morgan (University of New\n  South Wales)", "title": "Real-Reward Testing for Probabilistic Processes (Extended Abstract)", "comments": "In Proceedings QAPL 2011, arXiv:1107.0746", "journal-ref": "EPTCS 57, 2011, pp. 61-73", "doi": "10.4204/EPTCS.57.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a notion of real-valued reward testing for probabilistic\nprocesses by extending the traditional nonnegative-reward testing with negative\nrewards. In this richer testing framework, the may and must preorders turn out\nto be inverses. We show that for convergent processes with finitely many states\nand transitions, but not in the presence of divergence, the real-reward\nmust-testing preorder coincides with the nonnegative-reward must-testing\npreorder. To prove this coincidence we characterise the usual resolution-based\ntesting in terms of the weak transitions of processes, without having to\ninvolve policies, adversaries, schedulers, resolutions, or similar structures\nthat are external to the process under investigation. This requires\nestablishing the continuity of our function for calculating testing outcomes.\n", "versions": [{"version": "v1", "created": "Wed, 6 Jul 2011 17:54:51 GMT"}], "update_date": "2011-07-07", "authors_parsed": [["Deng", "Yuxin", "", "Shanghai Jiao Tong University"], ["van Glabbeek", "Rob", "", "NICTA"], ["Hennessy", "Matthew", "", "Trinity College Dublin"], ["Morgan", "Carroll", "", "University of New\n  South Wales"]]}, {"id": "1107.1203", "submitter": "EPTCS", "authors": "Daniel Seidel, Janis Voigtl\\\"ander", "title": "Improvements for Free", "comments": "In Proceedings QAPL 2011, arXiv:1107.0746", "journal-ref": "EPTCS 57, 2011, pp. 89-103", "doi": "10.4204/EPTCS.57.7", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  \"Theorems for Free!\" (Wadler, FPCA 1989) is a slogan for a technique that\nallows to derive statements about functions just from their types. So far, the\nstatements considered have always had a purely extensional flavor: statements\nrelating the value semantics of program expressions, but not statements\nrelating their runtime (or other) cost. Here we study an extension of the\ntechnique that allows precisely statements of the latter flavor, by deriving\nquantitative theorems for free. After developing the theory, we walk through a\nnumber of example derivations. Probably none of the statements derived in those\nsimple examples will be particularly surprising to most readers, but what is\nmaybe surprising, and at the very least novel, is that there is a general\ntechnique for obtaining such results on a quantitative level in a principled\nway. Moreover, there is good potential to bring that technique to bear on more\ncomplex examples as well. We turn our attention to short-cut fusion (Gill et\nal., FPCA 1993) in particular.\n", "versions": [{"version": "v1", "created": "Wed, 6 Jul 2011 17:55:03 GMT"}], "update_date": "2011-07-07", "authors_parsed": [["Seidel", "Daniel", ""], ["Voigtl\u00e4nder", "Janis", ""]]}, {"id": "1107.1204", "submitter": "EPTCS", "authors": "Joseph Assouramou (Universit\\'e Laval), Jos\\'ee Desharnais\n  (Universit\\'e Laval)", "title": "Analysis of Non-Linear Probabilistic Hybrid Systems", "comments": "In Proceedings QAPL 2011, arXiv:1107.0746", "journal-ref": "EPTCS 57, 2011, pp. 104-119", "doi": "10.4204/EPTCS.57.8", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper shows how to compute, for probabilistic hybrid systems, the clock\napproximation and linear phase-portrait approximation that have been proposed\nfor non probabilistic processes by Henzinger et al. The techniques permit to\ndefine a rectangular probabilistic process from a non rectangular one, hence\nallowing the model-checking of any class of systems. Clock approximation, which\napplies under some restrictions, aims at replacing a non rectangular variable\nby a clock variable. Linear phase-approximation applies without restriction and\nyields an approximation that simulates the original process. The conditions\nthat we need for probabilistic processes are the same as those for the classic\ncase.\n", "versions": [{"version": "v1", "created": "Wed, 6 Jul 2011 17:55:11 GMT"}], "update_date": "2011-07-07", "authors_parsed": [["Assouramou", "Joseph", "", "Universit\u00e9 Laval"], ["Desharnais", "Jos\u00e9e", "", "Universit\u00e9 Laval"]]}, {"id": "1107.1205", "submitter": "EPTCS", "authors": "Uli Fahrenberg (Irisa/INRIA Rennes), Claus Thrane (Aalborg\n  University), Kim G. Larsen (Aalborg University)", "title": "Distances for Weighted Transition Systems: Games and Properties", "comments": "In Proceedings QAPL 2011, arXiv:1107.0746", "journal-ref": "EPTCS 57, 2011, pp. 134-147", "doi": "10.4204/EPTCS.57.10", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a general framework for reasoning about distances between\ntransition systems with quantitative information. Taking as starting point an\narbitrary distance on system traces, we show how this leads to natural\ndefinitions of a linear and a branching distance on states of such a transition\nsystem. We show that our framework generalizes and unifies a large variety of\npreviously considered system distances, and we develop some general properties\nof our distances. We also show that if the trace distance admits a recursive\ncharacterization, then the corresponding branching distance can be obtained as\na least fixed point to a similar recursive characterization. The central tool\nin our work is a theory of infinite path-building games with quantitative\nobjectives.\n", "versions": [{"version": "v1", "created": "Wed, 6 Jul 2011 17:55:25 GMT"}], "update_date": "2011-07-07", "authors_parsed": [["Fahrenberg", "Uli", "", "Irisa/INRIA Rennes"], ["Thrane", "Claus", "", "Aalborg\n  University"], ["Larsen", "Kim G.", "", "Aalborg University"]]}, {"id": "1107.1206", "submitter": "EPTCS", "authors": "Mathieu Tracol (IST Austria), Jos\\'ee Desharnais (Departement\n  d'informatique et de g\\'enie logiciel, Universit\\'e Laval, Qu\\'ebec, Canada),\n  Abir Zhioua (Departement d'informatique et de g\\'enie logiciel, Universit\\'e\n  Laval, Qu\\'ebec, Canada)", "title": "Computing Distances between Probabilistic Automata", "comments": "In Proceedings QAPL 2011, arXiv:1107.0746", "journal-ref": "EPTCS 57, 2011, pp. 148-162", "doi": "10.4204/EPTCS.57.11", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present relaxed notions of simulation and bisimulation on Probabilistic\nAutomata (PA), that allow some error epsilon. When epsilon is zero we retrieve\nthe usual notions of bisimulation and simulation on PAs. We give logical\ncharacterisations of these notions by choosing suitable logics which differ\nfrom the elementary ones, L with negation and L without negation, by the modal\noperator. Using flow networks, we show how to compute the relations in PTIME.\nThis allows the definition of an efficiently computable non-discounted distance\nbetween the states of a PA. A natural modification of this distance is\nintroduced, to obtain a discounted distance, which weakens the influence of\nlong term transitions. We compare our notions of distance to others previously\ndefined and illustrate our approach on various examples. We also show that our\ndistance is not expansive with respect to process algebra operators. Although L\nwithout negation is a suitable logic to characterise epsilon-(bi)simulation on\ndeterministic PAs, it is not for general PAs; interestingly, we prove that it\ndoes characterise weaker notions, called a priori epsilon-(bi)simulation, which\nwe prove to be NP-difficult to decide.\n", "versions": [{"version": "v1", "created": "Wed, 6 Jul 2011 17:55:31 GMT"}], "update_date": "2011-07-07", "authors_parsed": [["Tracol", "Mathieu", "", "IST Austria"], ["Desharnais", "Jos\u00e9e", "", "Departement\n  d'informatique et de g\u00e9nie logiciel, Universit\u00e9 Laval, Qu\u00e9bec, Canada"], ["Zhioua", "Abir", "", "Departement d'informatique et de g\u00e9nie logiciel, Universit\u00e9\n  Laval, Qu\u00e9bec, Canada"]]}, {"id": "1107.1233", "submitter": "EPTCS", "authors": "Luca Bortolussi, Vashti Galpin, Jane Hillston", "title": "HYPE with stochastic events", "comments": "In Proceedings QAPL 2011, arXiv:1107.0746", "journal-ref": "EPTCS 57, 2011, pp. 120-133", "doi": "10.4204/EPTCS.57.9", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The process algebra HYPE was recently proposed as a fine-grained modelling\napproach for capturing the behaviour of hybrid systems. In the original\nproposal, each flow or influence affecting a variable is modelled separately\nand the overall behaviour of the system then emerges as the composition of\nthese flows. The discrete behaviour of the system is captured by instantaneous\nactions which might be urgent, taking effect as soon as some activation\ncondition is satisfied, or non-urgent meaning that they can tolerate some\n(unknown) delay before happening. In this paper we refine the notion of\nnon-urgent actions, to make such actions governed by a probability\ndistribution. As a consequence of this we now give HYPE a semantics in terms of\nTransition-Driven Stochastic Hybrid Automata, which are a subset of a general\nclass of stochastic processes termed Piecewise Deterministic Markov Processes.\n", "versions": [{"version": "v1", "created": "Wed, 6 Jul 2011 17:55:18 GMT"}], "update_date": "2011-07-08", "authors_parsed": [["Bortolussi", "Luca", ""], ["Galpin", "Vashti", ""], ["Hillston", "Jane", ""]]}, {"id": "1107.1327", "submitter": "Pierre Lescanne", "authors": "Pierre Lescanne (LIP)", "title": "On counting untyped lambda terms", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present several results on counting untyped lambda terms, i.e., on telling\nhow many terms belong to such or such class, according to the size of the terms\nand/or to the number of free variables.\n", "versions": [{"version": "v1", "created": "Thu, 7 Jul 2011 09:40:58 GMT"}, {"version": "v2", "created": "Mon, 8 Aug 2011 16:37:11 GMT"}, {"version": "v3", "created": "Fri, 30 Sep 2011 10:24:29 GMT"}, {"version": "v4", "created": "Thu, 20 Oct 2011 19:40:15 GMT"}, {"version": "v5", "created": "Thu, 16 Feb 2012 14:45:49 GMT"}], "update_date": "2012-02-17", "authors_parsed": [["Lescanne", "Pierre", "", "LIP"]]}, {"id": "1107.1351", "submitter": "Marina Lenisa", "authors": "Furio Honsell (Dipartimento di Matematica e Informatica), Marina\n  Lenisa (Dipartimento di Matematica e Informatica)", "title": "Conway games, algebraically and coalgebraically", "comments": "30 pages", "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (September\n  1, 2011) lmcs:703", "doi": "10.2168/LMCS-7(3:8)2011", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Using coalgebraic methods, we extend Conway's theory of games to possibly\nnon-terminating, i.e. non-wellfounded games (hypergames). We take the view that\na play which goes on forever is a draw, and hence rather than focussing on\nwinning strategies, we focus on non-losing strategies. Hypergames are a\nfruitful metaphor for non-terminating processes, Conway's sum being similar to\nshuffling. We develop a theory of hypergames, which extends in a non-trivial\nway Conway's theory; in particular, we generalize Conway's results on game\ndeterminacy and characterization of strategies. Hypergames have a rather\ninteresting theory, already in the case of impartial hypergames, for which we\ngive a compositional semantics, in terms of a generalized Grundy-Sprague\nfunction and a system of generalized Nim games. Equivalences and congruences on\ngames and hypergames are discussed. We indicate a number of intriguing\ndirections for future work. We briefly compare hypergames with other notions of\ngames used in computer science.\n", "versions": [{"version": "v1", "created": "Thu, 7 Jul 2011 11:34:51 GMT"}, {"version": "v2", "created": "Wed, 31 Aug 2011 07:39:57 GMT"}, {"version": "v3", "created": "Thu, 1 Sep 2011 07:28:42 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Honsell", "Furio", "", "Dipartimento di Matematica e Informatica"], ["Lenisa", "Marina", "", "Dipartimento di Matematica e Informatica"]]}, {"id": "1107.1383", "submitter": "Chih-Hong Cheng", "authors": "Chih-Hong Cheng, Saddek Bensalem, Yu-Fang Chen, Rongjie Yan, Barbara\n  Jobstmann, Harald Ruess, Christian Buckl, Alois Knoll", "title": "Algorithms for Synthesizing Priorities in Component-based Systems", "comments": "Full version of the ATVA'11 paper (compared to the 1st arXiv version,\n  we add one additional sentence to avoid confusion)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present algorithms to synthesize component-based systems that are safe and\ndeadlock-free using priorities, which define stateless-precedence between\nenabled actions. Our core method combines the concept of fault-localization\n(using safety-game) and fault-repair (using SAT for conflict resolution). For\ncomplex systems, we propose three complementary methods as preprocessing steps\nfor priority synthesis, namely (a) data abstraction to reduce component\ncomplexities, (b) alphabet abstraction and #-deadlock to ignore components, and\n(c) automated assumption learning for compositional priority synthesis.\n", "versions": [{"version": "v1", "created": "Wed, 6 Jul 2011 08:36:07 GMT"}, {"version": "v2", "created": "Fri, 7 Oct 2011 12:19:16 GMT"}], "update_date": "2011-10-10", "authors_parsed": [["Cheng", "Chih-Hong", ""], ["Bensalem", "Saddek", ""], ["Chen", "Yu-Fang", ""], ["Yan", "Rongjie", ""], ["Jobstmann", "Barbara", ""], ["Ruess", "Harald", ""], ["Buckl", "Christian", ""], ["Knoll", "Alois", ""]]}, {"id": "1107.1456", "submitter": "Andre Hernich", "authors": "Andre Hernich (Humboldt-Universit\\\"at zu Berlin)", "title": "Answering Non-Monotonic Queries in Relational Data Exchange", "comments": "55 pages, 3 figures", "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (September\n  1, 2011) lmcs:904", "doi": "10.2168/LMCS-7(3:9)2011", "report-no": null, "categories": "cs.DB cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Relational data exchange is the problem of translating relational data from a\nsource schema into a target schema, according to a specification of the\nrelationship between the source data and the target data. One of the basic\nissues is how to answer queries that are posed against target data. While\nconsensus has been reached on the definitive semantics for monotonic queries,\nthis issue turned out to be considerably more difficult for non-monotonic\nqueries. Several semantics for non-monotonic queries have been proposed in the\npast few years. This article proposes a new semantics for non-monotonic\nqueries, called the GCWA*-semantics. It is inspired by semantics from the area\nof deductive databases. We show that the GCWA*-semantics coincides with the\nstandard open world semantics on monotonic queries, and we further explore the\n(data) complexity of evaluating non-monotonic queries under the\nGCWA*-semantics. In particular, we introduce a class of schema mappings for\nwhich universal queries can be evaluated under the GCWA*-semantics in\npolynomial time (data complexity) on the core of the universal solutions.\n", "versions": [{"version": "v1", "created": "Thu, 7 Jul 2011 17:08:44 GMT"}, {"version": "v2", "created": "Wed, 31 Aug 2011 09:14:51 GMT"}, {"version": "v3", "created": "Thu, 1 Sep 2011 07:37:48 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Hernich", "Andre", "", "Humboldt-Universit\u00e4t zu Berlin"]]}, {"id": "1107.1901", "submitter": "Ruy de Queiroz", "authors": "Ruy J.G.B. de Queiroz and Anjolina G. de Oliveira", "title": "Propositional equality, identity types, and direct computational paths", "comments": "41 pages, submitted to a scientific journal. arXiv admin note: text\n  overlap with arXiv:1010.1810, arXiv:0906.4521 by other authors", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In proof theory the notion of canonical proof is rather basic, and it is\nusually taken for granted that a canonical proof of a sentence must be unique\nup to certain minor syntactical details (such as, e.g., change of bound\nvariables). When setting up a proof theory for equality one is faced with a\nrather unexpected situation where there may not be a unique canonical proof of\nan equality statement. Indeed, in a (1994--5) proposal for the formalisation of\nproofs of propositional equality in the Curry--Howard style, we have already\nuncovered such a peculiarity. Totally independently, and in a different\nsetting, Hofmann & Streicher (1994) have shown how to build a model of\nMartin-L\\\"of's Type Theory in which uniqueness of canonical proofs of identity\ntypes does not hold. The intention here is to show that, by considering as\nsequences of rewrites and substitution, it comes a rather natural fact that two\n(or more) distinct proofs may be yet canonical and are none to be preferred\nover one another. By looking at proofs of equality as rewriting (or\ncomputational) paths this approach will be in line with the recently proposed\nconnections between type theory and homotopy theory via identity types, since\nelements of identity types will be, concretely, paths (or homotopies).\n", "versions": [{"version": "v1", "created": "Sun, 10 Jul 2011 21:28:26 GMT"}, {"version": "v2", "created": "Thu, 1 Mar 2012 13:27:15 GMT"}, {"version": "v3", "created": "Mon, 5 Aug 2013 20:26:40 GMT"}], "update_date": "2013-08-07", "authors_parsed": [["de Queiroz", "Ruy J. G. B.", ""], ["de Oliveira", "Anjolina G.", ""]]}, {"id": "1107.1999", "submitter": "Bertrand Meyer", "authors": "Bertrand Meyer", "title": "Towards a Calculus of Object Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Verifying properties of object-oriented software requires a method for\nhandling references in a simple and intuitive way, closely related to how O-O\nprogrammers reason about their programs. The method presented here, a Calculus\nof Object Programs, combines four components: compositional logic, a framework\nfor describing program semantics and proving program properties; negative\nvariables to address the specifics of O-O programming, in particular qualified\ncalls; the alias calculus, which determines whether reference expressions can\never have the same value; and the calculus of object structures, a\nspecification technique for the structures that arise during the execution of\nan object-oriented program. The article illustrates the Calculus by proving the\nstandard algorithm for reversing a linked list.\n", "versions": [{"version": "v1", "created": "Mon, 11 Jul 2011 11:18:21 GMT"}, {"version": "v2", "created": "Sun, 17 Jul 2011 07:37:24 GMT"}], "update_date": "2011-07-19", "authors_parsed": [["Meyer", "Bertrand", ""]]}, {"id": "1107.2284", "submitter": "Wenyan Xu", "authors": "Wenyan Xu and Sanyang Liu", "title": "The parallel versus branching recurrences in computability logic", "comments": "14 pages", "journal-ref": "Notre Dame J. Formal Logic 54, no. 1 (2013), 61-78", "doi": "10.1215/00294527-1731389", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper shows that the basic logic induced by the parallel recurrence of\nComputability Logic is a proper superset of the basic logic induced by the\nbranching recurrence. The latter is known to be precisely captured by the\ncirquent calculus system CL15, conjectured by Japaridze to remain sound---but\nnot complete---with parallel recurrence instead of branching recurrence. The\npresent result is obtained by positively verifying that conjecture. A secondary\nresult of the paper is showing that parallel recurrence is strictly weaker than\nbranching recurrence in the sense that, while the latter logically implies the\nformer, vice versa does not hold.\n", "versions": [{"version": "v1", "created": "Tue, 12 Jul 2011 13:34:50 GMT"}], "update_date": "2016-02-10", "authors_parsed": [["Xu", "Wenyan", ""], ["Liu", "Sanyang", ""]]}, {"id": "1107.2513", "submitter": "Apostolos Syropoulos", "authors": "Apostolos Syropoulos and Valeria de Paiva", "title": "Fuzzy Topological Systems", "comments": "This paper was read at the 8th Panhellenic Logic Symposium, July 4-8,\n  2011, Ioannina, Greece", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dialectica categories are a very versatile categorical model of linear logic.\nThese have been used to model many seemingly different things (e.g., Petri nets\nand Lambek's calculus). In this note, we expand our previous work on fuzzy\npetri nets to deal with fuzzy topological systems. One basic idea is to use as\nthe dualizing object in the Dialectica categories construction, the unit real\ninterval [0,1], which has all the properties of a {\\em lineale}. The second\nbasic idea is to generalize Vickers's notion of a topological system.\n", "versions": [{"version": "v1", "created": "Wed, 13 Jul 2011 10:25:14 GMT"}], "update_date": "2011-07-14", "authors_parsed": [["Syropoulos", "Apostolos", ""], ["de Paiva", "Valeria", ""]]}, {"id": "1107.2822", "submitter": "Baris Sertkaya", "authors": "Baris Sertkaya", "title": "A Survey on how Description Logic Ontologies Benefit from Formal Concept\n  Analysis", "comments": "Invited paper that appeared in the Proceedings of the 7th\n  International Conference on Concept Lattices and Their Applications, (CLA\n  2010)", "journal-ref": "Proceedings of the 7th International Conference on Concept\n  Lattices and Their Applications, (CLA 2010), volume 672 of CEUR Workshop\n  Proceedings, pages 2-21. 2010", "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Although the notion of a concept as a collection of objects sharing certain\nproperties, and the notion of a conceptual hierarchy are fundamental to both\nFormal Concept Analysis and Description Logics, the ways concepts are described\nand obtained differ significantly between these two research areas. Despite\nthese differences, there have been several attempts to bridge the gap between\nthese two formalisms, and attempts to apply methods from one field in the\nother. The present work aims to give an overview on the research done in\ncombining Description Logics and Formal Concept Analysis.\n", "versions": [{"version": "v1", "created": "Thu, 14 Jul 2011 13:48:45 GMT"}], "update_date": "2011-07-15", "authors_parsed": [["Sertkaya", "Baris", ""]]}, {"id": "1107.3031", "submitter": "Marcelo Fiore", "authors": "Marcelo Fiore (University of Cambridge, Computer Laboratory),\n  Chung-Kil Hur (Universite Paris Diderot - Paris 7, Laboratoire PPS)", "title": "On the mathematical synthesis of equational logics", "comments": "Final version for publication in Logical Methods in Computer Science", "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (September\n  8, 2011) lmcs:1071", "doi": "10.2168/LMCS-7(3:12)2011", "report-no": null, "categories": "cs.LO math.CT math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide a mathematical theory and methodology for synthesising equational\nlogics from algebraic metatheories. We illustrate our methodology by means of\ntwo applications: a rational reconstruction of Birkhoff's Equational Logic and\na new equational logic for reasoning about algebraic structure with\nname-binding operators.\n", "versions": [{"version": "v1", "created": "Fri, 15 Jul 2011 10:04:12 GMT"}, {"version": "v2", "created": "Wed, 27 Jul 2011 12:56:07 GMT"}, {"version": "v3", "created": "Wed, 7 Sep 2011 08:43:53 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Fiore", "Marcelo", "", "University of Cambridge, Computer Laboratory"], ["Hur", "Chung-Kil", "", "Universite Paris Diderot - Paris 7, Laboratoire PPS"]]}, {"id": "1107.3127", "submitter": "Ramamohan Paturi", "authors": "Russell Impagliazzo, William Matthews, Ramamohan Paturi", "title": "A Satisfiability Algorithm for AC$^0$", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the problem of efficiently enumerating the satisfying assignments\nto $\\AC^0$ circuits. We give a zero-error randomized algorithm which takes an\n$\\AC^0$ circuit as input and constructs a set of restrictions which partition\n$\\{0,1\\}^n$ so that under each restriction the value of the circuit is\nconstant. Let $d$ denote the depth of the circuit and $cn$ denote the number of\ngates. This algorithm runs in time $|C| 2^{n(1-\\mu_{c.d})}$ where $|C|$ is the\nsize of the circuit for $\\mu_{c,d} \\ge 1/\\bigO[\\lg c + d \\lg d]^{d-1}$ with\nprobability at least $1-2^{-n}$.\n  As a result, we get improved exponential time algorithms for $\\AC^0$ circuit\nsatisfiability and for counting solutions. In addition, we get an improved\nbound on the correlation of $\\AC^0$ circuits with parity.\n  As an important component of our analysis, we extend the H{\\aa}stad Switching\nLemma to handle multiple $\\kcnf$s and $\\kdnf$s.\n", "versions": [{"version": "v1", "created": "Fri, 15 Jul 2011 18:37:49 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Impagliazzo", "Russell", ""], ["Matthews", "William", ""], ["Paturi", "Ramamohan", ""]]}, {"id": "1107.3430", "submitter": "Kord Eickmeyer", "authors": "Kord Eickmeyer (Humboldt-Universit\\\"at Berlin), Martin Grohe\n  (Humboldt-Universit\\\"at Berlin)", "title": "Randomisation and Derandomisation in Descriptive Complexity Theory", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (September\n  21, 2011) lmcs:714", "doi": "10.2168/LMCS-7(3:14)2011", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study probabilistic complexity classes and questions of derandomisation\nfrom a logical point of view. For each logic L we introduce a new logic BPL,\nbounded error probabilistic L, which is defined from L in a similar way as the\ncomplexity class BPP, bounded error probabilistic polynomial time, is defined\nfrom PTIME. Our main focus lies on questions of derandomisation, and we prove\nthat there is a query which is definable in BPFO, the probabilistic version of\nfirst-order logic, but not in Cinf, finite variable infinitary logic with\ncounting. This implies that many of the standard logics of finite model theory,\nlike transitive closure logic and fixed-point logic, both with and without\ncounting, cannot be derandomised. Similarly, we present a query on ordered\nstructures which is definable in BPFO but not in monadic second-order logic,\nand a query on additive structures which is definable in BPFO but not in FO.\nThe latter of these queries shows that certain uniform variants of AC0\n(bounded-depth polynomial sized circuits) cannot be derandomised. These results\nare in contrast to the general belief that most standard complexity classes can\nbe derandomised. Finally, we note that BPIFP+C, the probabilistic version of\nfixed-point logic with counting, captures the complexity class BPP, even on\nunordered structures.\n", "versions": [{"version": "v1", "created": "Mon, 18 Jul 2011 13:26:45 GMT"}, {"version": "v2", "created": "Tue, 20 Sep 2011 15:13:58 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Eickmeyer", "Kord", "", "Humboldt-Universit\u00e4t Berlin"], ["Grohe", "Martin", "", "Humboldt-Universit\u00e4t Berlin"]]}, {"id": "1107.3706", "submitter": "Wenyan Xu", "authors": "Wenyan Xu and Sanyang Liu", "title": "The countable versus uncountable branching recurrences in computability\n  logic", "comments": "20 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces a new simplified version of the countable branching\nrecurrence of Computability Logic, proves its equivalence to the old one, and\nshows that the basic logic induced by it is a proper superset of the basic\nlogic induced by the uncountable branching recurrence. A further result of this\npaper is showing that the countable branching recurrence is strictly weaker\nthan the uncountable branching recurrence in the sense that the latter\nlogically implies the former but not vice versa.\n", "versions": [{"version": "v1", "created": "Tue, 19 Jul 2011 13:01:16 GMT"}], "update_date": "2011-07-20", "authors_parsed": [["Xu", "Wenyan", ""], ["Liu", "Sanyang", ""]]}, {"id": "1107.4138", "submitter": "Gilles Geeraerts", "authors": "Gilles Geeraerts and Jean-Fran\\c{c}ois Raskin and Nathalie Sznajder", "title": "Event-Clock Automata: From Theory to Practice", "comments": "Full version of the FORMATS 2011 version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Event clock automata (ECA) are a model for timed languages that has been\nintroduced by Alur, Fix and Henzinger as an alternative to timed automata, with\nbetter theoretical properties (for instance, ECA are determinizable while timed\nautomata are not). In this paper, we revisit and extend the theory of ECA. We\nfirst prove that no finite time abstract language equivalence exists for ECA,\nthereby disproving a claim in the original work on ECA. This means in\nparticular that regions do not form a time abstract bisimulation. Nevertheless,\nwe show that regions can still be used to build a finite automaton recognizing\nthe untimed language of an ECA. Then, we extend the classical notions of zones\nand DBMs to let them handle event clocks instead of plain clocks (as in timed\nautomata) by introducing event zones and Event DBMs (EDBMs). We discuss\nalgorithms to handle event zones represented as EDBMs, as well as (semi-)\nalgorithms based on EDBMs to decide language emptiness of ECA.\n", "versions": [{"version": "v1", "created": "Wed, 20 Jul 2011 23:09:47 GMT"}, {"version": "v2", "created": "Fri, 22 Jul 2011 20:08:52 GMT"}], "update_date": "2011-07-26", "authors_parsed": [["Geeraerts", "Gilles", ""], ["Raskin", "Jean-Fran\u00e7ois", ""], ["Sznajder", "Nathalie", ""]]}, {"id": "1107.4160", "submitter": "Emmanuel Beffara", "authors": "Emmanuel Beffara (IML)", "title": "Functions as proofs as processes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a logical approach to the translation of functional\ncalculi into concurrent process calculi. The starting point is a type system\nfor the {\\pi}-calculus closely related to linear logic. Decompositions of\nintuitionistic and classical logics into this system provide type-preserving\ntranslations of the \\lambda- and \\lambda\\mu-calculus, both for call-by-name and\ncall-by-value evaluation strategies. Previously known encodings of the\n\\lam-calculus are shown to correspond to particular cases of this logical\nembedding. The realisability interpretation of types in the \\pi-calculus\nprovides systematic soundness arguments for these translations and allows for\nthe definition of type-safe extensions of functional calculi.\n", "versions": [{"version": "v1", "created": "Thu, 21 Jul 2011 05:06:48 GMT"}], "update_date": "2011-07-22", "authors_parsed": [["Beffara", "Emmanuel", "", "IML"]]}, {"id": "1107.4212", "submitter": "Umberto Straccia", "authors": "Marco Cerami and Umberto Straccia", "title": "On the Undecidability of Fuzzy Description Logics with GCIs with\n  Lukasiewicz t-norm", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recently there have been some unexpected results concerning Fuzzy Description\nLogics (FDLs) with General Concept Inclusions (GCIs). They show that, unlike\nthe classical case, the DL ALC with GCIs does not have the finite model\nproperty under Lukasiewicz Logic or Product Logic and, specifically, knowledge\nbase satisfiability is an undecidable problem for Product Logic. We complete\nhere the analysis by showing that knowledge base satisfiability is also an\nundecidable problem for Lukasiewicz Logic.\n", "versions": [{"version": "v1", "created": "Thu, 21 Jul 2011 09:38:11 GMT"}, {"version": "v2", "created": "Mon, 25 Jul 2011 13:35:28 GMT"}, {"version": "v3", "created": "Wed, 27 Jul 2011 15:48:55 GMT"}], "update_date": "2011-07-28", "authors_parsed": [["Cerami", "Marco", ""], ["Straccia", "Umberto", ""]]}, {"id": "1107.4422", "submitter": "G. Ramalingam", "authors": "Jyotirmoy Deshmukh (University of Texas at Austin), G. Ramalingam\n  (Microsoft Research India), Venkatesh-Prasad Ranganath (Microsoft Research\n  India), Kapil Vaswani (Microsoft Research India)", "title": "Logical Concurrency Control from Sequential Proofs", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (September\n  2, 2011) lmcs:986", "doi": "10.2168/LMCS-7(3:10)2011", "report-no": null, "categories": "cs.PL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We are interested in identifying and enforcing the isolation requirements of\na concurrent program, i.e., concurrency control that ensures that the program\nmeets its specification. The thesis of this paper is that this can be done\nsystematically starting from a sequential proof, i.e., a proof of correctness\nof the program in the absence of concurrent interleavings. We illustrate our\nthesis by presenting a solution to the problem of making a sequential library\nthread-safe for concurrent clients. We consider a sequential library annotated\nwith assertions along with a proof that these assertions hold in a sequential\nexecution. We show how we can use the proof to derive concurrency control that\nensures that any execution of the library methods, when invoked by concurrent\nclients, satisfies the same assertions. We also present an extension to\nguarantee that the library methods are linearizable or atomic.\n", "versions": [{"version": "v1", "created": "Fri, 22 Jul 2011 06:10:34 GMT"}, {"version": "v2", "created": "Thu, 1 Sep 2011 07:24:16 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Deshmukh", "Jyotirmoy", "", "University of Texas at Austin"], ["Ramalingam", "G.", "", "Microsoft Research India"], ["Ranganath", "Venkatesh-Prasad", "", "Microsoft Research\n  India"], ["Vaswani", "Kapil", "", "Microsoft Research India"]]}, {"id": "1107.4478", "submitter": "Ugo Dal Lago", "authors": "Ugo Dal Lago and Paolo Di Giamberardino", "title": "Soft Session Types (Long Version)", "comments": "24 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show how systems of sessions types can enforce interactions to be bounded\nfor all typable processes. The type system we propose is based on Lafont's soft\nlinear logic and is strongly inspired by recent works about session types as\nintuitionistic linear logic formulas. Our main result is the existence, for\nevery typable process, of a polynomial bound on the length of any reduction\nsequence starting from it and on the size of any of its reducts.\n", "versions": [{"version": "v1", "created": "Fri, 22 Jul 2011 10:57:08 GMT"}, {"version": "v2", "created": "Mon, 29 Aug 2011 14:38:27 GMT"}, {"version": "v3", "created": "Tue, 3 Jan 2012 09:20:22 GMT"}], "update_date": "2012-01-04", "authors_parsed": [["Lago", "Ugo Dal", ""], ["Di Giamberardino", "Paolo", ""]]}, {"id": "1107.4651", "submitter": "Nittaya Kerdprasop Prof.", "authors": "Nittaya Kerdprasop and Kittisak Kerdprasop", "title": "Higher Order Programming to Mine Knowledge for a Modern Medical Expert\n  System", "comments": "9 pages", "journal-ref": "IJCSI International Journal of Computer Science Issues, Vol. 8,\n  Issue 3, May 2011 ISSN (Online): 1694-0814 www.IJCSI.org", "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Knowledge mining is the process of deriving new and useful knowledge from\nvast volumes of data and background knowledge. Modern healthcare organizations\nregularly generate huge amount of electronic data stored in the databases.\nThese data are a valuable resource for mining useful knowledge to help medical\npractitioners making appropriate and accurate decision on the diagnosis and\ntreatment of diseases. In this paper, we propose the design of a novel medical\nexpert system based on a logic-programming framework. The proposed system\nincludes a knowledge-mining component as a repertoire of tools for discovering\nuseful knowledge. The implementation of classification and association mining\ntools based on the higher order and meta-level programming schemes using Prolog\nhas been presented to express the power of logic-based language. Such language\nalso provides a pattern matching facility, which is an essential function for\nthe development of knowledge-intensive tasks. Besides the major goal of medical\ndecision support, the knowledge discovered by our logic-based knowledge-mining\ncomponent can also be deployed as background knowledge to pre-treatment data\nfrom other sources as well as to guard the data repositories against constraint\nviolation. A framework for knowledge deployment is also presented.\n", "versions": [{"version": "v1", "created": "Sat, 23 Jul 2011 03:04:22 GMT"}], "update_date": "2011-07-26", "authors_parsed": [["Kerdprasop", "Nittaya", ""], ["Kerdprasop", "Kittisak", ""]]}, {"id": "1107.4747", "submitter": "Fabrizio Riguzzi PhD", "authors": "Fabrizio Riguzzi and Terrance Swift", "title": "The PITA System: Tabling and Answer Subsumption for Reasoning under\n  Uncertainty", "comments": null, "journal-ref": "Theory and Practice of Logic Programming, 27th International\n  Conference on Logic Programming (ICLP'11) Special Issue, 11(4-5), 433-449,\n  2011", "doi": "10.1017/S147106841100010X", "report-no": null, "categories": "cs.AI cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many real world domains require the representation of a measure of\nuncertainty. The most common such representation is probability, and the\ncombination of probability with logic programs has given rise to the field of\nProbabilistic Logic Programming (PLP), leading to languages such as the\nIndependent Choice Logic, Logic Programs with Annotated Disjunctions (LPADs),\nProblog, PRISM and others. These languages share a similar distribution\nsemantics, and methods have been devised to translate programs between these\nlanguages. The complexity of computing the probability of queries to these\ngeneral PLP programs is very high due to the need to combine the probabilities\nof explanations that may not be exclusive. As one alternative, the PRISM system\nreduces the complexity of query answering by restricting the form of programs\nit can evaluate. As an entirely different alternative, Possibilistic Logic\nPrograms adopt a simpler metric of uncertainty than probability. Each of these\napproaches -- general PLP, restricted PLP, and Possibilistic Logic Programming\n-- can be useful in different domains depending on the form of uncertainty to\nbe represented, on the form of programs needed to model problems, and on the\nscale of the problems to be solved. In this paper, we show how the PITA system,\nwhich originally supported the general PLP language of LPADs, can also\nefficiently support restricted PLP and Possibilistic Logic Programs. PITA\nrelies on tabling with answer subsumption and consists of a transformation\nalong with an API for library functions that interface with answer subsumption.\n", "versions": [{"version": "v1", "created": "Sun, 24 Jul 2011 11:22:41 GMT"}], "update_date": "2011-07-26", "authors_parsed": [["Riguzzi", "Fabrizio", ""], ["Swift", "Terrance", ""]]}, {"id": "1107.4751", "submitter": "Benedikt Ahrens", "authors": "Benedikt Ahrens (University of Nice Sophia-Antipolis)", "title": "Extended Initiality for Typed Abstract Syntax", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 2 (April 6,\n  2012) lmcs:1193", "doi": "10.2168/LMCS-8(2:1)2012", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Initial Semantics aims at interpreting the syntax associated to a signature\nas the initial object of some category of 'models', yielding induction and\nrecursion principles for abstract syntax. Zsid\\'o proves an initiality result\nfor simply-typed syntax: given a signature S, the abstract syntax associated to\nS constitutes the initial object in a category of models of S in monads.\nHowever, the iteration principle her theorem provides only accounts for\ntranslations between two languages over a fixed set of object types. We\ngeneralize Zsid\\'o's notion of model such that object types may vary, yielding\na larger category, while preserving initiality of the syntax therein. Thus we\nobtain an extended initiality theorem for typed abstract syntax, in which\ntranslations between terms over different types can be specified via the\nassociated category-theoretic iteration operator as an initial morphism. Our\ndefinitions ensure that translations specified via initiality are type-safe,\ni.e. compatible with the typing in the source and target language in the\nobvious sense. Our main example is given via the propositions-as-types\nparadigm: we specify propositions and inference rules of classical and\nintuitionistic propositional logics through their respective typed signatures.\nAfterwards we use the category--theoretic iteration operator to specify a\ndouble negation translation from the former to the latter. A second example is\ngiven by the signature of PCF. For this particular case, we formalize the\ntheorem in the proof assistant Coq. Afterwards we specify, via the\ncategory-theoretic iteration operator, translations from PCF to the untyped\nlambda calculus.\n", "versions": [{"version": "v1", "created": "Sun, 24 Jul 2011 12:32:49 GMT"}, {"version": "v2", "created": "Wed, 28 Mar 2012 15:38:05 GMT"}, {"version": "v3", "created": "Thu, 5 Apr 2012 07:04:45 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Ahrens", "Benedikt", "", "University of Nice Sophia-Antipolis"]]}, {"id": "1107.4929", "submitter": "Can Ba\\c{s}kent", "authors": "Can Baskent", "title": "Some Non-Classical Approaches to the Branderburger-Keisler Paradox", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  In this paper, we discuss a well-known self-referential paradox in\nfoundational game theory, the Brandenburger - Keisler paradox. We approach the\nparadox from two different perspectives: non-well-founded set theory and\nparaconsistent logic. We show that the paradox persists in both frameworks for\ncategory theoretical reasons, but, with different properties.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jul 2011 12:56:51 GMT"}], "update_date": "2011-07-26", "authors_parsed": [["Baskent", "Can", ""]]}, {"id": "1107.4931", "submitter": "Can Ba\\c{s}kent", "authors": "Can Baskent", "title": "A Logic for Strategy Updates", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  Notion of strategy in game theory is static and presumably constructed before\nthe game play. The static, pre-determined notion of strategies falls short\nanalyzing perfect information games. Because, we, people, do not strategize as\nsuch even in perfect information games - largely because we are not logically\nomniscient, and we have limited computational power and bounded memory. In this\npaper, we focus on what we call move updates where some moves become\nunavailable during the game. Our goal here is to present a formal framework for\nmove based strategy restrictions extending strategy logic which was introduced\nby Ramanujam and Simon. In this paper, we present a dynamic version of strategy\nlogic, prove its completeness and decidability along with the decidability of\nthe strategy logic which was an open problem so far. We also present an\nanalysis of centipede by using our logic.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jul 2011 13:02:43 GMT"}], "update_date": "2011-07-26", "authors_parsed": [["Baskent", "Can", ""]]}, {"id": "1107.4932", "submitter": "Can Ba\\c{s}kent", "authors": "Can Baskent", "title": "Homotopies in Classical and Paraconsistent Modal Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  Topological semantics for modal logics has recently gained new momentum in\nmany different branches of logic. In this paper, we will consider the\ntopological semantics of both classical and paraconsistent modal logics.\n  This work is a new step in the research program that focuses on\nparaconsistent systems from geometric and topological point of view. Here, we\ndiscuss the functional transformations in paraconsistent and classical modal\ncases: how to transform one classical or paraconsistent topological model to\nanother, how to transform one transformation to another in a validity\npreserving way. Furthermore, we also suggest a measure to keep track of such\nchange.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jul 2011 13:06:33 GMT"}], "update_date": "2011-08-19", "authors_parsed": [["Baskent", "Can", ""]]}, {"id": "1107.4935", "submitter": "Can Ba\\c{s}kent", "authors": "Can Baskent", "title": "Public Announcement Logic in Geometric Frameworks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.GT cs.MA", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  In this paper we introduce public announcement logic in different geometric\nframeworks. First, we consider topological models, and then extend our\ndiscussion to a more expressive model, namely, subset space models.\nFurthermore, we prove the completeness of public announcement logic in those\nframeworks. Moreover, we apply our results to different issues: announcement\nstabilization, backward induction and persistence.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jul 2011 13:11:42 GMT"}, {"version": "v2", "created": "Thu, 18 Aug 2011 07:44:19 GMT"}], "update_date": "2011-08-19", "authors_parsed": [["Baskent", "Can", ""]]}, {"id": "1107.4939", "submitter": "Can Ba\\c{s}kent", "authors": "Can Baskent", "title": "Paraconsistency and Topological Semantics", "comments": "arXiv admin note: substantial text overlap with arXiv:1107.4932", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  The well-studied notion of deductive explosion describes the situation where\nany formula can be deduced from an inconsistent set of formulas. Paraconsistent\nlogic, on the other hand, is the umbrella term for logical systems where the\nlogical consequence relation is not explosive. In this work, we investigate the\nrelationship between some different topological spaces and paraconsistency.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jul 2011 13:15:07 GMT"}, {"version": "v2", "created": "Thu, 10 Nov 2011 22:17:02 GMT"}], "update_date": "2011-11-14", "authors_parsed": [["Baskent", "Can", ""]]}, {"id": "1107.4967", "submitter": "Domenico Corapi Domenico Corapi", "authors": "Domenico Corapi, Alessandra Russo, Marina De Vos, Julian Padget, Ken\n  Satoh", "title": "Normative design using inductive learning", "comments": "Theory and Practice of Logic Programming, 27th Int'l. Conference on\n  Logic Programming (ICLP'11) Special Issue, volume 11, issue 4-5, 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we propose a use-case-driven iterative design methodology for\nnormative frameworks, also called virtual institutions, which are used to\ngovern open systems. Our computational model represents the normative framework\nas a logic program under answer set semantics (ASP). By means of an inductive\nlogic programming approach, implemented using ASP, it is possible to synthesise\nnew rules and revise the existing ones. The learning mechanism is guided by the\ndesigner who describes the desired properties of the framework through use\ncases, comprising (i) event traces that capture possible scenarios, and (ii) a\nstate that describes the desired outcome. The learning process then proposes\nadditional rules, or changes to current rules, to satisfy the constraints\nexpressed in the use cases. Thus, the contribution of this paper is a process\nfor the elaboration and revision of a normative framework by means of a\nsemi-automatic and iterative process driven from specifications of\n(un)desirable behaviour. The process integrates a novel and general methodology\nfor theory revision based on ASP.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jul 2011 15:01:50 GMT"}], "update_date": "2011-07-26", "authors_parsed": [["Corapi", "Domenico", ""], ["Russo", "Alessandra", ""], ["De Vos", "Marina", ""], ["Padget", "Julian", ""], ["Satoh", "Ken", ""]]}, {"id": "1107.5030", "submitter": "Miguel Areias", "authors": "Miguel Areias and Ricardo Rocha", "title": "On Combining Linear-Based Strategies for Tabled Evaluation of Logic\n  Programs", "comments": "16 pages, 9 figures, International Conference on Logic Programming\n  (ICLP 2011)", "journal-ref": "Theory and Practice of Logic Programming, Volume 11, Special Issue\n  4-5, July 2011, pp 681-696 Published Cambridge University Press 2011", "doi": "10.1017/S147106841100024X", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Tabled evaluation is a recognized and powerful technique that overcomes some\nlimitations of traditional Prolog systems in dealing with recursion and\nredundant sub-computations. We can distinguish two main categories of tabling\nmechanisms: suspension-based tabling and linear tabling. While suspension-based\nmechanisms are considered to obtain better results in general, they have more\nmemory space requirements and are more complex and harder to implement than\nlinear tabling mechanisms. Arguably, the SLDT and DRA strategies are the two\nmost successful extensions to standard linear tabled evaluation. In this work,\nwe propose a new strategy, named DRS, and we present a framework, on top of the\nYap system, that supports the combination of all these three strategies. Our\nimplementation shares the underlying execution environment and most of the data\nstructures used to implement tabling in Yap. We thus argue that all these\ncommon features allows us to make a first and fair comparison between these\ndifferent linear tabling strategies and, therefore, better understand the\nadvantages and weaknesses of each, when used solely or combined with the\nothers.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jul 2011 19:44:27 GMT"}, {"version": "v2", "created": "Tue, 26 Jul 2011 10:12:46 GMT"}], "update_date": "2011-07-27", "authors_parsed": [["Areias", "Miguel", ""], ["Rocha", "Ricardo", ""]]}, {"id": "1107.5142", "submitter": "Alexei Lisitsa", "authors": "Alexei Lisitsa", "title": "Finite countermodels for safety verification of parameterized tree\n  systems", "comments": "18 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we deal with verification of safety properties of parameterized\nsystems with a tree topology. The verification problem is translated to a\npurely logical problem of finding a finite countermodel for a first-order\nformula, which further resolved by a generic finite model finding procedure. A\nfinite countermodel method is shown is at least as powerful as regular tree\nmodel checking and as the methods based on monotonic abstraction and backwards\nsymbolic reachability. The practical efficiency of the method is illustrated on\na set of examples taken from the literature.\n", "versions": [{"version": "v1", "created": "Tue, 26 Jul 2011 09:25:35 GMT"}], "update_date": "2011-07-27", "authors_parsed": [["Lisitsa", "Alexei", ""]]}, {"id": "1107.5152", "submitter": "Bernd Gutmann", "authors": "Bernd Gutmann, Ingo Thon, Angelika Kimmig, Maurice Bruynooghe, Luc De\n  Raedt", "title": "The Magic of Logical Inference in Probabilistic Programming", "comments": "17 pages, 2 figures, International Conference on Logic Programming\n  (ICLP 2011)", "journal-ref": "Theory and Practice of Logic Programming, Volume 11, Special Issue\n  4-5, July 2011, pp 663-680. Cambridge University Press 2011", "doi": "10.1017/S1471068411000238", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Today, many different probabilistic programming languages exist and even more\ninference mechanisms for these languages. Still, most logic programming based\nlanguages use backward reasoning based on SLD resolution for inference. While\nthese methods are typically computationally efficient, they often can neither\nhandle infinite and/or continuous distributions, nor evidence. To overcome\nthese limitations, we introduce distributional clauses, a variation and\nextension of Sato's distribution semantics. We also contribute a novel\napproximate inference method that integrates forward reasoning with importance\nsampling, a well-known technique for probabilistic inference. To achieve\nefficiency, we integrate two logic programming techniques to direct forward\nsampling. Magic sets are used to focus on relevant parts of the program, while\nthe integration of backward reasoning allows one to identify and avoid regions\nof the sample space that are inconsistent with the evidence.\n", "versions": [{"version": "v1", "created": "Tue, 26 Jul 2011 09:58:08 GMT"}], "update_date": "2011-07-27", "authors_parsed": [["Gutmann", "Bernd", ""], ["Thon", "Ingo", ""], ["Kimmig", "Angelika", ""], ["Bruynooghe", "Maurice", ""], ["De Raedt", "Luc", ""]]}, {"id": "1107.5242", "submitter": "Conrad Drescher", "authors": "Conrad Drescher and Michael Thielscher", "title": "ALPprolog --- A New Logic Programming Method for Dynamic Domains", "comments": "16 pages", "journal-ref": "Theory and Practice of Logic Programming, 11(4-5), 451-468, 2011", "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logic programming is a powerful paradigm for programming autonomous agents in\ndynamic domains, as witnessed by languages such as Golog and Flux. In this work\nwe present ALPprolog, an expressive, yet efficient, logic programming language\nfor the online control of agents that have to reason about incomplete\ninformation and sensing actions.\n", "versions": [{"version": "v1", "created": "Tue, 26 Jul 2011 15:28:13 GMT"}], "update_date": "2011-07-27", "authors_parsed": [["Drescher", "Conrad", ""], ["Thielscher", "Michael", ""]]}, {"id": "1107.5252", "submitter": "Benedikt Ahrens", "authors": "Benedikt Ahrens", "title": "Modules over relative monads for syntax and semantics", "comments": "v2: - Abstract and Introduction completely rewritten - Addition of\n  examples and remarks in Secs. 1 and 2 - Sec 3 now describes the\n  implementation in proof assistant Coq of the main theorem v3: - final version\n  for publication in MSCS", "journal-ref": "Math. Struct. Comp. Sci. 26 (2016) 3-37", "doi": "10.1017/S0960129514000103", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give an algebraic characterization of the syntax and semantics of a class\nof languages with variable binding.\n  We introduce a notion of 2-signature: such a signature specifies not only the\nterms of a language, but also reduction rules on those terms. To any\n2-signature $S$ we associate a category of \"models\" of $S$. This category has\nan initial object, which integrates the terms freely generated by $S$, and\nwhich is equipped with reductions according to the inequations given in $S$. We\ncall this initial object the language generated by $S$. Models of a\n2--signature are built from relative monads and modules over such monads.\nThrough the use of monads, the models---and in particular, the initial\nmodel---come equipped with a substitution operation that is compatible with\nreduction in a suitable sense.\n  The initiality theorem is formalized in the proof assistant Coq, yielding a\nmachinery which, when fed with a 2-signature, provides the associated\nprogramming language with reduction relation and certified substitution.\n", "versions": [{"version": "v1", "created": "Tue, 26 Jul 2011 16:06:20 GMT"}, {"version": "v2", "created": "Sun, 6 Nov 2011 23:42:30 GMT"}, {"version": "v3", "created": "Tue, 19 Nov 2013 01:03:24 GMT"}], "update_date": "2019-02-20", "authors_parsed": [["Ahrens", "Benedikt", ""]]}, {"id": "1107.5722", "submitter": "Daniel Hirschkoff", "authors": "Ioana Cristescu (LIP), Daniel Hirschkoff (LIP)", "title": "Termination in a Pi-calculus with Subtyping", "comments": null, "journal-ref": "18th International Workshop on Expressiveness in Concurrency,\n  Aachen : Germany (2011)", "doi": "10.4204/EPTCS.64.4", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a type system to guarantee termination of pi-calculus processes\nthat exploits input/output capabilities and subtyping, as originally introduced\nby Pierce and Sangiorgi, in order to analyse the usage of channels. We show\nthat our system improves over previously existing proposals by accepting more\nprocesses as terminating. This increased expressiveness allows us to capture\nsensible programming idioms. We demonstrate how our system can be extended to\nhandle the encoding of the simply typed lambda-calculus, and discuss questions\nrelated to type inference.\n", "versions": [{"version": "v1", "created": "Thu, 28 Jul 2011 14:03:05 GMT"}, {"version": "v2", "created": "Thu, 25 Aug 2011 09:35:56 GMT"}, {"version": "v3", "created": "Fri, 26 Aug 2011 09:17:32 GMT"}], "update_date": "2011-08-29", "authors_parsed": [["Cristescu", "Ioana", "", "LIP"], ["Hirschkoff", "Daniel", "", "LIP"]]}, {"id": "1107.5742", "submitter": "Martin Gebser", "authors": "Martin Gebser and Roland Kaminski and Torsten Schaub", "title": "Complex Optimization in Answer Set Programming", "comments": "18 pages, 5 figures", "journal-ref": "Theory and Practice of Logic Programming, 11(4-5), 821-839, 2011", "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Preference handling and optimization are indispensable means for addressing\nnon-trivial applications in Answer Set Programming (ASP). However, their\nimplementation becomes difficult whenever they bring about a significant\nincrease in computational complexity. As a consequence, existing ASP systems do\nnot offer complex optimization capacities, supporting, for instance,\ninclusion-based minimization or Pareto efficiency. Rather, such complex\ncriteria are typically addressed by resorting to dedicated modeling techniques,\nlike saturation. Unlike the ease of common ASP modeling, however, these\ntechniques are rather involved and hardly usable by ASP laymen. We address this\nproblem by developing a general implementation technique by means of\nmeta-programming, thus reusing existing ASP systems to capture various forms of\nqualitative preferences among answer sets. In this way, complex preferences and\noptimization capacities become readily available for ASP applications.\n", "versions": [{"version": "v1", "created": "Thu, 28 Jul 2011 15:36:51 GMT"}], "update_date": "2011-07-29", "authors_parsed": [["Gebser", "Martin", ""], ["Kaminski", "Roland", ""], ["Schaub", "Torsten", ""]]}, {"id": "1107.5847", "submitter": "EPTCS", "authors": "Mohammad Reza Mousavi, Antonio Ravara", "title": "Proceedings 10th International Workshop on the Foundations of\n  Coordination Languages and Software Architectures", "comments": "EPTCS 58, 2011", "journal-ref": null, "doi": "10.4204/EPTCS.58", "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computation nowadays is becoming inherently concurrent, either because of\ncharacteristics of the hardware (with multicore processors becoming\nomnipresent) or due to the ubiquitous presence of distributed systems\n(incarnated in the Internet). Computational systems are therefore typically\ndistributed, concurrent, mobile, and often involve composition of heterogeneous\ncomponents.\n  To specify and reason about such systems and go beyond the functional\ncorrectness proofs, e.g., by supporting reusability and improving\nmaintainability, approaches such as coordination languages and software\narchitecture are recognised as fundamental.\n  The goal of the this workshop is to put together researchers and\npractitioners of the aforementioned fields, to share and identify common\nproblems, and to devise general solutions in the context of coordination\nlanguages and software architectures.\n", "versions": [{"version": "v1", "created": "Fri, 29 Jul 2011 00:30:04 GMT"}], "update_date": "2011-08-01", "authors_parsed": [["Mousavi", "Mohammad Reza", ""], ["Ravara", "Antonio", ""]]}, {"id": "1107.5886", "submitter": "Olivier Finkel", "authors": "Olivier Finkel (ELM)", "title": "Three Applications to Rational Relations of the High Undecidability of\n  the Infinite Post Correspondence Problem in a Regular omega-Language", "comments": "To appear in: Special Issue: Frontier Between Decidability and\n  Undecidability and Related Problems, International Journal of Foundations of\n  Computer Science", "journal-ref": "International Journal of Foundations of Computer Science 23, 7\n  (2012) p. 1481-1497", "doi": "10.1142/S0129054112400606", "report-no": null, "categories": "cs.LO cs.CC math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It was noticed by Harel in [Har86] that \"one can define $\\Sigma_1^1$-complete\nversions of the well-known Post Correspondence Problem\". We first give a\ncomplete proof of this result, showing that the infinite Post Correspondence\nProblem in a regular $\\omega$-language is $\\Sigma_1^1$-complete, hence located\nbeyond the arithmetical hierarchy and highly undecidable. We infer from this\nresult that it is $\\Pi_1^1$-complete to determine whether two given infinitary\nrational relations are disjoint. Then we prove that there is an amazing gap\nbetween two decision problems about $\\omega$-rational functions realized by\nfinite state B\\\"uchi transducers. Indeed Prieur proved in [Pri01, Pri02] that\nit is decidable whether a given $\\omega$-rational function is continuous, while\nwe show here that it is $\\Sigma_1^1$-complete to determine whether a given\n$\\omega$-rational function has at least one point of continuity. Next we prove\nthat it is $\\Pi_1^1$-complete to determine whether the continuity set of a\ngiven $\\omega$-rational function is $\\omega$-regular. This gives the exact\ncomplexity of two problems which were shown to be undecidable in [CFS08].\n", "versions": [{"version": "v1", "created": "Fri, 29 Jul 2011 07:15:04 GMT"}], "update_date": "2013-03-06", "authors_parsed": [["Finkel", "Olivier", "", "ELM"]]}, {"id": "1107.5896", "submitter": "Olivier Finkel", "authors": "Olivier Finkel (ELM)", "title": "Decision Problems for Recognizable Languages of Infinite Pictures", "comments": null, "journal-ref": "28th Weak Arithmetic Days, Journ\\'ees sur les Arithm\\'etiques\n  Faibles, Fontainebleau : France (2009)", "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Altenbernd, Thomas and W\\\"ohrle have considered in [ATW02] acceptance of\nlanguages of infinite two-dimensional words (infinite pictures) by finite\ntiling systems, with the usual acceptance conditions, such as the B\\\"uchi and\nMuller ones, firstly used for infinite words. Many classical decision problems\nare studied in formal language theory and in automata theory and arise now\nnaturally about recognizable languages of infinite pictures. We first review in\nthis paper some recent results of [Fin09b] where we gave the exact degree of\nnumerous undecidable problems for B\\\"uchi-recognizable languages of infinite\npictures, which are actually located at the first or at the second level of the\nanalytical hierarchy, and \"highly undecidable\". Then we prove here some more\n(high) undecidability results. We first show that it is $\\Pi_2^1$-complete to\ndetermine whether a given B\\\"uchi-recognizable languages of infinite pictures\nis unambiguous. Then we investigate cardinality problems. Using recent results\nof [FL09], we prove that it is $D_2(\\Sigma_1^1)$-complete to determine whether\na given B\\\"uchi-recognizable language of infinite pictures is countably\ninfinite, and that it is $\\Sigma_1^1$-complete to determine whether a given\nB\\\"uchi-recognizable language of infinite pictures is uncountable. Next we\nconsider complements of recognizable languages of infinite pictures. Using some\nresults of Set Theory, we show that the cardinality of the complement of a\nB\\\"uchi-recognizable language of infinite pictures may depend on the model of\nthe axiomatic system ZFC. We prove that the problem to determine whether the\ncomplement of a given B\\\"uchi-recognizable language of infinite pictures is\ncountable (respectively, uncountable) is in the class $\\Sigma_3^1 \\setminus\n(\\Pi_2^1 \\cup \\Sigma_2^1)$ (respectively, in the class $\\Pi_3^1 \\setminus\n(\\Pi_2^1 \\cup \\Sigma_2^1)$).\n", "versions": [{"version": "v1", "created": "Fri, 29 Jul 2011 08:48:07 GMT"}], "update_date": "2011-08-03", "authors_parsed": [["Finkel", "Olivier", "", "ELM"]]}, {"id": "1107.5897", "submitter": "Katerina Ksystra", "authors": "Katerina Ksystra, Nikolaos Triantafyllou, Petros Stefaneas and\n  Panayiotis Frangos", "title": "An Algebraic Specification of the Semantic Web", "comments": "6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a formal specification of the Semantic Web, as an extension of the\nWorld Wide Web using the well known algebraic specification language CafeOBJ.\nOur approach allows the description of the key elements of the Semantic Web\ntechnologies, in order to give a better understanding of the system, without\ngetting involved with their implementation details that might not yet be\nstandardized. This specification is part of our work in progress concerning the\nmodeling the Social Semantic Web.\n", "versions": [{"version": "v1", "created": "Fri, 29 Jul 2011 08:48:14 GMT"}], "update_date": "2011-08-01", "authors_parsed": [["Ksystra", "Katerina", ""], ["Triantafyllou", "Nikolaos", ""], ["Stefaneas", "Petros", ""], ["Frangos", "Panayiotis", ""]]}, {"id": "1107.5980", "submitter": "Juergen Giesl", "authors": "Michael Codish, Igor Gonopolskiy, Amir M. Ben-Amram, Carsten Fuhs,\n  J\\\"urgen Giesl", "title": "SAT-Based Termination Analysis Using Monotonicity Constraints over the\n  Integers", "comments": null, "journal-ref": "Theory and Practice of Logic Programming, 27th International\n  Conference on Logic Programming (ICLP'11) Special Issue, volume 11, issue\n  4-5, pages 503-520, 2011", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe an algorithm for proving termination of programs abstracted to\nsystems of monotonicity constraints in the integer domain. Monotonicity\nconstraints are a non-trivial extension of the well-known size-change\ntermination method. While deciding termination for systems of monotonicity\nconstraints is PSPACE complete, we focus on a well-defined and significant\nsubset, which we call MCNP, designed to be amenable to a SAT-based solution.\nOur technique is based on the search for a special type of ranking function\ndefined in terms of bounded differences between multisets of integer values. We\ndescribe the application of our approach as the back-end for the termination\nanalysis of Java Bytecode (JBC). At the front-end, systems of monotonicity\nconstraints are obtained by abstracting information, using two different\ntermination analyzers: AProVE and COSTA. Preliminary results reveal that our\napproach provides a good trade-off between precision and cost of analysis.\n", "versions": [{"version": "v1", "created": "Fri, 29 Jul 2011 14:19:14 GMT"}], "update_date": "2011-08-01", "authors_parsed": [["Codish", "Michael", ""], ["Gonopolskiy", "Igor", ""], ["Ben-Amram", "Amir M.", ""], ["Fuhs", "Carsten", ""], ["Giesl", "J\u00fcrgen", ""]]}]