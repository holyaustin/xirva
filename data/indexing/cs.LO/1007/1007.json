[{"id": "1007.0120", "submitter": "Olivier Laurent", "authors": "Thomas Ehrhard (PPS (CNRS - Univ Paris 7)), Olivier Laurent (PPS (CNRS\n  - Univ Paris 7))", "title": "Acyclic Solos and Differential Interaction Nets", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (September\n  1, 2010) lmcs:771", "doi": "10.2168/LMCS-6(3:11)2010", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a restriction of the solos calculus which is stable under\nreduction and expressive enough to contain an encoding of the pi-calculus. As a\nconsequence, it is shown that equalizing names that are already equal is not\nrequired by the encoding of the pi-calculus. In particular, the induced solo\ndiagrams bear an acyclicity property that induces a faithful encoding into\ndifferential interaction nets. This gives a (new) proof that differential\ninteraction nets are expressive enough to contain an encoding of the\npi-calculus. All this is worked out in the case of finitary (replication free)\nsystems without sum, match nor mismatch.\n", "versions": [{"version": "v1", "created": "Thu, 1 Jul 2010 10:23:59 GMT"}, {"version": "v2", "created": "Mon, 26 Jul 2010 17:50:06 GMT"}, {"version": "v3", "created": "Wed, 1 Sep 2010 14:36:19 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Ehrhard", "Thomas", "", "PPS"], ["Laurent", "Olivier", "", "PPS"]]}, {"id": "1007.0134", "submitter": "Martin Gebser", "authors": "Martin Gebser and Torsten Schaub and Sven Thiele and Philippe Veber", "title": "Detecting Inconsistencies in Large Biological Networks with Answer Set\n  Programming", "comments": "36 pages, 8 figures, 3 tables, to appear in Theory and Practice of\n  Logic Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce an approach to detecting inconsistencies in large biological\nnetworks by using Answer Set Programming (ASP). To this end, we build upon a\nrecently proposed notion of consistency between biochemical/genetic reactions\nand high-throughput profiles of cell activity. We then present an approach\nbased on ASP to check the consistency of large-scale data sets. Moreover, we\nextend this methodology to provide explanations for inconsistencies by\ndetermining minimal representations of conflicts. In practice, this can be used\nto identify unreliable data or to indicate missing reactions.\n", "versions": [{"version": "v1", "created": "Thu, 1 Jul 2010 11:41:21 GMT"}], "update_date": "2010-07-02", "authors_parsed": [["Gebser", "Martin", ""], ["Schaub", "Torsten", ""], ["Thiele", "Sven", ""], ["Veber", "Philippe", ""]]}, {"id": "1007.0523", "submitter": "Farn Wang", "authors": "Farn Wang", "title": "Simulation-Checking of Real-Time Systems with Fairness Assumptions", "comments": "18 pages, 5 figures, part of the materials appear in the proceedings\n  of FOMRATS 2007 and HSCC 2009", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  We investigate the simulation problem in of dense-time system. A\nspecification simulates a model if the specification can match every transition\nthat the model can make at a time point. We also adapt the approach of Emerson\nand Lei and allow for multiple strong and weak fairness assumptions in checking\nthe simulation relation. Furthermore, we allow for fairness assumptions\nspecified as either state-predicates or event-predicates. We focus on a\nsubclass of the problem with at most one fairness assumption for the\nspecification. We then present a simulation-checking algorithm for this\nsubclass. We propose simulation of a model by a specification against a common\nenvironment. We present efficient techniques for such simulations to take the\ncommon environment into consideration. Our experiment shows that such a\nconsideration can dramatically improve the efficiency of checking simulation.\nWe also report the performance of our algorithm in checking the liveness\nproperties with fairness assumptions.\n", "versions": [{"version": "v1", "created": "Sun, 4 Jul 2010 02:35:47 GMT"}], "update_date": "2010-07-06", "authors_parsed": [["Wang", "Farn", ""]]}, {"id": "1007.0779", "submitter": "Zachary Snow", "authors": "Zachary Snow, David Baelde, Gopalan Nadathur", "title": "Redundancies in Dependently Typed Lambda Calculi and Their Relevance to\n  Proof Search", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dependently typed lambda calculi such as the Logical Framework (LF) are\ncapable of representing relationships between terms through types. By\nexploiting the \"formulas-as-types\" notion, such calculi can also encode the\ncorrespondence between formulas and their proofs in typing judgments. As such,\nthese calculi provide a natural yet powerful means for specifying varied formal\nsystems. Such specifications can be transformed into a more direct form that\nuses predicate formulas over simply typed lambda-terms and that thereby\nprovides the basis for their animation using conventional logic programming\ntechniques. However, a naive use of this idea is fraught with inefficiencies\narising from the fact that dependently typed expressions typically contain much\nredundant typing information. We investigate syntactic criteria for recognizing\nand, hence, eliminating such redundancies. In particular, we identify a\nproperty of bound variables in LF types called \"rigidity\" and formally show\nthat checking that instantiations of such variables adhere to typing\nrestrictions is unnecessary for the purpose of ensuring that the overall\nexpression is well-formed. We show how to exploit this property in a\ntranslation based approach to executing specifications in the Twelf language.\nRecognizing redundancy is also relevant to devising compact representations of\ndependently typed expressions. We highlight this aspect of our work and discuss\nits connection with other approaches proposed in this context.\n", "versions": [{"version": "v1", "created": "Mon, 5 Jul 2010 22:19:31 GMT"}], "update_date": "2010-07-07", "authors_parsed": [["Snow", "Zachary", ""], ["Baelde", "David", ""], ["Nadathur", "Gopalan", ""]]}, {"id": "1007.0788", "submitter": "Guillermo Morales-Luna", "authors": "Guillermo Morales-Luna", "title": "A Geometric Presentation of Probabilistic Satisfiability", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  By considering probability distributions over the set of assignments the\nexpected truth values assignment to propositional variables are extended\nthrough linear operators, and the expected truth values of the clauses at any\ngiven conjunctive form are also extended through linear maps. The probabilistic\nsatisfiability problems are discussed in terms of the introduced linear\nextensions. The case of multiple truth values is also discussed.\n", "versions": [{"version": "v1", "created": "Tue, 6 Jul 2010 00:35:35 GMT"}], "update_date": "2010-07-07", "authors_parsed": [["Morales-Luna", "Guillermo", ""]]}, {"id": "1007.0822", "submitter": "Olivier Finkel", "authors": "Olivier Finkel (ELM), Stevo Todorcevic (ELM)", "title": "The Isomorphism Relation Between Tree-Automatic Structures", "comments": null, "journal-ref": "Central European Journal of Mathematics 8, 2 (2010) p. 299-313", "doi": "10.2478/s11533-010-0014-7", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An $\\omega$-tree-automatic structure is a relational structure whose domain\nand relations are accepted by Muller or Rabin tree automata. We investigate in\nthis paper the isomorphism problem for $\\omega$-tree-automatic structures. We\nprove first that the isomorphism relation for $\\omega$-tree-automatic boolean\nalgebras (respectively, partial orders, rings, commutative rings, non\ncommutative rings, non commutative groups, nilpotent groups of class n >1) is\nnot determined by the axiomatic system ZFC. Then we prove that the isomorphism\nproblem for $\\omega$-tree-automatic boolean algebras (respectively, partial\norders, rings, commutative rings, non commutative rings, non commutative\ngroups, nilpotent groups of class n >1) is neither a $\\Sigma_2^1$-set nor a\n$\\Pi_2^1$-set.\n", "versions": [{"version": "v1", "created": "Tue, 6 Jul 2010 07:34:55 GMT"}], "update_date": "2010-07-26", "authors_parsed": [["Finkel", "Olivier", "", "ELM"], ["Todorcevic", "Stevo", "", "ELM"]]}, {"id": "1007.0825", "submitter": "Jean-Louis Krivine", "authors": "Jean-Louis Krivine (CNRS)", "title": "Realizability algebras II : new models of ZF + DC", "comments": "28 p", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 1 (February\n  27, 2012) lmcs:1072", "doi": "10.2168/LMCS-8(1:10)2012", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Using the proof-program (Curry-Howard) correspondence, we give a new method\nto obtain models of ZF and relative consistency results in set theory. We show\nthe relative consistency of ZF + DC + there exists a sequence of subsets of R\nthe cardinals of which are strictly decreasing + other similar properties of R.\nThese results seem not to have been previously obtained by forcing.\n", "versions": [{"version": "v1", "created": "Tue, 6 Jul 2010 07:53:52 GMT"}, {"version": "v2", "created": "Sun, 15 Jan 2012 02:29:54 GMT"}, {"version": "v3", "created": "Thu, 23 Feb 2012 22:49:24 GMT"}, {"version": "v4", "created": "Thu, 29 Mar 2012 09:40:34 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Krivine", "Jean-Louis", "", "CNRS"]]}, {"id": "1007.0831", "submitter": "EPTCS", "authors": "In\\^es Lynce, Ralf Treinen", "title": "Proceedings First International Workshop on Logics for Component\n  Configuration", "comments": null, "journal-ref": "EPTCS 29, 2010", "doi": "10.4204/EPTCS.29", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the papers presented at the first international workshop\non Logics for Component Configuration (LoCoCo 2010) which was associated with\nthe International Conference on Theory and Applications of Satisfiability\nTesting (SAT 2010) as part of the Federated Logic Conference (FLoC 2010), and\nwhich took place on July 10, 2010 in Edinburgh, UK.\n  Modern software distributions are based on the notion of components, which\ndenote units of independent development and deployment. Components provide the\nnecessary flexibility when organizing a complex software distribution, but also\nare a challenge when it comes to selecting components from a large repository\nof possible choices, and configuring these components according to user needs,\nresource constraints, and interdependencies with other components. Representing\nand solving configuration problems is a hot topic of great importance for many\napplication domains. Some well-known examples of complex systems of components\nare Free and Open Source software distributions like GNU/Linux, or Eclipse\nplugins. The LoCoCo workshop has a focus on logic-based methods for specifying\nand solving complex configuration problems for software components. The goal\nwas to bring together both researchers and practitioners active in the area of\ncomponent configuration of software systems, using different modeling and\nsolving techniques, such as constraint and logic programing, description\nlogics, satisfiability and its extensions.\n", "versions": [{"version": "v1", "created": "Tue, 6 Jul 2010 08:34:02 GMT"}], "update_date": "2010-07-07", "authors_parsed": [["Lynce", "In\u00eas", ""], ["Treinen", "Ralf", ""]]}, {"id": "1007.1020", "submitter": "EPTCS", "authors": "Claude Michel (University of Nice - Sophia Antipolis / I3S-CNRS),\n  Michel Rueher (University of Nice - Sophia Antipolis / I3S-CNRS)", "title": "Handling software upgradeability problems with MILP solvers", "comments": "In Proceedings LoCoCo 2010, arXiv:1007.0831", "journal-ref": "EPTCS 29, 2010, pp. 1-10", "doi": "10.4204/EPTCS.29.1", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Upgradeability problems are a critical issue in modern operating systems. The\nproblem consists in finding the \"best\" solution according to some criteria, to\ninstall, remove or upgrade packages in a given installation. This is a\ndifficult problem: the complexity of the upgradeability problem is NP complete\nand modern OS contain a huge number of packages (often more than 20 000\npackages in a Linux distribution). Moreover, several optimisation criteria have\nto be considered, e.g., stability, memory efficiency, network efficiency. In\nthis paper we investigate the capabilities of MILP solvers to handle this\nproblem. We show that MILP solvers are very efficient when the resolution is\nbased on a linear combination of the criteria. Experiments done on real\nbenchmarks show that the best MILP solvers outperform CP solvers and that they\nare significantly better than Pseudo Boolean solvers.\n", "versions": [{"version": "v1", "created": "Wed, 7 Jul 2010 00:12:50 GMT"}], "update_date": "2010-07-08", "authors_parsed": [["Michel", "Claude", "", "University of Nice - Sophia Antipolis / I3S-CNRS"], ["Rueher", "Michel", "", "University of Nice - Sophia Antipolis / I3S-CNRS"]]}, {"id": "1007.1021", "submitter": "EPTCS", "authors": "Josep Argelich (DIEI), Daniel Le Berre (CRIL-CNRS), In\\^es Lynce\n  (INESC-ID/IST), Joao Marques-Silva (CSI/CASL), Pascal Rapicault (Sonatype)", "title": "Solving Linux Upgradeability Problems Using Boolean Optimization", "comments": "In Proceedings LoCoCo 2010, arXiv:1007.0831", "journal-ref": "EPTCS 29, 2010, pp. 11-22", "doi": "10.4204/EPTCS.29.2", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Managing the software complexity of package-based systems can be regarded as\none of the main challenges in software architectures. Upgrades are required on\na short time basis and systems are expected to be reliable and consistent after\nthat. For each package in the system, a set of dependencies and a set of\nconflicts have to be taken into account. Although this problem is\ncomputationally hard to solve, efficient tools are required. In the best\nscenario, the solutions provided should also be optimal in order to better\nfulfill users requirements and expectations. This paper describes two different\ntools, both based on Boolean satisfiability (SAT), for solving Linux\nupgradeability problems. The problem instances used in the evaluation of these\ntools were mainly obtained from real environments, and are subject to two\ndifferent lexicographic optimization criteria. The developed tools can provide\noptimal solutions for many of the instances, but a few challenges remain.\nMoreover, it is our understanding that this problem has many similarities with\nother configuration problems, and therefore the same techniques can be used in\nother domains.\n", "versions": [{"version": "v1", "created": "Wed, 7 Jul 2010 00:12:57 GMT"}], "update_date": "2010-07-08", "authors_parsed": [["Argelich", "Josep", "", "DIEI"], ["Berre", "Daniel Le", "", "CRIL-CNRS"], ["Lynce", "In\u00eas", "", "INESC-ID/IST"], ["Marques-Silva", "Joao", "", "CSI/CASL"], ["Rapicault", "Pascal", "", "Sonatype"]]}, {"id": "1007.1022", "submitter": "EPTCS", "authors": "Paulo Trezentos (ISCTE / ADETTI / Caixa M\\'agica)", "title": "Comparison of PBO solvers in a dependency solving domain", "comments": "In Proceedings LoCoCo 2010, arXiv:1007.0831", "journal-ref": "EPTCS 29, 2010, pp. 23-31", "doi": "10.4204/EPTCS.29.3", "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linux package managers have to deal with dependencies and conflicts of\npackages required to be installed by the user. As an NP-complete problem, this\nis a hard task to solve. In this context, several approaches have been pursued.\nApt-pbo is a package manager based on the apt project that encodes the\ndependency solving problem as a pseudo-Boolean optimization (PBO) problem. This\npaper compares different PBO solvers and their effectiveness on solving the\ndependency solving problem.\n", "versions": [{"version": "v1", "created": "Wed, 7 Jul 2010 00:13:00 GMT"}], "update_date": "2010-07-08", "authors_parsed": [["Trezentos", "Paulo", "", "ISCTE / ADETTI / Caixa M\u00e1gica"]]}, {"id": "1007.1024", "submitter": "EPTCS", "authors": "Andreas K\\\"ubler (Symbolic Computation Group, Wilhelm Schickard\n  Institute for Computer Science, Universit\\\"at T\\\"ubingen, Germany), Christoph\n  Zengler (Symbolic Computation Group, Wilhelm Schickard Institute for Computer\n  Science, Universit\\\"at T\\\"ubingen, Germany), Wolfgang K\\\"uchlin (Symbolic\n  Computation Group, Wilhelm Schickard Institute for Computer Science,\n  Universit\\\"at T\\\"ubingen, Germany)", "title": "Model Counting in Product Configuration", "comments": "In Proceedings LoCoCo 2010, arXiv:1007.0831", "journal-ref": "EPTCS 29, 2010, pp. 44-53", "doi": "10.4204/EPTCS.29.5", "report-no": null, "categories": "cs.AI cs.LO cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe how to use propositional model counting for a quantitative\nanalysis of product configuration data. Our approach computes valuable meta\ninformation such as the total number of valid configurations or the relative\nfrequency of components. This information can be used to assess the severity of\ndocumentation errors or to measure documentation quality. As an application\nexample we show how we apply these methods to product documentation formulas of\nthe Mercedes-Benz line of vehicles. In order to process these large formulas we\ndeveloped and implemented a new model counter for non-CNF formulas. Our model\ncounter can process formulas, whose CNF representations could not be processed\nup till now.\n", "versions": [{"version": "v1", "created": "Wed, 7 Jul 2010 00:13:11 GMT"}], "update_date": "2010-07-08", "authors_parsed": [["K\u00fcbler", "Andreas", "", "Symbolic Computation Group, Wilhelm Schickard\n  Institute for Computer Science, Universit\u00e4t T\u00fcbingen, Germany"], ["Zengler", "Christoph", "", "Symbolic Computation Group, Wilhelm Schickard Institute for Computer\n  Science, Universit\u00e4t T\u00fcbingen, Germany"], ["K\u00fcchlin", "Wolfgang", "", "Symbolic\n  Computation Group, Wilhelm Schickard Institute for Computer Science,\n  Universit\u00e4t T\u00fcbingen, Germany"]]}, {"id": "1007.1324", "submitter": "Giorgi Japaridze", "authors": "Giorgi Japaridze", "title": "Separating the basic logics of the basic recurrences", "comments": null, "journal-ref": "Annals of Pure and Applied Logic 163 (2012), pp. 377-389", "doi": "10.1016/j.apal.2011.11.009", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper shows that, even at the most basic level, the parallel, countable\nbranching and uncountable branching recurrences of Computability Logic (see\nhttp://www.cis.upenn.edu/~giorgi/cl.html) validate different principles.\n", "versions": [{"version": "v1", "created": "Thu, 8 Jul 2010 09:41:13 GMT"}, {"version": "v2", "created": "Fri, 9 Jul 2010 04:41:25 GMT"}, {"version": "v3", "created": "Tue, 15 Nov 2011 08:50:05 GMT"}], "update_date": "2012-01-04", "authors_parsed": [["Japaridze", "Giorgi", ""]]}, {"id": "1007.1669", "submitter": "Krishnendu Chatterjee", "authors": "Krishnendu Chatterjee and Laurent Doyen and Thomas A. Henzinger and\n  Jean-Francois Raskin", "title": "Generalized Mean-payoff and Energy Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In mean-payoff games, the objective of the protagonist is to ensure that the\nlimit average of an infinite sequence of numeric weights is nonnegative. In\nenergy games, the objective is to ensure that the running sum of weights is\nalways nonnegative. Generalized mean-payoff and energy games replace individual\nweights by tuples, and the limit average (resp. running sum) of each coordinate\nmust be (resp. remain) nonnegative. These games have applications in the\nsynthesis of resource-bounded processes with multiple resources.\n  We prove the finite-memory determinacy of generalized energy games and show\nthe inter-reducibility of generalized mean-payoff and energy games for\nfinite-memory strategies. We also improve the computational complexity for\nsolving both classes of games with finite-memory strategies: while the\npreviously best known upper bound was EXPSPACE, and no lower bound was known,\nwe give an optimal coNP-complete bound. For memoryless strategies, we show that\nthe problem of deciding the existence of a winning strategy for the protagonist\nis NP-complete.\n", "versions": [{"version": "v1", "created": "Fri, 9 Jul 2010 20:16:30 GMT"}, {"version": "v2", "created": "Tue, 10 Aug 2010 14:09:55 GMT"}, {"version": "v3", "created": "Wed, 29 Sep 2010 09:46:25 GMT"}, {"version": "v4", "created": "Sat, 2 Oct 2010 17:33:05 GMT"}], "update_date": "2010-10-05", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Doyen", "Laurent", ""], ["Henzinger", "Thomas A.", ""], ["Raskin", "Jean-Francois", ""]]}, {"id": "1007.1710", "submitter": "Tomas Brazdil", "authors": "Tomas Brazdil, Stefan Kiefer, Antonin Kucera, Ivana Hutarova Varekova", "title": "Runtime Analysis of Probabilistic Programs with Unbounded Recursion", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study termination time and recurrence time in programs with unbounded\nrecursion, which are either randomized or operate on some statistically\nquantified inputs. As the underlying formal model for such programs we use\nprobabilistic pushdown automata (pPDA) which are equivalent to probabilistic\nrecursive state machines. We obtain tail bounds for the distribution of\ntermination time for pPDA. We also study the recurrence time for probabilistic\nrecursive programs that are not supposed to terminate (such as system daemons,\nnetwork servers, etc.). Typically, such programs react to certain requests\ngenerated by their environment, and hence operate in finite request-service\ncycles. We obtain bounds for the frequency of long request-service cycles.\n", "versions": [{"version": "v1", "created": "Sat, 10 Jul 2010 09:49:19 GMT"}, {"version": "v2", "created": "Thu, 31 May 2012 09:09:25 GMT"}], "update_date": "2012-06-01", "authors_parsed": [["Brazdil", "Tomas", ""], ["Kiefer", "Stefan", ""], ["Kucera", "Antonin", ""], ["Varekova", "Ivana Hutarova", ""]]}, {"id": "1007.1785", "submitter": "Federico Aschieri", "authors": "Federico Aschieri (University of Turin and Queen Mary, University of\n  London), Stefano Berardi (University of Turin)", "title": "Interactive Learning-Based Realizability for Heyting Arithmetic with EM1", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (September\n  7, 2010) lmcs:1061", "doi": "10.2168/LMCS-6(3:19)2010", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We apply to the semantics of Arithmetic the idea of ``finite approximation''\nused to provide computational interpretations of Herbrand's Theorem, and we\ninterpret classical proofs as constructive proofs (with constructive rules for\n$\\vee, \\exists$) over a suitable structure $\\StructureN$ for the language of\nnatural numbers and maps of G\\\"odel's system $\\SystemT$. We introduce a new\nRealizability semantics we call ``Interactive learning-based Realizability'',\nfor Heyting Arithmetic plus $\\EM_1$ (Excluded middle axiom restricted to\n$\\Sigma^0_1$ formulas). Individuals of $\\StructureN$ evolve with time, and\nrealizers may ``interact'' with them, by influencing their evolution. We build\nour semantics over Avigad's fixed point result, but the same semantics may be\ndefined over different constructive interpretations of classical arithmetic\n(Berardi and de' Liguoro use continuations). Our notion of realizability\nextends intuitionistic realizability and differs from it only in the atomic\ncase: we interpret atomic realizers as ``learning agents''.\n", "versions": [{"version": "v1", "created": "Sun, 11 Jul 2010 16:31:48 GMT"}, {"version": "v2", "created": "Thu, 9 Sep 2010 13:11:35 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Aschieri", "Federico", "", "University of Turin and Queen Mary, University of\n  London"], ["Berardi", "Stefano", "", "University of Turin"]]}, {"id": "1007.2131", "submitter": "Soumyadip Bandyopadhyay", "authors": "S. Bandyopadhyay, D. Sarkar, C. R. Mandal", "title": "Equivalence Checking in Embedded Systems Design Verification", "comments": "This paper has been withdrawn by the author. I want to modify this\n  technical report. Please see arXiv:1010.4953", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this report we focus on some aspects related to modeling and formal\nverification of embedded systems. Many models have been proposed to represent\nembedded systems. These models encompass a broad range of styles,\ncharacteristics, and application domains and include the extensions of finite\nstate machines, data flow graphs, communication processes and Petri nets. In\nthis report, we have used a PRES+ model (Petri net based Representation for\nEmbedded Systems) as an extension of classical Petri net model that captures\nconcurrency, timing behaviour of embedded systems; it allows systems to be\nrepresentative in different levels of abstraction and improves expressiveness\nby allowing the token to carry information. Modeling using PRES+, as discussed\nabove, may be convenient for specifying the input behaviour because it supports\nconcurrency. However, there is no equivalence checking method reported in the\nliterature for PRES+ models to the best of our knowledge. In contrast,\nequivalence checking of FSMD models exist. As a first step, therefore, we seek\nto devise an algorithm to translate PRES+ models to FSMD models.\n", "versions": [{"version": "v1", "created": "Tue, 13 Jul 2010 16:03:11 GMT"}, {"version": "v2", "created": "Wed, 14 Jul 2010 09:06:56 GMT"}, {"version": "v3", "created": "Wed, 18 Aug 2010 20:34:38 GMT"}, {"version": "v4", "created": "Fri, 20 Aug 2010 18:10:26 GMT"}], "update_date": "2010-10-26", "authors_parsed": [["Bandyopadhyay", "S.", ""], ["Sarkar", "D.", ""], ["Mandal", "C. R.", ""]]}, {"id": "1007.2364", "submitter": "Loris Bozzato", "authors": "Loris Bozzato and Mauro Ferrari (DICOM - Universit\\`a degli Studi\n  dell'Insubria)", "title": "A Note on Semantic Web Services Specification and Composition in\n  Constructive Description Logics", "comments": "15 pages, 2 figures. Part of this work will appear as a position\n  paper in Proceedings of 4th Int. Conf. on Web Reasoning and Rule Systems (RR\n  2010)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The idea of the Semantic Web is to annotate Web content and services with\ncomputer interpretable descriptions with the aim to automatize many tasks\ncurrently performed by human users. In the context of Web services, one of the\nmost interesting tasks is their composition. In this paper we formalize this\nproblem in the framework of a constructive description logic. In particular we\npropose a declarative service specification language and a calculus for service\ncomposition. We show by means of an example how this calculus can be used to\ndefine composed Web services and we discuss the problem of automatic service\nsynthesis.\n", "versions": [{"version": "v1", "created": "Wed, 14 Jul 2010 16:02:32 GMT"}], "update_date": "2010-07-15", "authors_parsed": [["Bozzato", "Loris", "", "DICOM - Universit\u00e0 degli Studi\n  dell'Insubria"], ["Ferrari", "Mauro", "", "DICOM - Universit\u00e0 degli Studi\n  dell'Insubria"]]}, {"id": "1007.2584", "submitter": "Yuan Feng", "authors": "Yuan Feng, Runyao Duan, Mingsheng Ying", "title": "Bisimulation for quantum processes", "comments": "Journal version", "journal-ref": "ACM Transactions on Programming Languages and Systems 2012,\n  vol.34(4), no.17", "doi": null, "report-no": null, "categories": "quant-ph cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we introduce a novel notion of probabilistic bisimulation for\nquantum processes and prove that it is congruent with respect to various\nprocess algebra combinators including parallel composition even when both\nclassical and quantum communications are present. We also establish some basic\nalgebraic laws for this bisimulation. In particular, we prove uniqueness of the\nsolutions to recursive equations of quantum processes, which provides a\npowerful proof technique for verifying complex quantum protocols.\n", "versions": [{"version": "v1", "created": "Thu, 15 Jul 2010 15:03:45 GMT"}, {"version": "v2", "created": "Sun, 19 Sep 2010 09:33:47 GMT"}, {"version": "v3", "created": "Thu, 14 Nov 2013 07:30:55 GMT"}], "update_date": "2013-11-15", "authors_parsed": [["Feng", "Yuan", ""], ["Duan", "Runyao", ""], ["Ying", "Mingsheng", ""]]}, {"id": "1007.2754", "submitter": "Samson Abramsky", "authors": "Samson Abramsky", "title": "Relational Hidden Variables and Non-Locality", "comments": "42 pages in journal style. To appear in Studia Logica", "journal-ref": "Studia Logica April 2013, Volume 101, Issue 2, pp 411-452", "doi": "10.1007/s11225-013-9477-4", "report-no": null, "categories": "quant-ph cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We use a simple relational framework to develop the key notions and results\non hidden variables and non-locality. The extensive literature on these topics\nin the foundations of quantum mechanics is couched in terms of probabilistic\nmodels, and properties such as locality and no-signalling are formulated\nprobabilistically. We show that to a remarkable extent, the main structure of\nthe theory, through the major No-Go theorems and beyond, survives intact under\nthe replacement of probability distributions by mere relations.\n", "versions": [{"version": "v1", "created": "Fri, 16 Jul 2010 12:17:25 GMT"}, {"version": "v2", "created": "Wed, 28 Jul 2010 13:32:08 GMT"}, {"version": "v3", "created": "Tue, 24 Aug 2010 13:12:44 GMT"}, {"version": "v4", "created": "Fri, 31 Dec 2010 11:46:56 GMT"}, {"version": "v5", "created": "Tue, 18 Oct 2011 11:16:32 GMT"}], "update_date": "2014-06-10", "authors_parsed": [["Abramsky", "Samson", ""]]}, {"id": "1007.2816", "submitter": "Miroslaw Truszczynski", "authors": "Miroslaw Truszczynski", "title": "Trichotomy and Dichotomy Results on the Complexity of Reasoning with\n  Disjunctive Logic Programs", "comments": "24 pages To appear in Theory and Practice of Logic Programming (TPLP)", "journal-ref": "Theory and Practice of Logic Programming, 11(6): 881-904 (2011)", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present trichotomy results characterizing the complexity of reasoning with\ndisjunctive logic programs. To this end, we introduce a certain definition\nschema for classes of programs based on a set of allowed arities of rules. We\nshow that each such class of programs has a finite representation, and for each\nof the classes definable in the schema we characterize the complexity of the\nexistence of an answer set problem. Next, we derive similar characterizations\nof the complexity of skeptical and credulous reasoning with disjunctive logic\nprograms. Such results are of potential interest. On the one hand, they reveal\nsome reasons responsible for the hardness of computing answer sets. On the\nother hand, they identify classes of problem instances, for which the problem\nis \"easy\" (in P) or \"easier than in general\" (in NP). We obtain similar results\nfor the complexity of reasoning with disjunctive programs under the\nsupported-model semantics. To appear in Theory and Practice of Logic\nProgramming (TPLP)\n", "versions": [{"version": "v1", "created": "Fri, 16 Jul 2010 17:07:25 GMT"}, {"version": "v2", "created": "Thu, 2 Sep 2010 01:30:39 GMT"}], "update_date": "2014-10-08", "authors_parsed": [["Truszczynski", "Miroslaw", ""]]}, {"id": "1007.2924", "submitter": "Michael Thomas", "authors": "Michael Thomas", "title": "On the Applicability of Post's Lattice", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For decision problems P defined over Boolean circuits from a restricted set\nof gates, we have that P(B) AC0 many-one reduces to P(B') for all finite sets B\nand B' of gates such that all gates from B can be computed by circuits over\ngates from B'. In this paper, we show that a weaker version of this statement\nholds for decision problems defined over Boolean formulae, namely that P(B) NC2\nmany-one reduces to P(B' union {and,or}) and that P(B) NC2 many-one reduces to\nP(B' union {false,true}), for all finite sets B and B' of Boolean functions\nsuch that all f in B can be defined in B'.\n", "versions": [{"version": "v1", "created": "Sat, 17 Jul 2010 12:32:40 GMT"}, {"version": "v2", "created": "Tue, 4 Jan 2011 16:35:21 GMT"}, {"version": "v3", "created": "Thu, 5 Jan 2012 10:55:58 GMT"}], "update_date": "2012-01-06", "authors_parsed": [["Thomas", "Michael", ""]]}, {"id": "1007.2989", "submitter": "Sylvain Schmitz", "authors": "Diego Figueira, Santiago Figueira, Sylvain Schmitz, Philippe\n  Schnoebelen", "title": "Ackermannian and Primitive-Recursive Bounds with Dickson's Lemma", "comments": null, "journal-ref": "In LICS 2011, 26th Annual IEEE Symposium on Logic in Computer\n  Science, pages 269--278. IEEE Press", "doi": "10.1109/LICS.2011.39", "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dickson's Lemma is a simple yet powerful tool widely used in termination\nproofs, especially when dealing with counters or related data structures.\nHowever, most computer scientists do not know how to derive complexity upper\nbounds from such termination proofs, and the existing literature is not very\nhelpful in these matters.\n  We propose a new analysis of the length of bad sequences over (N^k,\\leq) and\nexplain how one may derive complexity upper bounds from termination proofs. Our\nupper bounds improve earlier results and are essentially tight.\n", "versions": [{"version": "v1", "created": "Sun, 18 Jul 2010 11:14:16 GMT"}, {"version": "v2", "created": "Wed, 12 Jan 2011 21:45:18 GMT"}, {"version": "v3", "created": "Tue, 19 Jul 2011 11:33:02 GMT"}], "update_date": "2011-07-20", "authors_parsed": [["Figueira", "Diego", ""], ["Figueira", "Santiago", ""], ["Schmitz", "Sylvain", ""], ["Schnoebelen", "Philippe", ""]]}, {"id": "1007.3303", "submitter": "Zhaohua Luo", "authors": "Zhaohua Luo", "title": "A New Approach to Abstract Machines - Introduction to the Theory of\n  Configuration Machines", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An abstract machine is a theoretical model designed to perform a rigorous\nstudy of computation. Such a model usually consists of configurations,\ninstructions, programs, inputs and outputs for the machine. In this paper we\nformalize these notions as a very simple algebraic system, called a\nconfiguration machine. If an abstract machine is defined as a configuration\nmachine consisting of primitive recursive functions then the functions computed\nby the machine are always recursive. The theory of configuration machines\nprovides a useful tool to study universal machines.\n", "versions": [{"version": "v1", "created": "Mon, 19 Jul 2010 22:53:06 GMT"}], "update_date": "2010-07-21", "authors_parsed": [["Luo", "Zhaohua", ""]]}, {"id": "1007.3350", "submitter": "Yves Bertot", "authors": "Jean-Fran\\c{c}ois Dufourd (LSIIT), Yves Bertot (INRIA Sophia\n  Antipolis)", "title": "Formal study of plane Delaunay triangulation", "comments": null, "journal-ref": "Interactive Theorem Priving, Edinburgh : United Kingdom (2010)", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article presents the formal proof of correctness for a plane Delaunay\ntriangulation algorithm. It consists in repeating a sequence of edge flippings\nfrom an initial triangulation until the Delaunay property is achieved. To\ndescribe triangulations, we rely on a combinatorial hypermap specification\nframework we have been developing for years. We embed hypermaps in the plane by\nattaching coordinates to elements in a consistent way. We then describe what\nare legal and illegal Delaunay edges and a flipping operation which we show\npreserves hypermap, triangulation, and embedding invariants. To prove the\ntermination of the algorithm, we use a generic approach expressing that any\nnon-cyclic relation is well-founded when working on a finite set.\n", "versions": [{"version": "v1", "created": "Tue, 20 Jul 2010 06:39:28 GMT"}], "update_date": "2010-07-26", "authors_parsed": [["Dufourd", "Jean-Fran\u00e7ois", "", "LSIIT"], ["Bertot", "Yves", "", "INRIA Sophia\n  Antipolis"]]}, {"id": "1007.3569", "submitter": "Cong Tian", "authors": "Cong Tian, Zhenhua Duan", "title": "Making Abstraction Refinement Efficient in Model Checking", "comments": "14 pages, 10 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Abstraction is one of the most important strategies for dealing with the\nstate space explosion problem in model checking. In the abstract model,\nalthough the state space is largely reduced, however, a counterexample found in\nsuch a model may not be a real counterexample. And the abstract model needs to\nbe further refined where an NP-hard state separation problem is often involved.\nIn this paper, a novel method is presented by adding extra variables to the\nabstract model for the refinement. With this method, not only the NP-hard state\nseparation problem is avoided, but also a smaller refined abstract model is\nobtained.\n", "versions": [{"version": "v1", "created": "Wed, 21 Jul 2010 07:11:17 GMT"}], "update_date": "2010-07-27", "authors_parsed": [["Tian", "Cong", ""], ["Duan", "Zhenhua", ""]]}, {"id": "1007.3615", "submitter": "Loic Pottier", "authors": "Lo\\\"ic Pottier (INRIA Sophia Antipolis)", "title": "Connecting Gr\\\"obner Bases Programs with Coq to do Proofs in Algebra,\n  Geometry and Arithmetics", "comments": null, "journal-ref": "Knowledge Exchange: Automated Provers and Proof Assistants, Doha :\n  Qatar (2008)", "doi": null, "report-no": null, "categories": "cs.SC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe how we connected three programs that compute Groebner bases to\nCoq, to do automated proofs on algebraic, geometrical and arithmetical\nexpressions. The result is a set of Coq tactics and a certificate mechanism\n(downloadable at http://www-sop.inria.fr/marelle/Loic.Pottier/gb-keappa.tgz).\nThe programs are: F4, GB \\, and gbcoq. F4 and GB are the fastest (up to our\nknowledge) available programs that compute Groebner bases. Gbcoq is slow in\ngeneral but is proved to be correct (in Coq), and we adapted it to our specific\nproblem to be efficient. The automated proofs concern equalities and\nnon-equalities on polynomials with coefficients and indeterminates in R or Z,\nand are done by reducing to Groebner computation, via Hilbert's\nNullstellensatz. We adapted also the results of Harrison, to allow to prove\nsome theorems about modular arithmetics. The connection between Coq and the\nprograms that compute Groebner bases is done using the \"external\" tactic of Coq\nthat allows to call arbitrary programs accepting xml inputs and outputs. We\nalso produce certificates in order to make the proof scripts independant from\nthe external programs.\n", "versions": [{"version": "v1", "created": "Wed, 21 Jul 2010 11:16:48 GMT"}], "update_date": "2010-07-22", "authors_parsed": [["Pottier", "Lo\u00efc", "", "INRIA Sophia Antipolis"]]}, {"id": "1007.3629", "submitter": "Carlos A. Romero-Diaz", "authors": "Mario Rodr\\'iguez-Artalejo and Carlos A. Romero-D\\'iaz", "title": "A Declarative Semantics for CLP with Qualification and Proximity", "comments": "17 pages, 26th Int'l. Conference on Logic Programming (ICLP'10)", "journal-ref": "Theory and Practice of Logic Programming, 26th Int'l. Conference\n  on Logic Programming (ICLP'10) Special Issue, 10(4-6):627-642, 2010", "doi": "10.1017/S1471068410000323", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Uncertainty in Logic Programming has been investigated during the last\ndecades, dealing with various extensions of the classical LP paradigm and\ndifferent applications. Existing proposals rely on different approaches, such\nas clause annotations based on uncertain truth values, qualification values as\na generalization of uncertain truth values, and unification based on proximity\nrelations. On the other hand, the CLP scheme has established itself as a\npowerful extension of LP that supports efficient computation over specialized\ndomains while keeping a clean declarative semantics. In this paper we propose a\nnew scheme SQCLP designed as an extension of CLP that supports qualification\nvalues and proximity relations. We show that several previous proposals can be\nviewed as particular cases of the new scheme, obtained by partial\ninstantiation. We present a declarative semantics for SQCLP that is based on\nobservables, providing fixpoint and proof-theoretical characterizations of\nleast program models as well as an implementation-independent notion of goal\nsolutions.\n", "versions": [{"version": "v1", "created": "Wed, 21 Jul 2010 12:25:10 GMT"}], "update_date": "2010-07-22", "authors_parsed": [["Rodr\u00edguez-Artalejo", "Mario", ""], ["Romero-D\u00edaz", "Carlos A.", ""]]}, {"id": "1007.3700", "submitter": "Enrico Pontelli", "authors": "Chitta Baral, Gregory Gelfond, Enrico Pontelli, Tran Cao Son", "title": "Logic Programming for Finding Models in the Logics of Knowledge and its\n  Applications: A Case Study", "comments": "16 pages, 1 figure, International Conference on Logic Programming\n  2010", "journal-ref": "Theory and Practice of Logic Programming, Volume 10, Special Issue\n  4-6, July 2010, pages 675-690", "doi": "10.1017/S1471068410000359", "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The logics of knowledge are modal logics that have been shown to be effective\nin representing and reasoning about knowledge in multi-agent domains.\nRelatively few computational frameworks for dealing with computation of models\nand useful transformations in logics of knowledge (e.g., to support multi-agent\nplanning with knowledge actions and degrees of visibility) have been proposed.\nThis paper explores the use of logic programming (LP) to encode interesting\nforms of logics of knowledge and compute Kripke models. The LP modeling is\nexpanded with useful operators on Kripke structures, to support multi-agent\nplanning in the presence of both world-altering and knowledge actions. This\nresults in the first ever implementation of a planner for this type of complex\nmulti-agent domains.\n", "versions": [{"version": "v1", "created": "Wed, 21 Jul 2010 17:44:02 GMT"}], "update_date": "2010-07-22", "authors_parsed": [["Baral", "Chitta", ""], ["Gelfond", "Gregory", ""], ["Pontelli", "Enrico", ""], ["Son", "Tran Cao", ""]]}, {"id": "1007.3712", "submitter": "Aaron Sterling", "authors": "Aaron Sterling", "title": "Formal Verification of Self-Assembling Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces the theory and practice of formal verification of\nself-assembling systems. We interpret a well-studied abstraction of\nnanomolecular self assembly, the Abstract Tile Assembly Model (aTAM), into\nComputation Tree Logic (CTL), a temporal logic often used in model checking. We\nthen consider the class of \"rectilinear\" tile assembly systems. This class\nincludes most aTAM systems studied in the theoretical literature, and all\n(algorithmic) DNA tile self-assembling systems that have been realized in\nlaboratories to date. We present a polynomial-time algorithm that, given a tile\nassembly system T as input, either provides a counterexample to T's\nrectilinearity or verifies whether T has a unique terminal assembly. Using\npartial order reductions, the verification search space for this algorithm is\nreduced from exponential size to O(n^2), where n x n is the size of the\nassembly surface. That reduction is asymptotically the best possible. We report\non experimental results obtained by translating tile assembly simulator files\ninto a Petri net format manipulable by the SMART model checking engines devised\nby Ciardo et al. The model checker runs in O(|T| x n^4) time, where |T| is the\nnumber of tile types in tile assembly system T, and n x n is the surface size.\nAtypical for a model checking problem -- in which the practical limit usually\nis insufficient memory to store the state space -- the limit in this case was\nthe amount of memory required to represent the rules of the model. (Storage of\nthe state space and of the reachability graph were small by comparison.) We\ndiscuss how to overcome this obstacle by means of a front end tailored to the\ncharacteristics of self-assembly.\n", "versions": [{"version": "v1", "created": "Wed, 21 Jul 2010 18:39:57 GMT"}], "update_date": "2010-07-22", "authors_parsed": [["Sterling", "Aaron", ""]]}, {"id": "1007.3769", "submitter": "Alexandra Silva", "authors": "Alexandra Silva (CWI), Marcello Bonsangue (LIACS, Leiden University),\n  Jan Rutten (CWI, VUA + RUN)", "title": "Non-Deterministic Kleene Coalgebras", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (September\n  9, 2010) lmcs:695", "doi": "10.2168/LMCS-6(3:23)2010", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present a systematic way of deriving (1) languages of\n(generalised) regular expressions, and (2) sound and complete axiomatizations\nthereof, for a wide variety of systems. This generalizes both the results of\nKleene (on regular languages and deterministic finite automata) and Milner (on\nregular behaviours and finite labelled transition systems), and includes many\nother systems such as Mealy and Moore machines.\n", "versions": [{"version": "v1", "created": "Wed, 21 Jul 2010 21:57:36 GMT"}, {"version": "v2", "created": "Thu, 9 Sep 2010 12:50:24 GMT"}, {"version": "v3", "created": "Thu, 16 Sep 2010 10:12:38 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Silva", "Alexandra", "", "CWI"], ["Bonsangue", "Marcello", "", "LIACS, Leiden University"], ["Rutten", "Jan", "", "CWI, VUA + RUN"]]}, {"id": "1007.3794", "submitter": "EPTCS", "authors": "Lucas Dixon (University of Edinburgh), Ross Duncan (University of\n  Oxford), Aleks Kissinger (University of Oxford)", "title": "Open Graphs and Computational Reasoning", "comments": "In Proceedings DCM 2010, arXiv:1006.1937", "journal-ref": "EPTCS 26, 2010, pp. 169-180", "doi": "10.4204/EPTCS.26.16", "report-no": null, "categories": "cs.LO cs.MS cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a form of algebraic reasoning for computational objects which are\nexpressed as graphs. Edges describe the flow of data between primitive\noperations which are represented by vertices. These graphs have an interface\nmade of half-edges (edges which are drawn with an unconnected end) and enjoy\nrich compositional principles by connecting graphs along these half-edges. In\nparticular, this allows equations and rewrite rules to be specified between\ngraphs. Particular computational models can then be encoded as an axiomatic set\nof such rules. Further rules can be derived graphically and rewriting can be\nused to simulate the dynamics of a computational system, e.g. evaluating a\nprogram on an input. Examples of models which can be formalised in this way\ninclude traditional electronic circuits as well as recent categorical accounts\nof quantum information.\n", "versions": [{"version": "v1", "created": "Thu, 22 Jul 2010 03:31:39 GMT"}], "update_date": "2010-07-23", "authors_parsed": [["Dixon", "Lucas", "", "University of Edinburgh"], ["Duncan", "Ross", "", "University of\n  Oxford"], ["Kissinger", "Aleks", "", "University of Oxford"]]}, {"id": "1007.3819", "submitter": "Broes De Cat", "authors": "Hou Ping and Broes De Cat and Marc Denecker", "title": "FO(FD): Extending classical logic with rule-based fixpoint definitions", "comments": "Presented at ICLP 2010. 16 pages, 1 figure", "journal-ref": "Theory and Practice of Logic Programming, Volume 10, Special Issue\n  4-6, July 2010, pp 581-596", "doi": "10.1017/S1471068410000293", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  We introduce fixpoint definitions, a rule-based reformulation of fixpoint\nconstructs. The logic FO(FD), an extension of classical logic with fixpoint\ndefinitions, is defined. We illustrate the relation between FO(FD) and FO(ID),\nwhich is developed as an integration of two knowledge representation paradigms.\nThe satisfiability problem for FO(FD) is investigated by first reducing FO(FD)\nto difference logic and then using solvers for difference logic. These\nreductions are evaluated in the computation of models for FO(FD) theories\nrepresenting fairness conditions and we provide potential applications of\nFO(FD).\n", "versions": [{"version": "v1", "created": "Thu, 22 Jul 2010 08:05:56 GMT"}], "update_date": "2010-07-23", "authors_parsed": [["Ping", "Hou", ""], ["De Cat", "Broes", ""], ["Denecker", "Marc", ""]]}, {"id": "1007.3829", "submitter": "Frank Raiser", "authors": "Hariolf Betz and Frank Raiser and Thom Fr\\\"uhwirth", "title": "A Complete and Terminating Execution Model for Constraint Handling Rules", "comments": "15 pages", "journal-ref": "Theory and Practice of Logic Programming, Volume 10, Special Issue\n  4-6, July 2010, pp 597-610", "doi": "10.1017/S147106841000030X", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We observe that the various formulations of the operational semantics of\nConstraint Handling Rules proposed over the years fall into a spectrum ranging\nfrom the analytical to the pragmatic. While existing analytical formulations\nfacilitate program analysis and formal proofs of program properties, they\ncannot be implemented as is. We propose a novel operational semantics, which\nhas a strong analytical foundation, while featuring a terminating execution\nmodel. We prove its soundness and completeness with respect to existing\nanalytical formulations and we provide an implementation in the form of a\nsource-to-source transformation to CHR with rule priorities.\n", "versions": [{"version": "v1", "created": "Thu, 22 Jul 2010 08:41:47 GMT"}], "update_date": "2010-07-23", "authors_parsed": [["Betz", "Hariolf", ""], ["Raiser", "Frank", ""], ["Fr\u00fchwirth", "Thom", ""]]}, {"id": "1007.3858", "submitter": "Jon Sneyers", "authors": "Jon Sneyers, Wannes Meert, Joost Vennekens, Yoshitaka Kameya and\n  Taisuke Sato", "title": "CHR(PRISM)-based Probabilistic Logic Learning", "comments": null, "journal-ref": "Theory and Practice of Logic Programming, 10(4-6), 433-447, 2010", "doi": "10.1017/S1471068410000207", "report-no": null, "categories": "cs.PL cs.AI cs.LG cs.LO", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  PRISM is an extension of Prolog with probabilistic predicates and built-in\nsupport for expectation-maximization learning. Constraint Handling Rules (CHR)\nis a high-level programming language based on multi-headed multiset rewrite\nrules.\n  In this paper, we introduce a new probabilistic logic formalism, called\nCHRiSM, based on a combination of CHR and PRISM. It can be used for high-level\nrapid prototyping of complex statistical models by means of \"chance rules\". The\nunderlying PRISM system can then be used for several probabilistic inference\ntasks, including probability computation and parameter learning. We define the\nCHRiSM language in terms of syntax and operational semantics, and illustrate it\nwith examples. We define the notion of ambiguous programs and define a\ndistribution semantics for unambiguous programs. Next, we describe an\nimplementation of CHRiSM, based on CHR(PRISM). We discuss the relation between\nCHRiSM and other probabilistic logic programming languages, in particular PCHR.\nFinally we identify potential application domains.\n", "versions": [{"version": "v1", "created": "Thu, 22 Jul 2010 11:32:21 GMT"}], "update_date": "2010-07-23", "authors_parsed": [["Sneyers", "Jon", ""], ["Meert", "Wannes", ""], ["Vennekens", "Joost", ""], ["Kameya", "Yoshitaka", ""], ["Sato", "Taisuke", ""]]}, {"id": "1007.4018", "submitter": "Krishnendu Chatterjee", "authors": "Krishnendu Chatterjee (IST Austria), Laurent Doyen (CNRS France),\n  Thomas A Henzinger (IST Austria and EPFL Switzerland)", "title": "Expressiveness and Closure Properties for Quantitative Languages", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (August 30,\n  2010) lmcs:1084", "doi": "10.2168/LMCS-6(3:10)2010", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Weighted automata are nondeterministic automata with numerical weights on\ntransitions. They can define quantitative languages~$L$ that assign to each\nword~$w$ a real number~$L(w)$. In the case of infinite words, the value of a\nrun is naturally computed as the maximum, limsup, liminf, limit-average, or\ndiscounted-sum of the transition weights. The value of a word $w$ is the\nsupremum of the values of the runs over $w$. We study expressiveness and\nclosure questions about these quantitative languages. We first show that the\nset of words with value greater than a threshold can be non-$\\omega$-regular\nfor deterministic limit-average and discounted-sum automata, while this set is\nalways $\\omega$-regular when the threshold is isolated (i.e., some neighborhood\naround the threshold contains no word). In the latter case, we prove that the\n$\\omega$-regular language is robust against small perturbations of the\ntransition weights. We next consider automata with transition weights Weighted\nautomata are nondeterministic automata with numerical weights ontransitions.\nThey can define quantitative languages~$L$ that assign to eachword~$w$ a real\nnumber~$L(w)$. In the case of infinite words, the value of arun is naturally\ncomputed as the maximum, limsup, liminf, limit-average, ordiscounted-sum of the\ntransition weights. The value of a word $w$ is thesupremum of the values of the\nruns over $w$. We study expressiveness andclosure questions about these\nquantitative languages. We first show that the set of words with value greater\nthan a threshold canbe non-$\\omega$-regular for deterministic limit-average and\ndiscounted-sumautomata, while this set is always $\\omega$-regular when the\nthreshold isisolated (i.e., some neighborhood around the threshold contains no\nword). Inthe latter case, we prove that the $\\omega$-regular language is robust\nagainstsmall perturbations of the transition weights. We next consider automata\nwith transition weights $0$ or $1$ and show thatthey are as expressive as\ngeneral weighted automata in the limit-average case,but not in the\ndiscounted-sum case. Third, for quantitative languages $L_1$ and~$L_2$, we\nconsider the operations$\\max(L_1,L_2)$, $\\min(L_1,L_2)$, and $1-L_1$, which\ngeneralize the booleanoperations on languages, as well as the sum $L_1 + L_2$.\nWe establish theclosure properties of all classes of quantitative languages\nwith respect tothese four operations.$ or $ and show that they are as\nexpressive as general weighted automata in the limit-average case, but not in\nthe discounted-sum case. Third, for quantitative languages $L_1$ and~$L_2$, we\nconsider the operations $\\max(L_1,L_2)$, $\\min(L_1,L_2)$, and -L_1$, which\ngeneralize the boolean operations on languages, as well as the sum $L_1 + L_2$.\nWe establish the closure properties of all classes of quantitative languages\nwith respect to these four operations.\n", "versions": [{"version": "v1", "created": "Thu, 22 Jul 2010 22:13:12 GMT"}, {"version": "v2", "created": "Thu, 2 Sep 2010 04:25:26 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Chatterjee", "Krishnendu", "", "IST Austria"], ["Doyen", "Laurent", "", "CNRS France"], ["Henzinger", "Thomas A", "", "IST Austria and EPFL Switzerland"]]}, {"id": "1007.4028", "submitter": "Mario Alviano", "authors": "Mario Alviano, Wolfgang Faber and Nicola Leone", "title": "Disjunctive ASP with Functions: Decidable Queries and Effective\n  Computation", "comments": "16 pages, 1 figure", "journal-ref": "Theory and Practice of Logic Programming, 10(4-6): 497-512, 2010", "doi": "10.1017/S1471068410000244", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Querying over disjunctive ASP with functions is a highly undecidable task in\ngeneral. In this paper we focus on disjunctive logic programs with stratified\nnegation and functions under the stable model semantics (ASP^{fs}). We show\nthat query answering in this setting is decidable, if the query is finitely\nrecursive (ASP^{fs}_{fr}). Our proof yields also an effective method for query\nevaluation. It is done by extending the magic set technique to ASP^{fs}_{fr}.\nWe show that the magic-set rewritten program is query equivalent to the\noriginal one (under both brave and cautious reasoning). Moreover, we prove that\nthe rewritten program is also finitely ground, implying that it is decidable.\nImportantly, finitely ground programs are evaluable using existing ASP solvers,\nmaking the class of ASP^{fs}_{fr} queries usable in practice.\n", "versions": [{"version": "v1", "created": "Thu, 22 Jul 2010 23:54:51 GMT"}], "update_date": "2010-07-26", "authors_parsed": [["Alviano", "Mario", ""], ["Faber", "Wolfgang", ""], ["Leone", "Nicola", ""]]}, {"id": "1007.4040", "submitter": "Yisong Wang", "authors": "Yisong Wang and Jia-Huai You and Li Yan Yuan and Yi-Dong Shen", "title": "Loop Formulas for Description Logic Programs", "comments": "29 pages, 1 figures (in pdf), a short version appeared in ICLP'10", "journal-ref": "yisong Wang, Jia-Huai You, Li-Yan Yuan, Yi-Dong Shen: Loop\n  formulas for description logic programs. TPLP 10(4-6): 531-545 (2010)", "doi": "10.1017/S1471068410000268", "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Description Logic Programs (dl-programs) proposed by Eiter et al. constitute\nan elegant yet powerful formalism for the integration of answer set programming\nwith description logics, for the Semantic Web. In this paper, we generalize the\nnotions of completion and loop formulas of logic programs to description logic\nprograms and show that the answer sets of a dl-program can be precisely\ncaptured by the models of its completion and loop formulas. Furthermore, we\npropose a new, alternative semantics for dl-programs, called the {\\em canonical\nanswer set semantics}, which is defined by the models of completion that\nsatisfy what are called canonical loop formulas. A desirable property of\ncanonical answer sets is that they are free of circular justifications. Some\nproperties of canonical answer sets are also explored.\n", "versions": [{"version": "v1", "created": "Fri, 23 Jul 2010 04:48:19 GMT"}], "update_date": "2010-07-26", "authors_parsed": [["Wang", "Yisong", ""], ["You", "Jia-Huai", ""], ["Yuan", "Li Yan", ""], ["Shen", "Yi-Dong", ""]]}, {"id": "1007.4114", "submitter": "Christian Drescher", "authors": "Christian Drescher and Toby Walsh", "title": "A Translational Approach to Constraint Answer Set Solving", "comments": "17 pages", "journal-ref": "Theory and Practice of Logic Programming, 10(4-6), 465-480, 2010", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new approach to enhancing Answer Set Programming (ASP) with\nConstraint Processing techniques which allows for solving interesting\nConstraint Satisfaction Problems in ASP. We show how constraints on finite\ndomains can be decomposed into logic programs such that unit-propagation\nachieves arc, bound or range consistency. Experiments with our encodings\ndemonstrate their computational impact.\n", "versions": [{"version": "v1", "created": "Fri, 23 Jul 2010 12:37:00 GMT"}], "update_date": "2010-07-26", "authors_parsed": [["Drescher", "Christian", ""], ["Walsh", "Toby", ""]]}, {"id": "1007.4157", "submitter": "Valerio Senni", "authors": "Alberto Pettorossi, Maurizio Proietti, and Valerio Senni", "title": "Transformations of Logic Programs on Infinite Lists", "comments": "37 pages, including the appendix with proofs. This is an extended\n  version of a paper published in Theory and Practice of Logic Programming, see\n  below", "journal-ref": "Theory and Practice of Logic Programming, Volume 10, Special Issue\n  4-6, 383-399, 2010", "doi": "10.1017/S1471068410000177", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider an extension of logic programs, called \\omega-programs, that can\nbe used to define predicates over infinite lists. \\omega-programs allow us to\nspecify properties of the infinite behavior of reactive systems and, in\ngeneral, properties of infinite sequences of events. The semantics of\n\\omega-programs is an extension of the perfect model semantics. We present\nvariants of the familiar unfold/fold rules which can be used for transforming\n\\omega-programs. We show that these new rules are correct, that is, their\napplication preserves the perfect model semantics. Then we outline a general\nmethodology based on program transformation for verifying properties of\n\\omega-programs. We demonstrate the power of our transformation-based\nverification methodology by proving some properties of Buechi automata and\n\\omega-regular languages.\n", "versions": [{"version": "v1", "created": "Fri, 23 Jul 2010 15:29:40 GMT"}], "update_date": "2010-07-26", "authors_parsed": [["Pettorossi", "Alberto", ""], ["Proietti", "Maurizio", ""], ["Senni", "Valerio", ""]]}, {"id": "1007.4172", "submitter": "Kirstin Peters", "authors": "Kirstin Peters and Uwe Nestmann", "title": "Breaking Symmetries", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A well-known result by Palamidessi tells us that {\\pi}mix (the {\\pi}-calculus\nwith mixed choice) is more expressive than {\\pi}sep (its subset with only\nseparate choice). The proof of this result argues with their different\nexpressive power concerning leader election in symmetric networks. Later on,\nGorla of- fered an arguably simpler proof that, instead of leader election in\nsymmetric networks, employed the reducibility of \"incestual\" processes (mixed\nchoices that include both enabled senders and receivers for the same channel)\nwhen running two copies in parallel. In both proofs, the role of breaking (ini-\ntial) symmetries is more or less apparent. In this paper, we shed more light on\nthis role by re-proving the above result-based on a proper formalization of\nwhat it means to break symmetries-without referring to another layer of the\ndistinguishing problem domain of leader election.\n  Both Palamidessi and Gorla rephrased their results by stating that there is\nno uniform and reason- able encoding from {\\pi}mix into {\\pi}sep . We indicate\nhow the respective proofs can be adapted and exhibit the consequences of\nvarying notions of uniformity and reasonableness. In each case, the ability to\nbreak initial symmetries turns out to be essential.\n", "versions": [{"version": "v1", "created": "Fri, 23 Jul 2010 16:45:45 GMT"}], "update_date": "2010-07-26", "authors_parsed": [["Peters", "Kirstin", ""], ["Nestmann", "Uwe", ""]]}, {"id": "1007.4266", "submitter": "Makoto Hamana", "authors": "Makoto Hamana (Gunma Univesity)", "title": "Initial Algebra Semantics for Cyclic Sharing Tree Structures", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (September\n  3, 2010) lmcs:1060", "doi": "10.2168/LMCS-6(3:15)2010", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Terms are a concise representation of tree structures. Since they can be\nnaturally defined by an inductive type, they offer data structures in\nfunctional programming and mechanised reasoning with useful principles such as\nstructural induction and structural recursion. However, for graphs or\n\"tree-like\" structures - trees involving cycles and sharing - it remains\nunclear what kind of inductive structures exists and how we can faithfully\nassign a term representation of them. In this paper we propose a simple term\nsyntax for cyclic sharing structures that admits structural induction and\nrecursion principles. We show that the obtained syntax is directly usable in\nthe functional language Haskell and the proof assistant Agda, as well as\nordinary data structures such as lists and trees. To achieve this goal, we use\na categorical approach to initial algebra semantics in a presheaf category.\nThat approach follows the line of Fiore, Plotkin and Turi's models of abstract\nsyntax with variable binding.\n", "versions": [{"version": "v1", "created": "Sat, 24 Jul 2010 11:12:56 GMT"}, {"version": "v2", "created": "Fri, 3 Sep 2010 10:37:02 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Hamana", "Makoto", "", "Gunma Univesity"]]}, {"id": "1007.4476", "submitter": "Jacopo Mauro", "authors": "Maurizio Gabbrielli abd Jacopo Mauro and Maria Chiara Meo and Jon\n  Sneyers", "title": "Decidability properties for fragments of CHR", "comments": null, "journal-ref": "Theory and Practice of Logic Programming, volume 10, number 4-6,\n  year 2010, pages 611-626", "doi": "10.1017/S1471068410000311", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the decidability of termination for two CHR dialects which,\nsimilarly to the Datalog like languages, are defined by using a signature which\ndoes not allow function symbols (of arity >0). Both languages allow the use of\nthe = built-in in the body of rules, thus are built on a host language that\nsupports unification. However each imposes one further restriction. The first\nCHR dialect allows only range-restricted rules, that is, it does not allow the\nuse of variables in the body or in the guard of a rule if they do not appear in\nthe head. We show that the existence of an infinite computation is decidable\nfor this dialect. The second dialect instead limits the number of atoms in the\nhead of rules to one. We prove that in this case, the existence of a\nterminating computation is decidable. These results show that both dialects are\nstrictly less expressive than Turing Machines. It is worth noting that the\nlanguage (without function symbols) without these restrictions is as expressive\nas Turing Machines.\n", "versions": [{"version": "v1", "created": "Mon, 26 Jul 2010 14:50:36 GMT"}], "update_date": "2010-07-27", "authors_parsed": [["Mauro", "Maurizio Gabbrielli abd Jacopo", ""], ["Meo", "Maria Chiara", ""], ["Sneyers", "Jon", ""]]}, {"id": "1007.4764", "submitter": "Benedikt Bollig", "authors": "Benedikt Bollig (LSV, ENS Cachan, CNRS), Dietrich Kuske (Institut\n  f\\\"ur Informatik, Universit\\\"at Leipzig), Ingmar Meinecke (Institut f\\\"ur\n  Informatik, Universit\\\"at Leipzig)", "title": "Propositional Dynamic Logic for Message-Passing Systems", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 3 (September\n  4, 2010) lmcs:1057", "doi": "10.2168/LMCS-6(3:16)2010", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We examine a bidirectional propositional dynamic logic (PDL) for finite and\ninfinite message sequence charts (MSCs) extending LTL and TLC-. By this kind of\nmulti-modal logic we can express properties both in the entire future and in\nthe past of an event. Path expressions strengthen the classical until operator\nof temporal logic. For every formula defining an MSC language, we construct a\ncommunicating finite-state machine (CFM) accepting the same language. The CFM\nobtained has size exponential in the size of the formula. This synthesis\nproblem is solved in full generality, i.e., also for MSCs with unbounded\nchannels. The model checking problem for CFMs and HMSCs turns out to be in\nPSPACE for existentially bounded MSCs. Finally, we show that, for PDL with\nintersection, the semantics of a formula cannot be captured by a CFM anymore.\n", "versions": [{"version": "v1", "created": "Tue, 27 Jul 2010 16:11:01 GMT"}, {"version": "v2", "created": "Sat, 4 Sep 2010 09:38:32 GMT"}, {"version": "v3", "created": "Tue, 7 Sep 2010 09:58:54 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Bollig", "Benedikt", "", "LSV, ENS Cachan, CNRS"], ["Kuske", "Dietrich", "", "Institut\n  f\u00fcr Informatik, Universit\u00e4t Leipzig"], ["Meinecke", "Ingmar", "", "Institut f\u00fcr\n  Informatik, Universit\u00e4t Leipzig"]]}, {"id": "1007.4767", "submitter": "Marcello Balduccini", "authors": "Marcello Balduccini and Sara Girotto", "title": "Formalization of Psychological Knowledge in Answer Set Programming and\n  its Application", "comments": "26th Int'l. Conference on Logic Programming (ICLP'10)", "journal-ref": "Theory and Practice of Logic Programming, 10(4-6), 725-740, 2010", "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we explore the use of Answer Set Programming (ASP) to\nformalize, and reason about, psychological knowledge. In the field of\npsychology, a considerable amount of knowledge is still expressed using only\nnatural language. This lack of a formalization complicates accurate studies,\ncomparisons, and verification of theories. We believe that ASP, a knowledge\nrepresentation formalism allowing for concise and simple representation of\ndefaults, uncertainty, and evolving domains, can be used successfully for the\nformalization of psychological knowledge. To demonstrate the viability of ASP\nfor this task, in this paper we develop an ASP-based formalization of the\nmechanics of Short-Term Memory. We also show that our approach can have rather\nimmediate practical uses by demonstrating an application of our formalization\nto the task of predicting a user's interaction with a graphical interface.\n", "versions": [{"version": "v1", "created": "Tue, 27 Jul 2010 16:33:33 GMT"}, {"version": "v2", "created": "Thu, 10 Feb 2011 14:28:48 GMT"}], "update_date": "2011-02-11", "authors_parsed": [["Balduccini", "Marcello", ""], ["Girotto", "Sara", ""]]}, {"id": "1007.4908", "submitter": "J\\\"urgen Giesl", "authors": "Peter Schneider-Kamp, J\\\"urgen Giesl, Thomas Str\\\"oder, Alexander\n  Serebrenik, Ren\\'e Thiemann", "title": "Automated Termination Analysis for Logic Programs with Cut", "comments": null, "journal-ref": "Theory and Practice of Logic Programming, 10(4-6), 365-381, 2010", "doi": "10.1017/S1471068410000165", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Termination is an important and well-studied property for logic programs.\nHowever, almost all approaches for automated termination analysis focus on\ndefinite logic programs, whereas real-world Prolog programs typically use the\ncut operator. We introduce a novel pre-processing method which automatically\ntransforms Prolog programs into logic programs without cuts, where termination\nof the cut-free program implies termination of the original program. Hence\nafter this pre-processing, any technique for proving termination of definite\nlogic programs can be applied. We implemented this pre-processing in our\ntermination prover AProVE and evaluated it successfully with extensive\nexperiments.\n", "versions": [{"version": "v1", "created": "Wed, 28 Jul 2010 09:27:52 GMT"}], "update_date": "2010-07-29", "authors_parsed": [["Schneider-Kamp", "Peter", ""], ["Giesl", "J\u00fcrgen", ""], ["Str\u00f6der", "Thomas", ""], ["Serebrenik", "Alexander", ""], ["Thiemann", "Ren\u00e9", ""]]}, {"id": "1007.4971", "submitter": "Johannes Oetsch", "authors": "Johannes Oetsch, J\\\"org P\\\"uhrer, Martin Schwengerer, and Hans Tompits", "title": "The System Kato: Detecting Cases of Plagiarism for Answer-Set Programs", "comments": null, "journal-ref": "Theory and Practice of Logic Programming, Volume 10, Special Issue\n  4-6, July 2010, pp 759-775", "doi": "10.1017/S1471068410000402", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Plagiarism detection is a growing need among educational institutions and\nsolutions for different purposes exist. An important field in this direction is\ndetecting cases of source-code plagiarism. In this paper, we present the tool\nKato for supporting the detection of this kind of plagiarism in the area of\nanswer-set programming (ASP). Currently, the tool is implemented for DLV\nprograms but it is designed to handle other logic-programming dialects as well.\nWe review the basic features of Kato, introduce its theoretical underpinnings,\nand discuss an application of Kato for plagiarism detection in the context of\ncourses on logic programming at the Vienna University of Technology.\n", "versions": [{"version": "v1", "created": "Wed, 28 Jul 2010 13:43:10 GMT"}], "update_date": "2010-07-29", "authors_parsed": [["Oetsch", "Johannes", ""], ["P\u00fchrer", "J\u00f6rg", ""], ["Schwengerer", "Martin", ""], ["Tompits", "Hans", ""]]}, {"id": "1007.4993", "submitter": "EPTCS", "authors": "MohammadReza Mousavi (Eindhoven University of Technology), Gwen\n  Sala\\\"un (INRIA Grenoble - Rhone-Alpes)", "title": "Proceedings Ninth International Workshop on the Foundations of\n  Coordination Languages and Software Architectures", "comments": null, "journal-ref": "EPTCS 30, 2010", "doi": "10.4204/EPTCS.30", "report-no": null, "categories": "cs.SE cs.DC cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of FOCLASA 2010, the 9th International\nWorkshop on the Foundations of Coordination Languages and Software\nArchitectures. FOCLASA 2010 was held in Paris, France on July 30th, 2010 as a\nsatellite event of the 21st International Conference on Concurrency Theory,\nCONCUR 2010. The papers presented in this proceedings tackle different issues\nthat are currently central to our community, namely software adaptation, sensor\nnetworks, distributed control, non-functional aspects of coordination such as\nresources, timing and stochastics.\n", "versions": [{"version": "v1", "created": "Wed, 28 Jul 2010 14:39:30 GMT"}], "update_date": "2010-07-29", "authors_parsed": [["Mousavi", "MohammadReza", "", "Eindhoven University of Technology"], ["Sala\u00fcn", "Gwen", "", "INRIA Grenoble - Rhone-Alpes"]]}, {"id": "1007.5091", "submitter": "EPTCS", "authors": "Maryam Kamali (IT-Department, Abo Akademi University), Linas Laibinis\n  (IT-Department, Abo Akademi University), Luigia Petre (IT-Department, Abo\n  Akademi University), Kaisa Sere (IT-Department, Abo Akademi University)", "title": "Self-Recovering Sensor-Actor Networks", "comments": "In Proceedings FOCLASA 2010, arXiv:1007.4993", "journal-ref": "EPTCS 30, 2010, pp. 47-61", "doi": "10.4204/EPTCS.30.4", "report-no": null, "categories": "cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Wireless sensor-actor networks are a recent development of wireless networks\nwhere both ordinary sensor nodes and more sophisticated and powerful nodes,\ncalled actors, are present. In this paper we formalize a recently introduced\nalgorithm that recovers failed actor communication links via the existing\nsensor infrastructure. We prove via refinement that the recovery is terminating\nin a finite number of steps and is distributed, thus self-performed by the\nactors. Most importantly, we prove that the recovery can be done at different\nlevels, via different types of links, such as direct actor links or indirect\nlinks between the actors, in the latter case reusing the wireless\ninfrastructure of sensors. This leads to identifying coordination classes,\ne.g., for delegating the most security sensitive coordination to the direct\nactor-actor coordination links, the least real-time constrained coordination to\nindirect links, and the safety critical coordination to both direct actor links\nand indirect sensor paths between actors. Our formalization is done using the\ntheorem prover in the RODIN platform.\n", "versions": [{"version": "v1", "created": "Thu, 29 Jul 2010 00:12:52 GMT"}], "update_date": "2010-07-30", "authors_parsed": [["Kamali", "Maryam", "", "IT-Department, Abo Akademi University"], ["Laibinis", "Linas", "", "IT-Department, Abo Akademi University"], ["Petre", "Luigia", "", "IT-Department, Abo\n  Akademi University"], ["Sere", "Kaisa", "", "IT-Department, Abo Akademi University"]]}, {"id": "1007.5095", "submitter": "EPTCS", "authors": "Mohammad Mahdi Jaghoori (LIACS and CWI), Tom Chothia (University of\n  Birmingham)", "title": "Timed Automata Semantics for Analyzing Creol", "comments": "In Proceedings FOCLASA 2010, arXiv:1007.4993", "journal-ref": "EPTCS 30, 2010, pp. 108-122", "doi": "10.4204/EPTCS.30.8", "report-no": null, "categories": "cs.LO cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give a real-time semantics for the concurrent, object-oriented modeling\nlanguage Creol, by mapping Creol processes to a network of timed automata. We\ncan use our semantics to verify real time properties of Creol objects, in\nparticular to see whether processes can be scheduled correctly and meet their\nend-to-end deadlines. Real-time Creol can be useful for analyzing, for\ninstance, abstract models of multi-core embedded systems. We show how analysis\ncan be done in Uppaal.\n", "versions": [{"version": "v1", "created": "Thu, 29 Jul 2010 00:13:14 GMT"}], "update_date": "2010-07-30", "authors_parsed": [["Jaghoori", "Mohammad Mahdi", "", "LIACS and CWI"], ["Chothia", "Tom", "", "University of\n  Birmingham"]]}, {"id": "1007.5188", "submitter": "Yuxin Deng", "authors": "Yuxin Deng and Rob van Glabbeek", "title": "Characterising Probabilistic Processes Logically", "comments": "18 pages", "journal-ref": null, "doi": "10.1007/978-3-642-16242-8_20", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we work on (bi)simulation semantics of processes that exhibit\nboth nondeterministic and probabilistic behaviour. We propose a probabilistic\nextension of the modal mu-calculus and show how to derive characteristic\nformulae for various simulation-like preorders over finite-state processes\nwithout divergence. In addition, we show that even without the fixpoint\noperators this probabilistic mu-calculus can be used to characterise these\nbehavioural relations in the sense that two states are equivalent if and only\nif they satisfy the same set of formulae.\n", "versions": [{"version": "v1", "created": "Thu, 29 Jul 2010 11:37:15 GMT"}], "update_date": "2015-05-19", "authors_parsed": [["Deng", "Yuxin", ""], ["van Glabbeek", "Rob", ""]]}, {"id": "1007.5249", "submitter": "Alexander Shen", "authors": "Laurent Bienvenu, Adam Day, Mathieu Hoyrup, Ilya Mezhirov, Alexander\n  Shen", "title": "A constructive version of Birkhoff's ergodic theorem for Martin-L\\\"of\n  random points", "comments": "Improved version of the CiE'10 paper, with the strong form of\n  Birkhoff's ergodic theorem for random points", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.DS cs.LO math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A theorem of Ku\\v{c}era states that given a Martin-L\\\"of random infinite\nbinary sequence {\\omega} and an effectively open set A of measure less than 1,\nsome tail of {\\omega} is not in A. We first prove several results in the same\nspirit and generalize them via an effective version of a weak form of\nBirkhoff's ergodic theorem. We then use this result to get a stronger form of\nit, namely a very general effective version of Birkhoff's ergodic theorem,\nwhich improves all the results previously obtained in this direction, in\nparticular those of V'Yugin, Nandakumar and Hoyrup, Rojas.\n", "versions": [{"version": "v1", "created": "Thu, 29 Jul 2010 15:32:54 GMT"}, {"version": "v2", "created": "Fri, 5 Aug 2011 03:39:13 GMT"}], "update_date": "2011-08-08", "authors_parsed": [["Bienvenu", "Laurent", ""], ["Day", "Adam", ""], ["Hoyrup", "Mathieu", ""], ["Mezhirov", "Ilya", ""], ["Shen", "Alexander", ""]]}, {"id": "1007.5421", "submitter": "Matthieu Petit", "authors": "Henning Christiansen, Christian Theil Have, Ole Torp Lassen and\n  Matthieu Petit", "title": "Inference with Constrained Hidden Markov Models in PRISM", "comments": null, "journal-ref": "TPLP 2010, 10 (4-6) 449-464", "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A Hidden Markov Model (HMM) is a common statistical model which is widely\nused for analysis of biological sequence data and other sequential phenomena.\nIn the present paper we show how HMMs can be extended with side-constraints and\npresent constraint solving techniques for efficient inference. Defining HMMs\nwith side-constraints in Constraint Logic Programming have advantages in terms\nof more compact expression and pruning opportunities during inference.\n  We present a PRISM-based framework for extending HMMs with side-constraints\nand show how well-known constraints such as cardinality and all different are\nintegrated. We experimentally validate our approach on the biologically\nmotivated problem of global pairwise alignment.\n", "versions": [{"version": "v1", "created": "Fri, 30 Jul 2010 11:55:05 GMT"}], "update_date": "2010-08-02", "authors_parsed": [["Christiansen", "Henning", ""], ["Have", "Christian Theil", ""], ["Lassen", "Ole Torp", ""], ["Petit", "Matthieu", ""]]}, {"id": "1007.5488", "submitter": "Rob van Glabbeek", "authors": "Rob van Glabbeek and Gordon Plotkin", "title": "On CSP and the Algebraic Theory of Effects", "comments": null, "journal-ref": null, "doi": "10.1007/978-1-84882-912-1_15", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider CSP from the point of view of the algebraic theory of effects,\nwhich classifies operations as effect constructors or effect deconstructors; it\nalso provides a link with functional programming, being a refinement of Moggi's\nseminal monadic point of view. There is a natural algebraic theory of the\nconstructors whose free algebra functor is Moggi's monad; we illustrate this by\ncharacterising free and initial algebras in terms of two versions of the stable\nfailures model of CSP, one more general than the other. Deconstructors are\ndealt with as homomorphisms to (possibly non-free) algebras.\n  One can view CSP's action and choice operators as constructors and the rest,\nsuch as concealment and concurrency, as deconstructors. Carrying this programme\nout results in taking deterministic external choice as constructor rather than\ngeneral external choice. However, binary deconstructors, such as the CSP\nconcurrency operator, provide unresolved difficulties. We conclude by\npresenting a combination of CSP with Moggi's computational {\\lambda}-calculus,\nin which the operators, including concurrency, are polymorphic. While the paper\nmainly concerns CSP, it ought to be possible to carry over similar ideas to\nother process calculi.\n", "versions": [{"version": "v1", "created": "Fri, 30 Jul 2010 16:19:23 GMT"}], "update_date": "2015-05-19", "authors_parsed": [["van Glabbeek", "Rob", ""], ["Plotkin", "Gordon", ""]]}, {"id": "1007.5491", "submitter": "Rob van Glabbeek", "authors": "Rob van Glabbeek", "title": "The Coarsest Precongruences Respecting Safety and Liveness Properties", "comments": "2018: A reference to Lamport has been corrected into one to Alpern &\n  Schneider", "journal-ref": "Proceedings TCS 2010, IFIP AICT 323, September 2010 (C.S. Calude &\n  V. Sassone, eds.), Springer, pp. 32-52", "doi": "10.1007/978-3-642-15240-5_3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper characterises the coarsest refinement preorders on labelled\ntransition systems that are precongruences for renaming and partially\nsynchronous interleaving operators, and respect all safety, liveness, and\nconditional liveness properties, respectively.\n", "versions": [{"version": "v1", "created": "Fri, 30 Jul 2010 16:34:46 GMT"}, {"version": "v2", "created": "Fri, 28 Dec 2018 12:46:22 GMT"}], "update_date": "2018-12-31", "authors_parsed": [["van Glabbeek", "Rob", ""]]}]