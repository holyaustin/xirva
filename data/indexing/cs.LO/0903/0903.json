[{"id": "0903.0422", "submitter": "Hirotaka Ono", "authors": "Kazuhisa Makino and Hirotaka Ono", "title": "Deductive Inference for the Interiors and Exteriors of Horn Theories", "comments": "20 pages, 1 figure, An extended abstract of this article was\n  presented in Proceedings of Algorithms and Computation, 19th International\n  Symposium (ISAAC 2008), Lecture Notes in Computer Science, Vol. 5369, pp.\n  390-401, Springer-Verlag Berlin Heidelberg, 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.CC cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we investigate the deductive inference for the interiors and\nexteriors of Horn knowledge bases, where the interiors and exteriors were\nintroduced by Makino and Ibaraki to study stability properties of knowledge\nbases. We present a linear time algorithm for the deduction for the interiors\nand show that it is co-NP-complete for the deduction for the exteriors. Under\nmodel-based representation, we show that the deduction problem for interiors is\nNP-complete while the one for exteriors is co-NP-complete. As for Horn\nenvelopes of the exteriors, we show that it is linearly solvable under\nmodel-based representation, while it is co-NP-complete under formula-based\nrepresentation. We also discuss the polynomially solvable cases for all the\nintractable problems.\n", "versions": [{"version": "v1", "created": "Tue, 3 Mar 2009 01:58:52 GMT"}], "update_date": "2009-03-04", "authors_parsed": [["Makino", "Kazuhisa", ""], ["Ono", "Hirotaka", ""]]}, {"id": "0903.0843", "submitter": "Jordi Planes", "authors": "Vasco Manquinho and Joao Marques-Silva and Jordi Planes", "title": "Algorithms for Weighted Boolean Optimization", "comments": "14 pages, 2 algorithms, 3 tables, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  The Pseudo-Boolean Optimization (PBO) and Maximum Satisfiability (MaxSAT)\nproblems are natural optimization extensions of Boolean Satisfiability (SAT).\n  In the recent past, different algorithms have been proposed for PBO and for\nMaxSAT, despite the existence of straightforward mappings from PBO to MaxSAT\nand vice-versa. This papers proposes Weighted Boolean Optimization (WBO), a new\nunified framework that aggregates and extends PBO and MaxSAT. In addition, the\npaper proposes a new unsatisfiability-based algorithm for WBO, based on recent\nunsatisfiability-based algorithms for MaxSAT. Besides standard MaxSAT, the new\nalgorithm can also be used to solve weighted MaxSAT and PBO, handling\npseudo-Boolean constraints either natively or by translation to clausal form.\nExperimental results illustrate that unsatisfiability-based algorithms for\nMaxSAT can be orders of magnitude more efficient than existing dedicated\nalgorithms. Finally, the paper illustrates how other algorithms for either PBO\nor MaxSAT can be extended to WBO.\n", "versions": [{"version": "v1", "created": "Wed, 4 Mar 2009 20:21:56 GMT"}, {"version": "v2", "created": "Fri, 6 Mar 2009 09:18:32 GMT"}], "update_date": "2009-03-06", "authors_parsed": [["Manquinho", "Vasco", ""], ["Marques-Silva", "Joao", ""], ["Planes", "Jordi", ""]]}, {"id": "0903.1032", "submitter": "Mohammad  Raza", "authors": "Mohammad Raza and Philippa Gardner", "title": "Footprints in Local Reasoning", "comments": "LMCS 2009 (FOSSACS 2008 special issue)", "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 2 (April 24,\n  2009) lmcs:1118", "doi": "10.2168/LMCS-5(2:4)2009", "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Local reasoning about programs exploits the natural local behaviour common in\nprograms by focussing on the footprint - that part of the resource accessed by\nthe program. We address the problem of formally characterising and analysing\nthe footprint notion for abstract local functions introduced by Calcagno, O\nHearn and Yang. With our definition, we prove that the footprints are the only\nessential elements required for a complete specification of a local function.\nWe formalise the notion of small specifications in local reasoning and show\nthat for well-founded resource models, a smallest specification always exists\nthat only includes the footprints, and also present results for the\nnon-well-founded case. Finally, we use this theory of footprints to investigate\nthe conditions under which the footprints correspond to the smallest safe\nstates. We present a new model of RAM in which, unlike the standard model, the\nfootprints of every program correspond to the smallest safe states, and we also\nidentify a general condition on the primitive commands of a programming\nlanguage which guarantees this property for arbitrary models.\n", "versions": [{"version": "v1", "created": "Thu, 5 Mar 2009 17:06:05 GMT"}, {"version": "v2", "created": "Fri, 24 Apr 2009 17:59:14 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Raza", "Mohammad", ""], ["Gardner", "Philippa", ""]]}, {"id": "0903.1196", "submitter": "Inge Bethke", "authors": "Inge Bethke, Piet Rodenburg and Arjen Sevenster", "title": "The structure of finite meadows", "comments": "12 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A meadow is a commutative ring with a total inverse operator satisfying\n0^{-1}=0. We show that the class of finite meadows is the closure of the class\nof Galois fields under finite products. As a corollary, we obtain a unique\nrepresentation of minimal finite meadows in terms of finite prime fields.\n", "versions": [{"version": "v1", "created": "Fri, 6 Mar 2009 12:08:55 GMT"}], "update_date": "2009-03-09", "authors_parsed": [["Bethke", "Inge", ""], ["Rodenburg", "Piet", ""], ["Sevenster", "Arjen", ""]]}, {"id": "0903.1374", "submitter": "Benedetto Intrigila", "authors": "Benedetto Intrigila and Richard Statman", "title": "The Omega Rule is $\\mathbf{\\Pi_{1}^{1}}$-Complete in the\n  $\\lambda\\beta$-Calculus", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 2 (April 27,\n  2009) lmcs:1147", "doi": "10.2168/LMCS-5(2:6)2009", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a functional calculus, the so called \\Omega-rule states that if two terms\nP and Q applied to any closed term <i>N</i> return the same value (i.e. PN =\nQN), then they are equal (i.e. P = Q holds). As it is well known, in the\n\\lambda\\beta-calculus the \\Omega-rule does not hold, even when the \\eta-rule\n(weak extensionality) is added to the calculus. A long-standing problem of H.\nBarendregt (1975) concerns the determination of the logical power of the\n\\Omega-rule when added to the \\lambda\\beta-calculus. In this paper we solve the\nproblem, by showing that the resulting theory is \\Pi\\_{1}^{1}-complete.\n", "versions": [{"version": "v1", "created": "Sat, 7 Mar 2009 23:20:09 GMT"}, {"version": "v2", "created": "Mon, 27 Apr 2009 15:49:47 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Intrigila", "Benedetto", ""], ["Statman", "Richard", ""]]}, {"id": "0903.1822", "submitter": "Jose Espirito Santo", "authors": "Jose Espirito Santo, Ralph Matthes, Luis Pinto", "title": "Continuation-Passing Style and Strong Normalisation for Intuitionistic\n  Sequent Calculi", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 2 (May 25,\n  2009) lmcs:1149", "doi": "10.2168/LMCS-5(2:11)2009", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The intuitionistic fragment of the call-by-name version of Curien and\nHerbelin's \\lambda\\_mu\\_{\\~mu}-calculus is isolated and proved strongly\nnormalising by means of an embedding into the simply-typed lambda-calculus. Our\nembedding is a continuation-and-garbage-passing style translation, the\ninspiring idea coming from Ikeda and Nakazawa's translation of Parigot's\n\\lambda\\_mu-calculus. The embedding strictly simulates reductions while usual\ncontinuation-passing-style transformations erase permutative reduction steps.\nFor our intuitionistic sequent calculus, we even only need \"units of garbage\"\nto be passed. We apply the same method to other calculi, namely successive\nextensions of the simply-typed &lambda;-calculus leading to our intuitionistic\nsystem, and already for the simplest extension we consider (&lambda;-calculus\nwith generalised application), this yields the first proof of strong\nnormalisation through a reduction-preserving embedding. The results obtained\nextend to second and higher-order calculi.\n", "versions": [{"version": "v1", "created": "Tue, 10 Mar 2009 18:10:52 GMT"}, {"version": "v2", "created": "Mon, 25 May 2009 12:35:06 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Santo", "Jose Espirito", ""], ["Matthes", "Ralph", ""], ["Pinto", "Luis", ""]]}, {"id": "0903.2177", "submitter": "Arno Pauly", "authors": "Arno Pauly", "title": "On the (semi)lattices induced by continuous reducibilities", "comments": "this version of the paper is outdated, please consult the journal\n  version", "journal-ref": "Mathematical Logic Quarterly, 56(5): 488--502, 2010", "doi": "10.1002/malq.200910104", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Continuous reducibilities are a proven tool in computable analysis, and have\napplications in other fields such as constructive mathematics or reverse\nmathematics. We study the order-theoretic properties of several variants of the\ntwo most important definitions, and especially introduce suprema for them. The\nsuprema are shown to commutate with several characteristic numbers.\n", "versions": [{"version": "v1", "created": "Thu, 12 Mar 2009 14:34:47 GMT"}, {"version": "v2", "created": "Thu, 21 Oct 2010 11:18:02 GMT"}], "update_date": "2010-10-22", "authors_parsed": [["Pauly", "Arno", ""]]}, {"id": "0903.2188", "submitter": "Damiano Zanardini", "authors": "Victor Pablos Ceruelo and Susana Munoz-Hernandez and Hannes Strass", "title": "Rfuzzy framework", "comments": "Paper presented at the 18th Workshop on Logic-based Methods in\n  Programming Environments (WLPE2008) (Report-No: WLPE/2008). Paper submitted\n  by a co-editor of the Workshop proceedings", "journal-ref": null, "doi": null, "report-no": "WLPE/2008/01", "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Fuzzy reasoning is a very productive research field that during the last\nyears has provided a number of theoretical approaches and practical\nimplementation prototypes. Nevertheless, the classical implementations, like\nFril, are not adapted to the latest formal approaches, like multi-adjoint logic\nsemantics. Some promising implementations, like Fuzzy Prolog, are so general\nthat the regular user/programmer does not feel comfortable because either\nrepresentation of fuzzy concepts is complex or the results difficult to\ninterpret. In this paper we present a modern framework, Rfuzzy, that is\nmodelling multi-adjoint logic. It provides some extensions as default values\n(to represent missing information, even partial default values) and typed\nvariables. Rfuzzy represents the truth value of predicates through facts, rules\nand functions. Rfuzzy answers queries with direct results (instead of\nconstraints) and it is easy to use for any person that wants to represent a\nproblem using fuzzy reasoning in a simple way (by using the classical\nrepresentation with real numbers).\n", "versions": [{"version": "v1", "created": "Thu, 12 Mar 2009 15:20:19 GMT"}], "update_date": "2009-03-13", "authors_parsed": [["Ceruelo", "Victor Pablos", ""], ["Munoz-Hernandez", "Susana", ""], ["Strass", "Hannes", ""]]}, {"id": "0903.2251", "submitter": "Damiano Zanardini", "authors": "Adrian Prantl and Jens Knoop and Markus Schordan and Markus Triska", "title": "Constraint solving for high-level WCET analysis", "comments": "Paper presented at the 18th Workshop on Logic-based Methods in\n  Programming Environments (WLPE2008) (Report-No: WLPE/2008). Paper submitted\n  by a co-editor of the Workshop proceedings", "journal-ref": null, "doi": null, "report-no": "WLPE/2008/05", "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The safety of our day-to-day life depends crucially on the correct\nfunctioning of embedded software systems which control the functioning of more\nand more technical devices. Many of these software systems are time-critical.\nHence, computations performed need not only to be correct, but must also be\nissued in a timely fashion. Worst case execution time (WCET) analysis is\nconcerned with computing tight upper bounds for the execution time of a system\nin order to provide formal guarantees for the proper timing behaviour of a\nsystem. Central for this is to compute safe and tight bounds for loops and\nrecursion depths. In this paper, we highlight the TuBound approach to this\nchallenge at whose heart is a constraint logic based approach for loop\nanalysis.\n", "versions": [{"version": "v1", "created": "Thu, 12 Mar 2009 15:45:50 GMT"}], "update_date": "2009-03-13", "authors_parsed": [["Prantl", "Adrian", ""], ["Knoop", "Jens", ""], ["Schordan", "Markus", ""], ["Triska", "Markus", ""]]}, {"id": "0903.2410", "submitter": "Jean-Yves Marion", "authors": "Jean-Yves Marion", "title": "On tiered small jump operators", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 1 (March 31,\n  2009) lmcs:1146", "doi": "10.2168/LMCS-5(1:7)2009", "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Predicative analysis of recursion schema is a method to characterize\ncomplexity classes like the class FPTIME of polynomial time computable\nfunctions. This analysis comes from the works of Bellantoni and Cook, and\nLeivant by data tiering. Here, we refine predicative analysis by using a\nramified Ackermann's construction of a non-primitive recursive function. We\nobtain a hierarchy of functions which characterizes exactly functions, which\nare computed in O(n^k) time over register machine model of computation. For\nthis, we introduce a strict ramification principle. Then, we show how to\ndiagonalize in order to obtain an exponential function and to jump outside\ndeterministic polynomial time. Lastly, we suggest a dependent typed\nlambda-calculus to represent this construction.\n", "versions": [{"version": "v1", "created": "Fri, 13 Mar 2009 15:36:42 GMT"}, {"version": "v2", "created": "Tue, 31 Mar 2009 00:32:12 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Marion", "Jean-Yves", ""]]}, {"id": "0903.2445", "submitter": "Krishnendu Chatterjee", "authors": "Krishnendu Chatterjee, Luca de Alfaro, Marco Faella and Axel Legay", "title": "Qualitative Logics and Equivalences for Probabilistic Systems", "comments": "The paper is accepted for LMCS", "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 2 (May 4,\n  2009) lmcs:1082", "doi": "10.2168/LMCS-5(2:7)2009", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate logics and equivalence relations that capture the qualitative\nbehavior of Markov Decision Processes (MDPs). We present Qualitative Randomized\nCTL (QRCTL): formulas of this logic can express the fact that certain temporal\nproperties hold over all paths, or with probability 0 or 1, but they do not\ndistinguish among intermediate probability values. We present a symbolic,\npolynomial time model-checking algorithm for QRCTL on MDPs.\n  The logic QRCTL induces an equivalence relation over states of an MDP that we\ncall qualitative equivalence: informally, two states are qualitatively\nequivalent if the sets of formulas that hold with probability 0 or 1 at the two\nstates are the same. We show that for finite alternating MDPs, where\nnondeterministic and probabilistic choices occur in different states,\nqualitative equivalence coincides with alternating bisimulation, and can thus\nbe computed via efficient partition-refinement algorithms. On the other hand,\nin non-alternating MDPs the equivalence relations cannot be computed via\npartition-refinement algorithms, but rather, they require non-local\ncomputation. Finally, we consider QRCTL*, that extends QRCTL with nested\ntemporal operators in the same manner in which CTL* extends CTL. We show that\nQRCTL and QRCTL* induce the same qualitative equivalence on alternating MDPs,\nwhile on non-alternating MDPs, the equivalence arising from QRCTL* can be\nstrictly finer. We also provide a full characterization of the relation between\nqualitative equivalence, bisimulation, and alternating bisimulation, according\nto whether the MDPs are finite, and to whether their transition relations are\nfinitely-branching.\n", "versions": [{"version": "v1", "created": "Fri, 13 Mar 2009 17:52:30 GMT"}, {"version": "v2", "created": "Mon, 4 May 2009 16:10:17 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["de Alfaro", "Luca", ""], ["Faella", "Marco", ""], ["Legay", "Axel", ""]]}, {"id": "0903.2448", "submitter": "Mehrnoosh Sadrzadeh", "authors": "Mehrnoosh Sadrzadeh and Roy Dyckhoff", "title": "Positive Logic with Adjoint Modalities: Proof Theory, Semantics and\n  Reasoning about Information", "comments": "This paper is the full version of the article that is to appear in\n  the ENTCS proceedings of the 25th conference on the Mathematical Foundations\n  of Programming Semantics (MFPS), April 2009, University of Oxford", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider a simple modal logic whose non-modal part has conjunction and\ndisjunction as connectives and whose modalities come in adjoint pairs, but are\nnot in general closure operators. Despite absence of negation and implication,\nand of axioms corresponding to the characteristic axioms of (e.g.) T, S4 and\nS5, such logics are useful, as shown in previous work by Baltag, Coecke and the\nfirst author, for encoding and reasoning about information and misinformation\nin multi-agent systems. For such a logic we present an algebraic semantics,\nusing lattices with agent-indexed families of adjoint pairs of operators, and a\ncut-free sequent calculus. The calculus exploits operators on sequents, in the\nstyle of \"nested\" or \"tree-sequent\" calculi; cut-admissibility is shown by\nconstructive syntactic methods. The applicability of the logic is illustrated\nby reasoning about the muddy children puzzle, for which the calculus is\naugmented with extra rules to express the facts of the muddy children scenario.\n", "versions": [{"version": "v1", "created": "Fri, 13 Mar 2009 18:30:55 GMT"}, {"version": "v2", "created": "Thu, 19 Mar 2009 16:46:40 GMT"}, {"version": "v3", "created": "Mon, 23 Mar 2009 18:42:39 GMT"}], "update_date": "2009-03-23", "authors_parsed": [["Sadrzadeh", "Mehrnoosh", ""], ["Dyckhoff", "Roy", ""]]}, {"id": "0903.2825", "submitter": "Susmit Jha", "authors": "Susmit Jha, Sanjit A. Seshia and Rhishikesh Limaye", "title": "On the Computational Complexity of Satisfiability Solving for String\n  Theories", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Satisfiability solvers are increasingly playing a key role in software\nverification, with particularly effective use in the analysis of security\nvulnerabilities. String processing is a key part of many software applications,\nsuch as browsers and web servers. These applications are susceptible to attacks\nthrough malicious data received over network. Automated tools for analyzing the\nsecurity of such applications, thus need to reason about strings. For\nefficiency reasons, it is desirable to have a solver that treats strings as\nfirst-class types. In this paper, we present some theories of strings that are\nuseful in a software security context and analyze the computational complexity\nof the presented theories. We use this complexity analysis to motivate a\nbyte-blast approach which employs a Boolean encoding of the string constraints\nto a corresponding Boolean satisfiability problem.\n", "versions": [{"version": "v1", "created": "Mon, 16 Mar 2009 18:25:54 GMT"}], "update_date": "2009-03-17", "authors_parsed": [["Jha", "Susmit", ""], ["Seshia", "Sanjit A.", ""], ["Limaye", "Rhishikesh", ""]]}, {"id": "0903.2904", "submitter": "Andreas Bauer", "authors": "Andreas Bauer, Rajeev Gore, Alwen Tiu", "title": "A decidable policy language for history-based transaction monitoring", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-642-03466-4_6", "report-no": null, "categories": "cs.LO cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Online trading invariably involves dealings between strangers, so it is\nimportant for one party to be able to judge objectively the trustworthiness of\nthe other. In such a setting, the decision to trust a user may sensibly be\nbased on that user's past behaviour. We introduce a specification language\nbased on linear temporal logic for expressing a policy for categorising the\nbehaviour patterns of a user depending on its transaction history. We also\npresent an algorithm for checking whether the transaction history obeys the\nstated policy. To be useful in a real setting, such a language should allow one\nto express realistic policies which may involve parameter quantification and\nquantitative or statistical patterns. We introduce several extensions of linear\ntemporal logic to cater for such needs: a restricted form of universal and\nexistential quantification; arbitrary computable functions and relations in the\nterm language; and a \"counting\" quantifier for counting how many times a\nformula holds in the past. We then show that model checking a transaction\nhistory against a policy, which we call the history-based transaction\nmonitoring problem, is PSPACE-complete in the size of the policy formula and\nthe length of the history. The problem becomes decidable in polynomial time\nwhen the policies are fixed. We also consider the problem of transaction\nmonitoring in the case where not all the parameters of actions are observable.\nWe formulate two such \"partial observability\" monitoring problems, and show\ntheir decidability under certain restrictions.\n", "versions": [{"version": "v1", "created": "Tue, 17 Mar 2009 06:23:44 GMT"}], "update_date": "2015-05-13", "authors_parsed": [["Bauer", "Andreas", ""], ["Gore", "Rajeev", ""], ["Tiu", "Alwen", ""]]}, {"id": "0903.2914", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "A process calculus with finitary comprehended terms", "comments": "25 pages, combined with arXiv:0901.3012 [math.RA]; presentation\n  improved, mistakes in Table 5 corrected", "journal-ref": "Theory of Computing Systems, 53(4):645--668, 2013", "doi": "10.1007/s00224-013-9468-x", "report-no": null, "categories": "cs.LO math.RA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce the notion of an ACP process algebra and the notion of a meadow\nenriched ACP process algebra. The former notion originates from the models of\nthe axiom system ACP. The latter notion is a simple generalization of the\nformer notion to processes in which data are involved, the mathematical\nstructure of data being a meadow. Moreover, for all associative operators from\nthe signature of meadow enriched ACP process algebras that are not of an\nauxiliary nature, we introduce variable-binding operators as generalizations.\nThese variable-binding operators, which give rise to comprehended terms, have\nthe property that they can always be eliminated. Thus, we obtain a process\ncalculus whose terms can be interpreted in all meadow enriched ACP process\nalgebras. Use of the variable-binding operators can have a major impact on the\nsize of terms.\n", "versions": [{"version": "v1", "created": "Tue, 17 Mar 2009 07:19:00 GMT"}, {"version": "v2", "created": "Tue, 29 Mar 2011 10:46:34 GMT"}, {"version": "v3", "created": "Thu, 28 Mar 2013 11:55:20 GMT"}], "update_date": "2013-08-07", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0903.3126", "submitter": "Mihaela Sighireanu", "authors": "Ahmed Bouajjani, Cezara Dragoi, Constantin Enea, Yan Jurski, Mihaela\n  Sighireanu", "title": "A Generic Framework for Reasoning about Dynamic Networks of\n  Infinite-State Processes", "comments": "29 pages, 5 tables, 1 figure, extended version of the paper published\n  in the the Proceedings of TACAS 2007, LNCS 4424", "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 2 (April 22,\n  2009) lmcs:991", "doi": "10.2168/LMCS-5(2:3)2009", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a framework for reasoning about unbounded dynamic networks of\ninfinite-state processes. We propose Constrained Petri Nets (CPN) as generic\nmodels for these networks. They can be seen as Petri nets where tokens\n(representing occurrences of processes) are colored by values over some\npotentially infinite data domain such as integers, reals, etc. Furthermore, we\ndefine a logic, called CML (colored markings logic), for the description of CPN\nconfigurations. CML is a first-order logic over tokens allowing to reason about\ntheir locations and their colors. Both CPNs and CML are parametrized by a color\nlogic allowing to express constraints on the colors (data) associated with\ntokens. We investigate the decidability of the satisfiability problem of CML\nand its applications in the verification of CPNs. We identify a fragment of CML\nfor which the satisfiability problem is decidable (whenever it is the case for\nthe underlying color logic), and which is closed under the computations of post\nand pre images for CPNs. These results can be used for several kinds of\nanalysis such as invariance checking, pre-post condition reasoning, and bounded\nreachability analysis.\n", "versions": [{"version": "v1", "created": "Wed, 18 Mar 2009 10:56:11 GMT"}, {"version": "v2", "created": "Wed, 22 Apr 2009 15:38:23 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Bouajjani", "Ahmed", ""], ["Dragoi", "Cezara", ""], ["Enea", "Constantin", ""], ["Jurski", "Yan", ""], ["Sighireanu", "Mihaela", ""]]}, {"id": "0903.3311", "submitter": "Dominique Duval", "authors": "Jean-Guillaume Dumas (LJK), Dominique Duval (LJK), Jean-Claude Reynaud\n  (RC)", "title": "Cartesian effect categories are Freyd-categories", "comments": "23 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most often, in a categorical semantics for a programming language, the\nsubstitution of terms is expressed by composition and finite products. However\nthis does not deal with the order of evaluation of arguments, which may have\nmajor consequences when there are side-effects. In this paper Cartesian effect\ncategories are introduced for solving this issue, and they are compared with\nstrong monads, Freyd-categories and Haskell's Arrows. It is proved that a\nCartesian effect category is a Freyd-category where the premonoidal structure\nis provided by a kind of binary product, called the sequential product. The\nuniversal property of the sequential product provides Cartesian effect\ncategories with a powerful tool for constructions and proofs. To our knowledge,\nboth effect categories and sequential products are new notions.\n", "versions": [{"version": "v1", "created": "Thu, 19 Mar 2009 12:01:21 GMT"}, {"version": "v2", "created": "Tue, 19 May 2009 13:42:19 GMT"}, {"version": "v3", "created": "Fri, 12 Jun 2009 14:18:27 GMT"}], "update_date": "2009-06-12", "authors_parsed": [["Dumas", "Jean-Guillaume", "", "LJK"], ["Duval", "Dominique", "", "LJK"], ["Reynaud", "Jean-Claude", "", "RC"]]}, {"id": "0903.3741", "submitter": "Alejandro Diaz-Caro", "authors": "Pablo Arrighi (ENS-Lyon, LIP and Universite de Grenoble, LIG),\n  Alejandro Diaz-Caro (Universite de Grenoble, LIG, and Universite Paris-Nord,\n  Laboratoire LIPN)", "title": "A System F accounting for scalars", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 1 (February\n  27, 2012) lmcs:846", "doi": "10.2168/LMCS-8(1:11)2012", "report-no": null, "categories": "cs.LO cs.PL quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Algebraic lambda-calculus and the Linear-Algebraic lambda-calculus extend\nthe lambda-calculus with the possibility of making arbitrary linear\ncombinations of terms. In this paper we provide a fine-grained, System F-like\ntype system for the linear-algebraic lambda-calculus. We show that this\n\"scalar\" type system enjoys both the subject-reduction property and the\nstrong-normalisation property, our main technical results. The latter yields a\nsignificant simplification of the linear-algebraic lambda-calculus itself, by\nremoving the need for some restrictions in its reduction rules. But the more\nimportant, original feature of this scalar type system is that it keeps track\nof 'the amount of a type' that is present in each term. As an example of its\nuse, we shown that it can serve as a guarantee that the normal form of a term\nis barycentric, i.e that its scalars are summing to one.\n", "versions": [{"version": "v1", "created": "Sun, 22 Mar 2009 17:10:09 GMT"}, {"version": "v2", "created": "Fri, 31 Jul 2009 11:19:20 GMT"}, {"version": "v3", "created": "Fri, 9 Apr 2010 17:37:28 GMT"}, {"version": "v4", "created": "Thu, 18 Nov 2010 11:40:41 GMT"}, {"version": "v5", "created": "Sun, 24 Apr 2011 10:36:35 GMT"}, {"version": "v6", "created": "Wed, 1 Feb 2012 14:40:41 GMT"}, {"version": "v7", "created": "Thu, 23 Feb 2012 23:27:05 GMT"}, {"version": "v8", "created": "Tue, 28 Feb 2012 08:59:44 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Arrighi", "Pablo", "", "ENS-Lyon, LIP and Universite de Grenoble, LIG"], ["Diaz-Caro", "Alejandro", "", "Universite de Grenoble, LIG, and Universite Paris-Nord,\n  Laboratoire LIPN"]]}, {"id": "0903.3850", "submitter": "Yves Bertot", "authors": "Yves Bertot (INRIA Sophia Antipolis), Ekaterina Komendantskaya (INRIA\n  Sophia Antipolis)", "title": "Using Structural Recursion for Corecursion", "comments": null, "journal-ref": "Types 2008 5497 (2008) 220-236", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a (limited) solution to the problem of constructing stream values\ndefined by recursive equations that do not respect the guardedness condition.\nThe guardedness condition is imposed on definitions of corecursive functions in\nCoq, AGDA, and other higher-order proof assistants. In this paper, we\nconcentrate in particular on those non-guarded equations where recursive calls\nappear under functions. We use a correspondence between streams and functions\nover natural numbers to show that some classes of non-guarded definitions can\nbe modelled through the encoding as structural recursive functions. In\npractice, this work extends the class of stream values that can be defined in a\nconstructive type theory-based theorem prover with inductive and coinductive\ntypes, structural recursion and guarded corecursion\n", "versions": [{"version": "v1", "created": "Mon, 23 Mar 2009 12:35:27 GMT"}], "update_date": "2009-03-24", "authors_parsed": [["Bertot", "Yves", "", "INRIA Sophia Antipolis"], ["Komendantskaya", "Ekaterina", "", "INRIA\n  Sophia Antipolis"]]}, {"id": "0903.4366", "submitter": "Dimitri Hendriks", "authors": "Joerg Endrullis, Clemens Grabmayer, Dimitri Hendriks", "title": "Complexity of Fractran and Productivity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In functional programming languages the use of infinite structures is common\npractice. For total correctness of programs dealing with infinite structures\none must guarantee that every finite part of the result can be evaluated in\nfinitely many steps. This is known as productivity. For programming with\ninfinite structures, productivity is what termination in well-defined results\nis for programming with finite structures.\n  Fractran is a simple Turing-complete programming language invented by Conway.\nWe prove that the question whether a Fractran program halts on all positive\nintegers is Pi^0_2-complete. In functional programming, productivity typically\nis a property of individual terms with respect to the inbuilt evaluation\nstrategy. By encoding Fractran programs as specifications of infinite lists, we\nestablish that this notion of productivity is Pi^0_2-complete even for the most\nsimple specifications. Therefore it is harder than termination of individual\nterms. In addition, we explore possible generalisations of the notion of\nproductivity in the framework of term rewriting, and prove that their\ncomputational complexity is Pi^1_1-complete, thus exceeding the expressive\npower of first-order logic.\n", "versions": [{"version": "v1", "created": "Wed, 25 Mar 2009 15:14:00 GMT"}, {"version": "v2", "created": "Thu, 4 Jun 2009 10:05:41 GMT"}, {"version": "v3", "created": "Fri, 31 Jul 2009 18:33:42 GMT"}], "update_date": "2009-07-31", "authors_parsed": [["Endrullis", "Joerg", ""], ["Grabmayer", "Clemens", ""], ["Hendriks", "Dimitri", ""]]}, {"id": "0903.4382", "submitter": "Amir Ben-Amram", "authors": "Amir M. Ben-Amram and Chin Soon Lee", "title": "Ranking Functions for Size-Change Termination II", "comments": "29 pages;", "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 2 (May 25,\n  2009) lmcs:1000", "doi": "10.2168/LMCS-5(2:8)2009", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Size-Change Termination is an increasingly-popular technique for verifying\nprogram termination. These termination proofs are deduced from an abstract\nrepresentation of the program in the form of \"size-change graphs\".\n  We present algorithms that, for certain classes of size-change graphs, deduce\na global ranking function: an expression that ranks program states, and\ndecreases on every transition. A ranking function serves as a witness for a\ntermination proof, and is therefore interesting for program certification. The\nparticular form of the ranking expressions that represent SCT termination\nproofs sheds light on the scope of the proof method. The complexity of the\nexpressions is also interesting, both practicaly and theoretically.\n  While deducing ranking functions from size-change graphs has already been\nshown possible, the constructions in this paper are simpler and more\ntransparent than previously known. They improve the upper bound on the size of\nthe ranking expression from triply exponential down to singly exponential (for\ncertain classes of instances). We claim that this result is, in some sense,\noptimal. To this end, we introduce a framework for lower bounds on the\ncomplexity of ranking expressions and prove exponential lower bounds.\n", "versions": [{"version": "v1", "created": "Wed, 25 Mar 2009 17:47:30 GMT"}, {"version": "v2", "created": "Wed, 6 May 2009 10:51:36 GMT"}, {"version": "v3", "created": "Mon, 11 May 2009 12:05:58 GMT"}, {"version": "v4", "created": "Mon, 25 May 2009 11:29:03 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Ben-Amram", "Amir M.", ""], ["Lee", "Chin Soon", ""]]}, {"id": "0903.4615", "submitter": "Olivier Finkel", "authors": "Olivier Finkel (ELM, Lip)", "title": "On Decidability Properties of One-Dimensional Cellular Automata", "comments": "Final version; to appear in the Journal of Cellular Automata", "journal-ref": "Journal of Cellular Automata 6, 2-3 (2011) 181-193", "doi": null, "report-no": null, "categories": "cs.LO cs.CC math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a recent paper Sutner proved that the first-order theory of the\nphase-space $\\mathcal{S}_\\mathcal{A}=(Q^\\mathbb{Z}, \\longrightarrow)$ of a\none-dimensional cellular automaton $\\mathcal{A}$ whose configurations are\nelements of $Q^\\mathbb{Z}$, for a finite set of states $Q$, and where\n$\\longrightarrow$ is the \"next configuration relation\", is decidable. He asked\nwhether this result could be extended to a more expressive logic. We prove in\nthis paper that this is actuallly the case. We first show that, for each\none-dimensional cellular automaton $\\mathcal{A}$, the phase-space\n$\\mathcal{S}_\\mathcal{A}$ is an omega-automatic structure. Then, applying\nrecent results of Kuske and Lohrey on omega-automatic structures, it follows\nthat the first-order theory, extended with some counting and cardinality\nquantifiers, of the structure $\\mathcal{S}_\\mathcal{A}$, is decidable. We give\nsome examples of new decidable properties for one-dimensional cellular\nautomata. In the case of surjective cellular automata, some more efficient\nalgorithms can be deduced from results of Kuske and Lohrey on structures of\nbounded degree. On the other hand we show that the case of cellular automata\ngive new results on automatic graphs.\n", "versions": [{"version": "v1", "created": "Thu, 26 Mar 2009 15:39:35 GMT"}, {"version": "v2", "created": "Mon, 1 Jun 2009 19:14:13 GMT"}], "update_date": "2010-10-01", "authors_parsed": [["Finkel", "Olivier", "", "ELM, Lip"]]}, {"id": "0903.5154", "submitter": "Ross Duncan", "authors": "Ross Duncan", "title": "Generalised Proof-Nets for Compact Categories with Biproducts", "comments": "77 pages, many figures. To appear in CUP volume, \"Semantics of\n  Quantum Computation\"", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Just as conventional functional programs may be understood as proofs in an\nintuitionistic logic, so quantum processes can also be viewed as proofs in a\nsuitable logic. We describe such a logic, the logic of compact closed\ncategories and biproducts, presented both as a sequent calculus and as a system\nof proof-nets. This logic captures much of the necessary structure needed to\nrepresent quantum processes under classical control, while remaining agnostic\nto the fine details. We demonstrate how to represent quantum processes as\nproof-nets, and show that the dynamic behaviour of a quantum process is\ncaptured by the cut-elimination procedure for the logic. We show that the cut\nelimination procedure is strongly normalising: that is, that every legal way of\nsimplifying a proof-net leads to the same, unique, normal form. Finally, taking\nsome initial set of operations as non-logical axioms, we show that that the\nresulting category of proof-nets is a representation of the free compact closed\ncategory with biproducts generated by those operations.\n", "versions": [{"version": "v1", "created": "Mon, 30 Mar 2009 09:59:53 GMT"}], "update_date": "2009-03-31", "authors_parsed": [["Duncan", "Ross", ""]]}, {"id": "0903.5259", "submitter": "Lutz Strassburger", "authors": "Lutz Strassburger and Alessio Guglielmi", "title": "A System of Interaction and Structure IV: The Exponentials and\n  Decomposition", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study a system, called NEL, which is the mixed commutative/non-commutative\nlinear logic BV augmented with linear logic's exponentials. Equivalently, NEL\nis MELL augmented with the non-commutative self-dual connective seq. In this\npaper, we show a basic compositionality property of NEL, which we call\ndecomposition. This result leads to a cut-elimination theorem, which is proved\nin the next paper of this series. To control the induction measure for the\ntheorem, we rely on a novel technique that extracts from NEL proofs the\nstructure of exponentials, into what we call !-?-Flow-Graphs.\n", "versions": [{"version": "v1", "created": "Mon, 30 Mar 2009 16:49:36 GMT"}, {"version": "v2", "created": "Tue, 27 Jul 2010 14:35:06 GMT"}], "update_date": "2010-07-28", "authors_parsed": [["Strassburger", "Lutz", ""], ["Guglielmi", "Alessio", ""]]}, {"id": "0903.5392", "submitter": "J\\\"urgen Koslowski", "authors": "Paola Bruscoli, Alessio Guglielmi, Tom Gundersen and Michel Parigot", "title": "Quasipolynomial Normalisation in Deep Inference via Atomic Flows and\n  Threshold Formulae", "comments": "Accepted by Logical Methods in Computer Science", "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 2 (May 3,\n  2016) lmcs:1637", "doi": "10.1007/978-3-642-17511-4_9", "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Je\\v{r}\\'abek showed that cuts in classical propositional logic proofs in\ndeep inference can be eliminated in quasipolynomial time. The proof is indirect\nand it relies on a result of Atserias, Galesi and Pudl\\'ak about monotone\nsequent calculus and a correspondence between that system and cut-free\ndeep-inference proofs. In this paper we give a direct proof of Je\\v{r}\\'abek's\nresult: we give a quasipolynomial-time cut-elimination procedure for classical\npropositional logic in deep inference. The main new ingredient is the use of a\ncomputational trace of deep-inference proofs called atomic flows, which are\nboth very simple (they only trace structural rules and forget logical rules)\nand strong enough to faithfully represent the cut-elimination procedure.\n", "versions": [{"version": "v1", "created": "Tue, 31 Mar 2009 10:37:42 GMT"}, {"version": "v2", "created": "Tue, 29 Apr 2014 13:49:34 GMT"}, {"version": "v3", "created": "Mon, 5 May 2014 16:06:34 GMT"}, {"version": "v4", "created": "Wed, 24 Feb 2016 13:07:34 GMT"}, {"version": "v5", "created": "Mon, 2 May 2016 06:36:04 GMT"}], "update_date": "2017-01-11", "authors_parsed": [["Bruscoli", "Paola", ""], ["Guglielmi", "Alessio", ""], ["Gundersen", "Tom", ""], ["Parigot", "Michel", ""]]}, {"id": "0903.5505", "submitter": "J\\\"urgen Koslowski", "authors": "Ren\\'e David (LAMA), Katarzyna Grygiel, Jakub Kozic, Christophe\n  Raffalli (LAMA), Guillaume Theyssier (LAMA), Marek Zaionc", "title": "Asymptotically almost all \\lambda-terms are strongly normalizing", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 1 (February\n  15, 2013) lmcs:848", "doi": "10.2168/LMCS-9(1:2)2013", "report-no": null, "categories": "math.LO cs.DM cs.LO math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present quantitative analysis of various (syntactic and behavioral)\nproperties of random \\lambda-terms. Our main results are that asymptotically\nall the terms are strongly normalizing and that any fixed closed term almost\nnever appears in a random term. Surprisingly, in combinatory logic (the\ntranslation of the \\lambda-calculus into combinators), the result is exactly\nopposite. We show that almost all terms are not strongly normalizing. This is\ndue to the fact that any fixed combinator almost always appears in a random\ncombinator.\n", "versions": [{"version": "v1", "created": "Tue, 31 Mar 2009 15:47:07 GMT"}, {"version": "v2", "created": "Fri, 9 Oct 2009 14:45:16 GMT"}, {"version": "v3", "created": "Mon, 27 Sep 2010 19:03:10 GMT"}, {"version": "v4", "created": "Tue, 23 Oct 2012 06:10:45 GMT"}, {"version": "v5", "created": "Wed, 13 Feb 2013 23:11:06 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["David", "Ren\u00e9", "", "LAMA"], ["Grygiel", "Katarzyna", "", "LAMA"], ["Kozic", "Jakub", "", "LAMA"], ["Raffalli", "Christophe", "", "LAMA"], ["Theyssier", "Guillaume", "", "LAMA"], ["Zaionc", "Marek", ""]]}]