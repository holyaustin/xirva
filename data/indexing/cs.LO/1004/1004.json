[{"id": "1004.0610", "submitter": "Markus Lohrey", "authors": "Dietrich Kuske, Jiamou Liu, and Markus Lohrey", "title": "The Isomorphism Problem for omega-Automatic Trees", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The main result of this paper is that the isomorphism for omega-automatic\ntrees of finite height is at least has hard as second-order arithmetic and\ntherefore not analytical. This strengthens a recent result by Hjorth,\nKhoussainov, Montalban, and Nies showing that the isomorphism problem for\nomega-automatic structures is not $\\Sigma^1_2$. Moreover, assuming the\ncontinuum hypothesis CH, we can show that the isomorphism problem for\nomega-automatic trees of finite height is recursively equivalent with\nsecond-order arithmetic. On the way to our main results, we show lower and\nupper bounds for the isomorphism problem for omega-automatic trees of every\nfinite height: (i) It is decidable ($\\Pi^0_1$-complete, resp,) for height 1 (2,\nresp.), (ii) $\\Pi^1_1$-hard and in $\\Pi^1_2$ for height 3, and (iii)\n$\\Pi^1_{n-3}$- and $\\Sigma^1_{n-3}$-hard and in $\\Pi^1_{2n-4}$ (assuming CH)\nfor all n > 3. All proofs are elementary and do not rely on theorems from set\ntheory.\n", "versions": [{"version": "v1", "created": "Mon, 5 Apr 2010 10:59:45 GMT"}], "update_date": "2010-04-06", "authors_parsed": [["Kuske", "Dietrich", ""], ["Liu", "Jiamou", ""], ["Lohrey", "Markus", ""]]}, {"id": "1004.0739", "submitter": "Barbara Jobstmann", "authors": "Krishnendu Chatterjee and Thomas A. Henzinger and Barbara Jobstmann\n  and Rohit Singh", "title": "Measuring and Synthesizing Systems in Probabilistic Environments", "comments": "29 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Often one has a preference order among the different systems that satisfy a\ngiven specification. Under a probabilistic assumption about the possible\ninputs, such a preference order is naturally expressed by a weighted automaton,\nwhich assigns to each word a value, such that a system is preferred if it\ngenerates a higher expected value. We solve the following optimal-synthesis\nproblem: given an omega-regular specification, a Markov chain that describes\nthe distribution of inputs, and a weighted automaton that measures how well a\nsystem satisfies the given specification under the given input assumption,\nsynthesize a system that optimizes the measured value.\n  For safety specifications and measures given by mean-payoff automata, the\noptimal-synthesis problem amounts to finding a strategy in a Markov decision\nprocess (MDP) that is optimal for a long-run average reward objective, which\ncan be done in polynomial time. For general omega-regular specifications, the\nsolution rests on a new, polynomial-time algorithm for computing optimal\nstrategies in MDPs with mean-payoff parity objectives.\n  Our algorithm generates optimal strategies consisting of two memoryless\nstrategies and a counter. This counter is in general not bounded. To obtain a\nfinite-state system, we show how to construct an \\epsilon-optimal strategy with\na bounded counter for any \\epsilon>0. We also show how to decide in polynomial\ntime if we can construct an optimal finite-state system (i.e., a system without\na counter) for a given specification.\n  We have implemented our approach in a tool that takes qualitative and\nquantitative specifications and automatically constructs a system that\nsatisfies the qualitative specification and optimizes the quantitative\nspecification, if such a system exists. We present experimental results showing\noptimal systems that were generated in this way.\n", "versions": [{"version": "v1", "created": "Mon, 5 Apr 2010 23:46:21 GMT"}, {"version": "v2", "created": "Thu, 14 Apr 2011 18:02:38 GMT"}], "update_date": "2011-04-15", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Henzinger", "Thomas A.", ""], ["Jobstmann", "Barbara", ""], ["Singh", "Rohit", ""]]}, {"id": "1004.0944", "submitter": "Roberto Bagnara", "authors": "Roberto Bagnara, Fred Mesnard, Andrea Pescetti, Enea Zaffanella", "title": "The Automatic Synthesis of Linear Ranking Functions: The Complete\n  Unabridged Version", "comments": "47 pages, 3 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The classical technique for proving termination of a generic sequential\ncomputer program involves the synthesis of a ranking function for each loop of\nthe program. Linear ranking functions are particularly interesting because many\nterminating loops admit one and algorithms exist to automatically synthesize\nit. In this paper we present two such algorithms: one based on work dated 1991\nby Sohn and Van Gelder; the other, due to Podelski and Rybalchenko, dated 2004.\nRemarkably, while the two algorithms will synthesize a linear ranking function\nunder exactly the same set of conditions, the former is mostly unknown to the\ncommunity of termination analysis and its general applicability has never been\nput forward before the present paper. In this paper we thoroughly justify both\nalgorithms, we prove their correctness, we compare their worst-case complexity\nand experimentally evaluate their efficiency, and we present an open-source\nimplementation of them that will make it very easy to include\ntermination-analysis capabilities in automatic program verifiers.\n", "versions": [{"version": "v1", "created": "Tue, 6 Apr 2010 19:54:20 GMT"}, {"version": "v2", "created": "Sun, 1 Apr 2012 07:14:21 GMT"}], "update_date": "2012-04-03", "authors_parsed": [["Bagnara", "Roberto", ""], ["Mesnard", "Fred", ""], ["Pescetti", "Andrea", ""], ["Zaffanella", "Enea", ""]]}, {"id": "1004.1027", "submitter": "Pablo Arrighi", "authors": "Pablo Arrighi, Gilles Dowek", "title": "On the completeness of quantum computation models", "comments": "15 pages, LaTeX", "journal-ref": "6th conference on Computability in Europe, CiE 2010, Proceedings\n  in LNCS", "doi": "10.1007/978-3-642-13962-8_3", "report-no": null, "categories": "cs.CC cs.LO quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The notion of computability is stable (i.e. independent of the choice of an\nindexing) over infinite-dimensional vector spaces provided they have a finite\n\"tensorial dimension\". Such vector spaces with a finite tensorial dimension\npermit to define an absolute notion of completeness for quantum computation\nmodels and give a precise meaning to the Church-Turing thesis in the framework\nof quantum theory. (Extra keywords: quantum programming languages, denotational\nsemantics, universality.)\n", "versions": [{"version": "v1", "created": "Wed, 7 Apr 2010 08:43:29 GMT"}], "update_date": "2015-05-18", "authors_parsed": [["Arrighi", "Pablo", ""], ["Dowek", "Gilles", ""]]}, {"id": "1004.1077", "submitter": "Marcello M. Bersani", "authors": "Marcello M. Bersani, Achille Frigeri, Angelo Morzenti, Matteo\n  Pradella, Matteo Rossi, Pierluigi San Pietro", "title": "Bounded Reachability for Temporal Logic over Constraint Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present CLTLB(D), an extension of PLTLB (PLTL with both past and future\noperators) augmented with atomic formulae built over a constraint system D.\nEven for decidable constraint systems, satisfiability and Model Checking\nproblem of such logic can be undecidable. We introduce suitable restrictions\nand assumptions that are shown to make the satisfiability problem for the\nextended logic decidable. Moreover for a large class of constraint systems we\npropose an encoding that realize an effective decision procedure for the\nBounded Reachability problem.\n", "versions": [{"version": "v1", "created": "Wed, 7 Apr 2010 12:58:32 GMT"}, {"version": "v2", "created": "Fri, 16 Apr 2010 09:33:25 GMT"}, {"version": "v3", "created": "Tue, 20 Apr 2010 09:05:08 GMT"}], "update_date": "2010-04-21", "authors_parsed": [["Bersani", "Marcello M.", ""], ["Frigeri", "Achille", ""], ["Morzenti", "Angelo", ""], ["Pradella", "Matteo", ""], ["Rossi", "Matteo", ""], ["Pietro", "Pierluigi San", ""]]}, {"id": "1004.1262", "submitter": "Nicolas Stouls", "authors": "Jacques Julliand (LIFC), Nicolas Stouls (CITI Insa Lyon / INRIA\n  Grenoble Rh\\^one-Alpes), Pierre-Christophe Bu\\'e (LIFC), Pierre-Alain Masson\n  (LIFC)", "title": "Syntactic Abstraction of B Models to Generate Tests", "comments": "Tests and Proofs 2010, Malaga : Spain (2010)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SC cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a model-based testing approach as well as for the verification of\nproperties, B models provide an interesting solution. However, for industrial\napplications, the size of their state space often makes them hard to handle. To\nreduce the amount of states, an abstraction function can be used, often\ncombining state variable elimination and domain abstractions of the remaining\nvariables. This paper complements previous results, based on domain abstraction\nfor test generation, by adding a preliminary syntactic abstraction phase, based\non variable elimination. We define a syntactic transformation that suppresses\nsome variables from a B event model, in addition to a method that chooses\nrelevant variables according to a test purpose. We propose two methods to\ncompute an abstraction A of an initial model M. The first one computes A as a\nsimulation of M, and the second one computes A as a bisimulation of M. The\nabstraction process produces a finite state system. We apply this abstraction\ncomputation to a Model Based Testing process.\n", "versions": [{"version": "v1", "created": "Thu, 8 Apr 2010 07:15:48 GMT"}, {"version": "v2", "created": "Mon, 31 May 2010 06:56:29 GMT"}], "update_date": "2010-06-01", "authors_parsed": [["Julliand", "Jacques", "", "LIFC"], ["Stouls", "Nicolas", "", "CITI Insa Lyon / INRIA\n  Grenoble Rh\u00f4ne-Alpes"], ["Bu\u00e9", "Pierre-Christophe", "", "LIFC"], ["Masson", "Pierre-Alain", "", "LIFC"]]}, {"id": "1004.1460", "submitter": "Nicolas Stouls", "authors": "Nicolas Stouls (LSR - IMAG), Marie-Laure Potet (LSR - IMAG, IMAG)", "title": "Security Policy Enforcement Through Refinement Process", "comments": null, "journal-ref": "B 2007, besan\\c{c}on : France (2007)", "doi": null, "report-no": null, "categories": "cs.CR cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the area of networks, a common method to enforce a security policy\nexpressed in a high-level language is based on an ad-hoc and manual rewriting\nprocess. We argue that it is possible to build a formal link between concrete\nand abstract terms, which can be dynamically computed from the environment\ndata. In order to progressively introduce configuration data and then simplify\nthe proof obligations, we use the B refinement process. We present a case study\nmodeling a network monitor. This program, described by refinement following the\nlayers of the TCP/IP suite protocol, has to warn for all observed events which\ndo not respect the security policy. To design this model, we use the event-B\nmethod because it is suitable for modeling network concepts. This work has been\ndone within the framework of the POTESTAT project, based on the research of\nnetwork testing methods from a high-level security policy.\n", "versions": [{"version": "v1", "created": "Fri, 9 Apr 2010 06:07:34 GMT"}], "update_date": "2010-04-12", "authors_parsed": [["Stouls", "Nicolas", "", "LSR - IMAG"], ["Potet", "Marie-Laure", "", "LSR - IMAG, IMAG"]]}, {"id": "1004.1472", "submitter": "Nicolas Stouls", "authors": "Didier Bert (LSR - IMAG), Marie-Laure Potet (LSR - IMAG), Nicolas\n  Stouls (LSR - IMAG)", "title": "GeneSyst: a Tool to Reason about Behavioral Aspects of B Event\n  Specifications. Application to Security Properties.", "comments": null, "journal-ref": "Formal Specification and Development in Z and B, 4th International\n  Conference of B and Z Users, Guildford : United Kingdom (2005)", "doi": null, "report-no": null, "categories": "cs.LO cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present a method and a tool to build symbolic labelled\ntransition systems from B specifications. The tool, called GeneSyst, can take\ninto account refinement levels and can visualize the decomposition of abstract\nstates in concrete hierarchical states. The resulting symbolic transition\nsystem represents all the behaviors of the initial B event system. So, it can\nbe used to reason about them. We illustrate the use of GeneSyst to check\nsecurity properties on a model of electronic purse.\n", "versions": [{"version": "v1", "created": "Fri, 9 Apr 2010 06:55:02 GMT"}], "update_date": "2010-04-12", "authors_parsed": [["Bert", "Didier", "", "LSR - IMAG"], ["Potet", "Marie-Laure", "", "LSR - IMAG"], ["Stouls", "Nicolas", "", "LSR - IMAG"]]}, {"id": "1004.1598", "submitter": "Bob Coecke", "authors": "Bob Coecke (Oxford University), Simon Perdrix (IMAG Grenoble)", "title": "Environment and classical channels in categorical quantum mechanics", "comments": "26 pages, many pics; this third version has substantially more\n  explanations than previous ones; Journal reference is of short 14 page\n  version; Proceedings of the 19th EACSL Annual Conference on Computer Science\n  Logic (CSL), Lecture Notes in Computer Science 6247, Springer-Verlag (2010)", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 4 (November\n  19, 2012) lmcs:719", "doi": "10.2168/LMCS-8(4:14)2012", "report-no": null, "categories": "quant-ph cs.LO math-ph math.CT math.MP", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a both simple and comprehensive graphical calculus for quantum\ncomputing. In particular, we axiomatize the notion of an environment, which\ntogether with the earlier introduced axiomatic notion of classical structure\nenables us to define classical channels, quantum measurements and classical\ncontrol. If we moreover adjoin the earlier introduced axiomatic notion of\ncomplementarity, we obtain sufficient structural power for constructive\nrepresentation and correctness derivation of typical quantum informatic\nprotocols.\n", "versions": [{"version": "v1", "created": "Fri, 9 Apr 2010 16:42:08 GMT"}, {"version": "v2", "created": "Wed, 25 Aug 2010 14:20:51 GMT"}, {"version": "v3", "created": "Tue, 25 Jan 2011 14:41:44 GMT"}, {"version": "v4", "created": "Fri, 29 Jun 2012 15:09:59 GMT"}, {"version": "v5", "created": "Fri, 16 Nov 2012 19:02:41 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Coecke", "Bob", "", "Oxford University"], ["Perdrix", "Simon", "", "IMAG Grenoble"]]}, {"id": "1004.1814", "submitter": "Prabhu Manyem", "authors": "Prabhu Manyem", "title": "Existential Second Order Logic Expression With Horn First Order for\n  Maximum Clique (Decision Version)", "comments": "Manuscript withdrawn, because results are incorrect. If phi = phi_1\n  AND phi_2, and phi is a Horn formula, it does NOT mean that both phi_1 and\n  phi_2 are Horn formulae. Furthermore, the cardinality constraint CANNOT be\n  expressed as a universal Horn sentence in ESO (NOT even when the structure is\n  ordered). Graedel's theorem is valid at a lower (machine) level, but probably\n  NOT at a higher level", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that the maximum clique problem (decision version) can be expressed\nin existential second order (ESO) logic, where the first order part is a Horn\nformula in second-order quantified predicates. Without ordering, the first\norder part is $\\Pi_2$ Horn; if ordering is used, then it is universal Horn (in\nwhich case, the second order variables can be determined in polynomial time).\nUPDATE: Manuscript withdrawn, because results are incorrect. If phi = phi_1 AND\nphi_2, and phi is a Horn formula, it does NOT mean that both phi_1 and phi_2\nare Horn formulae. Furthermore, the cardinality constraint CANNOT be expressed\nas a universal Horn sentence in ESO (NOT even when the structure is ordered).\nGraedel's theorem is valid at a lower (machine) level, but probably NOT at a\nhigher level.\n", "versions": [{"version": "v1", "created": "Sun, 11 Apr 2010 14:29:17 GMT"}, {"version": "v2", "created": "Tue, 20 Apr 2010 12:28:23 GMT"}, {"version": "v3", "created": "Fri, 23 Apr 2010 13:36:32 GMT"}, {"version": "v4", "created": "Mon, 3 May 2010 08:35:46 GMT"}, {"version": "v5", "created": "Sat, 2 Oct 2010 22:37:33 GMT"}], "update_date": "2010-10-05", "authors_parsed": [["Manyem", "Prabhu", ""]]}, {"id": "1004.1845", "submitter": "Kai Br\\\"unnler", "authors": "Kai Br\\\"unnler", "title": "Nested Sequents", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We see how nested sequents, a natural generalisation of hypersequents, allow\nus to develop a systematic proof theory for modal logics. As opposed to other\nprominent formalisms, such as the display calculus and labelled sequents,\nnested sequents stay inside the modal language and allow for proof systems\nwhich enjoy the subformula property in the literal sense. In the first part we\nstudy a systematic set of nested sequent systems for all normal modal logics\nformed by some combination of the axioms for seriality, reflexivity, symmetry,\ntransitivity and euclideanness. We establish soundness and completeness and\nsome of their good properties, such as invertibility of all rules,\nadmissibility of the structural rules, termination of proof-search, as well as\nsyntactic cut-elimination. In the second part we study the logic of common\nknowledge, a modal logic with a fixpoint modality. We look at two infinitary\nproof systems for this logic: an existing one based on ordinary sequents, for\nwhich no syntactic cut-elimination procedure is known, and a new one based on\nnested sequents. We see how nested sequents, in contrast to ordinary sequents,\nallow for syntactic cut-elimination and thus allow us to obtain an ordinal\nupper bound on the length of proofs.\n", "versions": [{"version": "v1", "created": "Sun, 11 Apr 2010 21:10:44 GMT"}], "update_date": "2010-04-13", "authors_parsed": [["Br\u00fcnnler", "Kai", ""]]}, {"id": "1004.1947", "submitter": "Chad E. Brown", "authors": "Chad E. Brown (Saarland University), Gert Smolka (Saarland University)", "title": "Analytic Tableaux for Simple Type Theory and its First-Order Fragment", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 6, Issue 2 (June 23,\n  2010) lmcs:1169", "doi": "10.2168/LMCS-6(2:3)2010", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study simple type theory with primitive equality (STT) and its first-order\nfragment EFO, which restricts equality and quantification to base types but\nretains lambda abstraction and higher-order variables. As deductive system we\nemploy a cut-free tableau calculus. We consider completeness, compactness, and\nexistence of countable models. We prove these properties for STT with respect\nto Henkin models and for EFO with respect to standard models. We also show that\nthe tableau system yields a decision procedure for three EFO fragments.\n", "versions": [{"version": "v1", "created": "Mon, 12 Apr 2010 13:09:24 GMT"}, {"version": "v2", "created": "Tue, 22 Jun 2010 22:18:39 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Brown", "Chad E.", "", "Saarland University"], ["Smolka", "Gert", "", "Saarland University"]]}, {"id": "1004.2228", "submitter": "Pawel Waszkiewicz", "authors": "Dirk Hofmann and Pawel Waszkiewicz", "title": "Approximation in quantale-enriched categories", "comments": "17 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CT cs.LO math.GN", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Our work is a fundamental study of the notion of approximation in\nV-categories and in (U,V)-categories, for a quantale V and the ultrafilter\nmonad U. We introduce auxiliary, approximating and Scott-continuous\ndistributors, the way-below distributor, and continuity of V- and\n(U,V)-categories. We fully characterize continuous V-categories (resp.\n(U,V)-categories) among all cocomplete V-categories (resp. (U,V)-categories) in\nthe same ways as continuous domains are characterized among all dcpos. By\nvarying the choice of the quantale V and the notion of ideals, and by further\nallowing the ultrafilter monad to act on the quantale, we obtain a flexible\ntheory of continuity that applies to partial orders and to metric and\ntopological spaces. We demonstrate on examples that our theory unifies some\nmajor approaches to quantitative domain theory.\n", "versions": [{"version": "v1", "created": "Tue, 13 Apr 2010 16:39:21 GMT"}], "update_date": "2010-04-14", "authors_parsed": [["Hofmann", "Dirk", ""], ["Waszkiewicz", "Pawel", ""]]}, {"id": "1004.2367", "submitter": "Arjun Radhakrishna", "authors": "Krishnendu Chatterjee, Thomas A. Henzinger, Barbara Jobstmann, Arjun\n  Radhakrishna", "title": "GIST: A Solver for Probabilistic Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Gist is a tool that (a) solves the qualitative analysis problem of turn-based\nprobabilistic games with {\\omega}-regular objectives; and (b) synthesizes\nreasonable environment assumptions for synthesis of unrealizable\nspecifications. Our tool provides the first and efficient implementations of\nseveral reduction-based techniques to solve turn-based probabilistic games, and\nuses the analysis of turn-based probabilistic games for synthesizing\nenvironment assumptions for unrealizable specifications.\n", "versions": [{"version": "v1", "created": "Wed, 14 Apr 2010 10:40:01 GMT"}], "update_date": "2010-04-15", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Henzinger", "Thomas A.", ""], ["Jobstmann", "Barbara", ""], ["Radhakrishna", "Arjun", ""]]}, {"id": "1004.2436", "submitter": "Evgeny Chutchev", "authors": "Evgeny Chutchev", "title": "Some Mathematicians Are Not Turing Machines", "comments": "6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A certain mathematician M, considering some hypothesis H, conclusion C and\ntext P, can arrive at one of the following judgments: (1) P does not convince M\nof the fact that since H, it follows that C; (2) P is the proof that since H,\nit follows that C (judgment of the type \"Proved\"). Is it possible to replace\nsuch a mathematician with an arbitrary Turing machine? The paper provides a\nproof that the answer to the question is negative under the two following\nconditions: (1) M is faultless, namely his judgment \"Proved\" always implies\nthat since H, it actually follows that C; (2) M recognizes a certain P' as the\ncorrect proof of the fact that for certain H' and C', if H', then C' (where P',\nH', and C' are stated in the paper).\n", "versions": [{"version": "v1", "created": "Tue, 13 Apr 2010 18:43:00 GMT"}], "update_date": "2010-04-15", "authors_parsed": [["Chutchev", "Evgeny", ""]]}, {"id": "1004.2522", "submitter": "Sreekanth Malladi", "authors": "Sreekanth Malladi", "title": "How to prevent type-flaw and multi-protocol attacks on cryptographic\n  protocols under Exclusive-OR", "comments": "37 pages plus 14 pages in the Appendix", "journal-ref": null, "doi": null, "report-no": "DSU-BIS-IA-Mall2010A", "categories": "cs.CR cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Type-flaw attacks and multi-protocol attacks on security protocols have been\nfrequently reported in the literature. Heather et al. and Guttman et al. have\nproven that these could be prevented by tagging encrypted components with\ndistinct constants in a standard protocol model with free message algebra and\nperfect encryption. However, most \"real-world\" protocols such as SSL 3.0 are\ndesigned with the Exclusive-OR (XOR) operator that possesses algebraic\nproperties, breaking the free algebra assumption. These algebraic properties\ninduce equational theories that need to be considered when analyzing protocols\nthat use the operator. This is the problem we consider in this paper: We prove\nthat, under certain assumptions, tagging encrypted components still prevents\ntype-flaw and multi-protocol attacks even in the presence of the XOR operator\nand its algebraic properties.\n", "versions": [{"version": "v1", "created": "Wed, 14 Apr 2010 23:09:53 GMT"}, {"version": "v2", "created": "Wed, 16 Jun 2010 08:01:59 GMT"}, {"version": "v3", "created": "Sat, 19 Jun 2010 17:13:47 GMT"}], "update_date": "2010-06-22", "authors_parsed": [["Malladi", "Sreekanth", ""]]}, {"id": "1004.2697", "submitter": "Vishwanath Raman", "authors": "Krishnendu Chatterjee and Vishwanath Raman", "title": "Assume-Guarantee Synthesis for Digital Contract Signing", "comments": "40 pages, 1 figure, 3 tables and 3 algorithms", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CR cs.GT cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the automatic synthesis of fair non-repudiation protocols, a class\nof fair exchange protocols, used for digital contract signing. First, we show\nhow to specify the objectives of the participating agents and the trusted third\nparty (TTP) as path formulas in LTL and prove that the satisfaction of these\nobjectives imply fairness; a property required of fair exchange protocols. We\nthen show that weak (co-operative) co-synthesis and classical (strictly\ncompetitive) co-synthesis fail, whereas assume-guarantee synthesis (AGS)\nsucceeds. We demonstrate the success of assume-guarantee synthesis as follows:\n(a) any solution of assume-guarantee synthesis is attack-free; no subset of\nparticipants can violate the objectives of the other participants; (b) the\nAsokan-Shoup-Waidner (ASW) certified mail protocol that has known\nvulnerabilities is not a solution of AGS; (c) the Kremer-Markowitch (KM)\nnon-repudiation protocol is a solution of AGS; and (d) AGS presents a new and\nsymmetric fair non-repudiation protocol that is attack-free. To our knowledge\nthis is the first application of synthesis to fair non-repudiation protocols,\nand our results show how synthesis can both automatically discover\nvulnerabilities in protocols and generate correct protocols. The solution to\nassume-guarantee synthesis can be computed efficiently as the secure\nequilibrium solution of three-player graph games.\n", "versions": [{"version": "v1", "created": "Thu, 15 Apr 2010 19:41:24 GMT"}, {"version": "v2", "created": "Sun, 18 Apr 2010 07:35:32 GMT"}, {"version": "v3", "created": "Mon, 19 Jul 2010 04:58:22 GMT"}, {"version": "v4", "created": "Sun, 13 Nov 2011 00:16:54 GMT"}], "update_date": "2011-11-15", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Raman", "Vishwanath", ""]]}, {"id": "1004.2717", "submitter": "Lutz Schr\\\"oder", "authors": "Lutz Schr\\\"oder and Yde Venema", "title": "Completeness of Flat Coalgebraic Fixpoint Logics", "comments": "Short version appeared in Proc. 21st International Conference on\n  Concurrency Theory, CONCUR 2010, Vol. 6269 of Lecture Notes in Computer\n  Science, Springer, 2010, pp. 524-538", "journal-ref": null, "doi": "10.1007/978-3-642-15375-4_36", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modal fixpoint logics traditionally play a central role in computer science,\nin particular in artificial intelligence and concurrency. The mu-calculus and\nits relatives are among the most expressive logics of this type. However,\npopular fixpoint logics tend to trade expressivity for simplicity and\nreadability, and in fact often live within the single variable fragment of the\nmu-calculus. The family of such flat fixpoint logics includes, e.g., LTL, CTL,\nand the logic of common knowledge. Extending this notion to the generic\nsemantic framework of coalgebraic logic enables covering a wide range of logics\nbeyond the standard mu-calculus including, e.g., flat fragments of the graded\nmu-calculus and the alternating-time mu-calculus (such as alternating-time\ntemporal logic ATL), as well as probabilistic and monotone fixpoint logics. We\ngive a generic proof of completeness of the Kozen-Park axiomatization for such\nflat coalgebraic fixpoint logics.\n", "versions": [{"version": "v1", "created": "Thu, 15 Apr 2010 21:16:32 GMT"}, {"version": "v2", "created": "Thu, 9 Jun 2016 09:01:43 GMT"}], "update_date": "2016-06-10", "authors_parsed": [["Schr\u00f6der", "Lutz", ""], ["Venema", "Yde", ""]]}, {"id": "1004.2764", "submitter": "Franck Cassez", "authors": "Franck Cassez", "title": "A Note on Fault Diagnosis Algorithms", "comments": "Note: This paper is an extended version of the paper published in the\n  proceedings of CDC'09, 48th IEEE Conference on Decision and Control and 28th\n  Chinese Control Conference, Shanghai, P.R. China, December 2009.", "journal-ref": null, "doi": "10.1109/CDC.2009.5399968", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we review algorithms for checking diagnosability of\ndiscrete-event systems and timed automata. We point out that the diagnosability\nproblems in both cases reduce to the emptiness problem for (timed) B\\\"uchi\nautomata. Moreover, it is known that, checking whether a discrete-event system\nis diagnosable, can also be reduced to checking bounded diagnosability. We\nestablish a similar result for timed automata. We also provide a synthesis of\nthe complexity results for the different fault diagnosis problems.\n", "versions": [{"version": "v1", "created": "Fri, 16 Apr 2010 05:58:20 GMT"}], "update_date": "2016-11-17", "authors_parsed": [["Cassez", "Franck", ""]]}, {"id": "1004.2780", "submitter": "Emmanuel Haucourt", "authors": "Thibaut Balabonski and Emmanuel Haucourt", "title": "A Geometric Approach to the Problem of Unique Decomposition of Processes", "comments": "15 pages", "journal-ref": null, "doi": "10.1007/978-3-642-15375-4_10", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes a geometric solution to the problem of prime\ndecomposability of concurrent processes first explored by R. Milner and F.\nMoller in [MM93]. Concurrent programs are given a geometric semantics using\ncubical areas, for which a unique factorization theorem is proved. An effective\nfactorization method which is correct and complete with respect to the\ngeometric semantics is derived from the factorization theorem. This algorithm\nis implemented in the static analyzer ALCOOL.\n", "versions": [{"version": "v1", "created": "Fri, 16 Apr 2010 08:21:27 GMT"}], "update_date": "2015-05-18", "authors_parsed": [["Balabonski", "Thibaut", ""], ["Haucourt", "Emmanuel", ""]]}, {"id": "1004.2802", "submitter": "Sylvain Schmitz", "authors": "Pierre Chambart, Alain Finkel, Sylvain Schmitz", "title": "Forward Analysis and Model Checking for Trace Bounded WSTS", "comments": null, "journal-ref": "32nd International Conference on Application and Theory of Petri\n  Nets, volume 6709 of Lecture Notes in Computer Science, pages 49--68.\n  Springer Heidelberg", "doi": "10.1007/978-3-642-21834-7_4", "report-no": "RR-LSV-10-08", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate a subclass of well-structured transition systems (WSTS), the\nbounded---in the sense of Ginsburg and Spanier (Trans. AMS 1964)---complete\ndeterministic ones, which we claim provide an adequate basis for the study of\nforward analyses as developed by Finkel and Goubault-Larrecq (Logic. Meth.\nComput. Sci. 2012). Indeed, we prove that, unlike other conditions considered\npreviously for the termination of forward analysis, boundedness is decidable.\nBoundedness turns out to be a valuable restriction for WSTS verification, as we\nshow that it further allows to decide all $\\omega$-regular properties on the\nset of infinite traces of the system.\n", "versions": [{"version": "v1", "created": "Fri, 16 Apr 2010 09:39:33 GMT"}, {"version": "v2", "created": "Thu, 15 Jul 2010 13:10:45 GMT"}, {"version": "v3", "created": "Tue, 19 Jul 2011 13:30:41 GMT"}, {"version": "v4", "created": "Fri, 4 Mar 2016 13:55:09 GMT"}], "update_date": "2016-03-07", "authors_parsed": [["Chambart", "Pierre", ""], ["Finkel", "Alain", ""], ["Schmitz", "Sylvain", ""]]}, {"id": "1004.2818", "submitter": "Samuel Mimram", "authors": "Eric Goubault (CEA LIST), Samuel Mimram (CEA LIST)", "title": "Formal Relationships Between Geometrical and Classical Models for\n  Concurrency", "comments": null, "journal-ref": "Electronic Notes in Theoretical Computer Science 283 (2012) 77-109", "doi": "10.1016/j.entcs.2012.05.007", "report-no": null, "categories": "cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A wide variety of models for concurrent programs has been proposed during the\npast decades, each one focusing on various aspects of computations: trace\nequivalence, causality between events, conflicts and schedules due to resource\naccesses, etc. More recently, models with a geometrical flavor have been\nintroduced, based on the notion of cubical set. These models are very rich and\nexpressive since they can represent commutation between any bunch of events,\nthus generalizing the principle of true concurrency. While they seem to be very\npromising - because they make possible the use of techniques from algebraic\ntopology in order to study concurrent computations - they have not yet been\nprecisely related to the previous models, and the purpose of this paper is to\nfill this gap. In particular, we describe an adjunction between Petri nets and\ncubical sets which extends the previously known adjunction between Petri nets\nand asynchronous transition systems by Nielsen and Winskel.\n", "versions": [{"version": "v1", "created": "Fri, 16 Apr 2010 11:35:42 GMT"}, {"version": "v2", "created": "Mon, 11 Jun 2012 19:36:18 GMT"}], "update_date": "2012-06-12", "authors_parsed": [["Goubault", "Eric", "", "CEA LIST"], ["Mimram", "Samuel", "", "CEA LIST"]]}, {"id": "1004.2873", "submitter": "Marcello M. Bersani", "authors": "Marcello M. Bersani, Luca Cavallaro, Achille Frigeri, Matteo Pradella,\n  Matteo Rossi", "title": "SMT-based Verification of LTL Specifications with Integer Constraints\n  and its Application to Runtime Checking of Service Substitutability", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An important problem that arises during the execution of service-based\napplications concerns the ability to determine whether a running service can be\nsubstituted with one with a different interface, for example if the former is\nno longer available. Standard Bounded Model Checking techniques can be used to\nperform this check, but they must be able to provide answers very quickly, lest\nthe check hampers the operativeness of the application, instead of aiding it.\nThe problem becomes even more complex when conversational services are\nconsidered, i.e., services that expose operations that have Input/Output data\ndependencies among them. In this paper we introduce a formal verification\ntechnique for an extension of Linear Temporal Logic that allows users to\ninclude in formulae constraints on integer variables. This technique applied to\nthe substitutability problem for conversational services is shown to be\nconsiderably faster and with smaller memory footprint than existing ones.\n", "versions": [{"version": "v1", "created": "Fri, 16 Apr 2010 15:53:38 GMT"}], "update_date": "2010-04-19", "authors_parsed": [["Bersani", "Marcello M.", ""], ["Cavallaro", "Luca", ""], ["Frigeri", "Achille", ""], ["Pradella", "Matteo", ""], ["Rossi", "Matteo", ""]]}, {"id": "1004.2884", "submitter": "Andrey Rybalchenko", "authors": "Ranjit Jhala and Rupak Majumdar and Andrey Rybalchenko", "title": "HMC: Verifying Functional Programs Using Abstract Interpreters", "comments": "12 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present Hindley-Milner-Cousots (HMC), an algorithm that allows any\ninterprocedural analysis for first-order imperative programs to be used to\nverify safety properties of typed higher-order functional programs. HMC works\nas follows. First, it uses the type structure of the functional program to\ngenerate a set of logical refinement constraints whose satisfaction implies the\nsafety of the source program. Next, it transforms the logical refinement\nconstraints into a simple first-order imperative program that is safe iff the\nconstraints are satisfiable. Thus, in one swoop, HMC makes tools for invariant\ngeneration, e.g., based on abstract domains, predicate abstraction,\ncounterexample-guided refinement, and Craig interpolation be directly\napplicable to verify safety properties of modern functional languages in a\nfully automatic manner. We have implemented HMC and describe preliminary\nexperimental results using two imperative checkers -- ARMC and InterProc -- to\nverify OCaml programs. Thus, by composing type-based reasoning grounded in\nprogram syntax and state-based reasoning grounded in abstract interpretation,\nHMC opens the door to automatic verification of programs written in modern\nprogramming languages.\n", "versions": [{"version": "v1", "created": "Fri, 16 Apr 2010 17:01:27 GMT"}, {"version": "v2", "created": "Thu, 30 Dec 2010 14:41:52 GMT"}], "update_date": "2011-01-04", "authors_parsed": [["Jhala", "Ranjit", ""], ["Majumdar", "Rupak", ""], ["Rybalchenko", "Andrey", ""]]}, {"id": "1004.3134", "submitter": "Samuel Mimram", "authors": "Samuel Mimram (LIST)", "title": "Focusing in Asynchronous Games", "comments": null, "journal-ref": "6th Conference on Computability in Europe 6158 (2010)", "doi": "10.1007/978-3-642-13962-8_37", "report-no": null, "categories": "cs.LO cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Game semantics provides an interactive point of view on proofs, which enables\none to describe precisely their dynamical behavior during cut elimination, by\nconsidering formulas as games on which proofs induce strategies. We are\nspecifically interested here in relating two such semantics of linear logic, of\nvery different flavor, which both take in account concurrent features of the\nproofs: asynchronous games and concurrent games. Interestingly, we show that\nassociating a concurrent strategy to an asynchronous strategy can be seen as a\nsemantical counterpart of the focusing property of linear logic.\n", "versions": [{"version": "v1", "created": "Mon, 19 Apr 2010 09:17:07 GMT"}], "update_date": "2015-05-18", "authors_parsed": [["Mimram", "Samuel", "", "LIST"]]}, {"id": "1004.3236", "submitter": "Giorgi Japaridze", "authors": "Giorgi Japaridze", "title": "Introduction to clarithmetic II", "comments": null, "journal-ref": "Information and Computation 247 (2016), pp.290-312", "doi": "10.1016/j.ic.2016.02.002", "report-no": null, "categories": "cs.LO cs.CC math.LO math.NT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The earlier paper \"Introduction to clarithmetic I\" constructed an axiomatic\nsystem of arithmetic based on computability logic (see\nhttp://www.cis.upenn.edu/~giorgi/cl.html), and proved its soundness and\nextensional completeness with respect to polynomial time computability. The\npresent paper elaborates three additional sound and complete systems in the\nsame style and sense: one for polynomial space computability, one for\nelementary recursive time (and/or space) computability, and one for primitive\nrecursive time (and/or space) computability.\n", "versions": [{"version": "v1", "created": "Mon, 19 Apr 2010 15:56:39 GMT"}, {"version": "v2", "created": "Tue, 12 Jul 2011 13:55:07 GMT"}, {"version": "v3", "created": "Sun, 24 Jul 2011 11:53:58 GMT"}, {"version": "v4", "created": "Tue, 23 Aug 2011 12:13:36 GMT"}, {"version": "v5", "created": "Thu, 2 Aug 2012 12:00:28 GMT"}, {"version": "v6", "created": "Wed, 24 Apr 2013 03:18:35 GMT"}], "update_date": "2016-06-24", "authors_parsed": [["Japaridze", "Giorgi", ""]]}, {"id": "1004.3655", "submitter": "Lionel Vaux", "authors": "Christine Tasson (PPS), Lionel Vaux (IML)", "title": "Transport of finiteness structures and applications", "comments": null, "journal-ref": "Mathematical Structures in Computer Science, Cambridge University\n  Press (CUP), 2016", "doi": "10.1017/S0960129516000384", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a general construction of finiteness spaces which subsumes the\ninterpretations of all positive connectors of linear logic. We then show how to\napply this construction to prove the existence of least fixpoints for\nparticular functors in the category of finiteness spaces: these include the\nfunctors involved in a relational interpretation of lazy recursive algebraic\ndatatypes along the lines of the coherence semantics of system T.\n", "versions": [{"version": "v1", "created": "Wed, 21 Apr 2010 09:07:08 GMT"}, {"version": "v2", "created": "Wed, 14 Dec 2016 14:07:30 GMT"}], "update_date": "2016-12-15", "authors_parsed": [["Tasson", "Christine", "", "PPS"], ["Vaux", "Lionel", "", "IML"]]}, {"id": "1004.3842", "submitter": "Antoine Mottet", "authors": "Manuel Bodirsky, Victor Dalmau, Barnaby Martin, Antoine Mottet,\n  Michael Pinsker", "title": "Distance Constraint Satisfaction Problems", "comments": "35 pages, 2 figures", "journal-ref": "Information and Computation. Vol. 247, pp. 87-105. 2016", "doi": "10.1016/j.ic.2015.11.010", "report-no": null, "categories": "cs.CC cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the complexity of constraint satisfaction problems for templates\n$\\Gamma$ that are first-order definable in $(\\Bbb Z; succ)$, the integers with\nthe successor relation. Assuming a widely believed conjecture from finite\ndomain constraint satisfaction (we require the tractability conjecture by\nBulatov, Jeavons and Krokhin in the special case of transitive finite\ntemplates), we provide a full classification for the case that Gamma is locally\nfinite (i.e., the Gaifman graph of $\\Gamma$ has finite degree). We show that\none of the following is true: The structure Gamma is homomorphically equivalent\nto a structure with a d-modular maximum or minimum polymorphism and\n$\\mathrm{CSP}(\\Gamma)$ can be solved in polynomial time, or $\\Gamma$ is\nhomomorphically equivalent to a finite transitive structure, or\n$\\mathrm{CSP}(\\Gamma)$ is NP-complete.\n", "versions": [{"version": "v1", "created": "Thu, 22 Apr 2010 06:12:26 GMT"}, {"version": "v2", "created": "Mon, 23 May 2011 22:07:47 GMT"}, {"version": "v3", "created": "Tue, 26 Apr 2016 15:01:42 GMT"}], "update_date": "2016-04-27", "authors_parsed": [["Bodirsky", "Manuel", ""], ["Dalmau", "Victor", ""], ["Martin", "Barnaby", ""], ["Mottet", "Antoine", ""], ["Pinsker", "Michael", ""]]}, {"id": "1004.4656", "submitter": "Krzysztof R. Apt", "authors": "Krzysztof R. Apt, Frank S. de Boer, Ernst-Ruediger Olderog and Stijn\n  de Gouw", "title": "Verification of Object-Oriented Programs: a Transformational Approach", "comments": "49 pages. To appear in Journal of Computer and System Sciences. Stijn\n  de Gouw is now a new author", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that verification of object-oriented programs by means of the\nassertional method can be achieved in a simple way by exploiting a\nsyntax-directed transformation from object-oriented programs to recursive\nprograms. This transformation suggests natural proofs rules and its correctness\nhelps us to establish soundness and relative completeness of the proposed proof\nsystem. One of the difficulties is how to properly deal in the assertion\nlanguage with the instance variables and aliasing. The discussed programming\nlanguage supports arrays, instance variables, failures and recursive methods\nwith parameters.\n", "versions": [{"version": "v1", "created": "Mon, 26 Apr 2010 21:02:10 GMT"}, {"version": "v2", "created": "Wed, 27 Jul 2011 06:57:28 GMT"}, {"version": "v3", "created": "Tue, 8 Nov 2011 07:41:30 GMT"}], "update_date": "2011-11-09", "authors_parsed": [["Apt", "Krzysztof R.", ""], ["de Boer", "Frank S.", ""], ["Olderog", "Ernst-Ruediger", ""], ["de Gouw", "Stijn", ""]]}, {"id": "1004.4998", "submitter": "Cesar Dominguez", "authors": "C\\'esar Dom\\'inguez and Julio Rubio", "title": "Computing in Coq with Infinite Algebraic Data Structures", "comments": "To appear in Conferences on Intelligent Computer Mathematics 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computational content encoded into constructive type theory proofs can be\nused to make computing experiments over concrete data structures. In this\npaper, we explore this possibility when working in Coq with chain complexes of\ninfinite type (that is to say, generated by infinite sets) as a part of the\nformalization of a hierarchy of homological algebra structures.\n", "versions": [{"version": "v1", "created": "Wed, 28 Apr 2010 11:04:47 GMT"}], "update_date": "2010-04-29", "authors_parsed": [["Dom\u00ednguez", "C\u00e9sar", ""], ["Rubio", "Julio", ""]]}, {"id": "1004.5034", "submitter": "Franck Butelle", "authors": "Franck Butelle and Florent Hivert and Micaela Mayero and Fr\\'ed\\'eric\n  Toumazet", "title": "Formal Proof of SCHUR Conjugate Function", "comments": "To appear in CALCULEMUS 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.MS cs.SC cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The main goal of our work is to formally prove the correctness of the key\ncommands of the SCHUR software, an interactive program for calculating with\ncharacters of Lie groups and symmetric functions. The core of the computations\nrelies on enumeration and manipulation of combinatorial structures. As a first\n\"proof of concept\", we present a formal proof of the conjugate function,\nwritten in C. This function computes the conjugate of an integer partition. To\nformally prove this program, we use the Frama-C software. It allows us to\nannotate C functions and to generate proof obligations, which are proved using\nseveral automated theorem provers. In this paper, we also draw on methodology,\ndiscussing on how to formally prove this kind of program.\n", "versions": [{"version": "v1", "created": "Wed, 28 Apr 2010 14:12:43 GMT"}], "update_date": "2010-04-29", "authors_parsed": [["Butelle", "Franck", ""], ["Hivert", "Florent", ""], ["Mayero", "Micaela", ""], ["Toumazet", "Fr\u00e9d\u00e9ric", ""]]}, {"id": "1004.5130", "submitter": "Omar Bataineh", "authors": "Omar I. Al-Bataineh (1), Ron van der Meyden (2) (1,2 University of New\n  South Wales)", "title": "Epistemic Model Checking for Knowledge-Based Program Implementation: an\n  Application to Anonymous Broadcast", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DC", "license": "http://creativecommons.org/licenses/publicdomain/", "abstract": "  Knowledge-based programs provide an abstract level of description of\nprotocols in which agent actions are related to their states of knowledge. The\npaper describes how epistemic model checking technology may be applied to\ndiscover and verify concrete implementations based on this abstract level of\ndescription. The details of the implementations depend on the specific context\nof use of the protocol. The knowledge-based approach enables the\nimplementations to be optimized relative to these conditions of use. The\napproach is illustrated using extensions of the Dining Cryptographers protocol,\na security protocol for anonymous broadcast.\n", "versions": [{"version": "v1", "created": "Mon, 26 Apr 2010 00:16:31 GMT"}], "update_date": "2016-10-05", "authors_parsed": [["Al-Bataineh", "Omar I.", ""], ["van der Meyden", "Ron", ""]]}, {"id": "1004.5257", "submitter": "Pierre Lescanne", "authors": "Pierre Lescanne (LIP), Perrinel Matthieu (LIP)", "title": "On the Rationality of Escalation", "comments": "23 p.", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Escalation is a typical feature of infinite games. Therefore tools conceived\nfor studying infinite mathematical structures, namely those deriving from\ncoinduction are essential. Here we use coinduction, or backward coinduction (to\nshow its connection with the same concept for finite games) to study carefully\nand formally the infinite games especially those called dollar auctions, which\nare considered as the paradigm of escalation. Unlike what is commonly admitted,\nwe show that, provided one assumes that the other agent will always stop,\nbidding is rational, because it results in a subgame perfect equilibrium. We\nshow that this is not the only rational strategy profile (the only subgame\nperfect equilibrium). Indeed if an agent stops and will stop at every step, we\nclaim that he is rational as well, if one admits that his opponent will never\nstop, because this corresponds to a subgame perfect equilibrium. Amazingly, in\nthe infinite dollar auction game, the behavior in which both agents stop at\neach step is not a Nash equilibrium, hence is not a subgame perfect\nequilibrium, hence is not rational.\n", "versions": [{"version": "v1", "created": "Thu, 29 Apr 2010 12:03:29 GMT"}], "update_date": "2010-04-30", "authors_parsed": [["Lescanne", "Pierre", "", "LIP"], ["Matthieu", "Perrinel", "", "LIP"]]}, {"id": "1004.5339", "submitter": "Kostyantyn Shchekotykhin", "authors": "Kostyantyn Shchekotykhin, Gerhard Friedrich, Philipp Fleiss, Patrick\n  Rodler", "title": "Query strategy for sequential ontology debugging", "comments": "Preprint submitted to Web Semantics: Science, Services and Agents on\n  the World Wide Web", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Debugging of ontologies is an important prerequisite for their wide-spread\napplication, especially in areas that rely upon everyday users to create and\nmaintain knowledge bases, as in the case of the Semantic Web. Recent approaches\nuse diagnosis methods to identify causes of inconsistent or incoherent\nontologies. However, in most debugging scenarios these methods return many\nalternative diagnoses, thus placing the burden of fault localization on the\nuser. This paper demonstrates how the target diagnosis can be identified by\nperforming a sequence of observations, that is, by querying an oracle about\nentailments of the target ontology. We exploit a-priori probabilities of\ntypical user errors to formulate information-theoretic concepts for query\nselection. Our evaluation showed that the proposed method significantly reduces\nthe number of required queries compared to myopic strategies. We experimented\nwith different probability distributions of user errors and different qualities\nof the a-priori probabilities. Our measurements showed the advantageousness of\ninformation-theoretic approach to query selection even in cases where only a\nrough estimate of the priors is available.\n", "versions": [{"version": "v1", "created": "Thu, 29 Apr 2010 16:46:09 GMT"}, {"version": "v2", "created": "Fri, 30 Apr 2010 13:00:40 GMT"}, {"version": "v3", "created": "Thu, 21 Jul 2011 08:43:45 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Shchekotykhin", "Kostyantyn", ""], ["Friedrich", "Gerhard", ""], ["Fleiss", "Philipp", ""], ["Rodler", "Patrick", ""]]}, {"id": "1004.5382", "submitter": "Pritam Roy", "authors": "Pritam Roy", "title": "Interface Building for Software by Modular Three-Valued Abstraction\n  Refinement", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Verification of software systems is a very hard problem due to the large size\nof program state-space. The traditional techniques (like model checking) do not\nscale; since they include the whole state-space by inlining the library\nfunction codes. Current research avoids these problem by creating a lightweight\nrepresentation of the library in form of an \"interface graph\" (call sequence\ngraph). In this paper we introduce a new algorithm to compute a safe,\npermissive interface graph for C-type functions. In this modular analysis, each\nfunction transition is summarized following three-valued abstraction semantics.\nThere are two kinds of abstraction used here. The global abstraction contains\npredicates over global variables only; however the local abstraction inside\neach function may also contain the local variables. The abstract summary needs\nrefinement to guarantee safety and permissiveness. We have implemented the\nalgorithms in TICC tool and compared this algorithm with some related interface\ngeneration algorithms. We also discuss the application of interface as an\noffline test-suite. We create an interface from the model program\n(specification) and the interface will act as a test-suite for the new\nimplementation-under-test (IUT).\n", "versions": [{"version": "v1", "created": "Thu, 29 Apr 2010 20:01:33 GMT"}], "update_date": "2010-05-03", "authors_parsed": [["Roy", "Pritam", ""]]}, {"id": "1004.5500", "submitter": "Christoph Benzmueller", "authors": "Christoph Benzmueller", "title": "Simple Type Theory as Framework for Combining Logics", "comments": "Contest paper at the World Congress and School on Universal Logic III\n  (UNILOG'2010), Lisbon, Portugal, April 18-25, 2010.", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Simple type theory is suited as framework for combining classical and\nnon-classical logics. This claim is based on the observation that various\nprominent logics, including (quantified) multimodal logics and intuitionistic\nlogics, can be elegantly embedded in simple type theory. Furthermore, simple\ntype theory is sufficiently expressive to model combinations of embedded logics\nand it has a well understood semantics. Off-the-shelf reasoning systems for\nsimple type theory exist that can be uniformly employed for reasoning within\nand about combinations of logics.\n", "versions": [{"version": "v1", "created": "Fri, 30 Apr 2010 11:20:10 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Benzmueller", "Christoph", ""]]}]