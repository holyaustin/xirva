[{"id": "1911.00055", "submitter": "Ali Sadeghian", "authors": "Ali Sadeghian, Mohammadreza Armandpour, Patrick Ding, Daisy Zhe Wang", "title": "DRUM: End-To-End Differentiable Rule Mining On Knowledge Graphs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.LO stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we study the problem of learning probabilistic logical rules\nfor inductive and interpretable link prediction. Despite the importance of\ninductive link prediction, most previous works focused on transductive link\nprediction and cannot manage previously unseen entities. Moreover, they are\nblack-box models that are not easily explainable for humans. We propose DRUM, a\nscalable and differentiable approach for mining first-order logical rules from\nknowledge graphs which resolves these problems. We motivate our method by\nmaking a connection between learning confidence scores for each rule and\nlow-rank tensor approximation. DRUM uses bidirectional RNNs to share useful\ninformation across the tasks of learning rules for different relations. We also\nempirically demonstrate the efficiency of DRUM over existing rule mining\nmethods for inductive link prediction on a variety of benchmark datasets.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 18:51:33 GMT"}], "update_date": "2019-11-04", "authors_parsed": [["Sadeghian", "Ali", ""], ["Armandpour", "Mohammadreza", ""], ["Ding", "Patrick", ""], ["Wang", "Daisy Zhe", ""]]}, {"id": "1911.00268", "submitter": "Kazutaka Matsuda", "authors": "Kazutaka Matsuda", "title": "Modular Inference of Linear Types for Multiplicity-Annotated Arrows", "comments": "The full version of our paper to appear in ESOP 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bernardy et al. [2018] proposed a linear type system $\\lambda^q_\\to$ as a\ncore type system of Linear Haskell. In the system, linearity is represented by\nannotated arrow types $A \\to_m B$, where $m$ denotes the multiplicity of the\nargument. Thanks to this representation, existing non-linear code typechecks as\nit is, and newly written linear code can be used with existing non-linear code\nin many cases. However, little is known about the type inference of\n$\\lambda^q_\\to$. Although the Linear Haskell implementation is equipped with\ntype inference, its algorithm has not been formalized, and the implementation\noften fails to infer principal types, especially for higher-order functions. In\nthis paper, based on OutsideIn(X) [Vytiniotis et al., 2011], we propose an\ninference system for a rank 1 qualified-typed variant of $\\lambda^q_\\to$, which\ninfers principal types. A technical challenge in this new setting is to deal\nwith ambiguous types inferred by naive qualified typing. We address this\nambiguity issue through quantifier elimination and demonstrate the\neffectiveness of the approach with examples.\n", "versions": [{"version": "v1", "created": "Fri, 1 Nov 2019 09:06:46 GMT"}, {"version": "v2", "created": "Wed, 19 Feb 2020 05:26:18 GMT"}], "update_date": "2020-02-20", "authors_parsed": [["Matsuda", "Kazutaka", ""]]}, {"id": "1911.00385", "submitter": "Joseph Tassarotti", "authors": "Joseph Tassarotti, Koundinya Vajjha, Anindya Banerjee, Jean-Baptiste\n  Tristan", "title": "A Formal Proof of PAC Learnability for Decision Stumps", "comments": "13 pages, appeared in Certified Programs and Proofs (CPP) 2021", "journal-ref": null, "doi": "10.1145/3437992.3439917", "report-no": null, "categories": "cs.LG cs.LO stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a formal proof in Lean of probably approximately correct (PAC)\nlearnability of the concept class of decision stumps. This classic result in\nmachine learning theory derives a bound on error probabilities for a simple\ntype of classifier. Though such a proof appears simple on paper, analytic and\nmeasure-theoretic subtleties arise when carrying it out fully formally. Our\nproof is structured so as to separate reasoning about deterministic properties\nof a learning function from proofs of measurability and analysis of\nprobabilities.\n", "versions": [{"version": "v1", "created": "Fri, 1 Nov 2019 14:02:39 GMT"}, {"version": "v2", "created": "Fri, 29 Nov 2019 14:37:47 GMT"}, {"version": "v3", "created": "Thu, 7 Jan 2021 22:38:00 GMT"}], "update_date": "2021-01-11", "authors_parsed": [["Tassarotti", "Joseph", ""], ["Vajjha", "Koundinya", ""], ["Banerjee", "Anindya", ""], ["Tristan", "Jean-Baptiste", ""]]}, {"id": "1911.00399", "submitter": "Joshua Chen", "authors": "Joshua Chen", "title": "An Implementation of Homotopy Type Theory in Isabelle/Pure", "comments": "Masters thesis", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this Masters thesis we present an implementation of a fragment of \"book\nHoTT\" as an object logic for the interactive proof assistant Isabelle. We also\ngive a mathematical description of the underlying theory of the Isabelle/Pure\nlogical framework, and discuss various issues and design decisions that arise\nwhen attempting to encode intensional dependent type theory with universes\ninside a simple type-theoretic logical foundation.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 14:46:31 GMT"}], "update_date": "2019-11-04", "authors_parsed": [["Chen", "Joshua", ""]]}, {"id": "1911.00403", "submitter": "Barnaby Martin", "authors": "Stefan Dantchev, Abdul Ghani, Barnaby Martin", "title": "Sherali-Adams and the binary encoding of combinatorial principles", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the Sherali-Adams (SA) refutation system together with the\nunusual binary encoding of certain combinatorial principles. For the unary\nencoding of the Pigeonhole Principle and the Least Number Principle, it is\nknown that linear rank is required for refutations in SA, although both admit\nrefutations of polynomial size. We prove that the binary encoding of the\nPigeonhole Principle requires exponentially-sized SA refutations, whereas the\nbinary encoding of the Least Number Principle admits logarithmic rank,\npolynomially-sized SA refutations. We continue by considering a refutation\nsystem between SA and Lasserre (Sum-of-Squares). In this system, the Least\nNumber Principle requires linear rank while the Pigeonhole Principle becomes\nconstant rank.\n", "versions": [{"version": "v1", "created": "Fri, 1 Nov 2019 14:30:32 GMT"}], "update_date": "2019-11-04", "authors_parsed": [["Dantchev", "Stefan", ""], ["Ghani", "Abdul", ""], ["Martin", "Barnaby", ""]]}, {"id": "1911.00406", "submitter": "Mauricio Ayala-Rincon", "authors": "Ariane Alves Almeida and Mauricio Ayala-Rincon", "title": "Formalizing the Dependency Pair Criterion for Innermost Termination", "comments": "Paper accepted for presentation at SBMF 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Rewriting is a framework for reasoning about functional programming. The\ndependency pair criterion is a well-known mechanism to analyze termination of\nterm rewriting systems. Functional specifications with an operational semantics\nbased on evaluation are related, in the rewriting framework, to the innermost\nreduction relation. This paper presents a PVS formalization of the dependency\npair criterion for the innermost reduction relation: a term rewriting system is\ninnermost terminating if and only if it is terminating by the dependency pair\ncriterion. The paper also discusses the application of this criterion to check\ntermination of functional specifications.\n", "versions": [{"version": "v1", "created": "Wed, 30 Oct 2019 03:28:16 GMT"}], "update_date": "2019-11-04", "authors_parsed": [["Almeida", "Ariane Alves", ""], ["Ayala-Rincon", "Mauricio", ""]]}, {"id": "1911.00407", "submitter": "Marco Peressotti", "authors": "Jakob Lykke Andersen and Marc Hellmuth and Daniel Merkle and Nikolai\n  N{\\o}jgaard and Marco Peressotti", "title": "A Graph-Based Tool to Embed the {\\pi}-Calculus into a Computational DPO\n  Framework", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Graph transformation approaches have been successfully used to analyse and\ndesign chemical and biological systems. Here we build on top of a DPO\nframework, in which molecules are modelled as typed attributed graphs and\nchemical reactions are modelled as graph transformations. Edges and vertexes\ncan be labelled with first-order terms, which can be used to encode, e.g.,\nsteric information of molecules. While targeted to chemical settings, the\ncomputational framework is intended to be very generic and applicable to the\nexploration of arbitrary spaces derived via iterative application of rewrite\nrules, such as process calculi like Milner's {\\pi}-calculus. To illustrate the\ngenerality of the framework, we introduce EpiM: a tool for computing execution\nspaces of {\\pi}-calculus processes. EpiM encodes {\\pi}-calculus processes as\ntyped attributed graphs and then exploits the existing DPO framework to compute\ntheir dynamics in the form of graphs where nodes are {\\pi}-calculus processes\nand edges are reduction steps. EpiM takes advantage of the graph-based\nrepresentation and facilities offered by the framework, like efficient\nisomorphism checking to prune the space without resorting to explicit\nstructural equivalences. EpiM is available as an online Python-based tool.\n", "versions": [{"version": "v1", "created": "Tue, 29 Oct 2019 10:23:01 GMT"}], "update_date": "2019-11-04", "authors_parsed": [["Andersen", "Jakob Lykke", ""], ["Hellmuth", "Marc", ""], ["Merkle", "Daniel", ""], ["N\u00f8jgaard", "Nikolai", ""], ["Peressotti", "Marco", ""]]}, {"id": "1911.00462", "submitter": "Leandro Gomes", "authors": "Leandro Gomes", "title": "On the construction of multi-valued concurrent dynamic logic", "comments": "13 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dynamic logic is a powerful framework for reasoning about imperative\nprograms. An extension with a concurrent operator [18] was introduced to\nformalise programs running in parallel. In other direction, other authors\nproposed a systematic method for generating multi-valued propositional dynamic\nlogics to reason about weighted programs [14]. This paper presents the first\nstep of combining these two frameworks to introduce uncertainty in concurrent\ncomputations. In the developed framework, a weight is assigned to each branch\nof the parallel execution, resulting in a (possible) asymmetric parallelism,\ninherent to fuzzy programming paradigm [21, 2]. By adopting such an approach, a\nfamily of logics is obtained, called multi-valued concurrent propositional\ndynamic logics (CGDL(A)), parametric on an action lattice A specifying a notion\nof \"weight\" assigned to program execution. Additionally, the validity of some\naxioms of CPDL is discussed in the new family of generated logics.\n", "versions": [{"version": "v1", "created": "Fri, 1 Nov 2019 16:54:26 GMT"}], "update_date": "2019-11-04", "authors_parsed": [["Gomes", "Leandro", ""]]}, {"id": "1911.00580", "submitter": "Martin Escardo", "authors": "Mart\\'in H\\\"otzel Escard\\'o", "title": "Introduction to Univalent Foundations of Mathematics with Agda", "comments": "200 pages, extended version of Midlands Graduate School course\n  (2019), includes Agda-verified mathematics. Sources available at github (as\n  explained in the pdf file), but not in LaTeX", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce Voevodsky's univalent foundations and univalent mathematics, and\nexplain how to develop them with the computer system Agda, which is based on\nMartin-L\\\"of type theory. Agda allows us to write mathematical definitions,\nconstructions, theorems and proofs, for example in number theory, analysis,\ngroup theory, topology, category theory or programming language theory,\nchecking them for logical and mathematical correctness.\n  Agda is a constructive mathematical system by default, which amounts to\nsaying that it can also be considered as a programming language for\nmanipulating mathematical objects. But we can assume the axiom of choice or the\nprinciple of excluded middle for pieces of mathematics that require them, at\nthe cost of losing the implicit programming-language character of the system.\nFor a fully constructive development of univalent mathematics in Agda, we would\nneed to use its new cubical flavour, and we hope these notes provide a base for\nresearchers interested in learning cubical type theory and cubical Agda as the\nnext step.\n  Compared to most expositions of the subject, we work with explicit universe\nlevels.\n", "versions": [{"version": "v1", "created": "Fri, 1 Nov 2019 20:29:08 GMT"}, {"version": "v2", "created": "Wed, 5 Feb 2020 23:10:20 GMT"}, {"version": "v3", "created": "Mon, 16 Nov 2020 17:17:29 GMT"}], "update_date": "2020-11-17", "authors_parsed": [["Escard\u00f3", "Mart\u00edn H\u00f6tzel", ""]]}, {"id": "1911.00608", "submitter": "Hussein Sibai", "authors": "Hussein Sibai and Navid Mokhlesi and Chuchu Fan and Sayan Mitra", "title": "Multi-Agent Safety Verification using Symmetry Transformations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.SC cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that symmetry transformations and caching can enable scalable, and\npossibly unbounded, verification of multi-agent systems. Symmetry\ntransformations map solutions and to other solutions. We show that this\nproperty can be used to transform cached reachsets to compute new reachsets,\nfor hybrid and multi-agent models. We develop a notion of virtual system which\ndefine symmetry transformations for a broad class of agent models that visit\nwaypoint sequences. Using this notion of virtual system, we present a prototype\ntool CacheReach that builds a cache of reachtubes for this system, in a way\nthat is agnostic of the representation of the reachsets and the reachability\nanalysis subroutine used. Our experimental evaluation of CacheReach shows up to\n66% savings in safety verification computation time on multi-agent systems with\n3-dimensional linear and 4-dimensional nonlinear fixed-wing aircraft models\nfollowing sequences of waypoints. These savings and our theoretical results\nillustrate the potential benefits of using symmetry-based caching in the safety\nverification of multi-agent systems.\n", "versions": [{"version": "v1", "created": "Fri, 1 Nov 2019 22:51:34 GMT"}], "update_date": "2019-11-05", "authors_parsed": [["Sibai", "Hussein", ""], ["Mokhlesi", "Navid", ""], ["Fan", "Chuchu", ""], ["Mitra", "Sayan", ""]]}, {"id": "1911.00620", "submitter": "Jeremy Alm", "authors": "Jeremy F. Alm, Saeed Moazami, Jorge Montero-Vallejo, Linda Pham, Dave\n  Sexton, Xiaonan Xu", "title": "Improved bounds on the size of the smallest representation of relation\n  algebra $32_{65}$ with the aid of a SAT solver", "comments": "14 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we shed new light on the spectrum of relation algebra\n$32_{65}$. We show that 1024 is in the spectrum, and no number smaller than 20\nis in the spectrum. In addition, we derive upper and lower bounds on the\nsmallest member of the spectra of an infinite class of algebras derived from\n$32_{65}$ via splitting.\n", "versions": [{"version": "v1", "created": "Sat, 2 Nov 2019 00:44:52 GMT"}], "update_date": "2019-11-05", "authors_parsed": [["Alm", "Jeremy F.", ""], ["Moazami", "Saeed", ""], ["Montero-Vallejo", "Jorge", ""], ["Pham", "Linda", ""], ["Sexton", "Dave", ""], ["Xu", "Xiaonan", ""]]}, {"id": "1911.00696", "submitter": "Bartosz Bednarczyk", "authors": "Bartosz Bednarczyk", "title": "Statistical EL is ExpTime-complete", "comments": "Major revision of the previous version, extra lemma provided, a few\n  grammar corrections. Under submission to IPL", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that the consistency problem for Statistical EL ontologies, defined\nby Pe{\\~{n}}aloza and Potyka, is ExpTime-hard. Together with existing ExpTime\nupper bounds, we conclude ExpTime-completeness of the logic. Our proof goes via\na reduction from the consistency problem for EL extended with negation of\natomic concepts.\n", "versions": [{"version": "v1", "created": "Sat, 2 Nov 2019 11:17:42 GMT"}, {"version": "v2", "created": "Fri, 31 Jul 2020 17:22:06 GMT"}, {"version": "v3", "created": "Wed, 21 Oct 2020 18:48:14 GMT"}, {"version": "v4", "created": "Wed, 3 Mar 2021 11:19:59 GMT"}, {"version": "v5", "created": "Fri, 5 Mar 2021 13:22:38 GMT"}], "update_date": "2021-03-08", "authors_parsed": [["Bednarczyk", "Bartosz", ""]]}, {"id": "1911.00786", "submitter": "Pavel Naumov", "authors": "Pavel Naumov and Rui-Jie Yew", "title": "Ethical Dilemmas in Strategic Games", "comments": "Proceedings of 35th AAAI Conference on Artificial Intelligence (AAAI\n  21), February 2-9, 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An agent, or a coalition of agents, faces an ethical dilemma between several\nstatements if she is forced to make a conscious choice between which of these\nstatements will be true. This paper proposes to capture ethical dilemmas as a\nmodality in strategic game settings with and without limit on sacrifice and for\nperfect and imperfect information games. The authors show that the dilemma\nmodality cannot be defined through the earlier proposed blameworthiness\nmodality. The main technical result is a sound and complete axiomatization of\nthe properties of this modality with sacrifice in games with perfect\ninformation.\n", "versions": [{"version": "v1", "created": "Sat, 2 Nov 2019 21:12:57 GMT"}, {"version": "v2", "created": "Sun, 13 Dec 2020 22:41:18 GMT"}, {"version": "v3", "created": "Tue, 2 Mar 2021 02:31:19 GMT"}], "update_date": "2021-03-03", "authors_parsed": [["Naumov", "Pavel", ""], ["Yew", "Rui-Jie", ""]]}, {"id": "1911.00874", "submitter": "Henning Urbat", "authors": "Henning Urbat and Lutz Schr\\\"oder", "title": "Automata Learning: An Algebraic Approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LG cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We propose a generic categorical framework for learning unknown formal\nlanguages of various types (e.g. finite or infinite words, weighted and nominal\nlanguages). Our approach is parametric in a monad T that represents the given\ntype of languages and their recognizing algebraic structures. Using the concept\nof anautomata presentation of T-algebras, we demonstrate that the task of\nlearning a T-recognizable language can be reduced to learning an abstract form\nof algebraic automaton whose transitions are modeled by a functor. For the\nimportant case of adjoint automata, we devise a learning algorithm generalizing\nAngluin's L*. The algorithm is phrased in terms of categorically described\nextension steps; we provide for a termination and complexity analysis based on\na dedicated notion of finiteness. Our framework applies to structures like\nomega-regular languages that were not within the scope of existing categorical\naccounts of automata learning. In addition, it yields new learning algorithms\nfor several types of languages for which no such algorithms were previously\nknown at all, including sorted languages, nominal languages with name binding,\nand cost functions.\n", "versions": [{"version": "v1", "created": "Sun, 3 Nov 2019 11:42:50 GMT"}, {"version": "v2", "created": "Tue, 5 May 2020 15:44:53 GMT"}, {"version": "v3", "created": "Fri, 28 Aug 2020 13:35:41 GMT"}], "update_date": "2020-08-31", "authors_parsed": [["Urbat", "Henning", ""], ["Schr\u00f6der", "Lutz", ""]]}, {"id": "1911.00928", "submitter": "Mohammad Rahman", "authors": "Mohammad Ashiqur Rahman, Md Hasan Shahriar, Mohamadsaleh Jafari, Rahat\n  Masum", "title": "Novel Attacks against Contingency Analysis in Power Grids", "comments": "The paper is under review at a conference. Rahman and Shahriar are\n  the co-first authors of this paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.CR cs.LO cs.SY", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Contingency Analysis (CA) is a core component of the Energy Management System\n(EMS) in the power grid. The goal of CA is to operate the power system in a\nsecure manner by analyzing the system subject to a contingency (e.g., the\noutage of a transmission line or a power generator) to determine the setpoints\nthat will allow system operation without violation of constraints. The analysis\nin CA is conducted based on the output from State Estimation (SE), another core\nEMS module. However, it is also shown that an adversary can alter certain power\nmeasurements to corrupt the system states estimated by SE without being\ndetected. Such a corrupted estimation can severely skew the results of the\ncontingency analysis as it will provide a fake model to deal with. In this\nresearch, we formally model necessary interdependency relationships and\nsystematically analyze these novel attacks on the contingency analysis. In\nparticular, this research focuses on Security Constrained Optimal Power Flow\n(SCOPF) that finds out the optimal economic dispatches considering a single\nline failure (based on the $n - 1$ contingency analysis) and transmission line\ncapacities. The proposed model is implemented and solved to find out potential\nthreat vectors (i.e., a set of measurements to be altered) that can evade CA so\nthat the system will face overloading situation on one or more transmission\nlines when some specific contingencies happen. We demonstrate our formal model\non an IEEE 14 bus system-based case study and verify the results with a\nstandard PowerWorld model. We further evaluate the model with respect to\nvarious attacks and grid characteristics.\n", "versions": [{"version": "v1", "created": "Sun, 3 Nov 2019 16:49:30 GMT"}], "update_date": "2019-11-05", "authors_parsed": [["Rahman", "Mohammad Ashiqur", ""], ["Shahriar", "Md Hasan", ""], ["Jafari", "Mohamadsaleh", ""], ["Masum", "Rahat", ""]]}, {"id": "1911.01077", "submitter": "J\\\"urgen Giesl", "authors": "Florian Frohn, Matthias Naaf, Marc Brockschmidt, J\\\"urgen Giesl", "title": "Inferring Lower Runtime Bounds for Integer Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a technique to infer lower bounds on the worst-case runtime\ncomplexity of integer programs, where in contrast to earlier work, our approach\nis not restricted to tail-recursion. Our technique constructs symbolic\nrepresentations of program executions using a framework for iterative,\nunder-approximating program simplification. The core of this simplification is\na method for (under-approximating) program acceleration based on recurrence\nsolving and a variation of ranking functions. Afterwards, we deduce asymptotic\nlower bounds from the resulting simplified programs using a special-purpose\ncalculus and an SMT encoding. We implemented our technique in our tool LoAT and\nshow that it infers non-trivial lower bounds for a large class of examples.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 09:03:49 GMT"}, {"version": "v2", "created": "Mon, 13 Jul 2020 13:51:49 GMT"}, {"version": "v3", "created": "Mon, 28 Sep 2020 16:19:28 GMT"}], "update_date": "2020-09-29", "authors_parsed": [["Frohn", "Florian", ""], ["Naaf", "Matthias", ""], ["Brockschmidt", "Marc", ""], ["Giesl", "J\u00fcrgen", ""]]}, {"id": "1911.01085", "submitter": "Luigi Santocanale", "authors": "Luigi Santocanale (LIS, LIRICA)", "title": "The Involutive Quantaloid of Completely Distributive Lattices", "comments": null, "journal-ref": "RAMICS 2020, Uli Fahrenberg; Peter Jipsen; Michael Winter, Apr\n  2020, Palaiseau, France. pp.286-301", "doi": null, "report-no": null, "categories": "cs.LO math.CT math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let L be a complete lattice and let Q(L) be the unital quantale of\njoin-continuous endo-functions of L. We prove the following result: Q(L) is an\ninvolutive (that is, non-commutative cyclic $\\star$-autonomous) quantale if and\nonly if L is a completely distributive lattice. If this is the case, then the\ndual tensor operation corresponds, via Raney's transforms, to composition in\nthe (dual) quantale of meet-continuous endo-functions of L. Let sLatt be the\ncategory of sup-lattices and join-continuous functions and let cdLatt be the\nfull subcategory of sLatt whose objects are the completely distributive\nlattices. We argue that (i) cdLatt is itself an involutive quantaloid, and\ntherefore it is the largest full-subcategory of sLatt with this property; (ii)\ncdLatt is closed under the monoidal operations of sLatt and, consequently, if\nQ(L) is involutive, then Q(L) is completely distributive as well.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 09:31:58 GMT"}, {"version": "v2", "created": "Fri, 15 Nov 2019 14:35:09 GMT"}, {"version": "v3", "created": "Fri, 17 Apr 2020 13:42:30 GMT"}], "update_date": "2020-04-20", "authors_parsed": [["Santocanale", "Luigi", "", "LIS, LIRICA"]]}, {"id": "1911.01146", "submitter": "Leandro Gomes", "authors": "Leandro Gomes, Alexandre Madeira, Lu\\'is Soares Barbosa", "title": "Generalising KAT to verify weighted computations", "comments": "49 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Kleene algebra with tests (KAT) was introduced as an algebraic structure to\nmodel and reason about classic imperative programs, i.e. sequences of discrete\ntransitions guarded by Boolean tests. This paper introduces two generalisations\nof this structure able to express programs as weighted transitions and tests\nwith outcomes in non necessarily bivalent truth spaces: graded Kleene algebra\nwith tests (GKAT) and a variant where tests are also idempotent (I-GKAT). On\nthis context, and in analogy to Kozen's encoding of Propositional Hoare Logic\n(PHL) in KAT [22], we discuss the encoding of a graded PHL in I-GKAT and of its\nwhile-free fragment in GKAT. Moreover, to establish semantics for these\nstructures four new algebras are defined: FSET(T), FREL(K,T) and FLANG(K,T)\nover complete residuated lattices K and T, and M(n,A) over a GKAT or I-GKAT A.\nAs a final exercise, the paper discusses some program equivalence proofs in a\ngraded context.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 11:54:57 GMT"}], "update_date": "2019-11-05", "authors_parsed": [["Gomes", "Leandro", ""], ["Madeira", "Alexandre", ""], ["Barbosa", "Lu\u00eds Soares", ""]]}, {"id": "1911.01185", "submitter": "Sosuke Moriguchi", "authors": "Sosuke Moriguchi and Kazuko Takahashi", "title": "Compiling Arguments in an Argumentation Framework into Three-valued\n  Logical Expressions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we propose a new method for computing general allocators\ndirectly from completeness conditions. A general allocator is an abstraction of\nall complete labelings for an argumentation framework. Any complete labeling is\nobtained from a general allocator by assigning logical constants to variables.\nWe proved the existence of the general allocators in our previous work.\nHowever, the construction requires us to enumerate all complete labelings for\nthe framework, which makes the computation prohibitively slow. The method\nproposed in this paper enables us to compute general allocators without\nenumerating complete labelings. It also provides the solutions of local\nallocation that yield semantics for subsets of the framework. We demonstrate\ntwo applications of general allocators, stability, and a new concept for\nframeworks, termed arity. Moreover, the method, including local allocation, is\napplicable to broad extensions of frameworks, such as argumentation frameworks\nwith set-attacks, bipolar argumentation frameworks, and abstract dialectical\nframeworks.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 13:19:19 GMT"}], "update_date": "2019-11-05", "authors_parsed": [["Moriguchi", "Sosuke", ""], ["Takahashi", "Kazuko", ""]]}, {"id": "1911.01195", "submitter": "Pierre Ohlmann", "authors": "Thomas Colcombet, Nathana\\\"el Fijalkow, Pierre Ohlmann", "title": "Controlling a random population", "comments": "20 pages, 6 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DC cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bertrand et al. introduced a model of parameterised systems, where each agent\nis represented by a finite state system, and studied the following control\nproblem: for any number of agents, does there exist a controller able to bring\nall agents to a target state? They showed that the problem is decidable and\nEXPTIME-complete in the adversarial setting, and posed as an open problem the\nstochastic setting, where the agent is represented by a Markov decision\nprocess. In this paper, we show that the stochastic control problem is\ndecidable. Our solution makes significant uses of well quasi orders, of the\nmax-flow min-cut theorem, and of the theory of regular cost functions. We\nintroduce an intermediate problem of independent interest called the sequential\nflow problem, and study the complexity of solving it.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 13:32:18 GMT"}, {"version": "v2", "created": "Tue, 29 Dec 2020 14:53:34 GMT"}, {"version": "v3", "created": "Mon, 26 Jul 2021 13:59:55 GMT"}], "update_date": "2021-07-27", "authors_parsed": [["Colcombet", "Thomas", ""], ["Fijalkow", "Nathana\u00ebl", ""], ["Ohlmann", "Pierre", ""]]}, {"id": "1911.01508", "submitter": "Siddharth Krishna", "authors": "Siddharth Krishna, Michael Emmi, Constantin Enea, Dejan Jovanovic", "title": "Verifying Visibility-Based Weak Consistency", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multithreaded programs generally leverage efficient and thread-safe\nconcurrent objects like sets, key-value maps, and queues. While some\nconcurrent-object operations are designed to behave atomically, each witnessing\nthe atomic effects of predecessors in a linearization order, others forego such\nstrong consistency to avoid complex control and synchronization bottlenecks.\nFor example, contains (value) methods of key-value maps may iterate through\nkey-value entries without blocking concurrent updates, to avoid unwanted\nperformance bottlenecks, and consequently overlook the effects of some\nlinearization-order predecessors. While such weakly-consistent operations may\nnot be atomic, they still offer guarantees, e.g., only observing values that\nhave been present.\n  In this work we develop a methodology for proving that concurrent object\nimplementations adhere to weak-consistency specifications. In particular, we\nconsider (forward) simulation-based proofs of implementations against\nrelaxed-visibility specifications, which allow designated operations to\noverlook some of their linearization-order predecessors, i.e., behaving as if\nthey never occurred. Besides annotating implementation code to identify\nlinearization points, i.e., points at which operations' logical effects occur,\nwe also annotate code to identify visible operations, i.e., operations whose\neffects are observed; in practice this annotation can be done automatically by\ntracking the writers to each accessed memory location. We formalize our\nmethodology over a general notion of transition systems, agnostic to any\nparticular programming language or memory model, and demonstrate its\napplication, using automated theorem provers, by verifying models of Java\nconcurrent object implementations.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 22:13:43 GMT"}], "update_date": "2019-11-06", "authors_parsed": [["Krishna", "Siddharth", ""], ["Emmi", "Michael", ""], ["Enea", "Constantin", ""], ["Jovanovic", "Dejan", ""]]}, {"id": "1911.01523", "submitter": "Shromona Ghosh", "authors": "Shromona Ghosh, Yash Vardhan Pant, Hadi Ravanbakhsh, and Sanjit A.\n  Seshia", "title": "Counterexample-Guided Synthesis of Perception Models and Control", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.LG cs.LO cs.RO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent advances in learning-based perception systems have led to drastic\nimprovements in the performance of robotic systems like autonomous vehicles and\nsurgical robots. These perception systems, however, are hard to analyze and\nerrors in them can propagate to cause catastrophic failures. In this paper, we\nconsider the problem of synthesizing safe and robust controllers for robotic\nsystems which rely on complex perception modules for feedback. We propose a\ncounterexample-guided synthesis framework that iteratively builds simple\nsurrogate models of the complex perception module and enables us to find safe\ncontrol policies. The framework uses a falsifier to find counterexamples, or\ntraces of the systems that violate a safety property, to extract information\nthat enables efficient modeling of the perception modules and errors in it.\nThese models are then used to synthesize controllers that are robust to errors\nin perception. If the resulting policy is not safe, we gather new\ncounterexamples. By repeating the process, we eventually find a controller\nwhich can keep the system safe even when there is a perception failure. We\ndemonstrate our framework on two scenarios in simulation, namely lane keeping\nand automatic braking, and show that it generates controllers that are safe, as\nwell as a simpler model of a deep neural network-based perception system that\ncan provide meaningful insight into operations of the perception system.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 23:03:32 GMT"}, {"version": "v2", "created": "Fri, 8 Nov 2019 16:05:27 GMT"}, {"version": "v3", "created": "Fri, 14 May 2021 02:25:24 GMT"}], "update_date": "2021-05-17", "authors_parsed": [["Ghosh", "Shromona", ""], ["Pant", "Yash Vardhan", ""], ["Ravanbakhsh", "Hadi", ""], ["Seshia", "Sanjit A.", ""]]}, {"id": "1911.01899", "submitter": "Thomas Ehrhard", "authors": "Thomas Ehrhard (IRIF)", "title": "Non-idempotent intersection types in logical form", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Intersection types are an essential tool in the analysis of operational and\ndenotational properties of lambda-terms and functional programs. Among them,\nnon-idempotent intersection types provide precise quantitative information\nabout the evaluation of terms and programs. However, unlike simple or\nsecond-order types, intersection types cannot be considered as a logical system\nbecause the application rule (or the intersection rule, depending on the\npresentation of the system) involves a condition expressing that the proofs of\npremises satisfy a very strong uniformity condition: the underlying\nlambda-terms must be the same. Using earlier work introducing an indexed\nversion of Linear Logic, we show that non-idempotent typing can be given a\nlogical form in a system where formulas represent hereditarily indexed families\nof intersection types.\n", "versions": [{"version": "v1", "created": "Tue, 5 Nov 2019 16:02:12 GMT"}], "update_date": "2019-11-06", "authors_parsed": [["Ehrhard", "Thomas", "", "IRIF"]]}, {"id": "1911.02065", "submitter": "Ibrahim Abdelaziz", "authors": "Maxwell Crouse, Ibrahim Abdelaziz, Bassem Makni, Spencer Whitehead,\n  Cristina Cornelio, Pavan Kapanipathi, Kavitha Srinivas, Veronika Thost,\n  Michael Witbrock, Achille Fokoue", "title": "A Deep Reinforcement Learning Approach to First-Order Logic Theorem\n  Proving", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automated theorem provers have traditionally relied on manually tuned\nheuristics to guide how they perform proof search. Deep reinforcement learning\nhas been proposed as a way to obviate the need for such heuristics, however,\nits deployment in automated theorem proving remains a challenge. In this paper\nwe introduce TRAIL, a system that applies deep reinforcement learning to\nsaturation-based theorem proving. TRAIL leverages (a) a novel neural\nrepresentation of the state of a theorem prover and (b) a novel\ncharacterization of the inference selection process in terms of an\nattention-based action policy. We show through systematic analysis that these\nmechanisms allow TRAIL to significantly outperform previous\nreinforcement-learning-based theorem provers on two benchmark datasets for\nfirst-order logic automated theorem proving (proving around 15% more theorems).\n", "versions": [{"version": "v1", "created": "Tue, 5 Nov 2019 20:03:58 GMT"}, {"version": "v2", "created": "Thu, 13 Feb 2020 18:14:22 GMT"}, {"version": "v3", "created": "Wed, 16 Sep 2020 01:22:17 GMT"}], "update_date": "2020-09-17", "authors_parsed": [["Crouse", "Maxwell", ""], ["Abdelaziz", "Ibrahim", ""], ["Makni", "Bassem", ""], ["Whitehead", "Spencer", ""], ["Cornelio", "Cristina", ""], ["Kapanipathi", "Pavan", ""], ["Srinivas", "Kavitha", ""], ["Thost", "Veronika", ""], ["Witbrock", "Michael", ""], ["Fokoue", "Achille", ""]]}, {"id": "1911.02289", "submitter": "Tim Lyon", "authors": "Agata Ciabattoni, Tim S. Lyon, Revantha Ramanayake and Alwen Tiu", "title": "Display to Labeled Proofs and Back Again for Tense Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce translations between display calculus proofs and labeled\ncalculus proofs in the context of tense logics. First, we show that every\nderivation in the display calculus for the minimal tense logic Kt extended with\ngeneral path axioms can be effectively transformed into a derivation in the\ncorresponding labeled calculus. Concerning the converse translation, we show\nthat for Kt extended with path axioms, every derivation in the corresponding\nlabeled calculus can be put into a special form that is translatable to a\nderivation in the associated display calculus. A key insight in this converse\ntranslation is a canonical representation of display sequents as labeled\npolytrees. Labeled polytrees, which represent equivalence classes of display\nsequents modulo display postulates, also shed light on related correspondence\nresults for tense logics.\n", "versions": [{"version": "v1", "created": "Wed, 6 Nov 2019 10:24:41 GMT"}, {"version": "v2", "created": "Tue, 23 Jun 2020 13:21:55 GMT"}, {"version": "v3", "created": "Thu, 6 May 2021 16:37:53 GMT"}], "update_date": "2021-05-07", "authors_parsed": [["Ciabattoni", "Agata", ""], ["Lyon", "Tim S.", ""], ["Ramanayake", "Revantha", ""], ["Tiu", "Alwen", ""]]}, {"id": "1911.02512", "submitter": "Mohammad Rahman", "authors": "M. Ashiqur Rahman, Rahat Masum, Matthew Anderson, and Steven L. Drager", "title": "Trajectory Synthesis for a UAV Swarm to Perform Resilient\n  Requirement-Aware Surveillance: A Smart Grid-based Study", "comments": "The paper is to be submitted to a conference. Rahman and Masum are\n  the co-first author of this paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SP cs.LO cs.SY eess.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A smart grid is a widely distributed engineering system with overhead\ntransmission lines. Physical damage to these power lines, from natural\ncalamities or technical failures, will disrupt the functional integrity of the\ngrid. To ensure the continuation of the grid's operational flow when those\nphenomena happen, the grid operator must immediately take steps to nullify the\nimpacts and repair the problems, even if those occur in hardly-reachable remote\nareas. Emerging unmanned aerial vehicles (UAVs) show great potential to replace\ntraditional human patrols for regularly monitoring critical situations\ninvolving the safety of the grid. The critical lines can be monitored by a\nfleet of UAVs to ensure a resilient surveillance system. The proposed approach\nconsiders the \\textit{n}-1 contingency analysis to find the criticality of a\ntransmission line. We propose a formal framework that verifies whether a given\nset of UAVs (i.e., a UAV swarm) can perform continuous surveillance of the grid\nsatisfying various requirements, particularly the monitoring and resiliency\nspecifications. The verification process ultimately provides a trajectory plan\nfor the UAVs, including the refueling schedules. The resiliency requirement of\ninspecting a point on a line is expressed in terms of a $k-$property specifying\nthat if $k$ UAVs fail or compromised still there is a UAV to collect the data\nat the point within on time. We evaluate the proposed framework on synthetic\ndata based on various IEEE test bus systems.\n", "versions": [{"version": "v1", "created": "Sun, 3 Nov 2019 21:19:29 GMT"}], "update_date": "2019-11-07", "authors_parsed": [["Rahman", "M. Ashiqur", ""], ["Masum", "Rahat", ""], ["Anderson", "Matthew", ""], ["Drager", "Steven L.", ""]]}, {"id": "1911.03122", "submitter": "Swen Jacobs", "authors": "Swen Jacobs, Mouhammad Sakr, Martin Zimmermann", "title": "Promptness and Bounded Fairness in Concurrent and Parameterized Systems", "comments": "Accepted for publication in VMCAI 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the satisfaction of specifications in Prompt Linear Temporal\nLogic (Prompt-LTL) by concurrent systems. Prompt-LTL is an extension of LTL\nthat allows to specify parametric bounds on the satisfaction of eventualities,\nthus adding a quantitative aspect to the specification language. We establish a\nconnection between bounded fairness, bounded stutter equivalence, and the\nsatisfaction of Prompt-LTL\\X formulas. Based on this connection, we prove the\nfirst cutoff results for different classes of systems with a parametric number\nof components and quantitative specifications, thereby identifying previously\nunknown decidable fragments of the parameterized model checking problem.\n", "versions": [{"version": "v1", "created": "Fri, 8 Nov 2019 08:38:57 GMT"}, {"version": "v2", "created": "Fri, 15 Nov 2019 13:38:57 GMT"}], "update_date": "2019-11-18", "authors_parsed": [["Jacobs", "Swen", ""], ["Sakr", "Mouhammad", ""], ["Zimmermann", "Martin", ""]]}, {"id": "1911.03679", "submitter": "Kevin Kappelmann", "authors": "Kevin Kappelmann", "title": "Decision Procedures for Guarded Logics", "comments": "A thesis submitted in partial fulfilment for the degree of MSc in\n  Mathematics and Foundations of Computer Science at the University of Oxford.\n  Update 25.03.2021: added missing constraint in definition of simple\n  saturation algorithm", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An important class of decidable first-order logic fragments are those\nsatisfying a guardedness condition, such as the guarded fragment (GF). Usually,\ndecidability for these logics is closely linked to the tree-like model property\n- the fact that satisfying models can be taken to have tree-like form. Decision\nprocedures for the guarded fragment based on the tree-like model property are\ndifficult to implement. An alternative approach, based on restricting\nfirst-order resolution, has been proposed, and this shows more promise from the\npoint of view of implementation. In this work, we connect the tree-like model\nproperty of the guarded fragment with the resolution-based approach. We derive\nefficient resolution-based rewriting algorithms that solve the Quantifier-Free\nQuery Answering Problem under Guarded Tuple Generating Dependencies (GTGDs) and\nDisjunctive Guarded Tuple Generating Dependencies (DisGTGDs). The Query\nAnswering Problem for these classes subsumes many cases of GF satisfiability.\nOur algorithms, in addition to making the connection to the tree-like model\nproperty clear, give a natural account of the selection and ordering strategies\nused by resolution procedures for the guarded fragment. We also believe that\nour rewriting algorithm for the special case of GTGDs may prove itself valuable\nin practice as it does not require any Skolemisation step and its theoretical\nruntime outperforms those of known GF resolution procedures in case of fixed\ndependencies. Moreover, we show a novel normalisation procedure for the widely\nused chase procedure in case of (disjunctive) GTGDs, which could be useful for\nfuture studies.\n", "versions": [{"version": "v1", "created": "Sat, 9 Nov 2019 12:44:21 GMT"}, {"version": "v2", "created": "Thu, 25 Mar 2021 13:50:53 GMT"}], "update_date": "2021-03-26", "authors_parsed": [["Kappelmann", "Kevin", ""]]}, {"id": "1911.03807", "submitter": "Suguman Bansal", "authors": "Suguman Bansal, Kedar S. Namjoshi, Yaniv Sa'ar", "title": "Synthesis of coordination programs from linear temporal logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper presents a method for synthesizing a reactive program which\ncoordinates the actions of a group of other reactive programs, so that the\ncombined system satisfies a temporal specification of its desired long-term\nbehavior. Traditionally, reactive synthesis has been applied to the\nconstruction of a stateful hardware circuit. This work is motivated by\napplications to other domains, such as the IoT (the Internet of Things) and\nrobotics, where it is necessary to coordinate the actions of multiple sensors,\ndevices, and robots. The mathematical model represents such entities as\nindividual processes in Hoare's CSP model. Given a network of interacting\nentities, called an \\emph{environment}, and a temporal specification of\nlong-term behavior, the synthesis method constructs a \\emph{coordinator}\nprocess (if one exists) that guides the actions of the environment entities so\nthat the combined system is deadlock-free and satisfies the given\nspecification. The main technical challenge is that a coordinator may have only\n\\emph{partial knowledge} of the environment state, due to non-determinism\nwithin the environment, and environment actions that are hidden from the\ncoordinator. This is the first method to handle both sources of partial\nknowledge, and to do so for arbitrary linear temporal logic specifications. It\nis shown that the coordination synthesis problem is \\PSPACE-hard in the size of\nthe environment. A prototype implementation is able to synthesize compact\nsolutions for a number of coordination problems.\n", "versions": [{"version": "v1", "created": "Sun, 10 Nov 2019 00:07:54 GMT"}], "update_date": "2019-11-12", "authors_parsed": [["Bansal", "Suguman", ""], ["Namjoshi", "Kedar S.", ""], ["Sa'ar", "Yaniv", ""]]}, {"id": "1911.03962", "submitter": "Sergey A. Slavnov", "authors": "Sergey Slavnov", "title": "Classical linear logic, cobordisms and categorial grammars", "comments": "This is an improved version of the previously posted paper \"Classical\n  linear logic, cobordisms and categorical semantics of categorial grammars\"\n  with reduced amonunt of category theory, much simplified definitions and a\n  number of examples. Also, a treatment of tree languages is added", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.CL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a categorial grammar based on classical multiplicative linear\nlogic.\n  This can be seen as an extension of abstract categorial grammars (ACG) and is\nat least as expressive. However, constituents of {\\it linear logic grammars\n(LLG)} are not abstract ${\\lambda}$-terms, but simply tuples of words with\nlabeled endpoints and supplied with specific {\\it plugging instructions}: the\nsets of endpoints are subdivided into the {\\it incoming} and the {\\it outgoing}\nparts. We call such objects {\\it word cobordisms}.\n  A key observation is that word cobordisms can be organized in a category,\nvery similar to the familiar category of topological cobordisms. This category\nis symmetric monoidal closed and compact closed and thus is a model of linear\n$\\lambda$-calculus and classical, as well as intuitionistic linear logic. This\nallows us using linear logic as a typing system for word cobordisms.\n  At least, this gives a concrete and intuitive representation of ACG.\n  We think, however, that the category of word cobordisms, which has a rich\nstructure and is independent of any grammar, might be interesting on its own\nright.\n", "versions": [{"version": "v1", "created": "Sun, 10 Nov 2019 16:56:25 GMT"}, {"version": "v2", "created": "Tue, 19 May 2020 14:44:28 GMT"}, {"version": "v3", "created": "Fri, 31 Jul 2020 18:28:14 GMT"}], "update_date": "2020-08-04", "authors_parsed": [["Slavnov", "Sergey", ""]]}, {"id": "1911.04026", "submitter": "Daniel Leivant", "authors": "Daniel Leivant", "title": "A generic imperative language for polynomial time", "comments": "18 pages, submitted to a conference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC cs.PL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The ramification method in Implicit Computational Complexity has been\nassociated with functional programming, but adapting it to generic imperative\nprogramming is highly desirable, given the wider algorithmic applicability of\nimperative programming. We introduce a new approach to ramification which,\namong other benefits, adapts readily to fully general imperative programming.\nThe novelty is in ramifying finite second-order objects, namely finite\nstructures, rather than ramifying elements of free algebras. In so doing we\nbridge between Implicit Complexity's type theoretic characterizations of\nfeasibility, and the data-flow approach of Static Analysis.\n", "versions": [{"version": "v1", "created": "Mon, 11 Nov 2019 01:15:07 GMT"}, {"version": "v2", "created": "Wed, 19 Feb 2020 02:10:18 GMT"}], "update_date": "2020-02-20", "authors_parsed": [["Leivant", "Daniel", ""]]}, {"id": "1911.04032", "submitter": "Curtis Bright", "authors": "Curtis Bright, Kevin Cheung, Brett Stevens, Dominique Roy, Ilias\n  Kotsireas, and Vijay Ganesh", "title": "A Nonexistence Certificate for Projective Planes of Order Ten with\n  Weight 15 Codewords", "comments": "To appear in Applicable Algebra in Engineering, Communication and\n  Computing", "journal-ref": null, "doi": "10.1007/s00200-020-00426-y", "report-no": null, "categories": "cs.DM cs.LO cs.SC math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Using techniques from the fields of symbolic computation and satisfiability\nchecking we verify one of the cases used in the landmark result that projective\nplanes of order ten do not exist. In particular, we show that there exist no\nprojective planes of order ten that generate codewords of weight fifteen, a\nresult first shown in 1973 via an exhaustive computer search. We provide a\nsimple satisfiability (SAT) instance and a certificate of unsatisfiability that\ncan be used to automatically verify this result for the first time. All\nprevious demonstrations of this result have relied on search programs that are\ndifficult or impossible to verify---in fact, our search found partial\nprojective planes that were missed by previous searches due to previously\nundiscovered bugs. Furthermore, we show how the performance of the SAT solver\ncan be dramatically increased by employing functionality from a computer\nalgebra system (CAS). Our SAT+CAS search runs significantly faster than all\nother published searches verifying this result.\n", "versions": [{"version": "v1", "created": "Mon, 11 Nov 2019 01:48:58 GMT"}, {"version": "v2", "created": "Wed, 25 Mar 2020 22:54:52 GMT"}], "update_date": "2020-04-17", "authors_parsed": [["Bright", "Curtis", ""], ["Cheung", "Kevin", ""], ["Stevens", "Brett", ""], ["Roy", "Dominique", ""], ["Kotsireas", "Ilias", ""], ["Ganesh", "Vijay", ""]]}, {"id": "1911.04112", "submitter": "Jie-Hong Jiang", "authors": "Nian-Ze Lee and Jie-Hong R. Jiang", "title": "Dependency Stochastic Boolean Satisfiability: A Logical Formalism for\n  NEXPTIME Decision Problems with Uncertainty", "comments": "10 pages, 5 figures. A condensed version of this work is published in\n  the AAAI Conference on Artificial Intelligence (AAAI) 2021", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Stochastic Boolean Satisfiability (SSAT) is a logical formalism to model\ndecision problems with uncertainty, such as Partially Observable Markov\nDecision Process (POMDP) for verification of probabilistic systems. SSAT,\nhowever, is limited by its descriptive power within the PSPACE complexity\nclass. More complex problems, such as the NEXPTIME-complete Decentralized POMDP\n(Dec-POMDP), cannot be succinctly encoded with SSAT. To provide a logical\nformalism of such problems, we extend the Dependency Quantified Boolean Formula\n(DQBF), a representative problem in the NEXPTIME-complete class, to its\nstochastic variant, named Dependency SSAT (DSSAT), and show that DSSAT is also\nNEXPTIME-complete. We demonstrate the potential applications of DSSAT to\ncircuit synthesis of probabilistic and approximate design. Furthermore, to\nstudy the descriptive power of DSSAT, we establish a polynomial-time reduction\nfrom Dec-POMDP to DSSAT. With the theoretical foundations paved in this work,\nwe hope to encourage the development of DSSAT solvers for potential broad\napplications.\n", "versions": [{"version": "v1", "created": "Mon, 11 Nov 2019 06:58:25 GMT"}, {"version": "v2", "created": "Fri, 17 Jul 2020 03:16:23 GMT"}, {"version": "v3", "created": "Thu, 25 Feb 2021 08:46:47 GMT"}], "update_date": "2021-02-26", "authors_parsed": [["Lee", "Nian-Ze", ""], ["Jiang", "Jie-Hong R.", ""]]}, {"id": "1911.04195", "submitter": "Hans-Dieter A. Hiep", "authors": "Hans-Dieter A. Hiep, Olaf Maathuis, Jinting Bian, Frank S. de Boer,\n  Marko van Eekelen, Stijn de Gouw", "title": "Verifying OpenJDK's LinkedList using KeY", "comments": "16 pages, 9 pages appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As a particular case study of the formal verification of state-of-the-art,\nreal software, we discuss the specification and verification of a corrected\nversion of the implementation of a linked list as provided by the Java\nCollection framework. Keywords: Java, standard library, deductive verification,\nKeY, Java Modeling Language, case study, bug\n", "versions": [{"version": "v1", "created": "Mon, 11 Nov 2019 11:39:54 GMT"}], "update_date": "2019-11-12", "authors_parsed": [["Hiep", "Hans-Dieter A.", ""], ["Maathuis", "Olaf", ""], ["Bian", "Jinting", ""], ["de Boer", "Frank S.", ""], ["van Eekelen", "Marko", ""], ["de Gouw", "Stijn", ""]]}, {"id": "1911.04326", "submitter": "Francesco Calimeri", "authors": "Francesco Calimeri, Wolfgang Faber, Martin Gebser, Giovambattista\n  Ianni, Roland Kaminski, Thomas Krennwallner, Nicola Leone, Marco Maratea,\n  Francesco Ricca, Torsten Schaub", "title": "ASP-Core-2 Input Language Format", "comments": null, "journal-ref": "Theory and Practice of Logic Programming 20 (2020) 294-309", "doi": "10.1017/S1471068419000450", "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Standardization of solver input languages has been a main driver for the\ngrowth of several areas within knowledge representation and reasoning,\nfostering the exploitation in actual applications. In this document we present\nthe ASP-Core-2 standard input language for Answer Set Programming, which has\nbeen adopted in ASP Competition events since 2013.\n", "versions": [{"version": "v1", "created": "Mon, 11 Nov 2019 15:14:00 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Calimeri", "Francesco", ""], ["Faber", "Wolfgang", ""], ["Gebser", "Martin", ""], ["Ianni", "Giovambattista", ""], ["Kaminski", "Roland", ""], ["Krennwallner", "Thomas", ""], ["Leone", "Nicola", ""], ["Maratea", "Marco", ""], ["Ricca", "Francesco", ""], ["Schaub", "Torsten", ""]]}, {"id": "1911.04344", "submitter": "Bill Stoddart", "authors": "Bill Stoddart, Frank Zeyda, Steve Dunne", "title": "Bunch theory: working notes on applications, axioms and models", "comments": "67 pages, 1 figure. key words: set theory, bunch theory, denotational\n  model, program semantics, non-deterministic choice, preferential choice,\n  probabilistic choice. Revised paper, Jan 2020, reformulation of axiom of\n  choice, revised comments on refinement, corrected precedence table, note on\n  parsing quantified formulae", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In his book \"A practical theory of programming\" Eric Hehner proposes and\napplies a remarkably radical reformulation of set theory, in which the\ncollection and packaging of elements are seen as separate activities. This\nprovides for unpackaged collections, referred to as \"bunches\". Bunches allow us\nto reason about non-determinism at the level of terms, and, very remarkably,\nallow us to reason about the conceptual entity \"nothing\", which is just an\nempty bunch (and very different from an empty set). This eliminates\nmathematical \"gaps\" caused by undefined terms. We compare the use of bunches\nwith other approaches to this problem, and we illustrate the use of bunch\ntheory in formulating program semantics which combines non-deterministic,\npreferential, and probabilistic choice. We show how an existing axiomatisation\nof set theory can be extended to incorporate bunches, and we provide and\nvalidate a model. Standard functions are lifted when applied to a bunch of\nvalues, but we also define a wholistic function application which allows whole\nbunches to be accepted as arguments, and we develop its associated fixed point\ntheory.\n", "versions": [{"version": "v1", "created": "Mon, 11 Nov 2019 15:35:02 GMT"}, {"version": "v2", "created": "Fri, 24 Jan 2020 18:09:00 GMT"}], "update_date": "2020-01-27", "authors_parsed": [["Stoddart", "Bill", ""], ["Zeyda", "Frank", ""], ["Dunne", "Steve", ""]]}, {"id": "1911.04588", "submitter": "G. A. Kavvos", "authors": "G. A. Kavvos and Edward Morehouse and Daniel R. Licata and Norman\n  Danner", "title": "Recurrence Extraction for Functional Programs through Call-by-Push-Value\n  (Extended Version)", "comments": "POPL 2020", "journal-ref": "Proc. ACM Program. Lang. 4, POPL, Article 15 (January 2020)", "doi": "10.1145/3371083", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The main way of analyzing the complexity of a program is that of extracting\nand solving a recurrence that expresses its running time in terms of the size\nof its input. We develop a method that automatically extracts such recurrences\nfrom the syntax of higher-order recursive functional programs. The resulting\nrecurrences, which are programs in a call-by-name language with recursion,\nexplicitly compute the running time in terms of the size of the input. In order\nto achieve this in a uniform way that covers both call-by-name and\ncall-by-value evaluation strategies, we use Call-by-Push-Value (CBPV) as an\nintermediate language. Finally, we use domain theory to develop a denotational\ncost semantics for the resulting recurrences.\n", "versions": [{"version": "v1", "created": "Mon, 11 Nov 2019 22:36:07 GMT"}], "update_date": "2019-11-13", "authors_parsed": [["Kavvos", "G. A.", ""], ["Morehouse", "Edward", ""], ["Licata", "Daniel R.", ""], ["Danner", "Norman", ""]]}, {"id": "1911.04732", "submitter": "Bas Spitters", "authors": "Jakob Botsch Nielsen, Bas Spitters", "title": "Smart Contract Interactions in Coq", "comments": null, "journal-ref": "1st Workshop on Formal Methods for Blockchains, 3rd Formal Methods\n  World Congress on October 11, 2019 in Porto, Portugal", "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a model/executable specification of smart contract execution in\nCoq. Our formalization allows for inter-contract communication and generalizes\nexisting work by allowing modelling of both depth-first execution blockchains\n(like Ethereum) and breadth-first execution blockchains (like Tezos). We\nrepresent smart contracts programs in Coq's functional language Gallina,\nenabling easier reasoning about functional correctness of concrete contracts\nthan other approaches. In particular we develop a Congress contract in this\nstyle. This contract -- a simplified version of the infamous DAO -- is\ninteresting because of its very dynamic communication pattern with other\ncontracts. We give a high-level partial specification of the Congress's\nbehavior, related to reentrancy, and prove that the Congress satisfies it for\nall possible smart contract execution orders.\n", "versions": [{"version": "v1", "created": "Tue, 12 Nov 2019 08:23:19 GMT"}], "update_date": "2020-02-10", "authors_parsed": [["Nielsen", "Jakob Botsch", ""], ["Spitters", "Bas", ""]]}, {"id": "1911.04863", "submitter": "Daniela Briola", "authors": "Daniela Briola, Viviana Mascardi, Massimiliano Gioseffi", "title": "OntoScene, A Logic-based Scene Interpreter: Implementation and\n  Application in the Rock Art Domain", "comments": "Under consideration in Theory and Practice of Logic Programming\n  (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.CV cs.LO cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present OntoScene, a framework aimed at understanding the semantics of\nvisual scenes starting from the semantics of their elements and the spatial\nrelations holding between them. OntoScene exploits ontologies for representing\nknowledge and Prolog for specifying the interpretation rules that domain\nexperts may adopt, and for implementing the SceneInterpreter engine. Ontologies\nallow the designer to formalize the domain in a reusable way, and make the\nsystem modular and interoperable with existing multiagent systems, while Prolog\nprovides a solid basis to define complex rules of interpretation in a way that\ncan be affordable even for people with no background in Computational Logics.\nThe domain selected for experimenting OntoScene is that of prehistoric rock\nart, which provides us with a fascinating and challenging testbed. Under\nconsideration in Theory and Practice of Logic Programming (TPLP)\n", "versions": [{"version": "v1", "created": "Tue, 5 Nov 2019 13:22:05 GMT"}], "update_date": "2019-11-13", "authors_parsed": [["Briola", "Daniela", ""], ["Mascardi", "Viviana", ""], ["Gioseffi", "Massimiliano", ""]]}, {"id": "1911.05430", "submitter": "Emanuele D'Osualdo", "authors": "Emanuele D'Osualdo and Felix Stutz", "title": "Decidable Inductive Invariants for Verification of Cryptographic\n  Protocols with Unbounded Sessions", "comments": "16 pages + 23 pages appendix, 5 figures To appear in CONCUR 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CR cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a theory of decidable inductive invariants for an infinite-state\nvariant of the Applied pi-calculus, with applications to automatic verification\nof stateful cryptographic protocols with unbounded sessions/nonces. Since the\nproblem is undecidable in general, we introduce depth-bounded protocols, a\nstrict generalisation of a class from the literature, for which our decidable\nanalysis is sound and complete. Our core contribution is a procedure to check\nthat an invariant is inductive, which implies that every reachable\nconfiguration satisfies it. Our invariants can capture security properties like\nsecrecy, can be inferred automatically, and represent an independently\ncheckable certificate of correctness.\n  We provide a prototype implementation and we report on its performance on\nsome textbook examples.\n", "versions": [{"version": "v1", "created": "Wed, 13 Nov 2019 12:45:28 GMT"}, {"version": "v2", "created": "Sun, 19 Jul 2020 09:15:53 GMT"}], "update_date": "2020-07-21", "authors_parsed": [["D'Osualdo", "Emanuele", ""], ["Stutz", "Felix", ""]]}, {"id": "1911.05834", "submitter": "Ronny Tredup", "authors": "Ronny Tredup", "title": "The Complexity of Synthesizing nop-Equipped Boolean Nets from g-Bounded\n  Inputs (Technical Report)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Boolean Petri nets equipped with nop allow places and transitions to be\nindependent by being related by nop. We characterize for any fixed natural\nnumber g the computational complexity of synthesizing nop-equipped Boolean\nPetri nets from labeled directed graphs whose states have at most g incoming\nand at most g outgoing arcs.\n", "versions": [{"version": "v1", "created": "Fri, 1 Nov 2019 05:16:02 GMT"}], "update_date": "2019-11-15", "authors_parsed": [["Tredup", "Ronny", ""]]}, {"id": "1911.05844", "submitter": "Bruno Bentzen", "authors": "Bruno Bentzen", "title": "Naive cubical type theory", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes a way of doing type theory informally, assuming a cubical\nstyle of reasoning. It can thus be viewed as a first step toward a cubical\nalternative to the program of informalization of type theory carried out in the\nhomotopy type theory book for dependent type theory augmented with axioms for\nunivalence and higher inductive types. We adopt a cartesian cubical type theory\nproposed by Angiuli, Brunerie, Coquand, Favonia, Harper, and Licata as the\nimplicit foundation, confining our presentation to elementary results such as\nfunction extensionality, the derivation of weak connections and path induction,\nthe groupoid structure of types, and the Eckmman-Hilton duality.\n", "versions": [{"version": "v1", "created": "Wed, 13 Nov 2019 22:31:35 GMT"}, {"version": "v2", "created": "Sun, 9 May 2021 21:58:26 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Bentzen", "Bruno", ""]]}, {"id": "1911.05907", "submitter": "Marlo Souza", "authors": "Marlo Souza, \\'Alvaro Moreira, Renata Vieira, John-Jules Ch. Meyer", "title": "A Dynamic Preference Logic for reasoning about Agent Programming", "comments": "piblished on BRACIS 2017", "journal-ref": null, "doi": "10.1109/BRACIS.2017.43", "report-no": null, "categories": "cs.MA cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  In this work, we investigate the use of Dynamic Preference Logic to encode\nBDI mental attitudes. Further, exploring this codification and the\nrepresentation of preferences over possible worlds by preferences over\npropositional formulas, here called priority graphs, we comment on how to\ninterpret BDI agent programs in this logic. Also, using the connection between\ndynamic operations defined over preference models and their encoding as\ntransformations on priority graphs, we show how our logic can be used not only\nto reason about agent programs, but as a tool to specify reasoning mechanisms\nto guarantee certain properties in the theory of rationality for the\nprogramming language.\n", "versions": [{"version": "v1", "created": "Thu, 14 Nov 2019 02:45:50 GMT"}], "update_date": "2019-11-15", "authors_parsed": [["Souza", "Marlo", ""], ["Moreira", "\u00c1lvaro", ""], ["Vieira", "Renata", ""], ["Meyer", "John-Jules Ch.", ""]]}, {"id": "1911.05908", "submitter": "Marlo Souza", "authors": "Marlo Souza, \\'Alvaro Moreira, Renata Vieira", "title": "Tractable reasoning about Agent Programming in Dynamic Preference Logic", "comments": "Published in BRACIS 2018", "journal-ref": null, "doi": "10.1109/BRACIS.2018.00070", "report-no": null, "categories": "cs.MA cs.LO", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  While several BDI logics have been proposed in the area of Agent Programming,\nit is not clear how these logics are connected to the agent programs they are\nsupposed to specify. More yet, the reasoning problems in these logics, being\nbased on modal logic, are not tractable in general, limiting their usage to\ntackle real-world problems. In this work, we use of Dynamic Preference Logic to\nprovide a semantic foundation to BDI agent programming languages and\ninvestigate tractable expressive fragments of this logic to reason about agent\nprograms. With that, we aim to provide a way of implementing semantically\ngrounded agent programming languages with tractable reasoning cycles.\n", "versions": [{"version": "v1", "created": "Thu, 14 Nov 2019 02:50:23 GMT"}], "update_date": "2019-11-15", "authors_parsed": [["Souza", "Marlo", ""], ["Moreira", "\u00c1lvaro", ""], ["Vieira", "Renata", ""]]}, {"id": "1911.06346", "submitter": "Stefan Milius", "authors": "Stefan Milius and Ji\\v{r}\\'i Ad\\'amek and Henning Urbat", "title": "On the Behaviour of Coalgebras with Side Effects and Algebras with\n  Effectful Iteration", "comments": "journal version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For every finitary monad $T$ on sets and every endofunctor $F$ on the\ncategory of $T$-algebras we introduce the concept of an ffg-Elgot algebra for\n$F$, that is, an algebra admitting coherent solutions for finite systems of\nrecursive equations with effects represented by the monad $T$. The goal is to\nstudy the existence and construction of free ffg-Elgot algebras. To this end,\nwe investigate the locally ffg fixed point $\\varphi F$, i.e. the colimit of all\n$F$-coalgebras with free finitely generated carrier, which is shown to be the\ninitial ffg-Elgot algebra. This is the technical foundation for our main\nresult: the category of ffg-Elgot algebras is monadic over the category of\n$T$-algebras.\n", "versions": [{"version": "v1", "created": "Thu, 14 Nov 2019 19:06:18 GMT"}], "update_date": "2019-11-18", "authors_parsed": [["Milius", "Stefan", ""], ["Ad\u00e1mek", "Ji\u0159\u00ed", ""], ["Urbat", "Henning", ""]]}, {"id": "1911.06367", "submitter": "Juan Afanador", "authors": "Juan Afanador", "title": "Arguing Ecosystem Values with Paraconsistent Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The valuation of ecosystem services prompts dialogical settings where\nnon-trivially inconsistent arguments are often invoked. Here, I propose an\napproach to the valuation of ecosystem services circumscribed to a logic-based\nargumentation framework that caters for valid inconsistencies. This framework\naccounts for preference formation processes underpinned by a paraconsistent\nmodel of logical entailment. The value of an ecosystem service is produced in\nthe form of an ordering over competing land-use practices, as per the arguments\nsurviving semantical probing.\n", "versions": [{"version": "v1", "created": "Thu, 14 Nov 2019 20:10:07 GMT"}], "update_date": "2019-11-18", "authors_parsed": [["Afanador", "Juan", ""]]}, {"id": "1911.06578", "submitter": "EPTCS", "authors": "Sarah Winkler (University of Verona), Georg Moser (University of\n  Innsbruck)", "title": "Smarter Features, Simpler Learning?", "comments": "In Proceedings ARCADE 2019, arXiv:1912.11786", "journal-ref": "EPTCS 311, 2019, pp. 25-31", "doi": "10.4204/EPTCS.311.4", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Earlier work on machine learning for automated reasoning mostly relied on\nsimple, syntactic features combined with sophisticated learning techniques.\nUsing ideas adopted in the software verification community, we propose the\ninvestigation of more complex, structural features to learn from. These may be\nexploited to either learn beneficial strategies for tools, or build a portfolio\nsolver that chooses the most suitable tool for a given problem. We present some\nideas for features of term rewrite systems and theorem proving problems.\n", "versions": [{"version": "v1", "created": "Fri, 15 Nov 2019 11:55:20 GMT"}, {"version": "v2", "created": "Tue, 14 Jan 2020 12:48:48 GMT"}], "update_date": "2020-01-15", "authors_parsed": [["Winkler", "Sarah", "", "University of Verona"], ["Moser", "Georg", "", "University of\n  Innsbruck"]]}, {"id": "1911.06643", "submitter": "Andrew Cropper", "authors": "Andrew Cropper", "title": "Forgetting to learn logic programs", "comments": "AAAI20", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most program induction approaches require predefined, often hand-engineered,\nbackground knowledge (BK). To overcome this limitation, we explore methods to\nautomatically acquire BK through multi-task learning. In this approach, a\nlearner adds learned programs to its BK so that they can be reused to help\nlearn other programs. To improve learning performance, we explore the idea of\nforgetting, where a learner can additionally remove programs from its BK. We\nconsider forgetting in an inductive logic programming (ILP) setting. We show\nthat forgetting can significantly reduce both the size of the hypothesis space\nand the sample complexity of an ILP learner. We introduce Forgetgol, a\nmulti-task ILP learner which supports forgetting. We experimentally compare\nForgetgol against approaches that either remember or forget everything. Our\nexperimental results show that Forgetgol outperforms the alternative approaches\nwhen learning from over 10,000 tasks.\n", "versions": [{"version": "v1", "created": "Fri, 15 Nov 2019 14:05:23 GMT"}], "update_date": "2019-11-18", "authors_parsed": [["Cropper", "Andrew", ""]]}, {"id": "1911.06899", "submitter": "S. C. Steenkamp", "authors": "Marcelo Fiore, Andrew M. Pitts, and S. C. Steenkamp", "title": "Constructing Infinitary Quotient-Inductive Types", "comments": "The accompanying Agda code can be found at\n  https://doi.org/10.17863/CAM.48187", "journal-ref": "Lecture Notes in Computer Science, Vol. 12077, pp 257-276, 2020", "doi": "10.1007/978-3-030-45231-5_14", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper introduces an expressive class of quotient-inductive types, called\nQW-types. We show that in dependent type theory with uniqueness of identity\nproofs, even the infinitary case of QW-types can be encoded using the\ncombination of inductive-inductive definitions involving strictly positive\noccurrences of Hofmann-style quotient types, and Abel's size types. The latter,\nwhich provide a convenient constructive abstraction of what classically would\nbe accomplished with transfinite ordinals, are used to prove termination of the\nrecursive definitions of the elimination and computation properties of our\nencoding of QW-types. The development is formalized using the Agda theorem\nprover.\n", "versions": [{"version": "v1", "created": "Fri, 15 Nov 2019 22:43:11 GMT"}, {"version": "v2", "created": "Wed, 19 Feb 2020 18:15:15 GMT"}], "update_date": "2021-01-11", "authors_parsed": [["Fiore", "Marcelo", ""], ["Pitts", "Andrew M.", ""], ["Steenkamp", "S. C.", ""]]}, {"id": "1911.06904", "submitter": "Maxwell Crouse", "authors": "Maxwell Crouse, Ibrahim Abdelaziz, Cristina Cornelio, Veronika Thost,\n  Lingfei Wu, Kenneth Forbus, Achille Fokoue", "title": "Improving Graph Neural Network Representations of Logical Formulae with\n  Subgraph Pooling", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent advances in the integration of deep learning with automated theorem\nproving have centered around the representation of logical formulae as inputs\nto deep learning systems. In particular, there has been a growing interest in\nadapting structure-aware neural methods to work with the underlying graph\nrepresentations of logical expressions. While more effective than character and\ntoken-level approaches, graph-based methods have often made representational\ntrade-offs that limited their ability to capture key structural properties of\ntheir inputs. In this work we propose a novel approach for embedding logical\nformulae that is designed to overcome the representational limitations of prior\napproaches. Our architecture works for logics of different expressivity; e.g.,\nfirst-order and higher-order logic. We evaluate our approach on two standard\ndatasets and show that the proposed architecture achieves state-of-the-art\nperformance on both premise selection and proof step classification.\n", "versions": [{"version": "v1", "created": "Fri, 15 Nov 2019 23:12:30 GMT"}, {"version": "v2", "created": "Tue, 11 Feb 2020 21:08:20 GMT"}, {"version": "v3", "created": "Fri, 5 Jun 2020 17:24:50 GMT"}], "update_date": "2020-06-08", "authors_parsed": [["Crouse", "Maxwell", ""], ["Abdelaziz", "Ibrahim", ""], ["Cornelio", "Cristina", ""], ["Thost", "Veronika", ""], ["Wu", "Lingfei", ""], ["Forbus", "Kenneth", ""], ["Fokoue", "Achille", ""]]}, {"id": "1911.07057", "submitter": "Jacques Fleuriot", "authors": "Phil Scott and Jacques D Fleuriot", "title": "Where are the Natural Numbers in Hilbert's Foundations of Geometry?", "comments": "8 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.HO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hilbert's Foundations of Geometry was perhaps one of the most influential\nworks of geometry in the 20th century and its axiomatics was the first\nsystematic attempt to clear up the logical gaps of the Elements. But does it\nhave gaps of its own? In this paper, we discuss a logical issue, asking how\nHilbert is able to talk about natural numbers within a foundational synthetic\ngeometry. We clarify the matter, showing how to obtain the natural numbers\nusing a very modest subset of his axioms.\n", "versions": [{"version": "v1", "created": "Sat, 16 Nov 2019 16:43:50 GMT"}], "update_date": "2019-11-19", "authors_parsed": [["Scott", "Phil", ""], ["Fleuriot", "Jacques D", ""]]}, {"id": "1911.07290", "submitter": "EPTCS", "authors": "Werner Damm, Martin Fr\\\"anzle, Willem Hagemann, Paul Kr\\\"oger, Astrid\n  Rakow", "title": "Dynamic Conflict Resolution Using Justification Based Reasoning", "comments": "In Proceedings CREST 2019, arXiv:1910.13641. arXiv admin note:\n  substantial text overlap with arXiv:1905.11764", "journal-ref": "EPTCS 308, 2019, pp. 47-65", "doi": "10.4204/EPTCS.308.4", "report-no": null, "categories": "cs.MA cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study conflict situations that dynamically arise in traffic scenarios,\nwhere different agents try to achieve their set of goals and have to decide on\nwhat to do based on their local perception. We distinguish several types of\nconflicts for this setting. In order to enable modelling of conflict situations\nand the reasons for conflicts, we present a logical framework that adopts\nconcepts from epistemic and modal logic, justification and temporal logic.\nUsing this framework, we illustrate how conflicts can be identified and how we\nderive a chain of justifications leading to this conflict. We discuss how\nconflict resolution can be done when a vehicle has local, incomplete\ninformation, vehicle to vehicle communication (V2V) and partially ordered\ngoals.\n", "versions": [{"version": "v1", "created": "Thu, 31 Oct 2019 02:30:45 GMT"}], "update_date": "2019-11-19", "authors_parsed": [["Damm", "Werner", ""], ["Fr\u00e4nzle", "Martin", ""], ["Hagemann", "Willem", ""], ["Kr\u00f6ger", "Paul", ""], ["Rakow", "Astrid", ""]]}, {"id": "1911.07748", "submitter": "Patrice Ossona de Mendez", "authors": "Jaroslav Nesetril, Patrice Ossona de Mendez, Roman Rabinovich,\n  Sebastian Siebertz", "title": "Linear rankwidth meets stability", "comments": "accepted at SODA 2020 conference. arXiv admin note: text overlap with\n  arXiv:1909.01564", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Classes with bounded rankwidth are MSO-transductions of trees and classes\nwith bounded linear rankwidth are MSO-transductions of paths. These results\nshow a strong link between the properties of these graph classes considered\nfrom the point of view of structural graph theory and from the point of view of\nfinite model theory. We take both views on classes with bounded linear\nrankwidth and prove structural and model theoretic properties of these classes:\n1) Graphs with linear rankwidth at most $r$ are linearly \\mbox{$\\chi$-bounded}.\nActually, they have bounded $c$-chromatic number, meaning that they can be\ncolored with $f(r)$ colors, each color inducing a cograph. 2) Based on a\nRamsey-like argument, we prove for every proper hereditary family $\\mathcal F$\nof graphs (like cographs) that there is a class with bounded rankwidth that\ndoes not have the property that graphs in it can be colored by a bounded number\nof colors, each inducing a subgraph in~$\\mathcal F$. 3) For a class $\\mathcal\nC$ with bounded linear rankwidth the following conditions are equivalent: a)\n$\\mathcal C$~is~stable, b)~$\\mathcal C$~excludes some half-graph as a\nsemi-induced subgraph, c) $\\mathcal C$ is a first-order transduction of a class\nwith bounded pathwidth. These results open the perspective to study classes\nadmitting low linear rankwidth covers.\n", "versions": [{"version": "v1", "created": "Fri, 15 Nov 2019 07:27:08 GMT"}], "update_date": "2019-11-19", "authors_parsed": [["Nesetril", "Jaroslav", ""], ["de Mendez", "Patrice Ossona", ""], ["Rabinovich", "Roman", ""], ["Siebertz", "Sebastian", ""]]}, {"id": "1911.07774", "submitter": "Alessandro Gianola", "authors": "Diego Calvanese and Silvio Ghilardi and Alessandro Gianola and Marco\n  Montali and Andrey Rivkin", "title": "Combined Covers and Beth Definability (Extended Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In ESOP 2008, Gulwani and Musuvathi introduced a notion of cover and\nexploited it to handle infinite-state model checking problems. Motivated by\napplications to the verification of data-aware processes, we proved in a\nprevious paper that covers are strictly related to model completions, a\nwell-known topic in model theory. In this paper we investigate cover transfer\nto theory combinations in the disjoint signatures case. We prove that for\nconvex theories, cover algorithms can be transferred to theory combinations\nunder the same hypothesis (equality interpolation property aka strong\namalgamation property) needed to transfer quantifier-free interpolation. In the\nnon-convex case, we show by a counterexample that covers may not exist in the\ncombined theories, even in case combined quantifier-free interpolants do exist.\nHowever, we exhibit a cover transfer algorithm operating also in the non-convex\ncase for special kinds of theory combinations; these combinations (called `tame\ncombinations') concern multi-sorted theories arising in many model-checking\napplications (in particular, the ones oriented to verification of data-aware\nprocesses).\n", "versions": [{"version": "v1", "created": "Mon, 18 Nov 2019 17:18:09 GMT"}, {"version": "v2", "created": "Tue, 31 Mar 2020 00:48:04 GMT"}, {"version": "v3", "created": "Mon, 29 Jun 2020 22:51:21 GMT"}], "update_date": "2020-07-01", "authors_parsed": [["Calvanese", "Diego", ""], ["Ghilardi", "Silvio", ""], ["Gianola", "Alessandro", ""], ["Montali", "Marco", ""], ["Rivkin", "Andrey", ""]]}, {"id": "1911.08145", "submitter": "Suguman Bansal", "authors": "Suguman Bansal, Yong Li, Lucas M. Tabajara, Moshe Y. Vardi", "title": "Hybrid Compositional Reasoning for Reactive Synthesis from\n  Finite-Horizon Specifications", "comments": "Accepted by AAAI 2020. Tool Lisa for (a). LTLf to DFA conversion, and\n  (b). LTLf synthesis can be found here: https://github.com/vardigroup/lisa", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  LTLf synthesis is the automated construction of a reactive system from a\nhigh-level description, expressed in LTLf, of its finite-horizon behavior. So\nfar, the conversion of LTLf formulas to deterministic finite-state automata\n(DFAs) has been identified as the primary bottleneck to the scalabity of\nsynthesis. Recent investigations have also shown that the size of the DFA state\nspace plays a critical role in synthesis as well.\n  Therefore, effective resolution of the bottleneck for synthesis requires the\nconversion to be time and memory performant, and prevent state-space explosion.\nCurrent conversion approaches, however, which are based either on\nexplicit-state representation or symbolic-state representation, fail to address\nthese necessities adequately at scale: Explicit-state approaches generate\nminimal DFA but are slow due to expensive DFA minimization. Symbolic-state\nrepresentations can be succinct, but due to the lack of DFA minimization they\ngenerate such large state spaces that even their symbolic representations\ncannot compensate for the blow-up.\n  This work proposes a hybrid representation approach for the conversion. Our\napproach utilizes both explicit and symbolic representations of the\nstate-space, and effectively leverages their complementary strengths. In doing\nso, we offer an LTLf to DFA conversion technique that addresses all three\nnecessities, hence resolving the bottleneck. A comprehensive empirical\nevaluation on conversion and synthesis benchmarks supports the merits of our\nhybrid approach.\n", "versions": [{"version": "v1", "created": "Tue, 19 Nov 2019 08:05:24 GMT"}, {"version": "v2", "created": "Mon, 9 Dec 2019 04:48:40 GMT"}, {"version": "v3", "created": "Mon, 17 Feb 2020 20:16:37 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Bansal", "Suguman", ""], ["Li", "Yong", ""], ["Tabajara", "Lucas M.", ""], ["Vardi", "Moshe Y.", ""]]}, {"id": "1911.08174", "submitter": "Thorsten Wissmann", "authors": "Andreas Abel and Thierry Coquand", "title": "Failure of Normalization in Impredicative Type Theory with\n  Proof-Irrelevant Propositional Equality", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 2 (June 30,\n  2020) lmcs:6606", "doi": "10.23638/LMCS-16(2:14)2020", "report-no": null, "categories": "cs.LO cs.PL math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Normalization fails in type theory with an impredicative universe of\npropositions and a proof-irrelevant propositional equality. The counterexample\nto normalization is adapted from Girard's counterexample against normalization\nof System F equipped with a decider for type equality. It refutes Werner's\nnormalization conjecture [LMCS 2008].\n", "versions": [{"version": "v1", "created": "Tue, 19 Nov 2019 09:38:00 GMT"}, {"version": "v2", "created": "Sat, 25 Jan 2020 16:56:28 GMT"}, {"version": "v3", "created": "Mon, 3 Feb 2020 12:42:16 GMT"}, {"version": "v4", "created": "Sun, 28 Jun 2020 19:04:27 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Abel", "Andreas", ""], ["Coquand", "Thierry", ""]]}, {"id": "1911.08405", "submitter": "EPTCS", "authors": "Anastasia Mavridou (Vanderbilt University), Joseph Sifakis (Verimag),\n  Janos Sztipanovits (Vanderbilt University)", "title": "DesignBIP: A Design Studio for Modeling and Generating Systems with BIP", "comments": "In Proceedings MeTRiD 2018, arXiv:1806.09330. A technical report with\n  full details is available at arXiv:1805.09919", "journal-ref": "EPTCS 272, 2018, pp. 93-106", "doi": "10.4204/EPTCS.272.8", "report-no": null, "categories": "cs.SE cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Behavior-Interaction-Priority (BIP) framework, rooted in rigorous\nsemantics, allows the construction of systems that are correct-by-design. BIP\nhas been effectively used for the construction and analysis of large systems\nsuch as robot controllers and satellite on-board software. Nevertheless, the\nspecification of BIP models is done in a purely textual manner without any code\neditor support. To facilitate the specification of BIP models, we present\nDesignBIP, a web-based, collaborative, version-controlled design studio. To\npromote model scaling and reusability of BIP models, we use a graphical\nlanguage for modeling parameterized BIP models with rigorous semantics. We\npresent the various services provided by the design studio, including model\neditors, code editors, consistency checking mechanisms, code generators, and\nintegration with the JavaBIP tool-set.\n", "versions": [{"version": "v1", "created": "Thu, 5 Jul 2018 07:06:57 GMT"}], "update_date": "2019-11-20", "authors_parsed": [["Mavridou", "Anastasia", "", "Vanderbilt University"], ["Sifakis", "Joseph", "", "Verimag"], ["Sztipanovits", "Janos", "", "Vanderbilt University"]]}, {"id": "1911.08406", "submitter": "EPTCS", "authors": "Laura Bozzelli (University of Napoli Federico II), Aniello Murano\n  (University of Napoli Federico II), Adriano Peron (University of Napoli\n  Federico II)", "title": "Timed Context-Free Temporal Logics", "comments": "In Proceedings GandALF 2018, arXiv:1809.02416. arXiv admin note: A\n  technical report with full details is available at arXiv:1808.04271", "journal-ref": "EPTCS 277, 2018, pp. 235-249", "doi": "10.4204/EPTCS.277.17", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper is focused on temporal logics for the description of the behaviour\nof real-time pushdown reactive systems. The paper is motivated to bridge\ntractable logics specialized for expressing separately dense-time real-time\nproperties and context-free properties by ensuring decidability and\ntractability in the combined setting. To this end we introduce two real-time\nlinear temporal logics for specifying quantitative timing context-free\nrequirements in a pointwise semantics setting: Event-Clock Nested Temporal\nLogic (EC_NTL) and Nested Metric Temporal Logic (NMTL). The logic EC_NTL is an\nextension of both the logic CaRet (a context-free extension of standard LTL)\nand Event-Clock Temporal Logic (a tractable real-time logical framework related\nto the class of Event-Clock automata). We prove that satisfiability of EC_NTL\nand visibly model-checking of Visibly Pushdown Timed Automata (VPTA) against\nEC_NTL are decidable and EXPTIME-complete. The other proposed logic NMTL is a\ncontext-free extension of standard Metric Temporal Logic (MTL). It is well\nknown that satisfiability of future MTL is undecidable when interpreted over\ninfinite timed words but decidable over finite timed words. On the other hand,\nwe show that by augmenting future MTL with future context-free temporal\noperators, the satisfiability problem turns out to be undecidable also for\nfinite timed words. On the positive side, we devise a meaningful and decidable\nfragment of the logic NMTL which is expressively equivalent to EC_NTL and for\nwhich satisfiability and visibly model-checking of VPTA are EXPTIME-complete.\n", "versions": [{"version": "v1", "created": "Mon, 10 Sep 2018 02:34:40 GMT"}], "update_date": "2019-11-20", "authors_parsed": [["Bozzelli", "Laura", "", "University of Napoli Federico II"], ["Murano", "Aniello", "", "University of Napoli Federico II"], ["Peron", "Adriano", "", "University of Napoli\n  Federico II"]]}, {"id": "1911.08632", "submitter": "Siddharth Krishna", "authors": "Siddharth Krishna, Alexander J. Summers, Thomas Wies", "title": "Local Reasoning for Global Graph Properties", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Separation logics are widely used for verifying programs that manipulate\ncomplex heap-based data structures. These logics build on so-called separation\nalgebras, which allow expressing properties of heap regions such that\nmodifications to a region do not invalidate properties stated about the\nremainder of the heap. This concept is key to enabling modular reasoning and\nalso extends to concurrency. While heaps are naturally related to mathematical\ngraphs, many ubiquitous graph properties are non-local in character, such as\nreachability between nodes, path lengths, acyclicity and other structural\ninvariants, as well as data invariants which combine with these notions.\nReasoning modularly about such graph properties remains notoriously difficult,\nsince a local modification can have side-effects on a global property that\ncannot be easily confined to a small region.\n  In this paper, we address the question: What separation algebra can be used\nto avoid proof arguments reverting back to tedious global reasoning in such\ncases? To this end, we consider a general class of global graph properties\nexpressed as fixpoints of algebraic equations over graphs. We present\nmathematical foundations for reasoning about this class of properties, imposing\nminimal requirements on the underlying theory that allow us to define a\nsuitable separation algebra. Building on this theory we develop a general proof\ntechnique for modular reasoning about global graph properties over program\nheaps, in a way which can be integrated with existing separation logics. To\ndemonstrate our approach, we present local proofs for two challenging examples:\na priority inheritance protocol and the non-blocking concurrent Harris list.\n", "versions": [{"version": "v1", "created": "Tue, 19 Nov 2019 23:55:34 GMT"}], "update_date": "2019-11-21", "authors_parsed": [["Krishna", "Siddharth", ""], ["Summers", "Alexander J.", ""], ["Wies", "Thomas", ""]]}, {"id": "1911.08635", "submitter": "Minh Le", "authors": "Minh Le", "title": "Robust Deep Neural Networks Inspired by Fuzzy Logic", "comments": "7 pages, 4 figures, source code:\n  https://bitbucket.org/minhlab/newlogic", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.LO stat.ML", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Deep neural networks have achieved impressive performance and become the\nde-facto standard in many tasks. However, troubling phenomena such as\nadversarial and fooling examples suggest that the generalization they make is\nflawed. I argue that among the roots of the phenomena are two geometric\nproperties of common deep learning architectures: their distributed nature and\nthe connectedness of their decision regions. As a remedy, I propose new\narchitectures inspired by fuzzy logic that combine several alternative design\nelements. Through experiments on MNIST and CIFAR-10, the new models are shown\nto be more local, better at rejecting noise samples, and more robust against\nadversarial examples. Ablation analyses reveal behaviors on adversarial\nexamples that cannot be explained by the linearity hypothesis but are\nconsistent with the hypothesis that logic-inspired traits create more robust\nmodels.\n", "versions": [{"version": "v1", "created": "Wed, 20 Nov 2019 00:12:26 GMT"}, {"version": "v2", "created": "Mon, 3 Feb 2020 09:01:55 GMT"}, {"version": "v3", "created": "Sun, 26 Apr 2020 22:29:40 GMT"}], "update_date": "2020-04-28", "authors_parsed": [["Le", "Minh", ""]]}, {"id": "1911.08755", "submitter": "Preslav Nakov", "authors": "Shafiq Joty, Alberto Barr\\'on-Cede\\~no, Giovanni Da San Martino,\n  Simone Filice, Llu\\'is M\\`arquez, Alessandro Moschitti, Preslav Nakov", "title": "Global Thread-Level Inference for Comment Classification in Community\n  Question Answering", "comments": "community question answering, thread-level inference, graph-cut,\n  inductive logic programming", "journal-ref": "EMNLP-2015", "doi": null, "report-no": null, "categories": "cs.CL cs.AI cs.IR cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Community question answering, a recent evolution of question answering in the\nWeb context, allows a user to quickly consult the opinion of a number of people\non a particular topic, thus taking advantage of the wisdom of the crowd. Here\nwe try to help the user by deciding automatically which answers are good and\nwhich are bad for a given question. In particular, we focus on exploiting the\noutput structure at the thread level in order to make more consistent global\ndecisions. More specifically, we exploit the relations between pairs of\ncomments at any distance in the thread, which we incorporate in a graph-cut and\nin an ILP frameworks. We evaluated our approach on the benchmark dataset of\nSemEval-2015 Task 3. Results improved over the state of the art, confirming the\nimportance of using thread level information.\n", "versions": [{"version": "v1", "created": "Wed, 20 Nov 2019 08:09:36 GMT"}], "update_date": "2019-11-21", "authors_parsed": [["Joty", "Shafiq", ""], ["Barr\u00f3n-Cede\u00f1o", "Alberto", ""], ["Martino", "Giovanni Da San", ""], ["Filice", "Simone", ""], ["M\u00e0rquez", "Llu\u00eds", ""], ["Moschitti", "Alessandro", ""], ["Nakov", "Preslav", ""]]}, {"id": "1911.09032", "submitter": "Christian Schilling", "authors": "Thomas A. Henzinger and Anna Lukina and Christian Schilling", "title": "Outside the Box: Abstraction-Based Monitoring of Neural Networks", "comments": "accepted at ECAI 2020", "journal-ref": null, "doi": "10.3233/FAIA200375", "report-no": null, "categories": "cs.LG cs.AI cs.LO stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Neural networks have demonstrated unmatched performance in a range of\nclassification tasks. Despite numerous efforts of the research community,\nnovelty detection remains one of the significant limitations of neural\nnetworks. The ability to identify previously unseen inputs as novel is crucial\nfor our understanding of the decisions made by neural networks. At runtime,\ninputs not falling into any of the categories learned during training cannot be\nclassified correctly by the neural network. Existing approaches treat the\nneural network as a black box and try to detect novel inputs based on the\nconfidence of the output predictions. However, neural networks are not trained\nto reduce their confidence for novel inputs, which limits the effectiveness of\nthese approaches. We propose a framework to monitor a neural network by\nobserving the hidden layers. We employ a common abstraction from program\nanalysis - boxes - to identify novel behaviors in the monitored layers, i.e.,\ninputs that cause behaviors outside the box. For each neuron, the boxes range\nover the values seen in training. The framework is efficient and flexible to\nachieve a desired trade-off between raising false warnings and detecting novel\ninputs. We illustrate the performance and the robustness to variability in the\nunknown classes on popular image-classification benchmarks.\n", "versions": [{"version": "v1", "created": "Wed, 20 Nov 2019 17:03:21 GMT"}, {"version": "v2", "created": "Fri, 29 Nov 2019 10:32:30 GMT"}, {"version": "v3", "created": "Wed, 19 Feb 2020 15:46:18 GMT"}], "update_date": "2020-09-22", "authors_parsed": [["Henzinger", "Thomas A.", ""], ["Lukina", "Anna", ""], ["Schilling", "Christian", ""]]}, {"id": "1911.09473", "submitter": "Dmitry Shkatov", "authors": "Mikhail Rybakov and Dmitry Shkatov", "title": "Recursive enumerability and elementary frame definability in predicate\n  modal logic", "comments": null, "journal-ref": null, "doi": "10.1093/logcom/exz028", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the relationship between recursive enumerability and\nelementary frame definability in first-order predicate modal logic. On the one\nhand, it is well-known that every first-order predicate modal logic complete\nwith respect to an elementary class of Kripke frames, i.e., a class of frames\ndefinable by a classical first-order formula, is recursively enumerable. On the\nother, numerous examples are known of predicate modal logics, based on\n`natural' propositional modal logics with essentially second-order Kripke\nsemantics, that are either not recursively enumerable or Kripke incomplete.\nThis raises the question of whether every Kripke complete, recursively\nenumerable predicate modal logic can be characterized by an elementary class of\nKripke frames. We answer this question in the negative, by constructing a\nnormal predicate modal logic which is Kripke complete, recursively enumerable,\nbut not complete with respect to an elementary class of frames. We also present\nan example of a normal predicate modal logic that is recursively enumerable,\nKripke complete, and not complete with respect to an elementary class of rooted\nframes, but is complete with respect to an elementary class of frames that are\nnot rooted.\n", "versions": [{"version": "v1", "created": "Thu, 21 Nov 2019 14:02:36 GMT"}, {"version": "v2", "created": "Fri, 22 Nov 2019 14:44:40 GMT"}, {"version": "v3", "created": "Mon, 25 Nov 2019 12:55:36 GMT"}, {"version": "v4", "created": "Fri, 20 Dec 2019 19:35:23 GMT"}], "update_date": "2019-12-24", "authors_parsed": [["Rybakov", "Mikhail", ""], ["Shkatov", "Dmitry", ""]]}, {"id": "1911.10098", "submitter": "Alex Raymond", "authors": "Alex Raymond, Hatice Gunes, Amanda Prorok", "title": "Culture-Based Explainable Human-Agent Deconfliction", "comments": "9 pages, 4 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MA cs.HC cs.LO cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Law codes and regulations help organise societies for centuries, and as AI\nsystems gain more autonomy, we question how human-agent systems can operate as\npeers under the same norms, especially when resources are contended. We posit\nthat agents must be accountable and explainable by referring to which rules\njustify their decisions. The need for explanations is associated with user\nacceptance and trust. This paper's contribution is twofold: i) we propose an\nargumentation-based human-agent architecture to map human regulations into a\nculture for artificial agents with explainable behaviour. Our architecture\nleans on the notion of argumentative dialogues and generates explanations from\nthe history of such dialogues; and ii) we validate our architecture with a user\nstudy in the context of human-agent path deconfliction. Our results show that\nexplanations provide a significantly higher improvement in human performance\nwhen systems are more complex. Consequently, we argue that the criteria\ndefining the need of explanations should also consider the complexity of a\nsystem. Qualitative findings show that when rules are more complex,\nexplanations significantly reduce the perception of challenge for humans.\n", "versions": [{"version": "v1", "created": "Fri, 22 Nov 2019 15:51:18 GMT"}], "update_date": "2019-11-25", "authors_parsed": [["Raymond", "Alex", ""], ["Gunes", "Hatice", ""], ["Prorok", "Amanda", ""]]}, {"id": "1911.10099", "submitter": "Marijn Heule", "authors": "Sean Weaver and Marijn Heule", "title": "Constructing Minimal Perfect Hash Functions Using SAT Technology", "comments": "Accepted for AAAI 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Minimal perfect hash functions (MPHFs) are used to provide efficient access\nto values of large dictionaries (sets of key-value pairs). Discovering new\nalgorithms for building MPHFs is an area of active research, especially from\nthe perspective of storage efficiency. The information-theoretic limit for\nMPHFs is 1/(ln 2) or roughly 1.44 bits per key. The current best practical\nalgorithms range between 2 and 4 bits per key. In this article, we propose two\nSAT-based constructions of MPHFs. Our first construction yields MPHFs near the\ninformation-theoretic limit. For this construction, current state-of-the-art\nSAT solvers can handle instances where the dictionaries contain up to 40\nelements, thereby outperforming the existing (brute-force) methods. Our second\nconstruction uses XOR-SAT filters to realize a practical approach with\nlong-term storage of approximately 1.83 bits per key.\n", "versions": [{"version": "v1", "created": "Fri, 22 Nov 2019 15:52:01 GMT"}], "update_date": "2019-11-25", "authors_parsed": [["Weaver", "Sean", ""], ["Heule", "Marijn", ""]]}, {"id": "1911.10244", "submitter": "Daniel Kroening", "authors": "Mohammadhosein Hasanbeig, Natasha Yogananda Jeppu, Alessandro Abate,\n  Tom Melham, Daniel Kroening", "title": "DeepSynth: Automata Synthesis for Automatic Task Segmentation in Deep\n  Reinforcement Learning", "comments": "Extended version of AAAI 2021 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.AI cs.LO stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes DeepSynth, a method for effective training of deep\nReinforcement Learning (RL) agents when the reward is sparse and non-Markovian,\nbut at the same time progress towards the reward requires achieving an unknown\nsequence of high-level objectives. Our method employs a novel algorithm for\nsynthesis of compact automata to uncover this sequential structure\nautomatically. We synthesise a human-interpretable automaton from trace data\ncollected by exploring the environment. The state space of the environment is\nthen enriched with the synthesised automaton so that the generation of a\ncontrol policy by deep RL is guided by the discovered structure encoded in the\nautomaton. The proposed approach is able to cope with both high-dimensional,\nlow-level features and unknown sparse non-Markovian rewards. We have evaluated\nDeepSynth's performance in a set of experiments that includes the Atari game\nMontezuma's Revenge. Compared to existing approaches, we obtain a reduction of\ntwo orders of magnitude in the number of iterations required for policy\nsynthesis, and also a significant improvement in scalability.\n", "versions": [{"version": "v1", "created": "Fri, 22 Nov 2019 20:44:27 GMT"}, {"version": "v2", "created": "Wed, 12 Feb 2020 13:51:38 GMT"}, {"version": "v3", "created": "Thu, 27 Feb 2020 17:46:02 GMT"}, {"version": "v4", "created": "Tue, 22 Sep 2020 19:58:16 GMT"}, {"version": "v5", "created": "Sat, 6 Mar 2021 09:53:15 GMT"}], "update_date": "2021-03-09", "authors_parsed": [["Hasanbeig", "Mohammadhosein", ""], ["Jeppu", "Natasha Yogananda", ""], ["Abate", "Alessandro", ""], ["Melham", "Tom", ""], ["Kroening", "Daniel", ""]]}, {"id": "1911.10376", "submitter": "Elie Adam", "authors": "Elie M. Adam, Munther A. Dahleh", "title": "On the Mathematical Structure of Cascade Effects and Emergent Phenomena", "comments": "37 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.GT cs.SI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We argue that the mathematical structure, enabling certain cascading and\nemergent phenomena to intuitively emerge, coincides with Galois connections. We\nintroduce the notion of generative effects to formally capture such phenomena.\nWe establish that these effects arise, via a notion of a veil, from either\nconcealing mechanisms in a system or forgetting characteristics from it. The\ngoal of the work is to initiate a mathematical base that enables us to further\nstudy such phenomena. In particular, generative effects can be further linked\nto a certain loss of exactness. Homological algebra, and related algebraic\nmethods, may then be used to characterize the effects.\n", "versions": [{"version": "v1", "created": "Sat, 23 Nov 2019 15:19:54 GMT"}], "update_date": "2019-11-26", "authors_parsed": [["Adam", "Elie M.", ""], ["Dahleh", "Munther A.", ""]]}, {"id": "1911.10478", "submitter": "Shiraj Arora", "authors": "Shiraj Arora and M. V. Panduranga Rao", "title": "The Bouquet Algorithm for Model Checking Unbounded Until", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of verifying the \"Unbounded Until\" fragment in temporal logic\nformulas has been studied extensively in the past, especially in the context of\nstatistical model checking. Statistical model checking, a computationally\ninexpensive sampling based alternative to the more expensive numerical model\nchecking technique, presents the following decision dilemma -- what length of\nthe sample is enough in general? In this paper, we discuss an algorithm for\nthis problem that combines ideas from graph theory, statistical model checking\nand numerical model checking. We analyze the algorithm and show through\nexperiments that this approach outperforms the standard statistical model\nchecking algorithm for verifying unbounded until for low density Discrete Time\nMarkov Chains.\n", "versions": [{"version": "v1", "created": "Sun, 24 Nov 2019 09:07:15 GMT"}], "update_date": "2019-11-26", "authors_parsed": [["Arora", "Shiraj", ""], ["Rao", "M. V. Panduranga", ""]]}, {"id": "1911.10981", "submitter": "David Carral", "authors": "David Carral and Jacopo Urbani", "title": "Checking Chase Termination over Ontologies of Existential Rules with\n  Equality", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The chase is a sound and complete algorithm for conjunctive query answering\nover ontologies of existential rules with equality. To enable its effective\nuse, we can apply acyclicity notions; that is, sufficient conditions that\nguarantee chase termination. Unfortunately, most of these notions have only\nbeen defined for existential rule sets without equality. A proposed solution to\ncircumvent this issue is to treat equality as an ordinary predicate with an\nexplicit axiomatisation. We empirically show that this solution is not\nefficient in practice and propose an alternative approach. More precisely, we\nshow that, if the chase terminates for any equality axiomatisation of an\nontology, then it terminates for the original ontology (which may contain\nequality). Therefore, one can apply existing acyclicity notions to check chase\ntermination over an axiomatisation of an ontology and then use the original\nontology for reasoning. We show that, in practice, doing so results in a more\nefficient reasoning procedure. Furthermore, we present equality model-faithful\nacyclicity, a general acyclicity notion that can be directly applied to\nontologies with equality.\n", "versions": [{"version": "v1", "created": "Mon, 25 Nov 2019 15:29:25 GMT"}], "update_date": "2019-11-26", "authors_parsed": [["Carral", "David", ""], ["Urbani", "Jacopo", ""]]}, {"id": "1911.11086", "submitter": "Aldo Iv\\'an Ram\\'irez Abarca", "authors": "Aldo Iv\\'an Ram\\'irez Abarca and Jan Broersen", "title": "Stit Semantics for Epistemic Notions Based on Information Disclosure in\n  Interactive Settings", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We characterize four types of agentive knowledge using a stit semantics over\nbranching discrete-time structures. These are \\emph{ex ante} knowledge,\n\\emph{ex interim} knowledge, \\emph{ex post} knowledge, and know-how. The first\nthree are notions that arose from game-theoretical analyses on the stages of\ninformation disclosure across the decision making process, and the fourth has\ngained prominence both in logics of action and in deontic logic as a means to\nformalize ability. In recent years, logicians in AI have argued that any\ncomprehensive study of responsibility attribution and blameworthiness should\ninclude proper treatment of these kinds of knowledge. This paper intends to\nclarify previous attempts to formalize them in stit logic and to propose\nalternative interpretations that in our opinion are more akin to the study of\nresponsibility in the stit tradition. The logic we present uses an extension\nwith knowledge operators of the Xstit language, and formulas are evaluated with\nrespect to branching discrete-time models. We also present an axiomatic system\nfor this logic, and address its soundness and completeness.\n", "versions": [{"version": "v1", "created": "Tue, 19 Nov 2019 16:15:55 GMT"}], "update_date": "2019-11-26", "authors_parsed": [["Abarca", "Aldo Iv\u00e1n Ram\u00edrez", ""], ["Broersen", "Jan", ""]]}, {"id": "1911.11247", "submitter": "Alejandro D\\'iaz-Caro", "authors": "Federico Olmedo and Alejandro D\\'iaz-Caro", "title": "Runtime Analysis of Quantum Programs: A Formal Approach", "comments": "Accepted at PLanQC 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this abstract we study the resource consumption of quantum programs.\nSpecifically, we focus on the expected runtime of programs and, inspired by\nrecent methods for probabilistic programs, we develop a calculus \\`a la weakest\nprecondition to formally and systematically derive the (exact) expected runtime\nof quantum programs. Notably, the calculus admits a notion of loop runtime\ninvariant that can be readily used to derive upper bounds of their runtime.\nFinally, we show the applicability of our calculus analyzing the runtime of (a\nsimplified version of) the BB84 quantum key distribution protocol.\n", "versions": [{"version": "v1", "created": "Mon, 25 Nov 2019 21:45:59 GMT"}, {"version": "v2", "created": "Fri, 27 Dec 2019 22:12:20 GMT"}], "update_date": "2020-01-01", "authors_parsed": [["Olmedo", "Federico", ""], ["D\u00edaz-Caro", "Alejandro", ""]]}, {"id": "1911.11302", "submitter": "Zinovy Diskin", "authors": "Zinovy Diskin, Harald K\\\"onig, Mark Lawford", "title": "Multiple Model Synchronization with Multiary Delta Lenses with Amendment\n  and K-Putput", "comments": "The version published at FAC has multiple essential typos in section\n  7.1, which make that section practically unreadable", "journal-ref": "Formal Aspects of Computing 31(5): 611-640 (2019)", "doi": null, "report-no": null, "categories": "cs.LO cs.SE", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Multiple (more than 2) model synchronization is ubiquitous and important for\nmodel driven engineering, but its theoretical underpinning gained much less\nattention than the binary case. Specifically, the latter was extensively\nstudied by the bx community in the framework of algebraic models for update\npropagation called lenses. Now we make a step to restore the balance and\npropose a notion of multiary delta lens. Besides multiarity, our lenses feature\n{\\em reflective} updates, when consistency restoration requires some amendment\nof the update that violated consistency. We emphasize the importance of various\nways of lens composition for practical applications of the framework, and prove\nseveral composition results.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 01:32:55 GMT"}], "update_date": "2019-11-27", "authors_parsed": [["Diskin", "Zinovy", ""], ["K\u00f6nig", "Harald", ""], ["Lawford", "Mark", ""]]}, {"id": "1911.11347", "submitter": "Zhe Xu", "authors": "Zhe Xu, Agung Julius, Ufuk Topcu and Joe H. Chow", "title": "Controller Synthesis of Wind Turbine Generator and Energy Storage System\n  with Stochastic Wind Variations under Temporal Logic Specifications", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "eess.SY cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present a controller synthesis approach for wind turbine\ngenerators (WTG) and energy storage systems with metric temporal logic (MTL)\nspecifications, with provable probabilistic guarantees in the stochastic\nenvironment of wind power generation. The MTL specifications are requirements\nfor the grid frequency deviations, WTG rotor speed variations and the power\nflow constraints at different lines. We present the stochastic control\nbisimulation function, which bounds the divergence of the trajectories of a\nswitched stochastic control system and the switched nominal control system in a\nprobabilistic fashion.We first design a feedforward controller by solving an\noptimization problem for the nominal trajectory of the deterministic control\nsystem with robustness against initial state variations and stochastic\nuncertainties. Then we generate a feedback control law from the data of the\nsimulated trajectories. We implement our control method on both a four-bus\nsystem and a nine-bus system, and test the effectiveness of the method with a\ngeneration loss disturbance. We also test the advantage of the feedback\ncontroller over the feedforward controller when unexpected disturbance occurs.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 05:22:40 GMT"}], "update_date": "2019-11-27", "authors_parsed": [["Xu", "Zhe", ""], ["Julius", "Agung", ""], ["Topcu", "Ufuk", ""], ["Chow", "Joe H.", ""]]}, {"id": "1911.11359", "submitter": "Heng Zhang", "authors": "Heng Zhang, Yan Zhang, Jia-Huai You, Zhiyong Feng, Guifei Jiang", "title": "Towards Universal Languages for Tractable Ontology Mediated Query\n  Answering", "comments": "10 pages, 1 figure, the full version of a paper accepted for AAAI\n  2020. Some typos have been corrected", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.DB cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An ontology language for ontology mediated query answering (OMQA-language) is\nuniversal for a family of OMQA-languages if it is the most expressive one among\nthis family. In this paper, we focus on three families of tractable\nOMQA-languages, including first-order rewritable languages and languages whose\ndata complexity of the query answering is in AC0 or PTIME. On the negative\nside, we prove that there is, in general, no universal language for each of\nthese families of languages. On the positive side, we propose a novel property,\nthe locality, to approximate the first-order rewritability, and show that there\nexists a language of disjunctive embedded dependencies that is universal for\nthe family of OMQA-languages with locality. All of these results apply to OMQA\nwith query languages such as conjunctive queries, unions of conjunctive queries\nand acyclic conjunctive queries.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 06:07:20 GMT"}, {"version": "v2", "created": "Fri, 13 Dec 2019 12:37:48 GMT"}], "update_date": "2019-12-16", "authors_parsed": [["Zhang", "Heng", ""], ["Zhang", "Yan", ""], ["You", "Jia-Huai", ""], ["Feng", "Zhiyong", ""], ["Jiang", "Guifei", ""]]}, {"id": "1911.11500", "submitter": "Marco Voigt", "authors": "Marco Voigt", "title": "Separateness of Variables -- A Novel Perspective on Decidable\n  First-Order Fragments", "comments": "44 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The classical decision problem, as it is understood today, is the quest for a\ndelineation between the decidable and the undecidable parts of first-order\nlogic based on elegant syntactic criteria. In this paper, we treat the concept\nof separateness of variables and explore its applicability to the classical\ndecision problem. Two disjoint sets of first-order variables are separated in a\ngiven formula if variables from the two sets never co-occur in any atom of that\nformula. This simple notion facilitates extending many well-known decidable\nfirst-order fragments significantly and in a way that preserves decidability.\nWe will demonstrate that for several prefix fragments, several guarded\nfragments, the two-variable fragment, and for the fluted fragment. Altogether,\nwe will investigate nine such extensions more closely. Interestingly, each of\nthem contains the relational monadic first-order fragment without equality.\nAlthough the extensions exhibit the same expressive power as the respective\noriginals, certain logical properties can be expressed much more succinctly. In\nthree cases the succinctness gap cannot be bounded using any elementary\nfunction.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 13:01:37 GMT"}], "update_date": "2019-11-27", "authors_parsed": [["Voigt", "Marco", ""]]}, {"id": "1911.11584", "submitter": "James Cheney", "authors": "Sheung Chi Chan and James Cheney", "title": "Flexible graph matching and graph edit distance using answer set\n  programming", "comments": "To appear, PADL 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The graph isomorphism, subgraph isomorphism, and graph edit distance problems\nare combinatorial problems with many applications. Heuristic exact and\napproximate algorithms for each of these problems have been developed for\ndifferent kinds of graphs: directed, undirected, labeled, etc. However,\nadditional work is often needed to adapt such algorithms to different classes\nof graphs, for example to accommodate both labels and property annotations on\nnodes and edges. In this paper, we propose an approach based on answer set\nprogramming. We show how each of these problems can be defined for a general\nclass of property graphs with directed edges, and labels and key-value\nproperties annotating both nodes and edges. We evaluate this approach on a\nvariety of synthetic and realistic graphs, demonstrating that it is feasible as\na rapid prototyping approach.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 14:49:25 GMT"}], "update_date": "2019-11-27", "authors_parsed": [["Chan", "Sheung Chi", ""], ["Cheney", "James", ""]]}, {"id": "1911.11629", "submitter": "Anton Fuxjaeger", "authors": "Anton Fuxjaeger, Vaishak Belle", "title": "Logical Interpretations of Autoencoders", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The unification of low-level perception and high-level reasoning is a\nlong-standing problem in artificial intelligence, which has the potential to\nnot only bring the areas of logic and learning closer together but also\ndemonstrate how abstract concepts might emerge from sensory data. Precisely\nbecause deep learning methods dominate perception-based learning, including\nvision, speech, and linguistic grammar, there is fast-growing literature on how\nto integrate symbolic reasoning and deep learning. Broadly, efforts seem to\nfall into three camps: those focused on defining a logic whose formulas capture\ndeep learning, ones that integrate symbolic constraints in deep learning, and\nothers that allow neural computations and symbolic reasoning to co-exist\nseparately, to enjoy the strengths of both worlds. In this paper, we identify\nanother dimension to this inquiry: what do the hidden layers really capture,\nand how can we reason about that logically? In particular, we consider\nautoencoders that are widely used for dimensionality reduction and inject a\nsymbolic generative framework onto the feature layer. This allows us, among\nother things, to generate example images for a class to get a sense of what was\nlearned. Moreover, the modular structure of the proposed model makes it\npossible to learn relations over multiple images at a time, as well as handle\nnoisy labels. Our empirical evaluations show the promise of this inquiry.\n", "versions": [{"version": "v1", "created": "Tue, 26 Nov 2019 15:20:32 GMT"}], "update_date": "2019-11-27", "authors_parsed": [["Fuxjaeger", "Anton", ""], ["Belle", "Vaishak", ""]]}, {"id": "1911.12073", "submitter": "Cezary Kaliszyk", "authors": "Miroslav Ol\\v{s}\\'ak, Cezary Kaliszyk and Josef Urban", "title": "Property Invariant Embedding for Automated Reasoning", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automated reasoning and theorem proving have recently become major challenges\nfor machine learning. In other domains, representations that are able to\nabstract over unimportant transformations, such as abstraction over\ntranslations and rotations in vision, are becoming more common. Standard\nmethods of embedding mathematical formulas for learning theorem proving are\nhowever yet unable to handle many important transformations. In particular,\nembedding previously unseen labels, that often arise in definitional encodings\nand in Skolemization, has been very weak so far. Similar problems appear when\ntransferring knowledge between known symbols.\n  We propose a novel encoding of formulas that extends existing graph neural\nnetwork models. This encoding represents symbols only by nodes in the graph,\nwithout giving the network any knowledge of the original labels. We provide\nadditional links between such nodes that allow the network to recover the\nmeaning and therefore correctly embed such nodes irrespective of the given\nlabels. We test the proposed encoding in an automated theorem prover based on\nthe tableaux connection calculus, and show that it improves on the best\ncharacterizations used so far. The encoding is further evaluated on the premise\nselection task and a newly introduced symbol guessing task, and shown to\ncorrectly predict 65% of the symbol names.\n", "versions": [{"version": "v1", "created": "Wed, 27 Nov 2019 10:55:23 GMT"}], "update_date": "2019-11-28", "authors_parsed": [["Ol\u0161\u00e1k", "Miroslav", ""], ["Kaliszyk", "Cezary", ""], ["Urban", "Josef", ""]]}, {"id": "1911.12749", "submitter": "Ferruccio Guidi Dr", "authors": "Ferruccio Guidi", "title": "A Formal System for the Universal Quantification of Schematic Variables", "comments": "37 pages, minor revision", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We advocate the use of de Bruijn's universal abstraction $\\lambda^\\infty$ for\nthe quantification of schematic variables in the predicative setting and we\npresent a typed $\\lambda$-calculus featuring the quantifier $\\lambda^\\infty$\naccompanied by other practically useful constructions like explicit\nsubstitutions and expected type annotations. The calculus stands just on two\nnotions, i.e., bound rt-reduction and parametric validity, and has the\nexpressive power of $\\lambda\\rightarrow$. Thus, while not aiming at being a\nlogical framework by itself, it does enjoy many desired invariants of logical\nframeworks including confluence of reduction, strong normalization,\npreservation of type by reduction, decidability, correctness of types and\nuniqueness of types up to conversion. This calculus belongs to the\n$\\lambda\\delta$ family of formal systems, which borrow some features from the\npure type systems and some from the languages of the Automath tradition, but\nstand outside both families. In particular, the calculus includes and evolves\ntwo earlier systems of this family. Moreover, a machine-checked specification\nof its theory is available.\n", "versions": [{"version": "v1", "created": "Thu, 28 Nov 2019 15:23:52 GMT"}, {"version": "v2", "created": "Wed, 25 Mar 2020 16:34:42 GMT"}, {"version": "v3", "created": "Wed, 28 Oct 2020 16:04:40 GMT"}, {"version": "v4", "created": "Wed, 16 Dec 2020 16:12:34 GMT"}, {"version": "v5", "created": "Fri, 7 May 2021 22:43:23 GMT"}], "update_date": "2021-05-11", "authors_parsed": [["Guidi", "Ferruccio", ""]]}, {"id": "1911.12837", "submitter": "Xavier Parent Dr.", "authors": "D. Gabbay, X. Parent and L. van der Torre", "title": "A geometrical view of I/O logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a geometrical account of the I/O logic put forth by Makinson and\nvan der Torre. A soundness and completeness results was reported for the\nsimplest I/O operation called simple-minded, and in the finite case only. On\nthis account a generator acts as a \"jump\" within a lattice.\n", "versions": [{"version": "v1", "created": "Thu, 28 Nov 2019 19:25:40 GMT"}], "update_date": "2019-12-02", "authors_parsed": [["Gabbay", "D.", ""], ["Parent", "X.", ""], ["van der Torre", "L.", ""]]}, {"id": "1911.12884", "submitter": "Graham Campbell", "authors": "Graham Campbell and Detlef Plump", "title": "Efficient Recognition of Graph Languages", "comments": "Project Report, Department of Computer Science, University of York,\n  83 pages, 2019. arXiv admin note: substantial text overlap with\n  arXiv:1906.05170", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC cs.SC", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  Graph transformation is the rule-based modification of graphs, and is a\ndiscipline dating back to the 1970s. In general, to match the left-hand graph\nof a fixed rule within a host graph requires polynomial time, but to improve\nmatching performance, D\\\"orr proposed to equip rules and host graphs with\ndistinguished root nodes. This model was implemented by Plump and Bak, but\nunfortunately, such rules are not invertible. We address this problem by\ndefining rootedness using a partial function into a two-point set rather than\npointing graphs with root nodes, meaning derivations are natural double\npushouts. Moreover, we give a sufficient condition on rules to give constant\ntime rule application on graphs of bounded degree, and that, the graph class of\ntrees can be recognised in linear time, given an input graph of bounded degree.\nFinally, we define a new notion of confluence up to garbage and non-garbage\ncritical pairs, showing it is sufficient to require strong joinability of only\nthe non-garbage critical pairs to establish confluence up to garbage. Finally,\nthis new result, presented for conventional graph transformation systems, can\nbe lifted to our rooted setting by encoding node labels and rootedness as\nlooped edges.\n", "versions": [{"version": "v1", "created": "Thu, 28 Nov 2019 22:32:41 GMT"}, {"version": "v2", "created": "Wed, 11 Dec 2019 20:42:37 GMT"}, {"version": "v3", "created": "Fri, 1 Jan 2021 12:34:22 GMT"}], "update_date": "2021-01-05", "authors_parsed": [["Campbell", "Graham", ""], ["Plump", "Detlef", ""]]}, {"id": "1911.12904", "submitter": "Zinovy Diskin", "authors": "Zinovy Diskin", "title": "General supervised learning as change propagation with delta lenses", "comments": "An extended version of paper with the same title published at FOSSACS\n  2020. Unfortunately, both the paper and the previous version of the extended\n  version uploaded to arxiv on Feb 26, 2020, had bad typos in Definition 4 and\n  Fig.4, which are now fixed", "journal-ref": "In: Foundations of Software Science and Computation Structures.\n  FoSSaCS 2020. Lecture Notes in Computer Science, vol 12077. Springer,\n  pp.177-197", "doi": "10.1007/978-3-030-45231-5_10", "report-no": null, "categories": "cs.LO math.CT", "license": "http://creativecommons.org/licenses/by-sa/4.0/", "abstract": "  Delta lenses are an established mathematical framework for modelling and\ndesigning bidirectional model transformations. Following the recent\nobservations by Fong et al, the paper extends the delta lens framework with a a\nnew ingredient: learning over a parameterized space of model transformations\nseen as functors. We define a notion of an asymmetric learning delta lens with\namendment (ala-lens), and show how ala-lenses can be organized into a symmetric\nmonoidal (sm) category. We also show that sequential and parallel composition\nof well-behaved ala-lenses are also well-behaved so that well-behaved\nala-lenses constitute a full sm-subcategory of ala-lenses.\n", "versions": [{"version": "v1", "created": "Thu, 28 Nov 2019 23:56:43 GMT"}, {"version": "v2", "created": "Tue, 25 Feb 2020 17:44:25 GMT"}, {"version": "v3", "created": "Wed, 26 Feb 2020 01:51:32 GMT"}, {"version": "v4", "created": "Fri, 9 Jul 2021 17:56:07 GMT"}], "update_date": "2021-07-12", "authors_parsed": [["Diskin", "Zinovy", ""]]}, {"id": "1911.13024", "submitter": "Timotheus Kampik", "authors": "Timotheus Kampik and Juan Carlos Nieves", "title": "Abstract Argumentation and the Rational Man", "comments": "To appear in the Journal of Logic and Computation", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Abstract argumentation has emerged as a method for non-monotonic reasoning\nthat has gained popularity in the symbolic artificial intelligence community.\nIn the literature, the different approaches to abstract argumentation that were\nrefined over the years are typically evaluated from a formal logics\nperspective; an analysis that is based on models of economically rational\ndecision-making does not exist. In this paper, we work towards addressing this\nissue by analyzing abstract argumentation from the perspective of the rational\nman paradigm in microeconomic theory. To assess under which conditions abstract\nargumentation-based decision-making can be considered economically rational, we\nderive reference independence as a non-monotonic inference property from a\nformal model of economic rationality and create a new argumentation principle\nthat ensures compliance with this property. We then compare the reference\nindependence principle with other reasoning principles, in particular with\ncautious monotony and rational monotony. We show that the argumentation\nsemantics as proposed in Dung's seminal paper, as well as other semantics we\nevaluate -- with the exception of naive semantics and the SCC-recursive CF2\nsemantics -- violate the reference independence principle. Consequently, we\ninvestigate how structural properties of argumentation frameworks impact the\nreference independence principle, and identify cyclic expansions (both even and\nodd cycles) as the root of the problem. Finally, we put reference independence\ninto the context of preference-based argumentation and show that for this\nargumentation variant, which explicitly models preferences, reference\nindependence cannot be ensured in a straight-forward manner.\n", "versions": [{"version": "v1", "created": "Fri, 29 Nov 2019 09:51:44 GMT"}, {"version": "v2", "created": "Fri, 13 Dec 2019 23:03:08 GMT"}, {"version": "v3", "created": "Tue, 17 Mar 2020 15:47:04 GMT"}, {"version": "v4", "created": "Thu, 6 Aug 2020 19:28:17 GMT"}, {"version": "v5", "created": "Mon, 30 Nov 2020 20:08:02 GMT"}, {"version": "v6", "created": "Fri, 8 Jan 2021 12:58:59 GMT"}], "update_date": "2021-01-11", "authors_parsed": [["Kampik", "Timotheus", ""], ["Nieves", "Juan Carlos", ""]]}, {"id": "1911.13104", "submitter": "Flavio Ferrarotti", "authors": "Flavio Ferrarotti, Sen\\'en Gonz\\'alez, Klaus-Dieter Schewe, Jos\\'e\n  Mar\\'ia Turull-Torres", "title": "Proper Hierarchies in Polylogarithmic Time and Absence of Complete\n  Problems", "comments": "Paper submitted to FoIKS 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The polylogarithmic time hierarchy structures sub-linear time complexity. In\nrecent work it was shown that all classes $\\tilde{\\Sigma}_{m}^{\\mathit{plog}}$\nor $\\tilde{\\Pi}_{m}^{\\mathit{plog}}$ ($m \\in \\mathbb{N}$) in this hierarchy can\nbe captured by semantically restricted fragments of second-order logic. In this\npaper the descriptive complexity theory of polylogarithmic time is taken\nfurther showing that there are strict hierarchies inside each of the classes of\nthe hierarchy. A straightforward consequence of this result is that there are\nno complete problems for these complexity classes, not even under polynomial\ntime reductions. As another consequence we show that the polylogarithmic time\nhierarchy itself is strict.\n", "versions": [{"version": "v1", "created": "Fri, 29 Nov 2019 13:30:16 GMT"}], "update_date": "2019-12-02", "authors_parsed": [["Ferrarotti", "Flavio", ""], ["Gonz\u00e1lez", "Sen\u00e9n", ""], ["Schewe", "Klaus-Dieter", ""], ["Turull-Torres", "Jos\u00e9 Mar\u00eda", ""]]}, {"id": "1911.13152", "submitter": "Daniel Furelos-Blanco", "authors": "Daniel Furelos-Blanco, Mark Law, Alessandra Russo, Krysia Broda and\n  Anders Jonsson", "title": "Induction of Subgoal Automata for Reinforcement Learning", "comments": "Preprint accepted for publication to the 34th AAAI Conference on\n  Artificial Intelligence (AAAI-20)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.AI cs.LO stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work we present ISA, a novel approach for learning and exploiting\nsubgoals in reinforcement learning (RL). Our method relies on inducing an\nautomaton whose transitions are subgoals expressed as propositional formulas\nover a set of observable events. A state-of-the-art inductive logic programming\nsystem is used to learn the automaton from observation traces perceived by the\nRL agent. The reinforcement learning and automaton learning processes are\ninterleaved: a new refined automaton is learned whenever the RL agent generates\na trace not recognized by the current automaton. We evaluate ISA in several\ngridworld problems and show that it performs similarly to a method for which\nautomata are given in advance. We also show that the learned automata can be\nexploited to speed up convergence through reward shaping and transfer learning\nacross multiple tasks. Finally, we analyze the running time and the number of\ntraces that ISA needs to learn an automata, and the impact that the number of\nobservable events has on the learner's performance.\n", "versions": [{"version": "v1", "created": "Fri, 29 Nov 2019 15:28:54 GMT"}], "update_date": "2019-12-02", "authors_parsed": [["Furelos-Blanco", "Daniel", ""], ["Law", "Mark", ""], ["Russo", "Alessandra", ""], ["Broda", "Krysia", ""], ["Jonsson", "Anders", ""]]}]