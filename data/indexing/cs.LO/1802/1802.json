[{"id": "1802.00195", "submitter": "Radu Iosif", "authors": "Mnacho Echenim, Radu Iosif, Nicolas Peltier", "title": "On the Expressive Completeness of Bernays-Sch\\\"onfinkel-Ramsey\n  Separation Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper investigates the satisfiability problem for Separation Logic, with\nunrestricted nesting of separating conjunctions and implications, for prenex\nformulae with quantifier prefix in the language $\\exists^*\\forall^*$, in the\ncases where the universe of possible locations is either countably infinite or\nfinite. In analogy with first-order logic with uninterpreted predicates and\nequality, we call this fragment Bernays-Sch\\\"onfinkel-Ramsey Separation Logic\n[BSR(SLk)]. We show that, unlike in first-order logic, the (in)finite\nsatisfiability problem is undecidable for BSR(SLk) and we define two\nnon-trivial subsets thereof, that are decidable for finite and infinite\nsatisfiability, respectively, by controlling the occurrences of universally\nquantified variables within the scope of separating implications, as well as\nthe polarity of the occurrences of the latter. The decidability results are\nobtained by a controlled elimination of separating connectives, described as\n(i) an effective translation of a prenex form Separation Logic formula into a\ncombination of a small number of \\emph{test formulae}, using only first-order\nconnectives, followed by (ii) a translation of the latter into an\nequisatisfiable first-order formula.\n", "versions": [{"version": "v1", "created": "Thu, 1 Feb 2018 08:49:14 GMT"}, {"version": "v2", "created": "Fri, 16 Feb 2018 09:37:05 GMT"}], "update_date": "2018-02-19", "authors_parsed": [["Echenim", "Mnacho", ""], ["Iosif", "Radu", ""], ["Peltier", "Nicolas", ""]]}, {"id": "1802.00405", "submitter": "William Farmer", "authors": "Jacques Carette and William M. Farmer and Patrick Laskowski", "title": "HOL Light QE", "comments": "20 pages. arXiv admin note: text overlap with arXiv:1612.02785", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We are interested in algorithms that manipulate mathematical expressions in\nmathematically meaningful ways. Expressions are syntactic, but most logics do\nnot allow one to discuss syntax. ${\\rm CTT}_{\\rm qe}$ is a version of Church's\ntype theory that includes quotation and evaluation operators, akin to quote and\neval in the Lisp programming language. Since the HOL logic is also a version of\nChurch's type theory, we decided to add quotation and evaluation to HOL Light\nto demonstrate the implementability of ${\\rm CTT}_{\\rm qe}$ and the benefits of\nhaving quotation and evaluation in a proof assistant. The resulting system is\ncalled HOL Light QE. Here we document the design of HOL Light QE and the\nchallenges that needed to be overcome. The resulting implementation is freely\navailable.\n", "versions": [{"version": "v1", "created": "Thu, 1 Feb 2018 17:31:06 GMT"}, {"version": "v2", "created": "Sat, 12 May 2018 18:05:54 GMT"}], "update_date": "2018-05-15", "authors_parsed": [["Carette", "Jacques", ""], ["Farmer", "William M.", ""], ["Laskowski", "Patrick", ""]]}, {"id": "1802.00478", "submitter": "Paul Wild", "authors": "Paul Wild, Lutz Schr\\\"oder, Dirk Pattinson, Barbara K\\\"onig", "title": "A van Benthem Theorem for Fuzzy Modal Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a fuzzy (or quantitative) version of the van Benthem theorem,\nwhich characterizes propositional modal logic as the bisimulation-invariant\nfragment of first-order logic. Specifically, we consider a first-order fuzzy\npredicate logic along with its modal fragment, and show that the fuzzy\nfirst-order formulas that are non-expansive w.r.t. the natural notion of\nbisimulation distance are exactly those that can be approximated by fuzzy modal\nformulas.\n", "versions": [{"version": "v1", "created": "Thu, 1 Feb 2018 20:35:06 GMT"}, {"version": "v2", "created": "Mon, 5 Feb 2018 14:23:33 GMT"}], "update_date": "2018-02-06", "authors_parsed": [["Wild", "Paul", ""], ["Schr\u00f6der", "Lutz", ""], ["Pattinson", "Dirk", ""], ["K\u00f6nig", "Barbara", ""]]}, {"id": "1802.00523", "submitter": "Paul He", "authors": "Joel Day, Vijay Ganesh, Paul He, Florin Manea, Dirk Nowotka", "title": "The Satisfiability of Extended Word Equations: The Boundary Between\n  Decidability and Undecidability", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The study of word equations (or the existential theory of equations over free\nmonoids) is a central topic in mathematics and theoretical computer science.\nThe problem of deciding whether a given word equation has a solution was shown\nto be decidable by Makanin in the late 1970s, and since then considerable work\nhas been done on this topic. In recent years, this decidability question has\ngained critical importance in the context of string SMT solvers for security\nanalysis. Further, many extensions (e.g., quantifier-free word equations with\nlinear arithmetic over the length function) and fragments (e.g., restrictions\non the number of variables) of this theory are important from a theoretical\npoint of view, as well as for program analysis applications. Motivated by these\nconsiderations, we prove several new results and thus shed light on the\nboundary between decidability and undecidability for many fragments and\nextensions of the first order theory of word equations.\n", "versions": [{"version": "v1", "created": "Fri, 2 Feb 2018 00:46:36 GMT"}], "update_date": "2018-02-05", "authors_parsed": [["Day", "Joel", ""], ["Ganesh", "Vijay", ""], ["He", "Paul", ""], ["Manea", "Florin", ""], ["Nowotka", "Dirk", ""]]}, {"id": "1802.00640", "submitter": "Pierre Lescanne", "authors": "Maciej Bendkowski, Pierre Lescanne", "title": "On the enumeration of closures and environments with an application to\n  random generation", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 4 (October\n  17, 2019) lmcs:5852", "doi": "10.23638/LMCS-15(4:3)2019", "report-no": null, "categories": "cs.LO math.CO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Environments and closures are two of the main ingredients of evaluation in\nlambda-calculus. A closure is a pair consisting of a lambda-term and an\nenvironment, whereas an environment is a list of lambda-terms assigned to free\nvariables. In this paper we investigate some dynamic aspects of evaluation in\nlambda-calculus considering the quantitative, combinatorial properties of\nenvironments and closures. Focusing on two classes of environments and\nclosures, namely the so-called plain and closed ones, we consider the problem\nof their asymptotic counting and effective random generation. We provide an\nasymptotic approximation of the number of both plain environments and closures\nof size $n$. Using the associated generating functions, we construct effective\nsamplers for both classes of combinatorial structures. Finally, we discuss the\nrelated problem of asymptotic counting and random generation of closed\nenvironemnts and closures.\n", "versions": [{"version": "v1", "created": "Fri, 2 Feb 2018 11:13:01 GMT"}, {"version": "v2", "created": "Thu, 22 Nov 2018 13:34:12 GMT"}, {"version": "v3", "created": "Tue, 22 Jan 2019 10:48:29 GMT"}, {"version": "v4", "created": "Tue, 2 Jul 2019 10:35:36 GMT"}, {"version": "v5", "created": "Wed, 16 Oct 2019 15:22:10 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Bendkowski", "Maciej", ""], ["Lescanne", "Pierre", ""]]}, {"id": "1802.00756", "submitter": "Reuben Rowe", "authors": "Liron Cohen and Reuben N. S. Rowe", "title": "Infinitary and Cyclic Proof Systems for Transitive Closure Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Transitive closure logic is a known extension of first-order logic obtained\nby introducing a transitive closure operator. While other extensions of\nfirst-order logic with inductive definitions are a priori parametrized by a set\nof inductive definitions, the addition of the transitive closure operator\nuniformly captures all finitary inductive definitions. In this paper we present\nan infinitary proof system for transitive closure logic which is an infinite\ndescent-style counterpart to the existing (explicit induction) proof system for\nthe logic. We show that, as for similar systems for first-order logic with\ninductive definitions, our infinitary system is complete for the standard\nsemantics and subsumes the explicit system. Moreover, the uniformity of the\ntransitive closure operator allows semantically meaningful complete\nrestrictions to be defined using simple syntactic criteria. Consequently, the\nrestriction to regular infinitary (i.e. cyclic) proofs provides the basis for\nan effective system for automating inductive reasoning.\n", "versions": [{"version": "v1", "created": "Fri, 2 Feb 2018 16:26:04 GMT"}, {"version": "v2", "created": "Mon, 5 Feb 2018 13:31:22 GMT"}, {"version": "v3", "created": "Thu, 28 Jun 2018 13:45:58 GMT"}], "update_date": "2018-06-29", "authors_parsed": [["Cohen", "Liron", ""], ["Rowe", "Reuben N. S.", ""]]}, {"id": "1802.00758", "submitter": "Viktor Toman", "authors": "Tom\\'a\\v{s} Br\\'azdil, Krishnendu Chatterjee, Jan K\\v{r}et\\'insk\\'y,\n  Viktor Toman", "title": "Strategy Representation by Decision Trees in Reactive Synthesis", "comments": "Full version of the paper. To appear in TACAS 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Graph games played by two players over finite-state graphs are central in\nmany problems in computer science. In particular, graph games with\n$\\omega$-regular winning conditions, specified as parity objectives, which can\nexpress properties such as safety, liveness, fairness, are the basic framework\nfor verification and synthesis of reactive systems. The decisions for a player\nat various states of the graph game are represented as strategies. While the\nalgorithmic problem for solving graph games with parity objectives has been\nwidely studied, the most prominent data-structure for strategy representation\nin graph games has been binary decision diagrams (BDDs). However, due to the\nbit-level representation, BDDs do not retain the inherent flavor of the\ndecisions of strategies, and are notoriously hard to minimize to obtain\nsuccinct representation. In this work we propose decision trees for strategy\nrepresentation in graph games. Decision trees retain the flavor of decisions of\nstrategies and allow entropy-based minimization to obtain succinct trees.\nHowever, decision trees work in settings (e.g., probabilistic models) where\nerrors are allowed, and overfitting of data is typically avoided. In contrast,\nfor strategies in graph games no error is allowed, and the decision tree must\nrepresent the entire strategy. We develop new techniques to extend decision\ntrees to overcome the above obstacles, while retaining the entropy-based\ntechniques to obtain succinct trees. We have implemented our techniques to\nextend the existing decision tree solvers. We present experimental results for\nproblems in reactive synthesis to show that decision trees provide a much more\nefficient data-structure for strategy representation as compared to BDDs.\n", "versions": [{"version": "v1", "created": "Fri, 2 Feb 2018 16:29:18 GMT"}, {"version": "v2", "created": "Mon, 19 Mar 2018 13:19:07 GMT"}], "update_date": "2018-03-20", "authors_parsed": [["Br\u00e1zdil", "Tom\u00e1\u0161", ""], ["Chatterjee", "Krishnendu", ""], ["K\u0159et\u00ednsk\u00fd", "Jan", ""], ["Toman", "Viktor", ""]]}, {"id": "1802.00914", "submitter": "Hans van Ditmarsch", "authors": "Hans van Ditmarsch, Wiebe van der Hoek, Barteld Kooi, Louwe B. Kuijer", "title": "Arrow Update Synthesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this contribution we present arbitrary arrow update model logic (AAUML).\nThis is a dynamic epistemic logic or update logic. In update logics,\nstatic/basic modalities are interpreted on a given relational model whereas\ndynamic/update modalities induce transformations (updates) of relational\nmodels. In AAUML the update modalities formalize the execution of arrow update\nmodels, and there is also a modality for quantification over arrow update\nmodels. Arrow update models are an alternative to the well-known action models.\nWe provide an axiomatization of AAUML. The axiomatization is a rewrite system\nallowing to eliminate arrow update modalities from any given formula, while\npreserving truth. Thus, AAUML is decidable and equally expressive as the base\nmulti-agent modal logic. Our main result is to establish arrow update\nsynthesis: if there is an arrow update model after which phi, we can construct\n(synthesize) that model from phi. We also point out some pregnant differences\nin update expressivity between arrow update logics, action model logics, and\nrefinement modal logic.\n", "versions": [{"version": "v1", "created": "Sat, 3 Feb 2018 05:17:40 GMT"}, {"version": "v2", "created": "Sun, 3 Feb 2019 17:04:48 GMT"}, {"version": "v3", "created": "Thu, 24 Oct 2019 17:03:20 GMT"}], "update_date": "2019-10-25", "authors_parsed": [["van Ditmarsch", "Hans", ""], ["van der Hoek", "Wiebe", ""], ["Kooi", "Barteld", ""], ["Kuijer", "Louwe B.", ""]]}, {"id": "1802.00961", "submitter": "Federico Aschieri", "authors": "F. Aschieri, A. Ciabattoni, F. A. Genco", "title": "Disjunctive Axioms and Concurrent $\\lambda$-Calculi: a Curry-Howard\n  Approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We add to intuitionistic logic infinitely many classical disjunctive\ntautologies and use the Curry--Howard correspondence to obtain typed concurrent\n$\\lambda$-calculi; each of them features a specific communication mechanism,\nincluding broadcasting and cyclic message-exchange, and enhanced expressive\npower with respect to the $\\lambda$-calculus. Moreover they all implement forms\nof code mobility. Our results provide a first concurrent computational\ninterpretation for many propositional intermediate logics, classical logic\nincluded.\n", "versions": [{"version": "v1", "created": "Sat, 3 Feb 2018 11:57:11 GMT"}, {"version": "v2", "created": "Tue, 13 Feb 2018 15:39:42 GMT"}], "update_date": "2018-02-14", "authors_parsed": [["Aschieri", "F.", ""], ["Ciabattoni", "A.", ""], ["Genco", "F. A.", ""]]}, {"id": "1802.01170", "submitter": "Anders M\\\"ortberg", "authors": "Thierry Coquand, Simon Huber, Anders M\\\"ortberg", "title": "On Higher Inductive Types in Cubical Type Theory", "comments": "24 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cubical type theory provides a constructive justification to certain aspects\nof homotopy type theory such as Voevodsky's univalence axiom. This makes many\nextensionality principles, like function and propositional extensionality,\ndirectly provable in the theory. This paper describes a constructive semantics,\nexpressed in a presheaf topos with suitable structure inspired by cubical sets,\nof some higher inductive types. It also extends cubical type theory by a syntax\nfor the higher inductive types of spheres, torus, suspensions,truncations, and\npushouts. All of these types are justified by the semantics and have judgmental\ncomputation rules for all constructors, including the higher dimensional ones,\nand the universes are closed under these type formers.\n", "versions": [{"version": "v1", "created": "Sun, 4 Feb 2018 18:19:44 GMT"}, {"version": "v2", "created": "Mon, 30 Apr 2018 20:39:48 GMT"}], "update_date": "2018-05-02", "authors_parsed": [["Coquand", "Thierry", ""], ["Huber", "Simon", ""], ["M\u00f6rtberg", "Anders", ""]]}, {"id": "1802.01177", "submitter": "Jochen Burghardt", "authors": "Jochen Burghardt", "title": "A Scheme-Driven Approach to Learning Programs from Input/Output\n  Equations", "comments": "19 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.PL", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We describe an approach to learn, in a term-rewriting setting, function\ndefinitions from input/output equations. By confining ourselves to structurally\nrecursive definitions we obtain a fairly fast learning algorithm that often\nyields definitions close to intuitive expectations. We provide a Prolog\nprototype implementation of our approach, and indicate open issues of further\ninvestigation.\n", "versions": [{"version": "v1", "created": "Sun, 4 Feb 2018 19:17:57 GMT"}], "update_date": "2018-02-06", "authors_parsed": [["Burghardt", "Jochen", ""]]}, {"id": "1802.01226", "submitter": "Andr\\'e Platzer", "authors": "Andr\\'e Platzer and Yong Kiam Tan", "title": "Differential Equation Axiomatization: The Impressive Power of\n  Differential Ghosts", "comments": "LICS '18: 33rd Annual ACM/IEEE Symposium on Logic in Computer\n  Science, July 9-12, 2018, Oxford, United Kingdom, ACM ISBN\n  978-1-4503-5583-4/18/07", "journal-ref": null, "doi": "10.1145/3209108.3209147", "report-no": "CMU-CS-17-117", "categories": "cs.LO cs.PL math.CA math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove the completeness of an axiomatization for differential equation\ninvariants. First, we show that the differential equation axioms in\ndifferential dynamic logic are complete for all algebraic invariants. Our proof\nexploits differential ghosts, which introduce additional variables that can be\nchosen to evolve freely along new differential equations. Cleverly chosen\ndifferential ghosts are the proof-theoretical counterpart of dark matter. They\ncreate new hypothetical state, whose relationship to the original state\nvariables satisfies invariants that did not exist before. The reflection of\nthese new invariants in the original system then enables its analysis.\n  We then show that extending the axiomatization with existence and uniqueness\naxioms makes it complete for all local progress properties, and further\nextension with a real induction axiom makes it complete for all real arithmetic\ninvariants. This yields a parsimonious axiomatization, which serves as the\nlogical foundation for reasoning about invariants of differential equations.\nMoreover, our results are purely axiomatic, and so the axiomatization is\nsuitable for sound implementation in foundational theorem provers.\n", "versions": [{"version": "v1", "created": "Mon, 5 Feb 2018 00:54:36 GMT"}, {"version": "v2", "created": "Tue, 1 May 2018 03:38:14 GMT"}, {"version": "v3", "created": "Mon, 10 Jun 2019 22:02:09 GMT"}], "update_date": "2019-06-12", "authors_parsed": [["Platzer", "Andr\u00e9", ""], ["Tan", "Yong Kiam", ""]]}, {"id": "1802.01318", "submitter": "Emanuel Kieronski", "authors": "Daniel Danielski, Emanuel Kieronski", "title": "Unary negation fragment with equivalence relations has the finite model\n  property", "comments": "Extended version of LICS'18 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider an extension of the unary negation fragment of first-order logic\nin which arbitrarily many binary symbols may be required to be interpreted as\nequivalence relations. We show that this extension has the finite model\nproperty. More specifically, we show that every satisfiable formula has a model\nof at most doubly exponential size. We argue that the satisfiability (= finite\nsatisfiability) problem for this logic is TwoExpTime-complete. We also transfer\nour results to a restricted variant of the guarded negation fragment with\nequivalence relations.\n", "versions": [{"version": "v1", "created": "Mon, 5 Feb 2018 10:02:25 GMT"}, {"version": "v2", "created": "Thu, 13 Sep 2018 13:25:56 GMT"}], "update_date": "2018-09-14", "authors_parsed": [["Danielski", "Daniel", ""], ["Kieronski", "Emanuel", ""]]}, {"id": "1802.01336", "submitter": "Bohua Zhan", "authors": "Bohua Zhan and Maximilian P. L. Haslbeck", "title": "Verifying Asymptotic Time Complexity of Imperative Programs in Isabelle", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a framework in Isabelle for verifying asymptotic time complexity\nof imperative programs. We build upon an extension of Imperative HOL and its\nseparation logic to include running time. In addition to the basic arguments,\nour framework is able to handle advanced techniques for time complexity\nanalysis, such as the use of the Akra-Bazzi theorem and amortized analysis.\nVarious automation is built and incorporated into the auto2 prover to reason\nabout separation logic with time credits, and to derive asymptotic behavior of\nfunctions. As case studies, we verify the asymptotic time complexity (in\naddition to functional correctness) of imperative algorithms and data\nstructures such as median of medians selection, Karatsuba's algorithm, and\nsplay trees.\n", "versions": [{"version": "v1", "created": "Mon, 5 Feb 2018 10:32:35 GMT"}], "update_date": "2018-02-06", "authors_parsed": [["Zhan", "Bohua", ""], ["Haslbeck", "Maximilian P. L.", ""]]}, {"id": "1802.01355", "submitter": "Thorsten Wissmann", "authors": "Vasco Brattka", "title": "A Galois connection between Turing jumps and limits", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 14, Issue 3,\n  Computability and logic (August 31, 2018) lmcs:4794", "doi": "10.23638/LMCS-14(3:13)2018", "report-no": null, "categories": "math.LO cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Limit computable functions can be characterized by Turing jumps on the input\nside or limits on the output side. As a monad of this pair of adjoint\noperations we obtain a problem that characterizes the low functions and dually\nto this another problem that characterizes the functions that are computable\nrelative to the halting problem. Correspondingly, these two classes are the\nlargest classes of functions that can be pre or post composed to limit\ncomputable functions without leaving the class of limit computable functions.\nWe transfer these observations to the lattice of represented spaces where it\nleads to a formal Galois connection. We also formulate a version of this result\nfor computable metric spaces. Limit computability and computability relative to\nthe halting problem are notions that coincide for points and sequences, but\neven restricted to continuous functions the former class is strictly larger\nthan the latter. On computable metric spaces we can characterize the functions\nthat are computable relative to the halting problem as those functions that are\nlimit computable with a modulus of continuity that is computable relative to\nthe halting problem. As a consequence of this result we obtain, for instance,\nthat Lipschitz continuous functions that are limit computable are automatically\ncomputable relative to the halting problem. We also discuss 1-generic points as\nthe canonical points of continuity of limit computable functions, and we prove\nthat restricted to these points limit computable functions are computable\nrelative to the halting problem. Finally, we demonstrate how these results can\nbe applied in computable analysis.\n", "versions": [{"version": "v1", "created": "Mon, 5 Feb 2018 11:27:51 GMT"}, {"version": "v2", "created": "Wed, 22 Aug 2018 15:16:49 GMT"}, {"version": "v3", "created": "Thu, 30 Aug 2018 12:08:45 GMT"}], "update_date": "2018-09-07", "authors_parsed": [["Brattka", "Vasco", ""]]}, {"id": "1802.01453", "submitter": "Ramanujan M. S.", "authors": "Daniel Lokshtanov, M. S. Ramanujan, Saket Saurabh and Meirav Zehavi", "title": "Reducing CMSO Model Checking to Highly Connected Graphs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a Counting Monadic Second Order (CMSO) sentence $\\psi$, the\nCMSO$[\\psi]$ problem is defined as follows. The input to CMSO$[\\psi]$ is a\ngraph $G$, and the objective is to determine whether $G\\models \\psi$. Our main\ntheorem states that for every CMSO sentence $\\psi$, if CMSO$[\\psi]$ is solvable\nin polynomial time on \"globally highly connected graphs\", then CMSO$[\\psi]$ is\nsolvable in polynomial time (on general graphs). We demonstrate the utility of\nour theorem in the design of parameterized algorithms. Specifically we show\nthat technical problem-specific ingredients of a powerful method for designing\nparameterized algorithms, recursive understanding, can be replaced by a\nblack-box invocation of our main theorem. We also show that our theorem can be\neasily deployed to show fixed parameterized tractability of a wide range of\nproblems, where the input is a graph $G$ and the task is to find a connected\ninduced subgraph of $G$ such that \"few\" vertices in this subgraph have\nneighbors outside the subgraph, and additionally the subgraph has a\nCMSO-definable property.\n", "versions": [{"version": "v1", "created": "Mon, 5 Feb 2018 15:06:32 GMT"}], "update_date": "2018-02-06", "authors_parsed": [["Lokshtanov", "Daniel", ""], ["Ramanujan", "M. S.", ""], ["Saurabh", "Saket", ""], ["Zehavi", "Meirav", ""]]}, {"id": "1802.01790", "submitter": "EPTCS", "authors": "Davide Ancona, Luca Franceschini, Giorgio Delzanno, Maurizio Leotta,\n  Marina Ribaudo, Filippo Ricca", "title": "Towards Runtime Monitoring of Node.js and Its Application to the\n  Internet of Things", "comments": "In Proceedings ALP4IoT 2017, arXiv:1802.00976", "journal-ref": "EPTCS 264, 2018, pp. 27-42", "doi": "10.4204/EPTCS.264.4", "report-no": null, "categories": "cs.PL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the last years Node.js has emerged as a framework particularly suitable\nfor implementing lightweight IoT applications, thanks to its underlying\nasynchronous event-driven, non blocking I/O model. However, verifying the\ncorrectness of programs with asynchronous nested callbacks is quite difficult,\nand, hence, runtime monitoring can be a valuable support to tackle such a\ncomplex task.\n  Runtime monitoring is a useful software verification technique that\ncomplements static analysis and testing, but has not been yet fully explored in\nthe context of Internet of Things (IoT) systems. Trace expressions have been\nsuccessfully employed for runtime monitoring in widespread multiagent system\nplatforms. Recently, their expressive power has been extended to allow\nparametric specifications on data that can be captured and monitored only at\nruntime. Furthermore, they can be language and system agnostic, through the\nnotion of event domain and type. This paper investigates the use of parametric\ntrace expressions as a first step towards runtime monitoring of programs\ndeveloped in Node.js and Node-RED, a flow-based IoT programming tool built on\ntop of Node.js. Runtime verification of such systems is a task that mostly\nseems to have been overlooked so far in the literature.\n  A prototype implementing the proposed system for Node.js, in order to\ndynamically check with trace expressions the correct usage of API functions, is\npresented. The tool exploits the dynamic analysis framework Jalangi for\nmonitoring Node.js programs and allows detection of errors that would be\ndifficult to catch with other techniques. Furthermore, it offers a simple REST\ninterface which can be exploited for runtime verification of Node-RED\ncomponents, and, more generally, IoT devices.\n", "versions": [{"version": "v1", "created": "Tue, 6 Feb 2018 04:10:13 GMT"}], "update_date": "2018-02-07", "authors_parsed": [["Ancona", "Davide", ""], ["Franceschini", "Luca", ""], ["Delzanno", "Giorgio", ""], ["Leotta", "Maurizio", ""], ["Ribaudo", "Marina", ""], ["Ricca", "Filippo", ""]]}, {"id": "1802.01791", "submitter": "EPTCS", "authors": "Sven Linker (1), Michele Sevegnani (2) ((1) University of Liverpool,\n  (2) University of Glasgow)", "title": "Formalising Sensor Topologies for Target Counting", "comments": "In Proceedings ALP4IoT 2017, arXiv:1802.00976", "journal-ref": "EPTCS 264, 2018, pp. 43-57", "doi": "10.4204/EPTCS.264.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a formal model developed to reason about topologies created by\nsensor ranges. This model is used to formalise the topological aspects of an\nexisting counting algorithm to estimate the number of targets in the area\ncovered by the sensors. To that end, we present a first-order logic tailored to\nspecify relations between parts of the space with respect to sensor coverage.\nThe logic serves as a specification language for Hoare-style proofs of\ncorrectness of the topological computations of the algorithm, which uncovers\nambiguities in their results. Subsequently, we extend the formal model as a\nstep towards improving the estimation of the algorithm. Finally, we sketch how\nthe model can be extended to take mobile sensors and temporal aspects into\naccount.\n", "versions": [{"version": "v1", "created": "Tue, 6 Feb 2018 04:10:29 GMT"}], "update_date": "2018-02-07", "authors_parsed": [["Linker", "Sven", ""], ["Sevegnani", "Michele", ""]]}, {"id": "1802.01810", "submitter": "Amaury Pouly", "authors": "Ehud Hrushovski, Jo\\\"el Ouaknine, Amaury Pouly, James Worrell", "title": "Polynomial Invariants for Affine Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DM math.AG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We exhibit an algorithm to compute the strongest polynomial (or algebraic)\ninvariants that hold at each location of a given affine program (i.e., a\nprogram having only non-deterministic (as opposed to conditional) branching and\nall of whose assignments are given by affine expressions). Our main tool is an\nalgebraic result of independent interest: given a finite set of rational square\nmatrices of the same dimension, we show how to compute the Zariski closure of\nthe semigroup that they generate.\n", "versions": [{"version": "v1", "created": "Tue, 6 Feb 2018 06:14:19 GMT"}, {"version": "v2", "created": "Wed, 2 May 2018 10:05:06 GMT"}], "update_date": "2018-05-03", "authors_parsed": [["Hrushovski", "Ehud", ""], ["Ouaknine", "Jo\u00ebl", ""], ["Pouly", "Amaury", ""], ["Worrell", "James", ""]]}, {"id": "1802.01866", "submitter": "Brijesh Dongol", "authors": "Simon Doherty, John Derrick, Brijesh Dongol, Heike Wehrheim", "title": "Causal Linearizability: Compositionality for Partially Ordered\n  Executions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the interleaving model of concurrency, where events are totally ordered,\nlinearizability is compositional: the composition of two linearizable objects\nis guaranteed to be linearizable. However, linearizability is not compositional\nwhen events are only partially ordered, as in many weak-memory models that\ndescribe multicore memory systems. In this paper, we present causal\nlinearizability, a correctness condition for concurrent objects implemented in\nweak-memory models. We abstract from the details of specific memory models by\ndefining our condition using Lamport's execution structures. We apply our\ncondition to the C11 memory model, providing a correctness condition for C11\nobjects. We develop a proof method for verifying objects implemented in C11 and\nrelated models. Our method is an adaptation of simulation-based methods, but in\ncontrast to other such methods, it does not require that the implementation\ntotally order its events. We also show that causal linearizability reduces to\nlinearizability in the totally ordered case.\n", "versions": [{"version": "v1", "created": "Tue, 6 Feb 2018 09:57:58 GMT"}], "update_date": "2018-02-07", "authors_parsed": [["Doherty", "Simon", ""], ["Derrick", "John", ""], ["Dongol", "Brijesh", ""], ["Wehrheim", "Heike", ""]]}, {"id": "1802.01910", "submitter": "Anton A. Kutsenko", "authors": "Anton Kutsenko", "title": "Programming infinite machines", "comments": "This is a preliminary version, some statements are not strict and are\n  subject to discussion", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For infinite machines which are free from the classical Thompson's lamp\nparadox we show that they are not free from its inverted version. We provide a\nprogram for infinite machines and an infinite mechanism which simulate this\nparadox. While their finite analogs work predictably, the program and the\ninfinite mechanism demonstrate an undefined behavior. As in the case of\ninfinite Davies's machines, our examples are free from infinite masses,\ninfinite velocities, infinite forces, etc. Only infinite divisibility of space\nand timeis assumed. Thus, the considered infinite devices are possible in a\ncontinuous Newtonian Universe and they do not conflict with continuous\nNewtonian mechanics. Some possible applications to the analysis of the\nNavier-Stokes equations are discussed.\n", "versions": [{"version": "v1", "created": "Tue, 6 Feb 2018 12:40:06 GMT"}], "update_date": "2018-02-07", "authors_parsed": [["Kutsenko", "Anton", ""]]}, {"id": "1802.02087", "submitter": "Xiang Yin", "authors": "Tomas Masopust and Xiang Yin", "title": "Deciding Detectability for Labeled Petri Nets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Detectability of discrete event systems (DESs) is a property to determine a\npriori whether the current and subsequent states can be determined based on\nobservations. In this paper, we investigate the verification of two\ndetectability properties -- strong detectability and weak detectability -- for\nDESs modeled by labeled Petri nets. Strong detectability requires that we can\nalways determine, after a finite number of observations, the current and\nsubsequent markings of the system, while weak detectability requires that we\ncan determine, after a finite number of observations, the current and\nsubsequent markings for some trajectories of the system. We show that for DESs\nmodeled by labeled Petri nets, checking strong detectability is decidable\nwhereas checking weak detectability is undecidable. Our results extend the\nexisting studies on the verification of detectability from finite-state\nautomata to labeled Petri nets. As a consequence, we strengthen a result on\nchecking current-state opacity for labeled Petri nets.\n", "versions": [{"version": "v1", "created": "Tue, 6 Feb 2018 17:41:26 GMT"}, {"version": "v2", "created": "Thu, 29 Nov 2018 12:05:48 GMT"}], "update_date": "2018-11-30", "authors_parsed": [["Masopust", "Tomas", ""], ["Yin", "Xiang", ""]]}, {"id": "1802.02143", "submitter": "Oleg Verbitsky", "authors": "Oleg Verbitsky and Maksim Zhukovskii", "title": "Tight Bounds on the Asymptotic Descriptive Complexity of Subgraph\n  Isomorphism", "comments": "22 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let $v(F)$ denote the number of vertices in a fixed connected pattern graph\n$F$. We show an infinite family of patterns $F$ such that the existence of a\nsubgraph isomorphic to $F$ is expressible by a first-order sentence of\nquantifier depth $\\frac23\\,v(F)+1$, assuming that the host graph is\nsufficiently large and connected. On the other hand, this is impossible for any\n$F$ with using less than $\\frac23\\,v(F)-2$ first-order variables.\n", "versions": [{"version": "v1", "created": "Tue, 6 Feb 2018 09:29:13 GMT"}], "update_date": "2018-02-08", "authors_parsed": [["Verbitsky", "Oleg", ""], ["Zhukovskii", "Maksim", ""]]}, {"id": "1802.02191", "submitter": "Kuen-Bang Hou (Favonia)", "authors": "Ulrik Buchholtz, Kuen-Bang Hou (Favonia)", "title": "Cellular Cohomology in Homotopy Type Theory", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 2 (June 1,\n  2020) lmcs:6518", "doi": "10.23638/LMCS-16(2:7)2020", "report-no": null, "categories": "cs.LO math.AT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present a development of cellular cohomology in homotopy type theory.\nCohomology associates to each space a sequence of abelian groups capturing part\nof its structure, and has the advantage over homotopy groups in that these\nabelian groups of many common spaces are easier to compute. Cellular cohomology\nis a special kind of cohomology designed for cell complexes: these are built in\nstages by attaching spheres of progressively higher dimension, and cellular\ncohomology defines the groups out of the combinatorial description of how\nspheres are attached. Our main result is that for finite cell complexes, a wide\nclass of cohomology theories (including the ones defined through\nEilenberg-MacLane spaces) can be calculated via cellular cohomology. This\nresult was formalized in the Agda proof assistant.\n", "versions": [{"version": "v1", "created": "Tue, 6 Feb 2018 20:06:39 GMT"}, {"version": "v2", "created": "Sat, 9 Mar 2019 23:06:15 GMT"}, {"version": "v3", "created": "Tue, 17 Dec 2019 19:20:07 GMT"}, {"version": "v4", "created": "Fri, 29 May 2020 11:24:09 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Buchholtz", "Ulrik", "", "Favonia"], ["Hou", "Kuen-Bang", "", "Favonia"]]}, {"id": "1802.02291", "submitter": "Jie Fan", "authors": "Jie Fan", "title": "Neighborhood Contingency Logic: A New Perspective", "comments": "17 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we propose a new neighborhood semantics for contingency logic,\nby introducing a simple property in standard neighborhood models. This\nsimplifies the neighborhood semantics given in (Fan and van Ditmarsch, 2015),\nbut does not change the set of valid formulas. Under this perspective, among\nvarious notions of bisimulation and respective Hennessy-Milner Theorems, we\nshow that $c$-bisimulation is equivalent to nbh-$\\Delta$-bisimulation in the\nliterature, which guides us to understand the essence of the latter notion.\nThis perspective also provides various frame definability and axiomatization\nresults.\n", "versions": [{"version": "v1", "created": "Wed, 7 Feb 2018 02:26:36 GMT"}], "update_date": "2018-02-08", "authors_parsed": [["Fan", "Jie", ""]]}, {"id": "1802.02388", "submitter": "Albert Atserias", "authors": "Albert Atserias and Joanna Ochremiak", "title": "Definable Ellipsoid Method, Sums-of-Squares Proofs, and the Isomorphism\n  Problem", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The ellipsoid method is an algorithm that solves the (weak) feasibility and\nlinear optimization problems for convex sets by making oracle calls to their\n(weak) separation problem. We observe that the previously known method for\nshowing that this reduction can be done in fixed-point logic with counting\n(FPC) for linear and semidefinite programs applies to any family of explicitly\nbounded convex sets. We use this observation to show that the exact feasibility\nproblem for semidefinite programs is expressible in the infinitary version of\nFPC. As a corollary we get that, for the isomorphism problem, the\nLasserre/Sums-of-Squares semidefinite programming hierarchy of relaxations\ncollapses to the Sherali-Adams linear programming hierarchy, up to a small loss\nin the degree.\n", "versions": [{"version": "v1", "created": "Wed, 7 Feb 2018 11:27:23 GMT"}], "update_date": "2018-02-08", "authors_parsed": [["Atserias", "Albert", ""], ["Ochremiak", "Joanna", ""]]}, {"id": "1802.02514", "submitter": "Shankara Narayanan Krishna", "authors": "Shankara Narayanan Krishna, Khushraj Madnani and Paritosh Pandya", "title": "B\\\"uchi-Kamp Theorems for 1-clock ATA", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper investigates Kamp-like and B\\\"uchi-like theorems for 1-clock\nAlternating Timed Automata (1-ATA) and its natural subclasses. A notion of\n1-ATA with loop-free-resets is defined. This automaton class is shown to be\nexpressively equivalent to the temporal logic $\\regmtl$ which is\n$\\mathsf{MTL[F_I]}$ extended with a regular expression guarded modality.\nMoreover, a subclass of future timed MSO with k-variable-connectivity property\nis introduced as logic $\\qkmso$. In a Kamp-like result, it is shown that\n$\\regmtl$ is expressively equivalent to $\\qkmso$. As our second result, we\ndefine a notion of conjunctive-disjunctive 1-clock ATA ($\\wf$ 1-ATA). We show\nthat $\\wf$ 1-ATA with loop-free-resets are expressively equivalent to the\nsublogic $\\F\\regmtl$ of $\\regmtl$. Moreover $\\F\\regmtl$ is expressively\nequivalent to $\\qtwomso$, the two-variable connected fragment of $\\qkmso$. The\nfull class of 1-ATA is shown to be expressively equivalent to $\\regmtl$\nextended with fixed point operators.\n", "versions": [{"version": "v1", "created": "Tue, 6 Feb 2018 13:16:55 GMT"}], "update_date": "2018-02-08", "authors_parsed": [["Krishna", "Shankara Narayanan", ""], ["Madnani", "Khushraj", ""], ["Pandya", "Paritosh", ""]]}, {"id": "1802.02685", "submitter": "Alfons Laarman", "authors": "Alfons Laarman", "title": "Stubborn Transaction Reduction (with Proofs)", "comments": "24 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The exponential explosion of parallel interleavings remains a fundamental\nchallenge to model checking of concurrent programs. Both partial-order\nreduction (POR) and transaction reduction (TR) decrease the number of\ninterleavings in a concurrent system. Unlike POR, transactions also reduce the\nnumber of intermediate states. Modern POR techniques, on the other hand, offer\nmore dynamic ways of identifying commutative behavior, a crucial task for\nobtaining good reductions.\n  We show that transaction reduction can use the same dynamic commutativity as\nfound in stubborn set POR. We also compare reductions obtained by POR and TR,\ndemonstrating with several examples that these techniques complement each\nother.\n  With an implementation of the dynamic transactions in the model checker\nLTSmin, we compare its effectiveness with the original static TR and two POR\napproaches. Several inputs, including realistic case studies, demonstrate that\nthe new dynamic TR can surpass POR in practice.\n", "versions": [{"version": "v1", "created": "Thu, 8 Feb 2018 01:24:26 GMT"}], "update_date": "2018-02-09", "authors_parsed": [["Laarman", "Alfons", ""]]}, {"id": "1802.02732", "submitter": "Christoph Benzm\\\"uller", "authors": "Alexander Steen and Christoph Benzm\\\"uller", "title": "The Higher-Order Prover Leo-III (Extended Version)", "comments": "13 pages (this is an extended version of the IJCAR 2018 paper)", "journal-ref": "9th International Joint Conference on Automated Reasoning, IJCAR\n  2018, Oxford, UK, July 14-17, 2018, Proceedings, Springer", "doi": null, "report-no": null, "categories": "cs.AI cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The automated theorem prover Leo-III for classical higher-order logic with\nHenkin semantics and choice is presented. Leo-III is based on extensional\nhigher-order paramodulation and accepts every common TPTP dialect (FOF, TFF,\nTHF), including their recent extensions to rank-1 polymorphism (TF1, TH1). In\naddition, the prover natively supports almost every normal higher-order modal\nlogic. Leo-III cooperates with first-order reasoning tools using translations\nto many-sorted first-order logic and produces verifiable proof certificates.\nThe prover is evaluated on heterogeneous benchmark sets.\n", "versions": [{"version": "v1", "created": "Thu, 8 Feb 2018 07:48:31 GMT"}, {"version": "v2", "created": "Thu, 19 Apr 2018 11:45:07 GMT"}], "update_date": "2018-04-20", "authors_parsed": [["Steen", "Alexander", ""], ["Benzm\u00fcller", "Christoph", ""]]}, {"id": "1802.02820", "submitter": "Sam Speight", "authors": "Steve Awodey, Jonas Frey and Sam Speight", "title": "Impredicative Encodings of (Higher) Inductive Types", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Postulating an impredicative universe in dependent type theory allows System\nF style encodings of finitary inductive types, but these fail to satisfy the\nrelevant {\\eta}-equalities and consequently do not admit dependent eliminators.\nTo recover {\\eta} and dependent elimination, we present a method to construct\nrefinements of these impredicative encodings, using ideas from homotopy type\ntheory. We then extend our method to construct impredicative encodings of some\nhigher inductive types, such as 1-truncation and the unit circle S1.\n", "versions": [{"version": "v1", "created": "Thu, 8 Feb 2018 12:22:17 GMT"}], "update_date": "2018-02-09", "authors_parsed": [["Awodey", "Steve", ""], ["Frey", "Jonas", ""], ["Speight", "Sam", ""]]}, {"id": "1802.02917", "submitter": "Fabrizio Montesi", "authors": "Fabrizio Montesi", "title": "Classical Higher-Order Processes", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Classical Processes (CP) is a calculus where the proof theory of classical\nlinear logic types communicating processes with mobile channels, a la\npi-calculus. Its construction builds on a recent propositions as types\ncorrespondence between session types and propositions in linear logic.\nDesirable properties such as type preservation under reductions and progress\ncome for free from the metatheory of linear logic.\n  We contribute to this research line by extending CP with code mobility. We\ngeneralise classical linear logic to capture higher-order (linear) reasoning on\nproofs, which yields a logical reconstruction of (a variant of) the\nHigher-Order pi-calculus (HOpi). The resulting calculus is called Classical\nHigher-Order Processes (CHOP). We explore the metatheory of CHOP, proving that\nits semantics enjoys type preservation and progress (terms do not get stuck).\nWe also illustrate the expressivity of CHOP through examples, derivable syntax\nsugar, and an extension to multiparty sessions. Lastly, we define a translation\nfrom CHOP to CP, which encodes mobility of process code into reference passing.\n", "versions": [{"version": "v1", "created": "Thu, 8 Feb 2018 15:21:22 GMT"}], "update_date": "2018-02-09", "authors_parsed": [["Montesi", "Fabrizio", ""]]}, {"id": "1802.02951", "submitter": "Joseph Tassarotti", "authors": "Joseph Tassarotti, Robert Harper", "title": "A Separation Logic for Concurrent Randomized Programs", "comments": "31 pages. Extended version of POPL 2019 paper", "journal-ref": "Proc. ACM Program. Lang. 3, POPL, Article 64 (January 2019)", "doi": "10.1145/3290377", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present Polaris, a concurrent separation logic with support for\nprobabilistic reasoning. As part of our logic, we extend the idea of coupling,\nwhich underlies recent work on probabilistic relational logics, to the setting\nof programs with both probabilistic and non-deterministic choice. To\ndemonstrate Polaris, we verify a variant of a randomized concurrent counter\nalgorithm and a two-level concurrent skip list. All of our results have been\nmechanized in Coq.\n", "versions": [{"version": "v1", "created": "Thu, 8 Feb 2018 16:29:43 GMT"}, {"version": "v2", "created": "Wed, 21 Nov 2018 16:12:53 GMT"}], "update_date": "2018-11-22", "authors_parsed": [["Tassarotti", "Joseph", ""], ["Harper", "Robert", ""]]}, {"id": "1802.03080", "submitter": "Alberto Speranzon", "authors": "Alberto Speranzon and David I. Spivak and Srivatsan Varadarajan", "title": "Abstraction, Composition and Contracts: A Sheaf Theoretic Approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Complex systems of systems (SoS) are characterized by multiple interconnected\nsubsystems. Typically, each subsystem is designed and analyzed using\nmethodologies and formalisms that are specific to the particular subsystem\nmodel of computation considered --- Petri nets, continuous time ODEs,\nnondeterministic automata, to name a few. When interconnecting subsystems, a\ndesigner needs to choose, based on the specific subsystems models, a common\nabstraction framework to analyze the composition. In this paper we introduce a\nnew framework for abstraction, composition and analysis of SoS that builds on\nresults and methods developed in sheaf theory, category theory and topos\ntheory. In particular, we will be modeling behaviors of systems using sheaves,\nleverage category theoretic methods to define wiring diagrams and formalize\ncomposition and, by establishing a connection with topos theory, define a\nformal (intuitionistic/constructive) logic with a sound sheaf semantics\n", "versions": [{"version": "v1", "created": "Thu, 8 Feb 2018 23:52:54 GMT"}], "update_date": "2018-02-12", "authors_parsed": [["Speranzon", "Alberto", ""], ["Spivak", "David I.", ""], ["Varadarajan", "Srivatsan", ""]]}, {"id": "1802.03115", "submitter": "Daniel Leivant", "authors": "Daniel Leivant and Jean-Yves Marion", "title": "Implicit complexity via structure transformation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Implicit computational complexity, which aims at characterizing complexity\nclasses by machine-independent means, has traditionally been based, on the one\nhand, on programs and deductive formalisms for free algebras, and on the other\nhand on descriptive tools for finite structures.\n  We consider here \"uninterpreted\" programs for the transformation of finite\nstructures, which define functions over a free algebra A once the elements of A\nare themselves considered as finite structures. We thus bridge the gap between\nthe two approaches above to implicit complexity, with the potential of\nstreamlining and clarifying important tools and techniques, such as\nset-existence and ramification.\n  We illustrate this potential by delineating a broad class of programs, based\non the notion of loop variant familiar from imperative program construction,\nthat characterizes a generic notion of primitive-recursive complexity, without\nreference to any data-driven recurrence.\n", "versions": [{"version": "v1", "created": "Fri, 9 Feb 2018 03:39:58 GMT"}], "update_date": "2018-02-12", "authors_parsed": [["Leivant", "Daniel", ""], ["Marion", "Jean-Yves", ""]]}, {"id": "1802.03188", "submitter": "Dominique Unruh", "authors": "Dominique Unruh", "title": "Quantum Relational Hoare Logic", "comments": "Extended abstract appeared at POPL 2019", "journal-ref": "Proc. ACM Program. Lang. 3 (Jan. 2019). Pages 33:1-33:31", "doi": "10.1145/3290346", "report-no": null, "categories": "quant-ph cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present a logic for reasoning about pairs of interactive quantum programs\n- quantum relational Hoare logic (qRHL). This logic follows the spirit of\nprobabilistic relational Hoare logic (Barthe et al. 2009) and allows us to\nformulate how the outputs of two quantum programs relate given the relationship\nof their inputs. Probabilistic RHL was used extensively for computer-verified\nsecurity proofs of classical cryptographic protocols. Since pRHL is not\nsuitable for analyzing quantum cryptography, we present qRHL as a replacement,\nsuitable for the security analysis of post-quantum cryptography and quantum\nprotocols. The design of qRHL poses some challenges unique to the quantum\nsetting, e.g., the definition of equality on quantum registers. Finally, we\nimplemented a tool for verifying proofs in qRHL and developed several example\nsecurity proofs in it.\n", "versions": [{"version": "v1", "created": "Fri, 9 Feb 2018 10:21:53 GMT"}, {"version": "v2", "created": "Mon, 14 Jan 2019 21:55:30 GMT"}], "update_date": "2019-01-16", "authors_parsed": [["Unruh", "Dominique", ""]]}, {"id": "1802.03224", "submitter": "Dominic Hughes", "authors": "Dominic J. D. Hughes", "title": "Unification nets: canonical proof net quantifiers", "comments": "34 pages, 11 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Proof nets for MLL (unit-free Multiplicative Linear Logic) are concise\ngraphical representations of proofs which are canonical in the sense that they\nabstract away syntactic redundancy such as the order of non-interacting rules.\nWe argue that Girard's extension to MLL1 (first-order MLL) fails to be\ncanonical because of redundant existential witnesses, and present canonical\nMLL1 proof nets called unification nets without them. For example, while there\nare infinitely many cut-free Girard nets $\\forall x Px \\vdash \\exists xPx$, one\nper arbitrary choice of witness for $\\exists x$, there is a unique cut-free\nunification net, with no specified witness.\n  Redundant existential witnesses cause Girard's MLL1 nets to suffer from\nsevere complexity issues: (1) cut elimination is non-local and exponential-time\n(and -space), and (2) some sequents require exponentially large cut-free Girard\nnets. Unification nets solve both problems: (1) cut elimination is local and\nlinear-time, and (2) cut-free unification nets grow linearly with the size of\nthe sequent. Since some unification nets are exponentially smaller than\ncorresponding Girard nets and sequent proofs, technical delicacy is required to\nensure correctness is polynomial-time (quadratic).\n  These results extend beyond MLL1 via a broader methodological insight: for\ncanonical quantifiers, the standard parallel/sequential dichotomy of proof nets\nfails; an implicit/explicit witness dichotomy is also needed. Work in progress\nextends unification nets to additives and uses them to extend combinatorial\nproofs [Proofs without syntax, Annals of Mathematics, 2006] to classical\nfirst-order logic.\n", "versions": [{"version": "v1", "created": "Fri, 9 Feb 2018 12:18:56 GMT"}], "update_date": "2018-02-12", "authors_parsed": [["Hughes", "Dominic J. D.", ""]]}, {"id": "1802.03255", "submitter": "Antoine Mottet", "authors": "Manuel Bodirsky, Florent Madelaine, Antoine Mottet", "title": "A universal-algebraic proof of the complexity dichotomy for Monotone\n  Monadic SNP", "comments": "A long version of an extended abstract that appeared in LICS 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO math.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  The logic MMSNP is a restricted fragment of existential second-order logic\nwhich allows to express many interesting queries in graph theory and finite\nmodel theory. The logic was introduced by Feder and Vardi who showed that every\nMMSNP sentence is computationally equivalent to a finite-domain constraint\nsatisfaction problem (CSP); the involved probabilistic reductions were\nderandomized by Kun using explicit constructions of expander structures. We\npresent a new proof of the reduction to finite-domain CSPs which does not rely\non the results of Kun. This new proof allows us to obtain a stronger statement\nand to verify the more general Bodirsky-Pinsker dichotomy conjecture for CSPs\nin MMSNP. Our approach uses the fact that every MMSNP sentence describes a\nfinite union of CSPs for countably infinite $\\omega$-categorical structures;\nmoreover, by a recent result of Hubi\\v{c}ka and Ne\\v{s}et\\v{r}il, these\nstructures can be expanded to homogeneous structures with finite relational\nsignature and the Ramsey property. This allows us to use the\nuniversal-algebraic approach to study the computational complexity of MMSNP.\n", "versions": [{"version": "v1", "created": "Fri, 9 Feb 2018 13:41:24 GMT"}, {"version": "v2", "created": "Wed, 16 May 2018 09:17:26 GMT"}, {"version": "v3", "created": "Tue, 17 Jul 2018 06:28:46 GMT"}, {"version": "v4", "created": "Wed, 25 Nov 2020 10:57:27 GMT"}], "update_date": "2020-11-26", "authors_parsed": [["Bodirsky", "Manuel", ""], ["Madelaine", "Florent", ""], ["Mottet", "Antoine", ""]]}, {"id": "1802.03292", "submitter": "Assaf Kfoury", "authors": "Assaf Kfoury", "title": "Mathematical Logic in Computer Science", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The article retraces major events and milestones in the mutual influences\nbetween mathematical logic and computer science since the 1950s.\n", "versions": [{"version": "v1", "created": "Wed, 7 Feb 2018 22:21:43 GMT"}], "update_date": "2018-02-12", "authors_parsed": [["Kfoury", "Assaf", ""]]}, {"id": "1802.03321", "submitter": "Kuize Zhang", "authors": "Kuize Zhang, Xiang Yin, Majid Zamani", "title": "Opacity of nondeterministic transition systems: A (bi)simulation\n  relation approach", "comments": "21 pages, partially presented at IEEE CDC 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we propose several opacity-preserving (bi)simulation relations\nfor general nondeterministic transition systems (NTS) in terms of initial-state\nopacity, current-state opacity, K-step opacity, and infinite-step opacity. We\nalso show how one can leverage quotient construction to compute such relations.\nIn addition, we use a two-way observer method to verify opacity of\nnondeterministic finite transition systems (NFTSs). As a result, although the\nverification of opacity for infinite NTSs is generally undecidable, if one can\nfind such an opacity-preserving relation from an infinite NTS to an NFTS, the\n(lack of) opacity of the NTS can be easily verified over the NFTS which is\ndecidable.\n", "versions": [{"version": "v1", "created": "Fri, 9 Feb 2018 16:06:48 GMT"}, {"version": "v2", "created": "Thu, 13 Sep 2018 09:28:32 GMT"}], "update_date": "2018-09-14", "authors_parsed": [["Zhang", "Kuize", ""], ["Yin", "Xiang", ""], ["Zamani", "Majid", ""]]}, {"id": "1802.03336", "submitter": "Hugo Gimbert", "authors": "Hugo Gimbert", "title": "The Monadic Second Order Theory of Grid-Free 1-Safe Petri Nets is\n  Decidable", "comments": "Buggy proof", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Finite 1-safe Petri nets, also called \\emph{net systems}, are natural models\nof asynchronous concurrency. The event structure of a net system describes all\nits possible executions and their concurrent nature: two events may be causally\nordered, occur in parallel or be conflicting. Monadic second order logic (MSO)\ncan be used to specify behavioural properties of net systems. Thiagarajan's\nconjecture states that MSO is decidable if and only if the net system is\ngrid-free. The present paper gives a positive answer to this conjecture.\n", "versions": [{"version": "v1", "created": "Fri, 9 Feb 2018 16:38:46 GMT"}, {"version": "v2", "created": "Mon, 12 Feb 2018 14:02:19 GMT"}, {"version": "v3", "created": "Thu, 15 Feb 2018 08:13:33 GMT"}, {"version": "v4", "created": "Fri, 16 Feb 2018 07:37:58 GMT"}], "update_date": "2018-02-19", "authors_parsed": [["Gimbert", "Hugo", ""]]}, {"id": "1802.03375", "submitter": "Bartosz Piotrowski", "authors": "Bartosz Piotrowski, Josef Urban", "title": "ATPboost: Learning Premise Selection in Binary Setting with ATP Feedback", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  ATPboost is a system for solving sets of large-theory problems by\ninterleaving ATP runs with state-of-the-art machine learning of premise\nselection from the proofs. Unlike many previous approaches that use multi-label\nsetting, the learning is implemented as binary classification that estimates\nthe pairwise-relevance of (theorem, premise) pairs. ATPboost uses for this the\nXGBoost gradient boosting algorithm, which is fast and has state-of-the-art\nperformance on many tasks. Learning in the binary setting however requires\nnegative examples, which is nontrivial due to many alternative proofs. We\ndiscuss and implement several solutions in the context of the ATP/ML feedback\nloop, and show that ATPboost with such methods significantly outperforms the\nk-nearest neighbors multilabel classifier.\n", "versions": [{"version": "v1", "created": "Fri, 9 Feb 2018 18:29:26 GMT"}], "update_date": "2018-02-12", "authors_parsed": [["Piotrowski", "Bartosz", ""], ["Urban", "Josef", ""]]}, {"id": "1802.03381", "submitter": "Daniel Gall", "authors": "Daniel Gall and Thom Fr\\\"uhwirth", "title": "Confluence Modulo Equivalence with Invariants in Constraint Handling\n  Rules", "comments": "Accepted for the Fourteenth International Symposium on Functional and\n  Logic Programming (FLOPS 2018), 9-11 May, 2018, Nagoya, Japan", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Confluence denotes the property of a state transition system that states can\nbe rewritten in more than one way yielding the same result. Although it is a\ndesirable property, confluence is often too strict in practical applications\nbecause it also considers states that can never be reached in practice.\nAdditionally, sometimes states that have the same semantics in the practical\ncontext are considered as different states due to different syntactic\nrepresentations. By introducing suitable invariants and equivalence relations\non the states, programs may have the property to be confluent modulo the\nequivalence relation w.r.t. the invariant which often is desirable in practice.\n  In this paper, a sufficient and necessary criterion for confluence modulo\nequivalence w.r.t. an invariant for Constraint Handling Rules (CHR) is\npresented. It is the first approach that covers invariant-based confluence\nmodulo equivalence for the de facto standard semantics of CHR. There is a\ntrade-off between practical applicability and the simplicity of proving a\nconfluence property. Therefore, a better manageable subset of equivalence\nrelations has been identified that allows for the proposed confluence criterion\nand and simplifies the confluence proofs by using well established CHR analysis\nmethods.\n", "versions": [{"version": "v1", "created": "Fri, 9 Feb 2018 18:44:25 GMT"}], "update_date": "2018-02-12", "authors_parsed": [["Gall", "Daniel", ""], ["Fr\u00fchwirth", "Thom", ""]]}, {"id": "1802.03516", "submitter": "Jie Fan", "authors": "Jie Fan", "title": "A sequence of neighborhood contingency logics", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This note proposes various axiomatizations of contingency logic under\nneighborhood semantics. In particular, by defining a suitable canonical\nneighborhood function, we give sound and complete axiomatizations of monotone\ncontingency logic and regular contingency logic, thereby answering two open\nquestions raised by Bakhtiari, van Ditmarsch, and Hansen. The canonical\nfunction is inspired by a function proposed by Kuhn in 1995. We show that\nKuhn's function is actually equal to a related function originally given by\nHumberstone.\n", "versions": [{"version": "v1", "created": "Sat, 10 Feb 2018 04:02:30 GMT"}], "update_date": "2018-02-13", "authors_parsed": [["Fan", "Jie", ""]]}, {"id": "1802.03685", "submitter": "Daniel Selsam", "authors": "Daniel Selsam, Matthew Lamm, Benedikt B\\\"unz, Percy Liang, Leonardo de\n  Moura, David L. Dill", "title": "Learning a SAT Solver from Single-Bit Supervision", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present NeuroSAT, a message passing neural network that learns to solve\nSAT problems after only being trained as a classifier to predict\nsatisfiability. Although it is not competitive with state-of-the-art SAT\nsolvers, NeuroSAT can solve problems that are substantially larger and more\ndifficult than it ever saw during training by simply running for more\niterations. Moreover, NeuroSAT generalizes to novel distributions; after\ntraining only on random SAT problems, at test time it can solve SAT problems\nencoding graph coloring, clique detection, dominating set, and vertex cover\nproblems, all on a range of distributions over small random graphs.\n", "versions": [{"version": "v1", "created": "Sun, 11 Feb 2018 03:04:28 GMT"}, {"version": "v2", "created": "Tue, 13 Feb 2018 22:52:15 GMT"}, {"version": "v3", "created": "Sat, 5 Jan 2019 22:20:18 GMT"}, {"version": "v4", "created": "Tue, 12 Mar 2019 00:56:48 GMT"}], "update_date": "2019-03-13", "authors_parsed": [["Selsam", "Daniel", ""], ["Lamm", "Matthew", ""], ["B\u00fcnz", "Benedikt", ""], ["Liang", "Percy", ""], ["de Moura", "Leonardo", ""], ["Dill", "David L.", ""]]}, {"id": "1802.03716", "submitter": "Jie Fan", "authors": "Jie Fan", "title": "Bimodal logics with contingency and accident", "comments": "19 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Contingency and accident are two important notions in philosophy and\nphilosophical logic. Their meanings are so close that they are mixed sometimes,\nin both everyday discourse and academic research. This indicates that it is\nnecessary to study them in a unified framework. However, there has been no\nlogical research on them together. In this paper, we propose a language of a\nbimodal logic with these two concepts, investigate its model-theoretical\nproperties such as expressivity and frame definability. We axiomatize this\nlogic over various classes of frames, whose completeness proofs are shown with\nthe help of a crucial schema. The interactions between contingency and accident\ncan sharpen our understanding of both notions. Then we extend the logic to a\ndynamic case: public announcements. By finding the required reduction axioms,\nwe obtain a complete axiomatization, which gives us a good application to Moore\nsentences.\n", "versions": [{"version": "v1", "created": "Sun, 11 Feb 2018 09:09:58 GMT"}], "update_date": "2018-02-13", "authors_parsed": [["Fan", "Jie", ""]]}, {"id": "1802.03726", "submitter": "Ale\\v{s} Bizjak", "authors": "Paolo Baldan, Roberto Bruni, Andrea Corradini, Fabio Gadducci, Hernan\n  Melgratti, and Ugo Montanari", "title": "Event Structures for Petri nets with Persistence", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 14, Issue 3 (September\n  28, 2018) lmcs:4857", "doi": "10.23638/LMCS-14(3:25)2018", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Event structures are a well-accepted model of concurrency. In a seminal paper\nby Nielsen, Plotkin and Winskel, they are used to establish a bridge between\nthe theory of domains and the approach to concurrency proposed by Petri. A\nbasic role is played by an unfolding construction that maps (safe) Petri nets\ninto a subclass of event structures, called prime event structures, where each\nevent has a uniquely determined set of causes. Prime event structures, in turn,\ncan be identified with their domain of configurations. At a categorical level,\nthis is nicely formalised by Winskel as a chain of coreflections.\n  Contrary to prime event structures, general event structures allow for the\npresence of disjunctive causes, i.e., events can be enabled by distinct minimal\nsets of events. In this paper, we extend the connection between Petri nets and\nevent structures in order to include disjunctive causes. In particular, we show\nthat, at the level of nets, disjunctive causes are well accounted for by\npersistent places. These are places where tokens, once generated, can be used\nseveral times without being consumed and where multiple tokens are interpreted\ncollectively, i.e., their histories are inessential. Generalising the work on\nordinary nets, Petri nets with persistence are related to a new subclass of\ngeneral event structures, called locally connected, by means of a chain of\ncoreflections relying on an unfolding construction.\n", "versions": [{"version": "v1", "created": "Sun, 11 Feb 2018 11:29:34 GMT"}, {"version": "v2", "created": "Thu, 27 Sep 2018 08:54:06 GMT"}], "update_date": "2018-10-03", "authors_parsed": [["Baldan", "Paolo", ""], ["Bruni", "Roberto", ""], ["Corradini", "Andrea", ""], ["Gadducci", "Fabio", ""], ["Melgratti", "Hernan", ""], ["Montanari", "Ugo", ""]]}, {"id": "1802.03744", "submitter": "Rasmus M{\\o}gelberg", "authors": "Ale\\v{s} Bizjak and Rasmus Ejlers M{\\o}gelberg", "title": "Denotational semantics for guarded dependent type theory", "comments": "This is the third version of the paper representing a minor revision\n  over the second version. The paper has 40 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new model of Guarded Dependent Type Theory (GDTT), a type theory\nwith guarded recursion and multiple clocks in which one can program with, and\nreason about coinductive types. Productivity of recursively defined coinductive\nprograms and proofs is encoded in types using guarded recursion, and can\ntherefore be checked modularly, unlike the syntactic checks implemented in\nmodern proof assistants.\n  The model is based on a category of covariant presheaves over a category of\ntime objects, and quantification over clocks is modelled using a presheaf of\nclocks. To model the clock irrelevance axiom, crucial for programming with\ncoinductive types, types must be interpreted as presheaves orthogonal to the\nobject of clocks. In the case of dependent types, this translates to a lifting\ncondition similar to the one found in homotopy theoretic models of type theory,\nbut here with an additional requirement of uniqueness of lifts. Since the\nuniverses defined by the standard Hofmann-Streicher construction in this model\ndo not satisfy this property, the universes in GDTT must be indexed by contexts\nof clock variables. We show how to model these universes in such a way that\ninclusions of clock contexts give rise to inclusions of universes commuting\nwith type operations on the nose.\n", "versions": [{"version": "v1", "created": "Sun, 11 Feb 2018 14:40:17 GMT"}, {"version": "v2", "created": "Wed, 18 Dec 2019 15:02:07 GMT"}, {"version": "v3", "created": "Mon, 13 Apr 2020 10:38:24 GMT"}], "update_date": "2020-04-14", "authors_parsed": [["Bizjak", "Ale\u0161", ""], ["M\u00f8gelberg", "Rasmus Ejlers", ""]]}, {"id": "1802.03775", "submitter": "Dejan Ni\\v{c}kovi\\'c", "authors": "Stefan Jaksic, Ezio Bartocci, Radu Grosu and Dejan Nickovic", "title": "An Algebraic Framework for Runtime Verification", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Runtime verification (RV) is a pragmatic and scalable, yet rigorous\ntechnique, to assess the correctness of complex systems, including\ncyber-physical systems (CPS). By measuring how robustly a CPS run satisfies a\nspecification, RV allows in addition, to quantify the resiliency of a CPS to\nperturbations. In this paper we propose Algebraic Runtime Verification (ARV), a\ngeneral, semantic framework for RV, which takes advantage of the monoidal\nstructure of runs (w.r.t. concatenation) and the semiring structure of a\nspecification automaton (w.r.t. choice and concatenation), to compute in an\nincremental and application specific fashion the resiliency measure. This\nallows us to expose the core aspects of RV, by developing an abstract\nmonitoring algorithm, and to strengthen and unify the various qualitative and\nquantitative approaches to RV, by instantiating choice and concatenation with\nreal-valued functions as dictated by the application. We demonstrate the power\nand effectiveness of our framework on two case studies from the automotive\ndomain.\n", "versions": [{"version": "v1", "created": "Sun, 11 Feb 2018 17:21:03 GMT"}], "update_date": "2018-02-13", "authors_parsed": [["Jaksic", "Stefan", ""], ["Bartocci", "Ezio", ""], ["Grosu", "Radu", ""], ["Nickovic", "Dejan", ""]]}, {"id": "1802.03828", "submitter": "Giovanni Amendola", "authors": "Giovanni Amendola, Francesco Ricca, Miroslaw Truszczynski", "title": "New Models for Generating Hard Random Boolean Formulas and Disjunctive\n  Logic Programs", "comments": "37 pages, 24 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose two models of random quantified boolean formulas and their natural\nrandom disjunctive logic program counterparts. The models extend the standard\nmodels of random k-CNF formulas and the Chen-Interian model of random 2QBFs.\nThe first model controls the generation of programs and QSAT formulas by\nimposing a specific structure on rules and clauses, respectively. The second\nmodel is based on a family of QSAT formulas in a non-clausal form. We provide\ntheoretical bounds for the phase transition region in our models, and show\nexperimentally the presence of the easy-hard-easy pattern and its alignment\nwith the location of the phase transition. We show that boolean formulas and\nlogic programs from our models are significantly harder than those obtained\nfrom the standard k-CNF and Chen-Interian models, and that their combination\nyields formulas and programs that are \"super-hard\" to evaluate. We also provide\nevidence suggesting that formulas from one of our models are well suited for\nassessing solvers tuned to real-world instances. Finally, it is noteworthy\nthat, to the best of our knowledge, our models and results on random\ndisjunctive logic programs are the first of their kind.\n", "versions": [{"version": "v1", "created": "Sun, 11 Feb 2018 22:12:24 GMT"}], "update_date": "2018-02-13", "authors_parsed": [["Amendola", "Giovanni", ""], ["Ricca", "Francesco", ""], ["Truszczynski", "Miroslaw", ""]]}, {"id": "1802.03993", "submitter": "Manuel Kauers", "authors": "Manuel Kauers and Martina Seidl", "title": "Symmetries of Quantified Boolean Formulas", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While symmetries are well understood for Boolean formulas and successfully\nexploited in practical SAT solving, less is known about symmetries in\nquantified Boolean formulas (QBF). There are some works introducing adaptions\nof propositional symmetry breaking techniques, with a theory covering only very\nspecific parts of QBF symmetries. We present a general framework that gives a\nconcise characterization of symmetries of QBF. Our framework naturally\nincorporates the duality of universal and existential symmetries resulting in a\ngeneral basis for QBF symmetry breaking.\n", "versions": [{"version": "v1", "created": "Mon, 12 Feb 2018 11:49:42 GMT"}], "update_date": "2018-02-13", "authors_parsed": [["Kauers", "Manuel", ""], ["Seidl", "Martina", ""]]}, {"id": "1802.04007", "submitter": "Zarathustra Amadeus Goertzel", "authors": "Zarathustra Goertzel (1), Jan Jakub\\r{u}v (1), Stephan Schulz (2),\n  Josef Urban (1) ((1) Czech Technical University in Prague, (2) DHBW\n  Stuttgart)", "title": "ProofWatch: Watchlist Guidance for Large Theories in E", "comments": "19 pages, 10 tables, submitted to ITP 2018 at FLOC", "journal-ref": null, "doi": "10.1007/978-3-319-94821-8_16", "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Watchlist (also hint list) is a mechanism that allows related proofs to guide\na proof search for a new conjecture. This mechanism has been used with the\nOtter and Prover9 theorem provers, both for interactive formalizations and for\nhuman-assisted proving of open conjectures in small theories. In this work we\nexplore the use of watchlists in large theories coming from first-order\ntranslations of large ITP libraries, aiming at improving hammer-style\nautomation by smarter internal guidance of the ATP systems. In particular, we\n(i) design watchlist-based clause evaluation heuristics inside the E ATP\nsystem, and (ii) develop new proof guiding algorithms that load many previous\nproofs inside the ATP and focus the proof search using a dynamically updated\nnotion of proof matching. The methods are evaluated on a large set of problems\ncoming from the Mizar library, showing significant improvement of E's standard\nportfolio of strategies, and also of the previous best set of strategies\ninvented for Mizar by evolutionary methods.\n", "versions": [{"version": "v1", "created": "Mon, 12 Feb 2018 12:38:55 GMT"}, {"version": "v2", "created": "Sat, 19 May 2018 10:43:49 GMT"}], "update_date": "2019-05-24", "authors_parsed": [["Goertzel", "Zarathustra", ""], ["Jakub\u016fv", "Jan", ""], ["Schulz", "Stephan", ""], ["Urban", "Josef", ""]]}, {"id": "1802.04067", "submitter": "Hugo Gimbert", "authors": "Paulin Fournier and Hugo Gimbert", "title": "Alternating Nonzero Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new class of automata on infinite trees called\n\\emph{alternating nonzero automata}, which extends the class of\nnon-deterministic nonzero automata. We reduce the emptiness problem for\nalternating nonzero automata to the same problem for non-deterministic ones,\nwhich implies decidability. We obtain as a corollary algorithms for the\nsatisfiability of a probabilistic temporal logic extending both CTL* and the\nqualitative fragment of pCTL*.\n", "versions": [{"version": "v1", "created": "Mon, 12 Feb 2018 14:33:50 GMT"}], "update_date": "2018-02-13", "authors_parsed": [["Fournier", "Paulin", ""], ["Gimbert", "Hugo", ""]]}, {"id": "1802.04127", "submitter": "Arif G\\\"ursoy", "authors": "Necla Kircali Gursoy, Ibrahim Senturk, Tahsin Oner, Arif Gursoy", "title": "A New Algorithmic Decision for Categorical Syllogisms via Caroll's\n  Diagrams", "comments": null, "journal-ref": null, "doi": "10.1007/s00500-019-04598-9", "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we deal with a calculus system SLCD (Syllogistic Logic with\nCarroll Diagrams), which gives a formal approach to logical reasoning with\ndiagrams, for representations of the fundamental Aristotelian categorical\npropositions and show that they are closed under the syllogistic criterion of\ninference which is the deletion of middle term. Therefore, it is implemented to\nlet the formalism comprise synchronically bilateral and trilateral\ndiagrammatical appearance and a naive algorithmic nature. And also, there is no\nneed specific knowledge or exclusive ability to understand as well as to use\nit. Consequently, we give an effective algorithm used to determine whether a\nsyllogistic reasoning valid or not by using SLCD.\n", "versions": [{"version": "v1", "created": "Thu, 8 Feb 2018 11:29:59 GMT"}, {"version": "v2", "created": "Wed, 28 Feb 2018 11:17:01 GMT"}, {"version": "v3", "created": "Wed, 7 Mar 2018 06:25:46 GMT"}, {"version": "v4", "created": "Thu, 28 Jan 2021 09:36:37 GMT"}], "update_date": "2021-01-29", "authors_parsed": [["Gursoy", "Necla Kircali", ""], ["Senturk", "Ibrahim", ""], ["Oner", "Tahsin", ""], ["Gursoy", "Arif", ""]]}, {"id": "1802.04315", "submitter": "Floris van Doorn", "authors": "Ulrik Buchholtz, Floris van Doorn and Egbert Rijke", "title": "Higher Groups in Homotopy Type Theory", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.AT math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a development of the theory of higher groups, including infinity\ngroups and connective spectra, in homotopy type theory. An infinity group is\nsimply the loops in a pointed, connected type, where the group structure comes\nfrom the structure inherent in the identity types of Martin-L\\\"of type theory.\nWe investigate ordinary groups from this viewpoint, as well as higher\ndimensional groups and groups that can be delooped more than once. A major\nresult is the stabilization theorem, which states that if an $n$-type can be\ndelooped $n+2$ times, then it is an infinite loop type. Most of the results\nhave been formalized in the Lean proof assistant.\n", "versions": [{"version": "v1", "created": "Mon, 12 Feb 2018 19:26:26 GMT"}], "update_date": "2018-02-14", "authors_parsed": [["Buchholtz", "Ulrik", ""], ["van Doorn", "Floris", ""], ["Rijke", "Egbert", ""]]}, {"id": "1802.04406", "submitter": "Robert Colvin", "authors": "Robert J. Colvin and Graeme Smith", "title": "A wide-spectrum language for verification of programs on weak memory\n  models", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-319-95582-7_14", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modern processors deploy a variety of weak memory models, which for\nefficiency reasons may (appear to) execute instructions in an order different\nto that specified by the program text. The consequences of instruction\nreordering can be complex and subtle, and can impact on ensuring correctness.\nPrevious work on the semantics of weak memory models has focussed on the\nbehaviour of assembler-level programs. In this paper we utilise that work to\nextract some general principles underlying instruction reordering, and apply\nthose principles to a wide-spectrum language encompassing abstract data types\nas well as low-level assembler code. The goal is to support reasoning about\nimplementations of data structures for modern processors with respect to an\nabstract specification.\n  Specifically, we define an operational semantics, from which we derive some\nproperties of program refinement, and encode the semantics in the rewriting\nengine Maude as a model-checking tool. The tool is used to validate the\nsemantics against the behaviour of a set of litmus tests (small assembler\nprograms) run on hardware, and also to model check implementations of data\nstructures from the literature against their abstract specifications.\n", "versions": [{"version": "v1", "created": "Tue, 13 Feb 2018 00:23:16 GMT"}], "update_date": "2018-12-04", "authors_parsed": [["Colvin", "Robert J.", ""], ["Smith", "Graeme", ""]]}, {"id": "1802.04428", "submitter": "Xiaokang Qiu", "authors": "Kangjing Huang and Xiaokang Qiu and Qi Tian and Yanjun Wang", "title": "Reconciling Enumerative and Symbolic Search in Syntax-Guided Synthesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Syntax-guided synthesis aims to find a program satisfying semantic\nspecification as well as user-provided structural hypothesis. For syntax-guided\nsynthesis there are two main search strategies: concrete search, which\nsystematically or stochastically enumerates all possible solutions, and\nsymbolic search, which interacts with a constraint solver to solve the\nsynthesis problem. In this paper, we propose a concolic synthesis framework\nwhich combines the best of the two worlds. Based on a decision tree\nrepresentation, our framework works by enumerating tree heights from the\nsmallest possible one to larger ones. For each fixed height, the framework\nsymbolically searches a solution through the counterexample-guided inductive\nsynthesis approach. To compensate the exponential blow-up problem with the\nconcolic synthesis framework, we identify two fragments of synthesis problems\nand develop purely symbolic and more efficient procedures. The two fragments\nare decidable as these procedures are terminating and complete. We implemented\nour synthesis procedures and compared with state-of-the-art synthesizers on a\nrange of benchmarks. Experiments show that our algorithms are promising.\n", "versions": [{"version": "v1", "created": "Tue, 13 Feb 2018 01:53:50 GMT"}], "update_date": "2018-02-14", "authors_parsed": [["Huang", "Kangjing", ""], ["Qiu", "Xiaokang", ""], ["Tian", "Qi", ""], ["Wang", "Yanjun", ""]]}, {"id": "1802.04512", "submitter": "Thorsten Wissmann", "authors": "Tatsuji Kawai and Giovanni Sambin", "title": "The principle of pointfree continuity", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 1 (March 5,\n  2019) lmcs:5254", "doi": "10.23638/LMCS-15(1:22)2019", "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In the setting of constructive pointfree topology, we introduce a notion of\ncontinuous operation between pointfree topologies and the corresponding\nprinciple of pointfree continuity. An operation between points of pointfree\ntopologies is continuous if it is induced by a relation between the bases of\nthe topologies; this gives a rigorous condition for Brouwer's continuity\nprinciple to hold. The principle of pointfree continuity for pointfree\ntopologies $\\mathcal{S}$ and $\\mathcal{T}$ says that any relation which induces\na continuous operation between points is a morphism from $\\mathcal{S}$ to\n$\\mathcal{T}$. The principle holds under the assumption of bi-spatiality of\n$\\mathcal{S}$. When $\\mathcal{S}$ is the formal Baire space or the formal unit\ninterval and $\\mathcal{T}$ is the formal topology of natural numbers, the\nprinciple is equivalent to spatiality of the formal Baire space and formal unit\ninterval, respectively. Some of the well-known connections between spatiality,\nbar induction, and compactness of the unit interval are recast in terms of our\nprinciple of continuity.\n  We adopt the Minimalist Foundation as our constructive foundation, and\npositive topology as the notion of pointfree topology. This allows us to\ndistinguish ideal objects from constructive ones, and in particular, to\ninterpret choice sequences as points of the formal Baire space.\n", "versions": [{"version": "v1", "created": "Tue, 13 Feb 2018 09:10:54 GMT"}, {"version": "v2", "created": "Sat, 27 Oct 2018 02:07:04 GMT"}, {"version": "v3", "created": "Tue, 19 Feb 2019 07:24:59 GMT"}, {"version": "v4", "created": "Mon, 4 Mar 2019 13:53:39 GMT"}], "update_date": "2019-04-29", "authors_parsed": [["Kawai", "Tatsuji", ""], ["Sambin", "Giovanni", ""]]}, {"id": "1802.04695", "submitter": "Carlos Olarte", "authors": "Carlos Olarte, Elaine Pimentel and Camilo Rueda", "title": "A Concurrent Constraint Programming Interpretation of Access Permissions", "comments": "This paper is under consideration for publication in Theory and\n  Practice of Logic Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A recent trend in object oriented (OO) programming languages is the use of\nAccess Permissions (APs) as an abstraction for controlling concurrent\nexecutions of programs. The use of AP source code annotations defines a\nprotocol specifying how object references can access the mutable state of\nobjects. Although the use of APs simplifies the task of writing concurrent\ncode, an unsystematic use of them can lead to subtle problems. This paper\npresents a declarative interpretation of APs as Linear Concurrent Constraint\nPrograms (lcc). We represent APs as constraints (i.e., formulas in logic) in an\nunderlying constraint system whose entailment relation models the\ntransformation rules of APs. Moreover, we use processes in lcc to model the\ndependencies imposed by APs, thus allowing the faithful representation of their\nflow in the program. We verify relevant properties about AP programs by taking\nadvantage of the interpretation of lcc processes as formulas in Girard's\nintuitionistic linear logic (ILL). Properties include deadlock detection,\nprogram correctness (whether programs adhere to their AP specifications or\nnot), and the ability of methods to run concurrently. By relying on a focusing\ndiscipline for ILL, we provide a complexity measure for proofs of the above\nmentioned properties. The effectiveness of our verification techniques is\ndemonstrated by implementing the Alcove tool that includes an animator and a\nverifier. The former executes the lcc model, observing the flow of APs and\nquickly finding inconsistencies of the APs vis-a-vis the implementation. The\nlatter is an automatic theorem prover based on ILL. This paper is under\nconsideration for publication in Theory and Practice of Logic Programming\n(TPLP).\n", "versions": [{"version": "v1", "created": "Tue, 13 Feb 2018 16:02:20 GMT"}], "update_date": "2018-02-14", "authors_parsed": [["Olarte", "Carlos", ""], ["Pimentel", "Elaine", ""], ["Rueda", "Camilo", ""]]}, {"id": "1802.04698", "submitter": "Julia Padberg", "authors": "Julia Padberg", "title": "Subtyping for Hierarchical, Reconfigurable Petri Nets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hierarchical Petri nets allow a more abstract view and reconfigurable Petri\nnets model dynamic structural adaptation. In this contribution we present the\ncombination of reconfigurable Petri nets and hierarchical Petri nets yielding\nhierarchical structure for reconfigurable Petri nets. Hierarchies are\nestablished by substituting transitions by subnets. These subnets are\nthemselves reconfigurable, so they are supplied with their own set of rules.\nMoreover, global rules that can be applied in all of the net, are provided.\n", "versions": [{"version": "v1", "created": "Tue, 13 Feb 2018 16:11:54 GMT"}], "update_date": "2018-02-14", "authors_parsed": [["Padberg", "Julia", ""]]}, {"id": "1802.04704", "submitter": "Elaine Pimentel", "authors": "Elaine Pimentel", "title": "Proof systems: from nestings to sequents and back", "comments": "Extended version of the paper submitted to IJCAR-18", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we explore proof theoretical connections between sequent,\nnested and labelled calculi. In particular, we show a general algorithm for\ntransforming a class of nested systems into sequent calculus systems, passing\nthrough linear nested systems. Moreover, we show a semantical characterisation\nof intuitionistic, multi-modal and non-normal modal logics for all these\nsystems, via a case-by-case translation between labelled nested to labelled\nsequent systems.\n", "versions": [{"version": "v1", "created": "Tue, 13 Feb 2018 16:17:38 GMT"}, {"version": "v2", "created": "Wed, 14 Feb 2018 08:35:55 GMT"}], "update_date": "2018-02-15", "authors_parsed": [["Pimentel", "Elaine", ""]]}, {"id": "1802.04739", "submitter": "Timos Antonopoulos", "authors": "Dana Angluin, Timos Antonopoulos, Dana Fisman", "title": "Query learning of derived $\\omega$-tree languages in polynomial time", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 3 (August\n  27, 2019) lmcs:5715", "doi": "10.23638/LMCS-15(3:21)2019", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present the first polynomial time algorithm to learn nontrivial classes of\nlanguages of infinite trees. Specifically, our algorithm uses membership and\nequivalence queries to learn classes of $\\omega$-tree languages derived from\nweak regular $\\omega$-word languages in polynomial time. The method is a\ngeneral polynomial time reduction of learning a class of derived $\\omega$-tree\nlanguages to learning the underlying class of $\\omega$-word languages, for any\nclass of $\\omega$-word languages recognized by a deterministic B\\\"{u}chi\nacceptor. Our reduction, combined with the polynomial time learning algorithm\nof Maler and Pnueli [1995] for the class of weak regular $\\omega$-word\nlanguages yields the main result. We also show that subset queries that return\ncounterexamples can be implemented in polynomial time using subset queries that\nreturn no counterexamples for deterministic or non-deterministic finite word\nacceptors, and deterministic or non-deterministic B\\\"{u}chi $\\omega$-word\nacceptors.\n  A previous claim of an algorithm to learn regular $\\omega$-trees due to\nJayasrirani, Begam and Thomas [2008] is unfortunately incorrect, as shown in\nAngluin [2016].\n", "versions": [{"version": "v1", "created": "Tue, 13 Feb 2018 17:06:12 GMT"}, {"version": "v2", "created": "Thu, 21 Mar 2019 18:17:43 GMT"}, {"version": "v3", "created": "Mon, 26 Aug 2019 09:36:15 GMT"}], "update_date": "2019-10-23", "authors_parsed": [["Angluin", "Dana", ""], ["Antonopoulos", "Timos", ""], ["Fisman", "Dana", ""]]}, {"id": "1802.04954", "submitter": "Kirsten Winter", "authors": "Graeme Smith, Kirsten Winter, Robert J. Colvin", "title": "A sound and complete definition of linearizability on weak memory models", "comments": "33 pages, including appendix. arXiv admin note: text overlap with\n  arXiv:1810.09612", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linearizability is a widely accepted notion of correctness for concurrent\nobjects. Recent research has investigated redefining linearizability for\nparticular hardware weak memory models, in particular for TSO. In this paper,\nwe provide an overview of this research and show that such redefinitions of\nlinearizability are not required: under an interpretation of specification\nbehaviour which abstracts from weak memory effects, the standard definition of\nlinearizability is sound and complete on all hardware weak memory models. We\nprove our result with respect to a definition of object refinement which takes\na weak memory model as a parameter. The main consequence of our findings is\nthat we can leverage the range of existing techniques and tools for standard\nlinearizability when verifying concurrent objects running on hardware weak\nmemory models.\n", "versions": [{"version": "v1", "created": "Wed, 14 Feb 2018 04:45:19 GMT"}, {"version": "v2", "created": "Mon, 1 Jul 2019 10:52:19 GMT"}], "update_date": "2019-07-03", "authors_parsed": [["Smith", "Graeme", ""], ["Winter", "Kirsten", ""], ["Colvin", "Robert J.", ""]]}, {"id": "1802.04970", "submitter": "Aleksandar S. Dimovski", "authors": "Aleksandar S. Dimovski", "title": "Abstract Family-based Model Checking using Modal Featured Transition\n  Systems: Preservation of CTL* (Extended Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Variational systems allow effective building of many custom variants by using\nfeatures (configuration options) to mark the variable functionality. In many of\nthe applications, their quality assurance and formal verification are of\nparamount importance. Family-based model checking allows simultaneous\nverification of all variants of a variational system in a single run by\nexploiting the commonalities between the variants. Yet, its computational cost\nstill greatly depends on the number of variants (often huge).\n  In this work, we show how to achieve efficient family-based model checking of\nCTL* temporal properties using variability abstractions and off-the-shelf\n(single-system) tools. We use variability abstractions for deriving abstract\nfamily-based model checking, where the variability model of a variational\nsystem is replaced with an abstract (smaller) version of it, called modal\nfeatured transition system, which preserves the satisfaction of both universal\nand existential temporal properties, as expressible in CTL*. Modal featured\ntransition systems contain two kinds of transitions, termed may and must\ntransitions, which are defined by the conservative (over-approximating)\nabstractions and their dual (under-approximating) abstractions, respectively.\nThe variability abstractions can be combined with different partitionings of\nthe set of variants to infer suitable divide-and-conquer verification plans for\nthe variational system. We illustrate the practicality of this approach for\nseveral variational systems.\n", "versions": [{"version": "v1", "created": "Wed, 14 Feb 2018 07:00:01 GMT"}, {"version": "v2", "created": "Mon, 5 Mar 2018 12:23:13 GMT"}], "update_date": "2018-03-06", "authors_parsed": [["Dimovski", "Aleksandar S.", ""]]}, {"id": "1802.04982", "submitter": "Christoph Wernhard", "authors": "Christoph Wernhard", "title": "Craig Interpolation and Access Interpolation with Clausal First-Order\n  Tableaux", "comments": null, "journal-ref": null, "doi": null, "report-no": "KRR 18-01", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop foundations for computing Craig interpolants and similar\nintermediates of two given formulas with first-order theorem provers that\nconstruct clausal tableaux. Provers that can be understood in this way include\nefficient machine-oriented systems based on calculi of two families:\ngoal-oriented like model elimination and the connection method, and bottom-up\nlike the hyper tableau calculus. The presented method for Craig-Lyndon\ninterpolation involves a lifting step where terms are replaced by quantified\nvariables, similar as known for resolution-based interpolation, but applied to\na differently characterized ground formula and proven correct more abstractly\non the basis of Herbrand's theorem, independently of a particular calculus.\nAccess interpolation is a recent form of interpolation for database query\nreformulation that applies to first-order formulas with relativized quantifiers\nand constrains the quantification patterns of predicate occurrences. It has\nbeen previously investigated in the framework of Smullyan's non-clausal\ntableaux. Here, in essence, we simulate these with the more machine-oriented\nclausal tableaux through structural constraints that can be ensured either\ndirectly by bottom-up tableau construction methods or, for closed clausal\ntableaux constructed with arbitrary calculi, by postprocessing with\nrestructuring transformations.\n", "versions": [{"version": "v1", "created": "Wed, 14 Feb 2018 08:00:10 GMT"}, {"version": "v2", "created": "Thu, 18 Oct 2018 08:22:32 GMT"}], "update_date": "2018-10-19", "authors_parsed": [["Wernhard", "Christoph", ""]]}, {"id": "1802.05143", "submitter": "Christoph Rauch", "authors": "Paolo Pistone", "title": "On completeness and parametricity in the realizability semantics of\n  System F", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 4 (October\n  29, 2019) lmcs:5878", "doi": "10.23638/LMCS-15(4:6)2019", "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We investigate completeness and parametricity for a general class of\nrealizability semantics for System F defined in terms of closure operators over\nsets of $\\lambda$-terms. This class includes most semantics used for\nnormalization theorems, as those arising from Tait's saturated sets and\nGirard's reducibility candidates.\n  We establish a completeness result for positive types which subsumes those\nexisting in the literature, and we show that closed realizers satisfy\nparametricity conditions expressed either as invariance with respect to logical\nrelations or as dinaturality. Our results imply that, for positive types,\ntypability, realizability and parametricity are equivalent properties of closed\nnormal $\\lambda$-terms.\n", "versions": [{"version": "v1", "created": "Wed, 14 Feb 2018 15:08:55 GMT"}, {"version": "v2", "created": "Fri, 8 Feb 2019 18:34:36 GMT"}, {"version": "v3", "created": "Mon, 8 Jul 2019 09:08:53 GMT"}, {"version": "v4", "created": "Wed, 28 Aug 2019 16:35:29 GMT"}, {"version": "v5", "created": "Mon, 28 Oct 2019 11:20:23 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Pistone", "Paolo", ""]]}, {"id": "1802.05159", "submitter": "Louis Abraham", "authors": "Louis Abraham", "title": "SAT solving techniques: a bibliography", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a selective bibliography about efficient SAT solving, focused on\noptimizations for the CDCL-based algorithms.\n", "versions": [{"version": "v1", "created": "Sat, 10 Feb 2018 23:25:00 GMT"}, {"version": "v2", "created": "Mon, 23 Apr 2018 15:03:29 GMT"}], "update_date": "2018-04-24", "authors_parsed": [["Abraham", "Louis", ""]]}, {"id": "1802.05266", "submitter": "Massimo Lauria", "authors": "Albert Atserias and Massimo Lauria", "title": "Circular (Yet Sound) Proofs", "comments": "3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new way of composing proofs in rule-based proof systems that\ngeneralizes tree-like and dag-like proofs. In the new definition, proofs are\ndirected graphs of derived formulas, in which cycles are allowed as long as\nevery formula is derived at least as many times as it is required as a premise.\nWe call such proofs circular. We show that, for all sets of standard inference\nrules, circular proofs are sound. For Frege we show that circular proofs can be\nconverted into tree-like ones with at most polynomial overhead. For Resolution\nthe translation can no longer be a Resolution proof because, as we show, the\npigeonhole principle has circular Resolution proofs of polynomial size.\nSurprisingly, as proof systems for deriving clauses from clauses, Circular\nResolution turns out to be equivalent to Sherali-Adams, a proof system for\nreasoning through polynomial inequalities that has linear programming at its\nbase. As corollaries we get: 1) polynomial-time (LP-based) algorithms that find\ncircular Resolution proofs of constant width, 2) examples that separate\ncircular from dag-like Resolution, such as the pigeonhole principle and its\nvariants, and 3) exponentially hard cases for circular Resolution.\n", "versions": [{"version": "v1", "created": "Wed, 14 Feb 2018 18:58:21 GMT"}], "update_date": "2018-02-15", "authors_parsed": [["Atserias", "Albert", ""], ["Lauria", "Massimo", ""]]}, {"id": "1802.05494", "submitter": "Christoph Rauch", "authors": "Delia Kesner and Pierre Vial", "title": "Non-idempotent types for classical calculi in natural deduction style", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 1 (January\n  14, 2020) lmcs:6028", "doi": "10.23638/LMCS-16(1:3)2020", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In the first part of this paper, we define two resource aware typing systems\nfor the {\\lambda}{\\mu}-calculus based on non-idempotent intersection and union\ntypes. The non-idempotent approach provides very simple combinatorial\narguments-based on decreasing measures of type derivations-to characterize head\nand strongly normalizing terms. Moreover, typability provides upper bounds for\nthe lengths of the head reduction and the maximal reduction sequences to\nnormal-form. In the second part of this paper, the {\\lambda}{\\mu}-calculus is\nrefined to a small-step calculus called {\\lambda}{\\mu}s, which is inspired by\nthe substitution at a distance paradigm. The {\\lambda}{\\mu}s-calculus turns out\nto be compatible with a natural extensionof the non-idempotent interpretations\nof {\\lambda}{\\mu}, i.e., {\\lambda}{\\mu}s-reduction preserves and decreases\ntyping derivations in an extended appropriate typing system. We thus derive a\nsimple arithmetical characterization of strongly {\\lambda}{\\mu}s-normalizing\nterms by means of typing.\n", "versions": [{"version": "v1", "created": "Thu, 15 Feb 2018 11:55:54 GMT"}, {"version": "v2", "created": "Wed, 7 Nov 2018 14:11:25 GMT"}, {"version": "v3", "created": "Fri, 5 Apr 2019 19:19:19 GMT"}, {"version": "v4", "created": "Fri, 14 Jun 2019 22:53:25 GMT"}, {"version": "v5", "created": "Fri, 27 Sep 2019 14:35:04 GMT"}, {"version": "v6", "created": "Mon, 13 Jan 2020 15:55:39 GMT"}], "update_date": "2020-06-17", "authors_parsed": [["Kesner", "Delia", ""], ["Vial", "Pierre", ""]]}, {"id": "1802.05559", "submitter": "Peter Chini", "authors": "Peter Chini, Roland Meyer, Prakash Saivasan", "title": "Fine-Grained Complexity of Safety Verification", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DC cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the fine-grained complexity of Leader Contributor Reachability (LCR)\nand Bounded-Stage Reachability (BSR), two variants of the safety verification\nproblem for shared memory concurrent programs. For both problems, the memory is\na single variable over a finite data domain. Our contributions are new\nverification algorithms and lower bounds. The latter are based on the\nExponential Time Hypothesis (ETH), the problem Set Cover, and\ncross-compositions.\n  LCR is the question whether a designated leader thread can reach an unsafe\nstate when interacting with a certain number of equal contributor threads. We\nsuggest two parameterizations: (1) By the size of the data domain D and the\nsize of the leader L, and (2) by the size of the contributors C. We present\nalgorithms for both cases. The key techniques are compact witnesses and dynamic\nprogramming. The algorithms run in O*((L(D+1))^(LD) * D^D) and O*(2^C) time,\nshowing that both parameterizations are fixed-parameter tractable. We\ncomplement the upper bounds by (matching) lower bounds based on ETH and Set\nCover. Moreover, we prove the absence of polynomial kernels.\n  For BSR, we consider programs involving t different threads. We restrict the\nanalysis to computations where the write permission changes s times between the\nthreads. BSR asks whether a given configuration is reachable via such an\ns-stage computation. When parameterized by P, the maximum size of a thread, and\nt, the interesting observation is that the problem has a large number of\ndifficult instances. Formally, we show that there is no polynomial kernel, no\ncompression algorithm that reduces the size of the data domain D or the number\nof stages s to a polynomial dependence on P and t. This indicates that symbolic\nmethods may be harder to find for this problem.\n", "versions": [{"version": "v1", "created": "Thu, 15 Feb 2018 14:26:10 GMT"}, {"version": "v2", "created": "Mon, 11 Feb 2019 14:55:41 GMT"}, {"version": "v3", "created": "Fri, 10 Jan 2020 17:02:16 GMT"}], "update_date": "2020-01-13", "authors_parsed": [["Chini", "Peter", ""], ["Meyer", "Roland", ""], ["Saivasan", "Prakash", ""]]}, {"id": "1802.05616", "submitter": "Benjamin Farinier", "authors": "Benjamin Farinier (1), S\\'ebastien Bardin (1), Richard Bonichon (1),\n  Marie-Laure Potet (2) ((1) LSL, (2) VERIMAG - IMAG)", "title": "Model Generation for Quantified Formulas: A Taint-Based Approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We focus in this paper on generating models of quantified first-order\nformulas over built-in theories, which is paramount in software verification\nand bug finding. While standard methods are either geared toward proving the\nabsence of solution or targeted to specific theories, we propose a generic\napproach based on a reduction to the quantifier-free case. Our technique allows\nthus to reuse all the efficient machinery developed for that context.\nExperiments show a substantial improvement over state-of-the-art methods.\n", "versions": [{"version": "v1", "created": "Thu, 15 Feb 2018 15:26:51 GMT"}], "update_date": "2018-02-16", "authors_parsed": [["Farinier", "Benjamin", "", "LSL"], ["Bardin", "S\u00e9bastien", "", "LSL"], ["Bonichon", "Richard", "", "LSL"], ["Potet", "Marie-Laure", "", "VERIMAG - IMAG"]]}, {"id": "1802.05629", "submitter": "Thorsten Wissmann", "authors": "Ian Orton and Andrew M. Pitts", "title": "Models of Type Theory Based on Moore Paths", "comments": "This is a revised and expanded version of a paper with the same name\n  that appeared in the proceedings of the 2nd International Conference on\n  Formal Structures for Computation and Deduction (FSCD 2017)", "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 1, Type\n  theory and constructive mathematics (January 9, 2019) lmcs:5069", "doi": "10.23638/LMCS-15(1:2)2019", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper introduces a new family of models of intensional Martin-L\\\"of type\ntheory. We use constructive ordered algebra in toposes. Identity types in the\nmodels are given by a notion of Moore path. By considering a particular gros\ntopos, we show that there is such a model that is non-truncated, i.e. contains\nnon-trivial structure at all dimensions. In other words, in this model a type\nin a nested sequence of identity types can contain more than one element, no\nmatter how great the degree of nesting. Although inspired by existing\nnon-truncated models of type theory based on simplicial and cubical sets, the\nnotion of model presented here is notable for avoiding any form of Kan filling\ncondition in the semantics of types.\n", "versions": [{"version": "v1", "created": "Thu, 15 Feb 2018 16:01:02 GMT"}, {"version": "v2", "created": "Fri, 28 Dec 2018 19:59:31 GMT"}, {"version": "v3", "created": "Tue, 8 Jan 2019 15:27:10 GMT"}], "update_date": "2019-01-10", "authors_parsed": [["Orton", "Ian", ""], ["Pitts", "Andrew M.", ""]]}, {"id": "1802.05734", "submitter": "Philipp Schlicht", "authors": "Merlin Carl, Benjamin Rin, Philipp Schlicht", "title": "Reachability for infinite time Turing machines with long tapes", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 2 (April 24,\n  2020) lmcs:6429", "doi": "10.23638/LMCS-16(2:2)2020", "report-no": null, "categories": "math.LO cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Infinite time Turing machine models with tape length $\\alpha$, denoted\n$T_\\alpha$, strengthen the machines of Hamkins and Kidder [HL00] with tape\nlength $\\omega$. A new phenomenon is that for some countable ordinals $\\alpha$,\nsome cells cannot be halting positions of $T_\\alpha$ given trivial input. The\nmain open question in [Rin14] asks about the size of the least such ordinal\n$\\delta$.\n  We answer this by providing various characterizations. For instance, $\\delta$\nis the least ordinal with any of the following properties: (a) For some\n$\\xi<\\alpha$, there is a $T_\\xi$-writable but not $T_\\alpha$-writable subset of\n$\\omega$. (b) There is a gap in the $T_\\alpha$-writable ordinals. (c) $\\alpha$\nis uncountable in $L_{\\lambda_\\alpha}$. Here $\\lambda_\\alpha$ denotes the\nsupremum of $T_\\alpha$-writable ordinals, i.e. those with a $T_\\alpha$-writable\ncode of length $\\alpha$.\n  We further use the above characterizations, and an analogue to Welch's\nsubmodel characterization of the ordinals $\\lambda$, $\\zeta$ and $\\Sigma$, to\nshow that $\\delta$ is large in the sense that it is a closure point of the\nfunction $\\alpha \\mapsto \\Sigma_\\alpha$, where $\\Sigma_\\alpha$ denotes the\nsupremum of the $T_\\alpha$-accidentally writable ordinals.\n", "versions": [{"version": "v1", "created": "Thu, 15 Feb 2018 19:55:02 GMT"}, {"version": "v10", "created": "Thu, 23 Apr 2020 09:08:19 GMT"}, {"version": "v2", "created": "Wed, 21 Feb 2018 07:58:12 GMT"}, {"version": "v3", "created": "Mon, 21 Jan 2019 17:35:28 GMT"}, {"version": "v4", "created": "Thu, 23 May 2019 11:53:38 GMT"}, {"version": "v5", "created": "Thu, 5 Dec 2019 20:00:10 GMT"}, {"version": "v6", "created": "Tue, 10 Dec 2019 07:28:22 GMT"}, {"version": "v7", "created": "Mon, 9 Mar 2020 08:05:29 GMT"}, {"version": "v8", "created": "Wed, 8 Apr 2020 14:35:32 GMT"}, {"version": "v9", "created": "Mon, 20 Apr 2020 20:35:58 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Carl", "Merlin", ""], ["Rin", "Benjamin", ""], ["Schlicht", "Philipp", ""]]}, {"id": "1802.05862", "submitter": "EPTCS", "authors": "Horatiu Cirstea (LORIA, Universit\\'e de Lorraine, France), David Sabel\n  (Goethe-University Frankfurt am Main, Germany)", "title": "Proceedings Fourth International Workshop on Rewriting Techniques for\n  Program Transformations and Evaluation", "comments": null, "journal-ref": "EPTCS 265, 2018", "doi": "10.4204/EPTCS.265", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the formal proceedings of the 4th International Workshop\non Rewriting Techniques for Program Transformations and Evaluation (WPTE 2017),\nheld on 8th September 2017 in Oxford, United Kingdom, and affiliated with the\nSecond International Conference on Formal Structures for Computation and\nDeduction (FSCD 2017).\n", "versions": [{"version": "v1", "created": "Fri, 16 Feb 2018 08:31:08 GMT"}], "update_date": "2018-02-19", "authors_parsed": [["Cirstea", "Horatiu", "", "LORIA, Universit\u00e9 de Lorraine, France"], ["Sabel", "David", "", "Goethe-University Frankfurt am Main, Germany"]]}, {"id": "1802.05935", "submitter": "Daisuke Kimura", "authors": "Daisuke Kimura and Makoto Tatsuta", "title": "Decidability for Entailments of Symbolic Heaps with Arrays", "comments": "arXiv admin note: text overlap with arXiv:1708.06696", "journal-ref": "Logical Methods in Computer Science, Volume 17, Issue 2 (May 11,\n  2021) lmcs:7472", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper presents two decidability results on the validity checking problem\nfor entailments of symbolic heaps in separation logic with Presburger\narithmetic and arrays. The first result is for a system with arrays and\nexistential quantifiers. The correctness of the decision procedure is proved\nunder the condition that sizes of arrays in the succedent are not existentially\nquantified. This condition is different from that proposed by Brotherston et\nal. in 2017 and one of them does not imply the other. The main idea is a novel\ntranslation from an entailment of symbolic heaps into a formula in Presburger\narithmetic. The second result is the decidability for a system with both arrays\nand lists. The key idea is to extend the unroll collapse technique proposed by\nBerdine et al. in 2005 to arrays and arithmetic as well as double-linked lists.\n", "versions": [{"version": "v1", "created": "Fri, 16 Feb 2018 14:00:00 GMT"}, {"version": "v2", "created": "Sun, 20 Dec 2020 10:38:25 GMT"}, {"version": "v3", "created": "Sat, 27 Mar 2021 03:43:36 GMT"}, {"version": "v4", "created": "Mon, 10 May 2021 16:09:35 GMT"}], "update_date": "2021-07-01", "authors_parsed": [["Kimura", "Daisuke", ""], ["Tatsuta", "Makoto", ""]]}, {"id": "1802.06217", "submitter": "Andrej Bauer", "authors": "Andrej Bauer, Ga\\\"etan Gilbert, Philipp G. Haselwarter, Matija\n  Pretnar, Christopher A. Stone", "title": "Design and Implementation of the Andromeda Proof Assistant", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Andromeda is an LCF-style proof assistant where the user builds derivable\njudgments by writing code in a meta-level programming language AML. The only\ntrusted component of Andromeda is a minimalist nucleus (an implementation of\nthe inference rules of an object-level type theory), which controls\nconstruction and decomposition of type-theoretic judgments.\n  Since the nucleus does not perform complex tasks like equality checking\nbeyond syntactic equality, this responsibility is delegated to the user, who\nimplements one or more equality checking procedures in the meta-language. The\nAML interpreter requests witnesses of equality from user code using the\nmechanism of algebraic operations and handlers. Dynamic checks in the nucleus\nguarantee that no invalid object-level derivations can be constructed. %even if\nthe AML code (or interpreter) is untrusted.\n  To demonstrate the flexibility of this system structure, we implemented a\nnucleus consisting of dependent type theory with equality reflection. Equality\nreflection provides a very high level of expressiveness, as it allows the user\nto add new judgmental equalities, but it also destroys desirable meta-theoretic\nproperties of type theory (such as decidability and strong normalization).\n  The power of effects and handlers in AML is demonstrated by a standard\nlibrary that provides default algorithms for equality checking, computation of\nnormal forms, and implicit argument filling. Users can extend these new\nalgorithms by providing local \"hints\" or by completely replacing these\nalgorithms for particular developments. We demonstrate the resulting system by\nshowing how to axiomatize and compute with natural numbers, by axiomatizing the\nuntyped $\\lambda$-calculus, and by implementing a simple automated system for\nmanaging a universe of types.\n", "versions": [{"version": "v1", "created": "Sat, 17 Feb 2018 10:04:17 GMT"}], "update_date": "2018-02-20", "authors_parsed": [["Bauer", "Andrej", ""], ["Gilbert", "Ga\u00ebtan", ""], ["Haselwarter", "Philipp G.", ""], ["Pretnar", "Matija", ""], ["Stone", "Christopher A.", ""]]}, {"id": "1802.06283", "submitter": "Justin Hsu", "authors": "Alejandro Aguirre, Gilles Barthe, Justin Hsu, Alexandra Silva", "title": "Almost Sure Productivity", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define Almost Sure Productivity (ASP), a probabilistic generalization of\nthe productivity condition for coinductively defined structures. Intuitively, a\nprobabilistic coinductive stream or tree is ASP if it produces infinitely many\noutputs with probability 1. Formally, we define almost sure productivity using\na final coalgebra semantics of programs inspired from Kerstan and K\\\"onig.\nThen, we introduce a core language for probabilistic streams and trees, and\nprovide two approaches to verify ASP: a sufficient syntactic criterion, and a\nreduction to model-checking pCTL* formulas on probabilistic pushdown automata.\nThe reduction shows that ASP is decidable for our core language.\n", "versions": [{"version": "v1", "created": "Sat, 17 Feb 2018 20:14:10 GMT"}, {"version": "v2", "created": "Sun, 13 May 2018 21:58:17 GMT"}], "update_date": "2018-05-15", "authors_parsed": [["Aguirre", "Alejandro", ""], ["Barthe", "Gilles", ""], ["Hsu", "Justin", ""], ["Silva", "Alexandra", ""]]}, {"id": "1802.06462", "submitter": "Farhad Shakerin", "authors": "Farhad Shakerin, Gopal Gupta", "title": "Heuristic Based Induction of Answer Set Programs: From Default theories\n  to combinatorial problems", "comments": "Technical Report 02-18-2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Significant research has been conducted in recent years to extend Inductive\nLogic Programming (ILP) methods to induce Answer Set Programs (ASP). These\nmethods perform an exhaustive search for the correct hypothesis by encoding an\nILP problem instance as an ASP program. Exhaustive search, however, results in\nloss of scalability. In addition, the language bias employed in these methods\nis overly restrictive too. In this paper we extend our previous work on\nlearning stratified answer set programs that have a single stable model to\nlearning arbitrary (i.e., non-stratified) ones with multiple stable models. Our\nextended algorithm is a greedy FOIL-like algorithm, capable of inducing\nnon-monotonic logic programs, examples of which includes programs for\ncombinatorial problems such as graph-coloring and N-queens. To the best of our\nknowledge, this is the first heuristic-based ILP algorithm to induce answer set\nprograms with multiple stable models.\n", "versions": [{"version": "v1", "created": "Sun, 18 Feb 2018 22:48:49 GMT"}], "update_date": "2018-02-20", "authors_parsed": [["Shakerin", "Farhad", ""], ["Gupta", "Gopal", ""]]}, {"id": "1802.06492", "submitter": "EPTCS", "authors": "Nneka Chinelo Ene (King's College London Dept. of Informatics),\n  Maribel Fern\\'andez (King's College London Dept. of Informatics), Bruno\n  Pinaud (University of Bordeaux, LaBRI UMR CNRS 5800, France)", "title": "Attributed Hierarchical Port Graphs and Applications", "comments": "In Proceedings WPTE 2017, arXiv:1802.05862", "journal-ref": "EPTCS 265, 2018, pp. 2-19", "doi": "10.4204/EPTCS.265.2", "report-no": null, "categories": "cs.LO cs.SE cs.SI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present attributed hierarchical port graphs (AHP) as an extension of port\ngraphs that aims at facilitating the design of modular port graph models for\ncomplex systems. AHP consist of a number of interconnected layers, where each\nlayer defines a port graph whose nodes may link to layers further down the\nhierarchy; attributes are used to store user-defined data as well as\nvisualisation and run-time system parameters. We also generalise the notion of\nstrategic port graph rewriting (a particular kind of graph transformation\nsystem, where port graph rewriting rules are controlled by user-defined\nstrategies) to deal with AHP following the Single Push-out approach. We outline\nexamples of application in two areas: functional programming and financial\nmodelling.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 02:05:54 GMT"}], "update_date": "2018-02-20", "authors_parsed": [["Ene", "Nneka Chinelo", "", "King's College London Dept. of Informatics"], ["Fern\u00e1ndez", "Maribel", "", "King's College London Dept. of Informatics"], ["Pinaud", "Bruno", "", "University of Bordeaux, LaBRI UMR CNRS 5800, France"]]}, {"id": "1802.06493", "submitter": "EPTCS", "authors": "Liyi Li (University of Illinois at Urbana-Champaign), Elsa Gunter\n  (University of Illinois at Urbana-Champaign)", "title": "A Method to Translate Order-Sorted Algebras to Many-Sorted Algebras", "comments": "In Proceedings WPTE 2017, arXiv:1802.05862", "journal-ref": "EPTCS 265, 2018, pp. 20-34", "doi": "10.4204/EPTCS.265.3", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Order-sorted algebras and many sorted algebras exist in a long history with\nmany different implementations and applications. A lot of language\nspecifications have been defined in order-sorted algebra frameworks such as the\nlanguage specifications in K (an order-sorted algebra framework). The biggest\nproblem in a lot of the order-sorted algebra frameworks is that even if they\nmight allow developers to write programs and language specifications easily,\nbut they do not have a large set of tools to provide reasoning infrastructures\nto reason about the specifications built on the frameworks, which are very\ncommon in some many-sorted algebra framework such as Isabelle/HOL, Coq and FDR.\nThis fact brings us the necessity to marry the worlds of order-sorted algebras\nand many sorted algebras. In this paper, we propose an algorithm to translate a\nstrictly sensible order-sorted algebra to a many-sorted one in a restricted\ndomain by requiring the order-sorted algebra to be strictly sensible. The key\nidea of the translation is to add an equivalence relation called core equality\nto the translated many-sorted algebras. By defining this relation, we reduce\nthe complexity of translating a strictly sensible order-sorted algebra to a\nmany-sorted one, make the translated many-sorted algebra equations only\nincreasing by a very small amount of new equations, and keep the number of\nrewrite rules in the algebra in the same amount. We then prove the order-sorted\nalgebra and its translated many-sorted algebra are bisimilar. To the best of\nour knowledge, our translation and bisimilar proof is the first attempt in\ntranslating and relating an order-sorted algebra with a many-sorted one in a\nway that keeps the size of the translated many-sorted algebra relatively small.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 02:06:10 GMT"}], "update_date": "2018-02-20", "authors_parsed": [["Li", "Liyi", "", "University of Illinois at Urbana-Champaign"], ["Gunter", "Elsa", "", "University of Illinois at Urbana-Champaign"]]}, {"id": "1802.06494", "submitter": "EPTCS", "authors": "Shinnosuke Mizutani (Nagoya University), Naoki Nishida (Nagoya\n  University)", "title": "Transforming Proof Tableaux of Hoare Logic into Inference Sequences of\n  Rewriting Induction", "comments": "In Proceedings WPTE 2017, arXiv:1802.05862", "journal-ref": "EPTCS 265, 2018, pp. 35-51", "doi": "10.4204/EPTCS.265.4", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A proof tableau of Hoare logic is an annotated program with pre- and\npost-conditions, which corresponds to an inference tree of Hoare logic. In this\npaper, we show that a proof tableau for partial correctness can be transformed\ninto an inference sequence of rewriting induction for constrained rewriting. We\nalso show that the resulting sequence is a valid proof for an inductive theorem\ncorresponding to the Hoare triple if the constrained rewriting system obtained\nfrom the program is terminating. Such a valid proof with termination of the\nconstrained rewriting system implies total correctness of the program w.r.t.\nthe Hoare triple. The transformation enables us to apply techniques for proving\ntermination of constrained rewriting to proving total correctness of programs\ntogether with proof tableaux for partial correctness.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 02:06:28 GMT"}], "update_date": "2018-02-20", "authors_parsed": [["Mizutani", "Shinnosuke", "", "Nagoya University"], ["Nishida", "Naoki", "", "Nagoya\n  University"]]}, {"id": "1802.06495", "submitter": "EPTCS", "authors": "Koko Muroya, Dan R. Ghica", "title": "Efficient Implementation of Evaluation Strategies via Token-Guided Graph\n  Rewriting", "comments": "In Proceedings WPTE 2017, arXiv:1802.05862", "journal-ref": "EPTCS 265, 2018, pp. 52-66", "doi": "10.4204/EPTCS.265.5", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In implementing evaluation strategies of the lambda-calculus, both\ncorrectness and efficiency of implementation are valid concerns. While the\nnotion of correctness is determined by the evaluation strategy, regarding\nefficiency there is a larger design space that can be explored, in particular\nthe trade-off between space versus time efficiency. We contributed to the study\nof this trade-off by the introduction of an abstract machine for call-by-need,\ninspired by Girard's Geometry of Interaction, a machine combining token passing\nand graph rewriting. This work presents an extension of the machine, to\nadditionally accommodate left-to-right and right-to-left call-by-value\nstrategies. We show soundness and completeness of the extended machine with\nrespect to each of the call-by-need and two call-by-value strategies. Analysing\ntime cost of its execution classifies the machine as \"efficient\" in Accattoli's\ntaxonomy of abstract machines.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 02:06:43 GMT"}], "update_date": "2018-02-21", "authors_parsed": [["Muroya", "Koko", ""], ["Ghica", "Dan R.", ""]]}, {"id": "1802.06496", "submitter": "EPTCS", "authors": "Yutaro Nagae (Nagoya University), Masahiko Sakai (Nagoya University)", "title": "Reduced Dependency Spaces for Existential Parameterised Boolean Equation\n  Systems", "comments": "In Proceedings WPTE 2017, arXiv:1802.05862", "journal-ref": "EPTCS 265, 2018, pp. 67-81", "doi": "10.4204/EPTCS.265.6", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A parameterised Boolean equation system (PBES) is a set of equations that\ndefines sets satisfying the equations as the least and/or greatest\nfixed-points. Thus this system is regarded as a declarative program defining\npredicates, where a program execution returns whether a given ground atomic\nformula holds or not. The program execution corresponds to the membership\nproblem of PBESs, which is however undecidable in general.\n  This paper proposes a subclass of PBESs which expresses universal-quantifiers\nfree formulas, and studies a technique to solve the problem on it. We use the\nfact that the membership problem is reduced to the problem whether a proof\ngraph exists. To check the latter problem, we introduce a so-called dependency\nspace which is a graph containing all of the minimal proof graphs. Dependency\nspaces are, however, infinite in general. Thus, we propose some conditions for\nequivalence relations to preserve the result of the membership problem, then we\nidentify two vertices as the same under the relation. In this sense, dependency\nspaces possibly result in a finite graph. We show some examples having infinite\ndependency spaces which are reducible to finite graphs by equivalence\nrelations. We provide a procedure to construct finite dependency spaces and\nshow the soundness of the procedure. We also implement the procedure using an\nSMT solver and experiment on some examples including a downsized McCarthy 91\nfunction.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 02:06:59 GMT"}], "update_date": "2018-02-20", "authors_parsed": [["Nagae", "Yutaro", "", "Nagoya University"], ["Sakai", "Masahiko", "", "Nagoya University"]]}, {"id": "1802.06497", "submitter": "EPTCS", "authors": "Tomohiro Sasano (Nagoya University), Naoki Nishida (Nagoya\n  University), Masahiko Sakai (Nagoya University), Tomoya Ueyama (Nagoya\n  University)", "title": "Transforming Dependency Chains of Constrained TRSs into Bounded Monotone\n  Sequences of Integers", "comments": "In Proceedings WPTE 2017, arXiv:1802.05862", "journal-ref": "EPTCS 265, 2018, pp. 82-97", "doi": "10.4204/EPTCS.265.7", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the dependency pair framework for proving termination of rewriting\nsystems, polynomial interpretations are used to transform dependency chains\ninto bounded decreasing sequences of integers, and they play an important role\nfor the success of proving termination, especially for constrained rewriting\nsystems. In this paper, we show sufficient conditions of linear polynomial\ninterpretations for transforming dependency chains into bounded monotone (i.e.,\ndecreasing or increasing) sequences of integers. Such polynomial\ninterpretations transform rewrite sequences of the original system into\ndecreasing or increasing sequences independently of the transformation of\ndependency chains. When we transform rewrite sequences into increasing\nsequences, polynomial interpretations have non-positive coefficients for\nreducible positions of marked function symbols. We propose four DP processors\nparameterized by transforming dependency chains and rewrite sequences into\neither decreasing or increasing sequences of integers, respectively. We show\nthat such polynomial interpretations make us succeed in proving termination of\nthe McCarthy 91 function over the integers.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 02:07:13 GMT"}], "update_date": "2018-02-20", "authors_parsed": [["Sasano", "Tomohiro", "", "Nagoya University"], ["Nishida", "Naoki", "", "Nagoya\n  University"], ["Sakai", "Masahiko", "", "Nagoya University"], ["Ueyama", "Tomoya", "", "Nagoya\n  University"]]}, {"id": "1802.06575", "submitter": "Amaury Pouly", "authors": "Nathana\\\"el Fijalkow, Jo\\\"el Ouaknine, Amaury Pouly, Jo\\~ao\n  Sousa-Pinto, James Worrell", "title": "On the Decidability of Reachability in Linear Time-Invariant Systems", "comments": null, "journal-ref": null, "doi": "10.1145/3302504.3311796", "report-no": null, "categories": "math.OC cs.DM cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the decidability of state-to-state reachability in linear\ntime-invariant control systems over discrete time. We analyse this problem with\nrespect to the allowable control sets, which in general are assumed to be\ndefined by boolean combinations of linear inequalities. Decidability of the\nversion of the reachability problem in which control sets are affine subspaces\nof $\\mathbb{R}^n$ is a fundamental result in control theory. Our first result\nis that reachability is undecidable if the set of controls is a finite union of\naffine subspaces. We also consider versions of the reachability problem in\nwhich (i)~the set of controls consists of a single affine subspace together\nwith the origin and (ii)~the set of controls is a convex polytope. In these two\ncases we respectively show that the reachability problem is as hard as Skolem's\nProblem and the Positivity Problem for linear recurrence sequences (whose\ndecidability has been open for several decades). Our main contribution is to\nshow decidability of a version of the reachability problem in which control\nsets are convex polytopes, under certain spectral assumptions on the transition\nmatrix.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 10:11:55 GMT"}, {"version": "v2", "created": "Mon, 18 Feb 2019 10:54:43 GMT"}], "update_date": "2020-11-19", "authors_parsed": [["Fijalkow", "Nathana\u00ebl", ""], ["Ouaknine", "Jo\u00ebl", ""], ["Pouly", "Amaury", ""], ["Sousa-Pinto", "Jo\u00e3o", ""], ["Worrell", "James", ""]]}, {"id": "1802.06603", "submitter": "Frederic Blanqui", "authors": "Fr\\'ed\\'eric Blanqui (DEDUCTEAM, LSV)", "title": "Size-based termination of higher-order rewriting", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide a general and modular criterion for the termination of\nsimply-typed $\\lambda$ -calculus extended with function symbols defined by\nuser-defined rewrite rules. Following a work of Hughes, Pareto and Sabry for\nfunctions defined with a fixpoint operator and pattern-matching, several\ncriteria use typing rules for bounding the height of arguments in function\ncalls. In this paper, we extend this approach to rewriting-based function\ndefinitions and more general user-defined notions of size.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 12:11:12 GMT"}, {"version": "v2", "created": "Tue, 20 Feb 2018 13:06:17 GMT"}], "update_date": "2018-02-21", "authors_parsed": [["Blanqui", "Fr\u00e9d\u00e9ric", "", "DEDUCTEAM, LSV"]]}, {"id": "1802.06653", "submitter": "Emmanuel Hainry", "authors": "Emmanuel Hainry (CARTE), Romain P\\'echoux (CARTE)", "title": "A Type-Based Complexity Analysis of Object Oriented Programs", "comments": "Information and Computation, Elsevier, A Para\\^itre, pp.60", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A type system is introduced for a generic Object Oriented programming\nlanguage in order to infer resource upper bounds. A sound andcomplete\ncharacterization of the set of polynomial time computable functions is\nobtained. As a consequence, the heap-space and thestack-space requirements of\ntyped programs are also bounded polynomially. This type system is inspired by\nprevious works on ImplicitComputational Complexity, using tiering and\nnon-interference techniques. The presented methodology has several advantages.\nFirst, itprovides explicit big $O$ polynomial upper bounds to the programmer,\nhence its use could allow the programmer to avoid memory errors.Second, type\nchecking is decidable in polynomial time. Last, it has a good expressivity\nsince it analyzes most object oriented featureslike inheritance, overload,\noverride and recursion. Moreover it can deal with loops guarded by objects and\ncan also be extended tostatements that alter the control flow like break or\nreturn.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 14:46:36 GMT"}], "update_date": "2018-02-20", "authors_parsed": [["Hainry", "Emmanuel", "", "CARTE"], ["P\u00e9choux", "Romain", "", "CARTE"]]}, {"id": "1802.06660", "submitter": "S{\\l}awomir Lasota", "authors": "Piotr Hofman and S{\\l}awomir Lasota", "title": "Linear Equations with Ordered Data", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Following a recently considered generalization of linear equations to\nunordered data vectors, we perform a further generalization to ordered data\nvectors. These generalized equations naturally appear in the analysis of vector\naddition systems (or Petri nets) extended with ordered data. We show that\nnonnegative-integer solvability of linear equations is computationally\nequivalent (up to an exponential blowup) with the reachability problem for\n(plain) vector addition systems. This high complexity is surprising, and\ncontrasts with NP-completeness for unordered data vectors. Also surprisingly,\nwe achieve polynomial time complexity of the solvability problem when the\nnonnegative-integer restriction on solutions is dropped.\n", "versions": [{"version": "v1", "created": "Mon, 19 Feb 2018 15:02:11 GMT"}], "update_date": "2018-02-20", "authors_parsed": [["Hofman", "Piotr", ""], ["Lasota", "S\u0142awomir", ""]]}, {"id": "1802.07038", "submitter": "Uli Fahrenberg", "authors": "Uli Fahrenberg", "title": "Higher-Dimensional Timed Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new formalism of higher-dimensional timed automata, based on\nvan Glabbeek's higher-dimensional automata and Alur's timed automata. We prove\nthat their reachability is PSPACE-complete and can be decided using zone-based\nalgorithms. We also show how to use tensor products to combat state-space\nexplosion and how to extend the setting to higher-dimensional hybrid automata.\n", "versions": [{"version": "v1", "created": "Tue, 20 Feb 2018 10:06:31 GMT"}], "update_date": "2018-02-21", "authors_parsed": [["Fahrenberg", "Uli", ""]]}, {"id": "1802.07143", "submitter": "Henning Basold", "authors": "Henning Basold", "title": "Breaking the Loop: Recursive Proofs for Coinductive Predicates in\n  Fibrations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The purpose of this paper is to develop and study recursive proofs of\ncoinductive predicates. Such recursive proofs allow one to discover proof goals\nin the construction of a proof of a coinductive predicate, while still allowing\nthe use of up-to techniques. This approach lifts the burden to guess\ninvariants, like bisimulation relations, beforehand. Rather, they allow one to\nstart with the sought-after proof goal and develop the proof from there until a\npoint is reached, at which the proof can be closed through a recursion step.\nProofs given in this way are both easier to construct and to understand,\nsimilarly to proofs given in cyclic proof systems or by appealing parameterised\ncoinduction.\n  In this paper, we develop a framework for recursive proofs of coinductive\npredicates that are given through fibrational predicate liftings. This\nframework is built on the so-called later modality, which has made its\nappearance in type theoretic settings before. In particular, we show the\nsoundness and completeness of recursive proofs, we prove that compatible up-to\ntechniques can be used as inference rules in recursive proofs, and provide some\nillustrating examples.\n", "versions": [{"version": "v1", "created": "Tue, 20 Feb 2018 15:10:47 GMT"}], "update_date": "2018-02-21", "authors_parsed": [["Basold", "Henning", ""]]}, {"id": "1802.07284", "submitter": "Yanhong Annie Liu", "authors": "Yanhong A. Liu", "title": "Logic Programming Applications: What Are the Abstractions and\n  Implementations?", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI cs.DB cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article presents an overview of applications of logic programming,\nclassifying them based on the abstractions and implementations of logic\nlanguages that support the applications. The three key abstractions are join,\nrecursion, and constraint. Their essential implementations are for-loops, fixed\npoints, and backtracking, respectively. The corresponding kinds of applications\nare database queries, inductive analysis, and combinatorial search,\nrespectively. We also discuss language extensions and programming paradigms,\nsummarize example application problems by application areas, and touch on\nexample systems that support variants of the abstractions with different\nimplementations.\n", "versions": [{"version": "v1", "created": "Tue, 20 Feb 2018 19:04:14 GMT"}], "update_date": "2018-02-23", "authors_parsed": [["Liu", "Yanhong A.", ""]]}, {"id": "1802.07320", "submitter": "Thorsten Wissmann", "authors": "Benedetto Intrigila and Giulio Manzonetto and Andrew Polonsky", "title": "Degrees of extensionality in the theory of B\\\"ohm trees and Sall\\'e's\n  conjecture", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 1 (January\n  29, 2019) lmcs:5133", "doi": "10.23638/LMCS-15(1:6)2019", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The main observational equivalences of the untyped lambda-calculus have been\ncharacterized in terms of extensional equalities between B\\\"ohm trees. It is\nwell known that the lambda-theory H*, arising by taking as observables the head\nnormal forms, equates two lambda-terms whenever their B\\\"ohm trees are equal up\nto countably many possibly infinite eta-expansions. Similarly, two lambda-terms\nare equal in Morris's original observational theory H+, generated by\nconsidering as observable the beta-normal forms, whenever their B\\\"ohm trees\nare equal up to countably many finite eta-expansions.\n  The lambda-calculus also possesses a strong notion of extensionality called\n\"the omega-rule\", which has been the subject of many investigations. It is a\nlongstanding open problem whether the equivalence B-omega obtained by closing\nthe theory of B\\\"ohm trees under the omega-rule is strictly included in H+, as\nconjectured by Sall\\'e in the seventies. In this paper we demonstrate that the\ntwo aforementioned theories actually coincide, thus disproving Sall\\'e's\nconjecture.\n  The proof technique we develop for proving the latter inclusion is general\nenough to provide as a byproduct a new characterization, based on bounded\neta-expansions, of the least extensional equality between B\\\"ohm trees.\nTogether, these results provide a taxonomy of the different degrees of\nextensionality in the theory of B\\\"ohm trees.\n", "versions": [{"version": "v1", "created": "Tue, 20 Feb 2018 20:44:14 GMT"}, {"version": "v2", "created": "Wed, 5 Dec 2018 12:54:12 GMT"}, {"version": "v3", "created": "Sat, 26 Jan 2019 19:42:05 GMT"}], "update_date": "2019-04-29", "authors_parsed": [["Intrigila", "Benedetto", ""], ["Manzonetto", "Giulio", ""], ["Polonsky", "Andrew", ""]]}, {"id": "1802.07366", "submitter": "Ale\\v{s} Bizjak", "authors": "Radu Mardare, Prakash Panangaden, and Gordon D. Plotkin", "title": "Free complete Wasserstein algebras", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 14, Issue 3 (September\n  14, 2018) lmcs:4826", "doi": "10.23638/LMCS-14(3:19)2018", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present an algebraic account of the Wasserstein distances $W_p$ on\ncomplete metric spaces, for $p \\geq 1$. This is part of a program of a\nquantitative algebraic theory of effects in programming languages. In\nparticular, we give axioms, parametric in $p$, for algebras over metric spaces\nequipped with probabilistic choice operations. The axioms say that the\noperations form a barycentric algebra and that the metric satisfies a property\ntypical of the Wasserstein distance $W_p$. We show that the free complete such\nalgebra over a complete metric space is that of the Radon probability measures\nwith finite moments of order $p$, equipped with the Wasserstein distance as\nmetric and with the usual binary convex sums as operations.\n", "versions": [{"version": "v1", "created": "Tue, 20 Feb 2018 22:51:07 GMT"}, {"version": "v2", "created": "Mon, 2 Jul 2018 15:57:00 GMT"}, {"version": "v3", "created": "Mon, 13 Aug 2018 01:35:13 GMT"}, {"version": "v4", "created": "Thu, 13 Sep 2018 08:59:38 GMT"}], "update_date": "2018-09-19", "authors_parsed": [["Mardare", "Radu", ""], ["Panangaden", "Prakash", ""], ["Plotkin", "Gordon D.", ""]]}, {"id": "1802.07435", "submitter": "M. Praveen", "authors": "Diego Figueira, Anirban Majumdar and M. Praveen", "title": "Playing with Repetitions in Data Words Using Energy Games", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 3 (July 3,\n  2020) lmcs:6614", "doi": "10.23638/LMCS-16(3:1)2020", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce two-player games which build words over infinite alphabets, and\nwe study the problem of checking the existence of winning strategies. These\ngames are played by two players, who take turns in choosing valuations for\nvariables ranging over an infinite data domain, thus generating\nmulti-attributed data words. The winner of the game is specified by formulas in\nthe Logic of Repeating Values, which can reason about repetitions of data\nvalues in infinite data words. We prove that it is undecidable to check if one\nof the players has a winning strategy, even in very restrictive settings.\nHowever, we prove that if one of the players is restricted to choose valuations\nranging over the Boolean domain, the games are effectively equivalent to\nsingle-sided games on vector addition systems with states (in which one of the\nplayers can change control states but cannot change counter values), known to\nbe decidable and effectively equivalent to energy games.\n  Previous works have shown that the satisfiability problem for various\nvariants of the logic of repeating values is equivalent to the reachability and\ncoverability problems in vector addition systems. Our results raise this\nconnection to the level of games, augmenting further the associations between\nlogics on data words and counter systems.\n", "versions": [{"version": "v1", "created": "Wed, 21 Feb 2018 06:15:55 GMT"}, {"version": "v2", "created": "Wed, 25 Apr 2018 11:23:59 GMT"}, {"version": "v3", "created": "Wed, 17 Oct 2018 06:11:38 GMT"}, {"version": "v4", "created": "Thu, 18 Oct 2018 06:04:09 GMT"}, {"version": "v5", "created": "Fri, 25 Oct 2019 10:27:19 GMT"}, {"version": "v6", "created": "Sun, 31 May 2020 06:19:24 GMT"}, {"version": "v7", "created": "Thu, 2 Jul 2020 08:33:29 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Figueira", "Diego", ""], ["Majumdar", "Anirban", ""], ["Praveen", "M.", ""]]}, {"id": "1802.07508", "submitter": "Marianna Nicolosi Asmundo", "authors": "Domenico Cantone, Marianna Nicolosi-Asmundo, Ewa Or{\\l}owska", "title": "A Dual Tableau-based Decision Procedure for a Relational Logic with the\n  Universal Relation (Extended Version)", "comments": "Extended version of the conference paper: D. Cantone, M.\n  Nicolosi-Asmundo, E. Or{\\l}owska. A Dual Tableau-based Decision Procedure for\n  a Relational Logic with the Universal Relation. In Proceedings of the 29th\n  Italian Conference on Computational Logic, Torino, Italy, June 16-18, 2014.\n  CEUR Workshop Proceedings Vol. 1195, pp. 194-209 (2014)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We present a first result towards the use of entailment in- side relational\ndual tableau-based decision procedures. To this end, we introduce a fragment of\nRL(1) which admits a restricted form of composition, (R ; S) or (R ; 1), where\nthe left subterm R of (R ; S) is only allowed to be either the constant 1, or a\nBoolean term neither containing the complement operator nor the constant 1,\nwhile in the case of (R ; 1), R can only be a Boolean term involving relational\nvariables and the operators of intersection and of union. We prove the\ndecidability of the fragment by defining a dual tableau- based decision\nprocedure with a suitable blocking mechanism and where the rules to decompose\ncompositional formulae are modified so to deal with the constant 1 while\npreserving termination. The fragment properly includes the logics presented in\nprevious work and, therefore, it allows one to express, among others, the\nmulti-modal logic K with union and intersection of accessibility relations, and\nthe description logic ALC with union and intersection of roles.\n", "versions": [{"version": "v1", "created": "Wed, 21 Feb 2018 10:57:05 GMT"}], "update_date": "2018-02-22", "authors_parsed": [["Cantone", "Domenico", ""], ["Nicolosi-Asmundo", "Marianna", ""], ["Or\u0142owska", "Ewa", ""]]}, {"id": "1802.07551", "submitter": "Kuize Zhang", "authors": "Kuize Zhang and Alessandro Giua", "title": "On detectability of labeled Petri nets and finite automata", "comments": "44 pages, 21 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.OC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study detectability properties for labeled Petri nets and finite automata.\nWe first study weak approximate detectability (WAD) that implies that there\nexists an infinite observed output sequence of the system such that each prefix\nof the output sequence with length greater than a given value allows an\nobserver to determine if the current state belongs to a given set. We also\nconsider two new concepts called instant strong detectability (ISD) and\neventual strong detectability (ESD). The former property implies that for each\npossible infinite observed output sequence each prefix of the output sequence\nallows reconstructing the current state. The latter implies that for each\npossible infinite observed output sequence, there exists a value such that each\nprefix of the output sequence with length greater than that value allows\nreconstructing the current state.\n  Results: WAD: undecidable for labeled Petri nets, PSPACE-complete for finite\nautomata ISD: decidable and EXPSPACE-hard for labeled Petri nets, belongs to P\nfor finite automata ESD: decidable under promptness assumption and\nEXPSPACE-hard for labeled Petri nets, belongs to P for finite automata SD:\nbelongs to P for finite automata, strengthens Shu and Lin's 2011 results based\non two assumptions of deadlock-freeness and promptness ISD<SD<ESD<WD<WAD for\nboth labeled Petri nets and finite automata\n", "versions": [{"version": "v1", "created": "Wed, 21 Feb 2018 13:04:56 GMT"}, {"version": "v2", "created": "Sun, 6 May 2018 11:26:57 GMT"}, {"version": "v3", "created": "Sat, 9 Mar 2019 19:06:26 GMT"}, {"version": "v4", "created": "Sun, 30 Jun 2019 13:16:33 GMT"}], "update_date": "2019-07-02", "authors_parsed": [["Zhang", "Kuize", ""], ["Giua", "Alessandro", ""]]}, {"id": "1802.07612", "submitter": "S{\\l}awomir Lasota", "authors": "S{\\l}awomir Lasota and Rados{\\l}aw Pi\\'orkowski", "title": "WQO dichotomy for 3-graphs", "comments": null, "journal-ref": null, "doi": "10.1016/j.ic.2020.104541", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate data-enriched models, like Petri nets with data, where\nexecutability of a transition is conditioned by a relation between data values\ninvolved. Decidability status of various decision problems in such models may\ndepend on the structure of data domain. According to the WQO Dichotomy\nConjecture, if a data domain is homogeneous then it either exhibits a well\nquasi-order (in which case decidability follows by standard arguments), or\nessentially all the decision problems are undecidable for Petri nets over that\ndata domain. We confirm the conjecture for data domains being 3-graphs (graphs\nwith 2-colored edges). On the technical level, this results is a significant\nstep beyond known classification results for homogeneous structures.\n", "versions": [{"version": "v1", "created": "Wed, 21 Feb 2018 15:25:10 GMT"}, {"version": "v2", "created": "Tue, 27 Feb 2018 11:08:26 GMT"}, {"version": "v3", "created": "Sun, 8 Mar 2020 09:58:57 GMT"}], "update_date": "2020-03-10", "authors_parsed": [["Lasota", "S\u0142awomir", ""], ["Pi\u00f3rkowski", "Rados\u0142aw", ""]]}, {"id": "1802.07830", "submitter": "Ana Sokolova", "authors": "Ana Sokolova and Harald Woracek", "title": "Proper Semirings and Proper Convex Functors", "comments": "FoSSaCS 2018 full version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Esik and Maletti introduced the notion of a proper semiring and proved that\nsome important (classes of) semirings -- Noetherian semirings, natural numbers\n-- are proper. Properness matters as the equivalence problem for weighted\nautomata over a semiring which is proper and finitely and effectively presented\nis decidable. Milius generalised the notion of properness from a semiring to a\nfunctor. As a consequence, a semiring is proper if and only if its associated\n\"cubic functor\" is proper. Moreover, properness of a functor renders soundness\nand completeness proofs for axiomatizations of equivalent behaviour.\n  In this paper we provide a method for proving properness of functors, and\ninstantiate it to cover both the known cases and several novel ones: (1)\nproperness of the semirings of positive rationals and positive reals, via\nproperness of the corresponding cubic functors; and (2) properness of two\nfunctors on (positive) convex algebras. The latter functors are important for\naxiomatizing trace equivalence of probabilistic transition systems. Our proofs\nrely on results that stretch all the way back to Hilbert and Minkowski.\n", "versions": [{"version": "v1", "created": "Wed, 21 Feb 2018 22:10:37 GMT"}, {"version": "v2", "created": "Sat, 24 Feb 2018 08:35:07 GMT"}], "update_date": "2018-02-27", "authors_parsed": [["Sokolova", "Ana", ""], ["Woracek", "Harald", ""]]}, {"id": "1802.07966", "submitter": "Arindam Mitra", "authors": "Arindam Mitra and Chitta Baral", "title": "Incremental and Iterative Learning of Answer Set Programs from Mutually\n  Distinct Examples", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Over the years the Artificial Intelligence (AI) community has produced\nseveral datasets which have given the machine learning algorithms the\nopportunity to learn various skills across various domains. However, a subclass\nof these machine learning algorithms that aimed at learning logic programs,\nnamely the Inductive Logic Programming algorithms, have often failed at the\ntask due to the vastness of these datasets. This has impacted the usability of\nknowledge representation and reasoning techniques in the development of AI\nsystems. In this research, we try to address this scalability issue for the\nalgorithms that learn answer set programs. We present a sound and complete\nalgorithm which takes the input in a slightly different manner and performs an\nefficient and more user controlled search for a solution. We show via\nexperiments that our algorithm can learn from two popular datasets from machine\nlearning community, namely bAbl (a question answering dataset) and MNIST (a\ndataset for handwritten digit recognition), which to the best of our knowledge\nwas not previously possible. The system is publicly available at\nhttps://goo.gl/KdWAcV. This paper is under consideration for acceptance in\nTPLP.\n", "versions": [{"version": "v1", "created": "Thu, 22 Feb 2018 10:22:58 GMT"}, {"version": "v2", "created": "Tue, 1 May 2018 14:42:15 GMT"}], "update_date": "2018-05-02", "authors_parsed": [["Mitra", "Arindam", ""], ["Baral", "Chitta", ""]]}, {"id": "1802.08064", "submitter": "Philipp J. Meyer", "authors": "Philipp J. Meyer, Javier Esparza, Hagen V\\\"olzer", "title": "Computing the concurrency threshold of sound free-choice workflow nets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Workflow graphs extend classical flow charts with concurrent fork and join\nnodes. They constitute the core of business processing languages such as BPMN\nor UML Activity Diagrams. The activities of a workflow graph are executed by\nhumans or machines, generically called resources. If concurrent activities\ncannot be executed in parallel by lack of resources, the time needed to execute\nthe workflow increases. We study the problem of computing the minimal number of\nresources necessary to fully exploit the concurrency of a given workflow, and\nexecute it as fast as possible (i.e., as fast as with unlimited resources).\n  We model this problem using free-choice Petri nets, which are known to be\nequivalent to workflow graphs. We analyze the computational complexity of two\nversions of the problem: computing the resource and concurrency thresholds. We\nuse the results to design an algorithm to approximate the concurrency\nthreshold, and evaluate it on a benchmark suite of 642 industrial examples. We\nshow that it performs very well in practice: It always provides the exact\nvalue, and never takes more than 30 milliseconds for any workflow, even for\nthose with a huge number of reachable markings.\n", "versions": [{"version": "v1", "created": "Thu, 22 Feb 2018 14:40:47 GMT"}], "update_date": "2018-02-23", "authors_parsed": [["Meyer", "Philipp J.", ""], ["Esparza", "Javier", ""], ["V\u00f6lzer", "Hagen", ""]]}, {"id": "1802.08070", "submitter": "Thorsten Wi{\\ss}mann", "authors": "Stefan Milius, Dirk Pattinson, Thorsten Wi{\\ss}mann", "title": "A New Foundation for Finitary Corecursion and Iterative Algebras", "comments": "Extended journal version of arXiv:1601.01532", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper contributes to a theory of the behaviour of \"finite-state\" systems\nthat is generic in the system type. We propose that such systems are modelled\nas coalgebras with a finitely generated carrier for an endofunctor on a locally\nfinitely presentable category. Their behaviour gives rise to a new fixpoint of\nthe coalgebraic type functor called locally finite fixpoint (LFF). We prove\nthat if the given endofunctor is finitary and preserves monomorphisms then the\nLFF always exists and is a subcoalgebra of the final coalgebra (unlike the\nrational fixpoint previously studied by Ad\\'amek, Milius, and Velebil).\nMoreover, we show that the LFF is characterized by two universal properties:\n(1) as the final locally finitely generated coalgebra, and (2) as the initial\nfg-iterative algebra. As instances of the LFF we first obtain the known\ninstances of the rational fixpoint, e.g. regular languages, rational streams\nand formal power-series, regular trees etc. Moreover, we obtain a number of new\nexamples, e.g. (realtime deterministic resp. non-deterministic) context-free\nlanguages, constructively S-algebraic formal power-series (in general, the\nbehaviour of finite coalgebras under the coalgebraic language semantics arising\nfrom the generalized powerset construction by Silva, Bonchi, Bonsangue, and\nRutten), and the monad of Courcelle's algebraic trees.\n", "versions": [{"version": "v1", "created": "Wed, 21 Feb 2018 03:18:25 GMT"}, {"version": "v2", "created": "Tue, 7 May 2019 09:48:13 GMT"}, {"version": "v3", "created": "Fri, 6 Sep 2019 16:42:12 GMT"}], "update_date": "2019-09-09", "authors_parsed": [["Milius", "Stefan", ""], ["Pattinson", "Dirk", ""], ["Wi\u00dfmann", "Thorsten", ""]]}, {"id": "1802.08437", "submitter": "Nao Hirokawa", "authors": "Nao Hirokawa, Aart Middeldorp, Christian Sternagel, Sarah Winkler", "title": "Abstract Completion, Formalized", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 3 (August\n  21, 2019) lmcs:5701", "doi": "10.23638/LMCS-15(3:19)2019", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Completion is one of the most studied techniques in term rewriting and\nfundamental to automated reasoning with equalities. In this paper we present\nnew correctness proofs of abstract completion, both for finite and infinite\nruns. For the special case of ground completion we present a new proof based on\nrandom descent. We moreover extend the results to ordered completion, an\nimportant extension of completion that aims to produce ground-complete\npresentations of the initial equations. We present new proofs concerning the\ncompleteness of ordered completion for two settings. Moreover, we revisit and\nextend results of M\\'etivier concerning canonicity of rewrite systems. All\nproofs presented in the paper have been formalized in Isabelle/HOL.\n", "versions": [{"version": "v1", "created": "Fri, 23 Feb 2018 08:21:29 GMT"}, {"version": "v2", "created": "Fri, 5 Apr 2019 04:13:49 GMT"}, {"version": "v3", "created": "Wed, 24 Jul 2019 05:38:38 GMT"}, {"version": "v4", "created": "Tue, 20 Aug 2019 14:24:24 GMT"}], "update_date": "2019-10-23", "authors_parsed": [["Hirokawa", "Nao", ""], ["Middeldorp", "Aart", ""], ["Sternagel", "Christian", ""], ["Winkler", "Sarah", ""]]}, {"id": "1802.08454", "submitter": "Christoph Benzm\\\"uller", "authors": "Christoph Benzm\\\"uller and Ali Farjami and Xavier Parent", "title": "Faithful Semantical Embedding of a Dyadic Deontic Logic in HOL", "comments": "23 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A shallow semantical embedding of a dyadic deontic logic by Carmo and Jones\nin classical higher-order logic is presented. This embedding is proven sound\nand complete, that is, faithful.\n  The work presented here provides the theoretical foundation for the\nimplementation and automation of dyadic deontic logic within off-the-shelf\nhigher-order theorem provers and proof assistants.\n", "versions": [{"version": "v1", "created": "Fri, 23 Feb 2018 09:24:26 GMT"}, {"version": "v2", "created": "Mon, 5 Mar 2018 17:19:02 GMT"}], "update_date": "2018-03-06", "authors_parsed": [["Benzm\u00fcller", "Christoph", ""], ["Farjami", "Ali", ""], ["Parent", "Xavier", ""]]}, {"id": "1802.08469", "submitter": "Nicolas Markey", "authors": "A. R. Balasubramanian, Nathalie Bertrand, Nicolas Markey", "title": "Parameterized verification of synchronization in constrained\n  reconfigurable broadcast networks", "comments": "Accepted for publication in TACAS 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DC cs.FL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  Reconfigurable broadcast networks provide a convenient formalism for\nmodelling and reasoning about networks of mobile agents broadcasting messages\nto other agents following some (evolving) communication topology. The\nparameterized verification of such models aims at checking whether a given\nproperty holds irrespective of the initial configuration (number of agents,\ninitial states and initial communication topology). We focus here on the\nsynchronization property, asking whether all agents converge to a set of target\nstates after some execution. This problem is known to be decidable in\npolynomial time when no constraints are imposed on the evolution of the\ncommunication topology (while it is undecidable for static broadcast networks).\n  In this paper we investigate how various constraints on reconfigurations\naffect the decidability and complexity of the synchronization problem. In\nparticular, we show that when bounding the number of reconfigured links between\ntwo communications steps by a constant, synchronization becomes undecidable; on\nthe other hand, synchronization remains decidable in PTIME when the bound grows\nwith the number of agents.\n", "versions": [{"version": "v1", "created": "Fri, 23 Feb 2018 10:17:50 GMT"}], "update_date": "2018-02-26", "authors_parsed": [["Balasubramanian", "A. R.", ""], ["Bertrand", "Nathalie", ""], ["Markey", "Nicolas", ""]]}, {"id": "1802.08500", "submitter": "Thorsten Wissmann", "authors": "Khadijeh Keshvardoost and Bartek Klin and S{\\l}awomir Lasota and\n  Joanna Ochremiak and Szymon Toru\\'nczyk", "title": "Definable isomorphism problem", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 4 (December\n  11, 2019) lmcs:5963", "doi": "10.23638/LMCS-15(4:14)2019", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We investigate the isomorphism problem in the setting of definable sets\n(equivalent to sets with atoms): given two definable relational structures, are\nthey related by a definable isomorphism? Under mild assumptions on the\nunderlying structure of atoms, we prove decidability of the problem. The core\nresult is parameter-elimination: existence of an isomorphism definable with\nparameters implies existence of an isomorphism definable without parameters.\n", "versions": [{"version": "v1", "created": "Fri, 23 Feb 2018 12:21:24 GMT"}, {"version": "v2", "created": "Thu, 7 Nov 2019 12:43:12 GMT"}, {"version": "v3", "created": "Tue, 10 Dec 2019 15:48:48 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Keshvardoost", "Khadijeh", ""], ["Klin", "Bartek", ""], ["Lasota", "S\u0142awomir", ""], ["Ochremiak", "Joanna", ""], ["Toru\u0144czyk", "Szymon", ""]]}, {"id": "1802.08588", "submitter": "Zuzana Hanikov\\'a", "authors": "Zuzana Hanikov\\'a", "title": "Implicit definability of truth constants in {\\L}ukasiewicz logic", "comments": "presented at ManyVal 2017; submitted to Soft Computing journal", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  In the framework of propositional {\\L}ukasiewicz logic, a suitable notion of\nimplicit definability, tailored to the intended real-valued semantics and\nreferring to the elements of its domain, is introduced. Several variants of\nimplicitly defining each of the rational elements in the standard semantics are\nexplored, and based on that, a faithful interpretation of theories in Rational\nPavelka logic in theories in {\\L}ukasiewicz logic is obtained. Some of these\nresults were already presented in H\\'ajek's \"Metamathematics of Fuzzy Logic\" as\ntechnical statements. A connection to the lack of (deductive) Beth property in\n{\\L}ukasiewicz logic is drawn. Moreover, while irrational elements of the\nstandard semantics are not implicitly definable by finitary means, a parallel\ndevelopment is possible for them in the infinitary {\\L}ukasiewicz logic. As an\napplication of definability of the rationals, it is shown how computational\ncomplexity results for Rational Pavelka logic can be obtained from analogous\nresults for {\\L}ukasiewicz logic. The complexity of the definability notion\nitself is studied as well. Finally, we review the import of these results for\nthe precision/vagueness discussion for fuzzy logic, and for the general\nstanding of truth constants in {\\L}ukasiewicz logic.\n", "versions": [{"version": "v1", "created": "Fri, 23 Feb 2018 15:19:47 GMT"}], "update_date": "2018-02-26", "authors_parsed": [["Hanikov\u00e1", "Zuzana", ""]]}, {"id": "1802.08641", "submitter": "Benedikt Bollig", "authors": "Benedikt Bollig, Marie Fortin and Paul Gastin", "title": "Gossiping in Message-Passing Systems", "comments": "subsumed by arXiv:1804.10076", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the gossip problem in a message-passing environment: When a process\nreceives a message, it has to decide whether the sender has more recent\ninformation on other processes than itself. This problem is at the heart of\nmany distributed algorithms, and it is tightly related to questions from formal\nmethods concerning the expressive power of distributed automata. We provide a\nnon-deterministic gossip protocol for message-passing systems with unbounded\nFIFO channels, using only finitely many local states and a finite message\nalphabet. We show that this is optimal in the sense that there is no\ndeterministic counterpart. As an application, the gossip protocol allows us to\nshow that message-passing systems capture well-known extensions of linear-time\ntemporal logics to a concurrent setting.\n", "versions": [{"version": "v1", "created": "Fri, 23 Feb 2018 17:00:35 GMT"}, {"version": "v2", "created": "Fri, 27 Apr 2018 08:53:38 GMT"}], "update_date": "2018-04-30", "authors_parsed": [["Bollig", "Benedikt", ""], ["Fortin", "Marie", ""], ["Gastin", "Paul", ""]]}, {"id": "1802.08756", "submitter": "Sergey Goncharov", "authors": "Sergey Goncharov and Lutz Schr\\\"oder", "title": "Guarded Traced Categories", "comments": "full version with appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Notions of guardedness serve to delineate the admissibility of cycles, e.g.\nin recursion, corecursion, iteration, or tracing. We introduce an abstract\nnotion of guardedness structure on a symmetric monoidal category, along with a\ncorresponding notion of guarded traces, which are defined only if the cycles\nthey induce are guarded. We relate structural guardedness, determined by\npropagating guardedness along the operations of the category, to geometric\nguardedness phrased in terms of a diagrammatic language. In our setup, the\nCartesian case (recursion) and the co-Cartesian case (iteration) become\ncompletely dual, and we show that in these cases, guarded tracedness is\nequivalent to presence of a guarded Conway operator, in analogy to an\nobservation on total traces by Hasegawa and Hyland. Moreover, we relate guarded\ntraces to unguarded categorical uniform fixpoint operators in the style of\nSimpson and Plotkin. Finally, we show that partial traces based on\nHilbert-Schmidt operators in the category of Hilbert spaces are an instance of\nguarded traces.\n", "versions": [{"version": "v1", "created": "Fri, 23 Feb 2018 22:53:25 GMT"}], "update_date": "2018-02-27", "authors_parsed": [["Goncharov", "Sergey", ""], ["Schr\u00f6der", "Lutz", ""]]}, {"id": "1802.09084", "submitter": "Alexandre Goy", "authors": "Alexandre Goy", "title": "Trace semantics via determinization for probabilistic transition systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A coalgebraic definition of finite and infinite trace semantics for\nprobabilistic transition systems has recently been given using a certain\nKleisli category. In this paper this semantics is developed using a coalgebraic\nmethod which is an instance of general determinization. Once applied to\ndiscrete systems, this point of view allows the exploitation of the\ndeterminized structure by up-to techniques. Thereby it becomes possible to\nalgorithmically check the equivalence of two finite probabilistic transition\nsystems.\n", "versions": [{"version": "v1", "created": "Sun, 25 Feb 2018 21:26:22 GMT"}], "update_date": "2018-02-27", "authors_parsed": [["Goy", "Alexandre", ""]]}, {"id": "1802.09182", "submitter": "Rob van Glabbeek", "authors": "Rob van Glabbeek", "title": "On the Validity of Encodings of the Synchronous in the Asynchronous\n  $\\pi$-calculus", "comments": "Various minor improvements following IPL refereeing. Section 5 does\n  not appear in IPL", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Process calculi may be compared in their expressive power by means of\nencodings between them. A widely accepted definition of what constitutes a\nvalid encoding for (dis)proving relative expressiveness results between process\ncalculi was proposed by Gorla. Prior to this work, diverse encodability and\nseparation results were generally obtained using distinct, and often\nincompatible, quality criteria on encodings.\n  Textbook examples of valid encoding are the encodings proposed by Boudol and\nby Honda & Tokoro of the synchronous choice-free $\\pi$-calculus into its\nasynchronous fragment, illustrating that the latter is no less expressive than\nthe former. Here I formally establish that these encodings indeed satisfy\nGorla's criteria.\n", "versions": [{"version": "v1", "created": "Mon, 26 Feb 2018 06:58:39 GMT"}, {"version": "v2", "created": "Thu, 26 Apr 2018 07:28:40 GMT"}], "update_date": "2018-04-27", "authors_parsed": [["van Glabbeek", "Rob", ""]]}, {"id": "1802.09240", "submitter": "Minghui Ma", "authors": "Zhe Lin and Minghui Ma", "title": "The Finite Model Property of Quasi-transitive Modal Logic", "comments": "11 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The finite model property of quasi-transitive modal logic\n$\\mathsf{K}_2^3=\\mathsf{K}\\oplus \\Box\\Box p\\rightarrow \\Box\\Box\\Box p$ is\nestablished. This modal logic is conservatively extended to the tense logic\n$\\mathsf{Kt}_2^3$. We present a Gentzen sequent calculus $\\mathsf{G}$ for\n$\\mathsf{Kt}_2^3$. The sequent calculus $\\mathsf{G}$ has the finite algebra\nproperty by a finite syntactic construction. It follows that $\\mathsf{Kt}_2^3$\nand $\\mathsf{K}_2^3$ have the finite model property.\n", "versions": [{"version": "v1", "created": "Mon, 26 Feb 2018 10:35:11 GMT"}, {"version": "v2", "created": "Thu, 22 Mar 2018 03:29:15 GMT"}, {"version": "v3", "created": "Fri, 22 Feb 2019 08:22:02 GMT"}], "update_date": "2019-02-25", "authors_parsed": [["Lin", "Zhe", ""], ["Ma", "Minghui", ""]]}, {"id": "1802.09263", "submitter": "Shaull Almagor", "authors": "Shaull Almagor, Dmitry Chistikov, Jo\\\"el Ouaknine and James Worrell", "title": "O-Minimal Invariants for Discrete-Time Dynamical Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO math.AG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Termination analysis of linear loops plays a key r\\^{o}le in several areas of\ncomputer science, including program verification and abstract interpretation.\nAlready for the simplest variants of linear loops the question of termination\nrelates to deep open problems in number theory, such as the decidability of the\nSkolem and Positivity Problems for linear recurrence sequences, or equivalently\nreachability questions for discrete-time linear dynamical systems. In this\npaper, we introduce the class of \\emph{o-minimal invariants}, which is broader\nthan any previously considered, and study the decidability of the existence and\nalgorithmic synthesis of such invariants as certificates of non-termination for\nlinear loops equipped with a large class of halting conditions. We establish\ntwo main decidability results, one of them conditional on Schanuel's conjecture\nin transcendental number theory.\n", "versions": [{"version": "v1", "created": "Mon, 26 Feb 2018 12:04:06 GMT"}, {"version": "v2", "created": "Mon, 11 May 2020 18:37:43 GMT"}], "update_date": "2020-05-13", "authors_parsed": [["Almagor", "Shaull", ""], ["Chistikov", "Dmitry", ""], ["Ouaknine", "Jo\u00ebl", ""], ["Worrell", "James", ""]]}, {"id": "1802.09377", "submitter": "Thorsten Wissmann", "authors": "Erich Gr\\\"adel and Martin Grohe and Benedikt Pago and Wied Pakusa", "title": "A Finite-Model-Theoretic View on Propositional Proof Complexity", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 1 (January\n  23, 2019) lmcs:5119", "doi": "10.23638/LMCS-15(1:4)2019", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We establish new, and surprisingly tight, connections between propositional\nproof complexity and finite model theory. Specifically, we show that the power\nof several propositional proof systems, such as Horn resolution, bounded-width\nresolution, and the polynomial calculus of bounded degree, can be characterised\nin a precise sense by variants of fixed-point logics that are of fundamental\nimportance in descriptive complexity theory. Our main results are that Horn\nresolution has the same expressive power as least fixed-point logic, that\nbounded-width resolution captures existential least fixed-point logic, and that\nthe polynomial calculus with bounded degree over the rationals solves precisely\nthe problems definable in fixed-point logic with counting. By exploring these\nconnections further, we establish finite-model-theoretic tools for proving\nlower bounds for the polynomial calculus over the rationals and over finite\nfields.\n", "versions": [{"version": "v1", "created": "Mon, 26 Feb 2018 15:07:07 GMT"}, {"version": "v2", "created": "Tue, 21 Aug 2018 13:52:45 GMT"}, {"version": "v3", "created": "Mon, 21 Jan 2019 12:04:50 GMT"}], "update_date": "2019-04-29", "authors_parsed": [["Gr\u00e4del", "Erich", ""], ["Grohe", "Martin", ""], ["Pago", "Benedikt", ""], ["Pakusa", "Wied", ""]]}, {"id": "1802.09687", "submitter": "Saksham Chand", "authors": "Saksham Chand, Yanhong A. Liu", "title": "Simpler Specifications and Easier Proofs of Distributed Algorithms Using\n  History Variables", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies specifications and proofs of distributed algorithms when\nonly message history variables are used, using the Basic Paxos and Multi-Paxos\nalgorithms for distributed consensus as precise case studies. We show that not\nusing and maintaining other state variables yields simpler specifications that\nare more declarative and easier to understand. It also allows easier proofs to\nbe developed by needing fewer invariants and facilitating proof derivations.\nFurthermore, the proofs are mechanically checked more efficiently.\n  We show that specifications in TLA+, Lamport's temporal logic of actions, and\nproofs in TLAPS, the TLA+ Proof System (TLAPS) are reduced by a quarter or more\nfor single-value Paxos and by about half or more for multi-value Paxos. Overall\nwe need about half as many manually written invariants and proof obligations.\nOur proof for Basic Paxos takes about 25% less time for TLAPS to check, and our\nproofs for Multi-Paxos are checked within 1.5 minutes whereas prior proofs fail\nto be checked by TLAPS.\n", "versions": [{"version": "v1", "created": "Tue, 27 Feb 2018 02:13:49 GMT"}, {"version": "v2", "created": "Wed, 19 Dec 2018 18:30:52 GMT"}, {"version": "v3", "created": "Mon, 23 Dec 2019 22:38:38 GMT"}], "update_date": "2020-06-30", "authors_parsed": [["Chand", "Saksham", ""], ["Liu", "Yanhong A.", ""]]}, {"id": "1802.09737", "submitter": "EPTCS", "authors": "Bob Coecke, Aleks Kissinger", "title": "Proceedings 14th International Conference on Quantum Physics and Logic", "comments": null, "journal-ref": "EPTCS 266, 2018", "doi": "10.4204/EPTCS.266", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the 14th International Conference on\nQuantum Physics and Logic (QPL 2017), which was held July 3-7, 2017 at the LUX\nCinema Nijmegen, the Netherlands, and was hosted by Radboud University. QPL is\na conference that brings together researchers working on mathematical\nfoundations of quantum physics, quantum computing, and related areas, with a\nfocus on structural perspectives and the use of logical tools, ordered\nalgebraic and category-theoretic structures, formal languages, semantical\nmethods, and other computer science techniques applied to the study of physical\nbehaviour in general. This conference also welcomes work that applies\nstructures and methods inspired by quantum theory to other fields (including\ncomputer science).\n", "versions": [{"version": "v1", "created": "Tue, 27 Feb 2018 06:25:29 GMT"}], "update_date": "2018-02-28", "authors_parsed": [["Coecke", "Bob", ""], ["Kissinger", "Aleks", ""]]}, {"id": "1802.10331", "submitter": "Berit Gru{\\ss}ien", "authors": "Berit Gru{\\ss}ien", "title": "Capturing Logarithmic Space and Polynomial Time on Chordal Claw-Free\n  Graphs", "comments": "34 pages, 13 figures", "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 3 (July 8,\n  2019) lmcs:5612", "doi": "10.23638/LMCS-15(3:2)2019", "report-no": null, "categories": "cs.LO cs.DM", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We show that the class of chordal claw-free graphs admits LREC$_=$-definable\ncanonization. LREC$_=$ is a logic that extends first-order logic with counting\nby an operator that allows it to formalize a limited form of recursion. This\noperator can be evaluated in logarithmic space. It follows that there exists a\nlogarithmic-space canonization algorithm, and therefore a logarithmic-space\nisomorphism test, for the class of chordal claw-free graphs. As a further\nconsequence, LREC$_=$ captures logarithmic space on this graph class. Since\nLREC$_=$ is contained in fixed-point logic with counting, we also obtain that\nfixed-point logic with counting captures polynomial time on the class of\nchordal claw-free graphs.\n", "versions": [{"version": "v1", "created": "Wed, 28 Feb 2018 09:52:25 GMT"}, {"version": "v2", "created": "Wed, 2 Jan 2019 22:30:23 GMT"}, {"version": "v3", "created": "Thu, 30 May 2019 14:03:26 GMT"}, {"version": "v4", "created": "Fri, 5 Jul 2019 09:05:15 GMT"}], "update_date": "2019-10-23", "authors_parsed": [["Gru\u00dfien", "Berit", ""]]}, {"id": "1802.10400", "submitter": "Pac\\^ome Perrotin", "authors": "K\\'evin Perrot, Pac\\^ome Perrotin and Sylvain Sen\\'e", "title": "A framework for (de)composing with Boolean automata networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DM cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Boolean automata networks (BANs) are a generalisation of Boolean cellular\nautomata. In such, any theorem describing the way BANs compute information is a\nstrong tool that can be applied to a wide range of models of computation. In\nthis paper we explore a way of working with BANs which involves adding external\ninputs to the base model (via modules), and more importantly, a way to link\nnetworks together using the above mentioned inputs (via wirings). Our aim is to\ndevelop a powerful formalism for BAN (de)composition. We formulate two results:\nthe first one shows that our modules/wirings definition is complete, the second\none uses modules/wirings to prove simulation results amongst BANs.\n", "versions": [{"version": "v1", "created": "Wed, 28 Feb 2018 13:33:12 GMT"}, {"version": "v2", "created": "Mon, 9 Apr 2018 14:03:07 GMT"}], "update_date": "2018-04-10", "authors_parsed": [["Perrot", "K\u00e9vin", ""], ["Perrotin", "Pac\u00f4me", ""], ["Sen\u00e9", "Sylvain", ""]]}, {"id": "1802.10465", "submitter": "Yusuke Kawamoto", "authors": "M\\'ario S. Alvim, Konstantinos Chatzikokolakis, Yusuke Kawamoto, and\n  Catuscia Palamidessi", "title": "Leakage and Protocol Composition in a Game-Theoretic Perspective", "comments": "POST'18 conference paper (An extended version of this paper with\n  proofs can be found in arXiv:1803.10042). This paper extends one half of the\n  unpublished v1 of arXiv:1705.05030, while v2 of arXiv:1705.05030 extends the\n  other half and is published in GameSec'17", "journal-ref": null, "doi": "10.1007/978-3-319-89722-6_6", "report-no": null, "categories": "cs.CR cs.GT cs.IT cs.LO math.IT", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In the inference attacks studied in Quantitative Information Flow (QIF), the\nadversary typically tries to interfere with the system in the attempt to\nincrease its leakage of secret information. The defender, on the other hand,\ntypically tries to decrease leakage by introducing some controlled noise. This\nnoise introduction can be modeled as a type of protocol composition, i.e., a\nprobabilistic choice among different protocols, and its effect on the amount of\nleakage depends heavily on whether or not this choice is visible to the\nadversary. In this work we consider operators for modeling visible and\ninvisible choice in protocol composition, and we study their algebraic\nproperties. We then formalize the interplay between defender and adversary in a\ngame-theoretic framework adapted to the specific issues of QIF, where the\npayoff is information leakage. We consider various kinds of leakage games,\ndepending on whether players act simultaneously or sequentially, and on whether\nor not the choices of the defender are visible to the adversary. Finally, we\nestablish a hierarchy of these games in terms of their information leakage, and\nprovide methods for finding optimal strategies (at the points of equilibrium)\nfor both attacker and defender in the various cases. The full version of this\npaper can be found in arXiv:1803.10042\n", "versions": [{"version": "v1", "created": "Tue, 27 Feb 2018 17:13:24 GMT"}, {"version": "v2", "created": "Fri, 30 Mar 2018 16:40:24 GMT"}], "update_date": "2019-12-16", "authors_parsed": [["Alvim", "M\u00e1rio S.", ""], ["Chatzikokolakis", "Konstantinos", ""], ["Kawamoto", "Yusuke", ""], ["Palamidessi", "Catuscia", ""]]}, {"id": "1802.10467", "submitter": "Christoph Matheja", "authors": "Kevin Batz, Benjamin Lucien Kaminski, Joost-Pieter Katoen, Christoph\n  Matheja, Thomas Noll", "title": "Quantitative Separation Logic - A Logic for Reasoning about\n  Probabilistic Programs", "comments": null, "journal-ref": "Proc. ACM Program. Lang. 3, POPL, Article 34 (January 2019)", "doi": "10.1145/3290347", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present quantitative separation logic ($\\mathsf{QSL}$). In contrast to\nclassical separation logic, $\\mathsf{QSL}$ employs quantities which evaluate to\nreal numbers instead of predicates which evaluate to Boolean values. The\nconnectives of classical separation logic, separating conjunction and\nseparating implication, are lifted from predicates to quantities. This\nextension is conservative: Both connectives are backward compatible to their\nclassical analogs and obey the same laws, e.g. modus ponens, adjointness, etc.\n  Furthermore, we develop a weakest precondition calculus for quantitative\nreasoning about probabilistic pointer programs in $\\mathsf{QSL}$. This calculus\nis a conservative extension of both Reynolds' separation logic for\nheap-manipulating programs and Kozen's / McIver and Morgan's weakest\npreexpectations for probabilistic programs. Soundness is proven with respect to\nan operational semantics based on Markov decision processes. Our calculus\npreserves O'Hearn's frame rule, which enables local reasoning. We demonstrate\nthat our calculus enables reasoning about quantities such as the probability of\nterminating with an empty heap, the probability of reaching a certain array\npermutation, or the expected length of a list.\n", "versions": [{"version": "v1", "created": "Wed, 28 Feb 2018 15:10:39 GMT"}, {"version": "v2", "created": "Sat, 17 Mar 2018 12:41:10 GMT"}, {"version": "v3", "created": "Wed, 11 Jul 2018 13:24:28 GMT"}, {"version": "v4", "created": "Mon, 26 Nov 2018 09:16:34 GMT"}], "update_date": "2019-01-18", "authors_parsed": [["Batz", "Kevin", ""], ["Kaminski", "Benjamin Lucien", ""], ["Katoen", "Joost-Pieter", ""], ["Matheja", "Christoph", ""], ["Noll", "Thomas", ""]]}, {"id": "1802.10555", "submitter": "Micha\\\"el Cadilhac", "authors": "Micha\\\"el Cadilhac, Olivier Carton, Charles Paperman", "title": "Continuity of Functional Transducers: A Profinite Study of Rational\n  Functions", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 1 (February\n  21, 2020) lmcs:6132", "doi": "10.23638/LMCS-16(1:24)2020", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  A word-to-word function is continuous for a class of languages~$\\mathcal{V}$\nif its inverse maps $\\mathcal{V}$_languages to~$\\mathcal{V}$. This notion\nprovides a basis for an algebraic study of transducers, and was integral to the\ncharacterization of the sequential transducers computable in some circuit\ncomplexity classes.\n  Here, we report on the decidability of continuity for functional transducers\nand some standard classes of regular languages. To this end, we develop a\nrobust theory rooted in the standard profinite analysis of regular languages.\n  Since previous algebraic studies of transducers have focused on the sole\nstructure of the underlying input automaton, we also compare the two algebraic\napproaches. We focus on two questions: When are the automaton structure and the\ncontinuity properties related, and when does continuity propagate to\nsuperclasses?\n", "versions": [{"version": "v1", "created": "Wed, 28 Feb 2018 17:44:43 GMT"}, {"version": "v2", "created": "Mon, 5 Aug 2019 21:46:43 GMT"}, {"version": "v3", "created": "Thu, 20 Feb 2020 13:29:59 GMT"}], "update_date": "2020-06-17", "authors_parsed": [["Cadilhac", "Micha\u00ebl", ""], ["Carton", "Olivier", ""], ["Paperman", "Charles", ""]]}, {"id": "1802.10583", "submitter": "William Blum", "authors": "William Blum", "title": "Reducing Lambda Terms with Traversals", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a method to evaluate untyped lambda terms by combining the\ntheory of traversals, a term-tree traversing technique inspired from Game\nSemantics, with judicious use of the eta-conversion rule of the lambda\ncalculus.\n  The traversal theory of the simply-typed lambda calculus relies on the\neta-long transform to ensure that when traversing an application, there is a\nsubterm representing every possible operator's argument. In the untyped\nsetting, we instead exhibit the missing operand via ad-hoc instantiation of the\neta-expansion rule, which allows the traversal to proceed as if the operand\nexisted in the original term. This gives rise to a more generic concept of\ntraversals for lambda terms. A notable improvement, in addition to handling\nuntyped terms, is that no preliminary transformation is required: the original\nunaltered lambda term is traversed.\n  We show that by bounding the non-determinism of the traversal rule for free\nvariables, one can effectively compute a set of traversals characterizing the\npaths in the tree representation of the beta-normal form, when it exists. This\nyields an evaluation algorithm for untyped lambda-terms. We prove correctness\nby showing that traversals implement leftmost linear reduction, a\ngeneralization of the head linear reduction of Danos et. al.\n", "versions": [{"version": "v1", "created": "Wed, 28 Feb 2018 18:46:19 GMT"}], "update_date": "2018-03-01", "authors_parsed": [["Blum", "William", ""]]}]