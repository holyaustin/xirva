[{"id": "1903.00153", "submitter": "J\\'er\\'emy Dubut", "authors": "Juraj Kol\\v{c}\\'ak, Ichiro Hasuo, J\\'er\\'emy Dubut, Shin-ya Katsumata,\n  David Sprunger and Akihisa Yamada", "title": "Relational Differential Dynamic Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In the field of quality assurance of hybrid systems (that combine continuous\nphysical dynamics and discrete digital control), Platzer's differential dynamic\nlogic (dL) is widely recognized as a deductive verification method with solid\nmathematical foundations and sophisticated tool support. Motivated by\nbenchmarks provided by our industry partner, we study a relational extension of\ndL, aiming to formally prove statements such as \"an earlier deployment of the\nemergency brake decreases the collision speed.\" A main technical challenge here\nis to relate two states of two dynamics at different time points. Our main\ncontribution is a theory of suitable simulations (a relational extension of\ndifferential invariants that are central proof methods in dL), and a derived\ntechnique of time stretching. The latter features particularly high\napplicability, since the user does not have to synthesize a simulation out of\nthe air. We derive new inference rules for dL from these notions, and\ndemonstrate their use over a couple of automotive case studies.\n", "versions": [{"version": "v1", "created": "Fri, 1 Mar 2019 04:42:35 GMT"}, {"version": "v2", "created": "Thu, 12 Mar 2020 07:01:31 GMT"}], "update_date": "2020-03-13", "authors_parsed": [["Kol\u010d\u00e1k", "Juraj", ""], ["Hasuo", "Ichiro", ""], ["Dubut", "J\u00e9r\u00e9my", ""], ["Katsumata", "Shin-ya", ""], ["Sprunger", "David", ""], ["Yamada", "Akihisa", ""]]}, {"id": "1903.00226", "submitter": "Wim Martens", "authors": "Wim Martens and Matthias Niewerth and Tina Trautner", "title": "A Trichotomy for Regular Trail Queries", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.DB cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Regular path queries (RPQs) are an essential component of graph query\nlanguages. Such queries consider a regular expression r and a directed\nedge-labeled graph G and search for paths in G for which the sequence of labels\nis in the language of r. In order to avoid having to consider infinitely many\npaths, some database engines restrict such paths to be trails, that is, they\nonly consider paths without repeated edges. In this paper we consider the\nevaluation problem for RPQs under trail semantics, in the case where the\nexpression is fixed. We show that, in this setting, there exists a trichotomy.\nMore precisely, the complexity of RPQ evaluation divides the regular languages\ninto the finite languages, the class Ttract (for which the problem is\ntractable), and the rest. Interestingly, the tractable class in the trichotomy\nis larger than for the trichotomy for simple paths, discovered by Bagan,\nBonifati, and Groz [PODS 2013]. In addition to this trichotomy result, we also\nstudy characterizations of the tractable class, its expressivity, the\nrecognition problem, closure properties, and show how the decision problem can\nbe extended to the enumeration problem, which is relevant to practice.\n", "versions": [{"version": "v1", "created": "Fri, 1 Mar 2019 09:50:53 GMT"}], "update_date": "2019-03-04", "authors_parsed": [["Martens", "Wim", ""], ["Niewerth", "Matthias", ""], ["Trautner", "Tina", ""]]}, {"id": "1903.00688", "submitter": "Arno Pauly", "authors": "Gafurjan Ibragimov, Bakh Khoussainov and Arno Pauly", "title": "Computability Aspects of Differential Games in Euclidian Spaces", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.OC cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study computability-theoretic aspects of differential games. Our focus is\non pursuit and evasion games played in Euclidean spaces in the tradition of\nRado's \"Lion versus Man\" game. In some ways, these games can be viewed as\ncontinuous versions of reachability games. We prove basic undecidability of\ndifferential games, and study natural classes of pursuit-evasion games in\nEuclidean spaces where the winners can win via computable strategies. The\nwinning strategy for Man found by Besicovitch for the traditional \"Lion versus\nMan\" is not computable. We show how to modify it to yield a computable\nnon-deterministic winning strategy, and raise the question whether Man can win\nin a computable and deterministic way.\n", "versions": [{"version": "v1", "created": "Sat, 2 Mar 2019 12:05:44 GMT"}], "update_date": "2019-03-05", "authors_parsed": [["Ibragimov", "Gafurjan", ""], ["Khoussainov", "Bakh", ""], ["Pauly", "Arno", ""]]}, {"id": "1903.00712", "submitter": "Peter Schrammel", "authors": "Viktor Malik, Martin Hruska, Peter Schrammel, Tomas Vojnar", "title": "2LS: Heap Analysis and Memory Safety (Competition Contribution)", "comments": "System description for contribution to Software Verification\n  Competition (SV-COMP) 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  2LS is a framework for analysis of sequential C programs that can verify and\nrefute program assertions and termination. The 2LS framework is built upon the\nCPROVER infrastructure and implements template-based synthesis techniques, e.g.\nto find invariants and ranking functions, and incremental loop unwinding\ntechniques to find counterexamples and k-induction proofs. The main\nimprovements in this year's version are the ability of 2LS to analyse programs\nrequiring combined reasoning about shape and content of dynamic data\nstructures, and an instrumentation for memory safety properties.\n", "versions": [{"version": "v1", "created": "Sat, 2 Mar 2019 14:49:49 GMT"}, {"version": "v2", "created": "Fri, 3 Jan 2020 08:52:23 GMT"}], "update_date": "2020-01-06", "authors_parsed": [["Malik", "Viktor", ""], ["Hruska", "Martin", ""], ["Schrammel", "Peter", ""], ["Vojnar", "Tomas", ""]]}, {"id": "1903.00745", "submitter": "Esra Erdem", "authors": "Faseeh Ahmad and Esra Erdem and Volkan Patoglu", "title": "A Formal Framework for Robot Construction Problems: A Hybrid Planning\n  Approach", "comments": "8 pages (double-column), 7 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study robot construction problems where multiple autonomous robots\nrearrange stacks of prefabricated blocks to build stable structures. These\nproblems are challenging due to ramifications of actions, true concurrency, and\nrequirements of supportedness of blocks by other blocks and stability of the\nstructure at all times. We propose a formal hybrid planning framework to solve\na wide range of robot construction problems, based on Answer Set Programming.\nThis framework not only decides for a stable final configuration of the\nstructure, but also computes the order of manipulation tasks for multiple\nautonomous robots to build the structure from an initial configuration, while\nsimultaneously ensuring the stability, supportedness and other desired\nproperties of the partial construction at each step of the plan. We prove the\nsoundness and completeness of our formal method with respect to these\nproperties. We introduce a set of challenging robot construction benchmark\ninstances, including bridge building and stack overhanging scenarios, discuss\nthe usefulness of our framework over these instances, and demonstrate the\napplicability of our method using a bimanual Baxter robot.\n", "versions": [{"version": "v1", "created": "Sat, 2 Mar 2019 19:00:20 GMT"}, {"version": "v2", "created": "Sun, 17 Mar 2019 19:38:46 GMT"}], "update_date": "2019-03-19", "authors_parsed": [["Ahmad", "Faseeh", ""], ["Erdem", "Esra", ""], ["Patoglu", "Volkan", ""]]}, {"id": "1903.00762", "submitter": "Kyle Julian", "authors": "Kyle D. Julian and Shivam Sharma and Jean-Baptiste Jeannin and Mykel\n  J. Kochenderfer", "title": "Verifying Aircraft Collision Avoidance Neural Networks Through Linear\n  Approximations of Safe Regions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The next generation of aircraft collision avoidance systems frame the problem\nas a Markov decision process and use dynamic programming to optimize the\nalerting logic. The resulting system uses a large lookup table to determine\nadvisories given to pilots, but these tables can grow very large. To enable the\nsystem to operate on limited hardware, prior work investigated compressing the\ntable using a deep neural network. However, ensuring that the neural network\nreliably issues safe advisories is important for certification. This work\ndefines linearized regions where each advisory can be safely provided, allowing\nReluplex, a neural network verification tool, to check if unsafe advisories are\never issued. A notional collision avoidance policy is generated and used to\ntrain a neural network representation. The neural networks are checked for\nunsafe advisories, resulting in the discovery of thousands of unsafe\ncounterexamples.\n", "versions": [{"version": "v1", "created": "Sat, 2 Mar 2019 20:42:51 GMT"}], "update_date": "2019-03-05", "authors_parsed": [["Julian", "Kyle D.", ""], ["Sharma", "Shivam", ""], ["Jeannin", "Jean-Baptiste", ""], ["Kochenderfer", "Mykel J.", ""]]}, {"id": "1903.00922", "submitter": "Benedikt Ahrens", "authors": "Benedikt Ahrens, Andr\\'e Hirschowitz, Ambroise Lafont, Marco Maggesi", "title": "Modular specification of monads through higher-order presentations", "comments": "17 pages", "journal-ref": "Formal Structures for Computation and Deduction (FSCD) 2019,\n  LIPIcs Vol. 131, pp. 6:1-6:19", "doi": "10.4230/LIPIcs.FSCD.2019.6", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In their work on second-order equational logic, Fiore and Hur have studied\npresentations of simply typed languages by generating binding constructions and\nequations among them. To each pair consisting of a binding signature and a set\nof equations, they associate a category of `models', and they give a monadicity\nresult which implies that this category has an initial object, which is the\nlanguage presented by the pair.\n  In the present work, we propose, for the untyped setting, a variant of their\napproach where monads and modules over them are the central notions. More\nprecisely, we study, for monads over sets, presentations by generating\n(`higher-order') operations and equations among them. We consider a notion of\n2-signature which allows to specify a monad with a family of binding operations\nsubject to a family of equations, as is the case for the paradigmatic example\nof the lambda calculus, specified by its two standard constructions\n(application and abstraction) subject to $\\beta$- and $\\eta$-equalities. Such a\n2-signature is hence a pair $(\\Sigma,E)$ of a binding signature $\\Sigma$ and a\nfamily $E$ of equations for $\\Sigma$. This notion of 2-signature has been\nintroduced earlier by Ahrens in a slightly different context.\n  We associate, to each 2-signature $(\\Sigma,E)$, a category of `models of\n$(\\Sigma,E)$; and we say that a 2-signature is `effective' if this category has\nan initial object; the monad underlying this (essentially unique) object is the\n`monad specified by the 2-signature'. Not every 2-signature is effective; we\nidentify a class of 2-signatures, which we call `algebraic', that are\neffective.\n  Importantly, our 2-signatures together with their models enjoy `modularity':\nwhen we glue (algebraic) 2-signatures together, their initial models are glued\naccordingly.\n  We provide a computer formalization for our main results.\n", "versions": [{"version": "v1", "created": "Sun, 3 Mar 2019 15:00:36 GMT"}], "update_date": "2019-07-16", "authors_parsed": [["Ahrens", "Benedikt", ""], ["Hirschowitz", "Andr\u00e9", ""], ["Lafont", "Ambroise", ""], ["Maggesi", "Marco", ""]]}, {"id": "1903.01093", "submitter": "David Sprunger", "authors": "David Sprunger and Shin-ya Katsumata", "title": "Differentiable Causal Computations via Delayed Trace", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.NE math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate causal computations taking sequences of inputs to sequences of\noutputs where the $n$th output depends on the first $n$ inputs only. We model\nthese in category theory via a construction taking a Cartesian category $C$ to\nanother category $St(C)$ with a novel trace-like operation called \"delayed\ntrace\", which misses yanking and dinaturality axioms of the usual trace. The\ndelayed trace operation provides a feedback mechanism in $St(C)$ with an\nimplicit guardedness guarantee.\n  When $C$ is equipped with a Cartesian differential operator, we construct a\ndifferential operator for $St(C)$ using an abstract version of backpropagation\nthrough time, a technique from machine learning based on unrolling of\nfunctions. This obtains a swath of properties for backpropagation through time,\nincluding a chain rule and Schwartz theorem. Our differential operator is also\nable to compute the derivative of a stateful network without requiring the\nnetwork to be unrolled.\n", "versions": [{"version": "v1", "created": "Mon, 4 Mar 2019 07:05:27 GMT"}], "update_date": "2019-03-05", "authors_parsed": [["Sprunger", "David", ""], ["Katsumata", "Shin-ya", ""]]}, {"id": "1903.01152", "submitter": "Benedikt Ahrens", "authors": "Benedikt Ahrens, Dan Frumin, Marco Maggesi, Niccol\\`o Veltri, Niels\n  van der Weide", "title": "Bicategories in Univalent Foundations", "comments": "v1: 16 pages; v2: Veltri added as coauthor, extended version, 32\n  pages, list of changes given in Section \"Publication history\"", "journal-ref": "conference version published in Formal Structures for Computation\n  and Deduction (FSCD) 2019, LIPIcs Vol. 131, pp. 5:1-5:17", "doi": "10.4230/LIPIcs.FSCD.2019.5", "report-no": null, "categories": "math.CT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop bicategory theory in univalent foundations. Guided by the notion\nof univalence for (1-)categories studied by Ahrens, Kapulkin, and Shulman, we\ndefine and study univalent bicategories. To construct examples of univalent\nbicategories, we develop the notion of `displayed bicategories', an analog of\ndisplayed 1-categories introduced by Ahrens and Lumsdaine. Displayed\nbicategories allow us to construct univalent bicategories in a modular fashion.\nWe demonstrate the applicability of this notion, and prove that several\nbicategories of interest are univalent. Among these are the bicategory of\nunivalent categories with families and the bicategory of pseudofunctors between\nunivalent bicategories. Furthermore, we show that every bicategory with\nunivalent hom-category is weakly equivalent to a univalent bicategory. All of\nour work is formalized in Coq as part of the UniMath library of univalent\nmathematics.\n", "versions": [{"version": "v1", "created": "Mon, 4 Mar 2019 09:52:35 GMT"}, {"version": "v2", "created": "Wed, 8 Jan 2020 20:08:47 GMT"}], "update_date": "2020-01-10", "authors_parsed": [["Ahrens", "Benedikt", ""], ["Frumin", "Dan", ""], ["Maggesi", "Marco", ""], ["Veltri", "Niccol\u00f2", ""], ["van der Weide", "Niels", ""]]}, {"id": "1903.01368", "submitter": "Dror Fried", "authors": "Dror Fried, Axel Legay, Jo\\\"el Ouaknine, Moshe Y. Vardi", "title": "Sequential Relational Decomposition", "comments": "An extended abstract of this article appeared in the Proceedings of\n  the 33rd Annual {ACM/IEEE} Symposium on Logic in Computer Science, {LICS}\n  2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The concept of decomposition in computer science and engineering is\nconsidered a fundamental component of computational thinking and is prevalent\nin design of algorithms, software construction, hardware design, and more. We\npropose a simple and natural formalization of sequential decomposition, in\nwhich a task is decomposed into two sequential sub-tasks, with the first\nsub-task to be executed out before the second sub-task is executed. These tasks\nare specified by means of input/output relations. We define and study\ndecomposition problems, which is to decide whether a given specification can be\nsequentially decomposed. Our main result is that decomposition itself is a\ndifficult computational problem. More specifically, we study decomposition\nproblems in three settings: where the input task is specified explicitly, by\nmeans of Boolean circuits, and by means of automatic relations. We show that in\nthe first setting decomposition is NP-complete, in the second setting it is\nNEXPTIME-complete, and in the third setting there is evidence to suggest that\nit is undecidable. Our results indicate that the intuitive idea of\ndecomposition as a system-design approach requires further investigation. In\nparticular, we show that adding human to the loop by asking for a decomposition\nhint lowers the complexity of decomposition problems considerably.\n", "versions": [{"version": "v1", "created": "Mon, 4 Mar 2019 17:07:29 GMT"}, {"version": "v2", "created": "Thu, 5 Dec 2019 14:31:03 GMT"}, {"version": "v3", "created": "Fri, 24 Jul 2020 16:08:26 GMT"}, {"version": "v4", "created": "Tue, 13 Apr 2021 06:12:22 GMT"}], "update_date": "2021-04-14", "authors_parsed": [["Fried", "Dror", ""], ["Legay", "Axel", ""], ["Ouaknine", "Jo\u00ebl", ""], ["Vardi", "Moshe Y.", ""]]}, {"id": "1903.01969", "submitter": "Saeed Amizadeh", "authors": "Saeed Amizadeh, Sergiy Matusevych, Markus Weimer", "title": "PDP: A General Neural Framework for Learning Constraint Satisfaction\n  Solvers", "comments": "Neuro-symbolic Methods, Neural Combinatorial Optimization, Geometric\n  Deep Learning", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.LO cs.NE stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There have been recent efforts for incorporating Graph Neural Network models\nfor learning full-stack solvers for constraint satisfaction problems (CSP) and\nparticularly Boolean satisfiability (SAT). Despite the unique representational\npower of these neural embedding models, it is not clear how the search strategy\nin the learned models actually works. On the other hand, by fixing the search\nstrategy (e.g. greedy search), we would effectively deprive the neural models\nof learning better strategies than those given. In this paper, we propose a\ngeneric neural framework for learning CSP solvers that can be described in\nterms of probabilistic inference and yet learn search strategies beyond greedy\nsearch. Our framework is based on the idea of propagation, decimation and\nprediction (and hence the name PDP) in graphical models, and can be trained\ndirectly toward solving CSP in a fully unsupervised manner via energy\nminimization, as shown in the paper. Our experimental results demonstrate the\neffectiveness of our framework for SAT solving compared to both neural and the\nstate-of-the-art baselines.\n", "versions": [{"version": "v1", "created": "Tue, 5 Mar 2019 18:26:33 GMT"}], "update_date": "2019-03-06", "authors_parsed": [["Amizadeh", "Saeed", ""], ["Matusevych", "Sergiy", ""], ["Weimer", "Markus", ""]]}, {"id": "1903.02028", "submitter": "Laurent Lyaudet", "authors": "Laurent Lyaudet", "title": "On finite width questionable representations of orders", "comments": "50 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this article, we study \"questionable representations\" of (partial or\ntotal) orders, introduced in our previous article \"A class of orders with\nlinear? time sorting algorithm\". (Later, we consider arbitrary binary\nfunctional/relational structures instead of orders.) A \"question\" is the first\ndifference between two sequences (with ordinal index) of elements of\norders/sets. In finite width \"questionable representations\" of an order O,\ncomparison can be solved by looking at the \"question\" that compares elements of\na finite order O'. A corollary of a theorem by Cantor (1895)is that all\ncountable total orders have a binary (width 2) questionable representation. We\nfind new classes of orders on which testing isomorphism or counting the number\nof linear extensions can be done in polynomial time. We also present a\ngeneralization of questionable-width, called balanced tree-questionable-width,\nand show that if a class of binary structures has bounded tree-width or\nclique-width, then it has bounded balanced tree-questionable-width. But there\nare classes of graphs of bounded balanced tree-questionable-width and unbounded\ntree-width or clique-width.\n", "versions": [{"version": "v1", "created": "Tue, 5 Mar 2019 19:45:25 GMT"}, {"version": "v2", "created": "Thu, 1 Aug 2019 16:43:33 GMT"}, {"version": "v3", "created": "Thu, 19 Sep 2019 19:56:07 GMT"}, {"version": "v4", "created": "Sun, 27 Oct 2019 19:55:47 GMT"}, {"version": "v5", "created": "Sat, 30 Nov 2019 13:58:49 GMT"}, {"version": "v6", "created": "Mon, 30 Dec 2019 20:46:31 GMT"}, {"version": "v7", "created": "Thu, 20 Feb 2020 20:45:55 GMT"}], "update_date": "2020-02-24", "authors_parsed": [["Lyaudet", "Laurent", ""]]}, {"id": "1903.02309", "submitter": "Eti Chaudhary", "authors": "Eti Chaudhary and Saurabh Joshi", "title": "Pinaka: Symbolic Execution meets Incremental Solving (Competition\n  Contribution)", "comments": "5 Pages, 3 Figures, To be published under TOOLympics 2019 (TACAS\n  2019, part 3)", "journal-ref": null, "doi": "10.1007/978-3-030-17502-3_20", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many modern-day solvers offer functionality for incremental SAT solving,\nwhich preserves the state of the solver across invocations. This is beneficial\nwhen multiple, closely related SAT queries need to be fed to the solver. Pinaka\nis a symbolic execution engine which makes aggressive use of incremental SAT\nsolving coupled with eager state infeasibility checks. It is built on top of\nthe CProver/Symex framework. Pinaka supports both Breadth First Search and\nDepth First Search as state exploration strategies along with partial and full\nincremental modes. For SVCOMP 2019, Pinaka is configured to use partial\nincremental mode with Depth First Search strategy.\n", "versions": [{"version": "v1", "created": "Wed, 6 Mar 2019 10:56:05 GMT"}], "update_date": "2020-02-21", "authors_parsed": [["Chaudhary", "Eti", ""], ["Joshi", "Saurabh", ""]]}, {"id": "1903.02344", "submitter": "Martin L\\\"uck", "authors": "Martin L\\\"uck and Miikka Vilander", "title": "On the Succinctness of Atoms of Dependency", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 3 (August\n  20, 2019) lmcs:5698", "doi": "10.23638/LMCS-15(3:17)2019", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Propositional team logic is the propositional analog to first-order team\nlogic. Non-classical atoms of dependence, independence, inclusion, exclusion\nand anonymity can be expressed in it, but for all atoms except dependence only\nexponential translations are known. In this paper, we systematically compare\ntheir succinctness in the existential fragment, where the splitting disjunction\nonly occurs positively, and in full propositional team logic with unrestricted\nnegation. By introducing a variant of the Ehrenfeucht-Fra\\\"{i}ss\\'{e} game\ncalled formula size game into team logic, we obtain exponential lower bounds in\nthe existential fragment for all atoms. In the full fragment, we present\npolynomial upper bounds also for all atoms.\n", "versions": [{"version": "v1", "created": "Wed, 6 Mar 2019 12:55:14 GMT"}, {"version": "v2", "created": "Wed, 10 Jul 2019 14:23:25 GMT"}, {"version": "v3", "created": "Mon, 19 Aug 2019 08:49:10 GMT"}], "update_date": "2019-10-23", "authors_parsed": [["L\u00fcck", "Martin", ""], ["Vilander", "Miikka", ""]]}, {"id": "1903.02539", "submitter": "Cezary Kaliszyk", "authors": "Chad E. Brown, Thibault Gauthier, Cezary Kaliszyk, Geoff Sutcliffe,\n  Josef Urban", "title": "GRUNGE: A Grand Unified ATP Challenge", "comments": "CADE 27 -- 27th International Conference on Automated Deduction", "journal-ref": null, "doi": "10.1007/978-3-030-29436-6_8", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes a large set of related theorem proving problems obtained\nby translating theorems from the HOL4 standard library into multiple logical\nformalisms. The formalisms are in higher-order logic (with and without type\nvariables) and first-order logic (possibly with multiple types, and possibly\nwith type variables). The resultant problem sets allow us to run automated\ntheorem provers that support different logical formats on corresponding\nproblems, and compare their performances. This also results in a new \"grand\nunified\" large theory benchmark that emulates the ITP/ATP hammer setting, where\nsystems and metasystems can use multiple ATP formalisms in complementary ways,\nand jointly learn from the accumulated knowledge.\n", "versions": [{"version": "v1", "created": "Wed, 6 Mar 2019 18:36:16 GMT"}, {"version": "v2", "created": "Tue, 19 Nov 2019 10:04:10 GMT"}], "update_date": "2019-11-20", "authors_parsed": [["Brown", "Chad E.", ""], ["Gauthier", "Thibault", ""], ["Kaliszyk", "Cezary", ""], ["Sutcliffe", "Geoff", ""], ["Urban", "Josef", ""]]}, {"id": "1903.02593", "submitter": "Francesco Kriegel", "authors": "Francesco Kriegel", "title": "Incremental Computation of Concept Diagrams", "comments": "Supplemental proceedings of the 12th International Conference on\n  Formal Concept Analysis (ICFCA 2014), Cluj-Napoca, Romania", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Suppose a formal context K=(G,M,I) is given, whose concept lattice B(K) with\nan attribute-additive concept diagram is already known, and an attribute column\nC=(G,{n},J) shall be inserted to or removed from it. This paper introduces and\nproves an incremental update algorithm for both tasks.\n", "versions": [{"version": "v1", "created": "Wed, 6 Mar 2019 19:49:12 GMT"}], "update_date": "2019-03-08", "authors_parsed": [["Kriegel", "Francesco", ""]]}, {"id": "1903.02835", "submitter": "Chandrika Bhardwaj", "authors": "Chandrika Bhardwaj, Sanjiva Prasad", "title": "Only Connect, Securely", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The lattice model proposed by Denning in her seminal work provided secure\ninformation flow analyses with an intuitive and uniform mathematical\nfoundation. Different organisations, however, may employ quite different\nsecurity lattices. In this paper, we propose a connection framework that\npermits different organisations to exchange information while maintaining both\nsecurity of information flows as well as their autonomy in formulating and\nmaintaining security policy. Our prescriptive framework is based on the\nrigorous mathematical framework of Lagois connections given by Melton, together\nwith a simple operational model for transferring object data between domains.\nThe merit of this formulation is that it is simple, minimal, adaptable and\nintuitive, and provides a formal framework for establishing secure information\nflow across autonomous interacting organisations. We show that our framework is\nsemantically sound, by proving that the connections proposed preserve standard\ncorrectness notions such as non-interference.\n", "versions": [{"version": "v1", "created": "Thu, 7 Mar 2019 11:12:16 GMT"}], "update_date": "2019-03-08", "authors_parsed": [["Bhardwaj", "Chandrika", ""], ["Prasad", "Sanjiva", ""]]}, {"id": "1903.03070", "submitter": "Thomas Powell", "authors": "Thomas Powell, Peter M Schuster, Franziskus Wiesnet", "title": "An algorithmic approach to the existence of ideal objects in commutative\n  algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DS math.AC math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The existence of ideal objects, such as maximal ideals in nonzero rings,\nplays a crucial role in commutative algebra. These are typically justified\nusing Zorn's lemma, and thus pose a challenge from a computational point of\nview. Giving a constructive meaning to ideal objects is a problem which dates\nback to Hilbert's program, and today is still a central theme in the area of\ndynamical algebra, which focuses on the elimination of ideal objects via\nsyntactic methods. In this paper, we take an alternative approach based on\nKreisel's no counterexample interpretation and sequential algorithms. We first\ngive a computational interpretation to an abstract maximality principle in the\ncountable setting via an intuitive, state based algorithm. We then carry out a\nconcrete case study, in which we give an algorithmic account of the result that\nin any commutative ring, the intersection of all prime ideals is contained in\nits nilradical.\n", "versions": [{"version": "v1", "created": "Thu, 7 Mar 2019 17:50:28 GMT"}], "update_date": "2019-03-08", "authors_parsed": [["Powell", "Thomas", ""], ["Schuster", "Peter M", ""], ["Wiesnet", "Franziskus", ""]]}, {"id": "1903.03182", "submitter": "Josef Urban", "authors": "Karel Chvalovsk\\'y and Jan Jakub\\r{u}v and Martin Suda and Josef Urban", "title": "ENIGMA-NG: Efficient Neural and Gradient-Boosted Inference Guidance for\n  E", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe an efficient implementation of clause guidance in\nsaturation-based automated theorem provers extending the ENIGMA approach.\nUnlike in the first ENIGMA implementation where fast linear classifier is\ntrained and used together with manually engineered features, we have started to\nexperiment with more sophisticated state-of-the-art machine learning methods\nsuch as gradient boosted trees and recursive neural networks. In particular the\nlatter approach poses challenges in terms of efficiency of clause evaluation,\nhowever, we show that deep integration of the neural evaluation with the ATP\ndata-structures can largely amortize this cost and lead to competitive\nreal-time results. Both methods are evaluated on a large dataset of theorem\nproving problems and compared with the previous approaches. The resulting\nmethods improve on the manually designed clause guidance, providing the first\npractically convincing application of gradient-boosted and neural clause\nguidance in saturation-style automated theorem provers.\n", "versions": [{"version": "v1", "created": "Thu, 7 Mar 2019 20:54:12 GMT"}], "update_date": "2019-03-11", "authors_parsed": [["Chvalovsk\u00fd", "Karel", ""], ["Jakub\u016fv", "Jan", ""], ["Suda", "Martin", ""], ["Urban", "Josef", ""]]}, {"id": "1903.03218", "submitter": "Rylo Ashmore", "authors": "Rylo Ashmore, Arie Gurfinkel, Richard Trefler", "title": "Local Reasoning for Parameterized First Order Protocols", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.MA", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  First Order Logic (FOL) is a powerful reasoning tool for program\nverification. Recent work on Ivy shows that FOL is well suited for verification\nof parameterized distributed systems. However, specifying many natural objects,\nsuch as a ring topology, in FOL is unexpectedly inconvenient. We present a\nframework based on FOL for specifying distributed multi-process protocols in a\nprocess-local manner together with an implicit network topology. In the\nspecification framework, we provide an auto-active analysis technique to reason\nabout the protocols locally, in a process-modular way. Our goal is to mirror\nthe way designers often describe and reason about protocols. By hiding the\ntopology behind the FOL structure, we simplify the modelling, but complicate\nthe reasoning. To deal with that, we use an oracle for the topology to develop\na sound and relatively complete proof rule that reduces reasoning about the\nimplicit topology back to pure FOL. This completely avoids the need to\naxiomatize the topology. Using the rule, we establish a property that reduces\nverification to a fixed number of processes bounded by the size of local\nneighbourhoods. We show how to use the framework on two examples, including\nleader election on a ring.\n", "versions": [{"version": "v1", "created": "Thu, 7 Mar 2019 23:21:59 GMT"}], "update_date": "2019-03-11", "authors_parsed": [["Ashmore", "Rylo", ""], ["Gurfinkel", "Arie", ""], ["Trefler", "Richard", ""]]}, {"id": "1903.03413", "submitter": "Flavio Ferrarotti", "authors": "Flavio Ferrarotti, Sen\\'en Gonz\\'alez, Jos\\'e Mar\\'ia Turull Torres,\n  Jan Van den Bussche, and Jonni Virtema", "title": "Descriptive Complexity of Deterministic Polylogarithmic Time and Space", "comments": "Submitted to the Journal of Computer and System Sciences", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose logical characterizations of problems solvable in deterministic\npolylogarithmic time (PolylogTime) and polylogarithmic space (PolylogSpace). We\nintroduce a novel two-sorted logic that separates the elements of the input\ndomain from the bit positions needed to address these elements. We prove that\nthe inflationary and partial fixed point vartiants of this logic capture\nPolylogTime and PolylogSpace, respectively. In the course of proving that our\nlogic indeed captures PolylogTime on finite ordered structures, we introduce a\nvariant of random-access Turing machines that can access the relations and\nfunctions of a structure directly. We investigate whether an explicit predicate\nfor the ordering of the domain is needed in our PolylogTime logic. Finally, we\npresent the open problem of finding an exact characterization of\norder-invariant queries in PolylogTime.\n", "versions": [{"version": "v1", "created": "Fri, 8 Mar 2019 13:11:28 GMT"}, {"version": "v2", "created": "Sun, 1 Dec 2019 07:24:26 GMT"}], "update_date": "2019-12-03", "authors_parsed": [["Ferrarotti", "Flavio", ""], ["Gonz\u00e1lez", "Sen\u00e9n", ""], ["Torres", "Jos\u00e9 Mar\u00eda Turull", ""], ["Bussche", "Jan Van den", ""], ["Virtema", "Jonni", ""]]}, {"id": "1903.03680", "submitter": "Apostolos Syropoulos", "authors": "Apostolos Syropoulos", "title": "Fuzzy Bigraphs: An Exercise in Fuzzy Communicating Agents", "comments": "11 pages, 3 figures", "journal-ref": null, "doi": "10.1007/978-3-030-38565-1_13", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bigraphs and their algebra is a model of concurrency. Fuzzy bigraphs are a\ngeneralization of birgraphs intended to be a model of concurrency that\nincorporates vagueness. More specifically, this model assumes that agents are\nsimilar, communication is not perfect, and, in general, everything is or\nhappens to some degree.\n", "versions": [{"version": "v1", "created": "Tue, 5 Mar 2019 14:28:59 GMT"}], "update_date": "2020-02-18", "authors_parsed": [["Syropoulos", "Apostolos", ""]]}, {"id": "1903.03709", "submitter": "Toshiaki Koike-Akino", "authors": "Toshiki Matsumine, Toshiaki Koike-Akino, Ye Wang", "title": "Polar Coding with Chemical Reaction Networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.IT cs.ET cs.LO eess.SP math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we propose a new polar coding scheme with molecular\nprogramming, which is capable of highly parallel implementation at a nano-scale\nwithout a need of electrical power sources. We designed chemical reaction\nnetworks (CRN) to employ either successive cancellation (SC) or\nmaximum-likelihood (ML) decoding schemes for short polar codes. From ordinary\ndifferential equation (ODE) analysis of the proposed CRNs, we demonstrate that\nSC and ML decoding achieve accurate computations across fully-parallel chemical\nreactions. We also make a comparison in terms of the number of required\nchemical reactions and species, where the superiority of ML decoder over SC\ndecoder is observed for very short block lengths.\n", "versions": [{"version": "v1", "created": "Sat, 9 Mar 2019 00:41:19 GMT"}], "update_date": "2019-03-12", "authors_parsed": [["Matsumine", "Toshiki", ""], ["Koike-Akino", "Toshiaki", ""], ["Wang", "Ye", ""]]}, {"id": "1903.03719", "submitter": "Kiraku Minami", "authors": "Kiraku Minami", "title": "Trace Equivalence and Epistemic Logic to Express Security Properties", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In process algebras, security properties are expressed as equivalences\nbetween processes, but which equivalence is suitable is not clear. This means\nthat there is a gap between an intuitive security notion and the formulation.\nAppropriate formalization is essential for verification, and our purpose is\nbridging this gap. By chasing scope extrusions, we prove that trace equivalence\nis congruent. Moreover, we construct an epistemic logic for the applied pi\ncalculus and show that its logical equivalence agrees with the trace\nequivalence. We use the epistemic logic to show that trace equivalence is\npertinent in the presence of a non-adaptive attacker.\n", "versions": [{"version": "v1", "created": "Sat, 9 Mar 2019 02:03:47 GMT"}], "update_date": "2019-03-12", "authors_parsed": [["Minami", "Kiraku", ""]]}, {"id": "1903.03773", "submitter": "Shankara Narayanan Krishna", "authors": "S. Akshay, Paul Gastin, Vincent Juge and Shankara Narayanan Krishna", "title": "Timed Systems through the Lens of Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  In this paper, we analyze timed systems with data structures, using a rich\ninterplay of logic and properties of graphs. We start by describing behaviors\nof timed systems using graphs with timing constraints. Such a graph is called\nrealizable if we can assign time-stamps to nodes or events so that they are\nconsistent with the timing constraints. The logical definability of several\ngraph properties has been a challenging problem, and we show, using a highly\nnon-trivial argument, that the realizability property for collections of graphs\nwith strict timing constraints is logically definable in a class of\npropositional dynamic logic (EQ-ICPDL), which is strictly contained in MSO.\nUsing this result, we propose a novel, algorithmically efficient and uniform\nproof technique for the analysis of timed systems enriched with auxiliary data\nstructures, like stacks and queues. Our technique unravels new results (for\nemptiness checking as well as model checking) for timed systems with richer\nfeatures than considered so far, while also recovering existing results.\n", "versions": [{"version": "v1", "created": "Sat, 9 Mar 2019 10:03:07 GMT"}, {"version": "v2", "created": "Sat, 27 Apr 2019 08:53:09 GMT"}], "update_date": "2019-04-30", "authors_parsed": [["Akshay", "S.", ""], ["Gastin", "Paul", ""], ["Juge", "Vincent", ""], ["Krishna", "Shankara Narayanan", ""]]}, {"id": "1903.03991", "submitter": "Paritosh Pandya", "authors": "Amol Wakankar, Paritosh K. Pandya, Rajmohan Matteplackel", "title": "DCSYNTH: Guided Reactive Synthesis with Soft Requirements", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In reactive controller synthesis, a number of implementations (controllers)\nare possible for a given specification because of the incomplete nature of\nspecification. To choose the most desirable one from the various options, we\nneed to specify additional properties which can guide the synthesis. In this\npaper, We propose a technique for guided controller synthesis from regular\nrequirements which are specified using an interval temporal logic QDDC. We find\nthat QDDC is well suited for guided synthesis due to its superiority in dealing\nwith both qualitative and quantitative specifications. Our framework allows\nspecification consisting of both hard and soft requirements as QDDC formulas.\n  We have also developed a method and a tool DCSynth, which computes a\ncontroller that invariantly satisfies the hard requirement and it optimally\nmeets the soft requirement. The proposed technique is also useful in dealing\nwith conflicting i.e., unrealizable requirements, by making some of them as\nsoft requirements. Case studies are carried out to demonstrate the\neffectiveness of the soft requirement guided synthesis in obtaining\nhigh-quality controllers. The quality of the synthesized controllers is\ncompared using metrics measuring both the guaranteed and the expected case\nbehaviour of the controlled system. Tool DCSynth facilitates such comparison.\n", "versions": [{"version": "v1", "created": "Sun, 10 Mar 2019 13:47:37 GMT"}, {"version": "v2", "created": "Wed, 22 May 2019 10:20:11 GMT"}, {"version": "v3", "created": "Mon, 27 May 2019 11:38:04 GMT"}], "update_date": "2019-05-28", "authors_parsed": [["Wakankar", "Amol", ""], ["Pandya", "Paritosh K.", ""], ["Matteplackel", "Rajmohan", ""]]}, {"id": "1903.04350", "submitter": "Vadim Malvone", "authors": "Francesco Belardinelli, Catalin Dima, Ioana Boureanu, and Vadim\n  Malvone", "title": "Model Checking ATL* on vCGS", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the model checking ATL* on concurrent game structures with\npropositional control for atom-visibility (vCGS) is undecidable. To do so, we\nreduce this problem to model checking ATL* on iCGS.\n", "versions": [{"version": "v1", "created": "Mon, 11 Mar 2019 15:05:47 GMT"}], "update_date": "2019-03-12", "authors_parsed": [["Belardinelli", "Francesco", ""], ["Dima", "Catalin", ""], ["Boureanu", "Ioana", ""], ["Malvone", "Vadim", ""]]}, {"id": "1903.04598", "submitter": "Henrique Lemos", "authors": "Henrique Lemos and Marcelo Prates and Pedro Avelar and Luis Lamb", "title": "Graph Colouring Meets Deep Learning: Effective Graph Neural Network\n  Models for Combinatorial Problems", "comments": "Under submission", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.LO cs.NE stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Deep learning has consistently defied state-of-the-art techniques in many\nfields over the last decade. However, we are just beginning to understand the\ncapabilities of neural learning in symbolic domains. Deep learning\narchitectures that employ parameter sharing over graphs can produce models\nwhich can be trained on complex properties of relational data. These include\nhighly relevant NP-Complete problems, such as SAT and TSP. In this work, we\nshowcase how Graph Neural Networks (GNN) can be engineered -- with a very\nsimple architecture -- to solve the fundamental combinatorial problem of graph\ncolouring. Our results show that the model, which achieves high accuracy upon\ntraining on random instances, is able to generalise to graph distributions\ndifferent from those seen at training time. Further, it performs better than\nthe Neurosat, Tabucol and greedy baselines for some distributions. In addition,\nwe show how vertex embeddings can be clustered in multidimensional spaces to\nyield constructive solutions even though our model is only trained as a binary\nclassifier. In summary, our results contribute to shorten the gap in our\nunderstanding of the algorithms learned by GNNs, as well as hoarding empirical\nevidence for their capability on hard combinatorial problems. Our results thus\ncontribute to the standing challenge of integrating robust learning and\nsymbolic reasoning in Deep Learning systems.\n", "versions": [{"version": "v1", "created": "Mon, 11 Mar 2019 20:46:47 GMT"}, {"version": "v2", "created": "Fri, 5 Jul 2019 19:00:53 GMT"}], "update_date": "2020-03-10", "authors_parsed": [["Lemos", "Henrique", ""], ["Prates", "Marcelo", ""], ["Avelar", "Pedro", ""], ["Lamb", "Luis", ""]]}, {"id": "1903.04940", "submitter": "Rafael Pe\\~naloza", "authors": "Fabrizio M. Maggi, Marco Montali and Rafael Pe\\~naloza", "title": "Temporal Logics Over Finite Traces with Uncertainty (Technical Report)", "comments": "Extended version of paper accepted at AAAI 2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Temporal logics over finite traces have recently seen wide application in a\nnumber of areas, from business process modelling, monitoring, and mining to\nplanning and decision making. However, real-life dynamic systems contain a\ndegree of uncertainty which cannot be handled with classical logics. We thus\npropose a new probabilistic temporal logic over finite traces using\nsuperposition semantics, where all possible evolutions are possible, until\nobserved. We study the properties of the logic and provide automata-based\nmechanisms for deriving probabilistic inferences from its formulas. We then\nstudy a fragment of the logic with better computational properties. Notably,\nformulas in this fragment can be discovered from event log data using\noff-the-shelf existing declarative process discovery techniques.\n", "versions": [{"version": "v1", "created": "Tue, 12 Mar 2019 14:17:44 GMT"}, {"version": "v2", "created": "Mon, 18 Nov 2019 15:38:40 GMT"}], "update_date": "2019-11-19", "authors_parsed": [["Maggi", "Fabrizio M.", ""], ["Montali", "Marco", ""], ["Pe\u00f1aloza", "Rafael", ""]]}, {"id": "1903.05073", "submitter": "Stefan Mitsch", "authors": "Brandon Bohrer and Yong Kiam Tan and Stefan Mitsch and Andrew Sogokon\n  and Andr\\'e Platzer", "title": "A Formal Safety Net for Waypoint Following in Ground Robots", "comments": null, "journal-ref": null, "doi": "10.1109/LRA.2019.2923099", "report-no": null, "categories": "cs.RO cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a reusable formally verified safety net that provides end-to-end\nsafety and liveness guarantees for 2D waypoint-following of Dubins-type ground\nrobots with tolerances and acceleration. We: i) Model a robot in differential\ndynamic logic (dL), and specify assumptions on the controller and robot\nkinematics, ii) Prove formal safety and liveness properties for\nwaypoint-following with speed limits, iii) Synthesize a monitor, which is\nautomatically proven to enforce model compliance at runtime, and iv) Our use of\nthe VeriPhy toolchain makes these guarantees carry over down to the level of\nmachine code with untrusted controllers, environments, and plans. The\nguarantees for the safety net apply to any robot as long as the waypoints are\nchosen safely and the physical assumptions in its model hold. Experiments show\nthese assumptions hold in practice, with an inherent trade-off between\ncompliance and performance.\n", "versions": [{"version": "v1", "created": "Tue, 12 Mar 2019 17:38:38 GMT"}, {"version": "v2", "created": "Wed, 12 Jun 2019 18:19:24 GMT"}, {"version": "v3", "created": "Tue, 18 Jun 2019 18:13:52 GMT"}], "update_date": "2019-06-20", "authors_parsed": [["Bohrer", "Brandon", ""], ["Tan", "Yong Kiam", ""], ["Mitsch", "Stefan", ""], ["Sogokon", "Andrew", ""], ["Platzer", "Andr\u00e9", ""]]}, {"id": "1903.05126", "submitter": "Moez AbdelGawad", "authors": "Moez A. AbdelGawad", "title": "Induction, Coinduction, and Fixed Points in PL Type Theory", "comments": "12 pages, formerly part of arXiv:1812.10026", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recently we presented a concise survey of the formulation of the induction\nand coinduction principles, and some concepts related to them, in programming\nlanguages type theory and four other mathematical disciplines. The presentation\nin type theory involved the separate formulation of these concepts, first, in\nthe theory of types of functional programming languages and, next, in the\ntheory of types of object-oriented programming languages. In this article we\nshow that separating these two formulations helps demonstrate some of the\nfundamental differences between structural subtyping, predominant in functional\nprogramming languages, and nominal subtyping, predominant in object-oriented\nprogramming languages---including differences concerning type negation and\nconcerning the existence of inductive types, of coinductive types, and of\napproximations thereof. In the article we also motivate mutual coinduction and\nmutual coinductive types, and their approximations, and we discuss in brief the\npotential relevance of these concepts to object-oriented programming (OOP) type\ntheory.\n", "versions": [{"version": "v1", "created": "Tue, 26 Feb 2019 16:44:11 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["AbdelGawad", "Moez A.", ""]]}, {"id": "1903.05127", "submitter": "Moez AbdelGawad", "authors": "Moez A. AbdelGawad", "title": "Induction, Coinduction, and Fixed Points: Intuitions and Tutorial", "comments": "9 pages. formerly part of arXiv:1812.10026", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recently we presented a concise survey of the formulation of the induction\nand coinduction principles, and some concepts related to them, in five\ndifferent fields mathematical fields, hence shedding some light on the precise\nrelation between these fields. In this article we present few tutorial\nexamples---from set theory, number theory and real analysis---that illustrate\nthese concepts, and the intuitions behind them, more concretely.\n", "versions": [{"version": "v1", "created": "Tue, 26 Feb 2019 16:40:37 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["AbdelGawad", "Moez A.", ""]]}, {"id": "1903.05333", "submitter": "Yingzhou Zhang", "authors": "Yingzhou Zhang", "title": "SymPas: Symbolic Program Slicing", "comments": "29 pages, 11 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program slicing is a technique for simplifying programs by focusing on\nselected aspects of their behaviour. Current mainstream static slicing methods\noperate on the PDG (program dependence graph) or SDG (system dependence graph),\nbut these friendly graph representations may be expensive and error-prone for\nsome users. We attempt in this paper to study a light-weight approach of static\nprogram slicing, called Symbolic Program Slicing (SymPas), which works as a\ndataflow analysis on LLVM (Low-Level Virtual Machine). In our SymPas approach,\nslices are stored symbolically rather than procedure being re-analysed (cf.\nprocedure summaries). Instead of re-analysing a procedure multiple times to\nfind its slices for each callling context, SymPas calculates a single symbolic\n(or parameterized) slice which can be instantiated at call sites avoiding\nre-analysis; it is implemented in LLVM to perform slicing on its intermediate\nrepresentation (IR). For comparison, we systematically adapt IFDS\n(Interprocedural Finite Distributive Subset) analysis and the SDG-based slicing\nmethod (SDG-IFDS) to statically IR slice programs. Evaluated on open-source and\nbenchmark programs, our backward SymPas shows a factor-of-6 reduction in time\ncost and a factor-of-4 reduction in space cost, compared to backward SDG-IFDS,\nthus being more efficient. In addition, the result shows that after studying\nslices from 66 programs, ranging up to 336,800 IR instructions in size, SymPas\nis highly size-scalable.\n", "versions": [{"version": "v1", "created": "Wed, 13 Mar 2019 06:31:12 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Zhang", "Yingzhou", ""]]}, {"id": "1903.05490", "submitter": "Arno Pauly", "authors": "Arno Pauly", "title": "Effective local compactness and the hyperspace of located sets", "comments": "Working paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We revisit the definition of effective local compactness, and propose an\napproach that works for arbitrary countably-based spaces extending the previous\nwork on computable metric spaces. We use this to show that effective local\ncompactness suffices to ensure that the hyperspace of closed-and-overt sets\n(aka located sets, aka closed sets with full information) is computably compact\nand computably metrizable.\n", "versions": [{"version": "v1", "created": "Wed, 13 Mar 2019 13:51:36 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Pauly", "Arno", ""]]}, {"id": "1903.05878", "submitter": "Thorsten Wissmann", "authors": "Anupam Das and Colin Riba", "title": "A Functional (Monadic) Second-Order Theory of Infinite Trees", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 4 (October\n  23, 2020) lmcs:6855", "doi": "10.23638/LMCS-16(4:6)2020", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This paper presents a complete axiomatization of Monadic Second-Order Logic\n(MSO) over infinite trees. MSO on infinite trees is a rich system, and its\ndecidability (\"Rabin's Tree Theorem\") is one of the most powerful known results\nconcerning the decidability of logics. By a complete axiomatization we mean a\ncomplete deduction system with a polynomial-time recognizable set of axioms. By\nnaive enumeration of formal derivations, this formally gives a proof of Rabin's\nTree Theorem. The deduction system consists of the usual rules for second-order\nlogic seen as two-sorted first-order logic, together with the natural\nadaptation In addition, it contains an axiom scheme expressing the (positional)\ndeterminacy of certain parity games. The main difficulty resides in the limited\nexpressive power of the language of MSO. We actually devise an extension of\nMSO, called Functional (Monadic) Second-Order Logic (FSO), which allows us to\nuniformly manipulate (hereditarily) finite sets and corresponding labeled\ntrees, and whose language allows for higher abstraction than that of MSO.\n", "versions": [{"version": "v1", "created": "Thu, 14 Mar 2019 09:49:14 GMT"}, {"version": "v2", "created": "Fri, 4 Sep 2020 10:02:01 GMT"}, {"version": "v3", "created": "Thu, 22 Oct 2020 17:16:45 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Das", "Anupam", ""], ["Riba", "Colin", ""]]}, {"id": "1903.05894", "submitter": "Andrea Masini", "authors": "Stefano Baratella, Andrea Masini", "title": "A two-dimensional metric temporal logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a two-dimensional metric (interval) temporal logic whose\ninternal and external time flows are dense linear orderings. We provide a\nsuitable semantics and a sequent calculus with axioms for equality and\nextralogical axioms. Then we prove completeness and a semantic partial\ncut-elimination theorem down to formulas of a certain type.\n", "versions": [{"version": "v1", "created": "Thu, 14 Mar 2019 10:19:38 GMT"}], "update_date": "2019-03-15", "authors_parsed": [["Baratella", "Stefano", ""], ["Masini", "Andrea", ""]]}, {"id": "1903.06035", "submitter": "Renaud Vilmart", "authors": "Emmanuel Jeandel, Simon Perdrix, Renaud Vilmart", "title": "Completeness of the ZX-Calculus", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 2 (June 4,\n  2020) lmcs:6532", "doi": "10.23638/LMCS-16(2:11)2020", "report-no": null, "categories": "quant-ph cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The ZX-Calculus is a graphical language for diagrammatic reasoning in quantum\nmechanics and quantum information theory. It comes equipped with an equational\npresentation. We focus here on a very important property of the language:\ncompleteness, which roughly ensures the equational theory captures all of\nquantum mechanics. We first improve on the known-to-be-complete presentation\nfor the so-called Clifford fragment of the language - a restriction that is not\nuniversal - by adding some axioms. Thanks to a system of back-and-forth\ntranslation between the ZX-Calculus and a third-party complete graphical\nlanguage, we prove that the provided axiomatisation is complete for the first\napproximately universal fragment of the language, namely Clifford+T.\n  We then prove that the expressive power of this presentation, though aimed at\nachieving completeness for the aforementioned restriction, extends beyond\nClifford+T, to a class of diagrams that we call linear with Clifford+T\nconstants. We use another version of the third-party language - and an adapted\nsystem of back-and-forth translation - to complete the language for the\nZX-Calculus as a whole, that is, with no restriction. We briefly discuss the\nadded axioms, and finally, we provide a complete axiomatisation for an altered\nversion of the language which involves an additional generator, making the\npresentation simpler.\n", "versions": [{"version": "v1", "created": "Wed, 13 Mar 2019 16:45:40 GMT"}, {"version": "v2", "created": "Wed, 30 Oct 2019 15:09:56 GMT"}, {"version": "v3", "created": "Wed, 3 Jun 2020 08:45:17 GMT"}], "update_date": "2020-08-25", "authors_parsed": [["Jeandel", "Emmanuel", ""], ["Perdrix", "Simon", ""], ["Vilmart", "Renaud", ""]]}, {"id": "1903.06514", "submitter": "Moez AbdelGawad", "authors": "Moez A. AbdelGawad", "title": "Mutual Coinduction", "comments": "22 pages (updated to include a proof of the sufficiency of\n  monotonicity)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present mutual coinduction as a dual of mutual induction and\nalso as a generalization of standard coinduction. In particular, we present a\nprecise formal definition of mutual induction and mutual coinduction. In the\nprocess we present the associated mutual induction and mutual coinduction proof\nprinciples, and we present the conditions under which these principles hold.\n  In spite of some mention of mutual (co)induction in research literature, but\nthe formal definition of mutual (co)induction and the proof of the mutual\n(co)induction proof principles we present here seem to be the first such\ndefinition and proof. As such, it seems our work is the first to point out that\nmonotonicity of mutual generators seems not sufficient for guaranteeing the\nexistence of least and greatest simultaneous fixed points in complete lattices,\nand that continuity on the other hand is sufficient for guaranteeing their\nexistence. [The paper has been responsively updated so as to not require the\ncontinuity of generators but only require their monotonicity, and it now\nincludes a proof of the sufficiency of monotonicity. A full revision of the\npaper to reflect the relaxed requirement is currently underway.]\n  In the course of our presentation of mutual coinduction we also discuss some\nconcepts related to standard (also called direct) induction and standard\ncoinduction, as well as ones related to mutual (also called simultaneous or\nindirect) induction. During the presentation we purposely discuss particular\nstandard concepts so as to help motivate the definitions of their more general\ncounterparts for mutual/ simultaneous/ indirect (co)induction. Greatest\nsimultaneous post-fixed points, in particular, will be abstractions and models\nof mathematical objects (e.g., points, sets, types, predicates, etc.) that are\ndefined mutually-coinductively.\n", "versions": [{"version": "v1", "created": "Thu, 14 Mar 2019 12:45:53 GMT"}, {"version": "v2", "created": "Tue, 19 Mar 2019 10:32:01 GMT"}, {"version": "v3", "created": "Thu, 21 Mar 2019 16:58:50 GMT"}, {"version": "v4", "created": "Mon, 8 Apr 2019 15:19:23 GMT"}, {"version": "v5", "created": "Mon, 29 Jul 2019 10:48:46 GMT"}], "update_date": "2019-07-30", "authors_parsed": [["AbdelGawad", "Moez A.", ""]]}, {"id": "1903.06775", "submitter": "Michele Basaldella", "authors": "Michele Basaldella", "title": "Lambda Congruences and Extensionality", "comments": "20 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this work we provide alternative formulations of the concepts of lambda\ntheory and extensional theory without introducing the notion of substitution\nand the sets of all, free and bound variables occurring in a term. We also\nclarify the actual role of $\\alpha$-renaming and $\\eta$-extensionality in the\nlambda calculus: both of them can be described as properties of extensionality\nfor certain classes of terms.\n", "versions": [{"version": "v1", "created": "Fri, 15 Mar 2019 19:38:07 GMT"}, {"version": "v2", "created": "Wed, 20 Mar 2019 01:17:33 GMT"}], "update_date": "2019-03-21", "authors_parsed": [["Basaldella", "Michele", ""]]}, {"id": "1903.06873", "submitter": "Bhaskar Ramasubramanian", "authors": "Bhaskar Ramasubramanian, Andrew Clark, Linda Bushnell, Radha\n  Poovendran", "title": "Secure Control under Partial Observability with Temporal Logic\n  Constraints", "comments": "To appear at the American Control Conference, 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.CR cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper studies the synthesis of control policies for an agent that has to\nsatisfy a temporal logic specification in a partially observable environment,\nin the presence of an adversary. The interaction of the agent (defender) with\nthe adversary is modeled as a partially observable stochastic game. The search\nfor policies is limited to over the space of finite state controllers, which\nleads to a tractable approach to determine policies. The goal is to generate a\ndefender policy to maximize satisfaction of a given temporal logic\nspecification under any adversary policy. We relate the satisfaction of the\nspecification in terms of reaching (a subset of) recurrent states of a Markov\nchain. We then present a procedure to determine a set of defender and adversary\nfinite state controllers of given sizes that will satisfy the temporal logic\nspecification. We illustrate our approach with an example.\n", "versions": [{"version": "v1", "created": "Sat, 16 Mar 2019 03:12:27 GMT"}], "update_date": "2019-03-19", "authors_parsed": [["Ramasubramanian", "Bhaskar", ""], ["Clark", "Andrew", ""], ["Bushnell", "Linda", ""], ["Poovendran", "Radha", ""]]}, {"id": "1903.07217", "submitter": "\\'Etienne Andr\\'e", "authors": "\\'Etienne Andr\\'e, Emmanuel Coquard, Laurent Fribourg, Jawher Jerray\n  and David Lesens", "title": "Parametric schedulability analysis of a launcher flight control system\n  under reactivity constraints", "comments": "This work was supported by the Paris \\^Ile-de-France Region (project\n  DIM RFSI ASTREI). \\'Etienne Andr\\'e is partially supported by the ANR\n  national research program PACS (ANR-14-CE28-0002), and the ERATO HASUO\n  Metamathematics for Systems Design Project (No. JPMJER1603), JST", "journal-ref": "This manuscript is the extended version of the manuscript of the\n  same name published in the proceedings of the 19th International Conference\n  on Application of Concurrency to System Design (ACSD 2019)", "doi": null, "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The next generation of space systems will have to achieve more and more\ncomplex missions. In order to master the development cost and duration of such\nsystems, an alternative to a manual design is to automatically synthesize the\nmain parameters of the system. In this paper, we present an approach on the\nspecific case of the scheduling of the flight control of a space launcher. The\napproach requires two successive steps: (1) the formalization of the problem to\nbe solved in a parametric formal model and (2) the synthesis of the model\nparameters with a tool. We first describe the problematic of the scheduling of\na launcher flight control, then we show how this problematic can be formalized\nwith parametric stopwatch automata; we then present the results computed by\nIMITATOR. We compare the results to the ones obtained by other tools\nclassically used in scheduling.\n", "versions": [{"version": "v1", "created": "Mon, 18 Mar 2019 01:05:59 GMT"}], "update_date": "2019-03-19", "authors_parsed": [["Andr\u00e9", "\u00c9tienne", ""], ["Coquard", "Emmanuel", ""], ["Fribourg", "Laurent", ""], ["Jerray", "Jawher", ""], ["Lesens", "David", ""]]}, {"id": "1903.07371", "submitter": "Ekaterina Komendantskaya Dr", "authors": "Ekaterina Komendantskaya and Yue Li", "title": "Coinductive Uniform Proofs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Coinduction occurs in two guises in Horn clause logic: in proofs of circular\nproperties and relations, and in proofs involving construction of infinite\ndata. Both instances of coinductive reasoning appeared in the literature\nbefore, but a systematic analysis of these two kinds of proofs and of their\nrelation was lacking. We propose a general proof-theoretic framework for\nhandling both kinds of coinduction arising in Horn clause logic. To this aim,\nwe propose a coinductive extension of Miller et al framework of uniform proofs\nand prove its soundness relative to coinductive models of Horn clause logic.\n", "versions": [{"version": "v1", "created": "Mon, 18 Mar 2019 11:27:27 GMT"}], "update_date": "2019-03-19", "authors_parsed": [["Komendantskaya", "Ekaterina", ""], ["Li", "Yue", ""]]}, {"id": "1903.07616", "submitter": "\\'Etienne Miquey", "authors": "\\'Etienne Miquey", "title": "A constructive proof of dependent choice in classical arithmetic via\n  memoization", "comments": "This is an extended version of arXiv:1805.09542", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  In a recent paper, Herbelin developed dPA${^\\omega}$, a calculus in which\nconstructive proofs for the axioms of countable and dependent choices could be\nderived via the memoization of choice functions. However, the property of\nnormalization (and therefore the one of soundness) was only conjectured. The\ndifficulty for the proof of normalization is due to the simultaneous presence\nof dependent types (for the constructive part of the choice), of control\noperators (for classical logic), of coinductive objects (to encode functions of\ntype ${\\mathbb{N} \\to A}$ into streams (${a_0},{a_1},...$)) and of lazy\nevaluation with sharing (for memoizing these coinductive objects). Elaborating\non previous works, we introduce in this paper a variant of dPA${^\\omega}$\npresented as a sequent calculus. On the one hand, we take advantage of a\nvariant of Krivine classical realizability that we developed to prove the\nnormalization of classical call-by-need. On the other hand, we benefit from\ndL${_{\\hat{tp}}}$, a classical sequent calculus with dependent types in which\ntype safety is ensured by using delimited continuations together with a\nsyntactic restriction. By combining the techniques developed in these papers,\nwe manage to define a realizability interpretation \\`a la Krivine of our\ncalculus that allows us to prove normalization and soundness. This paper goes\nover the whole process, starting from Herbelin's calculus dPA${^\\omega}$ until\nour introduction of its sequent calculus counterpart dLPA${^\\omega}$.\n", "versions": [{"version": "v1", "created": "Mon, 18 Mar 2019 12:45:38 GMT"}], "update_date": "2019-03-25", "authors_parsed": [["Miquey", "\u00c9tienne", ""]]}, {"id": "1903.07837", "submitter": "Ryuta Arisaka", "authors": "Ryuta Arisaka", "title": "Turing-Completeness of Dynamics in Abstract Persuasion Argumentation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Abstract Persuasion Argumentation (APA) is a dynamic argumentation formalism\nthat extends Dung argumentation with persuasion relations. In this work, we\nshow through two-counter Minsky machine encoding that APA dynamics is\nTuring-complete.\n", "versions": [{"version": "v1", "created": "Tue, 19 Mar 2019 05:09:42 GMT"}], "update_date": "2019-03-20", "authors_parsed": [["Arisaka", "Ryuta", ""]]}, {"id": "1903.07993", "submitter": "Sebastian Junges", "authors": "Sebastian Junges, Erika Abraham, Christian Hensel, Nils Jansen,\n  Joost-Pieter Katoen, Tim Quatmann, Matthias Volk", "title": "Parameter Synthesis for Markov Models", "comments": "38 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Markov chain analysis is a key technique in reliability engineering. A\npractical obstacle is that all probabilities in Markov models need to be known.\nHowever, system quantities such as failure rates or packet loss ratios, etc.\nare often not---or only partially---known. This motivates considering\nparametric models with transitions labeled with functions over parameters.\nWhereas traditional Markov chain analysis evaluates a reliability metric for a\nsingle, fixed set of probabilities, analysing parametric Markov models focuses\non synthesising parameter values that establish a given reliability or\nperformance specification $\\varphi$. Examples are: what component failure rates\nensure the probability of a system breakdown to be below 0.00000001?, or which\nfailure rates maximise reliability? This paper presents various analysis\nalgorithms for parametric Markov chains and Markov decision processes. We focus\non three problems: (a) do all parameter values within a given region satisfy\n$\\varphi$?, (b) which regions satisfy $\\varphi$ and which ones do not?, and (c)\nan approximate version of (b) focusing on covering a large fraction of all\npossible parameter values. We give a detailed account of the various\nalgorithms, present a software tool realising these techniques, and report on\nan extensive experimental evaluation on benchmarks that span a wide range of\napplications.\n", "versions": [{"version": "v1", "created": "Sat, 16 Mar 2019 15:07:25 GMT"}], "update_date": "2019-03-20", "authors_parsed": [["Junges", "Sebastian", ""], ["Abraham", "Erika", ""], ["Hensel", "Christian", ""], ["Jansen", "Nils", ""], ["Katoen", "Joost-Pieter", ""], ["Quatmann", "Tim", ""], ["Volk", "Matthias", ""]]}, {"id": "1903.08109", "submitter": "Andrey Nechesov", "authors": "Andrey Nechesov", "title": "Polynomial analogue of Gandhi's fixed point theorem", "comments": "This paper shows how to move from definability to computability: help\n  in creation p-computable programs. This approach based on semantic programs\n  methodology developed by russian mathematicans U.L. Ershov, S.S. Goncharov\n  and D.I. Sviridenko and also based on Gandi's fixed point theorem. Sobolev\n  institute of mathematics. Novosibirsk", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem to be solved in this paper is to construct a general method of\nproving whether a certain set is p-computable or not. The method is based on a\npolynomial analogue of the classical Gandhi's fixed point theorem. The\nclassical Gandhi theorem uses the extension of the predicate with the help of\nthe special operator $\\Gamma^{\\Omega^*}_{\\Phi(x)}$ whose smallest fixed point\nis the $\\Sigma$-set. The work uses a new type of operator -\n$\\Delta_0^p$-operator $\\Gamma_{F_{P_1^{+}},...,F_{P_n^{+}}}^{\\mathfrak{M}}$,\nwhich extends predicates so that the smallest fixed point remains a\np-computable set. Moreover, if in the classical Gandhi's fixed point theorem\nthe special $\\Sigma$-formula $\\Phi(\\overline {x})$ is used in the construction\nof the operator, then in the new operator, instead of a single formula, special\ngenerating families of formulas $F_ {P_1 ^ {+}},...,F_{P_n^{+}}$. This work\nopens up broad prospects for the application of the polynomial analogue of the\nGandhi theorem in the construction of new types of terms and formulas, in the\nconstruction of new data types and programs of polynomial computational\ncomplexity in Turing complete languages.\n", "versions": [{"version": "v1", "created": "Tue, 19 Mar 2019 16:54:39 GMT"}, {"version": "v2", "created": "Thu, 9 May 2019 13:57:24 GMT"}, {"version": "v3", "created": "Thu, 23 May 2019 08:31:13 GMT"}, {"version": "v4", "created": "Fri, 24 May 2019 06:48:22 GMT"}, {"version": "v5", "created": "Fri, 14 Jun 2019 05:51:53 GMT"}, {"version": "v6", "created": "Sat, 22 Jun 2019 15:33:39 GMT"}, {"version": "v7", "created": "Thu, 17 Jun 2021 03:59:50 GMT"}], "update_date": "2021-06-18", "authors_parsed": [["Nechesov", "Andrey", ""]]}, {"id": "1903.08357", "submitter": "Dominique Unruh", "authors": "Yangjia Li, Dominique Unruh", "title": "Quantum Relational Hoare Logic with Expectations", "comments": null, "journal-ref": "ICALP 2021, track B", "doi": "10.4230/LIPIcs.ICALP.2021.136", "report-no": null, "categories": "cs.LO quant-ph", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We present a variant of the quantum relational Hoare logic from (Unruh, POPL\n2019) that allows us to use \"expectations\" in pre- and postconditions. That is,\nwhen reasoning about pairs of programs, our logic allows us to quantitatively\nreason about how much certain pre-/postconditions are satisfied that refer to\nthe relationship between the programs inputs/outputs.\n", "versions": [{"version": "v1", "created": "Wed, 20 Mar 2019 06:47:10 GMT"}, {"version": "v2", "created": "Mon, 12 Jul 2021 11:26:09 GMT"}], "update_date": "2021-07-13", "authors_parsed": [["Li", "Yangjia", ""], ["Unruh", "Dominique", ""]]}, {"id": "1903.08571", "submitter": "Viktor Kuncak", "authors": "Slobodan Mitrovi\\'c and Ruzica Piskac and Viktor Kun\\v{c}ak", "title": "Identifying Maximal Non-Redundant Integer Cone Generators", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A non-redundant integer cone generator (NICG) of dimension $d$ is a set $S$\nof vectors from $\\{0,1\\}^d$ whose vector sum cannot be generated as a positive\ninteger linear combination of a proper subset of $S$. The largest possible\ncardinality of NICG of a dimension $d$, denoted by $N(d)$, provides an upper\nbound on the sparsity of systems of integer equations with a large number of\ninteger variables. A better estimate of $N(d)$ means that we can consider\nsmaller sub-systems of integer equations when solving systems with many integer\nvariables. Furthermore, given that we can reduce constraints on set algebra\nexpressions to constraints on cardinalities of Venn regions, tighter upper\nbound on $N(d)$ yields a more efficient decision procedure for a logic of sets\nwith cardinality constraints (BAPA), which has been applied in software\nverification. Previous attempts to compute $N(d)$ using SAT solvers have not\nsucceeded even for $d=3$. The only known values were computed manually:\n$N(d)=d$ for $d < 4$ and $N(4) > 4$. We provide the first exact values for $d >\n3$, namely, $N(4)=5$, $N(5)=7$, and $N(6)=9$, which is a significant\nimprovement of the known asymptotic bound (which would give only e.g. $N(6) \\le\n29$, making a decision procedure impractical for $d=6$). We also give lower\nbounds for $N(7)$, $N(8)$, $N(9)$, and $N(10)$, which are: $11$, $13$, $14$,\nand $16$, respectively. We describe increasingly sophisticated specialized\nsearch algorithms that we used to explore the space of non-redundant generators\nand obtain these results.\n", "versions": [{"version": "v1", "created": "Wed, 20 Mar 2019 15:55:48 GMT"}], "update_date": "2019-03-21", "authors_parsed": [["Mitrovi\u0107", "Slobodan", ""], ["Piskac", "Ruzica", ""], ["Kun\u010dak", "Viktor", ""]]}, {"id": "1903.08575", "submitter": "Sylvain Schmitz", "authors": "J\\'er\\^ome Leroux and Sylvain Schmitz", "title": "Reachability in Vector Addition Systems is Primitive-Recursive in Fixed\n  Dimension", "comments": null, "journal-ref": "34th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS\n  2019)", "doi": "10.1109/LICS.2019.8785796", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The reachability problem in vector addition systems is a central question,\nnot only for the static verification of these systems, but also for many\ninter-reducible decision problems occurring in various fields. The currently\nbest known upper bound on this problem is not primitive-recursive, even when\nconsidering systems of fixed dimension. We provide significant refinements to\nthe classical decomposition algorithm of Mayr, Kosaraju, and Lambert and to its\ntermination proof, which yield an ACKERMANN upper bound in the general case,\nand primitive-recursive upper bounds in fixed dimension. While this does not\nmatch the currently best known TOWER lower bound for reachability, it is\noptimal for related problems.\n", "versions": [{"version": "v1", "created": "Wed, 20 Mar 2019 16:00:47 GMT"}], "update_date": "2019-08-20", "authors_parsed": [["Leroux", "J\u00e9r\u00f4me", ""], ["Schmitz", "Sylvain", ""]]}, {"id": "1903.08922", "submitter": "Lili Shen", "authors": "Hongliang Lai, Lili Shen", "title": "Multi-adjoint concept lattices via quantaloid-enriched categories", "comments": "14 pages, final version", "journal-ref": "Fuzzy Sets and Systems, 405:74-87, 2021", "doi": "10.1016/j.fss.2020.03.007", "report-no": null, "categories": "cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  With quantaloids carefully constructed from multi-adjoint frames, it is shown\nthat multi-adjoint concept lattices, multi-adjoint property-oriented concept\nlattices and multi-adjoint object-oriented concept lattices are derivable from\nIsbell adjunctions, Kan adjunctions and dual Kan adjunctions between\nquantaloid-enriched categories, respectively.\n", "versions": [{"version": "v1", "created": "Thu, 21 Mar 2019 11:04:24 GMT"}, {"version": "v2", "created": "Wed, 11 Mar 2020 06:34:15 GMT"}], "update_date": "2021-02-22", "authors_parsed": [["Lai", "Hongliang", ""], ["Shen", "Lili", ""]]}, {"id": "1903.09354", "submitter": "Marcell Vazquez-Chanlatte", "authors": "Marcell Vazquez-Chanlatte, Markus N. Rabe, Sanjit A. Seshia", "title": "A Model Counter's Guide to Probabilistic Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we systematize the modeling of probabilistic systems for the\npurpose of analyzing them with model counting techniques. Starting from\nunbiased coin flips, we show how to model biased coins, correlated coins, and\ndistributions over finite sets. From there, we continue with modeling\nsequential systems, such as Markov chains, and revisit the relationship between\nweighted and unweighted model counting. Thereby, this work provides a\nconceptual framework for deriving #SAT encodings for probabilistic inference.\n", "versions": [{"version": "v1", "created": "Fri, 22 Mar 2019 04:37:36 GMT"}], "update_date": "2019-03-29", "authors_parsed": [["Vazquez-Chanlatte", "Marcell", ""], ["Rabe", "Markus N.", ""], ["Seshia", "Sanjit A.", ""]]}, {"id": "1903.09408", "submitter": "Jan Seeger", "authors": "Jan Seeger, Arne Br\\\"oring, Marc-Oliver Pahl and Ermin Sakic", "title": "Rule-Based Translation of Application-Level QoS Constraints into SDN\n  Configurations for the IoT", "comments": "Submitted to EUCNC '19", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.IT cs.LO math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we propose an approach for the automated translation of\napplication-level requirements regarding the logical workflow and its QoS into\na configuration of the underlying network substrate. Our goal is to facilitate\nthe integration of QoS constraints in the development of industrial IoT\napplications to make them more reliable. We follow an approach based on two\nsemantic models: The first model allows to design the workflow of an IoT\napplication and to express application-level QoS requirements on its\ninteractions. The second model captures the configuration of a network and can\nbe used as input to a north-bound interface of an SDN controller. Finally, we\nmake use of rule-based semantic reasoning to automatically translate from the\napplication requirements into SDN parameters.\n", "versions": [{"version": "v1", "created": "Fri, 22 Mar 2019 09:03:06 GMT"}], "update_date": "2019-03-25", "authors_parsed": [["Seeger", "Jan", ""], ["Br\u00f6ring", "Arne", ""], ["Pahl", "Marc-Oliver", ""], ["Sakic", "Ermin", ""]]}, {"id": "1903.09463", "submitter": "Thorsten Wissmann", "authors": "Robert Furber and Radu Mardare and Matteo Mio", "title": "Probabilistic logics based on Riesz spaces", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 16, Issue 1 (January\n  27, 2020) lmcs:6054", "doi": "10.23638/LMCS-16(1:6)2020", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce a novel real-valued endogenous logic for expressing properties\nof probabilistic transition systems called Riesz modal logic. The design of the\nsyntax and semantics of this logic is directly inspired by the theory of Riesz\nspaces, a mature field of mathematics at the intersection of universal algebra\nand functional analysis. By using powerful results from this theory, we develop\nthe duality theory of the Riesz modal logic in the form of an\nalgebra-to-coalgebra correspondence. This has a number of consequences\nincluding: a sound and complete axiomatization, the proof that the logic\ncharacterizes probabilistic bisimulation and other convenient results such as\ncompletion theorems. This work is intended to be the basis for subsequent\nresearch on extensions of Riesz modal logic with fixed-point operators.\n", "versions": [{"version": "v1", "created": "Fri, 22 Mar 2019 12:02:21 GMT"}, {"version": "v2", "created": "Fri, 27 Dec 2019 12:13:19 GMT"}, {"version": "v3", "created": "Fri, 24 Jan 2020 12:31:27 GMT"}], "update_date": "2020-06-17", "authors_parsed": [["Furber", "Robert", ""], ["Mardare", "Radu", ""], ["Mio", "Matteo", ""]]}, {"id": "1903.09475", "submitter": "Andrei Arusoaie", "authors": "Andrei Arusoaie, Ionut Pistol", "title": "Using SMT Solvers to Validate Models for AI Problems", "comments": "8 pages,1 table, technical report", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Artificial Intelligence problems, ranging form planning/scheduling up to game\ncontrol, include an essential crucial step: describing a model which accurately\ndefines the problem's required data, requirements, allowed transitions and\nestablished goals. The ways in which a model can fail are numerous and often\nlead to a failure of search strategies to provide a quick, optimal, or even any\nsolution. This paper proposes using SMT (Satisfiability Modulo Theories)\nsolvers, such as Z3, to check the validity of a model. We propose two tests:\nchecking whether a final(goal) state exists in the model's described problem\nspace and checking whether the transitions described can provide a path from\nthe identified initial states to any the goal states (meaning a solution has\nbeen found). The advantage of using an SMT solver for AI model checking is that\nthey substitute actual search strategies and they work over an abstract\nrepresentation of the model, that is, a set of logical formulas. Reasoning at\nan abstract level is not as expensive as exploring the entire solution space.\nSMT solvers use efficient decision procedures which provide proofs for the\nlogical formulas corresponding to the AI model. A recent addition to Z3 allowed\nus to describe sequences of transitions as a recursive function, thus we can\ncheck if a solution can be found in the defined model.\n", "versions": [{"version": "v1", "created": "Fri, 22 Mar 2019 12:45:23 GMT"}], "update_date": "2019-03-25", "authors_parsed": [["Arusoaie", "Andrei", ""], ["Pistol", "Ionut", ""]]}, {"id": "1903.09714", "submitter": "Zhe Xu", "authors": "Zhe Xu, Alexander J Nettekoven, A. Agung Julius, Ufuk Topcu", "title": "Graph Temporal Logic Inference for Classification and Identification", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Inferring spatial-temporal properties from data is important for many complex\nsystems, such as additive manufacturing systems, swarm robotic systems and\nbiological networks. Such systems can often be modeled as a labeled graph where\nlabels on the nodes and edges represent relevant measurements such as\ntemperatures and distances. We introduce graph temporal logic (GTL) which can\nexpress properties such as \"whenever a node's label is above 10, for the next 3\ntime units there are always at least two neighboring nodes with an edge label\nof at most 2 where the node labels are above 5\". This paper is a first attempt\nto infer spatial (graph) temporal logic formulas from data for classification\nand identification. For classification, we infer a GTL formula that classifies\ntwo sets of graph temporal trajectories with minimal misclassification rate.\nFor identification, we infer a GTL formula that is informative and is satisfied\nby the graph temporal trajectories in the dataset with high probability. The\ninformativeness of a GTL formula is measured by the information gain with\nrespect to given prior knowledge represented by a prior probability\ndistribution. We implement the proposed approach to classify the graph patterns\nof tensile specimens built from selective laser sintering (SLS) process with\nvarying strengths, and to identify informative spatial-temporal patterns from\nexperimental data of the SLS cooldown process and simulation data of a swarm of\nrobots.\n", "versions": [{"version": "v1", "created": "Fri, 22 Mar 2019 21:43:45 GMT"}], "update_date": "2019-03-26", "authors_parsed": [["Xu", "Zhe", ""], ["Nettekoven", "Alexander J", ""], ["Julius", "A. Agung", ""], ["Topcu", "Ufuk", ""]]}, {"id": "1903.09818", "submitter": "Christoph Benzm\\\"uller", "authors": "David Fuenmayor and Christoph Benzm\\\"uller", "title": "Harnessing Higher-Order (Meta-)Logic to Represent and Reason with\n  Complex Ethical Theories", "comments": "14 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The computer-mechanization of an ambitious explicit ethical theory, Gewirth's\nPrinciple of Generic Consistency, is used to showcase an approach for\nrepresenting and reasoning with ethical theories exhibiting complex logical\nfeatures like alethic and deontic modalities, indexicals, higher-order\nquantification, among others. Harnessing the high expressive power of Church's\ntype theory as a meta-logic to semantically embed a combination of quantified\nnon-classical logics, our work pushes existing boundaries in knowledge\nrepresentation and reasoning. We demonstrate that intuitive encodings of\ncomplex ethical theories and their automation on the computer are no longer\nantipodes.\n", "versions": [{"version": "v1", "created": "Sat, 23 Mar 2019 13:22:38 GMT"}, {"version": "v2", "created": "Sat, 15 Jun 2019 15:42:25 GMT"}], "update_date": "2019-06-18", "authors_parsed": [["Fuenmayor", "David", ""], ["Benzm\u00fcller", "Christoph", ""]]}, {"id": "1903.10405", "submitter": "Richard Trefler", "authors": "Kedar S. Namjoshi and Richard J. Trefler", "title": "Symmetry Reduction for the Local Mu-Calculus", "comments": "17 pages", "journal-ref": "TACAS (2) 2018: 379-395", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Model checking large networks of processes is challenging due to state\nexplosion. In many cases, individual processes are isomorphic, but there is\ninsufficient global symmetry to simplify model checking. This work considers\nthe verification of local properties, those defined over the neighborhood of a\nprocess. Considerably generalizing earlier results on invariance, it is shown\nthat all local mu-calculus properties, including safety and liveness\nproperties, are preserved by neighborhood symmetries. Hence, it suffices to\ncheck them locally over a set of representative process neighborhoods. In\ngeneral, local verification approximates verification over the global state\nspace; however, if process interactions are outward-facing, the relationship is\nshown to be exact. For many network topologies, even those with little global\nsymmetry, analysis with representatives provides a significant, even\nexponential, reduction in the cost of verification. Moreover, it is shown that\nfor network families generated from building-block patterns, neighborhood\nsymmetries are easily determined, and verification over the entire family\nreduces to verification over a finite set of representative process\nneighborhoods.\n", "versions": [{"version": "v1", "created": "Mon, 25 Mar 2019 15:38:40 GMT"}], "update_date": "2019-03-26", "authors_parsed": [["Namjoshi", "Kedar S.", ""], ["Trefler", "Richard J.", ""]]}, {"id": "1903.10706", "submitter": "Miika Hannula", "authors": "Miika Hannula and Lauri Hella", "title": "Complexity Thresholds in Inclusion Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logics with team semantics provide alternative means for logical\ncharacterization of complexity classes. Both dependence and independence logic\nare known to capture non-deterministic polynomial time, and the frontiers of\ntractability in these logics are relatively well understood. Inclusion logic is\nsimilar to these team-based logical formalisms with the exception that it\ncorresponds to deterministic polynomial time in ordered models. In this article\nwe examine connections between syntactical fragments of inclusion logic and\ndifferent complexity classes in terms of two computational problems: maximal\nsubteam membership and the model checking problem for a fixed inclusion logic\nformula. We show that very simple quantifier-free formulae with one or two\ninclusion atoms generate instances of these problems that are complete for\n(non-deterministic) logarithmic space and polynomial time. Furthermore, we\npresent a fragment of inclusion logic that captures non-deterministic\nlogarithmic space in ordered models.\n", "versions": [{"version": "v1", "created": "Tue, 26 Mar 2019 06:52:34 GMT"}], "update_date": "2019-03-27", "authors_parsed": [["Hannula", "Miika", ""], ["Hella", "Lauri", ""]]}, {"id": "1903.11092", "submitter": "Sibylle Schupp", "authors": "Sibylle Schupp", "title": "Tool Support of Formal Methods for Privacy by Design", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Formal methods are, in principle, suited for supporting the recent paradigm\nof privacy by design, but no overview is available that summarizes which\nparticular approaches have been investigated, for which application domains\nthey are suited, and whether they are implemented and available as tools. Using\nthe techniques of search-based literature review and snowballing this paper\nanswers those questions for a selected set of research papers.\n", "versions": [{"version": "v1", "created": "Tue, 26 Mar 2019 18:05:06 GMT"}], "update_date": "2019-03-28", "authors_parsed": [["Schupp", "Sibylle", ""]]}, {"id": "1903.11138", "submitter": "Christopher Hahn", "authors": "Bernd Finkbeiner, Christopher Hahn, and Tobias Hans", "title": "MGHyper: Checking Satisfiability of HyperLTL Formulas Beyond the\n  $\\exists^*\\forall^*$ Fragment", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hyperproperties are properties that refer to multiple computation traces.\nThis includes many information-flow security policies, such as observational\ndeterminism, (generalized) noninterference, and noninference, and other system\nproperties like symmetry or Hamming distances between in error-resistant codes.\nWe introduce MGHyper, a tool for automatic satisfiability checking and model\ngeneration for hyperproperties expressed in HyperLTL. Unlike previous\nsatisfiability checkers, MGHyper is not limited to the decidable $\\exists^*\n\\forall^*$ fragment of HyperLTL, but provides a semi-decisionprocedure for the\nfull logic. An important application of MGHyper is to automatically check\nequivalences between different hyperproperties (and different formalizations of\nthe same hyperproperty) and to build counterexamples that disprove a certain\nclaimed implication. We describe the semi-decisionprocedure implemented in\nMGHyper and report on experimental results obtained both with typical\nhyperproperties from the literature and with randomly generated HyperLTL\nformulas.\n", "versions": [{"version": "v1", "created": "Tue, 26 Mar 2019 20:09:10 GMT"}], "update_date": "2019-03-28", "authors_parsed": [["Finkbeiner", "Bernd", ""], ["Hahn", "Christopher", ""], ["Hans", "Tobias", ""]]}, {"id": "1903.11391", "submitter": "Manuel Kauers", "authors": "Marijn J.H. Heule, Manuel Kauers, and Martina Seidl", "title": "Local Search for Fast Matrix Multiplication", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Laderman discovered a scheme for computing the product of two 3x3 matrices\nusing only 23 multiplications in 1976. Since then, some more such schemes were\nproposed, but it remains open how many there are and whether there exist\nschemes with fewer than 23 multiplications. In this paper we present two\nindependent SAT-based methods for finding new schemes. Both methods allow\ncomputing a few hundred new schemes individually, and many thousands when\ncombined. Local search SAT solvers outperform CDCL solvers consistently in this\napplication.\n", "versions": [{"version": "v1", "created": "Wed, 27 Mar 2019 12:53:51 GMT"}, {"version": "v2", "created": "Mon, 19 Aug 2019 07:18:38 GMT"}], "update_date": "2019-08-20", "authors_parsed": [["Heule", "Marijn J. H.", ""], ["Kauers", "Manuel", ""], ["Seidl", "Martina", ""]]}, {"id": "1903.12402", "submitter": "EPTCS", "authors": "Pedro Quaresma (University of Coimbra, Portugal), Walther Neuper (Graz\n  University of Technology, Austria)", "title": "Proceedings 7th International Workshop on Theorem proving components for\n  Educational software", "comments": null, "journal-ref": "EPTCS 290, 2019", "doi": "10.4204/EPTCS.290", "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The 7th International Workshop on Theorem proving components for Educational\nsoftware (ThEdu'18) was held in Oxford, United Kingdom, on 18 July 2018. It was\nassociated to the conference, Federated Logic Conference 2018 (FLoC2018).\n  The major aim of the ThEdu workshop series was to link developers interested\nin adapting Computer Theorem Proving (TP) to the needs of education and to\ninform mathematicians and mathematics educators about TP's potential for\neducational software. Topics of interest include: methods of automated\ndeduction applied to checking students' input; methods of automated deduction\napplied to prove post-conditions for particular problem solutions; combinations\nof deduction and computation enabling systems to propose next steps; automated\nprovers specific for dynamic geometry systems; proof and proving in mathematics\neducation.\n  ThEdu'18 was a vibrant workshop, with one invited talk and six contributions.\nIt triggered the post-proceedings at hand.\n", "versions": [{"version": "v1", "created": "Fri, 29 Mar 2019 09:01:07 GMT"}], "update_date": "2019-04-01", "authors_parsed": [["Quaresma", "Pedro", "", "University of Coimbra, Portugal"], ["Neuper", "Walther", "", "Graz\n  University of Technology, Austria"]]}, {"id": "1903.12468", "submitter": "Niveditha Manjunath", "authors": "Ezio Bartocci, Niveditha Manjunath, Leonardo Mariani, Cristinel\n  Mateis, Dejan Ni\\v{c}kovi\\'c", "title": "Automatic Failure Explanation in CPS Models", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Debugging Cyber-Physical System (CPS) models can be extremely complex.\nIndeed, only the detection of a failure is insuffcient to know how to correct a\nfaulty model. Faults can propagate in time and in space producing observable\nmisbehaviours in locations completely different from the location of the fault.\nUnderstanding the reason of an observed failure is typically a challenging and\nlaborious task left to the experience and domain knowledge of the designer. \\n\nIn this paper, we propose CPSDebug, a novel approach that by combining testing,\nspecification mining, and failure analysis, can automatically explain failures\nin Simulink/Stateflow models. We evaluate CPSDebug on two case studies,\ninvolving two use scenarios and several classes of faults, demonstrating the\npotential value of our approach.\n", "versions": [{"version": "v1", "created": "Fri, 29 Mar 2019 12:26:42 GMT"}], "update_date": "2020-10-14", "authors_parsed": [["Bartocci", "Ezio", ""], ["Manjunath", "Niveditha", ""], ["Mariani", "Leonardo", ""], ["Mateis", "Cristinel", ""], ["Ni\u010dkovi\u0107", "Dejan", ""]]}, {"id": "1903.12510", "submitter": "Richard Taupe", "authors": "Richard Taupe, Antonius Weinzierl, Gerhard Friedrich", "title": "Degrees of Laziness in Grounding: Effects of Lazy-Grounding Strategies\n  on ASP Solving", "comments": null, "journal-ref": "In: Logic Programming and Nonmonotonic Reasoning. LPNMR 2019.\n  Lecture Notes in Computer Science, vol 11481. Springer, Cham", "doi": "10.1007/978-3-030-20528-7_22", "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The traditional ground-and-solve approach to Answer Set Programming (ASP)\nsuffers from the grounding bottleneck, which makes large-scale problem\ninstances unsolvable. Lazy grounding is an alternative approach that\ninterleaves grounding with solving and thus uses space more efficiently. The\nlimited view on the search space in lazy grounding poses unique challenges,\nhowever, and can have adverse effects on solving performance. In this paper we\npresent a novel characterization of degrees of laziness in grounding for ASP,\ni.e. of compromises between lazily grounding as little as possible and the\ntraditional full grounding upfront. We investigate how these degrees of\nlaziness compare to each other formally as well as, by means of an experimental\nanalysis using a number of benchmarks, in terms of their effects on solving\nperformance. Our contributions are the introduction of a range of novel lazy\ngrounding strategies, a formal account on their relationships and their\ncorrectness, and an investigation of their effects on solving performance.\nExperiments show that our approach performs significantly better than\nstate-of-the-art lazy grounding in many cases.\n", "versions": [{"version": "v1", "created": "Fri, 29 Mar 2019 13:22:33 GMT"}, {"version": "v2", "created": "Fri, 19 Jul 2019 06:18:16 GMT"}], "update_date": "2019-07-22", "authors_parsed": [["Taupe", "Richard", ""], ["Weinzierl", "Antonius", ""], ["Friedrich", "Gerhard", ""]]}, {"id": "1903.12576", "submitter": "Philipp J. Meyer", "authors": "Michael Luttenberger and Philipp J. Meyer and Salomon Sickert", "title": "Practical Synthesis of Reactive Systems from LTL Specifications via\n  Parity Games", "comments": null, "journal-ref": null, "doi": "10.1007/s00236-019-00349-3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The synthesis of reactive systems from linear temporal logic (LTL)\nspecifications is an important aspect in the design of reliable software and\nhardware. We present our adaption of the classic automata-theoretic approach to\nLTL synthesis, implemented in the tool Strix which has won the two last\nsynthesis competitions (Syntcomp2018/2019). The presented approach is (1)\nstructured, meaning that the states used in the construction have a semantic\nstructure that is exploited in several ways, it performs a (2) forward\nexploration such that it often constructs only a small subset of the reachable\nstates, and it is (3) incremental in the sense that it reuses results from\nprevious inconclusive solution attempts. Further, we present and study\ndifferent guiding heuristics that determine where to expand the on-demand\nconstructed arena. Moreover, we show several techniques for extracting an\nimplementation (Mealy machine or circuit) from the witness of the\ntree-automaton emptiness check. Lastly, the chosen constructions use a symbolic\nrepresentation of the transition functions to reduce runtime and memory\nconsumption. We evaluate the proposed techniques on the Syntcomp2019 benchmark\nset and show in more detail how the proposed techniques compare to the\ntechniques implemented in other leading LTL synthesis tools.\n", "versions": [{"version": "v1", "created": "Fri, 29 Mar 2019 15:36:27 GMT"}, {"version": "v2", "created": "Wed, 30 Oct 2019 16:28:09 GMT"}], "update_date": "2020-02-21", "authors_parsed": [["Luttenberger", "Michael", ""], ["Meyer", "Philipp J.", ""], ["Sickert", "Salomon", ""]]}, {"id": "1903.12653", "submitter": "Jean Goubault-Larrecq", "authors": "Jean Goubault-Larrecq", "title": "Fooling the Parallel Or Tester with Probability $8/27$", "comments": "Added missing two operational rules for 'if' in Figure 2; 24 pages, 3\n  figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is well-known that the higher-order language PCF is not fully abstract:\nthere is a program - the so-called parallel or tester, meant to test whether\nits input behaves as a parallel or - which never terminates on any input,\noperationally, but is denotationally non-trivial. We explore a probabilistic\nvariant of PCF, and ask whether the parallel or tester exhibits a similar\nbehavior there. The answer is no: operationally, one can feed the parallel or\ntester an input that will fool it into thinking it is a parallel or. We show\nthat the largest probability of success of such would-be parallel ors is\nexactly $8/27$. The bound is reached by a very simple probabilistic program.\nThe difficult part is to show that that bound cannot be exceeded.\n", "versions": [{"version": "v1", "created": "Fri, 29 Mar 2019 17:57:57 GMT"}, {"version": "v2", "created": "Thu, 31 Oct 2019 07:38:50 GMT"}], "update_date": "2019-11-01", "authors_parsed": [["Goubault-Larrecq", "Jean", ""]]}]