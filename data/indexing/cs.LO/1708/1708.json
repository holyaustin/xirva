[{"id": "1708.00072", "submitter": "Tobias Kapp\\'e", "authors": "Tobias Kapp\\'e, Farhad Arbab and Carolyn Talcott", "title": "A Component-oriented Framework for Autonomous Agents", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-319-68034-7_2", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The design of a complex system warrants a compositional methodology, i.e.,\ncomposing simple components to obtain a larger system that exhibits their\ncollective behavior in a meaningful way. We propose an automaton-based paradigm\nfor compositional design of such systems where an action is accompanied by one\nor more preferences. At run-time, these preferences provide a natural fallback\nmechanism for the component, while at design-time they can be used to reason\nabout the behavior of the component in an uncertain physical world. Using\nstructures that tell us how to compose preferences and actions, we can compose\nformal representations of individual components or agents to obtain a\nrepresentation of the composed system. We extend Linear Temporal Logic with two\nunary connectives that reflect the compositional structure of the actions, and\nshow how it can be used to diagnose undesired behavior by tracing the\nfalsification of a specification back to one or more culpable components.\n", "versions": [{"version": "v1", "created": "Mon, 31 Jul 2017 21:11:52 GMT"}], "update_date": "2017-10-24", "authors_parsed": [["Kapp\u00e9", "Tobias", ""], ["Arbab", "Farhad", ""], ["Talcott", "Carolyn", ""]]}, {"id": "1708.00148", "submitter": "Thorsten Wissmann", "authors": "Siddharth Bhaskar and Alex Kruckman", "title": "Tameness in least fixed-point logic and McColm's conjecture", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 17, Issue 1 (January\n  22, 2021) lmcs:7123", "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We investigate four model-theoretic tameness properties in the context of\nleast fixed-point logic over a family of finite structures. We find that each\nof these properties depends only on the elementary (i.e., first-order) limit\ntheory, and we completely determine the valid entailments among them. In\ncontrast to the context of first-order logic on arbitrary structures, the order\nproperty and independence property are equivalent in this setting. McColm\nconjectured that least fixed-point definability collapses to first-order\ndefinability exactly when proficiency fails. McColm's conjecture is known to be\nfalse in general. However, we show that McColm's conjecture is true for any\nfamily of finite structures whose limit theory is model-theoretically tame.\n", "versions": [{"version": "v1", "created": "Tue, 1 Aug 2017 03:31:44 GMT"}, {"version": "v2", "created": "Wed, 2 Aug 2017 02:54:19 GMT"}, {"version": "v3", "created": "Sat, 27 Jan 2018 20:37:18 GMT"}, {"version": "v4", "created": "Mon, 2 Apr 2018 18:25:43 GMT"}, {"version": "v5", "created": "Fri, 3 Jan 2020 19:29:34 GMT"}, {"version": "v6", "created": "Wed, 28 Oct 2020 09:19:38 GMT"}, {"version": "v7", "created": "Sat, 28 Nov 2020 17:52:10 GMT"}, {"version": "v8", "created": "Thu, 21 Jan 2021 08:09:27 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Bhaskar", "Siddharth", ""], ["Kruckman", "Alex", ""]]}, {"id": "1708.00378", "submitter": "EPTCS", "authors": "Pierfrancesco Guarino (School of Business and Economics, Maastricht\n  University)", "title": "The Topology-Free Construction of the Universal Type Structure for\n  Conditional Probability Systems", "comments": "In Proceedings TARK 2017, arXiv:1707.08250", "journal-ref": "EPTCS 251, 2017, pp. 285-305", "doi": "10.4204/EPTCS.251.20", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We construct the universal type structure for conditional probability systems\nwithout any topological assumption, namely a type structure that is terminal,\nbelief-complete, and non-redundant. In particular, in order to obtain the\nbelief-completeness in a constructive way, we extend the work of Meier [An\nInfinitary Probability Logic for Type Spaces. Israel Journal of Mathematics,\n192, 1-58] by proving strong soundness and strong completeness of an infinitary\nconditional probability logic with truthful and non-epistemic conditioning\nevents.\n", "versions": [{"version": "v1", "created": "Thu, 27 Jul 2017 11:26:02 GMT"}], "update_date": "2017-08-02", "authors_parsed": [["Guarino", "Pierfrancesco", "", "School of Business and Economics, Maastricht\n  University"]]}, {"id": "1708.00400", "submitter": "Jaroslav Bendik", "authors": "Jaroslav Bendik, Ivana Cerna, and Nikola Benes", "title": "Recursive Online Enumeration of All Minimal Unsatisfiable Subsets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In various areas of computer science, we deal with a set of constraints to be\nsatisfied. If the constraints cannot be satisfied simultaneously, it is\ndesirable to identify the core problems among them. Such cores are called\nminimal unsatisfiable subsets (MUSes). The more MUSes are identified, the more\ninformation about the conflicts among the constraints is obtained. However, a\nfull enumeration of all MUSes is in general intractable due to the large number\n(even exponential) of possible conflicts. Moreover, to identify MUSes\nalgorithms must test sets of constraints for their simultaneous satisfiabilty.\nThe type of the test depends on the application domains. The complexity of\ntests can be extremely high especially for domains like temporal logics, model\nchecking, or SMT. In this paper, we propose a recursive algorithm that\nidentifies MUSes in an online manner (i.e., one by one) and can be terminated\nat any time. The key feature of our algorithm is that it minimizes the number\nof satisfiability tests and thus speeds up the computation. The algorithm is\napplicable to an arbitrary constraint domain and its effectiveness demonstrates\nitself especially in domains with expensive satisfiability checks. We benchmark\nour algorithm against state of the art algorithm on Boolean and SMT constraint\ndomains and demonstrate that our algorithm really requires less satisfiability\ntests and consequently finds more MUSes in given time limits.\n", "versions": [{"version": "v1", "created": "Tue, 1 Aug 2017 15:57:18 GMT"}, {"version": "v2", "created": "Mon, 12 Feb 2018 13:58:42 GMT"}, {"version": "v3", "created": "Tue, 8 May 2018 12:14:23 GMT"}], "update_date": "2018-05-09", "authors_parsed": [["Bendik", "Jaroslav", ""], ["Cerna", "Ivana", ""], ["Benes", "Nikola", ""]]}, {"id": "1708.00699", "submitter": "Alexander Weinert", "authors": "Alexander Weinert", "title": "VLDL Satisfiability and Model Checking via Tree Automata", "comments": "14 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present novel algorithms solving the satisfiability problem and the model\nchecking problem for Visibly Linear Dynamic Logic (VLDL) in asymptotically\noptimal time via a reduction to the emptiness problem for tree automata with\nB\\\"uchi acceptance. Since VLDL allows for the specification of important\nproperties of recursive systems, this reduction enables the efficient analysis\nof such systems.\n  Furthermore, as the problem of tree automata emptiness is well-studied, this\nreduction enables leveraging the mature algorithms and tools for that problem\nin order to solve the satisfiability problem and the model checking problem for\nVLDL.\n", "versions": [{"version": "v1", "created": "Wed, 2 Aug 2017 11:11:31 GMT"}], "update_date": "2017-08-03", "authors_parsed": [["Weinert", "Alexander", ""]]}, {"id": "1708.00843", "submitter": "EPTCS", "authors": "Linde Wester (University of Oxford)", "title": "Almost Equivalent Paradigms of Contextuality", "comments": "In Proceedings QPL 2017, arXiv:1802.09737", "journal-ref": "EPTCS 266, 2018, pp. 1-22", "doi": "10.4204/EPTCS.266.1", "report-no": null, "categories": "quant-ph cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Various frameworks that generalise the notion of contextuality in theories of\nphysics have been proposed; one is the sheaf-theoretic approach by Abramsky and\nBrandenburger; an other is the equivalence-based approach by Spekkens. We show\nthat these frameworks are equivalent for scenarios with preparations and\nmeasurements, whenever factorizability is justified. This connection gives rise\nto a categorical isomorphism between suitable categories. We combine the\nadvantages of the two approaches to derive a canonical method for detecting\ncontextuality in such settings.\n", "versions": [{"version": "v1", "created": "Wed, 2 Aug 2017 17:35:07 GMT"}, {"version": "v2", "created": "Fri, 2 Mar 2018 03:43:21 GMT"}], "update_date": "2018-03-05", "authors_parsed": [["Wester", "Linde", "", "University of Oxford"]]}, {"id": "1708.01139", "submitter": "Thorsten Wissmann", "authors": "Nathanael L. Ackerman, Cameron E. Freer, Robert S. Lubarsky", "title": "Feedback computability on Cantor space", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 2 (April 30,\n  2019) lmcs:5410", "doi": "10.23638/LMCS-15(2:7)2019", "report-no": null, "categories": "math.LO cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We introduce the notion of feedback computable functions from $2^\\omega$ to\n$2^\\omega$, extending feedback Turing computation in analogy with the standard\nnotion of computability for functions from $2^\\omega$ to $2^\\omega$. We then\nshow that the feedback computable functions are precisely the effectively Borel\nfunctions. With this as motivation we define the notion of a feedback\ncomputable function on a structure, independent of any coding of the structure\nas a real. We show that this notion is absolute, and as an example characterize\nthose functions that are computable from a Gandy ordinal with some finite\nsubset distinguished.\n", "versions": [{"version": "v1", "created": "Thu, 3 Aug 2017 13:53:00 GMT"}, {"version": "v2", "created": "Sat, 3 Nov 2018 20:06:27 GMT"}, {"version": "v3", "created": "Wed, 13 Feb 2019 16:35:32 GMT"}, {"version": "v4", "created": "Sat, 23 Feb 2019 06:37:57 GMT"}, {"version": "v5", "created": "Mon, 29 Apr 2019 11:57:51 GMT"}], "update_date": "2019-09-04", "authors_parsed": [["Ackerman", "Nathanael L.", ""], ["Freer", "Cameron E.", ""], ["Lubarsky", "Robert S.", ""]]}, {"id": "1708.01473", "submitter": "Alberto Pettorossi", "authors": "Emanuele De Angelis (1), Fabio Fioravanti (1), Alberto Pettorossi (2),\n  Maurizio Proietti (3) ((1) DEC, University G. D'Annunzio, Pescara, Italy, (2)\n  DICII, Universita' di Roma Tor Vergata, Roma, Italy, (3) CNR-IASI, Roma,\n  Italy)", "title": "Predicate Pairing for Program Verification", "comments": "Published in Theory and Practice of Logic Programming (TPLP)", "journal-ref": "DE ANGELIS, E., FIORAVANTI, F., PETTOROSSI, A., & PROIETTI, M.\n  (2018). Predicate Pairing for program verification. Theory and Practice of\n  Logic Programming, 18(2), pages 126-166", "doi": "10.1017/S1471068417000497", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is well-known that the verification of partial correctness properties of\nimperative programs can be reduced to the satisfiability problem for\nconstrained Horn clauses (CHCs). However, state-of-the-art solvers for CHCs\n(CHC solvers) based on predicate abstraction are sometimes unable to verify\nsatisfiability because they look for models that are definable in a given class\nA of constraints, called A-definable models. We introduce a transformation\ntechnique, called Predicate Pairing (PP), which is able, in many interesting\ncases, to transform a set of clauses into an equisatisfiable set whose\nsatisfiability can be proved by finding an A-definable model, and hence can be\neffectively verified by CHC solvers. We prove that, under very general\nconditions on A, the unfold/fold transformation rules preserve the existence of\nan A-definable model, i.e., if the original clauses have an A-definable model,\nthen the transformed clauses have an A-definable model. The converse does not\nhold in general, and we provide suitable conditions under which the transformed\nclauses have an A-definable model iff the original ones have an A-definable\nmodel. Then, we present the PP strategy which guides the application of the\ntransformation rules with the objective of deriving a set of clauses whose\nsatisfiability can be proved by looking for A-definable models. PP introduces a\nnew predicate defined by the conjunction of two predicates together with some\nconstraints. We show through some examples that an A-definable model may exist\nfor the new predicate even if it does not exist for its defining atomic\nconjuncts. We also present some case studies showing that PP plays a crucial\nrole in the verification of relational properties of programs (e.g., program\nequivalence and non-interference). Finally, we perform an experimental\nevaluation to assess the effectiveness of PP in increasing the power of CHC\nsolving.\n", "versions": [{"version": "v1", "created": "Fri, 4 Aug 2017 12:24:22 GMT"}, {"version": "v2", "created": "Wed, 27 Jun 2018 20:39:52 GMT"}], "update_date": "2018-06-29", "authors_parsed": [["De Angelis", "Emanuele", ""], ["Fioravanti", "Fabio", ""], ["Pettorossi", "Alberto", ""], ["Proietti", "Maurizio", ""]]}, {"id": "1708.01477", "submitter": "Rasmus Kr{\\ae}mmer Rendsvig", "authors": "Rasmus K. Rendsvig", "title": "Diffusion, Influence and Best-Response Dynamics in Networks: An Action\n  Model Approach", "comments": "As appeared in R. de Haan (ed.), Proceedings of the ESSLLI 2014\n  Student Session, p. 63-75, T\\\"ubingen, Germany, 2014", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.LO cs.MA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Threshold models and their dynamics may be used to model the spread of\n`behaviors' in social networks. Regarding such from a modal logical\nperspective, it is shown how standard update mechanisms may be emulated using\naction models -- graphs encoding agents' decision rules. A small class of\naction models capturing the possible sets of decision rules suitable for\nthreshold models is identified, and shown to include models characterizing\nbest-response dynamics of both coordination and anti-coordination games played\non graphs.\n", "versions": [{"version": "v1", "created": "Fri, 4 Aug 2017 12:51:51 GMT"}], "update_date": "2017-08-07", "authors_parsed": [["Rendsvig", "Rasmus K.", ""]]}, {"id": "1708.01688", "submitter": "Thorsten Wissmann", "authors": "Annabelle McIver and Carroll Morgan and Tahiry Rabehaja", "title": "Abstract Hidden Markov Models: a monadic account of quantitative\n  information flow", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 1 (March 29,\n  2019) lmcs:5330", "doi": "10.23638/LMCS-15(1:36)2019", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Hidden Markov Models, HMM's, are mathematical models of Markov processes with\nstate that is hidden, but from which information can leak. They are typically\nrepresented as 3-way joint-probability distributions.\n  We use HMM's as denotations of probabilistic hidden-state sequential\nprograms: for that, we recast them as `abstract' HMM's, computations in the\nGiry monad $\\mathbb{D}$, and we equip them with a partial order of increasing\nsecurity. However to encode the monadic type with hiding over some state\n$\\mathcal{X}$ we use $\\mathbb{D}\\mathcal{X}\\to \\mathbb{D}^2\\mathcal{X}$ rather\nthan the conventional $\\mathcal{X}{\\to}\\mathbb{D}\\mathcal{X}$ that suffices for\nMarkov models whose state is not hidden. We illustrate the\n$\\mathbb{D}\\mathcal{X}\\to \\mathbb{D}^2\\mathcal{X}$ construction with a small\nHaskell prototype.\n  We then present uncertainty measures as a generalisation of the extant\ndiversity of probabilistic entropies, with characteristic analytic properties\nfor them, and show how the new entropies interact with the order of increasing\nsecurity. Furthermore, we give a `backwards' uncertainty-transformer semantics\nfor HMM's that is dual to the `forwards' abstract HMM's - it is an analogue of\nthe duality between forwards, relational semantics and backwards,\npredicate-transformer semantics for imperative programs with demonic choice.\n  Finally, we argue that, from this new denotational-semantic viewpoint, one\ncan see that the Dalenius desideratum for statistical databases is actually an\nissue in compositionality. We propose a means for taking it into account.\n", "versions": [{"version": "v1", "created": "Fri, 4 Aug 2017 23:46:00 GMT"}, {"version": "v2", "created": "Mon, 15 Oct 2018 21:59:55 GMT"}, {"version": "v3", "created": "Thu, 28 Mar 2019 17:34:47 GMT"}], "update_date": "2019-04-29", "authors_parsed": [["McIver", "Annabelle", ""], ["Morgan", "Carroll", ""], ["Rabehaja", "Tahiry", ""]]}, {"id": "1708.01745", "submitter": "Radu Grigore", "authors": "Mikolas Janota, Radu Grigore, Vasco Manquinho", "title": "On the Quest for an Acyclic Graph", "comments": "RCRA2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper aims at finding acyclic graphs under a given set of constraints.\nMore specifically, given a propositional formula {\\phi} over edges of a\nfixed-size graph, the objective is to find a model of {\\phi} that corresponds\nto a graph that is acyclic. The paper proposes several encodings of the problem\nand compares them in an experimental evaluation using stateof-the-art SAT\nsolvers.\n", "versions": [{"version": "v1", "created": "Sat, 5 Aug 2017 10:28:43 GMT"}, {"version": "v2", "created": "Mon, 9 Oct 2017 07:34:31 GMT"}], "update_date": "2017-10-10", "authors_parsed": [["Janota", "Mikolas", ""], ["Grigore", "Radu", ""], ["Manquinho", "Vasco", ""]]}, {"id": "1708.02143", "submitter": "Tadeusz Litak", "authors": "Tadeusz Litak and Albert Visser", "title": "Lewis meets Brouwer: constructive strict implication", "comments": "Our invited contribution to the collection \"L.E.J. Brouwer, 50 years\n  later\"", "journal-ref": null, "doi": "10.1016/j.indag.2017.10.003", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  C. I. Lewis invented modern modal logic as a theory of \"strict implication\".\nOver the classical propositional calculus one can as well work with the unary\nbox connective. Intuitionistically, however, the strict implication has greater\nexpressive power than the box and allows to make distinctions invisible in the\nordinary syntax. In particular, the logic determined by the most popular\nsemantics of intuitionistic K becomes a proper extension of the minimal normal\nlogic of the binary connective. Even an extension of this minimal logic with\nthe \"strength\" axiom, classically near-trivial, preserves the distinction\nbetween the binary and the unary setting. In fact, this distinction and the\nstrong constructive strict implication itself has been also discovered by the\nfunctional programming community in their study of \"arrows\" as contrasted with\n\"idioms\". Our particular focus is on arithmetical interpretations of the\nintuitionistic strict implication in terms of preservativity in extensions of\nHeyting's Arithmetic.\n", "versions": [{"version": "v1", "created": "Mon, 7 Aug 2017 14:52:34 GMT"}, {"version": "v2", "created": "Wed, 4 Oct 2017 15:10:34 GMT"}, {"version": "v3", "created": "Sun, 29 Oct 2017 15:27:52 GMT"}], "update_date": "2017-10-31", "authors_parsed": [["Litak", "Tadeusz", ""], ["Visser", "Albert", ""]]}, {"id": "1708.02328", "submitter": "Vikraman Choudhury", "authors": "Ryan Scott, Vikraman Choudhury, Ryan Newton, Niki Vazou and Ranjit\n  Jhala", "title": "Deriving Law-Abiding Instances", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Liquid Haskell's refinement-reflection feature augments the Haskell language\nwith theorem proving capabilities, allowing programmers to retrofit their\nexisting code with proofs. But many of these proofs require routine,\nboilerplate code that is tedious to write. Moreover, many such proofs do not\nscale well, as the size of proof terms can grow superlinearly with the size of\nthe datatypes involved in the proofs.\n  We present a technique for programming with refinement reflection which\nsolves this problem by leveraging datatype-generic programming. Our observation\nis that we can take any algebraic datatype, generate an equivalent\nrepresentation type, and have Liquid Haskell automatically construct (and\nprove) an isomorphism between the original type and the representation type.\nThis reduces many proofs down to easy theorems over simple algebraic \"building\nblock\" types, allowing programmers to write generic proofs cheaply and\ncheerfully.\n", "versions": [{"version": "v1", "created": "Mon, 7 Aug 2017 22:56:20 GMT"}], "update_date": "2017-08-09", "authors_parsed": [["Scott", "Ryan", ""], ["Choudhury", "Vikraman", ""], ["Newton", "Ryan", ""], ["Vazou", "Niki", ""], ["Jhala", "Ranjit", ""]]}, {"id": "1708.02537", "submitter": "Justin Hsu", "authors": "Gilles Barthe, Thomas Espitau, Benjamin Gr\\'egoire, Justin Hsu,\n  Pierre-Yves Strub", "title": "Proving Expected Sensitivity of Probabilistic Programs", "comments": null, "journal-ref": null, "doi": "10.1145/3158145", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program sensitivity, also known as Lipschitz continuity, describes how small\nchanges in a program's input lead to bounded changes in the output. We propose\nan average notion of program sensitivity for probabilistic programs---expected\nsensitivity---that averages a distance function over a probabilistic coupling\nof two output distributions from two similar inputs. By varying the distance,\nexpected sensitivity recovers useful notions of probabilistic function\nsensitivity, including stability of machine learning algorithms and convergence\nof Markov chains.\n  Furthermore, expected sensitivity satisfies clean compositional properties\nand is amenable to formal verification. We develop a relational program logic\ncalled $\\mathbb{E}$pRHL for proving expected sensitivity properties. Our logic\nfeatures two key ideas. First, relational pre-conditions and post-conditions\nare expressed using distances, a real-valued generalization of typical\nboolean-valued (relational) assertions. Second, judgments are interpreted in\nterms of expectation coupling, a novel, quantitative generalization of\nprobabilistic couplings which supports compositional reasoning.\n  We demonstrate our logic on examples beyond the reach of prior relational\nlogics. Our main example formalizes uniform stability of the stochastic\ngradient method. Furthermore, we prove rapid mixing for a probabilistic model\nof population dynamics. We also extend our logic with a transitivity principle\nfor expectation couplings to capture the path coupling proof technique by\nBubley and Dyer, and formalize rapid mixing of the Glauber dynamics from\nstatistical physics.\n", "versions": [{"version": "v1", "created": "Tue, 8 Aug 2017 15:58:45 GMT"}, {"version": "v2", "created": "Wed, 8 Nov 2017 20:31:33 GMT"}], "update_date": "2017-11-10", "authors_parsed": [["Barthe", "Gilles", ""], ["Espitau", "Thomas", ""], ["Gr\u00e9goire", "Benjamin", ""], ["Hsu", "Justin", ""], ["Strub", "Pierre-Yves", ""]]}, {"id": "1708.02654", "submitter": "EPTCS", "authors": "Hans van Ditmarsch, Michael Ian Hartley, Barteld Kooi, Jonathan\n  Welton, Joseph B.W. Yeo", "title": "Cheryl's Birthday", "comments": "In Proceedings TARK 2017, arXiv:1707.08250", "journal-ref": "EPTCS 251, 2017, pp. 1-9", "doi": "10.4204/EPTCS.251.1", "report-no": null, "categories": "cs.AI cs.GL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present four logic puzzles and after that their solutions. Joseph Yeo\ndesigned 'Cheryl's Birthday'. Mike Hartley came up with a novel solution for\n'One Hundred Prisoners and a Light Bulb'. Jonathan Welton designed 'A Blind\nGuess' and 'Abby's Birthday'. Hans van Ditmarsch and Barteld Kooi authored the\npuzzlebook 'One Hundred Prisoners and a Light Bulb' that contains other\nknowledge puzzles, and that can also be found on the webpage\nhttp://personal.us.es/hvd/lightbulb.html dedicated to the book.\n", "versions": [{"version": "v1", "created": "Thu, 27 Jul 2017 07:44:49 GMT"}], "update_date": "2017-08-10", "authors_parsed": [["van Ditmarsch", "Hans", ""], ["Hartley", "Michael Ian", ""], ["Kooi", "Barteld", ""], ["Welton", "Jonathan", ""], ["Yeo", "Joseph B. W.", ""]]}, {"id": "1708.02710", "submitter": "Vikraman Choudhury", "authors": "Jacques Carette, Chao-Hong Chen, Vikraman Choudhury and Amr Sabry", "title": "From Reversible Programs to Univalent Universes and Back", "comments": null, "journal-ref": null, "doi": "10.1016/j.entcs.2018.03.013", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We establish a close connection between a reversible programming language\nbased on type isomorphisms and a formally presented univalent universe. The\ncorrespondence relates combinators witnessing type isomorphisms in the\nprogramming language to paths in the univalent universe; and combinator\noptimizations in the programming language to 2-paths in the univalent universe.\nThe result suggests a simple computational interpretation of paths and of\nunivalence in terms of familiar programming constructs whenever the universe in\nquestion is computable.\n", "versions": [{"version": "v1", "created": "Wed, 9 Aug 2017 04:03:13 GMT"}], "update_date": "2019-07-16", "authors_parsed": [["Carette", "Jacques", ""], ["Chen", "Chao-Hong", ""], ["Choudhury", "Vikraman", ""], ["Sabry", "Amr", ""]]}, {"id": "1708.02844", "submitter": "Davide Antonio Nello Maran", "authors": "Davide Maran", "title": "A simple way to reduce factorization problems to SAT", "comments": "Poorly written, not very relevant", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As Cook-Levin theorem showed, every NP problem can be reduced to SAT in\npolynomial time. In this paper I show a simpler and more efficent method to\nreduce some factorization problems to the satisfability of a boolean formula.\n", "versions": [{"version": "v1", "created": "Fri, 23 Jun 2017 18:36:20 GMT"}, {"version": "v2", "created": "Tue, 28 Apr 2020 07:51:51 GMT"}], "update_date": "2020-04-29", "authors_parsed": [["Maran", "Davide", ""]]}, {"id": "1708.03403", "submitter": "Agi Kurucz", "authors": "Stanislav Kikot, Agi Kurucz, Yoshihito Tanaka, Frank Wolter, and\n  Michael Zakharyaschev", "title": "Kripke Completeness of Strictly Positive Modal Logics over\n  Meet-semilattices with Operators", "comments": null, "journal-ref": "Journal of Symbolic Logic, 84 (2019), pp.533-588", "doi": "10.1017/jsl.2019.22", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Our concern is the completeness problem for spi-logics, that is, sets of\nimplications between strictly positive formulas built from propositional\nvariables, conjunction and modal diamond operators. Originated in logic,\nalgebra and computer science, spi-logics have two natural semantics:\nmeet-semilattices with monotone operators providing Birkhoff-style calculi, and\nfirst-order relational structures (aka Kripke frames) often used as the\nintended structures in applications. Here we lay foundations for a completeness\ntheory that aims to answer the question whether the two semantics define the\nsame consequence relations for a given spi-logic.\n", "versions": [{"version": "v1", "created": "Thu, 10 Aug 2017 22:44:53 GMT"}, {"version": "v2", "created": "Sun, 11 Nov 2018 11:23:56 GMT"}, {"version": "v3", "created": "Fri, 22 Mar 2019 16:04:41 GMT"}], "update_date": "2019-06-12", "authors_parsed": [["Kikot", "Stanislav", ""], ["Kurucz", "Agi", ""], ["Tanaka", "Yoshihito", ""], ["Wolter", "Frank", ""], ["Zakharyaschev", "Michael", ""]]}, {"id": "1708.03536", "submitter": "Guido Mart\\'inez", "authors": "Alejandro D\\'iaz-Caro and Guido Mart\\'inez", "title": "Confluence in Probabilistic Rewriting", "comments": "LSFA 2017 Final version", "journal-ref": "ENTCS 338:115-131, 2018", "doi": "10.1016/j.entcs.2018.10.008", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Driven by the interest of reasoning about probabilistic programming\nlanguages, we set out to study a notion of unicity of normal forms for them. To\nprovide a tractable proof method for it, we define a property of distribution\nconfluence which is shown to imply the desired uniqueness (even for infinite\nsequences of reduction) and further properties. We then carry over several\ncriteria from the classical case, such as Newman's lemma, to simplify proving\nconfluence in concrete languages. Using these criteria, we obtain simple proofs\nof confluence for $\\lambda_1$, an affine probabilistic $\\lambda$-calculus, and\nfor Q$^*$, a quantum programming language for which a related property has\nalready been proven in the literature.\n", "versions": [{"version": "v1", "created": "Fri, 11 Aug 2017 13:26:43 GMT"}, {"version": "v2", "created": "Tue, 1 May 2018 03:12:16 GMT"}], "update_date": "2018-11-06", "authors_parsed": [["D\u00edaz-Caro", "Alejandro", ""], ["Mart\u00ednez", "Guido", ""]]}, {"id": "1708.03603", "submitter": "Miko{\\l}aj Boja\\'nczyk", "authors": "Mikolaj Bojanczyk", "title": "Star Height via Games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes a new algorithm deciding the star height problem. As\nshown by Kirsten, the star height problem reduces to a problem concerning\nautomata with counters, called limitedness. The new contribution is a different\nalgorithm for the limitedness problem, which reduces it to solving a\nGale-Stewart game with an {\\omega}-regular winning condition.\n", "versions": [{"version": "v1", "created": "Fri, 11 Aug 2017 16:26:39 GMT"}], "update_date": "2017-08-14", "authors_parsed": [["Bojanczyk", "Mikolaj", ""]]}, {"id": "1708.04070", "submitter": "Ra\\'ul Pardo", "authors": "Ra\\'ul Pardo, C\\'esar S\\'anchez and Gerardo Schneider", "title": "Timed Epistemic Knowledge Bases for Social Networks (Extended Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CR cs.SI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an epistemic logic equipped with time-stamps in the atoms and\nepistemic operators, which allows to reason not only about information\navailable to the different agents, but also about the moments at which events\nhappens and new knowledge is acquired or deduced. Our logic includes both an\nepistemic operator and a belief operator, which allows to model the disclosure\nof information that may not be accurate.\n  Our main motivation is to model rich privacy policies in online social\nnetworks. Online Social Networks (OSNs) are increasingly used for social\ninteractions in the modern digital era, which bring new challenges and concerns\nin terms of privacy. Most social networks today offer very limited mechanisms\nto express the desires of users in terms of how information that affects their\nprivacy is shared. In particular, most current privacy policy formalisms allow\nonly static policies, which are not rich enough to express timed properties\nlike \"my location after work should not be disclosed to my boss\". The logic we\npresent in this paper enables to express rich properties and policies in terms\nof the knowledge available to the different users and the precise time of\nactions and deductions. Our framework can be instantiated for different OSNs,\nby specifying the effect of the actions in the evolution of the social network\nand in the knowledge disclosed to each agent.\n  We present an algorithm for deducing knowledge, which can also be\ninstantiated with different variants of how the epistemic information is\npreserved through time. Our algorithm allows to model not only social networks\nwith eternal information but also networks with ephemeral disclosures. Policies\nare modelled as formulae in the logic, which are interpreted over timed traces\nrepresenting the evolution of the social network.\n", "versions": [{"version": "v1", "created": "Mon, 14 Aug 2017 10:47:33 GMT"}, {"version": "v2", "created": "Fri, 8 Sep 2017 13:11:57 GMT"}, {"version": "v3", "created": "Wed, 9 May 2018 09:40:36 GMT"}], "update_date": "2018-05-10", "authors_parsed": [["Pardo", "Ra\u00fal", ""], ["S\u00e1nchez", "C\u00e9sar", ""], ["Schneider", "Gerardo", ""]]}, {"id": "1708.04100", "submitter": "Ioannis Kokkinis", "authors": "Ioannis Kokkinis", "title": "The Complexity of Probabilistic Justification Logic", "comments": "presented to the 11th Panhellenic Logic Symposium\n  (http://pls11.cs.ntua.gr/)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Probabilistic justification logic is a modal logic with two kind of\nmodalities: probability measures and explicit justification terms. We present a\ntableau procedure that can be used to decide the satisfiability problem for\nthis logic in polynomial space. We show that this upper complexity bound is\ntight.\n", "versions": [{"version": "v1", "created": "Mon, 14 Aug 2017 12:42:45 GMT"}], "update_date": "2017-08-15", "authors_parsed": [["Kokkinis", "Ioannis", ""]]}, {"id": "1708.04845", "submitter": "EPTCS", "authors": "Karoliina Lehtinen (University of Kiel)", "title": "The Descriptive Complexity of Modal $\\mu$ Model-checking Games", "comments": "In Proceedings GandALF 2017, arXiv:1709.01761", "journal-ref": "EPTCS 256, 2017, pp. 76-90", "doi": "10.4204/EPTCS.256.6", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper revisits the well-established relationship between the modal mu\ncalculus and parity games to show that it is even more robust than previously\nknown. It addresses the question of whether the descriptive complexity of modal\nmu model-checking games, previously known to depend on the syntactic complexity\nof a formula, depends in fact on its semantic complexity. It shows that up to\nformulas of semantic co-B\\\"uchi complexity, the descriptive complexity of their\nmodel-checking games coincides exactly with their semantic complexity. Beyond\nco-B\\\"uchi, the descriptive complexity of the model-checking parity games of a\nformula is shown to be an upper bound on its semantic complexity; whether it is\nalso a lower bound remains an open question.\n", "versions": [{"version": "v1", "created": "Wed, 16 Aug 2017 11:02:36 GMT"}, {"version": "v2", "created": "Thu, 7 Sep 2017 06:55:29 GMT"}], "update_date": "2017-09-08", "authors_parsed": [["Lehtinen", "Karoliina", "", "University of Kiel"]]}, {"id": "1708.04976", "submitter": "Jasine Babu", "authors": "Jasine Babu, K. Murali Krishnan and Vineeth Paleri", "title": "A fix-point characterization of Herbrand equivalence of expressions in\n  data flow frameworks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of determining Herbrand equivalence of terms at each program\npoint in a data flow framework is a central and well studied question in\nprogram analysis. Most of the well-known algorithms for the computation of\nHerbrand equivalence in data flow frameworks proceed via iterative fix-point\ncomputation on some abstract lattice of short expressions relevant to the given\nflow graph. However the mathematical definition of Herbrand equivalence is\nbased on a meet over all path characterization over the (infinite) set of all\npossible expressions. The aim of this paper is to develop a lattice theoretic\nfix-point formulation of Herbrand equivalence on the (infinite) concrete\nlattice defined over the set of all terms constructible from variables,\nconstants and operators of a program. The present characterization uses an\naxiomatic formulation of the notion of Herbrand congruence and defines the\n(infinite) concrete lattice of Herbrand congruences. Transfer functions and\nnon-deterministic assignments are formulated as monotone functions over this\nconcrete lattice. Herbrand equivalence is defined as the maximum fix point of a\ncomposite transfer function defined over an appropriate product lattice of the\nabove concrete lattice. A re-formulation of the classical meet-over-all-paths\ndefinition of Herbrand equivalence in the above lattice theoretic framework is\nalso presented and is proven to be equivalent to the new lattice theoretic\nfix-point characterization.\n", "versions": [{"version": "v1", "created": "Wed, 16 Aug 2017 17:05:01 GMT"}, {"version": "v2", "created": "Fri, 20 Oct 2017 14:51:44 GMT"}], "update_date": "2017-10-23", "authors_parsed": [["Babu", "Jasine", ""], ["Krishnan", "K. Murali", ""], ["Paleri", "Vineeth", ""]]}, {"id": "1708.05193", "submitter": "Ale\\v{s} Bizjak", "authors": "Nick Benton, Martin Hofmann, Vivek Nigam", "title": "Proof-Relevant Logical Relations for Name Generation", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 14, Issue 1 (March 30,\n  2018) lmcs:4415", "doi": "10.23638/LMCS-14(1:25)2018", "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Pitts and Stark's $\\nu$-calculus is a paradigmatic total language for\nstudying the problem of contextual equivalence in higher-order languages with\nname generation. Models for the $\\nu$-calculus that validate basic equivalences\nconcerning names may be constructed using functor categories or nominal sets,\nwith a dynamic allocation monad used to model computations that may allocate\nfresh names. If recursion is added to the language and one attempts to adapt\nthe models from (nominal) sets to (nominal) domains, however, the direct-style\nconstruction of the allocation monad no longer works. This issue has previously\nbeen addressed by using a monad that combines dynamic allocation with\ncontinuations, at some cost to abstraction.\n  This paper presents a direct-style model of a $\\nu$-calculus-like language\nwith recursion using the novel framework of proof-relevant logical relations,\nin which logical relations also contain objects (or proofs) demonstrating the\nequivalence of (the semantic counterparts of) programs. Apart from providing a\nfresh solution to an old problem, this work provides an accessible setting in\nwhich to introduce the use of proof-relevant logical relations, free of the\nadditional complexities associated with their use for more sophisticated\nlanguages.\n", "versions": [{"version": "v1", "created": "Thu, 17 Aug 2017 10:04:53 GMT"}, {"version": "v2", "created": "Thu, 29 Mar 2018 07:25:02 GMT"}], "update_date": "2018-03-30", "authors_parsed": [["Benton", "Nick", ""], ["Hofmann", "Martin", ""], ["Nigam", "Vivek", ""]]}, {"id": "1708.05240", "submitter": "Keehang Kwon", "authors": "Keehang Kwon", "title": "On Answer Substitutions in Logic Programming", "comments": "3 pages. We introduce the notion of don't-know constants", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Answer substitutions play a central role in logic programming. To support\n{\\it selective} answer substitutions, we refine $\\exists x$ in goals into two\ndifferent versions: the noisy version $\\exists^o x$ and the silent version\n$\\exists x$. The main difference is that only the instantiation in $\\exists^o\nx$ will be recorded in the answer substitutions. Similarly for $\\forall x$. In\naddition, we discuss the notion of don't-care constants and don't-know\nconstants.\n", "versions": [{"version": "v1", "created": "Thu, 17 Aug 2017 12:45:38 GMT"}, {"version": "v2", "created": "Sat, 27 Jan 2018 10:44:30 GMT"}], "update_date": "2018-01-30", "authors_parsed": [["Kwon", "Keehang", ""]]}, {"id": "1708.05377", "submitter": "Michele Boreale", "authors": "Michele Boreale", "title": "Complete algorithms for algebraic strongest postconditions and weakest\n  preconditions in polynomial ODEs", "comments": "19 pages", "journal-ref": "Science of Computer Programming 193 (2020) 102441", "doi": "10.1016/j.scico.2020.102441", "report-no": "DISIA WORKING PAPER 2018/03", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A system of polynomial ordinary differential equations (ODEs) is specified\nvia a vector of multivariate polynomials, or vector field, $F$. A safety\nassertion $\\psi\\rightarrow[F]\\phi$ means that the trajectory of the system will\nlie in a subset $\\phi$ (the postcondition) of the state-space, whenever the\ninitial state belongs to a subset $\\psi$ (the precondition). We consider the\ncase when $\\phi$ and $\\psi$ are algebraic varieties, that is, zero sets of\npolynomials. In particular, polynomials specifying the postcondition can be\nseen as a system's conservation laws implied by $\\psi$. Checking the validity\nof algebraic safety assertions is a fundamental problem in, for instance,\nhybrid systems. We consider a generalized version of this problem, and offer an\nalgorithm that, given a user specified polynomial set $P$ and an algebraic\nprecondition $\\psi$, finds the largest subset of polynomials in $P$ implied by\n$\\psi$ (relativized strongest postcondition). Under certain assumptions on\n$\\phi$, this algorithm can also be used to find the largest algebraic invariant\nincluded in $\\phi$ and the weakest algebraic precondition for $\\phi$.\nApplications to continuous semialgebraic systems are also considered. The\neffectiveness of the proposed algorithm is demonstrated on several case studies\nfrom the literature.\n", "versions": [{"version": "v1", "created": "Thu, 17 Aug 2017 17:48:40 GMT"}, {"version": "v2", "created": "Sun, 29 Mar 2020 17:46:53 GMT"}], "update_date": "2020-03-31", "authors_parsed": [["Boreale", "Michele", ""]]}, {"id": "1708.05607", "submitter": "Tadeusz Litak", "authors": "Tadeusz Litak", "title": "Constructive Modalities with Provability Smack", "comments": "The paper is a modified and extended version (\"Author's Cut\") of my\n  contribution for the \"Leo Esakia on Duality in Modal and Intuitionistic\n  Logics.\"", "journal-ref": null, "doi": "10.1007/978-94-017-8860-1_8", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  I overview the work of the Tbilisi school on intuitionistic modal logics of\nwell-founded/scattered structures and its connections with contemporary\ntheoretical computer science. Fixed-point theorems and their consequences are\nof particular interest.\n", "versions": [{"version": "v1", "created": "Fri, 18 Aug 2017 13:42:22 GMT"}], "update_date": "2017-08-21", "authors_parsed": [["Litak", "Tadeusz", ""]]}, {"id": "1708.05640", "submitter": "Abhinav Aggarwal", "authors": "Abhinav Aggarwal", "title": "A similarity criterion for sequential programs using truth-preserving\n  partial functions", "comments": "Submitted as term paper in 2014", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The execution of sequential programs allows them to be represented using\nmathematical functions formed by the composition of statements following one\nafter the other. Each such statement is in itself a partial function, which\nallows only inputs satisfying a particular Boolean condition to carry forward\nthe execution and hence, the composition of such functions (as a result of\nsequential execution of the statements) strengthens the valid set of input\nstate variables for the program to complete its execution and halt succesfully.\nWith this thought in mind, this paper tries to study a particular class of\npartial functions, which tend to preserve the truth of two given Boolean\nconditions whenever the state variables satisfying one are mapped through such\nfunctions into a domain of state variables satisfying the other. The existence\nof such maps allows us to study isomorphism between different programs, based\nnot only on their structural characteristics (e.g. the kind of programming\nconstructs used and the overall input-output transformation), but also the\nnature of computation performed on seemingly different inputs. Consequently, we\ncan now relate programs which perform a given type of computation, like a loop\ncounting down indefinitely, without caring about the input sets they work on\nindividually or the set of statements each program contains.\n", "versions": [{"version": "v1", "created": "Fri, 18 Aug 2017 15:10:11 GMT"}], "update_date": "2017-08-21", "authors_parsed": [["Aggarwal", "Abhinav", ""]]}, {"id": "1708.05714", "submitter": "Mark Inman Ph.D.", "authors": "Mark Inman", "title": "A Stronger Foundation for Computer Science and P=NP", "comments": "13 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article describes a Turing machine which can solve for $\\beta^{'}$ which\nis RE-complete. RE-complete problems are proven to be undecidable by Turing's\naccepted proof on the Entscheidungsproblem. Thus, constructing a machine which\ndecides over $\\beta^{'}$ implies inconsistency in ZFC. We then discover that\nunrestricted use of the axiom of substitution can lead to hidden assumptions in\na certain class of proofs by contradiction. These hidden assumptions create an\nimplied axiom of incompleteness for ZFC. Later, we offer a restriction on the\naxiom of substitution by introducing a new axiom which prevents impredicative\ntautologies from producing theorems. Our discovery in regards to these\nfoundational arguments, disproves the SPACE hierarchy theorem which allows us\nto solve the P vs NP problem using a TIME-SPACE equivalence oracle.\n", "versions": [{"version": "v1", "created": "Fri, 18 Aug 2017 22:36:07 GMT"}, {"version": "v2", "created": "Mon, 23 Apr 2018 12:40:03 GMT"}], "update_date": "2018-04-24", "authors_parsed": [["Inman", "Mark", ""]]}, {"id": "1708.05847", "submitter": "Patricia Bouyer", "authors": "Patricia Bouyer, Serge Haddad, Vincent Jug\\'e", "title": "Unbounded product-form Petri nets", "comments": "31 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PF cs.DM cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Computing steady-state distributions in infinite-state stochastic systems is\nin general a very dificult task. Product-form Petri nets are those Petri nets\nfor which the steady-state distribution can be described as a natural product\ncorresponding, up to a normalising constant, to an exponentiation of the\nmarkings. However, even though some classes of nets are known to have a\nproduct-form distribution, computing the normalising constant can be hard. The\nclass of (closed) {\\Pi}3-nets has been proposed in an earlier work, for which\nit is shown that one can compute the steady-state distribution efficiently.\nHowever these nets are bounded. In this paper, we generalise queuing Markovian\nnetworks and closed {\\Pi}3-nets to obtain the class of open {\\Pi}3-nets, that\ngenerate infinite-state systems. We show interesting properties of these nets:\n(1) we prove that liveness can be decided in polynomial time, and that\nreachability in live {\\Pi}3-nets can be decided in polynomial time; (2) we show\nthat we can decide ergodicity of such nets in polynomial time as well; (3) we\nprovide a pseudo-polynomial time algorithm to compute the normalising constant.\n", "versions": [{"version": "v1", "created": "Sat, 19 Aug 2017 14:06:03 GMT"}], "update_date": "2017-08-22", "authors_parsed": [["Bouyer", "Patricia", ""], ["Haddad", "Serge", ""], ["Jug\u00e9", "Vincent", ""]]}, {"id": "1708.05849", "submitter": "Nicolas Markey", "authors": "Patrick Gardy, Patricia Bouyer, Nicolas Markey", "title": "Dependences in Strategy Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Strategy Logic (SL) is a very expressive logic for specifying and verifying\nproperties of multi-agent systems: in SL, one can quantify over strategies,\nassign them to agents, and express properties of the resulting plays. Such a\npowerful framework has two drawbacks: first, model checking SL has\nnon-elementary complexity; second, the exact semantics of SL is rather\nintricate, and may not correspond to what is expected. In this paper, we focus\non strategy dependences in SL, by tracking how existentially-quantified\nstrategies in a formula may (or may not) depend on other strategies selected in\nthe formula. We study different kinds of dependences, refining the approach of\n[Mogavero et al., Reasoning about strategies: On the model-checking problem,\n2014], and prove that they give rise to different satisfaction relations. In\nthe setting where strategies may only depend on what they have observed, we\nidentify a large fragment of SL for which we prove model checking can be\nperformed in 2EXPTIME.\n", "versions": [{"version": "v1", "created": "Sat, 19 Aug 2017 14:10:22 GMT"}], "update_date": "2017-08-22", "authors_parsed": [["Gardy", "Patrick", ""], ["Bouyer", "Patricia", ""], ["Markey", "Nicolas", ""]]}, {"id": "1708.05896", "submitter": "Harley Eades PhD", "authors": "Harley Eades III and Gianluigi Bellin", "title": "A Cointuitionistic Adjoint Logic", "comments": "54 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One leading question with respect to Bi-intuitionistic logic (BINT) is, what\ndoes BINT look like across the three arcs -- logic, typed $\\lambda$-calculi,\nand category theory -- of the Curry-Howard-Lambek correspondence?\nCategorically, BINT can be seen as a mixing of two worlds: the first being\nintuitionistic logic (IL), which is modeled by a cartesian closed category, and\nthe second being the dual to intuitionistic logic called cointuitionistic logic\n(coIL), which is modeled by a cocartesian coclosed category. Crolard showed\nthat combining these two categories into the same category results in it\ndegenerating to a poset. However, this degeneration does not occur when both\nlogics are linear. We propose that IL and coIL need to be separated, and then\nmixed in a controlled way using the modalities from linear logic. This\nseparation can be ultimately achieved by an adjoint formalization of\nbi-intuitionistic logic. This formalization consists of three worlds instead of\ntwo: the first is intuitionistic logic, the second is linear bi-intuitionistic\n(Bi-ILL), and the third is cointuitionistic logic. They are then related via\ntwo adjunctions. The adjunction between IL and ILL is known as a\nLinear/Non-linear model (LNL model) of ILL, and is due to Benton. However, the\ndual to LNL models which would amount to the adjunction between coILL and coIL\nhas yet to appear in the literature. In this paper we fill this gap by studying\nthe dual to LNL models which we call dual LNL models. We show that dual LNL\nmodels correspond to dual linear categories, the dual to Bierman's linear\ncategories proposed by Bellin. Then we give the definition of bi-LNL models by\ncombining our model with LNL models to obtain a new model of bi-intuitionistic\nlogic. Finally, we give a corresponding sequent calculus, natural deduction,\nand term assignment for dual LNL models.\n", "versions": [{"version": "v1", "created": "Sat, 19 Aug 2017 20:17:43 GMT"}], "update_date": "2017-08-22", "authors_parsed": [["Eades", "Harley", "III"], ["Bellin", "Gianluigi", ""]]}, {"id": "1708.06010", "submitter": "J\\\"urgen Koslowski", "authors": "Yuxi Fu", "title": "The Universal Process", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 13, Issue 4 (November\n  27, 2017) lmcs:4088", "doi": "10.23638/LMCS-13(4:11)2017", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A universal process of a process calculus is one that, given the G\\\"{o}del\nindex of a process of a certain type, produces a process equivalent to the\nencoded process. This paper demonstrates how universal processes can be\nformally defined and how a universal process of the value-passing calculus can\nbe constructed. The existence of such a universal process in a process model\ncan be explored to implement higher order communications, security protocols,\nand programming languages in the process model. A process version of the S-m-n\ntheorem is stated to showcase how to embed the recursion theory in a process\ncalculus.\n", "versions": [{"version": "v1", "created": "Sun, 20 Aug 2017 19:41:13 GMT"}, {"version": "v2", "created": "Wed, 15 Nov 2017 12:34:09 GMT"}, {"version": "v3", "created": "Thu, 16 Nov 2017 11:35:01 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Fu", "Yuxi", ""]]}, {"id": "1708.06121", "submitter": "Domenico Cantone", "authors": "Domenico Cantone, Alfio Giarlotta, Stephen Watson", "title": "The satisfiability problem for Boolean set theory with a choice\n  correspondence (Extended version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Given a set $U$ of alternatives, a choice (correspondence) on $U$ is a\ncontractive map $c$ defined on a family $\\Omega$ of nonempty subsets of $U$.\nSemantically, a choice $c$ associates to each menu $A \\in \\Omega$ a nonempty\nsubset $c(A) \\subseteq A$ comprising all elements of $A$ that are deemed\nselectable by an agent. A choice on $U$ is total if its domain is the powerset\nof $U$ minus the empty set, and partial otherwise. According to the theory of\nrevealed preferences, a choice is rationalizable if it can be retrieved from a\nbinary relation on $U$ by taking all maximal elements of each menu. It is\nwell-known that rationalizable choices are characterized by the satisfaction of\nsuitable axioms of consistency, which codify logical rules of selection within\nmenus. For instance, WARP (Weak Axiom of Revealed Preference) characterizes\nchoices rationalizable by a transitive relation. Here we study the\nsatisfiability problem for unquantified formulae of an elementary fragment of\nset theory involving a choice function symbol $\\mathtt{c}$, the Boolean set\noperators and the singleton, the equality and inclusion predicates, and the\npropositional connectives. In particular, we consider the cases in which the\ninterpretation of $\\mathtt{c}$ satisfies any combination of two specific axioms\nof consistency, whose conjunction is equivalent to WARP. In two cases we prove\nthat the related satisfiability problem is NP-complete, whereas in the\nremaining cases we obtain NP-completeness under the additional assumption that\nthe number of choice terms is constant.\n", "versions": [{"version": "v1", "created": "Mon, 21 Aug 2017 08:44:21 GMT"}, {"version": "v2", "created": "Tue, 22 Aug 2017 07:05:50 GMT"}], "update_date": "2017-08-23", "authors_parsed": [["Cantone", "Domenico", ""], ["Giarlotta", "Alfio", ""], ["Watson", "Stephen", ""]]}, {"id": "1708.06228", "submitter": "Victor Marsault", "authors": "Victor Marsault", "title": "An efficient algorithm to decide periodicity of $b$-recognisable sets\n  using LSDF convention", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 3 (July 31,\n  2019) lmcs:5656", "doi": "10.23638/LMCS-15(3:8)2019", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Let $b$ be an integer strictly greater than $1$. Each set of nonnegative\nintegers is represented in base $b$ by a language over $\\{0, 1, \\dots, b -\n1\\}$. The set is said to be $b$-recognisable if it is represented by a regular\nlanguage. It is known that ultimately periodic sets are $b$-recognisable, for\nevery base $b$, and Cobham's theorem implies the converse: no other set is\n$b$-recognisable in every base $b$.\n  We consider the following decision problem: let $S$ be a set of nonnegative\nintegers that is $b$-recognisable, given as a finite automaton over $\\{0,1,\n\\dots, b - 1\\}$, is $S$ periodic? Honkala showed in 1986 that this problem is\ndecidable. Later on, Leroux used in 2005 the convention to write number\nrepresentations with the least significant digit first (LSDF), and designed a\nquadratic algorithm to solve a more general problem.\n  We use here LSDF convention as well and give a structural description of the\nminimal automata that accept periodic sets. Then, we show that it can be\nverified in linear time if a minimal automaton meets this description. In\ngeneral, this yields a $O(b \\log(n))$ procedure to decide whether an automaton\nwith $n$ states accepts an ultimately periodic set of nonnegative integers.\n", "versions": [{"version": "v1", "created": "Mon, 21 Aug 2017 14:03:03 GMT"}, {"version": "v2", "created": "Mon, 7 May 2018 08:33:47 GMT"}, {"version": "v3", "created": "Wed, 9 May 2018 10:52:19 GMT"}, {"version": "v4", "created": "Fri, 26 Oct 2018 10:24:51 GMT"}, {"version": "v5", "created": "Wed, 19 Dec 2018 16:13:22 GMT"}, {"version": "v6", "created": "Tue, 30 Jul 2019 08:32:52 GMT"}], "update_date": "2019-10-23", "authors_parsed": [["Marsault", "Victor", ""]]}, {"id": "1708.06312", "submitter": "Linda Anticoli", "authors": "Linda Anticoli and Carla Piazza and Leonardo Taglialegne and Paolo\n  Zuliani", "title": "Verifying Quantum Programs: From Quipper to QPMC", "comments": "Long version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  In this paper we present a translation from the quantum programming language\nQuipper to the QPMC model checker, with the main aim of verifying Quipper\nprograms. Quipper is an embedded functional programming language for quantum\ncomputation. It is above all a circuit description language, for this reason it\nuses the vector state formalism and its main purpose is to make circuit\nimplementation easy providing high level operations for circuit manipulation.\nQuipper provides both an high-level circuit building interface and a simulator.\nQPMC is a model checker for quantum protocols based on the density matrix\nformalism. QPMC extends the probabilistic model checker IscasMC allowing to\nformally verify properties specified in the temporal logic QCTL on Quantum\nMarkov Chains. We implemented and tested our translation on several quantum\nalgorithms, including Grover's quantum search.\n", "versions": [{"version": "v1", "created": "Mon, 21 Aug 2017 16:26:23 GMT"}], "update_date": "2017-08-22", "authors_parsed": [["Anticoli", "Linda", ""], ["Piazza", "Carla", ""], ["Taglialegne", "Leonardo", ""], ["Zuliani", "Paolo", ""]]}, {"id": "1708.06696", "submitter": "Daisuke Kimura", "authors": "Daisuke Kimura and Makoto Tatsuta", "title": "Decision Procedure for Entailment of Symbolic Heaps with Arrays", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper gives a decision procedure for the validity of en- tailment of\nsymbolic heaps in separation logic with Presburger arithmetic and arrays. The\ncorrectness of the decision procedure is proved under the condition that sizes\nof arrays in the succedent are not existentially bound. This condition is\nindependent of the condition proposed by the CADE-2017 paper by Brotherston et\nal, namely, one of them does not imply the other. For improving efficiency of\nthe decision procedure, some techniques are also presented. The main idea of\nthe decision procedure is a novel translation of an entailment of symbolic\nheaps into a formula in Presburger arithmetic, and to combine it with an\nexternal SMT solver. This paper also gives experimental results by an\nimplementation, which shows that the decision procedure works efficiently\nenough to use.\n", "versions": [{"version": "v1", "created": "Tue, 22 Aug 2017 16:12:49 GMT"}, {"version": "v2", "created": "Mon, 28 Aug 2017 12:35:26 GMT"}], "update_date": "2017-08-29", "authors_parsed": [["Kimura", "Daisuke", ""], ["Tatsuta", "Makoto", ""]]}, {"id": "1708.06887", "submitter": "EPTCS", "authors": "Alexei Lisitsa (University of Liverpool, UK), Andrei P. Nemytykh\n  (ISPRAS, Russia), Maurizio Proietti (CNR-IASI, Italy)", "title": "Proceedings Fifth International Workshop on Verification and Program\n  Transformation", "comments": null, "journal-ref": "EPTCS 253, 2017", "doi": "10.4204/EPTCS.253", "report-no": null, "categories": "cs.LO cs.PL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Fifth International Workshop on\nVerification and Program Transformation (VPT 2017). The workshop took place in\nUppsala, Sweden, on April 29th, 2017, affiliated with the European Joint\nConferences on Theory and Practice of Software (ETAPS). The aim of the VPT\nworkshop series is to provide a forum where people from the areas of program\ntransformation and program verification can fruitfully exchange ideas and gain\na deeper understanding of the interactions between those two fields. Seven\npapers were presented at the workshop. Additionally, three invited talks were\ngiven by Javier Esparza (Technische Universit\\\"at M\\\"unchen, Germany), Manuel\nHermenegildo (IMDEA Software Institute, Madrid, Spain), and Alexey Khoroshilov\n(Linux Verification Center, ISPRAS, Moscow, Russia).\n", "versions": [{"version": "v1", "created": "Wed, 23 Aug 2017 05:39:02 GMT"}], "update_date": "2017-08-24", "authors_parsed": [["Lisitsa", "Alexei", "", "University of Liverpool, UK"], ["Nemytykh", "Andrei P.", "", "ISPRAS, Russia"], ["Proietti", "Maurizio", "", "CNR-IASI, Italy"]]}, {"id": "1708.06889", "submitter": "EPTCS", "authors": "Adrian Francalanza (University of Malta), Gordon J. Pace (University\n  of Malta)", "title": "Proceedings Second International Workshop on Pre- and Post-Deployment\n  Verification Techniques", "comments": null, "journal-ref": "EPTCS 254, 2017", "doi": "10.4204/EPTCS.254", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of PrePost 2017 (the Second\nInternational Workshop on Pre- and Post-Deployment Verification Techniques),\ntaking place on 19th September 2017 in Torino, Italy, as a satellite event of\nthe 13th International Conference on integrated Formal Methods (iFM 2017).\n  PrePost aims to bridge two areas of research and academic communities: on one\nhand techniques for analysis of systems prior to deployment, on the other\ntechniques for the analysis of systems once they have already been deployed.\nThe workshop brings together researchers working in the field of computer-aided\nvalidation, programming languages and verification to discuss the connections\nand interplay between pre- and post-deployment verification techniques. This\nincludes exploring relationships between techniques such as classic model\nchecking and testing, with ones such as runtime verification and statistical\nmodel checking, between type systems that may be checked either statically or\ndynamically through techniques such as runtime monitoring, gradual typing and\ncontracts.\n", "versions": [{"version": "v1", "created": "Wed, 23 Aug 2017 05:43:55 GMT"}], "update_date": "2017-08-24", "authors_parsed": [["Francalanza", "Adrian", "", "University of Malta"], ["Pace", "Gordon J.", "", "University\n  of Malta"]]}, {"id": "1708.07222", "submitter": "EPTCS", "authors": "Vincent Nys (KU Leuven), Danny De Schreye (KU Leuven)", "title": "Transforming Coroutining Logic Programs into Equivalent CHR Programs", "comments": "In Proceedings VPT 2017, arXiv:1708.06887", "journal-ref": "EPTCS 253, 2017, pp. 9-35", "doi": "10.4204/EPTCS.253.4", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We extend a technique called Compiling Control. The technique transforms\ncoroutining logic programs into logic programs that, when executed under the\nstandard left-to-right selection rule (and not using any delay features) have\nthe same computational behavior as the coroutining program. In recent work, we\nrevised Compiling Control and reformulated it as an instance of Abstract\nConjunctive Partial Deduction. This work was mostly focused on the program\nanalysis performed in Compiling Control. In the current paper, we focus on the\nsynthesis of the transformed program. Instead of synthesizing a new logic\nprogram, we synthesize a CHR(Prolog) program which mimics the coroutining\nprogram. The synthesis to CHR yields programs containing only simplification\nrules, which are particularly amenable to certain static analysis techniques.\nThe programs are also more concise and readable and can be ported to CHR\nimplementations embedded in other languages than Prolog.\n", "versions": [{"version": "v1", "created": "Thu, 24 Aug 2017 00:18:39 GMT"}], "update_date": "2017-08-28", "authors_parsed": [["Nys", "Vincent", "", "KU Leuven"], ["De Schreye", "Danny", "", "KU Leuven"]]}, {"id": "1708.07223", "submitter": "EPTCS", "authors": "G. W. Hamilton (School of Computing, Dublin City University, Republic\n  of Ireland)", "title": "Generating Loop Invariants for Program Verification by Transformation", "comments": "In Proceedings VPT 2017, arXiv:1708.06887", "journal-ref": "EPTCS 253, 2017, pp. 36-53", "doi": "10.4204/EPTCS.253.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Loop invariants play a central role in the verification of imperative\nprograms. However, finding these invariants is often a difficult and\ntime-consuming task for the programmer. We have previously shown how program\ntransformation can be used to facilitate the verification of functional\nprograms, but the verification of imperative programs is more challenging due\nto the need to discover these loop invariants. In this paper, we describe a\ntechnique for automatically discovering loop invariants. Our approach is\nsimilar to the induction-iteration method, but avoids the potentially\nexponential blow-up in clauses that can result when using this and other\nmethods. Our approach makes use of the distil- lation program transformation\nalgorithm to transform clauses into a simplified form that facilitates the\nidentification of similarities and differences between them and thus help\ndiscover invariants. We prove that our technique terminates, and demonstrate\nits successful application to example programs that have proven to be\nproblematic using other approaches. We also characterise the situations where\nour technique fails to find an invariant, and show how this can be ameliorated\nto a certain extent.\n", "versions": [{"version": "v1", "created": "Thu, 24 Aug 2017 00:18:58 GMT"}], "update_date": "2017-08-25", "authors_parsed": [["Hamilton", "G. W.", "", "School of Computing, Dublin City University, Republic\n  of Ireland"]]}, {"id": "1708.07228", "submitter": "EPTCS", "authors": "Giles Reger (University of Manchester, UK)", "title": "A Story of Parametric Trace Slicing, Garbage and Static Analysis", "comments": "In Proceedings PrePost 2017, arXiv:1708.06889", "journal-ref": "EPTCS 254, 2017, pp. 1-14", "doi": "10.4204/EPTCS.254.1", "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a proposal (story) of how statically detecting\nunreachable objects (in Java) could be used to improve a particular runtime\nverification approach (for Java), namely parametric trace slicing. Monitoring\nalgorithms for parametric trace slicing depend on garbage collection to (i)\ncleanup data-structures storing monitored objects, ensuring they do not become\nunmanageably large, and (ii) anticipate the violation of (non-safety)\nproperties that cannot be satisfied as a monitored object can no longer appear\nlater in the trace. The proposal is that both usages can be improved by making\nthe unreachability of monitored objects explicit in the parametric property and\nstatically introducing additional instrumentation points generating related\nevents. The ideas presented in this paper are still exploratory and the\nintention is to integrate the described techniques into the MarQ monitoring\ntool for quantified event automata.\n", "versions": [{"version": "v1", "created": "Thu, 24 Aug 2017 00:37:53 GMT"}], "update_date": "2017-08-25", "authors_parsed": [["Reger", "Giles", "", "University of Manchester, UK"]]}, {"id": "1708.07229", "submitter": "EPTCS", "authors": "Ian Cassar (University of Malta and Reykjavik University), Adrian\n  Francalanza (University of Malta), Luca Aceto (Reykjavik University), Anna\n  Ing\\'olfsd\\'ottir (Reykjavik University)", "title": "A Survey of Runtime Monitoring Instrumentation Techniques", "comments": "In Proceedings PrePost 2017, arXiv:1708.06889", "journal-ref": "EPTCS 254, 2017, pp. 15-28", "doi": "10.4204/EPTCS.254.2", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Runtime Monitoring is a lightweight and dynamic verification technique that\ninvolves observing the internal operations of a software system and/or its\ninteractions with other external entities, with the aim of determining whether\nthe system satisfies or violates a correctness specification. Compilation\ntechniques employed in Runtime Monitoring tools allow monitors to be\nautomatically derived from high-level correctness specifications (aka.\nproperties). This allows the same property to be converted into different types\nof monitors, which may apply different instrumentation techniques for checking\nwhether the property was satisfied or not. In this paper we compare and\ncontrast the various types of monitoring methodologies found in the current\nliterature, and classify them into a spectrum of monitoring instrumentation\ntechniques, ranging from completely asynchronous monitoring on the one end and\ncompletely synchronous monitoring on the other.\n", "versions": [{"version": "v1", "created": "Thu, 24 Aug 2017 00:38:23 GMT"}], "update_date": "2017-08-25", "authors_parsed": [["Cassar", "Ian", "", "University of Malta and Reykjavik University"], ["Francalanza", "Adrian", "", "University of Malta"], ["Aceto", "Luca", "", "Reykjavik University"], ["Ing\u00f3lfsd\u00f3ttir", "Anna", "", "Reykjavik University"]]}, {"id": "1708.07230", "submitter": "EPTCS", "authors": "Shaun Azzopardi (University of Malta), Christian Colombo (University\n  of Malta), Gordon J. Pace (University of Malta)", "title": "Control-Flow Residual Analysis for Symbolic Automata", "comments": "In Proceedings PrePost 2017, arXiv:1708.06889", "journal-ref": "EPTCS 254, 2017, pp. 29-43", "doi": "10.4204/EPTCS.254.3", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Where full static analysis of systems fails to scale up due to system size,\ndynamic monitoring has been increasingly used to ensure system correctness. The\ndownside is, however, runtime overheads which are induced by the additional\nmonitoring code instrumented. To address this issue, various approaches have\nbeen proposed in the literature to use static analysis in order to reduce\nmonitoring overhead. In this paper we generalise existing work which uses\ncontrol-flow static analysis to optimise properties specified as automata, and\nprove how similar analysis can be applied to more expressive symbolic automata\n- enabling reduction of monitoring instrumentation in the system, and also\nmonitoring logic. We also present empirical evidence of the effectiveness of\nthis approach through an analysis of the effect of monitoring overheads in a\nfinancial transaction system.\n", "versions": [{"version": "v1", "created": "Thu, 24 Aug 2017 00:38:45 GMT"}], "update_date": "2017-08-25", "authors_parsed": [["Azzopardi", "Shaun", "", "University of Malta"], ["Colombo", "Christian", "", "University\n  of Malta"], ["Pace", "Gordon J.", "", "University of Malta"]]}, {"id": "1708.07231", "submitter": "EPTCS", "authors": "Luke Chircop (University Of Malta), Christian Colombo (University Of\n  Malta), Mark Micallef (University Of Malta)", "title": "Exploring the Link Between Test Suite Quality and Automatic\n  Specification Inference", "comments": "In Proceedings PrePost 2017, arXiv:1708.06889", "journal-ref": "EPTCS 254, 2017, pp. 44-56", "doi": "10.4204/EPTCS.254.4", "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While no one doubts the importance of correct and complete specifications,\nmany industrial systems still do not have formal specifications written out --\nand even when they do, it is hard to check their correctness and completeness.\nThis work explores the possibility of using an invariant extraction tool such\nas Daikon to automatically infer specifications from available test suites with\nthe idea of aiding software engineers to improve the specifications by having\nanother version to compare to. Given that our initial experiments did not\nproduce satisfactory results, in this paper we explore which test suite\nattributes influence the quality of the inferred specification. Following\nfurther study, we found that instruction, branch and method coverage are\ncorrelated to high recall values, reaching up to 97.93%.\n", "versions": [{"version": "v1", "created": "Thu, 24 Aug 2017 00:39:13 GMT"}], "update_date": "2017-08-25", "authors_parsed": [["Chircop", "Luke", "", "University Of Malta"], ["Colombo", "Christian", "", "University Of\n  Malta"], ["Micallef", "Mark", "", "University Of Malta"]]}, {"id": "1708.07354", "submitter": "Sandra Kiefer", "authors": "Sandra Kiefer, Ilia Ponomarenko, Pascal Schweitzer", "title": "The Weisfeiler-Leman Dimension of Planar Graphs is at most 3", "comments": "34 pages, 3 figures, extended version of LICS 2017 paper", "journal-ref": null, "doi": "10.1109/LICS.2017.8005107", "report-no": null, "categories": "cs.DM cs.LO math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the Weisfeiler-Leman (WL) dimension of the class of all finite\nplanar graphs is at most 3. In particular, every finite planar graph is\ndefinable in first-order logic with counting using at most 4 variables. The\npreviously best known upper bounds for the dimension and number of variables\nwere 14 and 15, respectively.\n  First we show that, for dimension 3 and higher, the WL-algorithm correctly\ntests isomorphism of graphs in a minor-closed class whenever it determines the\norbits of the automorphism group of any arc-colored 3-connected graph belonging\nto this class.\n  Then we prove that, apart from several exceptional graphs (which have\nWL-dimension at most 2), the individualization of two correctly chosen vertices\nof a colored 3-connected planar graph followed by the 1-dimensional\nWL-algorithm produces the discrete vertex partition. This implies that the\n3-dimensional WL-algorithm determines the orbits of a colored 3-connected\nplanar graph.\n  As a byproduct of the proof, we get a classification of the 3-connected\nplanar graphs with fixing number 3.\n", "versions": [{"version": "v1", "created": "Thu, 24 Aug 2017 11:06:19 GMT"}], "update_date": "2017-08-25", "authors_parsed": [["Kiefer", "Sandra", ""], ["Ponomarenko", "Ilia", ""], ["Schweitzer", "Pascal", ""]]}, {"id": "1708.07366", "submitter": "Martin Sulzmann", "authors": "Martin Sulzmann and Peter Thiemann", "title": "A Computational Interpretation of Context-Free Expressions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We phrase parsing with context-free expressions as a type inhabitation\nproblem where values are parse trees and types are context-free expressions. We\nfirst show how containment among context-free and regular expressions can be\nreduced to a reachability problem by using a canonical representation of\nstates. The proofs-as-programs principle yields a computational interpretation\nof the reachability problem in terms of a coercion that transforms the parse\ntree for a context-free expression into a parse tree for a regular expression.\nIt also yields a partial coercion from regular parse trees to context-free\nones. The partial coercion from the trivial language of all words to a\ncontext-free expression corresponds to a predictive parser for the expression.\n", "versions": [{"version": "v1", "created": "Thu, 24 Aug 2017 12:02:28 GMT"}], "update_date": "2017-08-25", "authors_parsed": [["Sulzmann", "Martin", ""], ["Thiemann", "Peter", ""]]}, {"id": "1708.07854", "submitter": "John Gallagher", "authors": "Fabio Fioravanti and John P. Gallagher", "title": "Pre-proceedings of the 27th International Symposium on Logic-Based\n  Program Synthesis and Transformation (LOPSTR 2017)", "comments": "Papers selected for presentation at LOPSTR 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume constitutes the pre-proceedings of the 27th International\nSymposium on Logic-Based Program Synthesis and Transformation (LOPSTR 2016),\nheld on 10-12th October 2017 in Namur, Belgium, and co-located with the 19th\nInternational Symposium on Principles and Practice of Declarative Programming\n(PPDP 2017). After discussion at the symposium papers will go through a second\nround of refereeing and selection for the formal proceedings.\n", "versions": [{"version": "v1", "created": "Thu, 24 Aug 2017 14:54:20 GMT"}, {"version": "v2", "created": "Thu, 31 Aug 2017 11:57:03 GMT"}], "update_date": "2017-09-01", "authors_parsed": [["Fioravanti", "Fabio", ""], ["Gallagher", "John P.", ""]]}, {"id": "1708.07876", "submitter": "Julian Nagele", "authors": "Julian Nagele and Aart Middeldorp", "title": "CoCoWeb - A Convenient Web Interface for Confluence Tools", "comments": "6th International Workshop on Confluence", "journal-ref": "Proceedings of the 6th International Workshop on Confluence, pages\n  39 - 43, 2017", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a useful web interface for tools that participate in the annual\nconfluence competition.\n", "versions": [{"version": "v1", "created": "Fri, 25 Aug 2017 20:27:34 GMT"}], "update_date": "2020-05-13", "authors_parsed": [["Nagele", "Julian", ""], ["Middeldorp", "Aart", ""]]}, {"id": "1708.07877", "submitter": "Julian Nagele", "authors": "Nao Hirokawa and Julian Nagele and Vincent van Oostrom and Michio\n  Oyamaguchi", "title": "Critical Peaks Redefined - $\\Phi \\sqcup \\Psi = \\top$", "comments": "6th International Workshop on Confluence", "journal-ref": "In Proceedings of the 6th International Workshop on Confluence,\n  pages 33 - 37, 2017", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let a cluster be a term with a number of patterns occurring in it. We give\ntwo accounts of clusters, a geometric one as sets of (node and edge) positions,\nand an inductive one as pairs of terms with gaps (2nd order variables) and\npattern-substitutions for the gaps. We show both notions of cluster and the\ncorresponding refinement/coarsening orders on them, to be isomorphic. This\nequips clusters with a lattice structure which we lift to (parallel/multi)\nsteps to yield an alternative account of the notion of critical peak.\n", "versions": [{"version": "v1", "created": "Fri, 25 Aug 2017 20:37:40 GMT"}], "update_date": "2017-08-29", "authors_parsed": [["Hirokawa", "Nao", ""], ["Nagele", "Julian", ""], ["van Oostrom", "Vincent", ""], ["Oyamaguchi", "Michio", ""]]}, {"id": "1708.08081", "submitter": "Martin Grohe", "authors": "Martin Grohe and Christof L\\\"oding and Martin Ritzert", "title": "Learning MSO-definable hypotheses on string", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the classification problems over string data for hypotheses\nspecified by formulas of monadic second-order logic MSO. The goal is to design\nlearning algorithms that run in time polynomial in the size of the training\nset, independently of or at least sublinear in the size of the whole data set.\nWe prove negative as well as positive results. If the data set is an\nunprocessed string to which our algorithms have local access, then learning in\nsublinear time is impossible even for hypotheses definable in a small fragment\nof first-order logic. If we allow for a linear time pre-processing of the\nstring data to build an index data structure, then learning of MSO-definable\nhypotheses is possible in time polynomial in the size of the training set,\nindependently of the size of the whole data set.\n", "versions": [{"version": "v1", "created": "Sun, 27 Aug 2017 11:47:57 GMT"}], "update_date": "2017-08-29", "authors_parsed": [["Grohe", "Martin", ""], ["L\u00f6ding", "Christof", ""], ["Ritzert", "Martin", ""]]}, {"id": "1708.08179", "submitter": "Danny Nguyen", "authors": "Danny Nguyen, Igor Pak", "title": "Short Presburger arithmetic is hard", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.CC cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the computational complexity of short sentences in Presburger\narithmetic (Short-PA). Here by \"short\" we mean sentences with a bounded number\nof variables, quantifiers, inequalities and Boolean operations; the input\nconsists only of the integer coefficients involved in the linear inequalities.\nWe prove that satisfiability of Short-PA sentences with $m+2$ alternating\nquantifiers is $\\Sigma_{P}^m$-complete or $\\Pi_{P}^m$-complete, when the first\nquantifier is $\\exists$ or $\\forall$, respectively. Counting versions and\nrestricted systems are also analyzed. Further application are given to hardness\nof two natural problems in Integer Optimizations.\n", "versions": [{"version": "v1", "created": "Mon, 28 Aug 2017 03:54:10 GMT"}, {"version": "v2", "created": "Sun, 3 Sep 2017 21:09:40 GMT"}, {"version": "v3", "created": "Fri, 20 Oct 2017 05:57:33 GMT"}], "update_date": "2017-10-23", "authors_parsed": [["Nguyen", "Danny", ""], ["Pak", "Igor", ""]]}, {"id": "1708.08611", "submitter": "Mohammed Alshiekh", "authors": "Mohammed Alshiekh, Roderick Bloem, Ruediger Ehlers, Bettina\n  K\\\"onighofer, Scott Niekum, Ufuk Topcu", "title": "Safe Reinforcement Learning via Shielding", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reinforcement learning algorithms discover policies that maximize reward, but\ndo not necessarily guarantee safety during learning or execution phases. We\nintroduce a new approach to learn optimal policies while enforcing properties\nexpressed in temporal logic. To this end, given the temporal logic\nspecification that is to be obeyed by the learning system, we propose to\nsynthesize a reactive system called a shield. The shield is introduced in the\ntraditional learning process in two alternative ways, depending on the location\nat which the shield is implemented. In the first one, the shield acts each time\nthe learning agent is about to make a decision and provides a list of safe\nactions. In the second way, the shield is introduced after the learning agent.\nThe shield monitors the actions from the learner and corrects them only if the\nchosen action causes a violation of the specification. We discuss which\nrequirements a shield must meet to preserve the convergence guarantees of the\nlearner. Finally, we demonstrate the versatility of our approach on several\nchallenging reinforcement learning scenarios.\n", "versions": [{"version": "v1", "created": "Tue, 29 Aug 2017 07:16:54 GMT"}, {"version": "v2", "created": "Sun, 3 Sep 2017 20:35:33 GMT"}], "update_date": "2017-09-05", "authors_parsed": [["Alshiekh", "Mohammed", ""], ["Bloem", "Roderick", ""], ["Ehlers", "Ruediger", ""], ["K\u00f6nighofer", "Bettina", ""], ["Niekum", "Scott", ""], ["Topcu", "Ufuk", ""]]}, {"id": "1708.09013", "submitter": "Eugen Z\\u{a}linescu", "authors": "Bernd Finkbeiner, Christian M\\\"uller, Helmut Seidl and Eugen\n  Z\\u{a}linescu", "title": "Verifying Security Policies in Multi-agent Workflows with Loops", "comments": "Authors' version of the corresponding CCS 2017 conference paper", "journal-ref": null, "doi": "10.1145/3133956.3134080", "report-no": null, "categories": "cs.LO cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the automatic verification of information flow security policies\nof web-based workflows, such as conference submission systems like EasyChair.\nOur workflow description language allows for loops, non-deterministic choice,\nand an unbounded number of participating agents. The information flow policies\nare specified in a temporal logic for hyperproperties. We show that the\nverification problem can be reduced to the satisfiability of a formula of\nfirst-order linear-time temporal logic, and provide decidability results for\nrelevant classes of workflows and specifications. We report on experimental\nresults obtained with an implementation of our approach on a series of\nbenchmarks.\n", "versions": [{"version": "v1", "created": "Tue, 29 Aug 2017 20:28:13 GMT"}], "update_date": "2017-08-31", "authors_parsed": [["Finkbeiner", "Bernd", ""], ["M\u00fcller", "Christian", ""], ["Seidl", "Helmut", ""], ["Z\u0103linescu", "Eugen", ""]]}, {"id": "1708.09073", "submitter": "Arlen Cox", "authors": "Arlen Cox and Jason Leasure", "title": "Model Checking Regular Language Constraints", "comments": "16 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.SC", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Even the fastest SMT solvers have performance problems with regular\nexpressions from real programs. Because these performance issues often arise\nfrom the problem representation (e.g. non-deterministic finite automata get\ndeterminized and regular expressions get unrolled), we revisit Boolean finite\nautomata, which allow for the direct and natural representation of any Boolean\ncombination of regular languages. By applying the IC3 model checking algorithm\nto Boolean finite automata, not only can we efficiently answer emptiness and\nuniversality problems, but through an extension, we can decide satisfiability\nof multiple variable string membership problems. We demonstrate the resulting\nsystem's effectiveness on a number of popular benchmarks and regular\nexpressions.\n", "versions": [{"version": "v1", "created": "Wed, 30 Aug 2017 01:10:03 GMT"}], "update_date": "2017-08-31", "authors_parsed": [["Cox", "Arlen", ""], ["Leasure", "Jason", ""]]}, {"id": "1708.09253", "submitter": "Dominik Velan", "authors": "Tom\\'a\\v{s} Br\\'azdil, Krishnendu Chatterjee, Anton\\'in Ku\\v{c}era,\n  Petr Novotn\\'y, Dominik Velan", "title": "Efficient Algorithms for Checking Fast Termination in VASS", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC cs.DS cs.FL", "license": "http://creativecommons.org/publicdomain/zero/1.0/", "abstract": "  Vector Addition Systems with States (VASS) consists of a finite state space\nequipped with d counters, where in each transition every counter is\nincremented, decremented, or left unchanged. VASS provide a fundamental model\nfor analysis of concurrent processes, parametrized systems, and they are also\nused as abstract models for programs for bounds analysis. While termination is\nthe basic liveness property that asks the qualitative question of whether a\ngiven model always terminates or not, the more general quantitative question\nasks for bounds on the number of steps to termination. In the realm of\nquantitative bounds a fundamental problem is to obtain asymptotic bounds on\ntermination time. Large asymptotic bounds such as exponential or higher already\nsuggest that either there is some error in modeling, or the model is not useful\nin practice. Hence we focus on polynomial asymptotic bounds for VASS. While\nsome well-known approaches (e.g., lexicographic ranking functions) are neither\nsound nor complete with respect to polynomial bounds, other approaches only\npresent sound methods for upper bounds. In this work our main contributions are\nas follows: First, for linear asymptotic bounds we present a sound and complete\nmethod for VASS, and moreover, our algorithm runs in polynomial time. Second,\nwe classify VASS according the normals of the vectors of the cycles. We show\nthat singularities in the normal are the key reason for asymptotic bounds such\nas exponential and non-elementary for VASS. In absence of singularities, we\nshow that the asymptotic complexity bound is always polynomial and of the form\n${\\Theta}(n^k)$, for some k $\\leq$ d. We present an algorithm, with time\ncomplexity polynomial in the size of the VASS and exponential in dimension d,\nto compute the optimal k.\n", "versions": [{"version": "v1", "created": "Tue, 29 Aug 2017 12:29:41 GMT"}], "update_date": "2017-08-31", "authors_parsed": [["Br\u00e1zdil", "Tom\u00e1\u0161", ""], ["Chatterjee", "Krishnendu", ""], ["Ku\u010dera", "Anton\u00edn", ""], ["Novotn\u00fd", "Petr", ""], ["Velan", "Dominik", ""]]}, {"id": "1708.09765", "submitter": "Thorsten Wissmann", "authors": "Miko{\\l}aj Boja\\'nczyk, Thomas Colcombet", "title": "Boundedness in languages of infinite words", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 13, Issue 4 (October\n  26, 2017) lmcs:4016", "doi": "10.23638/LMCS-13(4:3)2017", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define a new class of languages of $\\omega$-words, strictly extending\n$\\omega$-regular languages.\n  One way to present this new class is by a type of regular expressions. The\nnew expressions are an extension of $\\omega$-regular expressions where two new\nvariants of the Kleene star $L^*$ are added: $L^B$ and $L^S$. These new\nexponents are used to say that parts of the input word have bounded size, and\nthat parts of the input can have arbitrarily large sizes, respectively. For\ninstance, the expression $(a^Bb)^\\omega$ represents the language of infinite\nwords over the letters $a,b$ where there is a common bound on the number of\nconsecutive letters $a$. The expression $(a^Sb)^\\omega$ represents a similar\nlanguage, but this time the distance between consecutive $b$'s is required to\ntend toward the infinite.\n  We develop a theory for these languages, with a focus on decidability and\nclosure. We define an equivalent automaton model, extending B\\\"uchi automata.\nThe main technical result is a complementation lemma that works for languages\nwhere only one type of exponent---either $L^B$ or $L^S$---is used.\n  We use the closure and decidability results to obtain partial decidability\nresults for the logic MSOLB, a logic obtained by extending monadic second-order\nlogic with new quantifiers that speak about the size of sets.\n", "versions": [{"version": "v1", "created": "Thu, 31 Aug 2017 15:06:22 GMT"}, {"version": "v2", "created": "Wed, 25 Oct 2017 14:33:16 GMT"}], "update_date": "2018-01-03", "authors_parsed": [["Boja\u0144czyk", "Miko\u0142aj", ""], ["Colcombet", "Thomas", ""]]}, {"id": "1708.09820", "submitter": "J\\\"urgen Koslowski", "authors": "Margarita Korovina and Oleg Kudinov", "title": "The Rice-Shapiro theorem in Computable Topology", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 13, Issue 4 (December\n  29, 2017) lmcs:4171", "doi": "10.23638/LMCS-13(4:30)2017", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide requirements on effectively enumerable topological spaces which\nguarantee that the Rice-Shapiro theorem holds for the computable elements of\nthese spaces. We show that the relaxation of these requirements leads to the\nclasses of effectively enumerable topological spaces where the Rice-Shapiro\ntheorem does not hold. We propose two constructions that generate effectively\nenumerable topological spaces with particular properties from wn--families and\ncomputable trees without computable infinite paths. Using them we propose\nexamples that give a flavor of this class.\n", "versions": [{"version": "v1", "created": "Thu, 31 Aug 2017 17:02:42 GMT"}, {"version": "v2", "created": "Thu, 14 Sep 2017 09:13:44 GMT"}, {"version": "v3", "created": "Fri, 27 Oct 2017 16:03:28 GMT"}, {"version": "v4", "created": "Thu, 28 Dec 2017 11:22:19 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Korovina", "Margarita", ""], ["Kudinov", "Oleg", ""]]}]