[{"id": "1206.0136", "submitter": "Christian Urban", "authors": "Christian Urban (TU Munich), Cezary Kaliszyk (University of Tsukuba)", "title": "General Bindings and Alpha-Equivalence in Nominal Isabelle", "comments": "35 pages", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 2 (June 20,\n  2012) lmcs:813", "doi": "10.2168/LMCS-8(2:14)2012", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Nominal Isabelle is a definitional extension of the Isabelle/HOL theorem\nprover. It provides a proving infrastructure for reasoning about programming\nlanguage calculi involving named bound variables (as opposed to de-Bruijn\nindices). In this paper we present an extension of Nominal Isabelle for dealing\nwith general bindings, that means term constructors where multiple variables\nare bound at once. Such general bindings are ubiquitous in programming language\nresearch and only very poorly supported with single binders, such as\nlambda-abstractions. Our extension includes new definitions of\nalpha-equivalence and establishes automatically the reasoning infrastructure\nfor alpha-equated terms. We also prove strong induction principles that have\nthe usual variable convention already built in.\n", "versions": [{"version": "v1", "created": "Fri, 1 Jun 2012 10:00:31 GMT"}, {"version": "v2", "created": "Tue, 19 Jun 2012 16:49:35 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Urban", "Christian", "", "TU Munich"], ["Kaliszyk", "Cezary", "", "University of Tsukuba"]]}, {"id": "1206.0141", "submitter": "Josef Urban", "authors": "Josef Urban", "title": "Parallelizing Mizar", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper surveys and describes the implementation of parallelization of the\nMizar proof checking and of related Mizar utilities. The implementation makes\nuse of Mizar's compiler-like division into several relatively independent\npasses, with typically quite different processing speeds. The information\nproduced in earlier (typically much faster) passes can be used to parallelize\nthe later (typically much slower) passes. The parallelization now works by\nsplitting the formalization into a suitable number of pieces that are processed\nin parallel, assembling from them together the required results. The\nimplementation is evaluated on examples from the Mizar library, and future\nextensions are discussed.\n", "versions": [{"version": "v1", "created": "Fri, 1 Jun 2012 10:36:53 GMT"}, {"version": "v2", "created": "Thu, 22 May 2014 09:34:45 GMT"}], "update_date": "2014-05-23", "authors_parsed": [["Urban", "Josef", ""]]}, {"id": "1206.0232", "submitter": "Dai Liyun", "authors": "Liyun Dai and Bican Xia", "title": "Non-Termination Sets of Simple Linear Loops", "comments": "15 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  A simple linear loop is a simple while loop with linear assignments and\nlinear loop guards. If a simple linear loop has only two program variables, we\ngive a complete algorithm for computing the set of all the inputs on which the\nloop does not terminate. For the case of more program variables, we show that\nthe non-termination set cannot be described by Tarski formulae in general\n", "versions": [{"version": "v1", "created": "Thu, 31 May 2012 11:28:23 GMT"}], "update_date": "2015-03-20", "authors_parsed": [["Dai", "Liyun", ""], ["Xia", "Bican", ""]]}, {"id": "1206.0911", "submitter": "Luca Ferrucci", "authors": "Luca Ferrucci, Dino Mandrioli, Angelo Morzenti, Matteo Rossi", "title": "Non-null Infinitesimal Micro-steps: a Metric Temporal Logic Approach", "comments": "20 pages, 2 figures, submitted to the conference \"FORMATS: Formal\n  Modelling and Analysis of Timed Systems\" 2012", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many systems include components interacting with each other that evolve with\npossibly very different speeds. To deal with this situation many formal models\nadopt the abstraction of \"zero-time transitions\", which do not consume time.\nThese however have several drawbacks in terms of naturalness and logic\nconsistency, as a system is modeled to be in different states at the same time.\nWe propose a novel approach that exploits concepts from non-standard analysis\nto introduce a notion of micro- and macro-steps in an extension of the TRIO\nmetric temporal logic, called X-TRIO. We use X-TRIO to provide a formal\nsemantics and an automated verification technique to Stateflow-like notations\nused in the design of flexible manufacturing systems.\n", "versions": [{"version": "v1", "created": "Tue, 5 Jun 2012 12:48:13 GMT"}], "update_date": "2012-06-06", "authors_parsed": [["Ferrucci", "Luca", ""], ["Mandrioli", "Dino", ""], ["Morzenti", "Angelo", ""], ["Rossi", "Matteo", ""]]}, {"id": "1206.1090", "submitter": "Mohamed El-Zawawy Dr.", "authors": "Mohamed A. El-Zawawy and Nagwan M. Daoud", "title": "Dynamic Verification for File Safety of Multithreaded Programs", "comments": "7 pages, http://paper.ijcsns.org/07_book/201205/20120503.pdf", "journal-ref": "IJCSNS International Journal of Computer Science and Network\n  Security, VOL.12 No.5, pp 14-20, May 2012", "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present a new semantics to check file safety of\nmultithreaded programs. A file-safe program is one that reaches a final\nconfiguration under the proposed semantics. We extend the While language with\nfile operations and multi-threading commands, and call the new language whilef.\nThis paper shows that the file safety is an un-decidable property for whilef.\nThe file safety becomes a decidable property in a special case shown in this\npaper. The case happens when users provide pointer information. If the file is\nsafe we call it a strongly safe file program. We modify the syntax and the\nsemantic of the language and called it SafeWhilef.\n", "versions": [{"version": "v1", "created": "Tue, 5 Jun 2012 23:37:00 GMT"}], "update_date": "2012-06-07", "authors_parsed": [["El-Zawawy", "Mohamed A.", ""], ["Daoud", "Nagwan M.", ""]]}, {"id": "1206.1317", "submitter": "Stefan Kiefer", "authors": "Taolue Chen and Klaus Dr\\\"ager and Stefan Kiefer", "title": "Model Checking Stochastic Branching Processes", "comments": "This is a technical report accompanying an MFCS'12 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Stochastic branching processes are a classical model for describing random\ntrees, which have applications in numerous fields including biology, physics,\nand natural language processing. In particular, they have recently been\nproposed to describe parallel programs with stochastic process creation. In\nthis paper, we consider the problem of model checking stochastic branching\nprocess. Given a branching process and a deterministic parity tree automaton,\nwe are interested in computing the probability that the generated random tree\nis accepted by the automaton. We show that this probability can be compared\nwith any rational number in PSPACE, and with 0 and 1 in polynomial time. In a\nsecond part, we suggest a tree extension of the logic PCTL, and develop a\nPSPACE algorithm for model checking a branching process against a formula of\nthis logic. We also show that the qualitative fragment of this logic can be\nmodel checked in polynomial time.\n", "versions": [{"version": "v1", "created": "Wed, 6 Jun 2012 19:51:48 GMT"}], "update_date": "2012-06-07", "authors_parsed": [["Chen", "Taolue", ""], ["Dr\u00e4ger", "Klaus", ""], ["Kiefer", "Stefan", ""]]}, {"id": "1206.1935", "submitter": "Nengkun Yu", "authors": "Nengkun Yu and Mingsheng Ying", "title": "Reachability and Termination Analysis of Concurrent Quantum Programs", "comments": "Accepted by Concur'12. Comments are welcome", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a Markov chain model of concurrent quantum programs. This model\nis a quantum generalization of Hart, Sharir and Pnueli's probabilistic\nconcurrent programs. Some characterizations of the reachable space, uniformly\nrepeatedly reachable space and termination of a concurrent quantum program are\nderived by the analysis of their mathematical structures. Based on these\ncharacterizations, algorithms for computing the reachable space and uniformly\nrepeatedly reachable space and for deciding the termination are given.\n", "versions": [{"version": "v1", "created": "Sat, 9 Jun 2012 12:43:59 GMT"}], "update_date": "2012-06-12", "authors_parsed": [["Yu", "Nengkun", ""], ["Ying", "Mingsheng", ""]]}, {"id": "1206.1936", "submitter": "Daan Staudt", "authors": "D.J.C. Staudt", "title": "Completeness for Two Left-Sequential Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Left-sequential logics provide a means for reasoning about (closed)\npropositional terms with atomic propositions that may have side effects and\nthat are evaluated sequentially from left to right. Such propositional terms\nare commonly used in programming languages to direct the flow of a program. In\nthis thesis we explore two such left-sequential logics. First we discuss Fully\nEvaluated Left-Sequential Logic, which employs a full evaluation strategy,\ni.e., to evaluate a term every one of its atomic propositions is evaluated\ncausing its possible side effects to occur. We then turn to Short-Circuit\n(Left-Sequential) Logic as presented in [BP10b], where the evaluation may be\n'short-circuited', thus preventing some, if not all, of the atomic propositions\nin a term being evaluated. We propose evaluation trees as a natural semantics\nfor both logics and provide axiomatizations for the least identifying variant\nof each. From this, we define a logic with connectives that prescribe a full\nevaluation strategy as well as connectives that prescribe a short-circuit\nevaluation strategy.\n", "versions": [{"version": "v1", "created": "Sat, 9 Jun 2012 12:58:28 GMT"}], "update_date": "2012-06-12", "authors_parsed": [["Staudt", "D. J. C.", ""]]}, {"id": "1206.2032", "submitter": "Yannai A. Gonczarowski", "authors": "Yannai A. Gonczarowski", "title": "Timely Coordination in a Multi-Agent System", "comments": "Master's thesis. Advisors: Prof. Gil Kalai and Prof. Yoram Moses", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MA cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a distributed algorithm, multiple processes, or agents, work toward a\ncommon goal. More often than not, the actions of some agents are dependent on\nthe previous execution (if not also on the outcome) of the actions of other\nagents. The resulting interdependencies between the timings of the actions of\nthe various agents give rise to the study of methods for timely coordination of\nthese actions.\n  In this work, we formulate and mathematically analyze \"Timely-Coordinated\nResponse\" - a novel multi-agent coordination problem in which the time\ndifference between each pair of actions may be constrained by upper and/or\nlower bounds. This problem generalizes coordination problems previously studied\nby Halpern and Moses and by Ben-Zvi and Moses.\n  We optimally solve timely-coordinated response in two ways: using a\ngeneralization of the fixed-point approach of Halpern and Moses, and using a\ngeneralization of the \"syncausality\" approach of Ben-Zvi and Moses. We\nconstructively show the equivalence of the solutions yielded by both\napproaches, and by combining them, derive strengthened versions of known\nresults for some previously-defined special cases of this problem.\n  Our analysis is conducted under minimal assumptions: we work in a\ncontinuous-time model with possibly infinitely many agents. The general results\nwe obtain for this model reduce to stronger ones for discrete-time models with\nonly finitely many agents. In order to distill the properties of such models\nthat are significant to this reduction, we define several classes of\nnaturally-occurring models, which in a sense separate the different results. We\npresent both a more practical optimal solution, as well as a surprisingly\nsimple condition for solvability, for timely coordinated response under these\nmodels.\n  Finally, we show how our results generalize the results known for\npreviously-studied special cases of this problem.\n", "versions": [{"version": "v1", "created": "Sun, 10 Jun 2012 14:10:25 GMT"}], "update_date": "2012-06-12", "authors_parsed": [["Gonczarowski", "Yannai A.", ""]]}, {"id": "1206.2037", "submitter": "M. H. van Emden", "authors": "M. H. van Emden", "title": "Programming in logic without Prolog", "comments": "This paper has been withdrawn because it is superseded by\n  arXiv:1412.3480, \"Logic Programming Beyond Prolog\"", "journal-ref": null, "doi": null, "report-no": "DCS-346-IR", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Logic can be made useful for programming and for databases independently of\nlogic programming. To be useful in this way, logic has to provide a mechanism\nfor the definition of new functions and new relations on the basis of those\ngiven in the interpretation of a logical theory. We provide this mechanism by\ncreating a compositional semantics on top of the classical semantics. In this\napproach verification of computational results relies on a correspondence\nbetween logic interpretations and a class definition in languages like Java or\nC++. The advantage of this approach is the combination of an expressive medium\nfor the programmer with, in the case of C++, optimal use of computer resources.\n", "versions": [{"version": "v1", "created": "Sun, 10 Jun 2012 15:54:39 GMT"}, {"version": "v2", "created": "Fri, 20 Jul 2012 00:21:30 GMT"}, {"version": "v3", "created": "Mon, 6 Aug 2012 19:17:37 GMT"}, {"version": "v4", "created": "Fri, 12 Dec 2014 22:47:15 GMT"}, {"version": "v5", "created": "Sat, 27 Dec 2014 16:34:52 GMT"}], "update_date": "2014-12-30", "authors_parsed": [["van Emden", "M. H.", ""]]}, {"id": "1206.3136", "submitter": "Cristian Prisacariu", "authors": "Cristian Prisacariu", "title": "The Glory of the Past and Geometrical Concurrency", "comments": "17 pages, 7 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  This paper contributes to the general understanding of the geometrical model\nof concurrency that was named higher dimensional automata (HDAs) by Pratt. In\nparticular we investigate modal logics for such models and their expressive\npower in terms of the bisimulation that can be captured. The geometric model of\nconcurrency is interesting from two main reasons: its generality and\nexpressiveness, and the natural way in which autoconcurrency and action\nrefinement are captured. Logics for this model, though, are not well\ninvestigated, where a simple, yet adequate, modal logic over HDAs was only\nrecently introduced. As this modal logic, with two existential modalities,\nduring and after, captures only split bisimulation, which is rather low in the\nspectrum of van Glabbeek and Vaandrager, the immediate question was what small\nextension of this logic could capture the more fine-grained hereditary history\npreserving bisimulation (hh)? In response, the work in this paper provides\nseveral insights. One is the fact that the geometrical aspect of HDAs makes it\npossible to use for capturing the hh-bisimulation, a standard modal logic that\ndoes not employ event variables, opposed to the two logics (over less\nexpressive models) that we compare with. The logic that we investigate here\nuses standard past modalities and extends the previously introduced logic\n(called HDML) that had only forward, action-labelled, modalities. Besides, we\ntry to understand better the above issues by introducing a related model that\nwe call ST-configuration structures, which extend the configuration structures\nof van Glabbeek and Plotkin. We relate this model to HDAs, and redefine and\nprove the earlier results in the light of this new model. These offer a\ndifferent view on why the past modalities and geometrical concurrency capture\nthe hereditary history preserving bisimulation. Additional correlating insights\nare also gained.\n", "versions": [{"version": "v1", "created": "Thu, 14 Jun 2012 15:20:38 GMT"}], "update_date": "2015-03-20", "authors_parsed": [["Prisacariu", "Cristian", ""]]}, {"id": "1206.3180", "submitter": "Michele Barletta", "authors": "Michele Barletta and Silvio Ranise and Luca Vigan\\`o", "title": "Automated Analysis of Scenario-based Specifications of Distributed\n  Access Control Policies with Non-Mechanizable Activities (Extended Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The advance of web services technologies promises to have far-reaching\neffects on the Internet and enterprise networks allowing for greater\naccessibility of data. The security challenges presented by the web services\napproach are formidable. In particular, access control solutions should be\nrevised to address new challenges, such as the need of using certificates for\nthe identification of users and their attributes, human intervention in the\ncreation or selection of the certificates, and (chains of) certificates for\ntrust management. With all these features, it is not surprising that analyzing\npolicies to guarantee that a sensitive resource can be accessed only by\nauthorized users becomes very difficult. In this paper, we present an automated\ntechnique to analyze scenario-based specifications of access control policies\nin open and distributed systems. We illustrate our ideas on a case study\narising in the e-government area.\n", "versions": [{"version": "v1", "created": "Thu, 14 Jun 2012 17:02:05 GMT"}], "update_date": "2012-06-15", "authors_parsed": [["Barletta", "Michele", ""], ["Ranise", "Silvio", ""], ["Vigan\u00f2", "Luca", ""]]}, {"id": "1206.3182", "submitter": "Marco Roveri", "authors": "Alessandro Cimatti (Fondazione Bruno Kessler), Iman Narasamdya\n  (Fondazione Bruno Kessler), Marco Roveri (Fondazione Bruno Kessler)", "title": "Software Model Checking with Explicit Scheduler and Symbolic Threads", "comments": "40 pages, 10 figures, accepted for publication in journal of logical\n  methods in computer science", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 2 (August 5,\n  2012) lmcs:1032", "doi": "10.2168/LMCS-8(2:18)2012", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In many practical application domains, the software is organized into a set\nof threads, whose activation is exclusive and controlled by a cooperative\nscheduling policy: threads execute, without any interruption, until they either\nterminate or yield the control explicitly to the scheduler. The formal\nverification of such software poses significant challenges. On the one side,\neach thread may have infinite state space, and might call for abstraction. On\nthe other side, the scheduling policy is often important for correctness, and\nan approach based on abstracting the scheduler may result in loss of precision\nand false positives. Unfortunately, the translation of the problem into a\npurely sequential software model checking problem turns out to be highly\ninefficient for the available technologies. We propose a software model\nchecking technique that exploits the intrinsic structure of these programs.\nEach thread is translated into a separate sequential program and explored\nsymbolically with lazy abstraction, while the overall verification is\norchestrated by the direct execution of the scheduler. The approach is\noptimized by filtering the exploration of the scheduler with the integration of\npartial-order reduction. The technique, called ESST (Explicit Scheduler,\nSymbolic Threads) has been implemented and experimentally evaluated on a\nsignificant set of benchmarks. The results demonstrate that ESST technique is\nway more effective than software model checking applied to the sequentialized\nprograms, and that partial-order reduction can lead to further performance\nimprovements.\n", "versions": [{"version": "v1", "created": "Thu, 14 Jun 2012 17:07:19 GMT"}, {"version": "v2", "created": "Tue, 31 Jul 2012 07:04:37 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Cimatti", "Alessandro", "", "Fondazione Bruno Kessler"], ["Narasamdya", "Iman", "", "Fondazione Bruno Kessler"], ["Roveri", "Marco", "", "Fondazione Bruno Kessler"]]}, {"id": "1206.3255", "submitter": "Daniel Roy", "authors": "Noah Goodman, Vikash Mansinghka, Daniel M. Roy, Keith Bonawitz, Joshua\n  B. Tenenbaum", "title": "Church: a language for generative models", "comments": "Minor revisions. Fixed errors in author list", "journal-ref": null, "doi": null, "report-no": "UAI-P-2008-PG-220-229", "categories": "cs.PL cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce Church, a universal language for describing stochastic\ngenerative processes. Church is based on the Lisp model of lambda calculus,\ncontaining a pure Lisp as its deterministic subset. The semantics of Church is\ndefined in terms of evaluation histories and conditional distributions on such\nhistories. Church also includes a novel language construct, the stochastic\nmemoizer, which enables simple description of many complex non-parametric\nmodels. We illustrate language features through several examples, including: a\ngeneralized Bayes net in which parameters cluster over trials, infinite PCFGs,\nplanning by inference, and various non-parametric clustering models. Finally,\nwe show how to implement query on any Church program, exactly and\napproximately, using Monte Carlo techniques.\n", "versions": [{"version": "v1", "created": "Wed, 13 Jun 2012 15:30:30 GMT"}, {"version": "v2", "created": "Tue, 15 Jul 2014 08:32:38 GMT"}], "update_date": "2014-07-16", "authors_parsed": [["Goodman", "Noah", ""], ["Mansinghka", "Vikash", ""], ["Roy", "Daniel M.", ""], ["Bonawitz", "Keith", ""], ["Tenenbaum", "Joshua B.", ""]]}, {"id": "1206.3357", "submitter": "Andre Platzer", "authors": "Andre Platzer (Carnegie Mellon University)", "title": "A Complete Axiomatization of Quantified Differential Dynamic Logic for\n  Distributed Hybrid Systems", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 4 (November\n  26, 2012) lmcs:720", "doi": "10.2168/LMCS-8(4:17)2012", "report-no": null, "categories": "cs.LO cs.PL math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address a fundamental mismatch between the combinations of dynamics that\noccur in cyber-physical systems and the limited kinds of dynamics supported in\nanalysis. Modern applications combine communication, computation, and control.\nThey may even form dynamic distributed networks, where neither structure nor\ndimension stay the same while the system follows hybrid dynamics, i.e., mixed\ndiscrete and continuous dynamics. We provide the logical foundations for\nclosing this analytic gap. We develop a formal model for distributed hybrid\nsystems. It combines quantified differential equations with quantified\nassignments and dynamic dimensionality-changes. We introduce a dynamic logic\nfor verifying distributed hybrid systems and present a proof calculus for this\nlogic. This is the first formal verification approach for distributed hybrid\nsystems. We prove that our calculus is a sound and complete axiomatization of\nthe behavior of distributed hybrid systems relative to quantified differential\nequations. In our calculus we have proven collision freedom in distributed car\ncontrol even when an unbounded number of new cars may appear dynamically on the\nroad.\n", "versions": [{"version": "v1", "created": "Fri, 15 Jun 2012 01:33:02 GMT"}, {"version": "v2", "created": "Thu, 25 Oct 2012 16:12:28 GMT"}, {"version": "v3", "created": "Thu, 22 Nov 2012 14:10:00 GMT"}], "update_date": "2016-12-02", "authors_parsed": [["Platzer", "Andre", "", "Carnegie Mellon University"]]}, {"id": "1206.3431", "submitter": "Vasco Brattka", "authors": "Jeremy Avigad and Vasco Brattka", "title": "Computability and analysis: the legacy of Alan Turing", "comments": "49 pages", "journal-ref": "in Rod Downey (ed.), Turing's Legacy, Developments from Turing's\n  Ideas in Logic, Lecture Notes in Logic 42, Cambridge University Press 2014,\n  p. 1-47", "doi": "10.1017/CBO9781107338579.002", "report-no": null, "categories": "math.LO cs.LO math.HO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We discuss the legacy of Alan Turing and his impact on computability and\nanalysis.\n", "versions": [{"version": "v1", "created": "Fri, 15 Jun 2012 11:38:29 GMT"}, {"version": "v2", "created": "Tue, 30 Oct 2012 10:50:11 GMT"}], "update_date": "2018-12-10", "authors_parsed": [["Avigad", "Jeremy", ""], ["Brattka", "Vasco", ""]]}, {"id": "1206.3883", "submitter": "Michael Codish", "authors": "Amit Metodi and Michael Codish", "title": "Compiling Finite Domain Constraints to SAT with BEE", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present BEE, a compiler which enables to encode finite domain constraint\nproblems to CNF. Using BEE both eases the encoding process for the user and\nalso performs transformations to simplify constraints and optimize their\nencoding to CNF. These optimizations are based primarily on equi-propagation\nand on partial evaluation, and also on the idea that a given constraint may\nhave various possible CNF encodings. Often, the better encoding choice is made\nafter constraint simplification. BEE is written in Prolog and integrates\ndirectly with a SAT solver through a suitable Prolog interface. We demonstrate\nthat constraint simplification is often highly beneficial when solving hard\nfinite domain constraint problems. A BEE implementation is available with this\npaper.\n", "versions": [{"version": "v1", "created": "Mon, 18 Jun 2012 10:57:13 GMT"}], "update_date": "2012-06-19", "authors_parsed": [["Metodi", "Amit", ""], ["Codish", "Michael", ""]]}, {"id": "1206.3902", "submitter": "Hubie Chen", "authors": "Hubie Chen", "title": "On the Complexity of Existential Positive Queries", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We systematically investigate the complexity of model checking the\nexistential positive fragment of first-order logic. In particular, for a set of\nexistential positive sentences, we consider model checking where the sentence\nis restricted to fall into the set; a natural question is then to classify\nwhich sentence sets are tractable and which are intractable. With respect to\nfixed-parameter tractability, we give a general theorem that reduces this\nclassification question to the corresponding question for primitive positive\nlogic, for a variety of representations of structures. This general theorem\nallows us to deduce that an existential positive sentence set having bounded\narity is fixed-parameter tractable if and only if each sentence is equivalent\nto one in bounded-variable logic. We then use the lens of classical complexity\nto study these fixed-parameter tractable sentence sets. We show that such a set\ncan be NP-complete, and consider the length needed by a translation from\nsentences in such a set to bounded-variable logic; we prove superpolynomial\nlower bounds on this length using the theory of compilability, obtaining an\ninteresting type of formula size lower bound. Overall, the tools, concepts, and\nresults of this article set the stage for the future consideration of the\ncomplexity of model checking on more expressive logics.\n", "versions": [{"version": "v1", "created": "Mon, 18 Jun 2012 12:19:32 GMT"}, {"version": "v2", "created": "Thu, 5 Jul 2012 14:51:45 GMT"}], "update_date": "2015-03-20", "authors_parsed": [["Chen", "Hubie", ""]]}, {"id": "1206.4444", "submitter": "Tino Teige", "authors": "Tino Teige (Carl von Ossietzky University of Oldenburg), Martin\n  Fr\\\"anzle (Carl von Ossietzky University of Oldenburg)", "title": "Generalized Craig Interpolation for Stochastic Boolean Satisfiability\n  Problems with Applications to Probabilistic State Reachability and Region\n  Stability", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 2 (June 26,\n  2012) lmcs:1031", "doi": "10.2168/LMCS-8(2:16)2012", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The stochastic Boolean satisfiability (SSAT) problem has been introduced by\nPapadimitriou in 1985 when adding a probabilistic model of uncertainty to\npropositional satisfiability through randomized quantification. SSAT has many\napplications, among them probabilistic bounded model checking (PBMC) of\nsymbolically represented Markov decision processes. This article identifies a\nnotion of Craig interpolant for the SSAT framework and develops an algorithm\nfor computing such interpolants based on a resolution calculus for SSAT. As a\npotential application area of this novel concept of Craig interpolation, we\naddress the symbolic analysis of probabilistic systems. We first investigate\nthe use of interpolation in probabilistic state reachability analysis, turning\nthe falsification procedure employing PBMC into a verification technique for\nprobabilistic safety properties. We furthermore propose an interpolation-based\napproach to probabilistic region stability, being able to verify that the\nprobability of stabilizing within some region is sufficiently large.\n", "versions": [{"version": "v1", "created": "Wed, 20 Jun 2012 10:20:14 GMT"}, {"version": "v2", "created": "Mon, 25 Jun 2012 15:48:27 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Teige", "Tino", "", "Carl von Ossietzky University of Oldenburg"], ["Fr\u00e4nzle", "Martin", "", "Carl von Ossietzky University of Oldenburg"]]}, {"id": "1206.4458", "submitter": "Guido Fiorino Mr", "authors": "Guido Fiorino", "title": "Terminating Calculi for Propositional Dummett Logic with Subformula\n  Property", "comments": "21 pages, rejected at CSL 2012", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present two terminating tableau calculi for propositional\nDummett logic obeying the subformula property. The ideas of our calculi rely on\nthe linearly ordered Kripke semantics of Dummett logic. The first calculus\nworks on two semantical levels: the present and the next possible world. The\nsecond calculus employs the usual object language of tableau systems and\nexploits a property of the construction of the completeness theorem to\nintroduce a check which is an alternative to loop check mechanisms.\n", "versions": [{"version": "v1", "created": "Wed, 20 Jun 2012 11:07:47 GMT"}], "update_date": "2012-06-21", "authors_parsed": [["Fiorino", "Guido", ""]]}, {"id": "1206.4504", "submitter": "Xu Wang", "authors": "Chris Chilton, Marta Kwiatkowska and Xu Wang", "title": "Revisiting Timed Specification Theories: A Linear-Time Perspective", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the setting of component-based design for real-time systems with\ncritical timing constraints. Based on our earlier work, we propose a\ncompositional specification theory for timed automata with I/O distinction,\nwhich supports substitutive refinement. Our theory provides the operations of\nparallel composition for composing components at run-time, logical\nconjunction/disjunction for independent development, and quotient for\nincremental synthesis. The key novelty of our timed theory lies in a weakest\ncongruence preserving safety as well as bounded liveness properties. We show\nthat the congruence can be characterised by two linear-time semantics,\ntimed-traces and timed-strategies, the latter of which is derived from a\ngame-based interpretation of timed interaction.\n", "versions": [{"version": "v1", "created": "Tue, 19 Jun 2012 11:07:33 GMT"}], "update_date": "2012-06-21", "authors_parsed": [["Chilton", "Chris", ""], ["Kwiatkowska", "Marta", ""], ["Wang", "Xu", ""]]}, {"id": "1206.4547", "submitter": "Benedikt Ahrens", "authors": "Benedikt Ahrens", "title": "Initiality for Typed Syntax and Semantics", "comments": "presented at WoLLIC 2012, 15 pages", "journal-ref": "Logic, Language, Information and Computation, LNCS 7456 (2012),\n  pp. 127-141, http://www.springerlink.com/content/n180nt1qxg76755g/", "doi": "10.1007/978-3-642-32621-9_10", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give an algebraic characterization of the syntax and semantics of a class\nof simply-typed languages, such as the language PCF: we characterize\nsimply-typed binding syntax equipped with reduction rules via a universal\nproperty, namely as the initial object of some category. For this purpose, we\nemploy techniques developed in two previous works: in [2], we model syntactic\ntranslations between languages over different sets of types as initial\nmorphisms in a category of models. In [1], we characterize untyped syntax with\nreduction rules as initial object in a category of models. In the present work,\nwe show that those techniques are modular enough to be combined: we thus\ncharacterize simply-typed syntax with reduction rules as initial object in a\ncategory. The universal property yields an operator which allows to specify\ntranslations - that are semantically faithful by construction - between\nlanguages over possibly different sets of types.\n  We specify a language by a 2-signature, that is, a signature on two levels:\nthe syntactic level specifies the types and terms of the language, and\nassociates a type to each term. The semantic level specifies, through\ninequations, reduction rules on the terms of the language. To any given\n2-signature we associate a category of models. We prove that this category has\nan initial object, which integrates the types and terms freely generated by the\n2-signature, and the reduction relation on those terms generated by the given\ninequations. We call this object the (programming) language generated by the\n2-signature.\n  [1] Ahrens, B.: Modules over relative monads for syntax and semantics (2011),\narXiv:1107.5252, to be published in Math. Struct. in Comp. Science\n  [2] Ahrens, B.: Extended Initiality for Typed Abstract Syntax. Logical\nMethods in Computer Science 8(2), 1-35 (2012)\n", "versions": [{"version": "v1", "created": "Wed, 20 Jun 2012 16:30:06 GMT"}], "update_date": "2012-08-28", "authors_parsed": [["Ahrens", "Benedikt", ""]]}, {"id": "1206.4556", "submitter": "Benedikt Ahrens", "authors": "Benedikt Ahrens", "title": "Initiality for Typed Syntax and Semantics", "comments": "215 pages, 2012, PhD thesis", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this thesis we give an algebraic characterization of the syntax and\nsemantics of simply-typed languages. More precisely, we characterize\nsimply-typed binding syntax equipped with reduction rules via a universal\nproperty, namely as the initial object of some category. We specify a language\nby a 2-signature ({\\Sigma}, A), that is, a signature on two levels: the\nsyntactic level {\\Sigma} specifies the sorts and terms of the language, and\nassociates a sort to each term. The semantic level A specifies, through\ninequations, reduction rules on the terms of the language. To any given\n2-signature ({\\Sigma}, A) we associate a category of \"models\" of ({\\Sigma}, A).\nWe prove that this category has an initial object, which integrates the terms\nfreely generated by {\\Sigma} and the reduction relation - on those terms -\ngenerated by A. We call this object the programming language generated by\n({\\Sigma}, A).\n  Initiality provides an iteration principle which allows to specify\ntranslations on the syntax, possibly to a language over different sorts.\nFurthermore, translations specified via the iteration principle are by\nconstruction type-safe and faithful with respect to reduction.\n  To illustrate our results, we consider two examples extensively: firstly, we\nspecify a double negation translation from classical to intuitionistic\npropositional logic via the category-theoretic iteration principle. Secondly,\nwe specify a translation from PCF to the untyped lambda calculus which is\nfaithful with respect to reduction in the source and target languages.\n  In a second part, we formalize some of our initiality theorems in the proof\nassistant Coq. The implementation yields a machinery which, when given a\n2-signature, returns an implementation of its associated abstract syntax\ntogether with certified substitution operation, iteration operator and a\nreduction relation generated by the specified reduction rules.\n", "versions": [{"version": "v1", "created": "Wed, 20 Jun 2012 16:57:25 GMT"}], "update_date": "2012-06-21", "authors_parsed": [["Ahrens", "Benedikt", ""]]}, {"id": "1206.4564", "submitter": "Peter Lohmann", "authors": "Peter Lohmann", "title": "Computational Aspects of Dependence Logic", "comments": "PhD thesis; 138 pages (110 main matter)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  In this thesis (modal) dependence logic is investigated. It was introduced in\n2007 by Jouko V\\\"a\\\"aan\\\"anen as an extension of first-order (resp. modal)\nlogic by the dependence operator =(). For first-order (resp. propositional)\nvariables x_1,...,x_n, =(x_1,...,x_n) intuitively states that the value of x_n\nis determined by those of x_1,...,x_n-1.\n  We consider fragments of modal dependence logic obtained by restricting the\nset of allowed modal and propositional connectives. We classify these fragments\nwith respect to the complexity of their satisfiability and model-checking\nproblems. For satisfiability we obtain complexity degrees from P over NP,\nSigma_P^2 and PSPACE up to NEXP, while for model-checking we only classify the\nfragments with respect to their tractability, i.e. we either show\nNP-completeness or containment in P.\n  We then study the extension of modal dependence logic by intuitionistic\nimplication. For this extension we again classify the complexity of the\nmodel-checking problem for its fragments. Here we obtain complexity degrees\nfrom P over NP and coNP up to PSPACE.\n  Finally, we analyze first-order dependence logic, independence-friendly logic\nand their two-variable fragments. We prove that satisfiability for two-variable\ndependence logic is NEXP-complete, whereas for two-variable\nindependence-friendly logic it is undecidable; and use this to prove that the\nlatter is also more expressive than the former.\n", "versions": [{"version": "v1", "created": "Wed, 20 Jun 2012 17:56:52 GMT"}], "update_date": "2012-06-21", "authors_parsed": [["Lohmann", "Peter", ""]]}, {"id": "1206.4809", "submitter": "Vasco Brattka", "authors": "Vasco Brattka, St\\'ephane Le Roux, Joseph S. Miller and Arno Pauly", "title": "Connected Choice and the Brouwer Fixed Point Theorem", "comments": "36 pages", "journal-ref": "Journal of Mathematical Logic 19:1 (2019) 1-46", "doi": "10.1142/S0219061319500041", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the computational content of the Brouwer Fixed Point Theorem in the\nWeihrauch lattice. Connected choice is the operation that finds a point in a\nnon-empty connected closed set given by negative information. One of our main\nresults is that for any fixed dimension the Brouwer Fixed Point Theorem of that\ndimension is computably equivalent to connected choice of the Euclidean unit\ncube of the same dimension. Another main result is that connected choice is\ncomplete for dimension greater than or equal to two in the sense that it is\ncomputably equivalent to Weak K\\H{o}nig's Lemma. While we can present two\nindependent proofs for dimension three and upwards that are either based on a\nsimple geometric construction or a combinatorial argument, the proof for\ndimension two is based on a more involved inverse limit construction. The\nconnected choice operation in dimension one is known to be equivalent to the\nIntermediate Value Theorem; we prove that this problem is not idempotent in\ncontrast to the case of dimension two and upwards. We also prove that Lipschitz\ncontinuity with Lipschitz constants strictly larger than one does not simplify\nfinding fixed points. Finally, we prove that finding a connectedness component\nof a closed subset of the Euclidean unit cube of any dimension greater or equal\nto one is equivalent to Weak K\\H{o}nig's Lemma. In order to describe these\nresults, we introduce a representation of closed subsets of the unit cube by\ntrees of rational complexes.\n", "versions": [{"version": "v1", "created": "Thu, 21 Jun 2012 08:31:51 GMT"}, {"version": "v2", "created": "Sat, 3 Dec 2016 13:09:39 GMT"}, {"version": "v3", "created": "Fri, 9 Nov 2018 14:07:53 GMT"}], "update_date": "2021-02-24", "authors_parsed": [["Brattka", "Vasco", ""], ["Roux", "St\u00e9phane Le", ""], ["Miller", "Joseph S.", ""], ["Pauly", "Arno", ""]]}, {"id": "1206.4833", "submitter": "Alo\\\"is Brunel", "authors": "Alo\\\"is Brunel and Antoine Madet", "title": "Indexed realizability for bounded-time programming with references and\n  type fixpoints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The field of implicit complexity has recently produced several\nbounded-complexity programming languages. This kind of language allows to\nimplement exactly the functions belonging to a certain complexity class. We\nhere present a realizability semantics for a higher-order functional language\nbased on a fragment of linear logic called LAL which characterizes the\ncomplexity class PTIME. This language features recursive types and higher-order\nstore. Our realizability is based on biorthogonality, step-indexing and is\nmoreover quantitative. This last feature enables us not only to derive a\nsemantical proof of termination, but also to give bounds on the number of\ncomputational steps needed by typed programs to terminate.\n", "versions": [{"version": "v1", "created": "Thu, 21 Jun 2012 11:09:02 GMT"}], "update_date": "2012-06-22", "authors_parsed": [["Brunel", "Alo\u00efs", ""], ["Madet", "Antoine", ""]]}, {"id": "1206.4860", "submitter": "Carlo Alberto Furia", "authors": "Carlo A. Furia", "title": "Asynchronous Multi-Tape Automata Intersection: Undecidability and\n  Approximation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  When their reading heads are allowed to move completely asynchronously,\nfinite-state automata with multiple tapes achieve a significant expressive\npower, but also lose useful closure properties---closure under intersection, in\nparticular. This paper investigates to what extent it is still feasible to use\nmulti-tape automata as recognizer of polyadic predicates on words. On the\nnegative side, determining whether the intersection of asynchronous multi-tape\nautomata is expressible is not even semidecidable. On the positive side, we\npresent an algorithm that computes under-approximations of the intersection;\nand discuss simple conditions under which it can construct complete\nintersections. A prototype implementation and a few non-trivial examples\ndemonstrate the algorithm in practice.\n", "versions": [{"version": "v1", "created": "Thu, 21 Jun 2012 13:02:07 GMT"}, {"version": "v2", "created": "Sun, 3 Mar 2013 16:20:21 GMT"}, {"version": "v3", "created": "Sun, 15 Sep 2013 17:13:54 GMT"}, {"version": "v4", "created": "Mon, 2 Dec 2013 16:31:52 GMT"}, {"version": "v5", "created": "Thu, 13 Feb 2014 13:45:17 GMT"}], "update_date": "2014-02-14", "authors_parsed": [["Furia", "Carlo A.", ""]]}, {"id": "1206.4935", "submitter": "Clemens Kupke", "authors": "Clemens Kupke (Imperial College London), Alexander Kurz (University of\n  Leicester), Yde Venema (University of Amsterdam)", "title": "Completeness for the coalgebraic cover modality", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 3 (July 31,\n  2012) lmcs:896", "doi": "10.2168/LMCS-8(3:2)2012", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the finitary version of the coalgebraic logic introduced by L. Moss.\nThe syntax of this logic, which is introduced uniformly with respect to a\ncoalgebraic type functor, required to preserve weak pullbacks, extends that of\nclassical propositional logic with a so-called coalgebraic cover modality\ndepending on the type functor. Its semantics is defined in terms of a\ncategorically defined relation lifting operation. As the main contributions of\nour paper we introduce a derivation system, and prove that it provides a sound\nand complete axiomatization for the collection of coalgebraically valid\ninequalities. Our soundness and completeness proof is algebraic, and we employ\nPattinson's stratification method, showing that our derivation system can be\nstratified in countably many layers, corresponding to the modal depth of the\nformulas involved. In the proof of our main result we identify some new\nconcepts and obtain some auxiliary results of independent interest. We survey\nproperties of the notion of relation lifting, induced by an arbitrary but fixed\nset functor. We introduce a category of Boolean algebra presentations, and\nestablish an adjunction between it and the category of Boolean algebras. Given\nthe fact that our derivation system involves only formulas of depth one, it can\nbe encoded as a endo-functor on Boolean algebras. We show that this functor is\nfinitary and preserves embeddings, and we prove that the Lindenbaum-Tarski\nalgebra of our logic can be identified with the initial algebra for this\nfunctor.\n", "versions": [{"version": "v1", "created": "Thu, 21 Jun 2012 16:36:09 GMT"}, {"version": "v2", "created": "Sun, 29 Jul 2012 23:36:31 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Kupke", "Clemens", "", "Imperial College London"], ["Kurz", "Alexander", "", "University of\n  Leicester"], ["Venema", "Yde", "", "University of Amsterdam"]]}, {"id": "1206.5112", "submitter": "Marcin  Benke", "authors": "Viviana Bono, Marcin Benke, Aleksy Schubert", "title": "Lucretia - a type system for objects in languages with reflection", "comments": "21 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Object-oriented scripting languages such as JavaScript or Python gain in\npopularity due to their flexibility. Still, the growing code bases written in\nthe languages call for methods that make possible to automatically control the\nproperties of the programs that ensure their stability in the running time. We\npropose a type system, called Lucretia, that makes possible to control the\nobject structure of languages with reflection. Subject reduction and soundness\nof the type system with respect to the semantics of the language is proved.\n", "versions": [{"version": "v1", "created": "Fri, 22 Jun 2012 11:07:14 GMT"}], "update_date": "2012-06-26", "authors_parsed": [["Bono", "Viviana", ""], ["Benke", "Marcin", ""], ["Schubert", "Aleksy", ""]]}, {"id": "1206.5174", "submitter": "Nir Piterman", "authors": "Krishnendu Chatterjee and Nir Piterman", "title": "Obligation Blackwell Games and p-Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We recently introduced p-automata, automata that read discrete-time Markov\nchains. We used turn-based stochastic parity games to define acceptance of\nMarkov chains by a subclass of p-automata. Definition of acceptance required a\ncumbersome and complicated reduction to a series of turn-based stochastic\nparity games. The reduction could not support acceptance by general p-automata,\nwhich was left undefined as there was no notion of games that supported it.\n  Here we generalize two-player games by adding a structural acceptance\ncondition called obligations. Obligations are orthogonal to the linear winning\nconditions that define winning. Obligations are a declaration that player 0 can\nachieve a certain value from a configuration. If the obligation is met, the\nvalue of that configuration for player 0 is 1.\n  One cannot define value in obligation games by the standard mechanism of\nconsidering the measure of winning paths on a Markov chain and taking the\nsupremum of the infimum of all strategies. Mainly because obligations need\ndefinition even for Markov chains and the nature of obligations has the flavor\nof an infinite nesting of supremum and infimum operators. We define value via a\nreduction to turn-based games similar to Martin's proof of determinacy of\nBlackwell games with Borel objectives. Based on this definition, we show that\ngames are determined. We show that for Markov chains with Borel objectives and\nobligations, and finite turn-based stochastic parity games with obligations\nthere exists an alternative and simpler characterization of the value function.\nBased on this simpler definition we give an exponential time algorithm to\nanalyze finite turn-based stochastic parity games with obligations. Finally, we\nshow that obligation games provide the necessary framework for reasoning about\np-automata and that they generalize the previous definition.\n", "versions": [{"version": "v1", "created": "Fri, 22 Jun 2012 15:13:32 GMT"}, {"version": "v2", "created": "Thu, 19 Sep 2013 08:10:44 GMT"}, {"version": "v3", "created": "Sun, 3 Nov 2013 20:57:32 GMT"}], "update_date": "2013-11-05", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Piterman", "Nir", ""]]}, {"id": "1206.5694", "submitter": "Naoki Nishida", "authors": "Naoki Nishida (Nagoya University), Masahiko Sakai (Nagoya University),\n  Toshiki Sakabe (Nagoya University)", "title": "Soundness of Unravelings for Conditional Term Rewriting Systems via\n  Ultra-Properties Related to Linearity", "comments": "49 pages, 1 table, publication in Special Issue: Selected papers of\n  the \"22nd International Conference on Rewriting Techniques and Applications\n  (RTA'11)\"", "journal-ref": "Logical Methods in Computer Science, Volume 8, Issue 3 (August 10,\n  2012) lmcs:669", "doi": "10.2168/LMCS-8(3:4)2012", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Unravelings are transformations from a conditional term rewriting system\n(CTRS, for short) over an original signature into an unconditional term\nrewriting systems (TRS, for short) over an extended signature. They are not\nsound w.r.t. reduction for every CTRS, while they are complete w.r.t.\nreduction. Here, soundness w.r.t. reduction means that every reduction sequence\nof the corresponding unraveled TRS, of which the initial and end terms are over\nthe original signature, can be simulated by the reduction of the original CTRS.\nIn this paper, we show that an optimized variant of Ohlebusch's unraveling for\na deterministic CTRS is sound w.r.t. reduction if the corresponding unraveled\nTRS is left-linear or both right-linear and non-erasing. We also show that\nsoundness of the variant implies that of Ohlebusch's unraveling. Finally, we\nshow that soundness of Ohlebusch's unraveling is the weakest in soundness of\nthe other unravelings and a transformation, proposed by Serbanuta and Rosu, for\n(normal) deterministic CTRSs, i.e., soundness of them respectively implies that\nof Ohlebusch's unraveling.\n", "versions": [{"version": "v1", "created": "Mon, 25 Jun 2012 14:20:07 GMT"}, {"version": "v2", "created": "Thu, 9 Aug 2012 19:17:35 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Nishida", "Naoki", "", "Nagoya University"], ["Sakai", "Masahiko", "", "Nagoya University"], ["Sakabe", "Toshiki", "", "Nagoya University"]]}, {"id": "1206.6295", "submitter": "Vojtech Forejt", "authors": "Vojtech Forejt, Marta Kwiatkowska and David Parker", "title": "Pareto Curves for Probabilistic Model Checking", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multi-objective probabilistic model checking provides a way to verify\nseveral, possibly conflicting, quantitative properties of a stochastic system.\nIt has useful applications in controller synthesis and compositional\nprobabilistic verification. However, existing methods are based on linear\nprogramming, which limits the scale of systems that can be analysed and makes\nverification of time-bounded properties very difficult. We present a novel\napproach that addresses both of these shortcomings, based on the generation of\nsuccessive approximations of the Pareto curve for a multi-objective model\nchecking problem. We illustrate dramatic improvements in efficiency on a large\nset of benchmarks and show how the ability to visualise Pareto curves\nsignificantly enhances the quality of results obtained from current\nprobabilistic verification tools.\n", "versions": [{"version": "v1", "created": "Sun, 24 Jun 2012 15:09:09 GMT"}], "update_date": "2015-03-20", "authors_parsed": [["Forejt", "Vojtech", ""], ["Kwiatkowska", "Marta", ""], ["Parker", "David", ""]]}, {"id": "1206.6504", "submitter": "Pierre Boudes", "authors": "Pierre Boudes, Damiano Mazza, Lorenzo Tortora de Falco", "title": "An Abstract Approach to Stratification in Linear Logic", "comments": null, "journal-ref": "Information and Computation, 241:32-61, 2015", "doi": "10.1016/j.ic.2014.10.006", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the notion of stratification, as used in subsystems of linear logic\nwith low complexity bounds on the cut-elimination procedure (the so-called\nlight logics), from an abstract point of view, introducing a logical system in\nwhich stratification is handled by a separate modality. This modality, which is\na generalization of the paragraph modality of Girard's light linear logic,\narises from a general categorical construction applicable to all models of\nlinear logic. We thus learn that stratification may be formulated independently\nof exponential modalities; when it is forced to be connected to exponential\nmodalities, it yields interesting complexity properties. In particular, from\nour analysis stem three alternative reformulations of Baillot and Mazza's\nlinear logic by levels: one geometric, one interactive, and one semantic.\n", "versions": [{"version": "v1", "created": "Wed, 27 Jun 2012 20:00:58 GMT"}, {"version": "v2", "created": "Thu, 14 Feb 2013 19:55:21 GMT"}], "update_date": "2015-09-04", "authors_parsed": [["Boudes", "Pierre", ""], ["Mazza", "Damiano", ""], ["de Falco", "Lorenzo Tortora", ""]]}, {"id": "1206.6565", "submitter": "Krishna S", "authors": "Shibashis Guha and Shankara Narayanan Krishna", "title": "Game Characterizations of Timed Relations for Timed Automata Processes", "comments": "20 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we design the game semantics for timed equivalences and\npreorders of timed processes. The timed games corresponding to the various\ntimed relations form a hierarchy. These games are similar to Stirling's\nbisimulation games. If it is the case that the existence of a winning strategy\nfor the defender in a game ${\\cal G}_1$ implies that there exists a winning\nstrategy for the defender in another game ${\\cal G}_2$, then the relation that\ncorresponds to ${\\cal G}_1$ is stronger than the relation corresponding to\n${\\cal G}_2$. The game hierarchy also throws light into several timed relations\nthat are not considered in this paper.\n", "versions": [{"version": "v1", "created": "Thu, 28 Jun 2012 04:52:32 GMT"}], "update_date": "2012-06-29", "authors_parsed": [["Guha", "Shibashis", ""], ["Krishna", "Shankara Narayanan", ""]]}, {"id": "1206.6573", "submitter": "Pietro Galliani Dr", "authors": "Pietro Galliani", "title": "Dialetheism, Game Theoretic Semantics, and Paraconsistent Team Semantics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a variant of Dependence Logic in which truth is defined not in\nterms of existence of winning strategies for the Proponent (Eloise) in a\nsemantic game, but in terms of lack of winning strategies for the Opponent\n(Abelard). We show that this language is a conservative but paraconsistent\nextension of First Order Logic, that its validity problem can be reduced to\nthat of First Order Logic, that it capable of expressing its own truth and\nvalidity predicates, and that it is expressively equivalent to Universal Second\nOrder Logic. Furthermore, we prove that a Paraconsistent Non-dependence Logic\nformula is consistent if and only if it is equivalent to some First Order Logic\nsentence; and we show that, on the other hand, all Paraconsistent Dependence\nLogic sentences are equivalent to some First Order sentence with respect to\ntruth (but not necessarily with respect to falsity).\n", "versions": [{"version": "v1", "created": "Thu, 28 Jun 2012 06:35:10 GMT"}, {"version": "v2", "created": "Fri, 14 Mar 2014 19:59:14 GMT"}], "update_date": "2014-03-17", "authors_parsed": [["Galliani", "Pietro", ""]]}]