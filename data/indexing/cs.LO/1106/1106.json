[{"id": "1106.0399", "submitter": "Arno Bastenhof", "authors": "Arno Bastenhof", "title": "Focalization and phase models for classical extensions of\n  non-associative Lambek calculus", "comments": "To be submitted", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Lambek's non-associative syntactic calculus (NL) excels in its resource\nconsciousness: the usual structural rules for weakening, contraction, exchange\nand even associativity are all dropped. Recently, there have been proposals for\nconservative extensions dispensing with NL's intuitionistic bias towards\nsequents with single conclusions: De Groote and Lamarche's classical\nnon-associative Lambek calculus (CNL) and the Lambek-Grishin calculus (LG) of\nMoortgat and associates. We demonstrate Andreoli's focalization property for\nsaid proposals: a normalization result for Cut-free sequent derivations\nidentifying to a large extent those differing only by trivial rule\npermutations. In doing so, we proceed from a `uniform' sequent presentation,\nderiving CNL from LG through the addition of structural rules. The\nnormalization proof proceeds by the construction of syntactic phase models\nwherein every `truth' has a focused proof, similar to work of Okada and of\nHerbelin and Lee.\n", "versions": [{"version": "v1", "created": "Thu, 2 Jun 2011 10:51:47 GMT"}], "update_date": "2011-06-03", "authors_parsed": [["Bastenhof", "Arno", ""]]}, {"id": "1106.0468", "submitter": "Igor Melatti", "authors": "Federico Mari, Igor Melatti, Ivano Salvo, Enrico Tronci", "title": "From Boolean Functional Equations to Control Software", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many software as well digital hardware automatic synthesis methods define the\nset of implementations meeting the given system specifications with a boolean\nrelation K. In such a context a fundamental step in the software (hardware)\nsynthesis process is finding effective solutions to the functional equation\ndefined by K. This entails finding a (set of) boolean function(s) F (typically\nrepresented using OBDDs, Ordered Binary Decision Diagrams) such that: 1) for\nall x for which K is satisfiable, K(x, F(x)) = 1 holds; 2) the implementation\nof F is efficient with respect to given implementation parameters such as code\nsize or execution time. While this problem has been widely studied in digital\nhardware synthesis, little has been done in a software synthesis context.\nUnfortunately the approaches developed for hardware synthesis cannot be\ndirectly used in a software context. This motivates investigation of effective\nmethods to solve the above problem when F has to be implemented with software.\nIn this paper we present an algorithm that, from an OBDD representation for K,\ngenerates a C code implementation for F that has the same size as the OBDD for\nF and a WCET (Worst Case Execution Time) at most O(nr), being n = |x| the\nnumber of arguments of functions in F and r the number of functions in F.\n", "versions": [{"version": "v1", "created": "Wed, 1 Jun 2011 12:20:18 GMT"}, {"version": "v2", "created": "Fri, 10 Jun 2011 10:37:13 GMT"}, {"version": "v3", "created": "Mon, 24 Oct 2011 07:47:06 GMT"}, {"version": "v4", "created": "Tue, 22 May 2012 08:48:06 GMT"}], "update_date": "2012-05-23", "authors_parsed": [["Mari", "Federico", ""], ["Melatti", "Igor", ""], ["Salvo", "Ivano", ""], ["Tronci", "Enrico", ""]]}, {"id": "1106.0706", "submitter": "Dusko Pavlovic", "authors": "Dusko Pavlovic and Catherine Meadows", "title": "Actor-network procedures: Modeling multi-factor authentication, device\n  pairing, social interactions", "comments": "32 pages, 12 figures, 3 tables; journal submission; extended\n  references, added discussion", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.CY cs.LO cs.SI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As computation spreads from computers to networks of computers, and migrates\ninto cyberspace, it ceases to be globally programmable, but it remains\nprogrammable indirectly: network computations cannot be controlled, but they\ncan be steered by local constraints on network nodes. The tasks of\n\"programming\" global behaviors through local constraints belong to the area of\nsecurity. The \"program particles\" that assure that a system of local\ninteractions leads towards some desired global goals are called security\nprotocols. As computation spreads beyond cyberspace, into physical and social\nspaces, new security tasks and problems arise. As networks are extended by\nphysical sensors and controllers, including the humans, and interlaced with\nsocial networks, the engineering concepts and techniques of computer security\nblend with the social processes of security. These new connectors for\ncomputational and social software require a new \"discipline of programming\" of\nglobal behaviors through local constraints. Since the new discipline seems to\nbe emerging from a combination of established models of security protocols with\nolder methods of procedural programming, we use the name procedures for these\nnew connectors, that generalize protocols. In the present paper we propose\nactor-networks as a formal model of computation in heterogenous networks of\ncomputers, humans and their devices; and we introduce Procedure Derivation\nLogic (PDL) as a framework for reasoning about security in actor-networks. On\nthe way, we survey the guiding ideas of Protocol Derivation Logic (also PDL)\nthat evolved through our work in security in last 10 years. Both formalisms are\ngeared towards graphic reasoning and tool support. We illustrate their workings\nby analysing a popular form of two-factor authentication, and a multi-channel\ndevice pairing procedure, devised for this occasion.\n", "versions": [{"version": "v1", "created": "Fri, 3 Jun 2011 16:34:50 GMT"}, {"version": "v2", "created": "Mon, 29 Aug 2011 14:20:24 GMT"}], "update_date": "2011-08-30", "authors_parsed": [["Pavlovic", "Dusko", ""], ["Meadows", "Catherine", ""]]}, {"id": "1106.0776", "submitter": "Juan Carlos Nieves", "authors": "Juan Carlos Nieves, Mauricio Osorio and Ulises Cort\\'es", "title": "Semantics for Possibilistic Disjunctive Programs", "comments": "37 pages, 5 figures. To appear in Theory and Practice of Logic\n  Programming (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  In this paper, a possibilistic disjunctive logic programming approach for\nmodeling uncertain, incomplete and inconsistent information is defined. This\napproach introduces the use of possibilistic disjunctive clauses which are able\nto capture incomplete information and incomplete states of a knowledge base at\nthe same time.\n  By considering a possibilistic logic program as a possibilistic logic theory,\na construction of a possibilistic logic programming semantic based on answer\nsets and the proof theory of possibilistic logic is defined. It shows that this\npossibilistic semantics for disjunctive logic programs can be characterized by\na fixed-point operator. It is also shown that the suggested possibilistic\nsemantics can be computed by a resolution algorithm and the consideration of\noptimal refutations from a possibilistic logic theory.\n  In order to manage inconsistent possibilistic logic programs, a preference\ncriterion between inconsistent possibilistic models is defined; in addition,\nthe approach of cuts for restoring consistency of an inconsistent possibilistic\nknowledge base is adopted. The approach is illustrated in a medical scenario.\n", "versions": [{"version": "v1", "created": "Fri, 3 Jun 2011 22:57:06 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Nieves", "Juan Carlos", ""], ["Osorio", "Mauricio", ""], ["Cort\u00e9s", "Ulises", ""]]}, {"id": "1106.0814", "submitter": "EPTCS", "authors": "Giovanna D'Agostino (Universit\\`a degli Studi di Udine), Salvatore La\n  Torre (Universit\\`a degli Studi di Salerno)", "title": "Proceedings of Second International Symposium on Games, Automata, Logics\n  and Formal Verification", "comments": null, "journal-ref": "EPTCS 54, 2011", "doi": "10.4204/EPTCS.54", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the Proceedings of the Second International Symposium on\nGames, Automata, Languages, and Formal Verification (GandALF 2011). The\nconference was held in Minori (Amalfi Coast, Italy), from the 15th to the 17th\nof June 2011. The aim of the GandALF Symposium is to provide a forum for\nresearchers from different areas and with different background, that share a\ncommon interest in game theory, mathematical logic, automata theory, and their\napplications to the specification, design, and verification of complex systems.\nThis proceedings contain the abstracts of three invited talks and nineteen\nregular papers that have been selected through a rigorous reviewing process\naccording to originality, quality, and relevance to the topics of the\nsymposium.\n", "versions": [{"version": "v1", "created": "Sat, 4 Jun 2011 11:51:36 GMT"}], "update_date": "2011-06-07", "authors_parsed": [["D'Agostino", "Giovanna", "", "Universit\u00e0 degli Studi di Udine"], ["La Torre", "Salvatore", "", "Universit\u00e0 degli Studi di Salerno"]]}, {"id": "1106.1228", "submitter": "EPTCS", "authors": "Yoad Lustig (Rice University), Moshe Vardi (Rice University)", "title": "Synthesis from Recursive-Components Libraries", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 1-16", "doi": "10.4204/EPTCS.54.1", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Synthesis is the automatic construction of a system from its specification.\nIn classical synthesis algorithms it is always assumed that the system is\n\"constructed from scratch\" rather than composed from reusable components. This,\nof course, rarely happens in real life. In real life, almost every non-trivial\ncommercial software system relies heavily on using libraries of reusable\ncomponents. Furthermore, other contexts, such as web-service orchestration, can\nbe modeled as synthesis of a system from a library of components.\n  In 2009 we introduced LTL synthesis from libraries of reusable components.\nHere, we extend the work and study synthesis from component libraries with\n\"call and return\"' control flow structure. Such control-flow structure is very\ncommon in software systems. We define the problem of Nested-Words Temporal\nLogic (NWTL) synthesis from recursive component libraries, where NWTL is a\nspecification formalism, richer than LTL, that is suitable for \"call and\nreturn\" computations. We solve the problem, providing a synthesis algorithm,\nand show the problem is 2EXPTIME-complete, as standard synthesis.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:05:37 GMT"}], "update_date": "2011-11-10", "authors_parsed": [["Lustig", "Yoad", "", "Rice University"], ["Vardi", "Moshe", "", "Rice University"]]}, {"id": "1106.1229", "submitter": "EPTCS", "authors": "Christian Appold", "title": "Improving BDD Based Symbolic Model Checking with Isomorphism Exploiting\n  Transition Relations", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 17-30", "doi": "10.4204/EPTCS.54.2", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Symbolic model checking by using BDDs has greatly improved the applicability\nof model checking. Nevertheless, BDD based symbolic model checking can still be\nvery memory and time consuming. One main reason is the complex transition\nrelation of systems. Sometimes, it is even not possible to generate the\ntransition relation, due to its exhaustive memory requirements. To diminish\nthis problem, the use of partitioned transition relations has been proposed.\nHowever, there are still systems which can not be verified at all. Furthermore,\nif the granularity of the partitions is too fine, the time required for\nverification may increase. In this paper we target the symbolic verification of\nasynchronous concurrent systems. For such systems we present an approach which\nuses similarities in the transition relation to get further memory reductions\nand runtime improvements. By applying our approach, even the verification of\nsystems with an previously intractable transition relation becomes feasible.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:05:45 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Appold", "Christian", ""]]}, {"id": "1106.1230", "submitter": "EPTCS", "authors": "Stefan Haar (INRIA and LSV, Ecole Normale Sup\\'erieure de Cachan and\n  CNRS), Christian Kern (TU M\\\"unchen), Stefan Schwoon (INRIA and LSV, Ecole\n  Normale Sup\\'erieure de Cachan and CNRS)", "title": "Computing the Reveals Relation in Occurrence Nets", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 31-44", "doi": "10.4204/EPTCS.54.3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Petri net unfoldings are a useful tool to tackle state-space explosion in\nverification and related tasks. Moreover, their structure allows to access\ndirectly the relations of causal precedence, concurrency, and conflict between\nevents. Here, we explore the data structure further, to determine the following\nrelation: event a is said to reveal event b iff the occurrence of a implies\nthat b inevitably occurs, too, be it before, after, or concurrently with a.\nKnowledge of reveals facilitates in particular the analysis of partially\nobservable systems, in the context of diagnosis, testing or verification; it\ncan also be used to generate more concise representations of behaviours via\nabstractions. The reveals relation was previously introduced in the context of\nfault diagnosis, where it was shown that the reveals relation was decidable:\nfor a given pair a,b in the unfolding U of a safe Petri net N, a finite prefix\nP of U is sufficient to decide whether or not a reveals b. In this paper, we\nfirst considerably improve the bound on |P|. We then show that there exists an\nefficient algorithm for computing the relation on a given prefix. We have\nimplemented the algorithm and report on experiments.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:05:53 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Haar", "Stefan", "", "INRIA and LSV, Ecole Normale Sup\u00e9rieure de Cachan and\n  CNRS"], ["Kern", "Christian", "", "TU M\u00fcnchen"], ["Schwoon", "Stefan", "", "INRIA and LSV, Ecole\n  Normale Sup\u00e9rieure de Cachan and CNRS"]]}, {"id": "1106.1231", "submitter": "EPTCS", "authors": "Federico Buti (University of Camerino), Massimo Callisto De Donato\n  (University of Camerino), Flavio Corradini (University of Camerino), Maria\n  Rita Di Berardini (University of Camerino), Walter Vogler (University of\n  Augsburg)", "title": "Automated Analysis of MUTEX Algorithms with FASE", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 45-59", "doi": "10.4204/EPTCS.54.4", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we study the liveness of several MUTEX solutions by\nrepresenting them as processes in PAFAS s, a CCS-like process algebra with a\nspecific operator for modelling non-blocking reading behaviours. Verification\nis carried out using the tool FASE, exploiting a correspondence between\nviolations of the liveness property and a special kind of cycles (called\ncatastrophic cycles) in some transition system. We also compare our approach\nwith others in the literature. The aim of this paper is twofold: on the one\nhand, we want to demonstrate the applicability of FASE to some concrete,\nmeaningful examples; on the other hand, we want to study the impact of\nintroducing non-blocking behaviours in modelling concurrent systems.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:05:57 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Buti", "Federico", "", "University of Camerino"], ["De Donato", "Massimo Callisto", "", "University of Camerino"], ["Corradini", "Flavio", "", "University of Camerino"], ["Di Berardini", "Maria Rita", "", "University of Camerino"], ["Vogler", "Walter", "", "University of\n  Augsburg"]]}, {"id": "1106.1234", "submitter": "EPTCS", "authors": "Makoto Tatsuta (National Institute of Informatics), Ferruccio Damiani\n  (Universita di Torino)", "title": "Type Inference for Bimorphic Recursion", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 102-115", "doi": "10.4204/EPTCS.54.8", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes bimorphic recursion, which is restricted polymorphic\nrecursion such that every recursive call in the body of a function definition\nhas the same type. Bimorphic recursion allows us to assign two different types\nto a recursively defined function: one is for its recursive calls and the other\nis for its calls outside its definition. Bimorphic recursion in this paper can\nbe nested. This paper shows bimorphic recursion has principal types and\ndecidable type inference. Hence bimorphic recursion gives us flexible typing\nfor recursion with decidable type inference. This paper also shows that its\ntypability becomes undecidable because of nesting of recursions when one\nremoves the instantiation property from the bimorphic recursion.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:06:23 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Tatsuta", "Makoto", "", "National Institute of Informatics"], ["Damiani", "Ferruccio", "", "Universita di Torino"]]}, {"id": "1106.1237", "submitter": "EPTCS", "authors": "Martin Zimmermann (RWTH Aachen University)", "title": "Optimal Bounds in Parametric LTL Games", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 146-161", "doi": "10.4204/EPTCS.54.11", "report-no": null, "categories": "cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider graph games of infinite duration with winning conditions in\nparameterized linear temporal logic, where the temporal operators are equipped\nwith variables for time bounds. In model checking such specifications were\nintroduced as \"PLTL\" by Alur et al. and (in a different version called\n\"PROMPT-LTL\") by Kupferman et al..\n  We present an algorithm to determine optimal variable valuations that allow a\nplayer to win a game. Furthermore, we show how to determine whether a player\nwins a game with respect to some, infinitely many, or all valuations. All our\nalgorithms run in doubly-exponential time; so, adding bounded temporal\noperators does not increase the complexity compared to solving plain LTL games.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:06:47 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Zimmermann", "Martin", "", "RWTH Aachen University"]]}, {"id": "1106.1239", "submitter": "EPTCS", "authors": "Laura Bozzelli (UPM, Madrid, Spain)", "title": "New results on pushdown module checking with imperfect information", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 162-177", "doi": "10.4204/EPTCS.54.12", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Model checking of open pushdown systems (OPD) w.r.t. standard branching\ntemporal logics (pushdown module checking or PMC) has been recently\ninvestigated in the literature, both in the context of environments with\nperfect and imperfect information about the system (in the last case, the\nenvironment has only a partial view of the system's control states and stack\ncontent). For standard CTL, PMC with imperfect information is known to be\nundecidable. If the stack content is assumed to be visible, then the problem is\ndecidable and 2EXPTIME-complete (matching the complexity of PMC with perfect\ninformation against CTL). The decidability status of PMC with imperfect\ninformation against CTL restricted to the case where the depth of the stack\ncontent is visible is open. In this paper, we show that with this restriction,\nPMC with imperfect information against CTL remains undecidable. On the other\nhand, we individuate an interesting subclass of OPDS with visible stack content\ndepth such that PMC with imperfect information against the existential fragment\nof CTL is decidable and in 2EXPTIME. Moreover, we show that the program\ncomplexity of PMC with imperfect information and visible stack content against\nCTL is 2EXPTIME-complete (hence, exponentially harder than the program\ncomplexity of PMC with perfect information, which is known to be\nEXPTIME-complete).\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:06:54 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Bozzelli", "Laura", "", "UPM, Madrid, Spain"]]}, {"id": "1106.1240", "submitter": "EPTCS", "authors": "R\\\"udiger Ehlers, Bernd Finkbeiner", "title": "Reactive Safety", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 178-191", "doi": "10.4204/EPTCS.54.13", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The distinction between safety and liveness properties is a fundamental\nclassification with immediate implications on the feasibility and complexity of\nvarious monitoring, model checking, and synthesis problems. In this paper, we\nrevisit the notion of safety for reactive systems, i.e., for systems whose\nbehavior is characterized by the interplay of uncontrolled environment inputs\nand controlled system outputs. We show that reactive safety is a strictly\nlarger class of properties than standard safety. We provide algorithms for\nchecking if a property, given as a temporal formula or as a word or tree\nautomaton, is a reactive safety property and for translating such properties\ninto safety automata. Based on this construction, the standard verification and\nsynthesis algorithms for safety properties immediately extend to the larger\nclass of reactive safety.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:07:04 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Ehlers", "R\u00fcdiger", ""], ["Finkbeiner", "Bernd", ""]]}, {"id": "1106.1241", "submitter": "EPTCS", "authors": "Davide Bresolin (University of Verona), Angelo Montanari (University\n  of Udine), Pietro Sala (University of Verona), Guido Sciavicco (University of\n  Murcia)", "title": "An Optimal Decision Procedure for MPNL over the Integers", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 192-206", "doi": "10.4204/EPTCS.54.14", "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Interval temporal logics provide a natural framework for qualitative and\nquantitative temporal reason- ing over interval structures, where the truth of\nformulae is defined over intervals rather than points. In this paper, we study\nthe complexity of the satisfiability problem for Metric Propositional Neigh-\nborhood Logic (MPNL). MPNL features two modalities to access intervals \"to the\nleft\" and \"to the right\" of the current one, respectively, plus an infinite set\nof length constraints. MPNL, interpreted over the naturals, has been recently\nshown to be decidable by a doubly exponential procedure. We improve such a\nresult by proving that MPNL is actually EXPSPACE-complete (even when length\nconstraints are encoded in binary), when interpreted over finite structures,\nthe naturals, and the in- tegers, by developing an EXPSPACE decision procedure\nfor MPNL over the integers, which can be easily tailored to finite linear\norders and the naturals (EXPSPACE-hardness was already known).\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:07:12 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Bresolin", "Davide", "", "University of Verona"], ["Montanari", "Angelo", "", "University\n  of Udine"], ["Sala", "Pietro", "", "University of Verona"], ["Sciavicco", "Guido", "", "University of\n  Murcia"]]}, {"id": "1106.1242", "submitter": "EPTCS", "authors": "Markus Latte", "title": "Separation of Test-Free Propositional Dynamic Logics over Context-Free\n  Languages", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 207-221", "doi": "10.4204/EPTCS.54.15", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For a class L of languages let PDL[L] be an extension of Propositional\nDynamic Logic which allows programs to be in a language of L rather than just\nto be regular. If L contains a non-regular language, PDL[L] can express\nnon-regular properties, in contrast to pure PDL.\n  For regular, visibly pushdown and deterministic context-free languages, the\nseparation of the respective PDLs can be proven by automata-theoretic\ntechniques. However, these techniques introduce non-determinism on the automata\nside. As non-determinism is also the difference between DCFL and CFL, these\ntechniques seem to be inappropriate to separate PDL[DCFL] from PDL[CFL].\nNevertheless, this separation is shown but for programs without test operators.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:07:17 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Latte", "Markus", ""]]}, {"id": "1106.1243", "submitter": "EPTCS", "authors": "Giacomo Lenzi (University of Salerno)", "title": "On P-transitive graphs and applications", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 222-236", "doi": "10.4204/EPTCS.54.16", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new class of graphs which we call P-transitive graphs, lying\nbetween transitive and 3-transitive graphs. First we show that the analogue of\nde Jongh-Sambin Theorem is false for wellfounded P-transitive graphs; then we\nshow that the mu-calculus fixpoint hierarchy is infinite for P-transitive\ngraphs. Both results contrast with the case of transitive graphs. We give also\nan undecidability result for an enriched mu-calculus on P-transitive graphs.\nFinally, we consider a polynomial time reduction from the model checking\nproblem on arbitrary graphs to the model checking problem on P-transitive\ngraphs. All these results carry over to 3-transitive graphs.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:07:24 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Lenzi", "Giacomo", "", "University of Salerno"]]}, {"id": "1106.1245", "submitter": "EPTCS", "authors": "Olga Tveretina (Karlsruhe Institute of Technology), Daniel Funke\n  (Karlsruhe Institute of Technology)", "title": "Deciding Reachability for 3-Dimensional Multi-Linear Systems", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 250-262", "doi": "10.4204/EPTCS.54.18", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper deals with the problem of point-to-point reachability in\nmulti-linear systems. These systems consist of a partition of the Euclidean\nspace into a finite number of regions and a constant derivative assigned to\neach region in the partition, which governs the dynamical behavior of the\nsystem within it. The reachability problem for multi-linear systems has been\nproven to be decidable for the two-dimensional case and undecidable for the\ndimension three and higher.\n  Multi-linear systems however exhibit certain properties that make them very\nsuitable for topological analysis. We prove that reachability can be decided\nexactly in the 3-dimensional case when systems satisfy certain conditions. We\nshow with experiments that our approach can be orders of magnitude more\nefficient than simulation.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:07:39 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Tveretina", "Olga", "", "Karlsruhe Institute of Technology"], ["Funke", "Daniel", "", "Karlsruhe Institute of Technology"]]}, {"id": "1106.1246", "submitter": "EPTCS", "authors": "Massimo Benerecetti (Universit\\`a di Napoli \"Federico II\", Italy),\n  Marco Faella (Universit\\`a di Napoli \"Federico II\", Italy), Stefano Minopoli\n  (Universit\\`a di Napoli \"Federico II\", Italy)", "title": "Towards Efficient Exact Synthesis for Linear Hybrid Systems", "comments": "In Proceedings GandALF 2011, arXiv:1106.0814", "journal-ref": "EPTCS 54, 2011, pp. 263-277", "doi": "10.4204/EPTCS.54.19", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the problem of automatically computing the controllable region of a\nLinear Hybrid Automaton, with respect to a safety objective. We describe the\ntechniques that are needed to effectively and efficiently implement a\nrecently-proposed solution procedure, based on polyhedral abstractions of the\nstate space. Supporting experimental results are presented, based on an\nimplementation of the proposed techniques on top of the tool PHAVer.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 01:07:47 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Benerecetti", "Massimo", "", "Universit\u00e0 di Napoli \"Federico II\", Italy"], ["Faella", "Marco", "", "Universit\u00e0 di Napoli \"Federico II\", Italy"], ["Minopoli", "Stefano", "", "Universit\u00e0 di Napoli \"Federico II\", Italy"]]}, {"id": "1106.1364", "submitter": "Andreas Gaiser", "authors": "Javier Esparza and Andreas Gaiser", "title": "Probabilistic Abstractions with Arbitrary Domains", "comments": "This is a technical report that goes along with an article to appear\n  in the Proceedings of the 18th International Static Analysis Symposium (SAS),\n  2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recent work by Hermanns et al. and Kattenbelt et al. has extended\ncounterexample-guided abstraction refinement (CEGAR) to probabilistic programs.\nThese approaches are limited to predicate abstraction. We present a novel\ntechnique, based on the abstract reachability tree recently introduced by\nGulavani et al., that can use arbitrary abstract domains and widening operators\n(in the sense of abstract interpretation). We show how suitable widening\noperators can deduce loop invariants diffcult to find for predicate\nabstraction, and propose refinement techniques.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 14:39:44 GMT"}, {"version": "v2", "created": "Thu, 16 Jun 2011 10:54:26 GMT"}], "update_date": "2011-06-17", "authors_parsed": [["Esparza", "Javier", ""], ["Gaiser", "Andreas", ""]]}, {"id": "1106.1370", "submitter": "Jingchao Chen", "authors": "Jingchao Chen", "title": "Exploiting Dynamically Propositional Logic Structures in SAT", "comments": "6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DM", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  The 32-bit hwb (hwb-n32 for short) problem is from equivalence checking that\narises in combining two circuits computing the hidden weighted bit function.\nSince 2002, it remains still unsolvable in every SAT competition. This paper\nfocuses on solving problems such as hwb-n32. Generally speaking, modern solvers\ncan detect only XOR, AND, OR and ITE gates. Other non-clausal formulas\n(propositional logic structures) cannot be detected. To solve the hwb-n32\nproblem, we extract dynamically some special propositional logic structures,\nand then use a variant of DPLL-based solvers to solve the subproblem simplified\nby the extracted structure information. Using the dynamic extraction technique,\nwe solved efficiently the hwb-n32 problem, even some of which were solved\nwithin 3000 seconds.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 15:06:41 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Chen", "Jingchao", ""]]}, {"id": "1106.1372", "submitter": "Jingchao Chen", "authors": "Jingchao Chen", "title": "Phase Selection Heuristics for Satisfiability Solvers", "comments": "12 pages 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DM", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  In general, a SAT Solver based on conflict-driven DPLL consists of variable\nselection, phase selection, Boolean Constraint Propagation, conflict analysis,\nclause learning and its database maintenance. Optimizing any part of these\ncomponents can enhance the performance of a solver. This paper focuses on\noptimizing phase selection. Although the ACE (Approximation of the Combined\nlookahead Evaluation) weight is applied to a lookahead SAT solver such as\nMarch, so far, no conflict-driven SAT solver applies successfully the ACE\nweight, since computing the ACE weight is time-consuming. Here we apply the ACE\nweight to partial phase selection of conflict-driven SAT solvers. This can be\nseen as an improvement of the heuristic proposed by Jeroslow-Wang (1990). We\nincorporate the ACE heuristic and the existing phase selection heuristics in\nthe new solver MPhaseSAT, and select a phase heuristic in a way similar to\nportfolio methods. Experimental results show that adding the ACE heuristic can\nimprove the conflict-driven solvers. Particularly on application instances,\nMPhaseSAT with the ACE heuristic is significantly better than MPhaseSAT without\nthe ACE heuristic, and even can solve a few SAT instances that remain\nunsolvable so far.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 15:13:41 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Chen", "Jingchao", ""]]}, {"id": "1106.1850", "submitter": "Fr", "authors": "Fr\\'ed\\'eric Herbreteau (Univ. Bordeaux, LaBRI), B Srivathsan (Univ.\n  Bordeaux, LaBRI)", "title": "Coarse abstractions make Zeno behaviours difficult to detect", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 1 (February\n  27, 2013) lmcs:882", "doi": "10.2168/LMCS-9(1:6)2013", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An infinite run of a timed automaton is Zeno if it spans only a finite amount\nof time. Such runs are considered unfeasible and hence it is important to\ndetect them, or dually, find runs that are non-Zeno. Over the years important\nimprovements have been obtained in checking reachability properties for timed\nautomata. We show that some of these very efficient optimizations make testing\nfor Zeno runs costly. In particular we show NP-completeness for the\nLU-extrapolation of Behrmann et al. We analyze the source of this complexity in\ndetail and give general conditions on extrapolation operators that guarantee a\n(low) polynomial complexity of Zenoness checking. We propose a slight weakening\nof the LU-extrapolation that satisfies these conditions.\n", "versions": [{"version": "v1", "created": "Thu, 9 Jun 2011 16:33:24 GMT"}, {"version": "v2", "created": "Wed, 9 Jan 2013 21:20:16 GMT"}, {"version": "v3", "created": "Tue, 26 Feb 2013 12:10:07 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Herbreteau", "Fr\u00e9d\u00e9ric", "", "Univ. Bordeaux, LaBRI"], ["Srivathsan", "B", "", "Univ.\n  Bordeaux, LaBRI"]]}, {"id": "1106.1875", "submitter": "Vincent Padovani", "authors": "Vincent Padovani (PPS)", "title": "Ticket Entailment is decidable", "comments": "Submitted on 06/09/2010 to Math. Struct. in Comp. Science. Accepted\n  for publication on 12/19/2011. Last revision on 03/06/2012", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove the decidability of Ticket Entailment. Raised by Anderson and Belnap\nwithin the framework of relevance logic, this question is equivalent to the\nquestion of the decidability of type inhabitation in simply-typed combinatory\nlogic with the partial basis BB'IW. We solve the equivalent problem of type\ninhabitation for the restriction of simply-typed lambda-calculus to\nhereditarily right-maximal terms.\n", "versions": [{"version": "v1", "created": "Thu, 9 Jun 2011 18:43:01 GMT"}, {"version": "v2", "created": "Fri, 8 Jul 2011 14:45:21 GMT"}, {"version": "v3", "created": "Tue, 12 Jul 2011 06:13:34 GMT"}, {"version": "v4", "created": "Mon, 19 Dec 2011 14:25:05 GMT"}, {"version": "v5", "created": "Mon, 19 Mar 2012 16:19:21 GMT"}, {"version": "v6", "created": "Thu, 5 Jul 2012 19:44:22 GMT"}], "update_date": "2012-07-06", "authors_parsed": [["Padovani", "Vincent", "", "PPS"]]}, {"id": "1106.1957", "submitter": "Frederick Maier", "authors": "Frederick Maier", "title": "Interdefinability of defeasible logic and logic programming under the\n  well-founded semantics", "comments": "36 pages; To appear in Theory and Practice of Logic Programming\n  (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide a method of translating theories of Nute's defeasible logic into\nlogic programs, and a corresponding translation in the opposite direction.\nUnder certain natural restrictions, the conclusions of defeasible theories\nunder the ambiguity propagating defeasible logic ADL correspond to those of the\nwell-founded semantics for normal logic programs, and so it turns out that the\ntwo formalisms are closely related. Using the same translation of logic\nprograms into defeasible theories, the semantics for the ambiguity blocking\ndefeasible logic NDL can be seen as indirectly providing an ambiguity blocking\nsemantics for logic programs. We also provide antimonotone operators for both\nADL and NDL, each based on the Gelfond-Lifschitz (GL) operator for logic\nprograms. For defeasible theories without defeaters or priorities on rules, the\noperator for ADL corresponds to the GL operator and so can be seen as partially\ncapturing the consequences according to ADL. Similarly, the operator for NDL\ncaptures the consequences according to NDL, though in this case no restrictions\non theories apply. Both operators can be used to define stable model semantics\nfor defeasible theories.\n", "versions": [{"version": "v1", "created": "Fri, 10 Jun 2011 05:20:17 GMT"}], "update_date": "2011-06-13", "authors_parsed": [["Maier", "Frederick", ""]]}, {"id": "1106.1978", "submitter": "Jun Pang", "authors": "Chenyi Zhang and Jun Pang", "title": "An Algorithm for Probabilistic Alternating Simulation", "comments": "We've fixed a problem in the SOFSEM'12 conference version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In probabilistic game structures, probabilistic alternating simulation\n(PA-simulation) relations preserve formulas defined in probabilistic\nalternating-time temporal logic with respect to the behaviour of a subset of\nplayers. We propose a partition based algorithm for computing the largest\nPA-simulation, which is to our knowledge the first such algorithm that works in\npolynomial time, by extending the generalised coarsest partition problem (GCPP)\nin a game-based setting with mixed strategies. The algorithm has higher\ncomplexities than those in the literature for non-probabilistic simulation and\nprobabilistic simulation without mixed actions, but slightly improves the\nexisting result for computing probabilistic simulation with respect to mixed\nactions.\n", "versions": [{"version": "v1", "created": "Fri, 10 Jun 2011 08:43:28 GMT"}, {"version": "v2", "created": "Thu, 30 Jun 2011 08:29:00 GMT"}, {"version": "v3", "created": "Fri, 8 Jun 2012 11:56:55 GMT"}], "update_date": "2015-03-19", "authors_parsed": [["Zhang", "Chenyi", ""], ["Pang", "Jun", ""]]}, {"id": "1106.2122", "submitter": "Praveen Manjunatha", "authors": "M. Praveen and Kamal Lodaya", "title": "Parameterized complexity results for 1-safe Petri nets", "comments": "Full version of the paper appearing in CONCUR 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC cs.DS cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We associate a graph with a 1-safe Petri net and study the parameterized\ncomplexity of various problems with parameters derived from the graph. With\ntreewidth as the parameter, we give W[1]-hardness results for many problems\nabout 1-safe Petri nets. As a corollary, this proves a conjecture of Downey et.\nal. about the hardness of some graph pebbling problems. We consider the\nparameter benefit depth (that is known to be helpful in getting better\nalgorithms for general Petri nets) and again give W[1]-hardness results for\nvarious problems on 1-safe Petri nets. We also consider the stronger parameter\nvertex cover number. Combining the well known automata-theoretic method and a\npowerful fixed parameter tractability (FPT) result about Integer Linear\nProgramming, we give a FPT algorithm for model checking Monadic Second Order\n(MSO) formulas on 1-safe Petri nets, with parameters vertex cover number and\nthe size of the formula.\n", "versions": [{"version": "v1", "created": "Fri, 10 Jun 2011 17:11:53 GMT"}], "update_date": "2011-06-13", "authors_parsed": [["Praveen", "M.", ""], ["Lodaya", "Kamal", ""]]}, {"id": "1106.2181", "submitter": "Lijun Zhang", "authors": "Lei Song (IT University of Copenhagen, Denmark), Lijun Zhang (DTU\n  Informatics, Technical University of Denmark), Jens Chr. Godskesen (IT\n  University of Copenhagen, Denmark), Flemming Nielson (DTU Compute, Technical\n  University of Denmark)", "title": "Bisimulations Meet PCTL Equivalences for Probabilistic Automata", "comments": "Long version of CONCUR'11 with the same title: added extension to\n  simulations, countable states", "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 2 (June 21,\n  2013) lmcs:1238", "doi": "10.2168/LMCS-9(2:7)2013", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Probabilistic automata (PAs) have been successfully applied in formal\nverification of concurrent and stochastic systems. Efficient model checking\nalgorithms have been studied, where the most often used logics for expressing\nproperties are based on probabilistic computation tree logic (PCTL) and its\nextension PCTL^*. Various behavioral equivalences are proposed, as a powerful\ntool for abstraction and compositional minimization for PAs. Unfortunately, the\nequivalences are well-known to be sound, but not complete with respect to the\nlogical equivalences induced by PCTL or PCTL*. The desire of a both sound and\ncomplete behavioral equivalence has been pointed out by Segala in 1995, but\nremains open throughout the years. In this paper we introduce novel notions of\nstrong bisimulation relations, which characterize PCTL and PCTL* exactly. We\nextend weak bisimulations that characterize PCTL and PCTL* without next\noperator, respectively. Further, we also extend the framework to simulation\npreorders. Thus, our paper bridges the gap between logical and behavioral\nequivalences and preorders in this setting.\n", "versions": [{"version": "v1", "created": "Fri, 10 Jun 2011 22:03:53 GMT"}, {"version": "v2", "created": "Fri, 13 Jan 2012 18:44:28 GMT"}, {"version": "v3", "created": "Tue, 9 Apr 2013 18:50:16 GMT"}, {"version": "v4", "created": "Wed, 19 Jun 2013 19:59:10 GMT"}, {"version": "v5", "created": "Fri, 21 Jun 2013 09:45:51 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Song", "Lei", "", "IT University of Copenhagen, Denmark"], ["Zhang", "Lijun", "", "DTU\n  Informatics, Technical University of Denmark"], ["Godskesen", "Jens Chr.", "", "IT\n  University of Copenhagen, Denmark"], ["Nielson", "Flemming", "", "DTU Compute, Technical\n  University of Denmark"]]}, {"id": "1106.2272", "submitter": "Wenyan Xu", "authors": "Wenyan Xu and Sanyang Liu", "title": "Soundness and completeness of the cirquent calculus system CL6 for\n  computability logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Computability logic is a formal theory of computability. The earlier article\n\"Introduction to cirquent calculus and abstract resource semantics\" by\nJaparidze proved soundness and completeness for the basic fragment CL5 of\ncomputability logic. The present article extends that result to the more\nexpressive cirquent calculus system CL6, which is a conservative extension of\nboth CL5 and classical propositional logic.\n", "versions": [{"version": "v1", "created": "Sun, 12 Jun 2011 02:20:53 GMT"}], "update_date": "2011-06-14", "authors_parsed": [["Xu", "Wenyan", ""], ["Liu", "Sanyang", ""]]}, {"id": "1106.2305", "submitter": "Linh Anh Nguyen D.Sc.", "authors": "Linh Anh Nguyen", "title": "Cut-Free ExpTime Tableaux for Checking Satisfiability of a Knowledge\n  Base in the Description Logic SHI", "comments": "a long version of the paper \"Linh Anh Nguyen. A Cut-Free ExpTime\n  Tableau Decision Procedure for the Description Logic SHI. In Proceedings of\n  ICCCI'2011, LNAI 6922, pages 572-581, Springer-Verlag, 2011\", 27 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give the first cut-free ExpTime (optimal) tableau decision procedure for\nchecking satisfiability of a knowledge base in the description logic SHI, which\nextends the description logic ALC with transitive roles, inverse roles and role\nhierarchies.\n", "versions": [{"version": "v1", "created": "Sun, 12 Jun 2011 12:07:18 GMT"}, {"version": "v2", "created": "Mon, 16 Jul 2012 11:58:10 GMT"}], "update_date": "2012-07-17", "authors_parsed": [["Nguyen", "Linh Anh", ""]]}, {"id": "1106.2320", "submitter": "Lucas Cordeiro Carvalho", "authors": "Raimundo Barreto, Lucas Cordeiro, Bernd Fischer", "title": "Verifying Embedded C Software with Timing Constraints using an Untimed\n  Model Checker", "comments": "16 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Embedded systems are everywhere, from home appliances to critical systems\nsuch as medical devices. They usually have associated timing constraints that\nneed to be verified for the implementation. Here, we use an untimed bounded\nmodel checker to verify timing properties of embedded C programs. We propose an\napproach to specify discrete time timing constraints using code annotations.\nThe annotated code is then automatically translated to code that manipulates\nauxiliary timer variables and is thus suitable as input to conventional,\nuntimed software model checker such as ESBMC. Thus, we can check timing\nconstraints in the same way and at the same time as untimed system\nrequirements, and even allow for interaction between them. We applied the\nproposed method in a case study, and verified timing constraints of a pulse\noximeter, a noninvasive medical device that measures the oxygen saturation of\narterial blood.\n", "versions": [{"version": "v1", "created": "Sun, 12 Jun 2011 15:54:28 GMT"}], "update_date": "2011-06-14", "authors_parsed": [["Barreto", "Raimundo", ""], ["Cordeiro", "Lucas", ""], ["Fischer", "Bernd", ""]]}, {"id": "1106.2352", "submitter": "Nicolaie Popescu-Bodorin", "authors": "Nicolaie Popescu-Bodorin, Luminita State", "title": "Cognitive Binary Logic - The Natural Unified Formal Theory of\n  Propositional Binary Logic", "comments": null, "journal-ref": "Recent Advances in Computational Intelligence, Proc. 4th\n  International Conference on Computational Intelligence, pp. 135-142, ISSN:\n  1790-5117, ISBN 978-960-474-179-3, WSEAS Press, April 2010", "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a formal theory which describes propositional binary\nlogic as a semantically closed formal language, and allows for syntactically\nand semantically well-formed formulae, formal proofs (demonstrability in\nHilbertian acception), deduction (Gentzen's view of demonstrability),\nCNF-ization, and deconstruction to be expressed and tested in the same\n(computational) formal language, using the same data structure. It is also\nshown here that Cognitive Binary Logic is a self-described theory in which the\nLiar Paradox is deconstructed.\n", "versions": [{"version": "v1", "created": "Sun, 12 Jun 2011 22:22:07 GMT"}], "update_date": "2011-06-21", "authors_parsed": [["Popescu-Bodorin", "Nicolaie", ""], ["State", "Luminita", ""]]}, {"id": "1106.2637", "submitter": "David Monniaux", "authors": "David Monniaux (VERIMAG - IMAG), Laure Gonnord (LIFL)", "title": "Using Bounded Model Checking to Focus Fixpoint Iterations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two classical sources of imprecision in static analysis by abstract\ninterpretation are widening and merge operations. Merge operations can be done\naway by distinguishing paths, as in trace partitioning, at the expense of\nenumerating an exponential number of paths. In this article, we describe how to\navoid such systematic exploration by focusing on a single path at a time,\ndesignated by SMT-solving. Our method combines well with acceleration\ntechniques, thus doing away with widenings as well in some cases. We illustrate\nit over the well-known domain of convex polyhedra.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2011 08:34:11 GMT"}], "update_date": "2011-06-15", "authors_parsed": [["Monniaux", "David", "", "VERIMAG - IMAG"], ["Gonnord", "Laure", "", "LIFL"]]}, {"id": "1106.2769", "submitter": "Zvonko Iljazovic", "authors": "Zvonko Iljazovic (University of Zagreb, Croatia)", "title": "Co-c.e. spheres and cells in computable metric spaces", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (August 25,\n  2011) lmcs:885", "doi": "10.2168/LMCS-7(3:5)2011", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate conditions under which a co-computably enumerable set in a\ncomputable metric space is computable. Using higher-dimensional chains and\nspherical chains we prove that in each computable metric space which is locally\ncomputable each co-computably enumerable sphere is computable and each co-c.e.\ncell with co-c.e. boundary sphere is computable.\n", "versions": [{"version": "v1", "created": "Tue, 14 Jun 2011 17:46:06 GMT"}, {"version": "v2", "created": "Tue, 23 Aug 2011 20:55:00 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Iljazovic", "Zvonko", "", "University of Zagreb, Croatia"]]}, {"id": "1106.2872", "submitter": "Yu Zhang", "authors": "Yuxin Deng, Yu Zhang", "title": "Program Equivalence in Linear Contexts", "comments": "Technical report, Laboratory for Computer Science, ISCAS", "journal-ref": null, "doi": null, "report-no": "ISCAS-SKLCS-11-04", "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Program equivalence in linear contexts, where programs are used or executed\nexactly once, is an important issue in programming languages. However, existing\ntechniques like those based on bisimulations and logical relations only target\nat contextual equivalence in the usual (non-linear) functional languages, and\nfail in capturing non-trivial equivalent programs in linear contexts,\nparticularly when non-determinism is present. We propose the notion of linear\ncontextual equivalence to formally characterize such program equivalence, as\nwell as a novel and general approach to studying it in higher-order languages,\nbased on labeled transition systems specifically designed for functional\nlanguages. We show that linear contextual equivalence indeed coincides with\ntrace equivalence - it is sound and complete. We illustrate our technique in\nboth deterministic (a linear version of PCF) and non-deterministic (linear PCF\nin Moggi's framework) functional languages.\n", "versions": [{"version": "v1", "created": "Wed, 15 Jun 2011 04:48:17 GMT"}, {"version": "v2", "created": "Tue, 11 Oct 2011 05:15:38 GMT"}], "update_date": "2011-10-12", "authors_parsed": [["Deng", "Yuxin", ""], ["Zhang", "Yu", ""]]}, {"id": "1106.2993", "submitter": "Douglas Cenzer", "authors": "Douglas Cenzer (University of Florida), Paul Brodhead (Indian River\n  State College), Ferit Toska (University of Florida), Sebastian Wyman\n  (University of Florida)", "title": "Algorithmic Randomness and Capacity of Closed Sets", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (September\n  23, 2011) lmcs:1020", "doi": "10.2168/LMCS-7(3:16)2011", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the connection between measure, capacity and algorithmic\nrandomness for the space of closed sets. For any computable measure m, a\ncomputable capacity T may be defined by letting T(Q) be the measure of the\nfamily of closed sets K which have nonempty intersection with Q. We prove an\neffective version of Choquet's capacity theorem by showing that every\ncomputable capacity may be obtained from a computable measure in this way. We\nestablish conditions on the measure m that characterize when the capacity of an\nm-random closed set equals zero. This includes new results in classical\nprobability theory as well as results for algorithmic randomness. For certain\ncomputable measures, we construct effectively closed sets with positive\ncapacity and with Lebesgue measure zero. We show that for computable measures,\na real q is upper semi-computable if and only if there is an effectively closed\nset with capacity q.\n", "versions": [{"version": "v1", "created": "Wed, 15 Jun 2011 15:19:01 GMT"}, {"version": "v2", "created": "Thu, 22 Sep 2011 10:59:00 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Cenzer", "Douglas", "", "University of Florida"], ["Brodhead", "Paul", "", "Indian River\n  State College"], ["Toska", "Ferit", "", "University of Florida"], ["Wyman", "Sebastian", "", "University of Florida"]]}, {"id": "1106.3054", "submitter": "Yaron Velner", "authors": "Yaron Velner", "title": "The Complexity of Mean-Payoff Automaton Expression", "comments": "arXiv admin note: text overlap with arXiv:1006.1492", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  \"Quantitative languages are extension of boolean languages that assign to\neach word a real number. Mean-payoff automata are finite automata with\nnumerical weights on transitions that assign to each infinite path the long-run\naverage of the transition weights. The class of \\emph{mean-payoff automaton\nexpressions}, introduced in [1], is a class of quantitative languages, which is\nrobust: it is closed under the four pointwise operations of max, min, sum and\nnumerical complement.\"[1] In this paper we improve the computational complexity\nfor solving the classical decision problems for mean-payoff automaton\nexpressions: while the previously best known upper bound was 4EXPTIME, and no\nlower bound was known, we give an optimal PSPACE complete bound. As a\nconsequence we also obtain a conceptually simple algorithm to solve the\nclassical decision problems for mean-payoff automaton expressions.\n", "versions": [{"version": "v1", "created": "Wed, 15 Jun 2011 18:58:56 GMT"}, {"version": "v2", "created": "Tue, 8 May 2012 10:32:32 GMT"}], "update_date": "2012-05-20", "authors_parsed": [["Velner", "Yaron", ""]]}, {"id": "1106.3448", "submitter": "J\\\"urgen Koslowski", "authors": "Robbert Krebbers and Bas Spitters", "title": "Type classes for efficient exact real arithmetic in Coq", "comments": "arXiv admin note: text overlap with arXiv:1105.2751", "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 1 (February\n  14, 2013) lmcs:958", "doi": "10.2168/LMCS-9(1:1)2013", "report-no": null, "categories": "cs.LO math.NA", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  Floating point operations are fast, but require continuous effort on the part\nof the user in order to ensure that the results are correct. This burden can be\nshifted away from the user by providing a library of exact analysis in which\nthe computer handles the error estimates. Previously, we [Krebbers/Spitters\n2011] provided a fast implementation of the exact real numbers in the Coq proof\nassistant. Our implementation improved on an earlier implementation by O'Connor\nby using type classes to describe an abstract specification of the underlying\ndense set from which the real numbers are built. In particular, we used dyadic\nrationals built from Coq's machine integers to obtain a 100 times speed up of\nthe basic operations already. This article is a substantially expanded version\nof [Krebbers/Spitters 2011] in which the implementation is extended in the\nvarious ways. First, we implement and verify the sine and cosine function.\nSecondly, we create an additional implementation of the dense set based on\nCoq's fast rational numbers. Thirdly, we extend the hierarchy to capture order\non undecidable structures, while it was limited to decidable structures before.\nThis hierarchy, based on type classes, allows us to share theory on the\nnaturals, integers, rationals, dyadics, and reals in a convenient way. Finally,\nwe obtain another dramatic speed-up by avoiding evaluation of termination\nproofs at runtime.\n", "versions": [{"version": "v1", "created": "Fri, 17 Jun 2011 11:20:20 GMT"}, {"version": "v2", "created": "Sat, 1 Dec 2012 15:24:43 GMT"}, {"version": "v3", "created": "Wed, 13 Feb 2013 15:06:05 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Krebbers", "Robbert", ""], ["Spitters", "Bas", ""]]}, {"id": "1106.3457", "submitter": "Panos Rondogiannis", "authors": "A. Charalambidis, K. Handjopoulos, P. Rondogiannis, W. W. Wadge", "title": "Extensional Higher-Order Logic Programming", "comments": "45 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a purely extensional semantics for higher-order logic programming.\nIn this semantics program predicates denote sets of ordered tuples, and two\npredicates are equal iff they are equal as sets. Moreover, every program has a\nunique minimum Herbrand model which is the greatest lower bound of all Herbrand\nmodels of the program and the least fixed-point of an immediate consequence\noperator. We also propose an SLD-resolution proof procedure which is proven\nsound and complete with respect to the minimum model semantics. In other words,\nwe provide a purely extensional theoretical framework for higher-order logic\nprogramming which generalizes the familiar theory of classical (first-order)\nlogic programming.\n", "versions": [{"version": "v1", "created": "Fri, 17 Jun 2011 12:01:01 GMT"}], "update_date": "2011-06-20", "authors_parsed": [["Charalambidis", "A.", ""], ["Handjopoulos", "K.", ""], ["Rondogiannis", "P.", ""], ["Wadge", "W. W.", ""]]}, {"id": "1106.3488", "submitter": "EPTCS", "authors": "John Derrick (University of Sheffield), Eerke Boiten (University of\n  Kent), Steve Reeves (University of Waikato)", "title": "Proceedings 15th International Refinement Workshop", "comments": null, "journal-ref": "EPTCS 55, 2011", "doi": "10.4204/EPTCS.55", "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Refinement is one of the cornerstones of a formal approach to software\nengineering: the process of developing a more detailed design or implementation\nfrom an abstract specification through a sequence of mathematically-based steps\nthat maintain correctness with respect to the original specification.\n  The aim of this BCS FACS Refinement Workshop, is to bring together people who\nare interested in the development of more concrete designs or executable\nprograms from abstract specifications using formal notations, tool support for\nformal software development, and practical experience with formal refinement\nmethodologies.\n  The purpose of the workshop is to provide a forum for the exchange of ideas,\nand discussion of common ground and key differences.\n  This 15th workshop continued a 20 year tradition in refinement workshops run\nunder the auspices of the British Computer Society (BCS) FACS special interest\ngroup. After the first seven editions had been held in the UK, in 1998 it was\ncombined with the Australasian Refinement Workshop to form the International\nRefinement Workshop, hosted at The Australian National University. Six more\neditions have followed in a variety of locations, all with electronic published\nproceedings and associated journal special issues.\n", "versions": [{"version": "v1", "created": "Fri, 17 Jun 2011 14:04:19 GMT"}], "update_date": "2011-06-20", "authors_parsed": [["Derrick", "John", "", "University of Sheffield"], ["Boiten", "Eerke", "", "University of\n  Kent"], ["Reeves", "Steve", "", "University of Waikato"]]}, {"id": "1106.3684", "submitter": "Nicolaie Popescu-Bodorin", "authors": "Nicolaie Popescu-Bodorin, Valentina E. Balas", "title": "Exploratory simulation of an Intelligent Iris Verifier Distributed\n  System", "comments": "4 pages, 2 figures, latest version: http://fmi.spiruharet.ro/bodorin/", "journal-ref": "Proc. 6th IEEE International Symposium on Applied Computational\n  Intelligence and Informatics, pp. 259 - 262, IEEE Press, June 2011", "doi": "10.1109/SACI.2011.5873010", "report-no": null, "categories": "cs.CV cs.ET cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper discusses some topics related to the latest trends in the field of\nevolutionary approaches to iris recognition. It presents the results of an\nexploratory experimental simulation whose goal was to analyze the possibility\nof establishing an Interchange Protocol for Digital Identities evolved in\ndifferent geographic locations interconnected through and into an Intelligent\nIris Verifier Distributed System (IIVDS) based on multi-enrollment. Finding a\nlogically consistent model for the Interchange Protocol is the key factor in\ndesigning the future large-scale iris biometric networks. Therefore, the\nlogical model of such a protocol is also investigated here. All tests are made\non Bath Iris Database and prove that outstanding power of discrimination\nbetween the intra- and the inter-class comparisons can be achieved by an IIVDS,\neven when practicing 52.759.182 inter-class and 10.991.943 intra-class\ncomparisons. Still, the test results confirm that inconsistent enrollment can\nchange the logic of recognition from a fuzzified 2-valent consistent logic of\nbiometric certitudes to a fuzzified 3-valent inconsistent possibilistic logic\nof biometric beliefs justified through experimentally determined probabilities,\nor to a fuzzified 8-valent logic which is almost consistent as a biometric\ntheory - this quality being counterbalanced by an absolutely reasonable loss in\nthe user comfort level.\n", "versions": [{"version": "v1", "created": "Sat, 18 Jun 2011 20:16:10 GMT"}], "update_date": "2011-06-21", "authors_parsed": [["Popescu-Bodorin", "Nicolaie", ""], ["Balas", "Valentina E.", ""]]}, {"id": "1106.3685", "submitter": "Christoph Benzmueller", "authors": "Christoph Benzmueller and Dov Gabbay and Valerio Genovese and Daniele\n  Rispoli", "title": "Embedding and Automating Conditional Logics in Classical Higher-Order\n  Logic", "comments": "15 pages, 1 Figure, 1 Table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A sound and complete embedding of conditional logics into classical\nhigher-order logic is presented. This embedding enables the application of\noff-the-shelf higher-order automated theorem provers and model finders for\nreasoning within and about conditional logics.\n", "versions": [{"version": "v1", "created": "Sat, 18 Jun 2011 20:20:37 GMT"}, {"version": "v2", "created": "Fri, 24 Jun 2011 04:15:11 GMT"}, {"version": "v3", "created": "Wed, 17 Aug 2011 08:03:50 GMT"}], "update_date": "2011-08-18", "authors_parsed": [["Benzmueller", "Christoph", ""], ["Gabbay", "Dov", ""], ["Genovese", "Valerio", ""], ["Rispoli", "Daniele", ""]]}, {"id": "1106.3705", "submitter": "Giorgi Japaridze", "authors": "Giorgi Japaridze", "title": "The taming of recurrences in computability logic through cirquent\n  calculus, Part II", "comments": null, "journal-ref": "Archive for Mathematical Logic 52 (2013), pp. 213-259", "doi": "10.1007/s00153-012-0314-7", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper constructs a cirquent calculus system and proves its soundness and\ncompleteness with respect to the semantics of computability logic (see\nhttp://www.cis.upenn.edu/~giorgi/cl.html). The logical vocabulary of the system\nconsists of negation, parallel conjunction, parallel disjunction, branching\nrecurrence, and branching corecurrence. The article is published in two parts,\nwith (the previous) Part I containing preliminaries and a soundness proof, and\n(the present) Part II containing a completeness proof.\n", "versions": [{"version": "v1", "created": "Sun, 19 Jun 2011 04:34:11 GMT"}], "update_date": "2013-02-05", "authors_parsed": [["Japaridze", "Giorgi", ""]]}, {"id": "1106.3767", "submitter": "Georg Gottlob", "authors": "Georg Gottlob and Thomas Schwentick", "title": "Rewriting Ontological Queries into Small Nonrecursive Datalog Programs", "comments": "A shorter version is presented at the 24th International Workshop on\n  Description Logics, DL 2011, Barcelona, Spain, July 13-16, 2011. The present\n  version mainly extends the proof of Theorem 1 in Section 3. We plan to post\n  further extended versions of this paper in the near future", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.DB cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the setting of ontological database access, where an Abox is\ngiven in form of a relational database D and where a Boolean conjunctive query\nq has to be evaluated against D modulo a Tbox T formulated in DL-Lite or Linear\nDatalog+/-. It is well-known that (T,q) can be rewritten into an equivalent\nnonrecursive Datalog program P that can be directly evaluated over D. However,\nfor Linear Datalog? or for DL-Lite versions that allow for role inclusion, the\nrewriting methods described so far result in a nonrecursive Datalog program P\nof size exponential in the joint size of T and q. This gives rise to the\ninteresting question of whether such a rewriting necessarily needs to be of\nexponential size. In this paper we show that it is actually possible to\ntranslate (T,q) into a polynomially sized equivalent nonrecursive Datalog\nprogram P.\n", "versions": [{"version": "v1", "created": "Sun, 19 Jun 2011 18:20:07 GMT"}, {"version": "v2", "created": "Sun, 10 Jul 2011 18:26:56 GMT"}, {"version": "v3", "created": "Sat, 23 Jul 2011 10:19:21 GMT"}], "update_date": "2011-07-26", "authors_parsed": [["Gottlob", "Georg", ""], ["Schwentick", "Thomas", ""]]}, {"id": "1106.4063", "submitter": "Mingsheng Ying", "authors": "Mingsheng Ying, Nengkun Yu, Yuan Feng, and Runyao Duan", "title": "Verification of Quantum Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper develops verification methodology for quantum programs, and the\ncontribution of the paper is two-fold: 1. Sharir, Pnueli and Hart [SIAM J.\nComput. 13(1984)292-314] presented a general method for proving properties of\nprobabilistic programs, in which a probabilistic program is modeled by a Markov\nchain and an assertion on the output distribution is extended into an invariant\nassertion on all intermediate distributions. Their method is essentially a\nprobabilistic generalization of the classical Floyd inductive assertion method.\nIn this paper, we consider quantum programs modeled by quantum Markov chains\nwhich are defined by super-operators. It is shown that the Sharir-Pnueli-Hart\nmethod can be elegantly generalized to quantum programs by exploiting the\nSchr\\\"odinger-Heisenberg duality between quantum states and observables. In\nparticular, a completeness theorem for the Sharir-Pnueli-Hart verification\nmethod of quantum programs is established. 2. As indicated by the completeness\ntheorem, the Sharir-Pnueli-Hart method is in principle effective for verifying\nall properties of quantum programs that can be expressed in terms of Hermitian\noperators (observables). But it is not feasible for many practical applications\nbecause of the complicated calculation involved in the verification. For the\ncase of finite-dimensional state spaces, we find a method for verification of\nquantum programs much simpler than the Sharir-Pnueli-Hart method by employing\nthe matrix representation of super-operators and Jordan decomposition of\nmatrices. In particular, this method enables us to compute easily the average\nrunning time and even to analyze some interesting long-run behaviors of quantum\nprograms in a finite-dimensional state space.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 00:35:24 GMT"}], "update_date": "2011-06-22", "authors_parsed": [["Ying", "Mingsheng", ""], ["Yu", "Nengkun", ""], ["Feng", "Yuan", ""], ["Duan", "Runyao", ""]]}, {"id": "1106.4090", "submitter": "EPTCS", "authors": "Maria Teresa Llano (Heriot-Watt University), Andrew Ireland\n  (Heriot-Watt University), Alison Pease (University of Edinburgh)", "title": "Discovery of Invariants through Automated Theory Formation", "comments": "In Proceedings Refine 2011, arXiv:1106.3488", "journal-ref": "EPTCS 55, 2011, pp. 1-19", "doi": "10.4204/EPTCS.55.1", "report-no": null, "categories": "cs.LO cs.AI cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Refinement is a powerful mechanism for mastering the complexities that arise\nwhen formally modelling systems. Refinement also brings with it additional\nproof obligations -- requiring a developer to discover properties relating to\ntheir design decisions. With the goal of reducing this burden, we have\ninvestigated how a general purpose theory formation tool, HR, can be used to\nautomate the discovery of such properties within the context of Event-B. Here\nwe develop a heuristic approach to the automatic discovery of invariants and\nreport upon a series of experiments that we undertook in order to evaluate our\napproach. The set of heuristics developed provides systematic guidance in\ntailoring HR for a given Event-B development. These heuristics are based upon\nproof-failure analysis, and have given rise to some promising results.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 05:24:01 GMT"}], "update_date": "2011-06-22", "authors_parsed": [["Llano", "Maria Teresa", "", "Heriot-Watt University"], ["Ireland", "Andrew", "", "Heriot-Watt University"], ["Pease", "Alison", "", "University of Edinburgh"]]}, {"id": "1106.4092", "submitter": "EPTCS", "authors": "John Derrick, Siobh\\'an North, Anthony J.H. Simons", "title": "Building a refinement checker for Z", "comments": "In Proceedings Refine 2011, arXiv:1106.3488", "journal-ref": "EPTCS 55, 2011, pp. 37-52", "doi": "10.4204/EPTCS.55.3", "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In previous work we have described how refinements can be checked using a\ntemporal logic based model-checker, and how we have built a model-checker for Z\nby providing a translation of Z into the SAL input language. In this paper we\ndraw these two strands of work together and discuss how we have implemented\nrefinement checking in our Z2SAL toolset.\n  The net effect of this work is that the SAL toolset can be used to check\nrefinements between Z specifications supplied as input files written in the\nLaTeX mark-up. Two examples are used to illustrate the approach and compare it\nwith a manual translation and refinement check.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 05:24:24 GMT"}], "update_date": "2011-06-22", "authors_parsed": [["Derrick", "John", ""], ["North", "Siobh\u00e1n", ""], ["Simons", "Anthony J. H.", ""]]}, {"id": "1106.4093", "submitter": "EPTCS", "authors": "C\\'esar Rodrigues (DI-CCTC, Minho University), Manuel A. Martins (Dep.\n  Mathematics, Aveiro University), Alexandre Madeira (DI-CCTC, Minho\n  University, Dep. Mathematics, Aveiro University and Critical Software, SA),\n  Luis S. Barbosa (DI-CCTC, Minho University)", "title": "Refinement by interpretation in {\\pi}-institutions", "comments": "In Proceedings Refine 2011, arXiv:1106.3488", "journal-ref": "EPTCS 55, 2011, pp. 53-64", "doi": "10.4204/EPTCS.55.4", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper discusses the role of interpretations, understood as multifunctions\nthat preserve and reflect logical consequence, as refinement witnesses in the\ngeneral setting of pi-institutions. This leads to a smooth generalization of\nthe refinement-by-interpretation approach, recently introduced by the authors\nin more specific contexts. As a second, yet related contribution a basis is\nprovided to build up a refinement calculus of structured specifications in and\nacross arbitrary pi-institutions.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 05:24:40 GMT"}], "update_date": "2019-08-15", "authors_parsed": [["Rodrigues", "C\u00e9sar", "", "DI-CCTC, Minho University"], ["Martins", "Manuel A.", "", "Dep.\n  Mathematics, Aveiro University"], ["Madeira", "Alexandre", "", "DI-CCTC, Minho\n  University, Dep. Mathematics, Aveiro University and Critical Software, SA"], ["Barbosa", "Luis S.", "", "DI-CCTC, Minho University"]]}, {"id": "1106.4094", "submitter": "EPTCS", "authors": "Alvaro Miyazawa (University of York), Ana Cavalcanti (University of\n  York)", "title": "Refinement-based verification of sequential implementations of Stateflow\n  charts", "comments": "In Proceedings Refine 2011, arXiv:1106.3488", "journal-ref": "EPTCS 55, 2011, pp. 65-83", "doi": "10.4204/EPTCS.55.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Simulink/Stateflow charts are widely used in industry for the specification\nof control systems, which are often safety-critical. This suggests a need for a\nformal treatment of such models. In previous work, we have proposed a technique\nfor automatic generation of formal models of Stateflow blocks to support\nrefinement-based reasoning. In this article, we present a refinement strategy\nthat supports the verification of automatically generated sequential C\nimplementations of Stateflow charts. In particular, we discuss how this\nstrategy can be specialised to take advantage of architectural features in\norder to allow a higher level of automation.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 05:24:48 GMT"}], "update_date": "2011-06-22", "authors_parsed": [["Miyazawa", "Alvaro", "", "University of York"], ["Cavalcanti", "Ana", "", "University of\n  York"]]}, {"id": "1106.4096", "submitter": "EPTCS", "authors": "Ukachukwu Ndukwu (Macquarie University, Australia), Annabelle McIver\n  (Macquarie University, Australia)", "title": "Model exploration and analysis for quantitative safety refinement in\n  probabilistic B", "comments": "In Proceedings Refine 2011, arXiv:1106.3488", "journal-ref": "EPTCS 55, 2011, pp. 101-120", "doi": "10.4204/EPTCS.55.7", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The role played by counterexamples in standard system analysis is well known;\nbut less common is a notion of counterexample in probabilistic systems\nrefinement. In this paper we extend previous work using counterexamples to\ninductive invariant properties of probabilistic systems, demonstrating how they\ncan be used to extend the technique of bounded model checking-style analysis\nfor the refinement of quantitative safety specifications in the probabilistic B\nlanguage. In particular, we show how the method can be adapted to cope with\nrefinements incorporating probabilistic loops. Finally, we demonstrate the\ntechnique on pB models summarising a one-step refinement of a randomised\nalgorithm for finding the minimum cut of undirected graphs, and that for the\ndependability analysis of a controller design.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 05:25:05 GMT"}], "update_date": "2011-06-22", "authors_parsed": [["Ndukwu", "Ukachukwu", "", "Macquarie University, Australia"], ["McIver", "Annabelle", "", "Macquarie University, Australia"]]}, {"id": "1106.4098", "submitter": "EPTCS", "authors": "Steve Schneider (University of Surrey), Helen Treharne (University of\n  Surrey), Heike Wehrheim (University of Paderborn)", "title": "A CSP Account of Event-B Refinement", "comments": "In Proceedings Refine 2011, arXiv:1106.3488", "journal-ref": "EPTCS 55, 2011, pp. 139-154", "doi": "10.4204/EPTCS.55.9", "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Event-B provides a flexible framework for stepwise system development via\nrefinement. The framework supports steps for (a) refining events (one-by-one),\n(b) splitting events (one-by-many), and (c) introducing new events. In each of\nthe steps events can moreover possibly be anticipated or convergent. All such\nsteps are accompanied with precise proof obligations. Still, it remains unclear\nwhat the exact relationship - in terms of a behaviour-oriented semantics -\nbetween an Event-B machine and its refinement is. In this paper, we give a CSP\naccount of Event-B refinement, with a treatment for the first time of splitting\nevents and of anticipated events. To this end, we define a CSP semantics for\nEvent-B and show how the different forms of Event-B refinement can be captured\nas CSP refinement.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 05:25:17 GMT"}], "update_date": "2011-06-22", "authors_parsed": [["Schneider", "Steve", "", "University of Surrey"], ["Treharne", "Helen", "", "University of\n  Surrey"], ["Wehrheim", "Heike", "", "University of Paderborn"]]}, {"id": "1106.4100", "submitter": "EPTCS", "authors": "Pontus Bostr\\\"om, Fredrik Degerlund, Kaisa Sere, Marina Wald\\'en", "title": "Concurrent Scheduling of Event-B Models", "comments": "In Proceedings Refine 2011, arXiv:1106.3488", "journal-ref": "EPTCS 55, 2011, pp. 166-182", "doi": "10.4204/EPTCS.55.11", "report-no": null, "categories": "cs.LO cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Event-B is a refinement-based formal method that has been shown to be useful\nin developing concurrent and distributed programs. Large models can be\ndecomposed into sub-models that can be refined semi-independently and executed\nin parallel. In this paper, we show how to introduce explicit control flow for\nthe concurrent sub-models in the form of event schedules. We explore how\nschedules can be designed so that their application results in a\ncorrectness-preserving refinement step. For practical application, two patterns\nfor schedule introduction are provided, together with their associated proof\nobligations. We demonstrate our method by applying it on the dining\nphilosophers problem.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 05:25:34 GMT"}], "update_date": "2011-06-22", "authors_parsed": [["Bostr\u00f6m", "Pontus", ""], ["Degerlund", "Fredrik", ""], ["Sere", "Kaisa", ""], ["Wald\u00e9n", "Marina", ""]]}, {"id": "1106.4102", "submitter": "Shrinivaasan Ka", "authors": "Ka.Shrinivaasan", "title": "Decidability of Existence and Construction of a Complement of a given\n  Function", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article defines a complement of a function and conditions for existence\nof such a complement function and presents few algorithms to construct a\ncomplement.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 05:36:42 GMT"}], "update_date": "2014-07-31", "authors_parsed": [["Shrinivaasan", "Ka.", ""]]}, {"id": "1106.4142", "submitter": "Dai Tri Man Le", "authors": "Stephen A. Cook, Dai Tri Man Le, Yuli Ye", "title": "Complexity Classes and Theories for the Comparator Circuit Value Problem", "comments": "This version was substantially rewritten, where several proofs were\n  rewritten and many typos and mistakes were fixed. A shorter version of this\n  paper appeared in CSL 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Subramanian defined the complexity class CC as the set of problems log-space\nreducible to the comparator circuit value problem. He proved that several other\nproblems are complete for CC, including the stable marriage problem, and\nfinding the lexicographical first maximal matching in a bipartite graph. We\nsuggest alternative definitions of CC based on different reducibilities and\nintroduce a two-sorted theory VCC* based on one of them. We sharpen and\nsimplify Subramanian's completeness proofs for the above two problems and\nformalize them in VCC*.\n", "versions": [{"version": "v1", "created": "Tue, 21 Jun 2011 09:15:01 GMT"}, {"version": "v2", "created": "Tue, 4 Oct 2011 23:51:45 GMT"}], "update_date": "2011-10-06", "authors_parsed": [["Cook", "Stephen A.", ""], ["Le", "Dai Tri Man", ""], ["Ye", "Yuli", ""]]}, {"id": "1106.4448", "submitter": "Damien Pous", "authors": "Thomas Braibant (LIG), Damien Pous (LIG)", "title": "Tactics for Reasoning modulo AC in Coq", "comments": "16p", "journal-ref": "Certified Proofs and Programs, Ta\\\"iwan, Province De Chine (2011)", "doi": "10.1007/978-3-642-25379-9_14", "report-no": null, "categories": "cs.MS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a set of tools for rewriting modulo associativity and\ncommutativity (AC) in Coq, solving a long-standing practical problem. We use\ntwo building blocks: first, an extensible reflexive decision procedure for\nequality modulo AC; second, an OCaml plug-in for pattern matching modulo AC. We\nhandle associative only operations, neutral elements, uninterpreted function\nsymbols, and user-defined equivalence relations. By relying on type-classes for\nthe reification phase, we can infer these properties automatically, so that\nend-users do not need to specify which operation is A or AC, or which constant\nis a neutral element.\n", "versions": [{"version": "v1", "created": "Wed, 22 Jun 2011 13:58:58 GMT"}, {"version": "v2", "created": "Thu, 22 Sep 2011 12:47:56 GMT"}], "update_date": "2013-03-08", "authors_parsed": [["Braibant", "Thomas", "", "LIG"], ["Pous", "Damien", "", "LIG"]]}, {"id": "1106.4606", "submitter": "Prabhu Manyem", "authors": "Prabhu Manyem", "title": "Expressibility at the machine level versus structure level: ESO\n  universal Horn Logic and the class P", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that ESO universal Horn logic (existential second logic where the\nfirst order part is a universal Horn formula) is insufficient to capture P, the\nclass of problems decidable in polynomial time. This statement is true in the\npresence of a successor relation in the input vocabulary. We provide two proofs\n--- one based on reduced products of two structures, and another based on\napproximability theory (the second proof is under the assumption that P is not\nthe same as NP). We show that the difference between the results here and those\nin Gr\\\"{a}del (1991), is due to the fact that the expressions this paper deals\nwith are at the \"structure level\", whereas the expressions in Gr\\\"{a}del (1991)\nare at the \"machine level\" --- a case of Easier done than said.\n", "versions": [{"version": "v1", "created": "Thu, 23 Jun 2011 01:55:56 GMT"}, {"version": "v2", "created": "Wed, 19 Oct 2011 12:53:31 GMT"}, {"version": "v3", "created": "Fri, 18 Nov 2011 10:13:10 GMT"}, {"version": "v4", "created": "Mon, 9 Jan 2012 04:55:50 GMT"}, {"version": "v5", "created": "Mon, 23 Jul 2012 07:55:27 GMT"}], "update_date": "2012-07-24", "authors_parsed": [["Manyem", "Prabhu", ""]]}, {"id": "1106.5128", "submitter": "Adrian Francalanza", "authors": "Adrian Francalanza (University of Malta), Julian Rathke (Southampton\n  University), Vladimiro Sassone (Southampton University)", "title": "Permission-Based Separation Logic for Message-Passing Concurrency", "comments": "47 pages", "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 3 (September\n  1, 2011) lmcs:772", "doi": "10.2168/LMCS-7(3:7)2011", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop local reasoning techniques for message passing concurrent programs\nbased on ideas from separation logics and resource usage analysis. We extend\nprocesses with permission- resources and define a reduction semantics for this\nextended language. This provides a foundation for interpreting separation\nformulas for message-passing concurrency. We also define a sound proof system\npermitting us to infer satisfaction compositionally using local,\nseparation-based reasoning.\n", "versions": [{"version": "v1", "created": "Sat, 25 Jun 2011 13:41:16 GMT"}, {"version": "v2", "created": "Wed, 31 Aug 2011 07:03:36 GMT"}, {"version": "v3", "created": "Thu, 1 Sep 2011 07:27:15 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Francalanza", "Adrian", "", "University of Malta"], ["Rathke", "Julian", "", "Southampton\n  University"], ["Sassone", "Vladimiro", "", "Southampton University"]]}, {"id": "1106.5294", "submitter": "Yohji Akama", "authors": "Yohji Akama", "title": "Set systems: order types, continuous nondeterministic deformations, and\n  quasi-orders", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.GT cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  By reformulating a learning process of a set system L as a game between\nTeacher and Learner, we define the order type of L to be the order type of the\ngame tree, if the tree is well-founded. The features of the order type of L\n(dim L in symbol) are (1) We can represent any well-quasi-order (wqo for short)\nby the set system L of the upper-closed sets of the wqo such that the maximal\norder type of the wqo is equal to dim L. (2) dim L is an upper bound of the\nmind-change complexity of L. dim L is defined iff L has a finite elasticity (fe\nfor short), where, according to computational learning theory, if an indexed\nfamily of recursive languages has fe then it is learnable by an algorithm from\npositive data. Regarding set systems as subspaces of Cantor spaces, we prove\nthat fe of set systems is preserved by any continuous function which is\nmonotone with respect to the set-inclusion. By it, we prove that finite\nelasticity is preserved by various (nondeterministic) language operators\n(Kleene-closure, shuffle-closure, union, product, intersection,. . ..) The\nmonotone continuous functions represent nondeterministic computations. If a\nmonotone continuous function has a computation tree with each node followed by\nat most n immediate successors and the order type of a set system L is\n{\\alpha}, then the direct image of L is a set system of order type at most\nn-adic diagonal Ramsey number of {\\alpha}. Furthermore, we provide an\norder-type-preserving contravariant embedding from the category of quasi-orders\nand finitely branching simulations between them, into the complete category of\nsubspaces of Cantor spaces and monotone continuous functions having Girard's\nlinearity between them. Keyword: finite elasticity, shuffle-closure\n", "versions": [{"version": "v1", "created": "Mon, 27 Jun 2011 04:55:23 GMT"}], "update_date": "2011-06-28", "authors_parsed": [["Akama", "Yohji", ""]]}, {"id": "1106.5470", "submitter": "Koji Kobayashi", "authors": "Koji Kobayashi", "title": "Connection and Dispersion of Computation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper talk about the influence of Connection and Dispersion on\nComputational Complexity. And talk about the HornCNF's connection and CNF's\ndispersion, and show the difference between CNFSAT and HornSAT. First, I talk\nthe relation between MUC decision problem and classifying the truth value\nassignment. Second, I define the two inner products (\"inner product\" and \"inner\nharmony\") and talk about the influence of orthogonal and correlation to MUC.\nAnd we can not reduce MUC to Orthogonalization MUC by using HornMUC in\npolynomial size because HornMUC have high orthogonal of inner harmony and MUC\ndo not. So DP is not P, and NP is not P.\n", "versions": [{"version": "v1", "created": "Mon, 27 Jun 2011 18:36:14 GMT"}, {"version": "v2", "created": "Tue, 28 Jun 2011 17:24:05 GMT"}, {"version": "v3", "created": "Tue, 5 Jul 2011 17:07:49 GMT"}, {"version": "v4", "created": "Mon, 18 Jul 2011 06:10:49 GMT"}, {"version": "v5", "created": "Tue, 2 Aug 2011 17:20:07 GMT"}, {"version": "v6", "created": "Wed, 3 Aug 2011 17:42:11 GMT"}, {"version": "v7", "created": "Thu, 4 Aug 2011 18:16:22 GMT"}, {"version": "v8", "created": "Mon, 8 Aug 2011 18:07:58 GMT"}, {"version": "v9", "created": "Tue, 9 Aug 2011 18:15:18 GMT"}], "update_date": "2011-08-10", "authors_parsed": [["Kobayashi", "Koji", ""]]}, {"id": "1106.5622", "submitter": "Luca Roversi", "authors": "Emanuele Cesena and Marco Pedicini and Luca Roversi", "title": "Typing a Core Binary Field Arithmetic in a Light Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We design a library for binary field arithmetic and we supply a core API\nwhich is completely developed in DLAL, extended with a fix point formula. Since\nDLAL is a restriction of linear logic where only functional programs with\npolynomial evaluation cost can be typed, we obtain the core of a functional\nprogramming setting for binary field arithmetic with built-in polynomial\ncomplexity.\n", "versions": [{"version": "v1", "created": "Tue, 28 Jun 2011 10:39:42 GMT"}], "update_date": "2011-06-29", "authors_parsed": [["Cesena", "Emanuele", ""], ["Pedicini", "Marco", ""], ["Roversi", "Luca", ""]]}, {"id": "1106.5700", "submitter": "Denis Poitrenaud", "authors": "Alexandre Duret-Lutz and Kais Klai and Denis Poitrenaud and Yann\n  Thierry-Mieg", "title": "Combining Explicit and Symbolic Approaches for Better On-the-Fly LTL\n  Model Checking", "comments": "Extended version of the paper titled \"Self-loop aggregation product -\n  a new hybrid approach to on-the-fly LTL model checking\" to appear in\n  Proceedings of the 9th International Symposium on Automated Technology for\n  Verification and Analysis (ATVA'11), Lecture Notes in Computer Science,\n  Taipei, Taiwan, October 2011. Springer", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present two new hybrid techniques that replace the synchronized product\nused in the automata-theoretic approach for LTL model checking. The proposed\nproducts are explicit graphs of aggregates (symbolic sets of states) that can\nbe interpreted as B\\\"uchi automata. These hybrid approaches allow on the one\nhand to use classical emptiness-check algorithms and build the graph\non-the-fly, and on the other hand, to have a compact encoding of the state\nspace thanks to the symbolic representation of the aggregates. The Symbolic\nObservation Product assumes a globally stuttering property (e.g., LTL \\ X) to\naggregate states. The Self-Loop Aggregation Product} does not require the\nproperty to be globally stuttering (i.e., it can tackle full LTL), but\ndynamically detects and exploits a form of stuttering where possible. Our\nexperiments show that these two variants, while incomparable with each other,\ncan outperform other existing approaches.\n", "versions": [{"version": "v1", "created": "Tue, 28 Jun 2011 15:11:27 GMT"}], "update_date": "2011-06-29", "authors_parsed": [["Duret-Lutz", "Alexandre", ""], ["Klai", "Kais", ""], ["Poitrenaud", "Denis", ""], ["Thierry-Mieg", "Yann", ""]]}, {"id": "1106.5995", "submitter": "Nicolaie Popescu-Bodorin", "authors": "Nicolaie Popescu-Bodorin, Valentina E. Balas", "title": "From Cognitive Binary Logic to Cognitive Intelligent Agents", "comments": "3 figures, 4 pages, latest version: http://fmi.spiruharet.ro/bodorin/", "journal-ref": "Proc. 14th Int. Conf. on Intelligent Engineering Systems, pp.\n  337-340, Conference Publishing Services - IEEE Computer Society, ISBN\n  978-1-4244-7651-0, May 2010", "doi": "10.1109/INES.2010.5483820", "report-no": null, "categories": "cs.AI cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The relation between self awareness and intelligence is an open problem these\ndays. Despite the fact that self awarness is usually related to Emotional\nIntelligence, this is not the case here. The problem described in this paper is\nhow to model an agent which knows (Cognitive) Binary Logic and which is also\nable to pass (without any mistake) a certain family of Turing Tests designed to\nverify its knowledge and its discourse about the modal states of truth\ncorresponding to well-formed formulae within the language of Propositional\nBinary Logic.\n", "versions": [{"version": "v1", "created": "Sat, 18 Jun 2011 09:09:07 GMT"}], "update_date": "2011-06-30", "authors_parsed": [["Popescu-Bodorin", "Nicolaie", ""], ["Balas", "Valentina E.", ""]]}, {"id": "1106.6196", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "On the behaviours produced by instruction sequences under execution", "comments": "36 pages, consolidates material from arXiv:0811.0436 [cs.PL],\n  arXiv:0902.2859 [cs.PL], and arXiv:0905.2257 [cs.PL]; abstract and\n  introduction rewritten, examples and proofs added", "journal-ref": "Fundamenta Informaticae, 120(2):111--144, 2012", "doi": "10.3233/FI-2012-753", "report-no": null, "categories": "cs.PL cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study several aspects of the behaviours produced by instruction sequences\nunder execution in the setting of the algebraic theory of processes known as\nACP. We use ACP to describe the behaviours produced by instruction sequences\nunder execution and to describe two protocols implementing these behaviours in\nthe case where the processing of instructions takes place remotely. We also\nshow that all finite-state behaviours considered in ACP can be produced by\ninstruction sequences under execution.\n", "versions": [{"version": "v1", "created": "Thu, 30 Jun 2011 11:51:25 GMT"}, {"version": "v2", "created": "Mon, 11 Jun 2012 07:11:09 GMT"}], "update_date": "2012-12-05", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "1106.6267", "submitter": "Nikolaos Triantafyllou", "authors": "Katerina Ksystra, Konstantinos Barlas, Nikolaos Triantafyllou and\n  Petros Stefaneas", "title": "A Dynamic Algebraic Specification for Social Networks", "comments": "8 apges, 1 figure, 5 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  With the help of the Internet, social networks have grown rapidly. This has\nincreased security requirements. We present a formalization of social networks\nas composite behavioral objects, defined using the Observational Transition\nSystem (OTS) approach. Our definition is then translated to the OTS/CafeOBJ\nalgebraic specification methodology. This translation allows the formal\nverification of safety properties for social networks via the Proof Score\nmethod. Finally, using this methodology we formally verify some security\nproperties.\n", "versions": [{"version": "v1", "created": "Wed, 29 Jun 2011 10:22:20 GMT"}], "update_date": "2011-07-01", "authors_parsed": [["Ksystra", "Katerina", ""], ["Barlas", "Konstantinos", ""], ["Triantafyllou", "Nikolaos", ""], ["Stefaneas", "Petros", ""]]}]