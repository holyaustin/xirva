[{"id": "1603.00087", "submitter": "Santiago Escobar", "authors": "Sonia Santiago and Santiago Escobar and Catherine Meadows and Jos\\'e\n  Meseguer", "title": "Effective Sequential Protocol Composition in Maude-NPA", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Protocols do not work alone, but together, one protocol relying on another to\nprovide needed services. Many of the problems in cryptographic protocols arise\nwhen such composition is done incorrectly or is not well understood. In this\npaper we discuss an extension to the Maude-NPA syntax and its operational\nsemantics to support dynamic sequential composition of protocols, so that\nprotocols can be specified separately and composed when desired. This allows\none to reason about many different compositions with minimal changes to the\nspecification, as well as improving, in terms of both performance and ease of\nspecification, on an earlier composition extension we presented in [18]. We\nshow how compositions can be defined and executed symbolically in Maude-NPA\nusing the compositional syntax and semantics. We also provide an experimental\nanalysis of the performance of Maude-NPA using the compositional syntax and\nsemantics, and compare it to the performance of a syntax and semantics for\ncomposition developed in earlier research. Finally, in the conclusion we give\nsome lessons learned about the best ways of extending narrowing-based state\nreachability tools, as well as comparison with related work and future plans.\n", "versions": [{"version": "v1", "created": "Mon, 29 Feb 2016 23:12:24 GMT"}], "update_date": "2016-03-02", "authors_parsed": [["Santiago", "Sonia", ""], ["Escobar", "Santiago", ""], ["Meadows", "Catherine", ""], ["Meseguer", "Jos\u00e9", ""]]}, {"id": "1603.00307", "submitter": "Christopher M. Poskitt", "authors": "Claudio Corrodi, Alexander Heu{\\ss}ner, Christopher M. Poskitt", "title": "A Graph-Based Semantics Workbench for Concurrent Asynchronous Programs", "comments": "Accepted for publication in the proceedings of FASE 2016 (to appear)", "journal-ref": "Proc. International Conference on Fundamental Approaches to\n  Software Engineering (FASE 2016), volume 9633 of LNCS, pages 31-48. Springer,\n  2016", "doi": "10.1007/978-3-662-49665-7_3", "report-no": null, "categories": "cs.SE cs.DC cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A number of novel programming languages and libraries have been proposed that\noffer simpler-to-use models of concurrency than threads. It is challenging,\nhowever, to devise execution models that successfully realise their\nabstractions without forfeiting performance or introducing unintended\nbehaviours. This is exemplified by SCOOP---a concurrent object-oriented\nmessage-passing language---which has seen multiple semantics proposed and\nimplemented over its evolution. We propose a \"semantics workbench\" with fully\nand semi-automatic tools for SCOOP, that can be used to analyse and compare\nprograms with respect to different execution models. We demonstrate its use in\nchecking the consistency of semantics by applying it to a set of representative\nprograms, and highlighting a deadlock-related discrepancy between the principal\nexecution models of the language. Our workbench is based on a modular and\nparameterisable graph transformation semantics implemented in the GROOVE tool.\nWe discuss how graph transformations are leveraged to atomically model\nintricate language abstractions, and how the visual yet algebraic nature of the\nmodel can be used to ascertain soundness.\n", "versions": [{"version": "v1", "created": "Tue, 1 Mar 2016 15:10:21 GMT"}], "update_date": "2016-03-24", "authors_parsed": [["Corrodi", "Claudio", ""], ["Heu\u00dfner", "Alexander", ""], ["Poskitt", "Christopher M.", ""]]}, {"id": "1603.00536", "submitter": "EPTCS", "authors": "C\\'esar A. Mu\\~noz (NASA Langley Research Center), Jorge A. P\\'erez\n  (University of Groningen)", "title": "Proceedings of the Eleventh International Workshop on Developments in\n  Computational Models", "comments": null, "journal-ref": "EPTCS 204, 2016", "doi": "10.4204/EPTCS.204", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of DCM 2015, the 11th International\nWorkshop on Developments in Computational Models held on October 28, 2015 in\nCali, Colombia. DCM 2015 was organized as a one-day satellite event of the 12th\nInternational Colloquium on Theoretical Aspects of Computing (ICTAC 2015).\n  Several new models of computation have emerged in the last few years, and\nmany developments of traditional computational models have been proposed with\nthe aim of taking into account the new demands of computer systems users and\nthe new capabilities of computation engines. A new computational model, or a\nnew feature in a traditional one, usually is reflected in a new family of\nprogramming languages, and new paradigms of software development.\n  The aim of the DCM workshop series is to bring together researchers who are\ncurrently developing new computational models or new features for traditional\ncomputational models, in order to foster their interaction, to provide a forum\nfor presenting new ideas and work in progress, and to enable newcomers to learn\nabout current activities in this area. Topics of interest include all abstract\nmodels of computation and their applications to the development of programming\nlanguages and systems.\n", "versions": [{"version": "v1", "created": "Wed, 2 Mar 2016 00:49:28 GMT"}], "update_date": "2016-03-03", "authors_parsed": [["Mu\u00f1oz", "C\u00e9sar A.", "", "NASA Langley Research Center"], ["P\u00e9rez", "Jorge A.", "", "University of Groningen"]]}, {"id": "1603.00636", "submitter": "Gudmund Grov PhD", "authors": "Gudmund Grov, Andrew Ireland, Maria Teresa Llano, Peter Kovacs, Simon\n  Colton and Jeremy Gow", "title": "Semi-Automated Design Space Exploration for Formal Modelling", "comments": "14 pages. Long version of a short paper to be published at ABZ 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Refinement based formal methods allow the modelling of systems through\nincremental steps via abstraction. Discovering the right levels of abstraction,\nformulating correct and meaningful invariants, and analysing faulty models are\nsome of the challenges faced when using this technique. Here, we propose Design\nSpace Exploration, an approach that aims to assist a designer by automatically\nproviding high-level modelling guidance in real-time. More specifically,\nthrough the combination of common patterns of modelling with techniques from\nautomated theory formation and automated reasoning, different design\nalternatives are explored and suitable models that deal with faults are\nproposed.\n", "versions": [{"version": "v1", "created": "Wed, 2 Mar 2016 09:54:44 GMT"}], "update_date": "2016-03-03", "authors_parsed": [["Grov", "Gudmund", ""], ["Ireland", "Andrew", ""], ["Llano", "Maria Teresa", ""], ["Kovacs", "Peter", ""], ["Colton", "Simon", ""], ["Gow", "Jeremy", ""]]}, {"id": "1603.00649", "submitter": "Malte Schwerhoff", "authors": "Peter M\\\"uller, Malte Schwerhoff, Alexander J. Summers", "title": "Automatic Verification of Iterated Separating Conjunctions using\n  Symbolic Execution", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In permission logics such as separation logic, the iterated separating\nconjunction is a quantifier denoting access permission to an unbounded set of\nheap locations. In contrast to recursive predicates, iterated separating\nconjunctions do not prescribe a structure on the locations they range over, and\nso do not restrict how to traverse and modify these locations. This flexibility\nis important for the verification of random-access data structures such as\narrays and data structures that can be traversed in multiple ways such as\ngraphs. Despite its usefulness, no automatic program verifier natively supports\niterated separating conjunctions; they are especially difficult to incorporate\ninto symbolic execution engines, the prevalent technique for building verifiers\nfor these logics.\n  In this paper, we present the first symbolic execution technique to support\ngeneral iterated separating conjunctions. We propose a novel representation of\nsymbolic heaps and flexible support for logical specifications that quantify\nover heap locations. Our technique exhibits predictable and fast performance\ndespite employing quantifiers at the SMT level, by carefully controlling\nquantifier instantiations. It is compatible with other features of permission\nlogics such as fractional permissions, recursive predicates, and abstraction\nfunctions. Our technique is implemented as an extension of the Viper\nverification infrastructure.\n", "versions": [{"version": "v1", "created": "Wed, 2 Mar 2016 10:41:47 GMT"}, {"version": "v2", "created": "Thu, 3 Mar 2016 09:21:38 GMT"}, {"version": "v3", "created": "Fri, 6 May 2016 10:23:37 GMT"}], "update_date": "2016-05-09", "authors_parsed": [["M\u00fcller", "Peter", ""], ["Schwerhoff", "Malte", ""], ["Summers", "Alexander J.", ""]]}, {"id": "1603.00658", "submitter": "Manjunatha Praveen", "authors": "M. Praveen, B. Srivathsan", "title": "Nesting Depth of Operators in Graph Database Queries: Expressiveness Vs.\n  Evaluation Complexity", "comments": "Improvements from ICALP 2016 review comments", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Designing query languages for graph structured data is an active field of\nresearch, where expressiveness and efficient algorithms for query evaluation\nare conflicting goals. To better handle dynamically changing data, recent work\nhas been done on designing query languages that can compare values stored in\nthe graph database, without hard coding the values in the query. The main idea\nis to allow variables in the query and bind the variables to values when\nevaluating the query. For query languages that bind variables only once, query\nevaluation is usually NP-complete. There are query languages that allow binding\ninside the scope of Kleene star operators, which can themselves be in the scope\nof bindings and so on. Uncontrolled nesting of binding and iteration within one\nanother results in query evaluation being PSPACE-complete.\n  We define a way to syntactically control the nesting depth of iterated\nbindings, and study how this affects expressiveness and efficiency of query\nevaluation. The result is an infinite, syntactically defined hierarchy of\nexpressions. We prove that the corresponding language hierarchy is strict.\nGiven an expression in the hierarchy, we prove that it is undecidable to check\nif there is a language equivalent expression at lower levels. We prove that\nevaluating a query based on an expression at level i can be done in $\\Sigma_i$\nin the polynomial time hierarchy. Satisfiability of quantified Boolean formulas\ncan be reduced to query evaluation; we study the relationship between\nalternations in Boolean quantifiers and the depth of nesting of iterated\nbindings.\n", "versions": [{"version": "v1", "created": "Wed, 2 Mar 2016 11:16:37 GMT"}, {"version": "v2", "created": "Thu, 5 May 2016 06:50:56 GMT"}], "update_date": "2016-05-06", "authors_parsed": [["Praveen", "M.", ""], ["Srivathsan", "B.", ""]]}, {"id": "1603.00838", "submitter": "Zoltan Esik", "authors": "Zoltan Esik, Sergey Goncharov", "title": "Some Remarks on Conway and Iteration Theories", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an axiomatization of Conway theories which yields,as a corollary,\na very concise axiomatization of iteration theories satisfying the functorial\nimplication for base morphisms.\n", "versions": [{"version": "v1", "created": "Wed, 2 Mar 2016 19:25:47 GMT"}], "update_date": "2016-03-03", "authors_parsed": [["Esik", "Zoltan", ""], ["Goncharov", "Sergey", ""]]}, {"id": "1603.00975", "submitter": "EPTCS", "authors": "Mauricio Ayala-Rinc\\'on (Universidade de Bras\\'ilia)", "title": "Formalising Confluence in PVS", "comments": "In Proceedings DCM 2015, arXiv:1603.00536", "journal-ref": "EPTCS 204, 2016, pp. 11-17", "doi": "10.4204/EPTCS.204.2", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Confluence is a critical property of computational systems which is related\nwith determinism and non ambiguity and thus with other relevant computational\nattributes of functional specifications and rewriting system as termination and\ncompletion. Several criteria have been explored that guarantee confluence and\ntheir formalisations provide further interesting information. This work\ndiscusses topics and presents personal positions and views related with the\nformalisation of confluence properties in the Prototype Verification System PVS\ndeveloped at our research group.\n", "versions": [{"version": "v1", "created": "Thu, 3 Mar 2016 05:33:28 GMT"}], "update_date": "2016-03-04", "authors_parsed": [["Ayala-Rinc\u00f3n", "Mauricio", "", "Universidade de Bras\u00edlia"]]}, {"id": "1603.00976", "submitter": "EPTCS", "authors": "Pawe{\\l} Soboci\\'nski (University of Southampton)", "title": "Compositional model checking of concurrent systems, with Petri nets", "comments": "In Proceedings DCM 2015, arXiv:1603.00536", "journal-ref": "EPTCS 204, 2016, pp. 19-30", "doi": "10.4204/EPTCS.204.3", "report-no": null, "categories": "cs.LO cs.FL cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compositionality and process equivalence are both standard concepts of\nprocess algebra. Compositionality means that the behaviour of a compound system\nrelies only on the behaviour of its components, i.e. there is no emergent\nbehaviour. Process equivalence means that the explicit statespace of a system\ntakes a back seat to its interaction patterns: the information that an\nenvironment can obtain though interaction.\n  Petri nets are a classical, yet widely used and understood, model of\nconcurrency. Nevertheless, they have often been described as a\nnon-compositional model, and tools tend to deal with monolithic,\nglobally-specified models.\n  This tutorial paper concentrates on Petri Nets with Boundaries (PNB): a\ncompositional, graphical algebra of 1-safe nets, and its applications to\nreachability checking within the tool Penrose. The algorithms feature the use\nof compositionality and process equivalence, a powerful combination that can be\nharnessed to improve the performance of checking reachability and coverability\nin several common examples where Petri nets model realistic concurrent systems.\n", "versions": [{"version": "v1", "created": "Thu, 3 Mar 2016 05:33:39 GMT"}], "update_date": "2016-03-04", "authors_parsed": [["Soboci\u0144ski", "Pawe\u0142", "", "University of Southampton"]]}, {"id": "1603.00978", "submitter": "EPTCS", "authors": "Edward Hermann Haeusler (Puc-Rio)", "title": "Finiteness and Computation in Toposes", "comments": "In Proceedings DCM 2015, arXiv:1603.00536", "journal-ref": "EPTCS 204, 2016, pp. 61-77", "doi": "10.4204/EPTCS.204.6", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Some notions in mathematics can be considered relative. Relative is a term\nused to denote when the variation in the position of an observer implies\nvariation in properties or measures on the observed object. We know, from\nSkolem theorem, that there are first-order models where the set of real numbers\nis countable and some where it is not. This fact depends on the position of the\nobserver and on the instrument/language the obserevr uses as well, i.e., it\ndepends on whether he/she is inside the model or not and in this particular\ncase the use of first-order logic. In this article, we assume that computation\nis based on finiteness rather than natural numbers and discuss Turing machines\ncomputable morphisms defined on top of the sole notion finiteness. We explore\nthe relativity of finiteness in models provided by toposes where the Axiom of\nChoice (AC) does not hold, since Tarski proved that if AC holds then all\nfiniteness notions are equivalent. Our toposes do not have natural numbers\nobject (NNO) either, since in a topos with a NNO these finiteness notions are\nequivalent to Peano finiteness going back to computation on top of Natural\nNumbers. The main contribution of this article is to show that although from\ninside every topos, with the properties previously stated, the computation\nmodel is standard, from outside some of these toposes, unexpected properties on\nthe computation arise, e.g., infinitely long programs, finite computations\ncontaining infinitely long ones, infinitely branching computations. We mainly\nconsider Dedekind and Kuratowski notions of finiteness in this article.\n", "versions": [{"version": "v1", "created": "Thu, 3 Mar 2016 05:34:10 GMT"}], "update_date": "2016-03-04", "authors_parsed": [["Haeusler", "Edward Hermann", "", "Puc-Rio"]]}, {"id": "1603.00979", "submitter": "EPTCS", "authors": "Mauricio Toro (Universidad Eafit, Colombia), Anna Philippou\n  (University of Cyprus, Cyprus), Sair Arboleda (Universidad de Antioquia,\n  Colombia), Mar\\'ia Puerta (Universidad Eafit, Colombia), Carlos M. V\\'elez S.\n  (Universidad Eafit, Colombia)", "title": "Mean-Field Semantics for a Process Calculus for Spatially-Explicit\n  Ecological Models", "comments": "In Proceedings DCM 2015, arXiv:1603.00536", "journal-ref": "EPTCS 204, 2016, pp. 79-94", "doi": "10.4204/EPTCS.204.7", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define a mean-field semantics for S-PALPS, a process calculus for\nspatially-explicit, individual-based modeling of ecological systems. The new\nsemantics of S-PALPS allows an interpretation of the average behavior of a\nsystem as a set of recurrence equations. Recurrence equations are a useful\napproximation when dealing with a large number of individuals, as it is the\ncase in epidemiological studies. As a case study, we compute a set of\nrecurrence equations capturing the dynamics of an individual-based model of the\ntransmission of dengue in Bello (Antioquia), Colombia.\n", "versions": [{"version": "v1", "created": "Thu, 3 Mar 2016 05:34:20 GMT"}], "update_date": "2016-03-04", "authors_parsed": [["Toro", "Mauricio", "", "Universidad Eafit, Colombia"], ["Philippou", "Anna", "", "University of Cyprus, Cyprus"], ["Arboleda", "Sair", "", "Universidad de Antioquia,\n  Colombia"], ["Puerta", "Mar\u00eda", "", "Universidad Eafit, Colombia"], ["S.", "Carlos M. V\u00e9lez", "", "Universidad Eafit, Colombia"]]}, {"id": "1603.01412", "submitter": "Brijesh Dongol", "authors": "Brijesh Dongol and Lindsay Groves", "title": "Contextual trace refinement for concurrent objects: Safety and progress", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Correctness of concurrent objects is defined in terms of safety properties\nsuch as linearizability, sequential consistency, and quiescent consistency, and\nprogress properties such as wait-, lock-, and obstruction-freedom. These\nproperties, however, only refer to the behaviours of the object in isolation,\nwhich does not tell us what guarantees these correctness conditions on\nconcurrent objects provide to their client programs. This paper investigates\nthe links between safety and progress properties of concurrent objects and a\nform of trace refinement for client programs, called contextual trace\nrefinement. In particular, we show that linearizability together with a minimal\nnotion of progress are sufficient properties of concurrent objects to ensure\ncontextual trace refinement, but sequential consistency and quiescent\nconsistency are both too weak. Our reasoning is carried out in the action\nsystems framework with procedure calls, which we extend to cope with non-atomic\noperations.\n", "versions": [{"version": "v1", "created": "Fri, 4 Mar 2016 10:20:23 GMT"}], "update_date": "2016-03-07", "authors_parsed": [["Dongol", "Brijesh", ""], ["Groves", "Lindsay", ""]]}, {"id": "1603.01445", "submitter": "Tetsuya Sato", "authors": "Tetsuya Sato", "title": "Approximate Relational Hoare Logic for Continuous Random Samplings", "comments": null, "journal-ref": null, "doi": "10.1016/j.entcs.2016.09.043", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Approximate relational Hoare logic (apRHL) is a logic for formal verification\nof the differential privacy of databases written in the programming language\npWHILE. Strictly speaking, however, this logic deals only with discrete random\nsamplings. In this paper, we define the graded relational lifting of the\nsubprobabilistic variant of Giry monad, which described differential privacy.\nWe extend the logic apRHL with this graded lifting to deal with continuous\nrandom samplings. We give a generic method to give proof rules of apRHL for\ncontinuous random samplings.\n", "versions": [{"version": "v1", "created": "Fri, 4 Mar 2016 13:13:17 GMT"}], "update_date": "2016-12-20", "authors_parsed": [["Sato", "Tetsuya", ""]]}, {"id": "1603.01455", "submitter": "Thorsten Wi{\\ss}mann", "authors": "Lutz Schr\\\"oder, Dexter Kozen, Stefan Milius, Thorsten Wi{\\ss}mann", "title": "Nominal Automata with Name Binding", "comments": "Updated arguments A.26/A.27; rest unchanged", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automata models for data languages (i.e. languages over infinite alphabets)\noften feature either global or local freshness operators. We show that Bollig\net al.'s session automata, which focus on global freshness, are equivalent to\nregular nondeterministic nominal automata (RNNA), a natural nominal automaton\nmodel with explicit name binding that has appeared implicitly in the semantics\nof nominal Kleene algebra (NKA), an extension of Kleene algebra with name\nbinding. The expected Kleene theorem for NKA is known to fail in one direction,\ni.e. there are nominal languages that can be accepted by an RNNA but are not\ndefinable in NKA; via session automata, we obtain a full Kleene theorem for\nRNNAs for an expression language that extends NKA with unscoped name binding.\nBased on the equivalence with RNNAs, we then slightly rephrase the known\nequivalence checking algorithm for session automata. Reinterpreting the data\nlanguage semantics of name binding by unrestricted instead of clean\nalpha-equivalence, we obtain a local freshness semantics as a quotient of the\nglobal freshness semantics. Under local freshness semantics, RNNAs turn out to\nbe equivalent to a natural subclass of Bojanczyk et al.'s nondeterministic\norbit-finite automata. We establish decidability of inclusion under local\nfreshness by modifying the RNNA-based algorithm; in summary, we obtain a\nformalism for local freshness in data languages that is reasonably expressive\nand has a decidable inclusion problem.\n", "versions": [{"version": "v1", "created": "Fri, 4 Mar 2016 13:39:02 GMT"}, {"version": "v2", "created": "Fri, 3 Feb 2017 10:44:32 GMT"}, {"version": "v3", "created": "Tue, 21 Feb 2017 13:53:20 GMT"}, {"version": "v4", "created": "Thu, 21 Jan 2021 12:45:42 GMT"}], "update_date": "2021-01-22", "authors_parsed": [["Schr\u00f6der", "Lutz", ""], ["Kozen", "Dexter", ""], ["Milius", "Stefan", ""], ["Wi\u00dfmann", "Thorsten", ""]]}, {"id": "1603.01758", "submitter": "Maciej Bendkowski", "authors": "Maciej Bendkowski", "title": "Normal-order reduction grammars", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an algorithm which, for given $n$, generates an unambiguous\nregular tree grammar defining the set of combinatory logic terms, over the set\n$\\{S,K\\}$ of primitive combinators, requiring exactly $n$ normal-order\nreduction steps to normalize. As a consequence of Curry and Feys's\nstandardization theorem, our reduction grammars form a complete syntactic\ncharacterization of normalizing combinatory logic terms. Using them, we provide\na recursive method of constructing ordinary generating functions counting the\nnumber of $S K$-combinators reducing in $n$ normal-order reduction steps.\nFinally, we investigate the size of generated grammars, giving a primitive\nrecursive upper bound.\n", "versions": [{"version": "v1", "created": "Sat, 5 Mar 2016 20:52:24 GMT"}, {"version": "v2", "created": "Sun, 20 Mar 2016 13:05:04 GMT"}, {"version": "v3", "created": "Thu, 2 Jun 2016 10:55:19 GMT"}], "update_date": "2016-06-03", "authors_parsed": [["Bendkowski", "Maciej", ""]]}, {"id": "1603.01766", "submitter": "Robert Goldblatt", "authors": "Robert Goldblatt and Ian Hodkinson", "title": "Spatial logic of modal mu-calculus and tangled closure operators", "comments": null, "journal-ref": "Part I: Studia Logica, Volume 106, Issue 1, February 2018,\n  131-166, doi: 10.1007/s11225-017-9732-1. Part II: Annals of Pure and Applied\n  Logic, Volume 168, Issue 5, May 2017, 1032-1090,\n  doi:10.1016/j.apal.2016.11.006", "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There has been renewed interest in recent years in McKinsey and Tarski's\ninterpretation of modal logic in topological spaces and their proof that S4 is\nthe logic of any separable dense-in-itself metric space. Here we extend this\nwork to the modal mu-calculus and to a logic of tangled closure operators that\nwas developed by Fern\\'andez-Duque after these two languages had been shown by\nDawar and Otto to have the same expressive power over finite transitive Kripke\nmodels. We prove that this equivalence remains true over topological spaces.\n  We establish the finite model property in Kripke semantics for various\ntangled closure logics with and without the universal modality $\\forall$. We\nalso extend the McKinsey--Tarski topological `dissection lemma'. These results\nare used to construct a representation map (also called a d-p-morphism) from\nany dense-in-itself metric space $X$ onto any finite connected locally\nconnected serial transitive Kripke frame.\n  This yields completeness theorems over $X$ for a number of languages: (i) the\nmodal mu-calculus with the closure operator $\\Diamond$; (ii) $\\Diamond$ and the\ntangled closure operators $\\langle t \\rangle$; (iii) $\\Diamond,\\forall$; (iv)\n$\\Diamond,\\forall,\\langle t \\rangle$; (v) the derivative operator $\\langle d\n\\rangle$; (vi) $\\langle d \\rangle$ and the associated tangled closure operators\n$\\langle dt \\rangle$; (vii) $\\langle d \\rangle,\\forall$; (viii) $\\langle d\n\\rangle,\\forall,\\langle dt \\rangle$. Soundness also holds, if: (a) for\nlanguages with $\\forall$, $X$ is connected; and (b) for languages with $\\langle\nd \\rangle$, $X$ validates the well known axiom $\\mathrm{G}_1$. For countable\nlanguages without $\\forall$, we prove strong completeness. We also show that in\nthe presence of $\\forall$, strong completeness fails if $X$ is compact and\nlocally connected.\n", "versions": [{"version": "v1", "created": "Sat, 5 Mar 2016 22:33:24 GMT"}], "update_date": "2018-11-06", "authors_parsed": [["Goldblatt", "Robert", ""], ["Hodkinson", "Ian", ""]]}, {"id": "1603.01776", "submitter": "Ian Hayes", "authors": "Ian J. Hayes", "title": "Generalised rely-guarantee concurrency: An algebraic foundation", "comments": "23 pages, 3 figures, submitted to Formal Aspects of Computing", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The rely-guarantee technique allows one to reason compositionally about\nconcurrent programs. To handle interference the technique makes use of rely and\nguarantee conditions, both of which are binary relations on states. A rely\ncondition is an assumption that the environment performs only atomic steps\nsatisfying the rely relation and a guarantee is a commitment that every atomic\nstep the program makes satisfies the guarantee relation. In order to\ninvestigate rely-guarantee reasoning more generally, in this paper we allow\ninterference to be represented by a process rather than a relation and hence\nderive more general rely-guarantee laws. The paper makes use of a weak\nconjunction operator between processes, which generalises a guarantee relation\nto a guarantee process, and introduces a rely quotient operator, which\ngeneralises a rely relation to a process. The paper focuses on the algebraic\nproperties of the general rely-guarantee theory. The Jones-style rely-guarantee\ntheory can be interpreted as a model of the general algebraic theory and hence\nthe general laws presented here hold for that theory.\n", "versions": [{"version": "v1", "created": "Sun, 6 Mar 2016 01:48:52 GMT"}], "update_date": "2016-03-08", "authors_parsed": [["Hayes", "Ian J.", ""]]}, {"id": "1603.02133", "submitter": "Kenta Cho", "authors": "Kenta Cho and Abraham Westerbaan", "title": "Von Neumann Algebras form a Model for the Quantum Lambda Calculus", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.OA quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a model of Selinger and Valiron's quantum lambda calculus based on\nvon Neumann algebras, and show that the model is adequate with respect to the\noperational semantics.\n", "versions": [{"version": "v1", "created": "Mon, 7 Mar 2016 16:10:42 GMT"}], "update_date": "2016-03-08", "authors_parsed": [["Cho", "Kenta", ""], ["Westerbaan", "Abraham", ""]]}, {"id": "1603.02148", "submitter": "Sergey Goncharov", "authors": "Sergey Goncharov and Stefan Milius and Christoph Rauch", "title": "Complete Elgot Monads and Coalgebraic Resumptions", "comments": "full version, 39 p", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Monads are extensively used nowadays to abstractly model a wide range of\ncomputational effects such as nondeterminism, statefulness, and exceptions. It\nturns out that equipping a monad with a (uniform) iteration operator satisfying\na set of natural axioms allows for modelling iterative computations just as\nabstractly. The emerging monads are called complete Elgot monads. It has been\nshown recently that extending complete Elgot monads with free effects (e.g.\noperations of sending/receiving messages over channels) canonically leads to\ngeneralized coalgebraic resumption monads, previously used as semantic domains\nfor non-wellfounded guarded processes. In this paper, we continue the study of\nthe relationship between abstract complete Elgot monads and those that capture\ncoalgebraic resumptions, by comparing the corresponding categories of\n(Eilenberg-Moore) algebras. To this end we first provide a characterization of\nthe latter category; even more generally, we formulate this characterization in\nterms of Uustalu's parametrized monads. This is further used for establishing a\ncharacterization of complete Elgot monads as precisely those monads whose\nalgebras are coherently equipped with the structure of algebras of coalgebraic\nresumption monads.\n", "versions": [{"version": "v1", "created": "Mon, 7 Mar 2016 16:48:18 GMT"}], "update_date": "2016-03-08", "authors_parsed": [["Goncharov", "Sergey", ""], ["Milius", "Stefan", ""], ["Rauch", "Christoph", ""]]}, {"id": "1603.02478", "submitter": "Christoph Lange", "authors": "Manfred Kerber and Christoph Lange and Colin Rowat", "title": "An Introduction to Mechanized Reasoning", "comments": null, "journal-ref": "Mathematical Economics 66, pp. 26-39. Elsevier, October 2016", "doi": "10.1016/j.jmateco.2016.06.005", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Mechanized reasoning uses computers to verify proofs and to help discover new\ntheorems. Computer scientists have applied mechanized reasoning to economic\nproblems but -- to date -- this work has not yet been properly presented in\neconomics journals. We introduce mechanized reasoning to economists in three\nways. First, we introduce mechanized reasoning in general, describing both the\ntechniques and their successful applications. Second, we explain how mechanized\nreasoning has been applied to economic problems, concentrating on the two\ndomains that have attracted the most attention: social choice theory and\nauction theory. Finally, we present a detailed example of mechanized reasoning\nin practice by means of a proof of Vickrey's familiar theorem on second-price\nauctions.\n", "versions": [{"version": "v1", "created": "Tue, 8 Mar 2016 11:12:30 GMT"}, {"version": "v2", "created": "Wed, 10 Aug 2016 22:45:43 GMT"}], "update_date": "2016-08-12", "authors_parsed": [["Kerber", "Manfred", ""], ["Lange", "Christoph", ""], ["Rowat", "Colin", ""]]}, {"id": "1603.02641", "submitter": "Joelle Despeyroux", "authors": "Joelle Despeyroux (INRIA), Kaustuv Chaudhuri (PARSIFAL)", "title": "A Hybrid Linear Logic for Constrained Transition Systems", "comments": "LIPIcs. TYPES'2013, Apr 2013, Toulouse, France. Post-proceedings of\n  TYPES'2013, 19th Intl Conference on Types for Proofs and Programs, LIPIcs.,\n  26, pp.150-168, 2014. arXiv admin note: substantial text overlap with\n  arXiv:1310.4310", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linear implication can represent state transitions, but real transition\nsystems operate under temporal, stochastic or probabilistic constraints that\nare not directly representable in ordinary linear logic. We propose a general\nmodal extension of intuitionistic linear logic where logical truth is indexed\nby constraints and hybrid connectives combine constraint reasoning with logical\nreasoning. The logic has a focused cut-free sequent calculus that can be used\nto internalize the rules of particular constrained transition systems; we\nillustrate this with an adequate encoding of the synchronous stochastic\npi-calculus.\n", "versions": [{"version": "v1", "created": "Tue, 8 Mar 2016 19:51:23 GMT"}], "update_date": "2016-03-09", "authors_parsed": [["Despeyroux", "Joelle", "", "INRIA"], ["Chaudhuri", "Kaustuv", "", "PARSIFAL"]]}, {"id": "1603.02922", "submitter": "Federico Olmedo", "authors": "Federico Olmedo and Benjamin Lucien Kaminski and Joost-Pieter Katoen\n  and Christoph Matheja", "title": "Reasoning about Recursive Probabilistic Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a wp-style calculus for obtaining expectations on the\noutcomes of (mutually) recursive probabilistic programs. We provide several\nproof rules to derive one-- and two--sided bounds for such expectations, and\nshow the soundness of our wp-calculus with respect to a probabilistic pushdown\nautomaton semantics. We also give a wp-style calculus for obtaining bounds on\nthe expected runtime of recursive programs that can be used to determine the\n(possibly infinite) time until termination of such programs.\n", "versions": [{"version": "v1", "created": "Wed, 9 Mar 2016 15:28:40 GMT"}], "update_date": "2016-03-10", "authors_parsed": [["Olmedo", "Federico", ""], ["Kaminski", "Benjamin Lucien", ""], ["Katoen", "Joost-Pieter", ""], ["Matheja", "Christoph", ""]]}, {"id": "1603.02966", "submitter": "Manfred Kufleitner", "authors": "Volker Diekert and Artur Je\\.z and Manfred Kufleitner", "title": "Solutions of Word Equations over Partially Commutative Structures", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give NSPACE(n log n) algorithms solving the following decision problems.\nSatisfiability: Is the given equation over a free partially commutative monoid\nwith involution (resp. a free partially commutative group) solvable?\nFiniteness: Are there only finitely many solutions of such an equation? PSPACE\nalgorithms with worse complexities for the first problem are known, but so far,\na PSPACE algorithm for the second problem was out of reach. Our results are\nmuch stronger: Given such an equation, its solutions form an EDT0L language\neffectively representable in NSPACE(n log n). In particular, we give an\neffective description of the set of all solutions for equations with\nconstraints in free partially commutative monoids and groups.\n", "versions": [{"version": "v1", "created": "Wed, 9 Mar 2016 17:03:22 GMT"}], "update_date": "2016-03-10", "authors_parsed": [["Diekert", "Volker", ""], ["Je\u017c", "Artur", ""], ["Kufleitner", "Manfred", ""]]}, {"id": "1603.03252", "submitter": "\\v{L}ubo\\v{s} Koren\\v{c}iak", "authors": "\\v{L}ubo\\v{s} Koren\\v{c}iak, Vojt\\v{e}ch \\v{R}eh\\'ak, Adrian Farmadin", "title": "Extension of PRISM by Synthesis of Optimal Timeouts in Fixed-Delay CTMC", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a practically appealing extension of the probabilistic model\nchecker PRISM rendering it to handle fixed-delay continuous-time Markov chains\n(fdCTMCs) with rewards, the equivalent formalism to the deterministic and\nstochastic Petri nets (DSPNs). fdCTMCs allow transitions with fixed-delays (or\ntimeouts) on top of the traditional transitions with exponential rates. Our\nextension supports an evaluation of expected reward until reaching a given set\nof target states. The main contribution is that, considering the fixed-delays\nas parameters, we implemented a synthesis algorithm that computes the\nepsilon-optimal values of the fixed-delays minimizing the expected reward. We\nprovide a performance evaluation of the synthesis on practical examples.\n", "versions": [{"version": "v1", "created": "Thu, 10 Mar 2016 13:20:05 GMT"}], "update_date": "2016-03-11", "authors_parsed": [["Koren\u010diak", "\u013dubo\u0161", ""], ["\u0158eh\u00e1k", "Vojt\u011bch", ""], ["Farmadin", "Adrian", ""]]}, {"id": "1603.03475", "submitter": "Robert Kent", "authors": "Robert E. Kent", "title": "Information Flow in Logical Environments", "comments": "This paper was completed in 2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes information flow within logical environments. The theory\nof information flow, the logic of distributed systems, was first defined by\nBarwise and Seligman (Information Flow: The Logic of Distributed Systems.\n1997). Logical environments are a semantic-oriented version of institutions.\nThe theory of institutions, which was initiated by Goguen and Burstall\n(Institutions: Abstract Model Theory for Specification and Programming. 1992),\nis abstract model theory. Information flow is the flow of information in\nchannels over distributed systems. The semantic integration of distributed\nsystems, be they ontologies, databases or other information resources, can be\ndefined in terms of the channel theory of information flow. As originally\ndefined, the theory of information flow uses only a specific logical\nenvironment in order to discuss information flow. This paper shows how\ninformation flow can be defined in an arbitrary logical environment.\n", "versions": [{"version": "v1", "created": "Thu, 10 Mar 2016 22:12:34 GMT"}], "update_date": "2016-03-14", "authors_parsed": [["Kent", "Robert E.", ""]]}, {"id": "1603.03727", "submitter": "Hongwei Xi", "authors": "Hongwei Xi and Zhiqiang Ren and Hanwen Wu and William Blair", "title": "Session Types in a Linearly Typed Multi-Threaded Lambda-Calculus", "comments": "This is the original version of the paper on supporting programming\n  with dyadic session types in ATS", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a formalization of session types in a multi-threaded\nlambda-calculus (MTLC) equipped with a linear type system, establishing for the\nMTLC both type preservation and global progress. The latter (global progress)\nimplies that the evaluation of a well-typed program in the MTLC can never reach\na deadlock. As this formulated MTLC can be readily embedded into ATS, a\nfull-fledged language with a functional programming core that supports both\ndependent types (of DML-style) and linear types, we obtain a direct\nimplementation of session types in ATS. In addition, we gain immediate support\nfor a form of dependent session types based on this embedding into ATS.\nCompared to various existing formalizations of session types, we see the one\ngiven in this paper is unique in its closeness to concrete implementation. In\nparticular, we report such an implementation ready for practical use that\ngenerates Erlang code from well-typed ATS source (making use of session types),\nthus taking great advantage of the infrastructural support for distributed\ncomputing in Erlang.\n", "versions": [{"version": "v1", "created": "Fri, 11 Mar 2016 19:15:03 GMT"}], "update_date": "2016-03-14", "authors_parsed": [["Xi", "Hongwei", ""], ["Ren", "Zhiqiang", ""], ["Wu", "Hanwen", ""], ["Blair", "William", ""]]}, {"id": "1603.03814", "submitter": "Mohamed El Halaby", "authors": "Mohamed El Halaby", "title": "Solving MaxSAT by Successive Calls to a SAT Solver", "comments": "Survey, 46 pages", "journal-ref": null, "doi": "10.1007/978-3-319-56994-9_31", "report-no": null, "categories": "cs.AI cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Maximum Satisfiability (MaxSAT) problem is the problem of finding a truth\nassignment that maximizes the number of satisfied clauses of a given Boolean\nformula in Conjunctive Normal Form (CNF). Many exact solvers for MaxSAT have\nbeen developed during recent years, and many of them were presented in the\nwell-known SAT conference. Algorithms for MaxSAT generally fall into two\ncategories: (1) branch and bound algorithms and (2) algorithms that use\nsuccessive calls to a SAT solver (SAT- based), which this paper in on. In\npractical problems, SAT-based algorithms have been shown to be more efficient.\nThis paper provides an experimental investigation to compare the performance of\nrecent SAT-based and branch and bound algorithms on the benchmarks of the\nMaxSAT Evaluations.\n", "versions": [{"version": "v1", "created": "Fri, 11 Mar 2016 22:54:28 GMT"}], "update_date": "2018-06-13", "authors_parsed": [["Halaby", "Mohamed El", ""]]}, {"id": "1603.04059", "submitter": "Laurent Bartholdi", "authors": "Laurent Bartholdi and Dzmitry Dudko", "title": "Algorithmic aspects of branched coverings II/V. Sphere bisets and their\n  decompositions", "comments": "wrt version 1: references fixed wrt version 2: general stylistic\n  improvements, replaced \"congruence\" by \"intertwiner\"; wrt version 3: rewrote\n  the algorithmic content", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.GR cs.LO math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider \"Thurston maps\": branched self-coverings of the sphere with\nultimately periodic critical points, and prove that the Thurston equivalence\nproblem between them (continuous deformation of maps along with their critical\norbits) is decidable.\n  More precisely, we consider the action of mapping class groups, by pre- and\npost-composition, on branched coverings, and encode them algebraically as\n\"mapping class bisets\". We show how the mapping class biset of maps preserving\na multicurve decomposes into mapping class bisets of smaller complexity, called\n\"small mapping class bisets\".\n  We phrase the decision problem of Thurston equivalence between branched\nself-coverings of the sphere in terms of the conjugacy and centralizer problems\nin a mapping class biset. Our decomposition results on mapping class bisets\nreduce these decision problems to small mapping class bisets; they correspond\nto rational maps, homeomorphisms and maps double covered by a torus\nendomorphism, and their conjugacy and centralizer problems are solvable\nrespectively in terms of complex analysis, group theory and linear algebra.\n  Branched coverings themselves are also encoded into bisets, with actions of\nthe fundamental groups. We characterize those bisets that arise from branched\ncoverings between topological spheres, and extend this correspondence to maps\nbetween spheres with multicurves, whose algebraic counterparts are \"sphere\ntrees of bisets\".\n  To illustrate the difference between Thurston maps and homeomorphisms, we\nproduce a Thurston map with infinitely generated centralizer --- while\ncentralizers of homeomorphisms are always finitely generated.\n", "versions": [{"version": "v1", "created": "Sun, 13 Mar 2016 18:34:59 GMT"}, {"version": "v2", "created": "Tue, 15 Mar 2016 09:40:34 GMT"}, {"version": "v3", "created": "Fri, 7 Oct 2016 21:51:34 GMT"}, {"version": "v4", "created": "Thu, 14 Jun 2018 13:48:40 GMT"}], "update_date": "2018-06-15", "authors_parsed": [["Bartholdi", "Laurent", ""], ["Dudko", "Dzmitry", ""]]}, {"id": "1603.04309", "submitter": "Leonid Libkin", "authors": "Pablo Barcelo (U Chile), Leonid Libkin (U Edinburgh)", "title": "Order-Invariant Types and Their Applications", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 1 (April 1,\n  2016) lmcs:1632", "doi": "10.2168/LMCS-12(1:9)2016", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Our goal is to show that the standard model-theoretic concept of types can be\napplied in the study of order-invariant properties, i.e., properties definable\nin a logic in the presence of an auxiliary order relation, but not actually\ndependent on that order relation. This is somewhat surprising since\norder-invariant properties are more of a combinatorial rather than a logical\nobject. We provide two applications of this notion. One is a proof, from the\nbasic principles, of a theorem by Courcelle stating that over trees,\norder-invariant MSO properties are expressible in MSO with counting\nquantifiers. The other is an analog of the Feferman-Vaught theorem for\norder-invariant properties.\n", "versions": [{"version": "v1", "created": "Mon, 14 Mar 2016 15:42:18 GMT"}, {"version": "v2", "created": "Tue, 15 Mar 2016 17:12:24 GMT"}, {"version": "v3", "created": "Wed, 30 Mar 2016 20:44:33 GMT"}], "update_date": "2017-01-11", "authors_parsed": [["Barcelo", "Pablo", "", "U Chile"], ["Libkin", "Leonid", "", "U Edinburgh"]]}, {"id": "1603.05072", "submitter": "Mickael Randour", "authors": "Mickael Randour", "title": "Reconciling Rationality and Stochasticity: Rich Behavioral Models in\n  Two-Player Games", "comments": "Accepted at GAMES 2016, the 5th World Congress of the Game Theory\n  Society. High-level survey notably based on arXiv:1204.3283 and\n  arXiv:1411.0835", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two traditional paradigms are often used to describe the behavior of agents\nin multi-agent complex systems. In the first one, agents are considered to be\nfully rational and systems are seen as multi-player games. In the second one,\nagents are considered to be fully stochastic processes and the system itself is\nseen as a large stochastic process. From the standpoint of a particular agent -\nhaving to choose a strategy, the choice of the paradigm is crucial: the most\nadequate strategy depends on the assumptions made on the other agents.\n  In this paper, we focus on two-player games and their application to the\nautomated synthesis of reliable controllers for reactive systems - a field at\nthe crossroads between computer science and mathematics. In this setting, the\nreactive system to control is a player, and its environment is its opponent,\nusually assumed to be fully antagonistic or fully stochastic. We illustrate\nseveral recent developments aiming to breach this narrow taxonomy by providing\nformal concepts and mathematical frameworks to reason about richer behavioral\nmodels.\n  The interest of such models is not limited to reactive system synthesis but\nextends to other application fields of game theory. The goal of our\ncontribution is to give a high-level presentation of key concepts and\napplications, aimed at a broad audience. To achieve this goal, we illustrate\nthose rich behavioral models on a classical challenge of the everyday life:\nplanning a journey in an uncertain environment.\n", "versions": [{"version": "v1", "created": "Wed, 16 Mar 2016 12:56:24 GMT"}], "update_date": "2016-03-17", "authors_parsed": [["Randour", "Mickael", ""]]}, {"id": "1603.05214", "submitter": "Tadeusz Litak", "authors": "Stefan Milius, Tadeusz Litak", "title": "Guard Your Daggers and Traces: Properties of Guarded (Co-)recursion", "comments": "invited to a special issue of Fundamenta Informaticae (FiCS'13).\n  arXiv admin note: text overlap with arXiv:1309.0895", "journal-ref": null, "doi": "10.3233/FI-2017-1475", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Motivated by the recent interest in models of guarded (co-)recursion, we\nstudy their equational properties. We formulate axioms for guarded fixpoint\noperators generalizing the axioms of iteration theories of Bloom and \\'Esik.\nModels of these axioms include both standard (e.g., cpo-based) models of\niteration theories and models of guarded recursion such as complete metric\nspaces or the topos of trees studied by Birkedal et al. We show that the\nstandard result on the satisfaction of all Conway axioms by a unique dagger\noperation generalizes to the guarded setting. We also introduce the notion of\nguarded trace operator on a category, and we prove that guarded trace and\nguarded fixpoint operators are in one-to-one correspondence. Our results are\nintended as first steps leading, hopefully, towards future description of\nclassifying theories for guarded recursion.\n", "versions": [{"version": "v1", "created": "Wed, 16 Mar 2016 18:39:53 GMT"}], "update_date": "2018-08-21", "authors_parsed": [["Milius", "Stefan", ""], ["Litak", "Tadeusz", ""]]}, {"id": "1603.05314", "submitter": "Te-Hsuan Chen", "authors": "Te-Hsuan Chen and Ju-Yi Lu", "title": "Hardware Acceleration for Boolean Satisfiability Solver by Applying\n  Belief Propagation Algorithm", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Boolean satisfiability (SAT) has an extensive application domain in computer\nscience, especially in electronic design automation applications. Circuit\nsynthesis, optimization, and verification problems can be solved by\ntransforming original problems to SAT problems. However, the SAT problem is\nknown as NP-complete, which means there is no efficient method to solve it.\nTherefore, an efficient SAT solver to enhance the performance is always\ndesired. We propose a hardware acceleration method for SAT problems. By\nsurveying the properties of SAT problems and the decoding of low-density\nparity-check (LDPC) codes, a special class of error-correcting codes, we\ndiscover that both of them are constraint satisfaction problems. The belief\npropagation algorithm has been successfully applied to the decoding of LDPC,\nand the corresponding decoder hardware designs are extensively studied.\nTherefore, we proposed a belief propagation based algorithm to solve SAT\nproblems. With this algorithm, the SAT solver can be accelerated by hardware. A\nsoftware simulator is implemented to verify the proposed algorithm and the\nperformance improvement is estimated. Our experiment results show that time\ncomplexity does not increase with the size of SAT problems and the proposed\nmethod can achieve at least 30x speedup compared to MiniSat.\n", "versions": [{"version": "v1", "created": "Wed, 16 Mar 2016 23:57:27 GMT"}], "update_date": "2016-03-18", "authors_parsed": [["Chen", "Te-Hsuan", ""], ["Lu", "Ju-Yi", ""]]}, {"id": "1603.05426", "submitter": "Wanwei Liu", "authors": "Wanwei Liu", "title": "A Short Note on Infinite Union/Intersection of Omega Regular Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We in this paper show that omega regular languages are not closed under\ninfinite union and intersection. As an attempt, we propose to add step\nvariables and quantifiers to temporal logics to enhance the expressiveness of\nthe underlying logic. We also show that doing this would cause undecidability\nin satisfiability, even if for a rather limited fragment of temporal logic.\n", "versions": [{"version": "v1", "created": "Thu, 17 Mar 2016 10:57:30 GMT"}], "update_date": "2016-03-18", "authors_parsed": [["Liu", "Wanwei", ""]]}, {"id": "1603.05495", "submitter": "Matthew Noonan", "authors": "Matthew Noonan, Alexey Loginov, David Cok", "title": "Polymorphic Type Inference for Machine Code", "comments": "Full version with appendices, for PLDI 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For many compiled languages, source-level types are erased very early in the\ncompilation process. As a result, further compiler passes may convert type-safe\nsource into type-unsafe machine code. Type-unsafe idioms in the original source\nand type-unsafe optimizations mean that type information in a stripped binary\nis essentially nonexistent. The problem of recovering high-level types by\nperforming type inference over stripped machine code is called type\nreconstruction, and offers a useful capability in support of reverse\nengineering and decompilation.\n  In this paper, we motivate and develop a novel type system and algorithm for\nmachine-code type inference. The features of this type system were developed by\nsurveying a wide collection of common source- and machine-code idioms, building\na catalog of challenging cases for type reconstruction. We found that these\nidioms place a sophisticated set of requirements on the type system, inducing\nfeatures such as recursively-constrained polymorphic types. Many of the\nfeatures we identify are often seen only in expressive and powerful type\nsystems used by high-level functional languages.\n  Using these type-system features as a guideline, we have developed Retypd: a\nnovel static type-inference algorithm for machine code that supports recursive\ntypes, polymorphism, and subtyping. Retypd yields more accurate inferred types\nthan existing algorithms, while also enabling new capabilities such as\nreconstruction of pointer const annotations with 98% recall. Retypd can operate\non weaker program representations than the current state of the art, removing\nthe need for high-quality points-to information that may be impractical to\ncompute.\n", "versions": [{"version": "v1", "created": "Thu, 17 Mar 2016 14:09:14 GMT"}, {"version": "v2", "created": "Fri, 18 Mar 2016 20:09:56 GMT"}], "update_date": "2016-03-22", "authors_parsed": [["Noonan", "Matthew", ""], ["Loginov", "Alexey", ""], ["Cok", "David", ""]]}, {"id": "1603.05625", "submitter": "Andreas Krebs", "authors": "Andreas Krebs, Kamal Lodaya, Paritosh Pandya, Howard Straubing", "title": "Two-variable Logic with a Between Predicate", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study an extension of FO^2[<], first-order logic interpreted in finite\nwords, in which formulas are restricted to use only two variables. We adjoin to\nthis language two-variable atomic formulas that say, `the letter a appears\nbetween positions x and y'. This is, in a sense, the simplest property that is\nnot expressible using only two variables.\n  We present several logics, both first-order and temporal, that have the same\nexpressive power, and find matching lower and upper bounds for the complexity\nof satisfiability for each of these formulations. We also give an effective\nnecessary condition, in terms of the syntactic monoid of a regular language,\nfor a property to be expressible in this logic. We show that this condition is\nalso sufficient for words over a two-letter alphabet. This algebraic analysis\nallows us us to prove, among other things, that our new logic has strictly less\nexpressive power than full first-order logic FO[<].\n", "versions": [{"version": "v1", "created": "Thu, 17 Mar 2016 19:17:10 GMT"}], "update_date": "2016-03-18", "authors_parsed": [["Krebs", "Andreas", ""], ["Lodaya", "Kamal", ""], ["Pandya", "Paritosh", ""], ["Straubing", "Howard", ""]]}, {"id": "1603.05789", "submitter": "Jeroen Keiren", "authors": "David N. Jansen and Jeroen J.A. Keiren", "title": "Stuttering equivalence is too slow!", "comments": "11 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Groote and Wijs recently described an algorithm for deciding stuttering\nequivalence and branching bisimulation equivalence, acclaimed to run in\n$\\mathcal{O}(m \\log n)$ time. Unfortunately, the algorithm does not always meet\nthe acclaimed running time. In this paper, we present two counterexamples where\nthe algorithms uses $\\Omega(md)$ time. A third example shows that the\ncorrection is not trivial. In order to analyse the problem we present\npseudocode of the algorithm, and indicate the time that can be spent on each\npart of the algorithm in order to meet the desired bound. We also propose fixes\nto the algorithm such that it indeed runs in $\\mathcal{O}(m \\log n)$ time.\n", "versions": [{"version": "v1", "created": "Fri, 18 Mar 2016 08:20:16 GMT"}, {"version": "v2", "created": "Thu, 22 Sep 2016 07:23:46 GMT"}], "update_date": "2016-09-23", "authors_parsed": [["Jansen", "David N.", ""], ["Keiren", "Jeroen J. A.", ""]]}, {"id": "1603.06017", "submitter": "Hamoon Mousavi", "authors": "Hamoon Mousavi", "title": "Automatic Theorem Proving in Walnut", "comments": "Added a few more sections", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO cs.MS math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Walnut is a software package that implements a mechanical decision procedure\nfor deciding certain combinatorial properties of some special words referred to\nas automatic words or automatic sequences. Walnut is written in Java and is\nopen source. It is licensed under GNU General Public License.\n", "versions": [{"version": "v1", "created": "Fri, 18 Mar 2016 23:53:10 GMT"}, {"version": "v2", "created": "Tue, 25 May 2021 23:20:24 GMT"}], "update_date": "2021-05-27", "authors_parsed": [["Mousavi", "Hamoon", ""]]}, {"id": "1603.06266", "submitter": "G\\\"unter Khyo", "authors": "G\\\"unter Khyo", "title": "Multidimensional Predicates for Prolog", "comments": "17 pages, to be submitted to ICLP 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In 2014, Ungar et al. proposed Korz, a new computational model for\nstructuring adaptive (object-oriented) systems. Korz combines implicit\nparameters and multiple dispatch to structure the behavior of objects in a\nmultidimensional space. Korz is a simple yet expressive model which does not\nrequire special programming techniques such as the Visitor or Strategy pattern\nto accommodate a system for emerging contextual requirements. We show how the\nideas of Korz can be integrated in a Prolog system by extending its syntax and\nsemantics with simple meta-programming techniques. We developed a library,\ncalled mdp (multidimensional predicates) which can be used to experiment with\nmultidimensional Prolog systems. We highlight its benefits with numerous\nscenarios such as printing debugging information, memoization, object-oriented\nprogramming and adaptive GUIs. In particular, we point out that we can\nstructure and extend Prolog programs with additional concerns in a clear and\nconcise manner. We also demonstrate how Prolog's unique meta-programming\ncapabilities allow for quick experimentation with syntactical and semantical\nenhancement of the new, multidimensional model. While there are many open\nconcerns, such as efficiency and comprehensibility in the case of larger\nsystems, we will see that we can use the leverage of mdp and Prolog to explore\nnew horizons in the design of adaptive systems.\n", "versions": [{"version": "v1", "created": "Sun, 20 Mar 2016 20:43:06 GMT"}], "update_date": "2016-03-22", "authors_parsed": [["Khyo", "G\u00fcnter", ""]]}, {"id": "1603.06422", "submitter": "Jeroen Keiren", "authors": "S. Cranen, J.J.A. Keiren, T.A.C. Willemse", "title": "Parity Game Reductions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Parity games play a central role in model checking and satisfiability\nchecking. Solving parity games is computationally expensive, among others due\nto the size of the games, which, for model checking problems, can easily\ncontain $10^9$ vertices or beyond. Equivalence relations can be used to reduce\nthe size of a parity game, thereby potentially alleviating part of the\ncomputational burden. We reconsider (governed) bisimulation and (governed)\nstuttering bisimulation, and we give detailed proofs that these relations are\nequivalences, have unique quotients and they approximate the winning regions of\nparity games. Furthermore, we present game-based characterisations of these\nrelations. Using these characterisations our equivalences are compared to\nrelations for parity games that can be found in the literature, such as direct\nsimulation equivalence and delayed simulation equivalence. To complete the\noverview we develop coinductive characterisations of direct- and delayed\nsimulation equivalence and we establish a lattice of equivalences for parity\ngames.\n", "versions": [{"version": "v1", "created": "Mon, 21 Mar 2016 13:17:37 GMT"}], "update_date": "2016-03-22", "authors_parsed": [["Cranen", "S.", ""], ["Keiren", "J. J. A.", ""], ["Willemse", "T. A. C.", ""]]}, {"id": "1603.06716", "submitter": "R\\\"udiger Ehlers", "authors": "Ruediger Ehlers, Salar Moarref, Ufuk Topcu", "title": "Risk-Averse $\\omega$-regular Markov Decision Process Control", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.LO cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many control problems in environments that can be modeled as Markov decision\nprocesses (MDPs) concern infinite-time horizon specifications. The classical\naim in this context is to compute a control policy that maximizes the\nprobability of satisfying the specification. In many scenarios, there is\nhowever a non-zero probability of failure in every step of the system's\nexecution. For infinite-time horizon specifications, this implies that the\nspecification is violated with probability 1 in the long run no matter what\npolicy is chosen, which prevents previous policy computation methods from being\nuseful in these scenarios.\n  In this paper, we introduce a new optimization criterion for MDP policies\nthat captures the task of working towards the satisfaction of some\ninfinite-time horizon $\\omega$-regular specification. The new criterion is\napplicable to MDPs in which the violation of the specification cannot be\navoided in the long run. We give an algorithm to compute policies that are\noptimal in this criterion and show that it captures the ideas of optimism and\nrisk-averseness in MDP control: while the computed policies are optimistic in\nthat a MDP run enters a failure state relatively late, they are risk-averse by\nalways maximizing the probability to reach their respective next goal state. We\ngive results on two robot control scenarios to validate the usability of\nrisk-averse MDP policies.\n", "versions": [{"version": "v1", "created": "Tue, 22 Mar 2016 10:03:30 GMT"}, {"version": "v2", "created": "Tue, 2 May 2017 09:07:05 GMT"}], "update_date": "2017-05-03", "authors_parsed": [["Ehlers", "Ruediger", ""], ["Moarref", "Salar", ""], ["Topcu", "Ufuk", ""]]}, {"id": "1603.06844", "submitter": "Radu Iosif", "authors": "Andrew Reynolds and Radu Iosif and Tim King", "title": "A Decision Procedure for Separation Logic in SMT", "comments": "22 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a complete decision procedure for the entire\nquantifier-free fragment of Separation Logic ($\\seplog$) interpreted over\nheaplets with data elements ranging over a parametric multi-sorted (possibly\ninfinite) domain. The algorithm uses a combination of theories and is used as a\nspecialized solver inside a DPLL($T$) architecture. A prototype was implemented\nwithin the CVC4 SMT solver. Preliminary evaluation suggests the possibility of\nusing this procedure as a building block of a more elaborate theorem prover for\nSL with inductive predicates, or as back-end of a bounded model checker for\nprograms with low-level pointer and data manipulations.\n", "versions": [{"version": "v1", "created": "Tue, 22 Mar 2016 16:00:05 GMT"}, {"version": "v2", "created": "Thu, 19 May 2016 07:40:05 GMT"}], "update_date": "2016-05-20", "authors_parsed": [["Reynolds", "Andrew", ""], ["Iosif", "Radu", ""], ["King", "Tim", ""]]}, {"id": "1603.06850", "submitter": "Przemys{\\l}aw Daca", "authors": "Przemys{\\l}aw Daca, Thomas A. Henzinger, Andrey Kupriyanov", "title": "Array Folds Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an extension to the quantifier-free theory of integer arrays which\nallows us to express counting. The properties expressible in Array Folds Logic\n(AFL) include statements such as \"the first array cell contains the array\nlength,\" and \"the array contains equally many minimal and maximal elements.\"\nThese properties cannot be expressed in quantified fragments of the theory of\narrays, nor in the theory of concatenation. Using reduction to counter\nmachines, we show that the satisfiability problem of AFL is PSPACE-complete,\nand with a natural restriction the complexity decreases to NP. We also show\nthat adding either universal quantifiers or concatenation leads to\nundecidability.\n  AFL contains terms that fold a function over an array. We demonstrate that\nfolding, a well-known concept from functional languages, allows us to concisely\nsummarize loops that count over arrays, which occurs frequently in real-life\nprograms. We provide a tool that can discharge proof obligations in AFL, and we\ndemonstrate on practical examples that our decision procedure can solve a broad\nrange of problems in symbolic testing and program verification.\n", "versions": [{"version": "v1", "created": "Tue, 22 Mar 2016 16:10:47 GMT"}, {"version": "v2", "created": "Thu, 24 Mar 2016 19:49:04 GMT"}, {"version": "v3", "created": "Thu, 12 May 2016 14:41:29 GMT"}], "update_date": "2016-05-13", "authors_parsed": [["Daca", "Przemys\u0142aw", ""], ["Henzinger", "Thomas A.", ""], ["Kupriyanov", "Andrey", ""]]}, {"id": "1603.07030", "submitter": "Octavio Zapata", "authors": "Anuj Dawar, Simone Severini, Octavio Zapata", "title": "Descriptive complexity of graph spectra", "comments": "17 pages", "journal-ref": "Logic, Language, Information, and Computation: 23rd International\n  Workshop, WoLLIC 2016, Puebla, Mexico, August 16-19th, 2016", "doi": "10.1007/978-3-662-52921-8_12", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Two graphs are co-spectral if their respective adjacency matrices have the\nsame multi-set of eigenvalues. A graph is said to be determined by its spectrum\nif all graphs that are co-spectral with it are isomorphic to it. We consider\nthese properties in relation to logical definability. We show that any pair of\ngraphs that are elementarily equivalent with respect to the three-variable\ncounting first-order logic $C^3$ are co-spectral, and this is not the case with\n$C^2$, nor with any number of variables if we exclude counting quantifiers. We\nalso show that the class of graphs that are determined by their spectra is\ndefinable in partial fixed-point logic with counting. We relate these\nproperties to other algebraic and combinatorial problems.\n", "versions": [{"version": "v1", "created": "Tue, 22 Mar 2016 23:45:34 GMT"}, {"version": "v2", "created": "Wed, 25 May 2016 13:56:39 GMT"}, {"version": "v3", "created": "Wed, 1 Jun 2016 13:01:52 GMT"}, {"version": "v4", "created": "Fri, 24 Jun 2016 14:41:54 GMT"}, {"version": "v5", "created": "Wed, 14 Sep 2016 19:45:16 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Dawar", "Anuj", ""], ["Severini", "Simone", ""], ["Zapata", "Octavio", ""]]}, {"id": "1603.07218", "submitter": "Lionel Vaux", "authors": "Michele Pagani, Christine Tasson and Lionel Vaux", "title": "Strong Normalizability as a Finiteness Structure via the Taylor\n  Expansion of {\\lambda}-terms", "comments": "Presented at FoSSaCS 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the folklore of linear logic, a common intuition is that the structure of\nfiniteness spaces, introduced by Ehrhard, semantically reflects the strong\nnormalization property of cut-elimination. We make this intuition formal in the\ncontext of the non-deterministic {\\lambda}-calculus by introducing a finiteness\nstructure on resource terms, which is such that a {\\lambda}-term is strongly\nnormalizing iff the support of its Taylor expansion is finitary. An application\nof our result is the existence of a normal form for the Taylor expansion of any\nstrongly normalizable non-deterministic {\\lambda}-term.\n", "versions": [{"version": "v1", "created": "Wed, 23 Mar 2016 15:04:04 GMT"}], "update_date": "2016-03-24", "authors_parsed": [["Pagani", "Michele", ""], ["Tasson", "Christine", ""], ["Vaux", "Lionel", ""]]}, {"id": "1603.07256", "submitter": "Sebastian Muskalla", "authors": "Luk\\'a\\v{s} Hol\\'ik and Roland Meyer and Sebastian Muskalla", "title": "Summaries for Context-Free Games", "comments": "The conference version of this paper was accepted for FSTTCS 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study two-player games played on the infinite graph of sentential forms\ninduced by a context-free grammar (that comes with an ownership partitioning of\nthe non-terminals). The winning condition is inclusion of the derived terminal\nword in the language of a finite automaton. Our contribution is a new algorithm\nto decide the winning player and to compute her strategy. It is based on a\nnovel representation of all plays starting in a non-terminal. The\nrepresentation uses the domain of Boolean formulas over the transition monoid\nof the target automaton. The elements of the monoid are essentially procedure\nsummaries, and our approach can be seen as the first summary-based algorithm\nfor the synthesis of recursive programs. We show that our algorithm has optimal\n(doubly exponential) time complexity, that it is compatible with recent\nantichain optimizations, and that it admits a lazy evaluation strategy. Our\npreliminary experiments indeed show encouraging results, indicating a speed up\nof three orders of magnitude over a competitor.\n", "versions": [{"version": "v1", "created": "Wed, 23 Mar 2016 16:20:56 GMT"}, {"version": "v2", "created": "Wed, 20 Jul 2016 10:39:17 GMT"}, {"version": "v3", "created": "Fri, 9 Sep 2016 15:52:19 GMT"}, {"version": "v4", "created": "Tue, 1 Nov 2016 13:45:24 GMT"}], "update_date": "2016-11-02", "authors_parsed": [["Hol\u00edk", "Luk\u00e1\u0161", ""], ["Meyer", "Roland", ""], ["Muskalla", "Sebastian", ""]]}, {"id": "1603.07259", "submitter": "J\\\"urgen Koslowski", "authors": "Flavien Breuvart", "title": "On the characterization of models of H*: The semantical aspect", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 2 (April 27,\n  2016) lmcs:1636", "doi": "10.2168/LMCS-12(2:4)2016", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We give a characterization, with respect to a large class of models of\nuntyped lambda-calculus, of those models that are fully abstract for\nhead-normalization, i.e., whose equational theory is H* (observations for head\nnormalization). An extensional K-model $D$ is fully abstract if and only if it\nis hyperimmune, {\\em i.e.}, not well founded chains of elements of D cannot be\ncaptured by any recursive function.\n  This article, together with its companion paper, form the long version of\n[Bre14]. It is a standalone paper that presents a purely semantical proof of\nthe result as opposed to its companion paper that presents an independent and\npurely syntactical proof of the same result.\n", "versions": [{"version": "v1", "created": "Wed, 23 Mar 2016 16:41:59 GMT"}, {"version": "v2", "created": "Tue, 26 Apr 2016 06:58:04 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Breuvart", "Flavien", ""]]}, {"id": "1603.07453", "submitter": "Bruno Woltzenlogel Paleo", "authors": "Bruno Woltzenlogel Paleo", "title": "An Expressive Probabilistic Temporal Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  This paper argues that a combined treatment of probabilities, time and\nactions is essential for an appropriate logical account of the notion of\nprobability; and, based on this intuition, describes an expressive\nprobabilistic temporal logic for reasoning about actions with uncertain\noutcomes. The logic is modal and higher-order: modalities annotated by actions\nare used to express possibility and necessity of propositions in the next\nstates resulting from the actions, and a higher-order function is needed to\nexpress the probability operator. The proposed logic is shown to be an adequate\nextension of classical mathematical probability theory, and its expressiveness\nis illustrated through the formalization of the Monty Hall problem.\n", "versions": [{"version": "v1", "created": "Thu, 24 Mar 2016 07:00:33 GMT"}, {"version": "v2", "created": "Sun, 8 Oct 2017 02:02:49 GMT"}], "update_date": "2017-10-10", "authors_parsed": [["Paleo", "Bruno Woltzenlogel", ""]]}, {"id": "1603.07458", "submitter": "Michel Levy", "authors": "Michel L\\'evy", "title": "The method \"Model Elimination\" of D.W.Loveland explained", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present concisely the method \"Model Elimination\" of D.W.Loveland.\nEspecially, we explain and prove the correctness of the lemmas generated by\nthis method.\n", "versions": [{"version": "v1", "created": "Thu, 24 Mar 2016 07:46:04 GMT"}, {"version": "v2", "created": "Wed, 29 Jun 2016 13:40:15 GMT"}], "update_date": "2016-06-30", "authors_parsed": [["L\u00e9vy", "Michel", ""]]}, {"id": "1603.07484", "submitter": "Rodolphe Lepigre", "authors": "Rodolphe Lepigre (LAMA)", "title": "A Classical Realizability Model for a Semantical Value Restriction", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-662-49498-1_19", "report-no": null, "categories": "cs.LO cs.PL math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new type system with support for proofs of programs in a\ncall-by-value language with control operators. The proof mechanism relies on\nobservational equivalence of (untyped) programs. It appears in two type\nconstructors, which are used for specifying program properties and for encoding\ndependent products. The main challenge arises from the lack of expressiveness\nof dependent products due to the value restriction. To circumvent this\nlimitation we relax the syntactic restriction and only require equivalence to a\nvalue. The consistency of the system is obtained semantically by constructing a\nclassical realizability model in three layers (values, stacks and terms).\n", "versions": [{"version": "v1", "created": "Thu, 24 Mar 2016 09:00:30 GMT"}, {"version": "v2", "created": "Thu, 7 Apr 2016 13:48:16 GMT"}], "update_date": "2016-04-08", "authors_parsed": [["Lepigre", "Rodolphe", "", "LAMA"]]}, {"id": "1603.07735", "submitter": "Shane Mansfield", "authors": "Samson Abramsky, Rui Soares Barbosa, Kohei Kishida, Raymond Lal, Shane\n  Mansfield", "title": "Possibilities Determine the Combinatorial Structure of Probability\n  Polytopes", "comments": null, "journal-ref": "In special issue on Foundations of Probability Theory in\n  Psychology and Beyond, Journal of Mathematical Psychology, 74: 58--65, 2016", "doi": "10.1016/j.jmp.2016.03.006", "report-no": null, "categories": "quant-ph cs.LO math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the set of no-signalling empirical models on a measurement scenario,\nand show that the combinatorial structure of the no-signalling polytope is\ncompletely determined by the possibilistic information given by the support of\nthe models. This is a special case of a general result which applies to all\npolytopes presented in a standard form, given by linear equations together with\nnon-negativity constraints on the variables.\n", "versions": [{"version": "v1", "created": "Thu, 24 Mar 2016 20:03:46 GMT"}], "update_date": "2018-07-03", "authors_parsed": [["Abramsky", "Samson", ""], ["Barbosa", "Rui Soares", ""], ["Kishida", "Kohei", ""], ["Lal", "Raymond", ""], ["Mansfield", "Shane", ""]]}, {"id": "1603.08204", "submitter": "Zhiguang Zhao", "authors": "Giuseppe Greco, Minghui Ma, Alessandra Palmigiano, Apostolos\n  Tzimoulis, Zhiguang Zhao", "title": "Unified Correspondence as a Proof-Theoretic Tool", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The present paper aims at establishing formal connections between\ncorrespondence phenomena, well known from the area of modal logic, and the\ntheory of display calculi, originated by Belnap. These connections have been\nseminally observed and exploited by Marcus Kracht, in the context of his\ncharacterization of the modal axioms (which he calls primitive formulas) which\ncan be effectively transformed into `analytic' structural rules of display\ncalculi. In this context, a rule is `analytic' if adding it to a display\ncalculus preserves Belnap's cut-elimination theorem. In recent years, the\nstate-of-the-art in correspondence theory has been uniformly extended from\nclassical modal logic to diverse families of nonclassical logics, ranging from\n(bi-)intuitionistic (modal) logics, linear, relevant and other substructural\nlogics, to hybrid logics and mu-calculi. This generalization has given rise to\na theory called unified correspondence, the most important technical tools of\nwhich are the algorithm ALBA, and the syntactic characterization of\nSahlqvist-type classes of formulas and inequalities which is uniform in the\nsetting of normal DLE-logics (logics the algebraic semantics of which is based\non bounded distributive lattices). We apply unified correspondence theory, with\nits tools and insights, to extend Kracht's results and prove his claims in the\nsetting of DLE-logics. The results of the present paper characterize the space\nof properly displayable DLE-logics.\n", "versions": [{"version": "v1", "created": "Sun, 27 Mar 2016 11:08:09 GMT"}], "update_date": "2016-03-29", "authors_parsed": [["Greco", "Giuseppe", ""], ["Ma", "Minghui", ""], ["Palmigiano", "Alessandra", ""], ["Tzimoulis", "Apostolos", ""], ["Zhao", "Zhiguang", ""]]}, {"id": "1603.08206", "submitter": "Zhiguang Zhao", "authors": "Maria Esteban, Alessandra Palmigiano, Zhiguang Zhao", "title": "An Abstract Algebraic Logic View on Judgment Aggregation", "comments": "This is an extended version with details of proofs of the proceeding\n  paper with the same title, in Logic, Rationality and Interaction: Proceedings\n  of 5th International Workshop, LORI 2015, Taipei, Taiwan, October 28-30,\n  2015, Lecture Notes in Computer Science, Volume 9394, page 77-89", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the present paper, we propose Abstract Algebraic Logic (AAL) as a general\nlogical framework for Judgment Aggregation. Our main contribution is a\ngeneralization of Herzberg's algebraic approach to characterization results in\non judgment aggregation and propositional-attitude aggregation, characterizing\ncertain Arrovian classes of aggregators as Boolean algebra and MV-algebra\nhomomorphisms, respectively. The characterization result of the present paper\napplies to agendas of formulas of an arbitrary selfextensional logic. This\nnotion comes from AAL, and encompasses a vast class of logics, of which\nclassical, intuitionistic, modal, many-valued and relevance logics are special\ncases. To each selfextensional logic $\\Sm$, a unique class of algebras\n$\\Alg\\Sm$ is canonically associated by the general theory of AAL. We show that\nfor any selfextensional logic $\\Sm$ such that $\\Alg\\Sm$ is closed under direct\nproducts, any algebra in $\\Alg\\Sm$ can be taken as the set of truth values on\nwhich an aggregation problem can be formulated. In this way, judgment\naggregation on agendas formalized in classical, intuitionistic, modal,\nmany-valued and relevance logic can be uniformly captured as special cases.\nThis paves the way to the systematic study of a wide array of \"realistic\nagendas\" made up of complex formulas, the propositional connectives of which\nare interpreted in ways which depart from their classical interpretation. This\nis particularly interesting given that, as observed by Dietrich, nonclassical\n(subjunctive) interpretation of logical connectives can provide a strategy for\nescaping impossibility results.\n", "versions": [{"version": "v1", "created": "Sun, 27 Mar 2016 11:53:56 GMT"}], "update_date": "2016-03-29", "authors_parsed": [["Esteban", "Maria", ""], ["Palmigiano", "Alessandra", ""], ["Zhao", "Zhiguang", ""]]}, {"id": "1603.08213", "submitter": "Beno\\^it Valiron", "authors": "Benoit Valiron", "title": "Generating reversible circuits from higher-order functional programs", "comments": "21 pages. A shorter preprint has been accepted for publication in the\n  Proceedings of Reversible Computation 2016. The final publication is\n  available at http://link.springer.com", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Boolean reversible circuits are boolean circuits made of reversible\nelementary gates. Despite their constrained form, they can simulate any boolean\nfunction. The synthesis and validation of a reversible circuit simulating a\ngiven function is a difficult problem. In 1973, Bennett proposed to generate\nreversible circuits from traces of execution of Turing machines. In this paper,\nwe propose a novel presentation of this approach, adapted to higher-order\nprograms. Starting with a PCF-like language, we use a monadic representation of\nthe trace of execution to turn a regular boolean program into a\ncircuit-generating code. We show that a circuit traced out of a program\ncomputes the same boolean function as the original program. This technique has\nbeen successfully applied to generate large oracles with the quantum\nprogramming language Quipper.\n", "versions": [{"version": "v1", "created": "Sun, 27 Mar 2016 12:49:26 GMT"}], "update_date": "2016-03-29", "authors_parsed": [["Valiron", "Benoit", ""]]}, {"id": "1603.08246", "submitter": "Yuchen Zhou", "authors": "Yuchen Zhou, Dipankar Maity and John S. Baras", "title": "Timed Automata Approach for Motion Planning Using Metric Interval\n  Temporal Logic", "comments": "Full Version for ECC 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SY cs.LO cs.RO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we consider the robot motion (or task) planning problem under\nsome given time bounded high level specifications. We use metric interval\ntemporal logic (MITL), a member of the temporal logic family, to represent the\ntask specification and then we provide a constructive way to generate a timed\nautomaton and methods to look for accepting runs on the automaton to find a\nfeasible motion (or path) sequence for the robot to complete the task.\n", "versions": [{"version": "v1", "created": "Sun, 27 Mar 2016 19:12:27 GMT"}, {"version": "v2", "created": "Tue, 29 Mar 2016 03:16:41 GMT"}], "update_date": "2016-03-30", "authors_parsed": [["Zhou", "Yuchen", ""], ["Maity", "Dipankar", ""], ["Baras", "John S.", ""]]}, {"id": "1603.08264", "submitter": "Luca Reggio", "authors": "Mai Gehrke, Daniela Petrisan, Luca Reggio", "title": "The Sch\\\"utzenberger product for syntactic spaces", "comments": "21 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL math.GN math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Starting from Boolean algebras of languages closed under quotients and using\nduality theoretic insights, we derive the notion of Boolean spaces with\ninternal monoids as recognisers for arbitrary formal languages of finite words\nover finite alphabets. This leads to a setting that is well-suited for applying\nexisting tools from Stone duality as applied in semantics. The main focus of\nthe paper is the development of topo-algebraic constructions pertinent to the\ntreatment of languages given by logic formulas. In particular, using the\nstandard semantic view of quantification as projection, we derive a notion of\nSch\\\"utzenberger product for Boolean spaces with internal monoids. This makes\nheavy use of the Vietoris construction, and its dual functor, which is central\nto the coalgebraic treatment of classical modal logic. We show that the unary\nSch\\\"utzenberger product for spaces, when applied to a recogniser for the\nlanguage associated to a formula with a free first-order variable, yields a\nrecogniser for the language of all models of the corresponding existentially\nquantified formula. Further, we generalise global and local versions of the\ntheorems of Sch\\\"utzenberger and Reutenauer characterising the languages\nrecognised by the binary Sch\\\"utzenberger product. Finally, we provide an\nequational characterisation of Boolean algebras obtained by local\nSch\\\"utzenberger product with the one element space based on an Egli-Milner\ntype condition on generalised factorisations of ultrafilters on words.\n", "versions": [{"version": "v1", "created": "Sun, 27 Mar 2016 22:27:49 GMT"}], "update_date": "2016-03-29", "authors_parsed": [["Gehrke", "Mai", ""], ["Petrisan", "Daniela", ""], ["Reggio", "Luca", ""]]}, {"id": "1603.08633", "submitter": "EPTCS", "authors": "Sarmen Keshishzadeh (Eindhoven University of Technology), Arjan J.\n  Mooij (Embedded Systems Innovation by TNO), Jozef Hooman (Embedded Systems\n  Innovation by TNO and Radboud University Nijmegen)", "title": "Industrial Experiences with a Formal DSL Semantics to Check the\n  Correctness of DSL Artifacts", "comments": "In Proceedings FESCA 2016, arXiv:1603.08371", "journal-ref": "EPTCS 205, 2016, pp. 16-30", "doi": "10.4204/EPTCS.205.2", "report-no": null, "categories": "cs.SE cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A domain specific language (DSL) abstracts from implementation details and is\naligned with the way domain experts reason about a software component. The\ndevelopment of DSLs is usually centered around a grammar and transformations\nthat generate implementation code or analysis models. The semantics of the\nlanguage is often defined implicitly and in terms of a transformation to\nimplementation code. In the presence of multiple transformations from the DSL,\nthe correctness of the generated artifacts with respect to the semantics of the\nDSL is a relevant issue. We show that a formal semantics is essential for\nchecking the correctness of the generated artifacts. We exploit the formal\nsemantics in an industrial project and use formal techniques based on\nequivalence checking and model-based testing for validating the correctness of\nthe generated artifacts. We report about our experience with this approach in\nan industrial development project.\n", "versions": [{"version": "v1", "created": "Tue, 29 Mar 2016 04:34:04 GMT"}], "update_date": "2016-03-30", "authors_parsed": [["Keshishzadeh", "Sarmen", "", "Eindhoven University of Technology"], ["Mooij", "Arjan J.", "", "Embedded Systems Innovation by TNO"], ["Hooman", "Jozef", "", "Embedded Systems\n  Innovation by TNO and Radboud University Nijmegen"]]}, {"id": "1603.08769", "submitter": "Andrew Gacek", "authors": "Tuan-Hung Pham, Andrew Gacek, Michael W. Whalen", "title": "Reasoning about Algebraic Data Types with Abstractions", "comments": "To appear in Journal of Automated Reasoning", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Reasoning about functions that operate over algebraic data types is an\nimportant problem for a large variety of applications. One application of\nparticular interest is network applications that manipulate or reason about\ncomplex message structures, such as XML messages. This paper presents a\ndecision procedure for reasoning about algebraic data types using abstractions\nthat are provided by catamorphisms: fold functions that map instances of\nalgebraic data types to values in a decidable domain. We show that the\nprocedure is sound and complete for a class of catamorphisms that satisfy a\ngeneralized sufficient surjectivity condition. Our work extends a previous\ndecision procedure that unrolls catamorphism functions until a solution is\nfound.\n  We use the generalized sufficient surjectivity condition to address an\nincompleteness in the previous unrolling algorithm (and associated proof). We\nthen propose the categories of monotonic and associative catamorphisms, which\nwe argue provide a more intuitive inclusion test than the generalized\nsufficient surjectivity condition. We use these notions to address two open\nproblems from previous work: (1) we provide a bound, with respect to formula\nsize, on the number of unrollings necessary for completeness, showing that it\nis linear for monotonic catamorphisms and exponentially small for associative\ncatamorphisms, and (2) we demonstrate that associative catamorphisms can be\ncombined within a formula while preserving completeness. Our combination\nresults extend the set of problems that can be reasoned about using the\ncatamorphism-based approach.\n  We also describe an implementation of the approach, called RADA, which\naccepts formulas in an extended version of the SMT-LIB 2.0 syntax. The\nprocedure is quite general and is central to the reasoning infrastructure for\nGuardol, a domain-specific language for reasoning about network guards.\n", "versions": [{"version": "v1", "created": "Tue, 29 Mar 2016 13:35:24 GMT"}], "update_date": "2016-03-30", "authors_parsed": [["Pham", "Tuan-Hung", ""], ["Gacek", "Andrew", ""], ["Whalen", "Michael W.", ""]]}, {"id": "1603.09055", "submitter": "Frederik Harwath", "authors": "Kord Eickmeyer, Michael Elberfeld, Frederik Harwath", "title": "Succinctness of Order-Invariant Logics on Depth-Bounded Structures", "comments": "A preliminary version of this paper was presented at MFCS 2014", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the expressive power and succinctness of order-invariant sentences\nof first-order (FO) and monadic second-order (MSO) logic on structures of\nbounded tree-depth. Order- invariance is undecidable in general and, thus, one\nstrives for logics with a decidable syntax that have the same expressive power\nas order-invariant sentences. We show that on structures of bounded tree-depth,\norder-invariant FO has the same expressive power as FO. Our proof technique\nallows for a fine-grained analysis of the succinctness of this translation. We\nshow that for every order-invariant FO sentence there exists an FO sentence\nwhose size is elementary in the size of the original sentence, and whose number\nof quantifier alternations is linear in the tree-depth. We obtain similar\nresults for MSO. It is known that the expressive power of MSO and FO coincide\non structures of bounded tree-depth. We provide a translation from MSO to FO\nand we show that this translation is essentially optimal regarding the formula\nsize. As a further result, we show that order-invariant MSO has the same\nexpressive power as FO with modulo-counting quantifiers on bounded tree-depth\nstructures.\n", "versions": [{"version": "v1", "created": "Wed, 30 Mar 2016 07:14:35 GMT"}], "update_date": "2016-03-31", "authors_parsed": [["Eickmeyer", "Kord", ""], ["Elberfeld", "Michael", ""], ["Harwath", "Frederik", ""]]}, {"id": "1603.09286", "submitter": "Eduardo Ferm\\'e", "authors": "Marco Garapa, Eduardo Ferm\\'e, Maur\\'icio D. L. Reis", "title": "Studies on Brutal Contraction and Severe Withdrawal: Preliminary Report", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we study the class of brutal base contractions that are based\non a bounded ensconcement and also the class of severe withdrawals which are\nbased on bounded epistemic entrenchment relations that are defined by means of\nbounded ensconcements (using the procedure proposed by Mary-Anne Williams). We\npresent axiomatic characterizations for each one of those classes of functions\nand investigate the interrelation among them.\n", "versions": [{"version": "v1", "created": "Wed, 30 Mar 2016 17:30:32 GMT"}], "update_date": "2016-03-31", "authors_parsed": [["Garapa", "Marco", ""], ["Ferm\u00e9", "Eduardo", ""], ["Reis", "Maur\u00edcio D. L.", ""]]}, {"id": "1603.09300", "submitter": "J\\\"urgen Koslowski", "authors": "John Case and Michael Ralston", "title": "Non-Obfuscated Unprovable Programs & Many Resultant Subtleties", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 2 (April 20,\n  2016) lmcs:1634", "doi": "10.2168/LMCS-12(2:2)2016", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The \\emph{International Obfuscated C Code Contest} was a programming contest\nfor the most creatively obfuscated yet succinct C code. By \\emph{contrast}, an\ninterest herein is in programs which are, \\emph{in a sense}, \\emph{easily} seen\nto be correct, but which can\\emph{not} be proved correct in pre-assigned,\ncomputably axiomatized, powerful, true theories {\\bf T}. A point made by our\nfirst theorem, then, is that, then, \\emph{un}verifiable programs need\n\\emph{not} be obfuscated!\n  The first theorem and its proof is followed by a motivated, concrete example\nbased on a remark of Hilary Putnam.\n  The first theorem has some non-constructivity in its statement and proof, and\nthe second theorem implies some of the non-constructivity is inherent. That\nresult, then, brings up the question of whether there is an acceptable\nprogramming system (numbering) for which some non-constructivity of the first\ntheorem disappears. The third theorem shows this is the case, but for a subtle\nreason explained in the text. This latter theorem has a number of corollaries,\nregarding its acceptable programming system, and providing some surprises and\nsubtleties about proving its program properties (including universality, and\nthe presence of the composition control structure). The next two theorems\nprovide acceptable systems with contrasting surprises regarding proving\nuniversality in them. Finally the next and last theorem (the most difficult to\nprove in the paper) provides an acceptable system with some positive and\nnegative surprises regarding verification of its true program properties: the\nexistence of the control structure composition is provable for it, but anything\nabout true I/O-program equivalence for syntactically unequal programs is not\nprovable.\n", "versions": [{"version": "v1", "created": "Wed, 30 Mar 2016 18:20:05 GMT"}, {"version": "v2", "created": "Tue, 19 Apr 2016 12:29:35 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Case", "John", ""], ["Ralston", "Michael", ""]]}, {"id": "1603.09465", "submitter": "Zhiqiang Zhuang", "authors": "Zhiqiang Zhuang, James Delgrande, Abhaya Nayak, Abdul Sattar", "title": "A New Approach for Revising Logic Programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Belief revision has been studied mainly with respect to background logics\nthat are monotonic in character. In this paper we study belief revision when\nthe underlying logic is non-monotonic instead--an inherently interesting\nproblem that is under explored. In particular, we will focus on the revision of\na body of beliefs that is represented as a logic program under the answer set\nsemantics, while the new information is also similarly represented as a logic\nprogram. Our approach is driven by the observation that unlike in a monotonic\nsetting where, when necessary, consistency in a revised body of beliefs is\nmaintained by jettisoning some old beliefs, in a non-monotonic setting\nconsistency can be restored by adding new beliefs as well. We will define a\nsyntactic revision function and subsequently provide representation theorem for\ncharacterising it.\n", "versions": [{"version": "v1", "created": "Thu, 31 Mar 2016 06:27:16 GMT"}], "update_date": "2016-04-05", "authors_parsed": [["Zhuang", "Zhiqiang", ""], ["Delgrande", "James", ""], ["Nayak", "Abhaya", ""], ["Sattar", "Abdul", ""]]}, {"id": "1603.09488", "submitter": "Andrey Luxemburg", "authors": "Andrey Luxemburg", "title": "Building the Signature of Set Theory Using the MathSem Program", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Knowledge representation is a popular research field in IT. As mathematical\nknowledge is most formalized, its representation is important and interesting.\nMathematical knowledge consists of various mathematical theories. In this paper\nwe consider a deductive system that derives mathematical notions, axioms and\ntheorems. All these notions, axioms and theorems can be considered as the part\nof elementary set theory. This theory will be represented as a semantic net.\n", "versions": [{"version": "v1", "created": "Thu, 31 Mar 2016 08:41:22 GMT"}], "update_date": "2016-04-01", "authors_parsed": [["Luxemburg", "Andrey", ""]]}, {"id": "1603.09495", "submitter": "Zeynep G\\\"ozen Saribatur", "authors": "Zeynep G. Saribatur, Thomas Eiter", "title": "Reactive Policies with Planning for Action Languages", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a representation in a high-level transition system for policies\nthat express a reactive behavior for the agent. We consider a target decision\ncomponent that figures out what to do next and an (online) planning capability\nto compute the plans needed to reach these targets. Our representation allows\none to analyze the flow of executing the given reactive policy, and to\ndetermine whether it works as expected. Additionally, the flexibility of the\nrepresentation opens a range of possibilities for designing behaviors.\n", "versions": [{"version": "v1", "created": "Thu, 31 Mar 2016 09:05:28 GMT"}], "update_date": "2016-04-01", "authors_parsed": [["Saribatur", "Zeynep G.", ""], ["Eiter", "Thomas", ""]]}, {"id": "1603.09531", "submitter": "Anselm Haak", "authors": "Anselm Haak, Heribert Vollmer", "title": "A Model-Theoretic Characterization of Constant-Depth Arithmetic Circuits", "comments": null, "journal-ref": null, "doi": "10.1016/j.apal.2019.04.006", "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the class $\\textrm{AC}^0$ of functions computed by constant-depth\npolynomial-size arithmetic circuits of unbounded fan-in addition and\nmultiplication gates. No model-theoretic characterization for arithmetic\ncircuit classes is known so far. Inspired by Immerman's characterization of the\nBoolean class $\\textrm{AC}^0$, we remedy this situation and develop such a\ncharacterization of $\\textrm{AC}^0$. Our characterization can be interpreted as\nfollows: Functions in $\\textrm{AC}^0$ are exactly those functions counting\nwinning strategies in first-order model checking games. A consequence of our\nresults is a new model-theoretic characterization of $\\textrm{TC}^0$, the class\nof languages accepted by constant-depth polynomial-size majority circuits.\n", "versions": [{"version": "v1", "created": "Thu, 31 Mar 2016 11:27:20 GMT"}, {"version": "v2", "created": "Thu, 5 Oct 2017 09:04:16 GMT"}], "update_date": "2020-05-08", "authors_parsed": [["Haak", "Anselm", ""], ["Vollmer", "Heribert", ""]]}, {"id": "1603.09545", "submitter": "Thomas Linsbichler", "authors": "Thomas Linsbichler, J\\\"org P\\\"uhrer and Hannes Strass", "title": "Characterizing Realizability in Abstract Argumentation", "comments": "Contribution to the 16h International Workshop on Non-Monotonic\n  Reasoning, 2016, Cape Town", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Realizability for knowledge representation formalisms studies the following\nquestion: given a semantics and a set of interpretations, is there a knowledge\nbase whose semantics coincides exactly with the given interpretation set? We\nintroduce a general framework for analyzing realizability in abstract\ndialectical frameworks (ADFs) and various of its subclasses. In particular, the\nframework applies to Dung argumentation frameworks, SETAFs by Nielsen and\nParsons, and bipolar ADFs. We present a uniform characterization method for the\nadmissible, complete, preferred and model/stable semantics. We employ this\nmethod to devise an algorithm that decides realizability for the mentioned\nformalisms and semantics; moreover the algorithm allows for constructing a\ndesired knowledge base whenever one exists. The algorithm is built in a modular\nway and thus easily extensible to new formalisms and semantics. We have also\nimplemented our approach in answer set programming, and used the implementation\nto obtain several novel results on the relative expressiveness of the\nabovementioned formalisms.\n", "versions": [{"version": "v1", "created": "Thu, 31 Mar 2016 12:05:34 GMT"}], "update_date": "2016-04-01", "authors_parsed": [["Linsbichler", "Thomas", ""], ["P\u00fchrer", "J\u00f6rg", ""], ["Strass", "Hannes", ""]]}, {"id": "1603.09617", "submitter": "Francesco Scarcello", "authors": "Gianluigi Greco and Francesco Scarcello", "title": "Greedy Strategies and Larger Islands of Tractability for Conjunctive\n  Queries and Constraint Satisfaction Problems", "comments": "arXiv admin note: substantial text overlap with arXiv:1205.3321", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Structural decomposition methods have been developed for identifying\ntractable classes of instances of fundamental problems in databases, such as\nconjunctive queries and query containment, of the constraint satisfaction\nproblem in artificial intelligence, or more generally of the homomorphism\nproblem over relational structures. Most structural decomposition methods can\nbe characterized through hypergraph games that are variations of the Robber and\nCops graph game that characterizes the notion of treewidth. In particular,\ndecomposition trees somehow correspond to monotone winning strategies, where\nthe escape space of the robber on the hypergraph is shrunk monotonically by the\ncops. In fact, unlike the treewidth case, there are hypergraphs where monotonic\nstrategies do not exist, while the robber can be captured by means of more\ncomplex non-monotonic strategies. However, these powerful strategies do not\ncorrespond in general to valid decompositions. The paper provides a general way\nto exploit the power of non-monotonic strategies, by allowing a \"disciplined\"\nform of non-monotonicity, characteristic of cops playing in a greedy way. It is\nshown that deciding the existence of a (non-monotone) greedy winning strategy\n(and compute one, if any) is tractable. Moreover, despite their\nnon-monotonicity, such strategies always induce valid decomposition trees,\nwhich can be computed efficiently based on them. As a consequence, greedy\nstrategies allow us to define new islands of tractability for the considered\nproblems properly including all previously known classes of tractable\ninstances.\n", "versions": [{"version": "v1", "created": "Thu, 31 Mar 2016 14:57:33 GMT"}, {"version": "v2", "created": "Mon, 4 Jul 2016 21:20:28 GMT"}], "update_date": "2016-07-06", "authors_parsed": [["Greco", "Gianluigi", ""], ["Scarcello", "Francesco", ""]]}]