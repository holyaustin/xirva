[{"id": "1609.00091", "submitter": "Gaogao Yan", "authors": "Gaogao Yan, Li Jiao, Yangjia Li, Shuling Wang and Naijun Zhan", "title": "Approximate Bisimulation and Discretization of Hybrid CSP", "comments": "FM 2016, Proof Appendix, HCSP, approximately bisimilar, hybrid\n  systems, discretization", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hybrid Communicating Sequential Processes (HCSP) is a powerful formal\nmodeling language for hybrid systems, which is an extension of CSP by\nintroducing differential equations for modeling continuous evolution and\ninterrupts for modeling interaction between continuous and discrete dynamics.\nIn this paper, we investigate the semantic foundation for HCSP from an\noperational point of view by proposing notion of approximate bisimulation,\nwhich provides an appropriate criterion to characterize the equivalence between\nHCSP processes with continuous and discrete behaviour. We give an algorithm to\ndetermine whether two HCSP processes are approximately bisimilar. In addition,\nbased on that, we propose an approach on how to discretize HCSP, i.e., given an\nHCSP process A, we construct another HCSP process B which does not contain any\ncontinuous dynamics such that A and B are approximately bisimilar with given\nprecisions. This provides a rigorous way to transform a verified control model\nto a correct program model, which fills the gap in the design of embedded\nsystems.\n", "versions": [{"version": "v1", "created": "Thu, 1 Sep 2016 02:23:22 GMT"}, {"version": "v2", "created": "Thu, 8 Sep 2016 02:52:03 GMT"}], "update_date": "2016-09-09", "authors_parsed": [["Yan", "Gaogao", ""], ["Jiao", "Li", ""], ["Li", "Yangjia", ""], ["Wang", "Shuling", ""], ["Zhan", "Naijun", ""]]}, {"id": "1609.00118", "submitter": "Robert Colvin", "authors": "Ian J. Hayes, Robert Colvin, Larissa Meinicke, Kirsten Winter, and\n  Andrius Velykis", "title": "An algebra of synchronous atomic steps", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This research started with an algebra for reasoning about rely/guarantee\nconcurrency for a shared memory model. The approach taken led to a more\nabstract algebra of atomic steps, in which atomic steps synchronise (rather\nthan interleave) when composed in parallel. The algebra of rely/guarantee\nconcurrency then becomes an interpretation of the more abstract algebra. Many\nof the core properties needed for rely/guarantee reasoning can be shown to hold\nin the abstract algebra where their proofs are simpler and hence allow a higher\ndegree of automation. Moreover, the realisation that the synchronisation\nmechanisms of standard process algebras, such as CSP and CCS/SCCS, can be\ninterpreted in our abstract algebra gives evidence of its unifying power. The\nalgebra has been encoded in Isabelle/HOL to provide a basis for tool support.\n", "versions": [{"version": "v1", "created": "Thu, 1 Sep 2016 06:10:00 GMT"}, {"version": "v2", "created": "Thu, 6 Oct 2016 04:37:26 GMT"}], "update_date": "2016-10-07", "authors_parsed": [["Hayes", "Ian J.", ""], ["Colvin", "Robert", ""], ["Meinicke", "Larissa", ""], ["Winter", "Kirsten", ""], ["Velykis", "Andrius", ""]]}, {"id": "1609.00132", "submitter": "K. V. Krishna", "authors": "Gayatri Panicker, K. V. Krishna, Purandar Bhaduri", "title": "Axiomatization of if-then-else over possibly non-halting programs and\n  tests", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In order to study the axiomatization of the if-then-else construct over\npossibly non-halting programs and tests, this paper introduces the notion of\n$C$-sets by considering the tests from an abstract $C$-algebra. When the\n$C$-algebra is an ada, the axiomatization is shown to be complete by obtaining\na subdirect representation of $C$-sets. Further, this paper considers the\nequality test with the if-then-else construct and gives a complete\naxiomatization through the notion of agreeable $C$-sets.\n", "versions": [{"version": "v1", "created": "Thu, 1 Sep 2016 07:35:07 GMT"}], "update_date": "2016-09-02", "authors_parsed": [["Panicker", "Gayatri", ""], ["Krishna", "K. V.", ""], ["Bhaduri", "Purandar", ""]]}, {"id": "1609.00169", "submitter": "Rajdeep Mukherjee", "authors": "Rajdeep Mukherjee, Saurabh Joshi, Andreas Griesmayer, Daniel Kroening,\n  Tom Melham", "title": "Equivalence Checking a Floating-point Unit against a High-level C Model\n  (Extended Version)", "comments": "14 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Semiconductor companies have increasingly adopted a methodology that starts\nwith a system-level design specification in C/C++/SystemC. This model is\nextensively simulated to ensure correct functionality and performance. Later, a\nRegister Transfer Level (RTL) implementation is created in Verilog, either\nmanually by a designer or automatically by a high-level synthesis tool. It is\nessential to check that the C and Verilog programs are consistent. In this\npaper, we present a two-step approach, embodied in two equivalence checking\ntools, VERIFOX and HW-CBMC, to validate designs at the software and RTL levels,\nrespectively. VERIFOX is used for equivalence checking of an untimed software\nmodel in C against a high-level reference model in C. HW-CBMC verifies the\nequivalence of a Verilog RTL implementation against an untimed software model\nin C. To evaluate our tools, we applied them to a commercial floating-point\narithmetic unit (FPU) from ARM and an open-source dual-path floating-point\nadder.\n", "versions": [{"version": "v1", "created": "Thu, 1 Sep 2016 09:55:30 GMT"}], "update_date": "2016-09-02", "authors_parsed": [["Mukherjee", "Rajdeep", ""], ["Joshi", "Saurabh", ""], ["Griesmayer", "Andreas", ""], ["Kroening", "Daniel", ""], ["Melham", "Tom", ""]]}, {"id": "1609.00195", "submitter": "Robert Colvin", "authors": "Robert J. Colvin, Ian J. Hayes, Larissa A. Meinicke", "title": "Designing a semantic model for a wide-spectrum language with concurrency", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A wide-spectrum language integrates specification constructs into a\nprogramming language in a manner that treats a specification command just like\nany other command. This paper investigates a semantic model for a wide-spectrum\nlanguage that supports concurrency and a refinement calculus. In order to\nhandle specifications with rely and guarantee conditions, the model includes\nexplicit environment steps as well as program steps. A novelty of our approach\nis that we define a set of primitive commands and operators, from which more\ncomplex specification and programming language commands are built. The\nprimitives have simple algebraic properties which support proof using algebraic\nreasoning. The model is general enough to specify notions as diverse as\nrely-guarantee reasoning, temporal logic, and progress properties of programs,\nand supports refining specifications to code. It also forms an instance of an\nabstract concurrent program algebra, which facilitates reasoning about\nproperties of the model at a high level of abstraction.\n", "versions": [{"version": "v1", "created": "Thu, 1 Sep 2016 11:50:02 GMT"}], "update_date": "2016-09-02", "authors_parsed": [["Colvin", "Robert J.", ""], ["Hayes", "Ian J.", ""], ["Meinicke", "Larissa A.", ""]]}, {"id": "1609.00322", "submitter": "Giulio Guerrieri", "authors": "Beniamino Accattoli, Giulio Guerrieri", "title": "Open Call-by-Value (Extended Version)", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The elegant theory of the call-by-value lambda-calculus relies on weak\nevaluation and closed terms, that are natural hypotheses in the study of\nprogramming languages. To model proof assistants, however, strong evaluation\nand open terms are required, and it is well known that the operational\nsemantics of call-by-value becomes problematic in this case. Here we study the\nintermediate setting -- that we call Open Call-by-Value -- of weak evaluation\nwith open terms, on top of which Gr\\'egoire and Leroy designed the abstract\nmachine of Coq. Various calculi for Open Call-by-Value already exist, each one\nwith its pros and cons. This paper presents a detailed comparative study of the\noperational semantics of four of them, coming from different areas such as the\nstudy of abstract machines, denotational semantics, linear logic proof nets,\nand sequent calculus. We show that these calculi are all equivalent from a\ntermination point of view, justifying the slogan Open Call-by-Value.\n", "versions": [{"version": "v1", "created": "Thu, 1 Sep 2016 17:15:45 GMT"}, {"version": "v2", "created": "Mon, 19 Sep 2016 20:39:25 GMT"}], "update_date": "2016-09-21", "authors_parsed": [["Accattoli", "Beniamino", ""], ["Guerrieri", "Giulio", ""]]}, {"id": "1609.00507", "submitter": "EPTCS", "authors": "Swen Jacobs (Saarland University), Roderick Bloem (Graz University of\n  Technology), Romain Brenguier (University of Oxford), Ayrat Khalimov (Graz\n  University of Technology), Felix Klein (Saarland University), Robert\n  K\\\"onighofer (Graz University of Technology), Jens Kreber (Saarland\n  University), Alexander Legg (Data 61, CSIRO (formerly NICTA) and UNSW), Nina\n  Narodytska (Samsung Research America), Guillermo A. P\\'erez (Universit\\'e\n  Libre de Bruxelles), Jean-Fran\\c{c}ois Raskin (Universit\\'e Libre de\n  Bruxelles), Leonid Ryzhyk (Samsung Research America), Ocan Sankur (CNRS,\n  Irisa), Martina Seidl (Johannes-Kepler-University Linz), Leander Tentrup\n  (Saarland University), Adam Walker (Independent Researcher)", "title": "The 3rd Reactive Synthesis Competition (SYNTCOMP 2016): Benchmarks,\n  Participants & Results", "comments": "In Proceedings SYNT 2016, arXiv:1611.07178", "journal-ref": "EPTCS 229, 2016, pp. 149-177", "doi": "10.4204/EPTCS.229.12", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We report on the benchmarks, participants and results of the third reactive\nsynthesis competition(SYNTCOMP 2016). The benchmark library of SYNTCOMP 2016\nhas been extended to benchmarks in the new LTL-based temporal logic synthesis\nformat (TLSF), and 2 new sets of benchmarks for the existing AIGER-based format\nfor safety specifications. The participants of SYNTCOMP 2016 can be separated\naccording to these two classes of specifications, and we give an overview of\nthe 6 tools that entered the competition in the AIGER-based track, and the 3\nparticipants that entered the TLSF-based track. We briefly describe the\nbenchmark selection, evaluation scheme and the experimental setup of SYNTCOMP\n2016. Finally, we present and analyze the results of our experimental\nevaluation, including a comparison to participants of previous competitions and\na legacy tool.\n", "versions": [{"version": "v1", "created": "Fri, 2 Sep 2016 09:01:36 GMT"}, {"version": "v2", "created": "Wed, 23 Nov 2016 22:04:18 GMT"}], "update_date": "2016-11-28", "authors_parsed": [["Jacobs", "Swen", "", "Saarland University"], ["Bloem", "Roderick", "", "Graz University of\n  Technology"], ["Brenguier", "Romain", "", "University of Oxford"], ["Khalimov", "Ayrat", "", "Graz\n  University of Technology"], ["Klein", "Felix", "", "Saarland University"], ["K\u00f6nighofer", "Robert", "", "Graz University of Technology"], ["Kreber", "Jens", "", "Saarland\n  University"], ["Legg", "Alexander", "", "Data 61, CSIRO"], ["Narodytska", "Nina", "", "Samsung Research America"], ["P\u00e9rez", "Guillermo A.", "", "Universit\u00e9\n  Libre de Bruxelles"], ["Raskin", "Jean-Fran\u00e7ois", "", "Universit\u00e9 Libre de\n  Bruxelles"], ["Ryzhyk", "Leonid", "", "Samsung Research America"], ["Sankur", "Ocan", "", "CNRS,\n  Irisa"], ["Seidl", "Martina", "", "Johannes-Kepler-University Linz"], ["Tentrup", "Leander", "", "Saarland University"], ["Walker", "Adam", "", "Independent Researcher"]]}, {"id": "1609.00919", "submitter": "Quang-Trung Ta", "authors": "Quang-Trung Ta, Ton Chanh Le, Siau-Cheng Khoo, Wei-Ngan Chin", "title": "Automated Mutual Explicit Induction Proof in Separation Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We present a sequent-based deductive system for automatically proving\nentailments in separation logic by using mathematical induction. Our technique,\ncalled mutual explicit induction proof, is an instance of Noetherian induction.\nSpecifically, we propose a novel induction principle on a well-founded relation\nof separation logic model and follow the explicit induction methods to\nimplement this principle as inference rules, so that it can be easily\nintegrated into a deductive system. We also support mutual induction, a natural\nfeature of implicit induction, where the goal entailment and other entailments\nderived during the proof search can be used as hypotheses to prove each other.\nWe have implemented a prototype prover and evaluated it on a benchmark of\nhandcrafted entailments as well as benchmarks from a separation logic\ncompetition.\n", "versions": [{"version": "v1", "created": "Sun, 4 Sep 2016 11:50:23 GMT"}, {"version": "v2", "created": "Tue, 6 Sep 2016 16:04:42 GMT"}], "update_date": "2017-10-30", "authors_parsed": [["Ta", "Quang-Trung", ""], ["Le", "Ton Chanh", ""], ["Khoo", "Siau-Cheng", ""], ["Chin", "Wei-Ngan", ""]]}, {"id": "1609.01171", "submitter": "Artem Khyzha", "authors": "Artem Khyzha, Alexey Gotsman, Matthew Parkinson", "title": "A Generic Logic for Proving Linearizability (Extended Version)", "comments": "Formal Methods 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DC cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Linearizability is a commonly accepted notion of correctness for libraries of\nconcurrent algorithms, and recent years have seen a number of proposals of\nprogram logics for proving it. Although these logics differ in technical\ndetails, they embody similar reasoning principles. To explicate these\nprinciples, we propose a logic for proving linearizability that is generic: it\ncan be instantiated with different means of compositional reasoning about\nconcurrency, such as separation logic or rely-guarantee. To this end, we\ngeneralise the Views framework for reasoning about concurrency to handle\nrelations between programs, required for proving linearizability. We present\nsample instantiations of our generic logic and show that it is powerful enough\nto handle concurrent algorithms with challenging features, such as helping.\n", "versions": [{"version": "v1", "created": "Mon, 5 Sep 2016 14:12:03 GMT"}], "update_date": "2016-09-06", "authors_parsed": [["Khyzha", "Artem", ""], ["Gotsman", "Alexey", ""], ["Parkinson", "Matthew", ""]]}, {"id": "1609.01220", "submitter": "Christoph-Simon Senjak", "authors": "Christoph-Simon Senjak, Martin Hofmann", "title": "An implementation of Deflate in Coq", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The widely-used compression format \"Deflate\" is defined in RFC 1951 and is\nbased on prefix-free codings and backreferences. There are unclear points about\nthe way these codings are specified, and several sources for confusion in the\nstandard. We tried to fix this problem by giving a rigorous mathematical\nspecification, which we formalized in Coq. We produced a verified\nimplementation in Coq which achieves competitive performance on inputs of\nseveral megabytes. In this paper we present the several parts of our\nimplementation: a fully verified implementation of canonical prefix-free\ncodings, which can be used in other compression formats as well, and an elegant\nformalism for specifying sophisticated formats, which we used to implement both\na compression and decompression algorithm in Coq which we formally prove\ninverse to each other -- the first time this has been achieved to our\nknowledge. The compatibility to other Deflate implementations can be shown\nempirically. We furthermore discuss some of the difficulties, specifically\nregarding memory and runtime requirements, and our approaches to overcome them.\n", "versions": [{"version": "v1", "created": "Mon, 5 Sep 2016 16:51:32 GMT"}], "update_date": "2016-09-06", "authors_parsed": [["Senjak", "Christoph-Simon", ""], ["Hofmann", "Martin", ""]]}, {"id": "1609.01491", "submitter": "Christopher M. Poskitt", "authors": "Yuqi Chen, Christopher M. Poskitt, Jun Sun", "title": "Towards Learning and Verifying Invariants of Cyber-Physical Systems by\n  Code Mutation", "comments": "Short paper accepted by the 21st International Symposium on Formal\n  Methods (FM 2016)", "journal-ref": "In Proc. International Symposium on Formal Methods (FM 2016),\n  volume 9995 of LNCS, pages 155-163. Springer, 2016", "doi": "10.1007/978-3-319-48989-6_10", "report-no": null, "categories": "cs.SE cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Cyber-physical systems (CPS), which integrate algorithmic control with\nphysical processes, often consist of physically distributed components\ncommunicating over a network. A malfunctioning or compromised component in such\na CPS can lead to costly consequences, especially in the context of public\ninfrastructure. In this short paper, we argue for the importance of\nconstructing invariants (or models) of the physical behaviour exhibited by CPS,\nmotivated by their applications to the control, monitoring, and attestation of\ncomponents. To achieve this despite the inherent complexity of CPS, we propose\na new technique for learning invariants that combines machine learning with\nideas from mutation testing. We present a preliminary study on a water\ntreatment system that suggests the efficacy of this approach, propose\nstrategies for establishing confidence in the correctness of invariants, then\nsummarise some research questions and the steps we are taking to investigate\nthem.\n", "versions": [{"version": "v1", "created": "Tue, 6 Sep 2016 11:28:40 GMT"}], "update_date": "2016-11-08", "authors_parsed": [["Chen", "Yuqi", ""], ["Poskitt", "Christopher M.", ""], ["Sun", "Jun", ""]]}, {"id": "1609.01493", "submitter": "Christoph Benzm\\\"uller", "authors": "Christoph Benzm\\\"uller and Dana S. Scott", "title": "Axiomatizing Category Theory in Free Logic", "comments": "17 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI math.CT math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Starting from a generalization of the standard axioms for a monoid we present\na stepwise development of various, mutually equivalent foundational axiom\nsystems for category theory. Our axiom sets have been formalized in the\nIsabelle/HOL interactive proof assistant, and this formalization utilizes a\nsemantically correct embedding of free logic in classical higher-order logic.\nThe modeling and formal analysis of our axiom sets has been significantly\nsupported by series of experiments with automated reasoning tools integrated\nwith Isabelle/HOL. We also address the relation of our axiom systems to\nalternative proposals from the literature, including an axiom set proposed by\nFreyd and Scedrov for which we reveal a technical issue (when encoded in free\nlogic where free variables range over defined and undefined objects): either\nall operations, e.g. morphism composition, are total or their axiom system is\ninconsistent. The repair for this problem is quite straightforward, however.\n", "versions": [{"version": "v1", "created": "Tue, 6 Sep 2016 11:30:37 GMT"}, {"version": "v2", "created": "Thu, 8 Sep 2016 13:43:00 GMT"}, {"version": "v3", "created": "Wed, 14 Sep 2016 13:54:59 GMT"}, {"version": "v4", "created": "Fri, 28 Apr 2017 04:45:54 GMT"}, {"version": "v5", "created": "Fri, 12 Oct 2018 09:33:18 GMT"}], "update_date": "2018-10-15", "authors_parsed": [["Benzm\u00fcller", "Christoph", ""], ["Scott", "Dana S.", ""]]}, {"id": "1609.01789", "submitter": "Christoph Rauch", "authors": "Anuj Dawar and Eryk Kopczy\\'nski", "title": "Bounded degree and planar spectra", "comments": "21 pages. Accepted for publication in Logical Methods in Computer\n  Science", "journal-ref": "Logical Methods in Computer Science, Volume 13, Issue 4 (November\n  6, 2017) lmcs:4050", "doi": "10.23638/LMCS-13(4:6)2017", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The finite spectrum of a first-order sentence is the set of positive integers\nthat are the sizes of its models. The class of finite spectra is known to be\nthe same as the complexity class NE. We consider the spectra obtained by\nlimiting models to be either planar (in the graph-theoretic sense) or by\nbounding the degree of elements. We show that the class of such spectra is\nstill surprisingly rich by establishing that significant fragments of NE are\nincluded among them. At the same time, we establish non-trivial upper bounds\nshowing that not all sets in NE are obtained as planar or bounded-degree\nspectra.\n", "versions": [{"version": "v1", "created": "Wed, 7 Sep 2016 00:10:13 GMT"}, {"version": "v2", "created": "Mon, 23 Oct 2017 11:03:25 GMT"}, {"version": "v3", "created": "Thu, 2 Nov 2017 16:29:15 GMT"}, {"version": "v4", "created": "Fri, 3 Nov 2017 16:06:25 GMT"}], "update_date": "2018-01-03", "authors_parsed": [["Dawar", "Anuj", ""], ["Kopczy\u0144ski", "Eryk", ""]]}, {"id": "1609.02010", "submitter": "Pedro Cabalar", "authors": "Pedro Cabalar, Carlos P\\'erez, Gilberto P\\'erez", "title": "Equilibrium Graphs", "comments": "Paper presented at the 9th Workshop on Answer Set Programming and\n  Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present an extension of Peirce's existential graphs to\nprovide a diagrammatic representation of expressions in Quantified Equilibrium\nLogic (QEL). Using this formalisation, logical connectives are replaced by\nencircled regions (circles and squares) and quantified variables are\nrepresented as \"identity\" lines. Although the expressive power is equivalent to\nthat of QEL, the new representation can be useful for illustrative or\neducational purposes.\n", "versions": [{"version": "v1", "created": "Wed, 7 Sep 2016 15:07:21 GMT"}], "update_date": "2016-09-08", "authors_parsed": [["Cabalar", "Pedro", ""], ["P\u00e9rez", "Carlos", ""], ["P\u00e9rez", "Gilberto", ""]]}, {"id": "1609.02320", "submitter": "Dohan Kim", "authors": "Dohan Kim", "title": "Distributed agent-based automated theorem proving in order-sorted\n  first-order logic", "comments": "14 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents a distributed agent-based automated theorem proving\nframework based on order-sorted first-order logic. Each agent in our framework\nhas its own knowledge base, communicating to its neighboring agent(s) using\nmessage-passing algorithms. The communication language between agents is\nrestricted in such a manner that each agent can only communicate to its\nneighboring agent(s) by means of their common language. In this paper we\nprovide a refutation-complete report procedure for automated theorem proving in\norder-sorted first-order logic in a subclass of distributed agent-based\nnetworks. Rather than studying and evaluating the performance improvement of\nthe automated theorem proving in order-sorted first-order logic using parallel\nor distributed agents, this paper focuses on building proofs in order-sorted\nfirst-order logic in a distributed manner under the restriction that agents may\nreport their knowledge or observations only with their predefined language.\n", "versions": [{"version": "v1", "created": "Thu, 8 Sep 2016 08:29:30 GMT"}], "update_date": "2016-09-09", "authors_parsed": [["Kim", "Dohan", ""]]}, {"id": "1609.02664", "submitter": "Charles Jordan", "authors": "Charles Jordan and {\\L}ukasz Kaiser", "title": "Machine Learning with Guarantees using Descriptive Complexity and SMT\n  Solvers", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Machine learning is a thriving part of computer science. There are many\nefficient approaches to machine learning that do not provide strong theoretical\nguarantees, and a beautiful general learning theory. Unfortunately, machine\nlearning approaches that give strong theoretical guarantees have not been\nefficient enough to be applicable. In this paper we introduce a logical\napproach to machine learning. Models are represented by tuples of logical\nformulas and inputs and outputs are logical structures. We present our\nframework together with several applications where we evaluate it using SAT and\nSMT solvers. We argue that this approach to machine learning is particularly\nsuited to bridge the gap between efficiency and theoretical soundness. We\nexploit results from descriptive complexity theory to prove strong theoretical\nguarantees for our approach. To show its applicability, we present experimental\nresults including learning complexity-theoretic reductions rules for board\ngames. We also explain how neural networks fit into our framework, although the\ncurrent implementation does not scale to provide guarantees for real-world\nneural networks.\n", "versions": [{"version": "v1", "created": "Fri, 9 Sep 2016 06:04:17 GMT"}], "update_date": "2016-09-12", "authors_parsed": [["Jordan", "Charles", ""], ["Kaiser", "\u0141ukasz", ""]]}, {"id": "1609.02753", "submitter": "J\\\"urgen Koslowski", "authors": "Sylvain Salvati and Igor Walukiewicz", "title": "Typing weak MSOL properties", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 13, Issue 1 (March 23,\n  2017) lmcs:3215", "doi": "10.23638/LMCS-13(1:14)2017", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider lambda-Y-calculus as a non-interpreted functional programming\nlanguage: the result of the execution of a program is its normal form that can\nbe seen as the tree of calls to built-in operations. Weak monadic second-order\nlogic (wMSOL) is well suited to express properties of such trees. We give a\ntype system for ensuring that the result of the execution of a lambda-Y-program\nsatisfies a given wMSOL property. In order to prove soundness and completeness\nof the system we construct a denotational semantics of lambda-Y-calculus that\nis capable of computing properties expressed in wMSOL.\n", "versions": [{"version": "v1", "created": "Fri, 9 Sep 2016 11:58:43 GMT"}, {"version": "v2", "created": "Wed, 22 Mar 2017 13:55:11 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Salvati", "Sylvain", ""], ["Walukiewicz", "Igor", ""]]}, {"id": "1609.03003", "submitter": "Bruno Blanchet", "authors": "Mart\\'in Abadi, Bruno Blanchet, and C\\'edric Fournet", "title": "The Applied Pi Calculus: Mobile Values, New Names, and Secure\n  Communication", "comments": "104 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the interaction of the programming construct \"new\", which generates\nstatically scoped names, with communication via messages on channels. This\ninteraction is crucial in security protocols, which are the main motivating\nexamples for our work, it also appears in other programming-language contexts.\n  We define the applied pi calculus, a simple, general extension of the pi\ncalculus in which values can be formed from names via the application of\nbuilt-in functions, subject to equations, and be sent as messages. (In\ncontrast, the pure pi calculus lacks built-in functions, its only messages are\natomic names.) We develop semantics and proof techniques for this extended\nlanguage and apply them in reasoning about security protocols.\n  This paper essentially subsumes the conference paper that introduced the\napplied pi calculus in 2001. It fills gaps, incorporates improvements, and\nfurther explains and studies the applied pi calculus. Since 2001, the applied\npi calculus has been the basis for much further work, described in many\nresearch publications and sometimes embodied in useful software, such as the\ntool ProVerif, which relies on the applied pi calculus to support the\nspecification and automatic analysis of security protocols. Although this paper\ndoes not aim to be a complete review of the subject, it benefits from that\nfurther work and provides better foundations for some of it. In particular, the\napplied pi calculus has evolved through its implementation in ProVerif, and the\npresent definition reflects that evolution.\n", "versions": [{"version": "v1", "created": "Sat, 10 Sep 2016 06:11:16 GMT"}, {"version": "v2", "created": "Fri, 28 Jul 2017 16:22:22 GMT"}], "update_date": "2017-07-31", "authors_parsed": [["Abadi", "Mart\u00edn", ""], ["Blanchet", "Bruno", ""], ["Fournet", "C\u00e9dric", ""]]}, {"id": "1609.03014", "submitter": "EPTCS", "authors": "Andrea Corradini (Pisa), Hans Zantema (Eindhoven)", "title": "Proceedings 9th International Workshop on Computing with Terms and\n  Graphs", "comments": null, "journal-ref": "EPTCS 225, 2016", "doi": "10.4204/EPTCS.225", "report-no": null, "categories": "cs.LO cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of TERMGRAPH 2016, the Ninth\nInternational Workshop on Computing with Terms and Graphs which was held on\nApril 8, 2016 in Eindhoven, The Netherlands, as a satellite event of the\nEuropean Joint Conferences on Theory and Practice of Software (ETAPS 2016).\n", "versions": [{"version": "v1", "created": "Sat, 10 Sep 2016 08:38:13 GMT"}], "update_date": "2016-09-13", "authors_parsed": [["Corradini", "Andrea", "", "Pisa"], ["Zantema", "Hans", "", "Eindhoven"]]}, {"id": "1609.03139", "submitter": "Julian Nagele", "authors": "Julian Nagele, Vincent van Oostrom, Christian Sternagel", "title": "A Short Mechanized Proof of the Church-Rosser Theorem by the Z-property\n  for the $\\lambda\\beta$-calculus in Nominal Isabelle", "comments": "5th International Workshop on Confluence", "journal-ref": "In Proceedings of the 5th International Workshop on Confluence,\n  pages 55 - 59, 2016", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a short proof of the Church-Rosser property for the\nlambda-calculus enjoying two distinguishing features: Firstly, it employs the\nZ-property, resulting in a short and elegant proof; and secondly, it is\nformalized in the nominal higher-order logic available for the proof assistant\nIsabelle/HOL.\n", "versions": [{"version": "v1", "created": "Sun, 11 Sep 2016 09:22:53 GMT"}], "update_date": "2017-08-29", "authors_parsed": [["Nagele", "Julian", ""], ["van Oostrom", "Vincent", ""], ["Sternagel", "Christian", ""]]}, {"id": "1609.03190", "submitter": "J\\\"urgen Koslowski", "authors": "Federico Aschieri (Technische Universit\\\"at Wien)", "title": "On Natural Deduction for Herbrand Constructive Logics I: Curry-Howard\n  Correspondence for Dummett's Logic LC", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 3 (April 27,\n  2017) lmcs:2048", "doi": "10.2168/LMCS-12(3:13)2016", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dummett's logic LC is intuitionistic logic extended with Dummett's axiom: for\nevery two statements the first implies the second or the second implies the\nfirst. We present a natural deduction and a Curry-Howard correspondence for\nfirst-order and second-order Dummett's logic. We add to the lambda calculus an\noperator which represents, from the viewpoint of programming, a mechanism for\nrepresenting parallel computations and communication between them, and from the\nviewpoint of logic, Dummett's axiom. We prove that our typed calculus is\nnormalizing and show that proof terms for existentially quantified formulas\nreduce to a list of individual terms forming an Herbrand disjunction.\n", "versions": [{"version": "v1", "created": "Sun, 11 Sep 2016 18:39:32 GMT"}, {"version": "v2", "created": "Tue, 27 Sep 2016 11:57:48 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Aschieri", "Federico", "", "Technische Universit\u00e4t Wien"]]}, {"id": "1609.03338", "submitter": "Malvin Gattinger", "authors": "Jan van Eijck, Malvin Gattinger, Yanjing Wang", "title": "Knowing Values and Public Inspection", "comments": null, "journal-ref": null, "doi": "10.1007/978-3-662-54069-5_7", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a basic dynamic epistemic logic of \"knowing the value\". Analogous\nto public announcement in standard DEL, we study \"public inspection\", a new\ndynamic operator which updates the agents' knowledge about the values of\nconstants. We provide a sound and strongly complete axiomatization for the\nsingle and multi-agent case, making use of the well-known Armstrong axioms for\ndependencies in databases.\n", "versions": [{"version": "v1", "created": "Mon, 12 Sep 2016 10:45:44 GMT"}, {"version": "v2", "created": "Wed, 23 Nov 2016 14:58:41 GMT"}], "update_date": "2017-01-17", "authors_parsed": [["van Eijck", "Jan", ""], ["Gattinger", "Malvin", ""], ["Wang", "Yanjing", ""]]}, {"id": "1609.03341", "submitter": "Thomas Sternagel", "authors": "Thomas Sternagel, Christian Sternagel", "title": "Formalized Confluence of Quasi-Decreasing, Strongly Deterministic\n  Conditional TRSs", "comments": "IWC 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an Isabelle/HOL formalization of a characterization of confluence\nfor quasi-reductive strongly deterministic conditional term rewrite systems,\ndue to Avenhaus and Lor\\'ia-S\\'aenz.\n", "versions": [{"version": "v1", "created": "Mon, 12 Sep 2016 11:05:19 GMT"}], "update_date": "2016-09-13", "authors_parsed": [["Sternagel", "Thomas", ""], ["Sternagel", "Christian", ""]]}, {"id": "1609.03345", "submitter": "Thomas Sternagel", "authors": "Thomas Sternagel, Christian Sternagel", "title": "A Characterization of Quasi-Decreasingness", "comments": "WST 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In 2010 Schernhammer and Gramlich showed that quasi-decreasingness of a DCTRS\nR is equivalent to \\mu-termination of its context-sensitive unraveling Ucs(R)\non original terms. While the direction that quasi-decreasingness of R implies\n\\mu-termination of Ucs(R) on original terms is shown directly; the converse -\nfacilitating the use of context-sensitive termination tools like MU-TERM and\nVMTL - employs the additional notion of context-sensitive quasi-reductivity of\nR. In the following, we give a direct proof of the fact that \\mu-termination of\nUcs(R) on original terms implies quasi-decreasingness of R. Moreover, we report\nour experimental findings on DCTRSs from the confluence problems database\n(Cops), extending the experiments of Schernhammer and Gramlich.\n", "versions": [{"version": "v1", "created": "Mon, 12 Sep 2016 11:12:23 GMT"}], "update_date": "2016-09-13", "authors_parsed": [["Sternagel", "Thomas", ""], ["Sternagel", "Christian", ""]]}, {"id": "1609.03432", "submitter": "Christian Sternagel", "authors": "Christian Sternagel", "title": "The Generalized Subterm Criterion in TTT2", "comments": "In Proceedings of 15th International Workshop on Termination (WST\n  2016)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an SMT encoding of a generalized version of the subterm criterion\nand evaluate its implementation in TTT2.\n", "versions": [{"version": "v1", "created": "Mon, 12 Sep 2016 15:02:27 GMT"}], "update_date": "2016-09-13", "authors_parsed": [["Sternagel", "Christian", ""]]}, {"id": "1609.03437", "submitter": "Fabio Cozman", "authors": "Fabio Gagliardi Cozman", "title": "First-Order Bayesian Network Specifications Capture the Complexity Class\n  PP", "comments": "7 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The point of this note is to prove that a language is in the complexity class\nPP if and only if the strings of the language encode valid inferences in a\nBayesian network defined using function-free first-order logic with equality.\n", "versions": [{"version": "v1", "created": "Mon, 12 Sep 2016 15:11:58 GMT"}], "update_date": "2016-09-13", "authors_parsed": [["Cozman", "Fabio Gagliardi", ""]]}, {"id": "1609.03438", "submitter": "Joerg Puehrer", "authors": "Gerhard Brewka, Stefan Ellmauthaler, Ricardo Gon\\c{c}alves, Matthias\n  Knorr, Jo\\~ao Leite, J\\\"org P\\\"uhrer", "title": "Reactive Multi-Context Systems: Heterogeneous Reasoning in Dynamic\n  Environments", "comments": null, "journal-ref": "Artificial Intelligence 256 (2018) 68-104", "doi": "10.1016/j.artint.2017.11.007", "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Managed multi-context systems (mMCSs) allow for the integration of\nheterogeneous knowledge sources in a modular and very general way. They were,\nhowever, mainly designed for static scenarios and are therefore not well-suited\nfor dynamic environments in which continuous reasoning over such heterogeneous\nknowledge with constantly arriving streams of data is necessary. In this paper,\nwe introduce reactive multi-context systems (rMCSs), a framework for reactive\nreasoning in the presence of heterogeneous knowledge sources and data streams.\nWe show that rMCSs are indeed well-suited for this purpose by illustrating how\nseveral typical problems arising in the context of stream reasoning can be\nhandled using them, by showing how inconsistencies possibly occurring in the\nintegration of multiple knowledge sources can be handled, and by arguing that\nthe potential non-determinism of rMCSs can be avoided if needed using an\nalternative, more skeptical well-founded semantics instead with beneficial\ncomputational properties. We also investigate the computational complexity of\nvarious reasoning problems related to rMCSs. Finally, we discuss related work,\nand show that rMCSs do not only generalize mMCSs to dynamic settings, but also\ncapture/extend relevant approaches w.r.t. dynamics in knowledge representation\nand stream reasoning.\n", "versions": [{"version": "v1", "created": "Mon, 12 Sep 2016 15:12:00 GMT"}, {"version": "v2", "created": "Fri, 9 Dec 2016 11:20:56 GMT"}, {"version": "v3", "created": "Mon, 11 Dec 2017 08:59:56 GMT"}], "update_date": "2017-12-12", "authors_parsed": [["Brewka", "Gerhard", ""], ["Ellmauthaler", "Stefan", ""], ["Gon\u00e7alves", "Ricardo", ""], ["Knorr", "Matthias", ""], ["Leite", "Jo\u00e3o", ""], ["P\u00fchrer", "J\u00f6rg", ""]]}, {"id": "1609.03543", "submitter": "Scott Garrabrant", "authors": "Scott Garrabrant, Tsvi Benson-Tilsen, Andrew Critch, Nate Soares,\n  Jessica Taylor", "title": "Logical Induction", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO math.LO math.PR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a computable algorithm that assigns probabilities to every logical\nstatement in a given formal language, and refines those probabilities over\ntime. For instance, if the language is Peano arithmetic, it assigns\nprobabilities to all arithmetical statements, including claims about the twin\nprime conjecture, the outputs of long-running computations, and its own\nprobabilities. We show that our algorithm, an instance of what we call a\nlogical inductor, satisfies a number of intuitive desiderata, including: (1) it\nlearns to predict patterns of truth and falsehood in logical statements, often\nlong before having the resources to evaluate the statements, so long as the\npatterns can be written down in polynomial time; (2) it learns to use\nappropriate statistical summaries to predict sequences of statements whose\ntruth values appear pseudorandom; and (3) it learns to have accurate beliefs\nabout its own current beliefs, in a manner that avoids the standard paradoxes\nof self-reference. For example, if a given computer program only ever produces\noutputs in a certain range, a logical inductor learns this fact in a timely\nmanner; and if late digits in the decimal expansion of $\\pi$ are difficult to\npredict, then a logical inductor learns to assign $\\approx 10\\%$ probability to\n\"the $n$th digit of $\\pi$ is a 7\" for large $n$. Logical inductors also learn\nto trust their future beliefs more than their current beliefs, and their\nbeliefs are coherent in the limit (whenever $\\phi \\implies \\psi$,\n$\\mathbb{P}_\\infty(\\phi) \\le \\mathbb{P}_\\infty(\\psi)$, and so on); and logical\ninductors strictly dominate the universal semimeasure in the limit.\n  These properties and many others all follow from a single logical induction\ncriterion, which is motivated by a series of stock trading analogies. Roughly\nspeaking, each logical sentence $\\phi$ is associated with a stock that is worth\n\\$1 per share if [...]\n", "versions": [{"version": "v1", "created": "Mon, 12 Sep 2016 19:30:56 GMT"}, {"version": "v2", "created": "Mon, 19 Sep 2016 20:32:15 GMT"}, {"version": "v3", "created": "Sun, 2 Oct 2016 14:58:09 GMT"}, {"version": "v4", "created": "Wed, 13 Dec 2017 00:17:09 GMT"}, {"version": "v5", "created": "Mon, 7 Dec 2020 22:26:59 GMT"}], "update_date": "2020-12-09", "authors_parsed": [["Garrabrant", "Scott", ""], ["Benson-Tilsen", "Tsvi", ""], ["Critch", "Andrew", ""], ["Soares", "Nate", ""], ["Taylor", "Jessica", ""]]}, {"id": "1609.03640", "submitter": "EPTCS", "authors": "Ian Mackie (LIX, Ecole Polytechnique)", "title": "Compiling Process Networks to Interaction Nets", "comments": "In Proceedings TERMGRAPH 2016, arXiv:1609.03014", "journal-ref": "EPTCS 225, 2016, pp. 5-14", "doi": "10.4204/EPTCS.225.3", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Kahn process networks are a model of computation based on a collection of\nsequential, deterministic processes that communicate by sending messages\nthrough unbounded channels. They are well suited for modelling stream-based\ncomputations, but are in no way restricted to this application. Interaction\nnets are graph rewriting systems that have many interesting properties for\nimplementation. In this paper we show how to encode process networks using\ninteraction nets, where we model both networks and messages in the same\nframework.\n", "versions": [{"version": "v1", "created": "Tue, 13 Sep 2016 00:17:01 GMT"}], "update_date": "2016-09-14", "authors_parsed": [["Mackie", "Ian", "", "LIX, Ecole Polytechnique"]]}, {"id": "1609.03641", "submitter": "EPTCS", "authors": "Ian Mackie (LIX, Ecole Polytechnique, France), Shinya Sato (Ibaraki\n  University, Japan)", "title": "In-place Graph Rewriting with Interaction Nets", "comments": "In Proceedings TERMGRAPH 2016, arXiv:1609.03014", "journal-ref": "EPTCS 225, 2016, pp. 15-24", "doi": "10.4204/EPTCS.225.4", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  An algorithm is in-place, or runs in-situ, when it does not need any\nadditional memory to execute beyond a small constant amount. There are many\nalgorithms that are efficient because of this feature, therefore it is an\nimportant aspect of an algorithm. In most programming languages, it is not\nobvious when an algorithm can run in-place, and moreover it is often not clear\nthat the implementation respects that idea. In this paper we study interaction\nnets as a formalism where we can see directly, visually, that an algorithm is\nin-place, and moreover the implementation will respect that it is in-place. Not\nall algorithms can run in-place however. We can nevertheless still use the same\nlanguage, but now we can annotate parts of the algorithm that can run in-place.\nWe suggest an annotation for rules, and give an algorithm to find this\nautomatically through analysis of the interaction rules.\n", "versions": [{"version": "v1", "created": "Tue, 13 Sep 2016 00:17:10 GMT"}], "update_date": "2016-09-14", "authors_parsed": [["Mackie", "Ian", "", "LIX, Ecole Polytechnique, France"], ["Sato", "Shinya", "", "Ibaraki\n  University, Japan"]]}, {"id": "1609.03642", "submitter": "EPTCS", "authors": "Georg Moser (Universit\\\"at Innsbruck, Austria), Maria A. Schett\n  (Universit\\\"at Innsbruck, Austria)", "title": "Kruskal's Tree Theorem for Acyclic Term Graphs", "comments": "In Proceedings TERMGRAPH 2016, arXiv:1609.03014", "journal-ref": "EPTCS 225, 2016, pp. 25-34", "doi": "10.4204/EPTCS.225.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we study termination of term graph rewriting, where we restrict\nour attention to acyclic term graphs. Motivated by earlier work by Plump we aim\nat a definition of the notion of simplification order for acyclic term graphs.\nFor this we adapt the homeomorphic embedding relation to term graphs. In\ncontrast to earlier extensions, our notion is inspired by morphisms. Based on\nthis, we establish a variant of Kruskal's Tree Theorem formulated for acyclic\nterm graphs. In proof, we rely on the new notion of embedding and follow\nNash-Williams' minimal bad sequence argument. Finally, we propose a variant of\nthe lexicographic path order for acyclic term graphs.\n", "versions": [{"version": "v1", "created": "Tue, 13 Sep 2016 00:17:18 GMT"}], "update_date": "2016-09-14", "authors_parsed": [["Moser", "Georg", "", "Universit\u00e4t Innsbruck, Austria"], ["Schett", "Maria A.", "", "Universit\u00e4t Innsbruck, Austria"]]}, {"id": "1609.03643", "submitter": "EPTCS", "authors": "Detlef Plump (The University of York, United Kingdom)", "title": "Reasoning about Graph Programs", "comments": "In Proceedings TERMGRAPH 2016, arXiv:1609.03014", "journal-ref": "EPTCS 225, 2016, pp. 35-44", "doi": "10.4204/EPTCS.225.6", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  GP 2 is a non-deterministic programming language for computing by graph\ntransformation. One of the design goals for GP 2 is syntactic and semantic\nsimplicity, to facilitate formal reasoning about programs. In this paper, we\ndemonstrate with four case studies how programmers can prove termination and\npartial correctness of their solutions. We argue that GP 2's graph\ntransformation rules, together with induction on the length of program\nexecutions, provide a convenient framework for program verification.\n", "versions": [{"version": "v1", "created": "Tue, 13 Sep 2016 00:17:26 GMT"}], "update_date": "2016-09-14", "authors_parsed": [["Plump", "Detlef", "", "The University of York, United Kingdom"]]}, {"id": "1609.03644", "submitter": "EPTCS", "authors": "Anton Salikhmetov", "title": "Token-passing Optimal Reduction with Embedded Read-back", "comments": "In Proceedings TERMGRAPH 2016, arXiv:1609.03014", "journal-ref": "EPTCS 225, 2016, pp. 45-54", "doi": "10.4204/EPTCS.225.7", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new interaction net implementation of optimal reduction for\nthe pure untyped lambda calculus. Unlike others, our implementation allows to\nreach normal form regardless of the interaction net reduction strategy using\nthe approach of so-called token-passing nets and a non-deterministic extension\nfor interaction nets. Another new feature is the read-back mechanism\nimplemented without leaving the formalism of interaction nets.\n", "versions": [{"version": "v1", "created": "Tue, 13 Sep 2016 00:17:35 GMT"}], "update_date": "2016-09-14", "authors_parsed": [["Salikhmetov", "Anton", ""]]}, {"id": "1609.03648", "submitter": "EPTCS", "authors": "Domenico Cantone (University of Catania), Giorgio Delzanno (University\n  of Genova)", "title": "Proceedings of the Seventh International Symposium on Games, Automata,\n  Logics and Formal Verification", "comments": null, "journal-ref": "EPTCS 226, 2016", "doi": "10.4204/EPTCS.226", "report-no": null, "categories": "cs.LO cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Seventh International Symposium\non Games, Automata, Logic and Formal Verification (GandALF 2016). The symposium\ntook place in Catania, Italy, from the 14th to the 16th of September 2016. The\nproceedings of the symposium contain abstracts of the 3 invited talks and 21\nfull papers that were accepted after a careful evaluation for presentation at\nthe conference. The topics of the accepted papers cover algorithmic game\ntheory, automata theory, synthesis, formal verification, and dynamic, modal and\ntemporal logics.\n", "versions": [{"version": "v1", "created": "Tue, 13 Sep 2016 00:48:10 GMT"}], "update_date": "2016-09-14", "authors_parsed": [["Cantone", "Domenico", "", "University of Catania"], ["Delzanno", "Giorgio", "", "University\n  of Genova"]]}, {"id": "1609.04085", "submitter": "EPTCS", "authors": "Patrick Ah-Fat (Imperial College London), Michael Huth (Imperial\n  College London)", "title": "Partial Solvers for Parity Games: Effective Polynomial-Time Composition", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 1-15", "doi": "10.4204/EPTCS.226.1", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Partial methods play an important role in formal methods and beyond. Recently\nsuch methods were developed for parity games, where polynomial-time partial\nsolvers decide the winners of a subset of nodes. We investigate here how\neffective polynomial-time partial solvers can be by studying interactions of\npartial solvers based on generic composition patterns that preserve\npolynomial-time computability. We show that use of such composition patterns\ndiscovers new partial solvers - including those that merge node sets that have\nthe same but unknown winner - by studying games that composed partial solvers\ncan neither solve nor simplify. We experimentally validate that this\ndata-driven approach to refinement leads to polynomial-time partial solvers\nthat can solve all standard benchmarks of structured games. For one of these\npolynomial-time partial solvers not even a sole random game from a few billion\nrandom games of varying configuration was found that it won't solve completely.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:57:34 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Ah-Fat", "Patrick", "", "Imperial College London"], ["Huth", "Michael", "", "Imperial\n  College London"]]}, {"id": "1609.04086", "submitter": "EPTCS", "authors": "Carlos Areces, Raul Fervari, Guillaume Hoffmann, Mauricio Martel", "title": "Relation-Changing Logics as Fragments of Hybrid Logics", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 16-29", "doi": "10.4204/EPTCS.226.2", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Relation-changing modal logics are extensions of the basic modal logic that\nallow changes to the accessibility relation of a model during the evaluation of\na formula. In particular, they are equipped with dynamic modalities that are\nable to delete, add, and swap edges in the model, both locally and globally. We\nprovide translations from these logics to hybrid logic along with an\nimplementation. In general, these logics are undecidable, but we use our\ntranslations to identify decidable fragments. We also compare the expressive\npower of relation-changing modal logics with hybrid logics.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:57:43 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Areces", "Carlos", ""], ["Fervari", "Raul", ""], ["Hoffmann", "Guillaume", ""], ["Martel", "Mauricio", ""]]}, {"id": "1609.04088", "submitter": "EPTCS", "authors": "Nick Bezhanishvili (ILLC, University of Amsterdam), Clemens Kupke\n  (University of Strathclyde)", "title": "Games for Topological Fixpoint Logic", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 46-60", "doi": "10.4204/EPTCS.226.4", "report-no": null, "categories": "cs.LO cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Topological fixpoint logics are a family of logics that admits topological\nmodels and where the fixpoint operators are defined with respect to the\ntopological interpretations. Here we consider a topological fixpoint logic for\nrelational structures based on Stone spaces, where the fixpoint operators are\ninterpreted via clopen sets. We develop a game-theoretic semantics for this\nlogic. First we introduce games characterising clopen fixpoints of monotone\noperators on Stone spaces. These fixpoint games allow us to characterise the\nsemantics for our topological fixpoint logic using a two-player graph game.\nAdequacy of this game is the main result of our paper. Finally, we define\nbisimulations for the topological structures under consideration and use our\ngame semantics to prove that the truth of a formula of our topological fixpoint\nlogic is bisimulation-invariant.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:58:01 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Bezhanishvili", "Nick", "", "ILLC, University of Amsterdam"], ["Kupke", "Clemens", "", "University of Strathclyde"]]}, {"id": "1609.04090", "submitter": "EPTCS", "authors": "Laura Bozzelli (Technical University of Madrid (UPM), Spain), Alberto\n  Molinari (University of Udine, Italy), Angelo Montanari (University of Udine,\n  Italy), Adriano Peron (University of Napoli \"Federico II\", Italy), Pietro\n  Sala (University of Verona, Italy)", "title": "Model Checking the Logic of Allen's Relations Meets and Started-by is\n  $P^NP$-Complete", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 76-90", "doi": "10.4204/EPTCS.226.6", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the plethora of fragments of Halpern and Shoham's modal logic of time\nintervals (HS), the logic AB of Allen's relations Meets and Started-by is at a\ncentral position. Statements that may be true at certain intervals, but at no\nsub-interval of them, such as accomplishments, as well as metric constraints\nabout the length of intervals, that force, for instance, an interval to be at\nleast (resp., at most, exactly) k points long, can be expressed in AB.\nMoreover, over the linear order of the natural numbers N, it subsumes the\n(point-based) logic LTL, as it can easily encode the next and until modalities.\nFinally, it is expressive enough to capture the {\\omega}-regular languages,\nthat is, for each {\\omega}-regular expression R there exists an AB formula\n{\\phi} such that the language defined by R coincides with the set of models of\n{\\phi} over N. It has been shown that the satisfiability problem for AB over N\nis EXPSPACE-complete. Here we prove that, under the homogeneity assumption, its\nmodel checking problem is {\\Delta}^p_2 = P^NP-complete (for the sake of\ncomparison, the model checking problem for full HS is EXPSPACE-hard, and the\nonly known decision procedure is nonelementary). Moreover, we show that the\nmodality for the Allen relation Met-by can be added to AB at no extra cost\n(AA'B is P^NP-complete as well).\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:58:20 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Bozzelli", "Laura", "", "Technical University of Madrid"], ["Molinari", "Alberto", "", "University of Udine, Italy"], ["Montanari", "Angelo", "", "University of Udine,\n  Italy"], ["Peron", "Adriano", "", "University of Napoli \"Federico II\", Italy"], ["Sala", "Pietro", "", "University of Verona, Italy"]]}, {"id": "1609.04091", "submitter": "EPTCS", "authors": "Davide Bresolin (University of Bologna), Emilio Mu\\~noz-Velasco\n  (University of Malaga), Guido Sciavicco (University of Ferrara)", "title": "On the Expressive Power of Sub-Propositional Fragments of Modal Logic", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 91-104", "doi": "10.4204/EPTCS.226.7", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modal logic is a paradigm for several useful and applicable formal systems in\ncomputer science. It generally retains the low complexity of classical\npropositional logic, but notable exceptions exist in the domains of\ndescription, temporal, and spatial logic, where the most expressive formalisms\nhave a very high complexity or are even undecidable. In search of\ncomputationally well-behaved fragments, clausal forms and other\nsub-propositional restrictions of temporal and description logics have been\nrecently studied. This renewed interest on sub-propositional logics, which\nmainly focus on the complexity of the various fragments, raise natural\nquestions on their the relative expressive power, which we try to answer here\nfor the basic multi-modal logic Kn. We consider the Horn and the Krom\nrestrictions, as well as the combined restriction (known as the core fragment)\nof modal logic, and, orthogonally, the fragments that emerge by disallowing\nboxes or diamonds from positive literals. We study the problem in a very\ngeneral setting, to ease transferring our results to other meaningful cases.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:58:29 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Bresolin", "Davide", "", "University of Bologna"], ["Mu\u00f1oz-Velasco", "Emilio", "", "University of Malaga"], ["Sciavicco", "Guido", "", "University of Ferrara"]]}, {"id": "1609.04092", "submitter": "EPTCS", "authors": "Florian Bruse (Universit\\\"at Kassel)", "title": "Alternation Is Strict For Higher-Order Modal Fixpoint Logic", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 105-119", "doi": "10.4204/EPTCS.226.8", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the expressive power of Alternating Parity Krivine Automata (APKA),\nwhich provide operational semantics to Higher-Order Modal Fixpoint Logic (HFL).\nAPKA consist of ordinary parity automata extended by a variation of the Krivine\nAbstract Machine. We show that the number and parity of priorities available to\nan APKA form a proper hierarchy of expressive power as in the modal\nmu-calculus. This also induces a strict alternation hierarchy on HFL. The proof\nfollows Arnold's (1999) encoding of runs into trees and subsequent use of the\nBanach Fixpoint Theorem.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:58:38 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Bruse", "Florian", "", "Universit\u00e4t Kassel"]]}, {"id": "1609.04093", "submitter": "EPTCS", "authors": "Florian Bruse (University of Kassel), Daniel Kernberger (University of\n  Kassel), Martin Lange (University of Kassel)", "title": "A Canonical Model Construction for Iteration-Free PDL with Intersection", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 120-134", "doi": "10.4204/EPTCS.226.9", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the axiomatisability of the iteration-free fragment of Propositional\nDynamic Logic with Intersection and Tests. The combination of program\ncomposition, intersection and tests makes its proof-theory rather difficult. We\ndevelop a normal form for formulae which minimises the interaction between\nthese operators, as well as a refined canonical model construction. From these\nwe derive an axiom system and a proof of its strong completeness.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:58:48 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Bruse", "Florian", "", "University of Kassel"], ["Kernberger", "Daniel", "", "University of\n  Kassel"], ["Lange", "Martin", "", "University of Kassel"]]}, {"id": "1609.04094", "submitter": "EPTCS", "authors": "Manfred Droste (Leipzig, Germany), George Rahonis (Thessaloniki,\n  Greece)", "title": "Weighted Linear Dynamic Logic", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 149-163", "doi": "10.4204/EPTCS.226.11", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a weighted linear dynamic logic (weighted LDL for short) and\nshow the expressive equivalence of its formulas to weighted rational\nexpressions. This adds a new characterization for recognizable series to the\nfundamental Sch\\\"utzenberger theorem. Surprisingly, the equivalence does not\nrequire any restriction to our weighted LDL. Our results hold over arbitrary\n(resp. totally complete) semirings for finite (resp. infinite) words. As a\nconsequence, the equivalence problem for weighted LDL formulas over fields is\ndecidable in doubly exponential time. In contrast to classical logics, we show\nthat our weighted LDL is expressively incomparable to weighted LTL for finite\nwords. We determine a fragment of the weighted LTL such that series over finite\nand infinite words definable by LTL formulas in this fragment are definable\nalso by weighted LDL formulas.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:59:07 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Droste", "Manfred", "", "Leipzig, Germany"], ["Rahonis", "George", "", "Thessaloniki,\n  Greece"]]}, {"id": "1609.04095", "submitter": "EPTCS", "authors": "Ga\\\"elle Fontaine (Universidad de Chile), Fabio Mogavero (University\n  of Oxford), Aniello Murano (University of Naples), Giuseppe Perelli\n  (University of Oxford), Loredana Sorrentino (University of Naples)", "title": "Cycle Detection in Computation Tree Logic", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 164-177", "doi": "10.4204/EPTCS.226.12", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Temporal logic is a very powerful formalism deeply investigated and used in\nformal system design and verification. Its application usually reduces to\nsolving specific decision problems such as model checking and satisfiability.\nIn these kind of problems, the solution often requires detecting some specific\nproperties over cycles. For instance, this happens when using classic\ntechniques based on automata, game-theory, SCC decomposition, and the like.\nSurprisingly, no temporal logics have been considered so far with the explicit\nability of talking about cycles.\n  In this paper we introduce Cycle-CTL*, an extension of the classical\nbranching-time temporal logic CTL* along with cycle quantifications in order to\npredicate over cycles. This logic turns out to be very expressive. Indeed, we\nprove that it strictly extends CTL* and is orthogonal to mu-calculus. We also\ngive an evidence of its usefulness by providing few examples involving\nnon-regular properties.\n  We investigate the model checking problem for Cycle-CTL* and show that it is\nPSPACE-Complete as for CTL*. We also study the satisfiability problem for the\nexistential-cycle fragment of the logic and show that it is solvable in\n2ExpTime. This result makes use of an automata-theoretic approach along with\nnovel ad-hoc definitions of bisimulation and tree-like unwinding.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:59:17 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Fontaine", "Ga\u00eblle", "", "Universidad de Chile"], ["Mogavero", "Fabio", "", "University\n  of Oxford"], ["Murano", "Aniello", "", "University of Naples"], ["Perelli", "Giuseppe", "", "University of Oxford"], ["Sorrentino", "Loredana", "", "University of Naples"]]}, {"id": "1609.04097", "submitter": "EPTCS", "authors": "Miika Hannula (Department of Computer Science, The University of\n  Auckland), Juha Kontinen (Department of Mathematics and Statistics,\n  University of Helsinki), Martin L\\\"uck (Institut f\\\"ur Theoretische\n  Informatik, Leibniz Universit\\\"at Hannover), Jonni Virtema (Department of\n  Mathematics and Statistics, University of Helsinki)", "title": "On Quantified Propositional Logics and the Exponential Time Hierarchy", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 198-212", "doi": "10.4204/EPTCS.226.14", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study quantified propositional logics from the complexity theoretic point\nof view. First we introduce alternating dependency quantified boolean formulae\n(ADQBF) which generalize both quantified and dependency quantified boolean\nformulae. We show that the truth evaluation for ADQBF is\nAEXPTIME(poly)-complete. We also identify fragments for which the problem is\ncomplete for the levels of the exponential hierarchy. Second we study\npropositional team-based logics. We show that DQBF formulae correspond\nnaturally to quantified propositional dependence logic and present a general\nNEXPTIME upper bound for quantified propositional logic with a large class of\ngeneralized dependence atoms. Moreover we show AEXPTIME(poly)-completeness for\nextensions of propositional team logic with generalized dependence atoms.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:59:36 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Hannula", "Miika", "", "Department of Computer Science, The University of\n  Auckland"], ["Kontinen", "Juha", "", "Department of Mathematics and Statistics,\n  University of Helsinki"], ["L\u00fcck", "Martin", "", "Institut f\u00fcr Theoretische\n  Informatik, Leibniz Universit\u00e4t Hannover"], ["Virtema", "Jonni", "", "Department of\n  Mathematics and Statistics, University of Helsinki"]]}, {"id": "1609.04098", "submitter": "EPTCS", "authors": "Milka Hutagalung (Universit\\\"at Kassel), Norbert Hundeshagen\n  (Universit\\\"at Kassel), Dietrich Kuske (Technische Universit\\\"at Ilmenau),\n  Martin Lange (Universit\\\"at Kassel), Etienne Lozes (ENS Cachan)", "title": "Multi-Buffer Simulations for Trace Language Inclusion", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 213-227", "doi": "10.4204/EPTCS.226.15", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider simulation games played between Spoiler and Duplicator on two\nB\\\"uchi automata in which the choices made by Spoiler can be buffered by\nDuplicator in several buffers before she executes them on her structure. We\nshow that the simulation games are useful to approximate the inclusion of trace\nclosures of languages accepted by finite-state automata, which is known to be\nundecidable. We study the decidability and complexity and show that the game\nwith bounded buffers can be decided in polynomial time, whereas the game with\none unbounded and one bounded buffer is highly undecidable. We also show some\nsufficient conditions on the automata for Duplicator to win the game (with\nunbounded buffers).\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 00:59:45 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Hutagalung", "Milka", "", "Universit\u00e4t Kassel"], ["Hundeshagen", "Norbert", "", "Universit\u00e4t Kassel"], ["Kuske", "Dietrich", "", "Technische Universit\u00e4t Ilmenau"], ["Lange", "Martin", "", "Universit\u00e4t Kassel"], ["Lozes", "Etienne", "", "ENS Cachan"]]}, {"id": "1609.04100", "submitter": "EPTCS", "authors": "Tomer Libal (Inria), Marco Volpe (Inria)", "title": "Certification of Prefixed Tableau Proofs for Modal Logic", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 257-271", "doi": "10.4204/EPTCS.226.18", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Different theorem provers tend to produce proof objects in different formats\nand this is especially the case for modal logics, where several deductive\nformalisms (and provers based on them) have been presented. This work falls\nwithin the general project of establishing a common specification language in\norder to certify proofs given in a wide range of deductive formalisms. In\nparticular, by using a translation from the modal language into a first-order\npolarized language and a checker whose small kernel is based on a classical\nfocused sequent calculus, we are able to certify modal proofs given in labeled\nsequent calculi, prefixed tableaux and free-variable prefixed tableaux. We\ndescribe the general method for the logic K, present its implementation in a\nprolog-like language, provide some examples and discuss how to extend the\napproach to other normal modal logics\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 01:00:16 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Libal", "Tomer", "", "Inria"], ["Volpe", "Marco", "", "Inria"]]}, {"id": "1609.04102", "submitter": "EPTCS", "authors": "Mark Reynolds (UWA)", "title": "A New Rule for LTL Tableaux", "comments": "In Proceedings GandALF 2016, arXiv:1609.03648", "journal-ref": "EPTCS 226, 2016, pp. 287-301", "doi": "10.4204/EPTCS.226.20", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Propositional linear time temporal logic (LTL) is the standard temporal logic\nfor computing applications and many reasoning techniques and tools have been\ndeveloped for it. Tableaux for deciding satisfiability have existed since the\n1980s. However, the tableaux for this logic do not look like traditional\ntree-shaped tableau systems and their processing is often quite complicated.\n  In this paper, we introduce a novel style of tableau rule which supports a\nnew simple traditional-style tree-shaped tableau for LTL. We prove that it is\nsound and complete. As well as being simple to understand, to introduce to\nstudents and to use, it is also simple to implement and is competitive against\nstate of the art systems. It is particularly suitable for parallel\nimplementations.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 01:00:35 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Reynolds", "Mark", "", "UWA"]]}, {"id": "1609.04176", "submitter": "Sasha Rubin", "authors": "Benjamin Aminof, Sasha Rubin, Francesco Spegni, Florian Zuleger", "title": "Liveness of Parameterized Timed Networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the model checking problem of infinite state systems given in the\nform of parameterized discrete timed networks with multiple clocks. We show\nthat this problem is decidable with respect to specifications given by B- or\nS-automata. Such specifications are very expressive (they strictly subsume\nomega-regular specifications), and easily express complex liveness and safety\nproperties. Our results are obtained by modeling the passage of time using\nsymmetric broadcast, and by solving the model checking problem of parameterized\nsystems of un-timed processes communicating using k-wise rendezvous and\nsymmetric broadcast. Our decidability proof makes use of automata theory,\nrational linear programming, and geometric reasoning for solving certain\nreachability questions in vector addition systems; we believe these proof\ntechniques will be useful in solving related problems.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 08:55:06 GMT"}], "update_date": "2016-09-15", "authors_parsed": [["Aminof", "Benjamin", ""], ["Rubin", "Sasha", ""], ["Spegni", "Francesco", ""], ["Zuleger", "Florian", ""]]}, {"id": "1609.04371", "submitter": "Alberto Camacho", "authors": "Jorge A. Baier, Alberto Camacho, Christian Muise and Sheila A.\n  McIlraith", "title": "Finite LTL Synthesis is EXPTIME-complete", "comments": "We withdraw this paper because of an error in the proof", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  LTL synthesis -- the construction of a function to satisfy a logical\nspecification formulated in Linear Temporal Logic -- is a 2EXPTIME-complete\nproblem with relevant applications in controller synthesis and a myriad of\nartificial intelligence applications. In this research note we consider De\nGiacomo and Vardi's variant of the synthesis problem for LTL formulas\ninterpreted over finite rather than infinite traces. Rather surprisingly, given\nthe existing claims on complexity, we establish that LTL synthesis is\nEXPTIME-complete for the finite interpretation, and not 2EXPTIME-complete as\npreviously reported. Our result coincides nicely with the planning perspective\nwhere non-deterministic planning with full observability is EXPTIME-complete\nand partial observability increases the complexity to 2EXPTIME-complete; a\nrecent related result for LTL synthesis shows that in the finite case with\npartial observability, the problem is 2EXPTIME-complete.\n", "versions": [{"version": "v1", "created": "Wed, 14 Sep 2016 18:23:25 GMT"}, {"version": "v2", "created": "Thu, 17 Nov 2016 14:12:45 GMT"}], "update_date": "2016-11-18", "authors_parsed": [["Baier", "Jorge A.", ""], ["Camacho", "Alberto", ""], ["Muise", "Christian", ""], ["McIlraith", "Sheila A.", ""]]}, {"id": "1609.04693", "submitter": "Rob van Glabbeek", "authors": "Rob van Glabbeek and Dominic Hughes", "title": "MALL proof nets identify proofs modulo rule commutation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that the proof nets introduced in [Hughes & van Glabbeek 2003, 2005]\nfor MALL (Multiplicative Additive Linear Logic, without units) identify\ncut-free proofs modulo rule commutation: two cut-free proofs translate to the\nsame proof net if and only if one can be obtained from the other by a\nsuccession of rule commutations. This result holds with and without the mix\nrule, and we extend it with cut.\n", "versions": [{"version": "v1", "created": "Thu, 15 Sep 2016 15:13:12 GMT"}], "update_date": "2016-09-16", "authors_parsed": [["van Glabbeek", "Rob", ""], ["Hughes", "Dominic", ""]]}, {"id": "1609.05079", "submitter": "Arthur Ramos MSCS", "authors": "Arthur Freitas Ramos, Ruy J. G. B. de Queiroz and Anjolina G. de\n  Oliveira", "title": "Explicit Computational Paths", "comments": "45 pages (2 pages - appendix)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The treatment of equality as a type in type theory gives rise to an\ninteresting type-theoretic structure known as `identity type'. The idea is\nthat, given terms $a,b$ of a type $A$, one may form the type $Id_{A}(a,b)$,\nwhose elements are proofs that $a$ and $b$ are equal elements of type $A$. A\nterm of this type, $p : Id_{A}(a,b)$, makes up for the grounds (or proof) that\nestablishes that $a$ is indeed equal to $b$. Based on that, a proof of equality\ncan be seen as a sequence of substitutions and rewrites, also known as a\n`computational path'. One interesting fact is that it is possible to rewrite\ncomputational paths using a set of reduction rules arising from an analysis of\nredundancies in paths. These rules were mapped by De Oliveira in 1994 in a term\nrewrite system known as $LND_{EQ}-TRS$. Here we use computational paths and\nthis term rewrite system to develop the main foundations of homotopy type\ntheory, i.e., we develop the lemmas and theorems connected to the main types of\nthis theory, types such as products, coproducts, identity type, transport and\nmany others. We also show that it is possible to directly construct path spaces\nthrough computational paths. To show this, we construct the natural numbers and\nthe fundamental group of the circle, showing results connected to these\nstructures.\n", "versions": [{"version": "v1", "created": "Fri, 16 Sep 2016 14:29:20 GMT"}, {"version": "v2", "created": "Mon, 19 Sep 2016 18:07:51 GMT"}, {"version": "v3", "created": "Thu, 26 Apr 2018 02:15:12 GMT"}], "update_date": "2018-04-27", "authors_parsed": [["Ramos", "Arthur Freitas", ""], ["de Queiroz", "Ruy J. G. B.", ""], ["de Oliveira", "Anjolina G.", ""]]}, {"id": "1609.05207", "submitter": "Jan Leike", "authors": "Jan Leike, Matthias Heizmann", "title": "Geometric Nontermination Arguments", "comments": "18 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new kind of nontermination argument, called geometric\nnontermination argument. The geometric nontermination argument is a finite\nrepresentation of an infinite execution that has the form of a sum of several\ngeometric series. For so-called linear lasso programs we can decide the\nexistence of a geometric nontermination argument using a nonlinear algebraic\n$\\exists$-constraint. We show that a deterministic conjunctive loop program\nwith nonnegative eigenvalues is nonterminating if an only if there exists a\ngeometric nontermination argument. Furthermore, we present an evaluation that\ndemonstrates that our method is feasible in practice.\n", "versions": [{"version": "v1", "created": "Fri, 16 Sep 2016 14:12:51 GMT"}], "update_date": "2016-09-20", "authors_parsed": [["Leike", "Jan", ""], ["Heizmann", "Matthias", ""]]}, {"id": "1609.05367", "submitter": "Miquel Bofill", "authors": "Miquel Bofill, V\\'ictor Mu\\~noz, Javier Murillo", "title": "Solving the Wastewater Treatment Plant Problem with SMT", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we introduce the Wastewater Treatment Plant Problem, a\nreal-world scheduling problem, and compare the performance of several tools on\nit. We show that, for a naive modeling, state-of-the-art SMT solvers outperform\nother tools ranging from mathematical programming to constraint programming. We\nuse both real and randomly generated benchmarks.\n  From this and similar results, we claim for the convenience of developing\ncompiler front-ends being able to translate from constraint programming\nlanguages to the SMT-LIB standard language.\n", "versions": [{"version": "v1", "created": "Sat, 17 Sep 2016 17:17:15 GMT"}], "update_date": "2016-09-20", "authors_parsed": [["Bofill", "Miquel", ""], ["Mu\u00f1oz", "V\u00edctor", ""], ["Murillo", "Javier", ""]]}, {"id": "1609.05385", "submitter": "Anca Muscholl", "authors": "Anca Muscholl, Helmut Seidl and Igor Walukiewicz", "title": "Reachability for dynamic parametric processes", "comments": "31 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a dynamic parametric process every subprocess may spawn arbitrarily many,\nidentical child processes, that may communicate either over global variables,\nor over local variables that are shared with their parent.\n  We show that reachability for dynamic parametric processes is decidable under\nmild assumptions. These assumptions are e.g. met if individual processes are\nrealized by pushdown systems, or even higher-order pushdown systems. We also\nprovide algorithms for subclasses of pushdown dynamic parametric processes,\nwith complexity ranging between NP and DEXPTIME.\n", "versions": [{"version": "v1", "created": "Sat, 17 Sep 2016 20:11:09 GMT"}], "update_date": "2016-09-20", "authors_parsed": [["Muscholl", "Anca", ""], ["Seidl", "Helmut", ""], ["Walukiewicz", "Igor", ""]]}, {"id": "1609.05621", "submitter": "J\\\"urgen Koslowski", "authors": "Franz Baader and Stefan Borgwardt and Barbara Morawska (Technische\n  Universit\\\"at Dresden)", "title": "Extending Unification in $\\mathcal{EL}$ to Disunification: The Case of\n  Dismatching and Local Disunification", "comments": "32 pages, extended version of a paper from RTA'15", "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 4 (April 27,\n  2017) lmcs:2063", "doi": "10.2168/LMCS-12(4:1)2016", "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Unification in Description Logics has been introduced as a means to detect\nredundancies in ontologies. We try to extend the known decidability results for\nunification in the Description Logic $\\mathcal{EL}$ to disunification since\nnegative constraints can be used to avoid unwanted unifiers. While decidability\nof the solvability of general $\\mathcal{EL}$-disunification problems remains an\nopen problem, we obtain NP-completeness results for two interesting special\ncases: dismatching problems, where one side of each negative constraint must be\nground, and local solvability of disunification problems, where we consider\nonly solutions that are constructed from terms occurring in the input problem.\nMore precisely, we first show that dismatching can be reduced to local\ndisunification, and then provide two complementary NP-algorithms for finding\nlocal solutions of disunification problems.\n", "versions": [{"version": "v1", "created": "Mon, 19 Sep 2016 07:45:50 GMT"}, {"version": "v2", "created": "Wed, 5 Oct 2016 21:44:19 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Baader", "Franz", "", "Technische\n  Universit\u00e4t Dresden"], ["Borgwardt", "Stefan", "", "Technische\n  Universit\u00e4t Dresden"], ["Morawska", "Barbara", "", "Technische\n  Universit\u00e4t Dresden"]]}, {"id": "1609.05686", "submitter": "Louwe B. Kuijer", "authors": "Hans van Ditmarsch, Wiebe van der Hoek, Louwe B. Kuijer", "title": "The Undecidability of Arbitrary Arrow Update Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Arbitrary Arrow Update Logic is a dynamic modal logic that uses an arbitrary\narrow update modality to quantify over all arrow updates. Some properties of\nthis logic have already been established, but until now it remained an open\nquestion whether the logic's satisfiability problem is decidable. Here, we show\nthat the satisfiability problem of Arbitrary Arrow Update Logic is co-RE hard,\nand therefore undecidable, by a reduction of the tiling problem.\n", "versions": [{"version": "v1", "created": "Mon, 19 Sep 2016 12:27:01 GMT"}], "update_date": "2016-09-20", "authors_parsed": [["van Ditmarsch", "Hans", ""], ["van der Hoek", "Wiebe", ""], ["Kuijer", "Louwe B.", ""]]}, {"id": "1609.05811", "submitter": "Pedro Cabalar", "authors": "Felicidad Aguado, Pedro Cabalar, Mart\\'in Di\\'eguez, Gilberto P\\'erez,\n  Concepci\\'on Vidal", "title": "Temporal Logic Programs with Variables", "comments": "Under consideration in Theory and Practice of Logic Programming\n  (TPLP)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this note we consider the problem of introducing variables in temporal\nlogic programs under the formalism of \"Temporal Equilibrium Logic\" (TEL), an\nextension of Answer Set Programming (ASP) for dealing with linear-time modal\noperators. To this aim, we provide a definition of a first-order version of TEL\nthat shares the syntax of first-order Linear-time Temporal Logic (LTL) but has\na different semantics, selecting some LTL models we call \"temporal stable\nmodels\". Then, we consider a subclass of theories (called \"splittable temporal\nlogic programs\") that are close to usual logic programs but allowing a\nrestricted use of temporal operators. In this setting, we provide a syntactic\ndefinition of \"safe variables\" that suffices to show the property of \"domain\nindependence\" -- that is, addition of arbitrary elements in the universe does\nnot vary the set of temporal stable models. Finally, we present a method for\ncomputing the derivable facts by constructing a non-temporal logic program with\nvariables that is fed to a standard ASP grounder. The information provided by\nthe grounder is then used to generate a subset of ground temporal rules which\nis equivalent to (and generally smaller than) the full program instantiation.\n", "versions": [{"version": "v1", "created": "Mon, 19 Sep 2016 16:11:49 GMT"}], "update_date": "2016-09-20", "authors_parsed": [["Aguado", "Felicidad", ""], ["Cabalar", "Pedro", ""], ["Di\u00e9guez", "Mart\u00edn", ""], ["P\u00e9rez", "Gilberto", ""], ["Vidal", "Concepci\u00f3n", ""]]}, {"id": "1609.05847", "submitter": "Revantha Ramanayake Dr", "authors": "Revantha Ramanayake", "title": "A syntactic proof of decidability for the logic of bunched implication\n  BI", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The logic of bunched implication BI provides a framework for reasoning about\nresource composition and forms the basis for an assertion language of\nseparation logic which is used to reason about software programs. Propositional\nBI is obtained by freely combining propositional intuitionistic logic and\nmultiplicative intuitionistic linear logic. It possesses an elegant proof\ntheory: its bunched calculus combines the sequent calculi for these logics.\nSeveral natural extensions of BI have been shown as undecidable, e.g. Boolean\nBI which replaces intuitionistic logic with classical logic. This makes the\ndecidability of BI, proved recently via an intricate semantical argument,\nparticularly noteworthy. However, a syntactic proof of decidability has thus\nfar proved elusive. We obtain such a proof here using a proof-theoretic\nargument. The proof is technically interesting, accessible as it uses the usual\nbunched calculus (it does not require any knowledge of the semantics of BI),\nyields an implementable decision procedure and implies an upper bound on the\ncomplexity of the logic.\n", "versions": [{"version": "v1", "created": "Mon, 19 Sep 2016 18:25:19 GMT"}, {"version": "v2", "created": "Tue, 15 Nov 2016 15:24:32 GMT"}, {"version": "v3", "created": "Fri, 2 Dec 2016 17:32:41 GMT"}], "update_date": "2016-12-05", "authors_parsed": [["Ramanayake", "Revantha", ""]]}, {"id": "1609.05952", "submitter": "Mickael Randour", "authors": "V\\'eronique Bruy\\`ere, Quentin Hautem, Mickael Randour", "title": "Window Parity Games: An Alternative Approach Toward Parity Games with\n  Time Bounds (Full Version)", "comments": "Full version of GandALF 2016 paper (arXiv:1606.01831v2), same as\n  arXiv:1606.01831v1", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL cs.GT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Classical objectives in two-player zero-sum games played on graphs often deal\nwith limit behaviors of infinite plays: e.g., mean-payoff and total-payoff in\nthe quantitative setting, or parity in the qualitative one (a canonical way to\nencode omega-regular properties). Those objectives offer powerful abstraction\nmechanisms and often yield nice properties such as memoryless determinacy.\nHowever, their very nature provides no guarantee on time bounds within which\nsomething good can be witnessed. In this work, we consider two approaches\ntoward inclusion of time bounds in parity games. The first one, parity-response\ngames, is based on the notion of finitary parity games [CHH09] and parity games\nwith costs [FZ14,WZ16]. The second one, window parity games, is inspired by\nwindow mean-payoff games [CDRR15]. We compare the two approaches and show that\nwhile they prove to be equivalent in some contexts, window parity games offer a\nmore tractable alternative when the time bound is given as a parameter (P-c.\nvs. PSPACE-C.). In particular, it provides a conservative approximation of\nparity games computable in polynomial time. Furthermore, we extend both\napproaches to the multi-dimension setting. We give the full picture for both\ntypes of games with regard to complexity and memory bounds.\n  [CHH09] K. Chatterjee, T.A. Henzinger, F. Horn (2009): Finitary winning in\nomega-regular games. ACM Trans. Comput. Log. 11(1). [FZ14] N. Fijalkow, M.\nZimmermann (2014): Parity and Streett Games with Costs. LMCS 10(2). [WZ16] A.\nWeinert, M. Zimmermann (2016): Easy to Win, Hard to Master: Optimal Strategies\nin Parity Games with Costs. Proc. of CSL, LIPIcs 62, pp. 31:1-31:17, Schloss\nDagstuhl - LZI. [CDRR15] K. Chatterjee, L. Doyen, M. Randour, J.-F. Raskin\n(2015): Looking at mean-payoff and total-payoff through windows. Information\nand Computation 242, pp. 25-52.\n", "versions": [{"version": "v1", "created": "Thu, 15 Sep 2016 09:37:14 GMT"}], "update_date": "2016-09-21", "authors_parsed": [["Bruy\u00e8re", "V\u00e9ronique", ""], ["Hautem", "Quentin", ""], ["Randour", "Mickael", ""]]}, {"id": "1609.06124", "submitter": "Thorsten Wissmann", "authors": "Benedikt Bollig, Karin Quaas and Arnaud Sangnier", "title": "The Complexity of Flat Freeze LTL", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 15, Issue 3 (September\n  30, 2019) lmcs:5795", "doi": "10.23638/LMCS-15(3:33)2019", "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We consider the model-checking problem for freeze LTL on one-counter automata\n(OCA). Freeze LTL extends LTL with the freeze quantifier, which allows one to\nstore different counter values of a run in registers so that they can be\ncompared with one another. As the model-checking problem is undecidable in\ngeneral, we focus on the flat fragment of freeze LTL, in which the usage of the\nfreeze quantifier is restricted. In a previous work, Lechner et al. showed that\nmodel checking for flat freeze LTL on OCA with binary encoding of counter\nupdates is decidable and in 2NEXPTIME. In this paper, we prove that the problem\nis, in fact, NEXPTIME-complete no matter whether counter updates are encoded in\nunary or binary. Like Lechner et al., we rely on a reduction to the\nreachability problem in OCA with parameterized tests (OCA(P)). The new aspect\nis that we simulate OCA(P) by alternating two-way automata over words. This\nimplies an exponential upper bound on the parameter values that we exploit\ntowards an NP algorithm for reachability in OCA(P) with unary updates. We\nobtain our main result as a corollary. As another application, relying on a\nreduction by Bundala and Ouaknine, one obtains an alternative proof of the\nknown fact that reachability in closed parametric timed automata with one\nparametric clock is in NEXPTIME.\n", "versions": [{"version": "v1", "created": "Tue, 20 Sep 2016 12:13:44 GMT"}, {"version": "v2", "created": "Sun, 26 Feb 2017 21:40:27 GMT"}, {"version": "v3", "created": "Wed, 26 Apr 2017 11:20:35 GMT"}, {"version": "v4", "created": "Mon, 2 Jul 2018 08:07:51 GMT"}, {"version": "v5", "created": "Fri, 26 Apr 2019 12:31:05 GMT"}, {"version": "v6", "created": "Mon, 2 Sep 2019 20:24:29 GMT"}, {"version": "v7", "created": "Fri, 27 Sep 2019 09:24:19 GMT"}, {"version": "v8", "created": "Tue, 15 Oct 2019 14:09:21 GMT"}], "update_date": "2019-10-23", "authors_parsed": [["Bollig", "Benedikt", ""], ["Quaas", "Karin", ""], ["Sangnier", "Arnaud", ""]]}, {"id": "1609.06290", "submitter": "C Aiswarya", "authors": "C. Aiswarya, Paul Gastin, Prakash Saivasan", "title": "Nested Words for Order-2 Pushdown Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  We study linear time model checking of collapsible higher-order pushdown\nsystems (CPDS) of order 2 (manipulating stack of stacks) against MSO and PDL\n(propositional dynamic logic with converse and loop) enhanced with push/pop\nmatching relations. To capture these linear time behaviours with matchings, we\npropose order-2 nested words. These graphs consist of a word structure\naugmented with two binary matching relations, one for each order of stack,\nwhich relate a push with matching pops (or collapse) on the respective stack.\nDue to the matching relations, satisfiability and model checking are\nundecidable. Hence we propose an under-approximation, bounding the number of\ntimes an order-1 push can be popped. With this under-approximation, which still\nallows unbounded stack height, we get decidability for satisfiability and model\nchecking of both MSO and PDL. The problems are ExpTime-Complete for PDL.\n", "versions": [{"version": "v1", "created": "Tue, 20 Sep 2016 18:52:07 GMT"}], "update_date": "2016-09-21", "authors_parsed": [["Aiswarya", "C.", ""], ["Gastin", "Paul", ""], ["Saivasan", "Prakash", ""]]}, {"id": "1609.06297", "submitter": "Abhisekh Sankaran", "authors": "Abhisekh Sankaran", "title": "A Generalization of the {\\L}o\\'s-Tarski Preservation Theorem", "comments": "180 pages, 8 figures, Ph.D. dissertation, Indian Institute of\n  Technology (IIT) Bombay, August 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this dissertation, we present for each natural number $k$, semantic\ncharacterizations of the $\\exists^k \\forall^*$ and $\\forall^k \\exists^*$ prefix\nclasses of first order logic sentences, over all structures finite and\ninfinite. This result, that we call the *generalized {\\L}o\\'s-Tarski theorem*,\nabbreviated $\\mathsf{GLT}(k)$, yields the classical {\\L}o\\'s-Tarski\npreservation theorem when $k$ equals 0. It also provides new characterizations\nof the $\\Sigma^0_2$ and $\\Pi^0_2$ prefix classes, that are finer than all\ncharacterizations of these classes in the literature. Further, our semantic\nnotions are finitary in nature, in contrast to those contained in the\nliterature characterizations.\n  In the context of finite structures, we formulate an abstract combinatorial\nproperty of structures, that when satisfied by a class, ensures that\n$\\mathsf{GLT}(k)$ holds over the class. This property, that we call the\n*Equivalent Bounded Substructure Property*, abbreviated $\\mathsf{EBSP}$,\nintuitively states that a large structure contains a small \"logically similar\"\nsubstructure. It turns out that this simply stated property is enjoyed by a\nvariety of classes of interest in computer science: examples include words,\ntrees (unordered, ordered or ranked), nested words, graph classes of bounded\ntree-depth/shrub-depth, and $m$-partite cographs. Further, $\\mathsf{EBSP}$\nremains preserved under various well-studied operations, such as\ncomplementation, transpose, the line-graph operation, disjoint union, cartesian\nand tensor products, etc. This enables constructing a wide spectrum of classes\nthat satisfy $\\mathsf{EBSP}$, and hence $\\mathsf{GLT}(k)$. Remarkably,\n$\\mathsf{EBSP}$ can be regarded as a finitary analogue of the classical\ndownward L\\\"owenheim-Skolem property.\n  In summary, this dissertation provides new notions and results in both\ncontexts, that of all structures and that of finite structures.\n", "versions": [{"version": "v1", "created": "Tue, 20 Sep 2016 19:24:55 GMT"}], "update_date": "2016-09-21", "authors_parsed": [["Sankaran", "Abhisekh", ""]]}, {"id": "1609.06379", "submitter": "Daniel Hausmann Daniel Hausmann", "authors": "Daniel Hausmann, Lutz Schr\\\"oder and Christoph Egger", "title": "Global Caching for the Alternation-free $\\mu$-Calculus", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a sound, complete, and optimal single-pass tableau algorithm for\nthe alternation-free $\\mu$-calculus. The algorithm supports global caching with\nintermediate propagation and runs in time $2^{\\mathcal{O}(n)}$. In\ngame-theoretic terms, our algorithm integrates the steps for constructing and\nsolving the B\\\"uchi game arising from the input tableau into a single\nprocedure; this is done on-the-fly, i.e. may terminate before the game has been\nfully constructed. This suggests a slogan to the effect that global caching =\ngame solving on-the-fly. A prototypical implementation shows promising initial\nresults.\n", "versions": [{"version": "v1", "created": "Tue, 20 Sep 2016 22:56:46 GMT"}], "update_date": "2016-09-22", "authors_parsed": [["Hausmann", "Daniel", ""], ["Schr\u00f6der", "Lutz", ""], ["Egger", "Christoph", ""]]}, {"id": "1609.06382", "submitter": "Mohammad Amin Alipour", "authors": "Mohammad Amin Alipour, Alex Groce, Chaoqiang Zhang, Anahita Sanadaji,\n  and Gokul Caushik", "title": "Finding Model-Checkable Needles in Large Source Code Haystacks: Modular\n  Bug-Finding via Static Analysis and Dynamic Invariant Discovery", "comments": "6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present a novel marriage of static and dynamic analysis.\nGiven a large code base with many functions and a mature test suite, we propose\nusing static analysis to find functions 1) with assertions or other evident\ncorrectness properties (e.g., array bounds requirements or pointer access) and\n2) with simple enough control flow and data use to be amenable to\npredicate-abstraction based or bounded model checking without human\nintervention. Because most such functions in realistic software systems in fact\nrely on many input preconditions not specified by the language's type system\n(or annotated in any way), we propose using dynamically discovered invariants\nbased on a program's test suite to characterize likely preconditions, in order\nto reduce the problem of false positives. While providing little in the way of\nverification, this approach may provide an additional quick and highly scalable\nbug-finding method for programs that are usually considered \"too large to model\ncheck.\" We present a simple example showing that the technique can be useful\nfor a more typically \"model-checkable\" code base, even in the presence of a\npoorly designed test suite and bad invariants.\n", "versions": [{"version": "v1", "created": "Tue, 20 Sep 2016 23:22:53 GMT"}], "update_date": "2016-09-22", "authors_parsed": [["Alipour", "Mohammad Amin", ""], ["Groce", "Alex", ""], ["Zhang", "Chaoqiang", ""], ["Sanadaji", "Anahita", ""], ["Caushik", "Gokul", ""]]}, {"id": "1609.06405", "submitter": "Yanjing Wang", "authors": "Chao Xu, Yanjing Wang, Thomas Studer", "title": "A Logic of Knowing Why", "comments": "34 pages, submitted, a new section added", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  When we say \"I know why he was late\", we know not only the fact that he was\nlate, but also an explanation of this fact. We propose a logical framework of\n\"knowing why\" inspired by the existing formal studies on why-questions,\nscientific explanation, and justification logic. We introduce the Ky_i operator\ninto the language of epistemic logic to express \"agent i knows why phi\" and\npropose a Kripke-style semantics of such expressions in terms of knowing an\nexplanation of phi. We obtain two sound and complete axiomatizations w.r.t. two\ndifferent model classes depending on different assumptions about introspection.\n", "versions": [{"version": "v1", "created": "Wed, 21 Sep 2016 02:16:14 GMT"}, {"version": "v2", "created": "Tue, 14 Mar 2017 23:14:28 GMT"}], "update_date": "2017-03-16", "authors_parsed": [["Xu", "Chao", ""], ["Wang", "Yanjing", ""], ["Studer", "Thomas", ""]]}, {"id": "1609.06513", "submitter": "J\\\"urgen Koslowski", "authors": "Vincenzo Ciancia, Diego Latella, Michele Loreti, Mieke Massink", "title": "Model Checking Spatial Logics for Closure Spaces", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 4 (April 27,\n  2017) lmcs:2067", "doi": "10.2168/LMCS-12(4:2)2016", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Spatial aspects of computation are becoming increasingly relevant in Computer\nScience, especially in the field of collective adaptive systems and when\ndealing with systems distributed in physical space. Traditional formal\nverification techniques are well suited to analyse the temporal evolution of\nprograms; however, properties of space are typically not taken into account\nexplicitly. We present a topology-based approach to formal verification of\nspatial properties depending upon physical space. We define an appropriate\nlogic, stemming from the tradition of topological interpretations of modal\nlogics, dating back to earlier logicians such as Tarski, where modalities\ndescribe neighbourhood. We lift the topological definitions to the more general\nsetting of closure spaces, also encompassing discrete, graph-based structures.\nWe extend the framework with a spatial surrounded operator, a propagation\noperator and with some collective operators. The latter are interpreted over\narbitrary sets of points instead of individual points in space. We define\nefficient model checking procedures, both for the individual and the collective\nspatial fragments of the logic and provide a proof-of-concept tool.\n", "versions": [{"version": "v1", "created": "Wed, 21 Sep 2016 11:57:44 GMT"}, {"version": "v2", "created": "Fri, 7 Oct 2016 20:48:08 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Ciancia", "Vincenzo", ""], ["Latella", "Diego", ""], ["Loreti", "Michele", ""], ["Massink", "Mieke", ""]]}, {"id": "1609.06951", "submitter": "Arne Meier", "authors": "Lauri Hella, Antti Kuusisto, Arne Meier, and Jonni Virtema", "title": "Model Checking and Validity in Propositional and Modal Inclusion Logics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Propositional and modal inclusion logic are formalisms that belong to the\nfamily of logics based on team semantics. This article investigates the model\nchecking and validity problems of these logics. We identify complexity bounds\nfor both problems, covering both lax and strict team semantics. By doing so, we\ncome close to finalising the programme that ultimately aims to classify the\ncomplexities of the central reasoning problems for modal and propositional\ndependence, independence, and inclusion logics.\n", "versions": [{"version": "v1", "created": "Thu, 22 Sep 2016 13:09:17 GMT"}, {"version": "v2", "created": "Mon, 24 Apr 2017 09:55:19 GMT"}], "update_date": "2017-04-25", "authors_parsed": [["Hella", "Lauri", ""], ["Kuusisto", "Antti", ""], ["Meier", "Arne", ""], ["Virtema", "Jonni", ""]]}, {"id": "1609.06954", "submitter": "Vaishak Belle", "authors": "Vaishak Belle, Luc De Raedt", "title": "Semiring Programming: A Declarative Framework for Generalized Sum\n  Product Problems", "comments": "In AAAI Workshop: Statistical Relational Artificial Intelligence,\n  2020", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  To solve hard problems, AI relies on a variety of disciplines such as logic,\nprobabilistic reasoning, machine learning and mathematical programming.\nAlthough it is widely accepted that solving real-world problems requires an\nintegration amongst these, contemporary representation methodologies offer\nlittle support for this.\n  In an attempt to alleviate this situation, we introduce a new declarative\nprogramming framework that provides abstractions of well-known problems such as\nSAT, Bayesian inference, generative models, and convex optimization. The\nsemantics of programs is defined in terms of first-order structures with\nsemiring labels, which allows us to freely combine and integrate problems from\ndifferent AI disciplines.\n", "versions": [{"version": "v1", "created": "Wed, 21 Sep 2016 08:17:40 GMT"}, {"version": "v2", "created": "Mon, 13 Jan 2020 13:55:44 GMT"}], "update_date": "2020-01-14", "authors_parsed": [["Belle", "Vaishak", ""], ["De Raedt", "Luc", ""]]}, {"id": "1609.07048", "submitter": "Arno Pauly", "authors": "St\\'ephane Le Roux and Arno Pauly and Jean-Fran\\c{c}ois Raskin", "title": "Minkowski games", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.GT cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce and study Minkowski games. These are two player games, where the\nplayers take turns to chose positions in $\\mathbb{R}^d$ based on some rules.\nVariants include boundedness games, where one player wants to keep the\npositions bounded, and the other wants to escape to infinity; as well as safety\ngames, where one player wants to stay within a prescribed set, while the other\nwants to leave it.\n  We provide some general characterizations of which player can win such games,\nand explore the computational complexity of the associated decision problems. A\nnatural representation of boundedness games yields coNP-completeness, whereas\nthe safety games are undecidable.\n", "versions": [{"version": "v1", "created": "Thu, 22 Sep 2016 16:10:15 GMT"}, {"version": "v2", "created": "Fri, 25 Nov 2016 17:40:33 GMT"}], "update_date": "2016-11-28", "authors_parsed": [["Roux", "St\u00e9phane Le", ""], ["Pauly", "Arno", ""], ["Raskin", "Jean-Fran\u00e7ois", ""]]}, {"id": "1609.07065", "submitter": "J\\\"urgen Koslowski", "authors": "David Sabel and Hans Zantema", "title": "Termination of Cycle Rewriting by Transformation and Matrix\n  Interpretation", "comments": "38 pages, 1 figure", "journal-ref": "Logical Methods in Computer Science, Volume 13, Issue 1 (March 17,\n  2017) lmcs:3206", "doi": "10.23638/LMCS-13(1:11)2017", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present techniques to prove termination of cycle rewriting, that is,\nstring rewriting on cycles, which are strings in which the start and end are\nconnected. Our main technique is to transform cycle rewriting into string\nrewriting and then apply state of the art techniques to prove termination of\nthe string rewrite system. We present three such transformations, and prove for\nall of them that they are sound and complete. In this way not only termination\nof string rewriting of the transformed system implies termination of the\noriginal cycle rewrite system, a similar conclusion can be drawn for\nnon-termination. Apart from this transformational approach, we present a\nuniform framework of matrix interpretations, covering most of the earlier\napproaches to automatically proving termination of cycle rewriting. All our\ntechniques serve both for proving termination and relative termination. We\npresent several experiments showing the power of our techniques.\n", "versions": [{"version": "v1", "created": "Thu, 22 Sep 2016 16:56:22 GMT"}, {"version": "v2", "created": "Thu, 16 Mar 2017 08:56:28 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Sabel", "David", ""], ["Zantema", "Hans", ""]]}, {"id": "1609.07127", "submitter": "Jacques Fleuriot", "authors": "Jacques Fleuriot, Steven Obua, Phil Scott", "title": "Social Network Processes in the Isabelle and Coq Theorem Proving\n  Communities", "comments": "15 pages, 13 figures, Research supported by EPSRC grant EP/L011794/1", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SI cs.AI cs.LO physics.soc-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We identify the main actors in the Isabelle and Coq communities and describe\nhow they affect and influence their peers. This work explores selected\nfoundations of social networking analysis that we expect to be useful in the\ncontext of the ProofPeer project, which is developing a new model for\ninteractive theorem proving based on collaboration and social interactions.\n", "versions": [{"version": "v1", "created": "Thu, 22 Sep 2016 19:46:08 GMT"}], "update_date": "2016-09-23", "authors_parsed": [["Fleuriot", "Jacques", ""], ["Obua", "Steven", ""], ["Scott", "Phil", ""]]}, {"id": "1609.07254", "submitter": "David Cerna", "authors": "David M. Cerna", "title": "Taking a Detour to Zero: An Alternative Formalization of Functions\n  Beyond PR", "comments": "Remains too incomplete and I would like to avoid future reference to\n  this work", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There are two well known systems formalizing total recursion beyond primitive\nrecursion (\\textbf{PR}), system \\textbf{T} by G\\\"odel and system \\textbf{F} by\nGirard and Reynolds. system \\textbf{T} defines recursion on typed objects and\ncan construct every function of Heyting arithmetic (\\textbf{HA}). System\n\\textbf{F} introduces type variables which can define the recursion of system\n\\textbf{T}. The result is a system as expressive as second-order Heyting\narithmetic (\\textbf{HA}$_{2}$). Though, both are able to express unimaginably\nfast growing functions, in some applications a more flexible formalism is\nneeded. One such application is CERES cut-elimination for schematic\n\\textbf{LK}-proofs ($CERES_{s}$) where the shape of the recursion is important.\nIn this paper we introduce a formalism for fast growing functions without a\ntype theory foundation. The recursion is indexed by ordered sets of natural\nnumbers. We highlight the relationship between our recursion and the Wainer\nhierarchy to provide an comparison to existing systems. We can show that our\nformalism expresses the functions expressible using system \\textbf{T}. We leave\ncomparison to system \\textbf{F} and beyond to future work.\n", "versions": [{"version": "v1", "created": "Fri, 23 Sep 2016 07:34:18 GMT"}, {"version": "v2", "created": "Tue, 11 Oct 2016 15:13:56 GMT"}, {"version": "v3", "created": "Wed, 3 Jan 2018 11:57:07 GMT"}], "update_date": "2018-01-04", "authors_parsed": [["Cerna", "David M.", ""]]}, {"id": "1609.07398", "submitter": "Antti Kuusisto", "authors": "Valentin Goranko and Antti Kuusisto", "title": "Logics for Propositional Determinacy and Independence", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper investigates formal logics for reasoning about determinacy and\nindependence. Propositional Dependence Logic D and Propositional Independence\nLogic I are recently developed logical systems, based on team semantics, that\nprovide a framework for such reasoning tasks. We introduce two new logics L_D\nand L_I, based on Kripke semantics, and propose them as alternatives for D and\nI, respectively. We analyze the relative expressive powers of these four logics\nand discuss the way these systems relate to natural language. We argue that L_D\nand L_I naturally resolve a range of interpretational problems that arise in D\nand I. We also obtain sound and complete axiomatizations for L_D and L_I.\n", "versions": [{"version": "v1", "created": "Fri, 23 Sep 2016 15:24:38 GMT"}, {"version": "v2", "created": "Sun, 3 Dec 2017 22:09:39 GMT"}], "update_date": "2017-12-05", "authors_parsed": [["Goranko", "Valentin", ""], ["Kuusisto", "Antti", ""]]}, {"id": "1609.07546", "submitter": "Xiaoxiao Yang", "authors": "Xiaoxiao Yang and Joost-Pieter Katoen and Huimin Lin and Hao Wu", "title": "Proving Linearizability via Branching Bisimulation", "comments": "In this paper, we conducted the experiment on 13 popular concurrent\n  data structures yielding promising results", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linearizability and progress properties are key correctness notions for\nconcurrent objects. However, model checking linearizability has suffered from\nthe PSPACE-hardness of the trace inclusion problem. This paper proposes to\nexploit branching bisimulation, a fundamental semantic equivalence relation\ndeveloped for process algebras which can be computed efficiently, in checking\nthese properties. A quotient construction is provided which results in huge\nstate space reductions. We confirm the advantages of the proposed approach on\nmore than a dozen benchmark problems.\n", "versions": [{"version": "v1", "created": "Sat, 24 Sep 2016 01:03:34 GMT"}, {"version": "v2", "created": "Tue, 27 Sep 2016 04:36:50 GMT"}, {"version": "v3", "created": "Wed, 28 Sep 2016 00:36:27 GMT"}, {"version": "v4", "created": "Thu, 29 Sep 2016 00:58:00 GMT"}, {"version": "v5", "created": "Fri, 30 Sep 2016 02:42:55 GMT"}], "update_date": "2016-10-03", "authors_parsed": [["Yang", "Xiaoxiao", ""], ["Katoen", "Joost-Pieter", ""], ["Lin", "Huimin", ""], ["Wu", "Hao", ""]]}, {"id": "1609.07593", "submitter": "Maciej Bendkowski", "authors": "Maciej Bendkowski, Katarzyna Grygiel, Pierre Lescanne, Marek Zaionc", "title": "Combinatorics of $\\lambda$-terms: a natural approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DM math.CO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider combinatorial aspects of $\\lambda$-terms in the model based on de\nBruijn indices where each building constructor is of size one. Surprisingly,\nthe counting sequence for $\\lambda$-terms corresponds also to two families of\nbinary trees, namely black-white trees and zigzag-free ones. We provide a\nconstructive proof of this fact by exhibiting appropriate bijections. Moreover,\nwe identify the sequence of Motzkin numbers with the counting sequence for\nneutral $\\lambda$-terms, giving a bijection which, in consequence, results in\nan exact-size sampler for the latter based on the exact-size sampler for\nMotzkin trees of Bodini et alli. Using the powerful theory of analytic\ncombinatorics, we state several results concerning the asymptotic growth rate\nof $\\lambda$-terms in neutral, normal, and head normal forms. Finally, we\ninvestigate the asymptotic density of $\\lambda$-terms containing arbitrary\nfixed subterms showing that, inter alia, strongly normalising or typeable terms\nare asymptotically negligible in the set of all $\\lambda$-terms.\n", "versions": [{"version": "v1", "created": "Sat, 24 Sep 2016 09:50:25 GMT"}, {"version": "v2", "created": "Fri, 14 Oct 2016 15:15:37 GMT"}], "update_date": "2016-10-17", "authors_parsed": [["Bendkowski", "Maciej", ""], ["Grygiel", "Katarzyna", ""], ["Lescanne", "Pierre", ""], ["Zaionc", "Marek", ""]]}, {"id": "1609.07684", "submitter": "Yifeng Ding", "authors": "Yifeng Ding", "title": "Axiomatization and complexity of modal logic with knowing-what operator\n  on model class K", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Standard epistemic logic studies propositional knowledge, yet many other\ntypes of knowledge such as \"knowing whether\", \"knowing what\", \"knowing how\" are\nfrequently and widely used in everyday life as well as academic fields. In\n\"Conditionally Knowing What\" by Wang and Fan, an axiomatization of the\nepistemic logic with both regular \"knowing that\" operator and \"conditionally\nknowing what\" operator is given. Then the decidability and complexity of this\nlogic command our study. In this paper, we direct our attention to the\narbitrary models instead of epistemic models, thus making things clearer, and\nthen give a axiomatization and a tableau for the modal logic with same\noperators on arbitrary Kripke models. Given the tableau of this logic, the\ncomplexity of the satisfiability problem of this logic is PSPACE-complete.\n", "versions": [{"version": "v1", "created": "Sun, 25 Sep 2016 00:36:21 GMT"}, {"version": "v2", "created": "Fri, 25 Nov 2016 04:26:37 GMT"}], "update_date": "2016-11-28", "authors_parsed": [["Ding", "Yifeng", ""]]}, {"id": "1609.07895", "submitter": "Thomas Seiller", "authors": "Thomas Seiller", "title": "Interaction Graphs: Nondeterministic Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper exhibits a series of semantic characterisations of sublinear\nnondeterministic complexity classes. These results fall into the general domain\nof logic-based approaches to complexity theory and so-called implicit\ncomputational complexity (ICC), i.e. descriptions of complexity classes without\nreference to specific machine models. In particular, it relates strongly to ICC\nresults based on linear logic since the semantic framework considered stems\nfrom work on the latter. Moreover, the obtained characterisations are of a\ngeometric nature: each class is characterised by a specific action of a group\nby measure-preserving maps.\n", "versions": [{"version": "v1", "created": "Mon, 26 Sep 2016 09:22:15 GMT"}], "update_date": "2016-09-27", "authors_parsed": [["Seiller", "Thomas", ""]]}, {"id": "1609.07972", "submitter": "Walid Gomaa", "authors": "Olivier Bournez, Walid Gomaa, Emmanuel Hainry", "title": "A Framework for Algebraic Characterizations in Recursive Analysis", "comments": "38 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Algebraic characterizations of the computational aspects of functions defined\nover the real numbers provide very effective tool to understand what\ncomputability and complexity over the reals, and generally over continuous\nspaces, mean. This is relevant for both communities of computer scientists and\nmathematical analysts, particularly the latter who do not understand (and/or\nlike) the language of machines and string encodings. Recursive analysis can be\nconsidered the most standard framework of computation over continuous spaces,\nit is however defined in a very machine specific way which does not leave much\nto intuitiveness. Recently several characterizations, in the form of function\nalgebras, of recursively computable functions and some sub-recursive classes\nwere introduced. These characterizations shed light on the hidden behavior of\nrecursive analysis as they convert complex computational operations on\nsequences of real objects to \"simple\" intuitive mathematical operations such as\nintegration or taking limits. The authors previously presented a framework for\nobtaining algebraic characterizations at the complexity level over compact\ndomains. The current paper presents a comprehensive extension to that\nframework. Though we focus our attention in this paper on functions defined\nover the whole real line, the framework, and accordingly the obtained results,\ncan be easily extended to functions defined over arbitrary domains.\n", "versions": [{"version": "v1", "created": "Mon, 26 Sep 2016 13:54:45 GMT"}], "update_date": "2016-09-27", "authors_parsed": [["Bournez", "Olivier", ""], ["Gomaa", "Walid", ""], ["Hainry", "Emmanuel", ""]]}, {"id": "1609.08367", "submitter": "J\\\"urgen Koslowski", "authors": "Helle Hvid Hansen, Clemens Kupke, Jan Rutten", "title": "Stream Differential Equations: Specification Formats and Solution\n  Methods", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 13, Issue 1 (February\n  3, 2017) lmcs:3118", "doi": "10.23638/LMCS-13(1:3)2017", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Streams, or infinite sequences, are infinite objects of a very simple type,\nyet they have a rich theory partly due to their ubiquity in mathematics and\ncomputer science. Stream differential equations are a coinductive method for\nspecifying streams and stream operations, and their theory has been developed\nin many papers over the past two decades. In this paper we present a survey of\nthe many results in this area. Our focus is on the classification of different\nformats of stream differential equations, their solution methods, and the\nclasses of streams they can define. Moreover, we describe in detail the\nconnection between the so-called syntactic solution method and abstract GSOS.\n", "versions": [{"version": "v1", "created": "Tue, 27 Sep 2016 11:56:31 GMT"}, {"version": "v2", "created": "Wed, 1 Feb 2017 14:07:38 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Hansen", "Helle Hvid", ""], ["Kupke", "Clemens", ""], ["Rutten", "Jan", ""]]}, {"id": "1609.08419", "submitter": "Lantian Li Mr.", "authors": "Lantian Li, Renyu Wang, Gang Wang, Caixia Wang, Thomas Fang Zheng", "title": "Decision Making Based on Cohort Scores for Speaker Verification", "comments": "APSIPA ASC 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SD cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Decision making is an important component in a speaker verification system.\nFor the conventional GMM-UBM architecture, the decision is usually conducted\nbased on the log likelihood ratio of the test utterance against the GMM of the\nclaimed speaker and the UBM. This single-score decision is simple but tends to\nbe sensitive to the complex variations in speech signals (e.g. text content,\nchannel, speaking style, etc.). In this paper, we propose a decision making\napproach based on multiple scores derived from a set of cohort GMMs (cohort\nscores). Importantly, these cohort scores are not simply averaged as in\nconventional cohort methods; instead, we employ a powerful discriminative model\nas the decision maker. Experimental results show that the proposed method\ndelivers substantial performance improvement over the baseline system,\nespecially when a deep neural network (DNN) is used as the decision maker, and\nthe DNN input involves some statistical features derived from the cohort\nscores.\n", "versions": [{"version": "v1", "created": "Tue, 27 Sep 2016 13:29:12 GMT"}], "update_date": "2016-09-28", "authors_parsed": [["Li", "Lantian", ""], ["Wang", "Renyu", ""], ["Wang", "Gang", ""], ["Wang", "Caixia", ""], ["Zheng", "Thomas Fang", ""]]}, {"id": "1609.08531", "submitter": "Anirban Bhattacharyya", "authors": "Anirban Bhattacharyya and Andrey Mokhov and Ken Pierce", "title": "An Empirical Comparison of Formalisms for Modelling and Analysis of\n  Dynamic Reconfiguration of Dependable Systems", "comments": "84 pages including 4 appendices, journal paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper uses a case study to evaluate empirically three formalisms of\ndifferent kinds for their suitability for the modelling and analysis of dynamic\nreconfiguration of dependable systems. The requirements on an ideal formalism\nfor dynamic software reconfiguration are defined. The reconfiguration of an\noffice workflow for order processing is described, and the requirements on the\nreconfiguration of the workflow are defined. The workflow is modelled using the\nVienna Development Method ($\\mathrm{VDM}$), conditional partial order graphs\n($\\mathrm{CPOGs}$), and the basic Calculus of Communicating Systems for dynamic\nprocess reconfiguration (basic $\\mathrm{CCS^{dp}}$), and verification of the\nreconfiguration requirements is attempted using the models. The formalisms are\nevaluated according to their ability to model the reconfiguration of the\nworkflow, to verify the requirements on the workflow's reconfiguration, and to\nmeet the requirements on an ideal formalism.\n", "versions": [{"version": "v1", "created": "Tue, 27 Sep 2016 16:59:50 GMT"}], "update_date": "2016-09-28", "authors_parsed": [["Bhattacharyya", "Anirban", ""], ["Mokhov", "Andrey", ""], ["Pierce", "Ken", ""]]}, {"id": "1609.08916", "submitter": "J\\\"urgen Koslowski", "authors": "Jasmin Christian Blanchette, Sascha B\\\"ohme, Andrei Popescu, Nicholas\n  Smallbone", "title": "Encoding Monomorphic and Polymorphic Types", "comments": "LMCS-2014-1018", "journal-ref": "Logical Methods in Computer Science, Volume 12, Issue 4 (April 27,\n  2017) lmcs:2628", "doi": "10.2168/LMCS-12(4:13)2016", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Many automatic theorem provers are restricted to untyped logics, and existing\ntranslations from typed logics are bulky or unsound. Recent research proposes\nmonotonicity as a means to remove some clutter when translating monomorphic to\nuntyped first-order logic. Here we pursue this approach systematically,\nanalysing formally a variety of encodings that further improve on efficiency\nwhile retaining soundness and completeness. We extend the approach to rank-1\npolymorphism and present alternative schemes that lighten the translation of\npolymorphic symbols based on the novel notion of \"cover\". The new encodings are\nimplemented in Isabelle/HOL as part of the Sledgehammer tool. We include\ninformal proofs of soundness and correctness, and have formalised the\nmonomorphic part of this work in Isabelle/HOL. Our evaluation finds the new\nencodings vastly superior to previous schemes.\n", "versions": [{"version": "v1", "created": "Wed, 28 Sep 2016 13:57:40 GMT"}, {"version": "v2", "created": "Thu, 29 Dec 2016 19:39:00 GMT"}, {"version": "v3", "created": "Fri, 30 Dec 2016 17:00:47 GMT"}], "update_date": "2019-03-14", "authors_parsed": [["Blanchette", "Jasmin Christian", ""], ["B\u00f6hme", "Sascha", ""], ["Popescu", "Andrei", ""], ["Smallbone", "Nicholas", ""]]}, {"id": "1609.09269", "submitter": "Matthew England Dr", "authors": "Matthew England and James H. Davenport", "title": "Experience with Heuristics, Benchmarks & Standards for Cylindrical\n  Algebraic Decomposition", "comments": "Presented at the 1st International Workshop on Satisfiability\n  Checking and Symbolic Computation (SC-Square 2016)", "journal-ref": "Proceedings of the 1st Workshop on Satisfiability Checking and\n  Symbolic Computation (SC2 '16), E. Abraham, J.H. Davenport and P. Fontaine\n  eds. CEUR Workshop Proceedings 1804, 2016. http://ceur-ws.org/Vol-1804/", "doi": null, "report-no": null, "categories": "cs.SC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the paper which inspired the SC-Square project, [E. Abraham, Building\nBridges between Symbolic Computation and Satisfiability Checking, Proc. ISSAC\n'15, pp. 1-6, ACM, 2015] the author identified the use of sophisticated\nheuristics as a technique that the Satisfiability Checking community excels in\nand from which it is likely the Symbolic Computation community could learn and\nprosper. To start this learning process we summarise our experience with\nheuristic development for the computer algebra algorithm Cylindrical Algebraic\nDecomposition. We also propose and discuss standards and benchmarks as another\narea where Symbolic Computation could prosper from Satisfiability Checking\nexpertise, noting that these have been identified as initial actions for the\nnew SC-Square community in the CSA project, as described in [E.~Abraham et al.,\nSC$^2$: Satisfiability Checking meets Symbolic Computation (Project Paper)},\nIntelligent Computer Mathematics (LNCS 9761), pp. 28--43, Springer, 2015].\n", "versions": [{"version": "v1", "created": "Thu, 29 Sep 2016 09:30:22 GMT"}], "update_date": "2017-03-14", "authors_parsed": [["England", "Matthew", ""], ["Davenport", "James H.", ""]]}, {"id": "1609.09288", "submitter": "George Karpenkov", "authors": "Egor George Karpenkov and David Monniaux", "title": "Formula Slicing: Inductive Invariants from Preconditions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a \"formula slicing\" method for finding inductive invariants. It is\nbased on the observation that many loops in the program affect only a small\npart of the memory, and many invariants which were valid before a loop are\nstill valid after.\n  Given a precondition of the loop, obtained from the preceding program\nfragment, we weaken it until it becomes inductive. The weakening procedure is\nguided by counterexamples-to-induction given by an SMT solver. Our algorithm\napplies to programs with arbitrary loop structure, and it computes the\nstrongest invariant in an abstract domain of weakenings of preconditions. We\ncall this algorithm \"formula slicing\", as it effectively performs \"slicing\" on\nformulas derived from symbolic execution.\n  We evaluate our algorithm on the device driver benchmarks from the\nInternational Competition on Software Verification (SV-COMP), and we show that\nit is competitive with the state-of-the-art verification techniques.\n", "versions": [{"version": "v1", "created": "Thu, 29 Sep 2016 10:27:15 GMT"}, {"version": "v2", "created": "Sun, 2 Oct 2016 09:48:12 GMT"}], "update_date": "2016-10-04", "authors_parsed": [["Karpenkov", "Egor George", ""], ["Monniaux", "David", ""]]}, {"id": "1609.09675", "submitter": "Thorsten Wissmann", "authors": "Bruno Courcelle", "title": "Algebraic and logical descriptions of generalized trees", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 13, Issue 3 (July 28,\n  2017) lmcs:3817", "doi": "10.23638/LMCS-13(3:7)2017", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Quasi-trees generalize trees in that the unique \"path\" between two nodes may\nbe infinite and have any countable order type. They are used to define the\nrank-width of a countable graph in such a way that it is equal to the least\nupper-bound of the rank-widths of its finite induced subgraphs. Join-trees are\nthe corresponding directed trees. They are useful to define the modular\ndecomposition of a countable graph. We also consider ordered join-trees, that\ngeneralize rooted trees equipped with a linear order on the set of sons of each\nnode. We define algebras with finitely many operations that generate (via\ninfinite terms) these generalized trees. We prove that the associated regular\nobjects (those defined by regular terms) are exactly the ones that are the\nunique models of monadic second-order sentences. These results use and\ngeneralize a similar result by W. Thomas for countable linear orders.\n", "versions": [{"version": "v1", "created": "Fri, 30 Sep 2016 11:30:57 GMT"}, {"version": "v2", "created": "Fri, 5 May 2017 11:28:02 GMT"}, {"version": "v3", "created": "Thu, 27 Jul 2017 17:02:43 GMT"}], "update_date": "2017-08-02", "authors_parsed": [["Courcelle", "Bruno", ""]]}, {"id": "1609.09728", "submitter": "Peter Chini", "authors": "Peter Chini, Jonathan Kolberg, Andreas Krebs, Roland Meyer, Prakash\n  Saivasan", "title": "On the Complexity of Bounded Context Switching", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bounded context switching (BCS) is an under-approximate method for finding\nviolations to safety properties in shared memory concurrent programs.\nTechnically, BCS is a reachability problem that is known to be NP-complete. Our\ncontribution is a parameterized analysis of BCS.\n  The first result is an algorithm that solves BCS when parameterized by the\nnumber of context switches (cs) and the size of the memory (m) in\nO*(m^(cs)2^(cs)). This is achieved by creating instances of the easier problem\nShuff which we solve via fast subset convolution. We also present a lower bound\nfor BCS of the form m^o(cs / log(cs)), based on the exponential time\nhypothesis. Interestingly, closing the gap means settling a conjecture that has\nbeen open since FOCS'07. Further, we prove that BCS admits no polynomial\nkernel.\n  Next, we introduce a measure, called scheduling dimension, that captures the\ncomplexity of schedules. We study BCS parameterized by the scheduling dimension\n(sdim) and show that it can be solved in O*((2m)^(4sdim)4^t)$, where t is the\nnumber of threads. We consider variants of the problem for which we obtain\n(matching) upper and lower bounds.\n", "versions": [{"version": "v1", "created": "Fri, 30 Sep 2016 13:44:32 GMT"}, {"version": "v2", "created": "Mon, 24 Apr 2017 13:34:44 GMT"}], "update_date": "2017-04-25", "authors_parsed": [["Chini", "Peter", ""], ["Kolberg", "Jonathan", ""], ["Krebs", "Andreas", ""], ["Meyer", "Roland", ""], ["Saivasan", "Prakash", ""]]}, {"id": "1609.09783", "submitter": "Paul-Andr\\'e Melli\\`es", "authors": "Paul-Andr\\'e Melli\\`es", "title": "Five Basic Concepts of Axiomatic Rewriting Theory", "comments": "6 pages, 4 figures, Invited talk at the International Workshop on\n  Confluence, Obergurgl 2016", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.PL math.CT math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this invited talk, I will review five basic concepts of Axiomatic\nRewriting Theory, an axiomatic and diagrammatic theory of rewriting started 25\nyears ago in a LICS paper with Georges Gonthier and Jean-Jacques L\\'evy, and\ndeveloped along the subsequent years into a full-fledged 2-dimensional theory\nof causality and residuation in rewriting. I will give a contemporary view on\nthe theory, informed by my later work on categorical semantics and\nhigher-dimensional algebra, and also indicate a number of current research\ndirections in the field.\n", "versions": [{"version": "v1", "created": "Tue, 27 Sep 2016 18:47:22 GMT"}], "update_date": "2016-10-03", "authors_parsed": [["Melli\u00e8s", "Paul-Andr\u00e9", ""]]}]