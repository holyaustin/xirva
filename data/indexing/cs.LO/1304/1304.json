[{"id": "1304.0084", "submitter": "Krishnendu Chatterjee", "authors": "Krishnendu Chatterjee and Jakub {\\L}\\k{a}cki", "title": "Faster Algorithms for Markov Decision Processes with Low Treewidth", "comments": "Conference version will appear in CAV 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider two core algorithmic problems for probabilistic verification: the\nmaximal end-component decomposition and the almost-sure reachability set\ncomputation for Markov decision processes (MDPs). For MDPs with treewidth $k$,\nwe present two improved static algorithms for both the problems that run in\ntime $O(n \\cdot k^{2.38} \\cdot 2^k)$ and $O(m \\cdot \\log n \\cdot k)$,\nrespectively, where $n$ is the number of states and $m$ is the number of edges,\nsignificantly improving the previous known $O(n\\cdot k \\cdot \\sqrt{n\\cdot k})$\nbound for low treewidth. We also present decremental algorithms for both\nproblems for MDPs with constant treewidth that run in amortized logarithmic\ntime, which is a huge improvement over the previously known algorithms that\nrequire amortized linear time.\n", "versions": [{"version": "v1", "created": "Sat, 30 Mar 2013 10:17:14 GMT"}, {"version": "v2", "created": "Wed, 30 Oct 2013 12:09:19 GMT"}], "update_date": "2016-08-11", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["\u0141\u0105cki", "Jakub", ""]]}, {"id": "1304.0272", "submitter": "Pedro Francisco Valencia Vizca\\'ino", "authors": "Pedro Francisco Valencia Vizca\\'ino", "title": "Relations between ex falso, tertium non datur, and double negation\n  elimination", "comments": "9 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show which implicational relations hold between the three principles ex\nfalso sequitur quodlibet, tertium non datur, and double negation elimination,\non the basis of minimal logic.\n", "versions": [{"version": "v1", "created": "Mon, 1 Apr 2013 01:08:26 GMT"}], "update_date": "2013-04-02", "authors_parsed": [["Vizca\u00edno", "Pedro Francisco Valencia", ""]]}, {"id": "1304.0558", "submitter": "Anton Salikhmetov", "authors": "Anton Salikhmetov", "title": "Lambda Calculus Synopsis", "comments": "8 pages, in Russian", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.GN math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This text gives a rough, but linear summary covering some key definitions,\nnotations, and propositions from Lambda Calculus: Its Syntax and Semantics, the\nclassical monograph by Barendregt. First, we define a theory of untyped\nextensional lambda calculus. Then, some syntactic sugar, a system of\ncombinatory logic, and the fixed point theorem are described. The final section\nintroduces a topology on the set of lambda terms which is meant to explain an\nillusory contradiction. Namely, functions defined on the set of lambda terms\nare in the set of lambda terms itself, the latter being a countable set.\nHowever, the functions on the set of lambda terms appear to be continuous with\nrespect to a topology of trees.\n", "versions": [{"version": "v1", "created": "Tue, 2 Apr 2013 08:27:00 GMT"}, {"version": "v2", "created": "Fri, 11 Oct 2013 10:35:14 GMT"}, {"version": "v3", "created": "Thu, 24 Oct 2013 20:16:53 GMT"}], "update_date": "2013-10-28", "authors_parsed": [["Salikhmetov", "Anton", ""]]}, {"id": "1304.0611", "submitter": "Fredrik Engstr\\\"om", "authors": "Fredrik Engstr\\\"om, Juha Kontinen and Jouko V\\\"a\\\"an\\\"anen", "title": "Dependence Logic with Generalized Quantifiers: Axiomatizations", "comments": "17 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove two completeness results, one for the extension of dependence logic\nby a monotone generalized quantifier Q with weak interpretation, weak in the\nmeaning that the interpretation of Q varies with the structures. The second\nresult considers the extension of dependence logic where Q is interpreted as\n\"there exists uncountable many.\" Both of the axiomatizations are shown to be\nsound and complete for FO(Q) consequences.\n", "versions": [{"version": "v1", "created": "Tue, 2 Apr 2013 12:21:09 GMT"}], "update_date": "2013-04-03", "authors_parsed": [["Engstr\u00f6m", "Fredrik", ""], ["Kontinen", "Juha", ""], ["V\u00e4\u00e4n\u00e4nen", "Jouko", ""]]}, {"id": "1304.0680", "submitter": "Chris Kapulkin", "authors": "Jeremy Avigad, Chris Kapulkin, and Peter LeFanu Lumsdaine", "title": "Homotopy limits in type theory", "comments": "33 pages; v3: theorem numbering changed since v2 to match journal\n  version", "journal-ref": "Math. Struct. Comp. Sci. 25 (2015) 1040-1070", "doi": "10.1017/S0960129514000498", "report-no": null, "categories": "math.LO cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Working in homotopy type theory, we provide a systematic study of homotopy\nlimits of diagrams over graphs, formalized in the Coq proof assistant. We\ndiscuss some of the challenges posed by this approach to formalizing\nhomotopy-theoretic material. We also compare our constructions with the more\nclassical approach to homotopy limits via fibration categories.\n", "versions": [{"version": "v1", "created": "Tue, 2 Apr 2013 16:33:50 GMT"}, {"version": "v2", "created": "Sat, 14 Jun 2014 00:41:25 GMT"}, {"version": "v3", "created": "Wed, 8 Jul 2015 03:10:22 GMT"}], "update_date": "2019-02-20", "authors_parsed": [["Avigad", "Jeremy", ""], ["Kapulkin", "Chris", ""], ["Lumsdaine", "Peter LeFanu", ""]]}, {"id": "1304.0829", "submitter": "Tony Tan", "authors": "Eryk Kopczynski and Tony Tan", "title": "Regular graphs and the spectra of two-variable logic with counting", "comments": "30 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC cs.DM math.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The {\\em spectrum} of a first-order logic sentence is the set of natural\nnumbers that are cardinalities of its finite models. In this paper we show that\nwhen restricted to using only two variables, but allowing counting quantifiers,\nthe spectra of first-order logic sentences are semilinear and hence, closed\nunder complement. At the heart of our proof are semilinear characterisations\nfor the existence of regular and biregular graphs, the class of graphs in which\nthere are a priori bounds on the degrees of the vertices.\n  Our proof also provides a simple characterisation of models of two-variable\nlogic with counting -- that is, up to renaming and extending the relation\nnames, they are simply a collection of regular and biregular graphs.\n", "versions": [{"version": "v1", "created": "Wed, 3 Apr 2013 03:15:45 GMT"}, {"version": "v2", "created": "Wed, 30 Oct 2013 19:06:16 GMT"}, {"version": "v3", "created": "Fri, 22 Nov 2013 23:04:12 GMT"}, {"version": "v4", "created": "Wed, 11 Jun 2014 16:18:28 GMT"}], "update_date": "2014-06-12", "authors_parsed": [["Kopczynski", "Eryk", ""], ["Tan", "Tony", ""]]}, {"id": "1304.0864", "submitter": "David Monniaux", "authors": "Alexis Fouilh\\'e (VERIMAG - IMAG), David Monniaux (VERIMAG - IMAG),\n  Micha\\\"el P\\'erin (VERIMAG - IMAG)", "title": "Efficient Generation of Correctness Certificates for the Abstract Domain\n  of Polyhedra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Polyhedra form an established abstract domain for inferring runtime\nproperties of programs using abstract interpretation. Computations on them need\nto be certified for the whole static analysis results to be trusted. In this\nwork, we look at how far we can get down the road of a posteriori verification\nto lower the overhead of certification of the abstract domain of polyhedra. We\ndemonstrate methods for making the cost of inclusion certificate generation\nnegligible. From a performance point of view, our single-representation,\nconstraints-based implementation compares with state-of-the-art\nimplementations.\n", "versions": [{"version": "v1", "created": "Wed, 3 Apr 2013 08:01:42 GMT"}], "update_date": "2013-04-04", "authors_parsed": [["Fouilh\u00e9", "Alexis", "", "VERIMAG - IMAG"], ["Monniaux", "David", "", "VERIMAG - IMAG"], ["P\u00e9rin", "Micha\u00ebl", "", "VERIMAG - IMAG"]]}, {"id": "1304.1119", "submitter": "Ronald Fagin", "authors": "Ronald Fagin, Joseph Y. Halpern", "title": "A New Approach to Updating Beliefs", "comments": "Appears in Proceedings of the Sixth Conference on Uncertainty in\n  Artificial Intelligence (UAI1990)", "journal-ref": null, "doi": null, "report-no": "UAI-P-1990-PG-317-325", "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define a new notion of conditional belief, which plays the same role for\nDempster-Shafer belief functions as conditional probability does for\nprobability functions. Our definition is different from the standard definition\ngiven by Dempster, and avoids many of the well-known problems of that\ndefinition. Just as the conditional probability Pr (lB) is a probability\nfunction which is the result of conditioning on B being true, so too our\nconditional belief function Bel (lB) is a belief function which is the result\nof conditioning on B being true. We define the conditional belief as the lower\nenvelope (that is, the inf) of a family of conditional probability functions,\nand provide a closed form expression for it. An alternate way of understanding\nour definition of conditional belief is provided by considering ideas from an\nearlier paper [Fagin and Halpern, 1989], where we connect belief functions with\ninner measures. In particular, we show here how to extend the definition of\nconditional probability to non measurable sets, in order to get notions of\ninner and outer conditional probabilities, which can be viewed as best\napproximations to the true conditional probability, given our lack of\ninformation. Our definition of conditional belief turns out to be an exact\nanalogue of our definition of inner conditional probability.\n", "versions": [{"version": "v1", "created": "Wed, 27 Mar 2013 13:58:06 GMT"}], "update_date": "2013-04-05", "authors_parsed": [["Fagin", "Ronald", ""], ["Halpern", "Joseph Y.", ""]]}, {"id": "1304.1185", "submitter": "Pierre Ganty", "authors": "Javier Esparza, Pierre Ganty, Rupak Majumdar", "title": "Parameterized Verification of Asynchronous Shared-Memory Systems", "comments": "26 pages, International Conference on Computer Aided Verification\n  (CAV'13)", "journal-ref": null, "doi": "10.1007/978-3-642-39799-8_8", "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We characterize the complexity of the safety verification problem for\nparameterized systems consisting of a leader process and arbitrarily many\nanonymous and identical contributors. Processes communicate through a shared,\nbounded-value register. While each operation on the register is atomic, there\nis no synchronization primitive to execute a sequence of operations atomically.\nWe analyze the complexity of the safety verification problem when processes are\nmodeled by finite-state machines, pushdown machines, and Turing machines. The\nproblem is coNP-complete when all processes are finite-state machines, and is\nPSPACE-complete when they are pushdown machines. The complexity remains\ncoNP-complete when each Turing machine is allowed boundedly many interactions\nwith the register. Our proofs use combinatorial characterizations of\ncomputations in the model, and in case of pushdown-systems, some\nlanguage-theoretic constructions of independent interest.\n", "versions": [{"version": "v1", "created": "Wed, 3 Apr 2013 20:56:20 GMT"}, {"version": "v2", "created": "Fri, 12 Jul 2013 18:47:44 GMT"}], "update_date": "2015-05-26", "authors_parsed": [["Esparza", "Javier", ""], ["Ganty", "Pierre", ""], ["Majumdar", "Rupak", ""]]}, {"id": "1304.1239", "submitter": "Victor Selivanov", "authors": "Victor Selivanov", "title": "Total Representations", "comments": "30 pages", "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 2 (June 2,\n  2013) lmcs:1191", "doi": "10.2168/LMCS-9(2:5)2013", "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Almost all representations considered in computable analysis are partial. We\nprovide arguments in favor of total representations (by elements of the Baire\nspace). Total representations make the well known analogy between numberings\nand representations closer, unify some terminology, simplify some technical\ndetails, suggest interesting open questions and new invariants of topological\nspaces relevant to computable analysis.\n", "versions": [{"version": "v1", "created": "Thu, 4 Apr 2013 03:52:07 GMT"}, {"version": "v2", "created": "Mon, 27 May 2013 00:38:28 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Selivanov", "Victor", ""]]}, {"id": "1304.1309", "submitter": "Anton Salikhmetov", "authors": "Anton Salikhmetov", "title": "Interaction Nets in Russian", "comments": "22 pages, in Russian", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Draft translation to Russian of Chapter 7, Interaction-Based Models of\nComputation, from Models of Computation: An Introduction to Computability\nTheory by Maribel Fernandez. \"In this chapter, we study interaction nets, a\nmodel of computation that can be seen as a representative of a class of models\nbased on the notion of 'computation as interaction'. Interaction nets are a\ngraphical model of computation devised by Yves Lafont in 1990 as a\ngeneralisation of the proof structures of linear logic. It can be seen as an\nabstract formalism, used to define algorithms and analyse their cost, or as a\nlow-level language into which other programming languages can be compiled. This\nis fruitful because interaction nets can be implemented with reasonable\nefficiency.\"\n", "versions": [{"version": "v1", "created": "Thu, 4 Apr 2013 10:39:02 GMT"}, {"version": "v2", "created": "Fri, 5 Apr 2013 19:44:03 GMT"}], "update_date": "2013-04-08", "authors_parsed": [["Salikhmetov", "Anton", ""]]}, {"id": "1304.1584", "submitter": "Kuldeep Meel", "authors": "Supratik Chakraborty, Kuldeep S. Meel and Moshe Y. Vardi", "title": "A Scalable and Nearly Uniform Generator of SAT Witnesses", "comments": "Conference version will appear in CAV 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Functional verification constitutes one of the most challenging tasks in the\ndevelopment of modern hardware systems, and simulation-based verification\ntechniques dominate the functional verification landscape. A dominant paradigm\nin simulation-based verification is directed random testing, where a model of\nthe system is simulated with a set of random test stimuli that are uniformly or\nnear-uniformly distributed over the space of all stimuli satisfying a given set\nof constraints. Uniform or near-uniform generation of solutions for large\nconstraint sets is therefore a problem of theoretical and practical interest.\nFor Boolean constraints, prior work offered heuristic approaches with no\nguarantee of performance, and theoretical approaches with proven guarantees,\nbut poor performance in practice. We offer here a new approach with theoretical\nperformance guarantees and demonstrate its practical utility on large\nconstraint sets.\n", "versions": [{"version": "v1", "created": "Thu, 4 Apr 2013 23:19:36 GMT"}], "update_date": "2013-04-08", "authors_parsed": [["Chakraborty", "Supratik", ""], ["Meel", "Kuldeep S.", ""], ["Vardi", "Moshe Y.", ""]]}, {"id": "1304.1647", "submitter": "Victor Selivanov", "authors": "Matthias Schroeder and Victor Selivanov", "title": "Some Hierarchies of QCB_0-Spaces", "comments": "24 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define and study hierarchies of topological spaces induced by the\nclassical Borel and Luzin hierarchies of sets. Our hierarchies are divided into\ntwo classes: hierarchies of countably based spaces induced by their embeddings\ninto the domain P\\omega, and hierarchies of spaces (not necessarily countably\nbased) induced by their admissible representations. We concentrate on the\nnon-collapse property of the hierarchies and on the relationships between\nhierarchies in the two classes.\n", "versions": [{"version": "v1", "created": "Fri, 5 Apr 2013 09:00:07 GMT"}], "update_date": "2013-04-08", "authors_parsed": [["Schroeder", "Matthias", ""], ["Selivanov", "Victor", ""]]}, {"id": "1304.1697", "submitter": "Dmitry Solomakhin", "authors": "Dmitry Solomakhin and Marco Montali and Sergio Tessaris and Riccardo\n  De Masellis", "title": "Verification of Artifact-Centric Systems: Decidability and Modeling\n  Issues", "comments": "artifact-centric systems, guard-stage-milestone, formal verification", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Artifact-centric business processes have recently emerged as an approach in\nwhich processes are centred around the evolution of business entities, called\nartifacts, giving equal importance to control-flow and data. The recent\nGuard-State-Milestone (GSM) approach provides means for specifying business\nartifacts lifecycles in a declarative manner, using constructs that match how\nexecutive-level stakeholders think about their business. However, it turns out\nthat formal verification of GSM is undecidable even for very simple\npropositional temporal properties. We attack this challenging problem by\ntranslating GSM into a well-studied formal framework. We exploit this\ntranslation to isolate an interesting class of state-bounded GSM models for\nwhich verification of sophisticated temporal properties is decidable. We then\nintroduce some guidelines to turn an arbitrary GSM model into a state-bounded,\nverifiable model.\n", "versions": [{"version": "v1", "created": "Fri, 5 Apr 2013 12:54:00 GMT"}], "update_date": "2013-04-08", "authors_parsed": [["Solomakhin", "Dmitry", ""], ["Montali", "Marco", ""], ["Tessaris", "Sergio", ""], ["De Masellis", "Riccardo", ""]]}, {"id": "1304.2290", "submitter": "Anton Salikhmetov", "authors": "Anton Salikhmetov", "title": "Macro Lambda Calculus", "comments": "3 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The goal of our Macro Lambda Calculus project (MLC) is to encode lambda terms\ninto interaction nets. Its software implementation will accept input in the\nnotation similar to lambda calculus allowing macro definitions. Output is\nsimilar to interaction calculus and is suitable for our Interaction Nets\nCompiler program (INC). In this paper, we describe the interaction system for\ncall-by-need evaluation and the mechanism of encoding lambda terms into this\nsystem which MLC is based on.\n", "versions": [{"version": "v1", "created": "Mon, 8 Apr 2013 18:17:32 GMT"}, {"version": "v2", "created": "Thu, 11 Apr 2013 15:28:37 GMT"}, {"version": "v3", "created": "Sat, 13 Apr 2013 09:03:54 GMT"}, {"version": "v4", "created": "Tue, 25 Jun 2013 18:22:25 GMT"}, {"version": "v5", "created": "Wed, 30 Apr 2014 15:21:16 GMT"}, {"version": "v6", "created": "Thu, 16 Apr 2015 19:18:29 GMT"}, {"version": "v7", "created": "Fri, 17 Apr 2015 06:30:12 GMT"}, {"version": "v8", "created": "Fri, 7 Aug 2015 08:37:32 GMT"}], "update_date": "2015-08-10", "authors_parsed": [["Salikhmetov", "Anton", ""]]}, {"id": "1304.2412", "submitter": "Marianna Nicolosi Asmundo", "authors": "Domenico Cantone and Marianna Nicolosi Asmundo", "title": "On the satisfiability problem for a 3-level quantified syllogistic", "comments": "arXiv admin note: text overlap with arXiv:1209.1943", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We show that a collection of three-sorted set-theoretic formulae, denoted\nTLQSR and which admits a restricted form of quantification over individual and\nset variables, has a solvable satisfiability problem by proving that it enjoys\na small model property, i.e., any satisfiable TLQSR-formula psi has a finite\nmodel whose size depends solely on the size of psi itself. We also introduce\nthe sublanguages (TLQSR)^h of TLQSR, whose formulae are characterized by having\nquantifier prefixes of length bounded by h \\geq 2 and some other syntactic\nconstraints, and we prove that each of them has the satisfiability problem\nNP-complete. Then, we show that the modal logic S5 can be formalized in\n(TLQSR)^3.\n", "versions": [{"version": "v1", "created": "Mon, 8 Apr 2013 20:18:26 GMT"}], "update_date": "2013-04-10", "authors_parsed": [["Cantone", "Domenico", ""], ["Asmundo", "Marianna Nicolosi", ""]]}, {"id": "1304.2814", "submitter": "Gilles Geeraerts", "authors": "Thomas Brihaye and Morgane Esti\\'evenart and Gilles Geeraerts", "title": "On MITL and alternating timed automata", "comments": "28 pages, 3 figures, submitted", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.FL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One clock alternating timed automata OCATA have been recently introduced as\nnatural extension of (one clock) timed automata to express the semantics of MTL\n(Ouaknine, Worrell 2005). We consider the application of OCATA to problem of\nmodel-checking MITL formulas (a syntactic fragment of MTL) against timed\nautomata. We introduce a new semantics for OCATA where, intuitively, clock\nvaluations are intervals instead of single real values. Thanks to this new\nsemantics, we show that we can bound the number of clock copies that are\nnecessary to allow an OCATA to recognise the models of an MITL formula.\nEquipped with this technique, we propose a new algorithm to translate an MITL\nformula into a timed automaton, and we sketch several ideas to define new model\nchecking algorithms for MITL.\n", "versions": [{"version": "v1", "created": "Tue, 9 Apr 2013 23:13:43 GMT"}], "update_date": "2013-04-11", "authors_parsed": [["Brihaye", "Thomas", ""], ["Esti\u00e9venart", "Morgane", ""], ["Geeraerts", "Gilles", ""]]}, {"id": "1304.2936", "submitter": "Chinmay Narayan", "authors": "Chinmay Narayan, Shibashis Guha, S.Arun-Kumar", "title": "Inferring Fences in a Concurrent Program Using SC proof of Correctness", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most proof systems for concurrent programs assume the underlying memory model\nto be sequentially consistent (SC), an assumption which does not hold for\nmodern multicore processors. These processors, for performance reasons,\nimplement relaxed memory models. As a result of this relaxation a program,\nproved correct on the SC memory model, might execute incorrectly. To ensure its\ncorrectness under relaxation, fence instructions are inserted in the code. In\nthis paper we show that the SC proof of correctness of an algorithm, carried\nout in the proof system of [Sou84], identifies per-thread instruction orderings\nsufficient for this SC proof. Further, to correctly execute this algorithm on\nan underlying relaxed memory model it is sufficient to respect only these\norderings by inserting fence instructions.\n", "versions": [{"version": "v1", "created": "Wed, 10 Apr 2013 12:34:37 GMT"}], "update_date": "2013-04-11", "authors_parsed": [["Narayan", "Chinmay", ""], ["Guha", "Shibashis", ""], ["Arun-Kumar", "S.", ""]]}, {"id": "1304.2948", "submitter": "Thierry Martinez", "authors": "Faten Nabli (INRIA Rocquencourt), Fran\\c{c}ois Fages (INRIA\n  Rocquencourt), Thierry Martinez (INRIA Rocquencourt), Sylvain Soliman (INRIA\n  Rocquencourt)", "title": "Un mod\\`ele bool\\'een pour l'\\'enum\\'eration des siphons et des pi\\`eges\n  minimaux dans les r\\'eseaux de Petri", "comments": "JFPC 2012 (2012)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Petri-nets are a simple formalism for modeling concurrent computation.\nRecently, they have emerged as a powerful tool for the modeling and analysis of\nbiochemical reaction networks, bridging the gap between purely qualitative and\nquantitative models. These networks can be large and complex, which makes their\nstudy difficult and computationally challenging. In this paper, we focus on two\nstructural properties of Petri-nets, siphons and traps, that bring us\ninformation about the persistence of some molecular species. We present two\nmethods for enumerating all minimal siphons and traps of a Petri-net by\niterating the resolution of a boolean model interpreted as either a SAT or a\nCLP(B) program. We compare the performance of these methods with a\nstate-of-the-art dedicated algorithm of the Petri-net community. We show that\nthe SAT and CLP(B) programs are both faster. We analyze why these programs\nperform so well on the models of the repository of biological models\nbiomodels.net, and propose some hard instances for the problem of minimal\nsiphons enumeration.\n", "versions": [{"version": "v1", "created": "Wed, 10 Apr 2013 13:23:06 GMT"}], "update_date": "2013-04-11", "authors_parsed": [["Nabli", "Faten", "", "INRIA Rocquencourt"], ["Fages", "Fran\u00e7ois", "", "INRIA\n  Rocquencourt"], ["Martinez", "Thierry", "", "INRIA Rocquencourt"], ["Soliman", "Sylvain", "", "INRIA\n  Rocquencourt"]]}, {"id": "1304.3121", "submitter": "Owen Stephens", "authors": "Julian Rathke, Pawel Sobocinski, Owen Stephens", "title": "Decomposing Petri nets", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In recent work, the second and third authors introduced a technique for\nreachability checking in 1-bounded Petri nets, based on wiring decompositions,\nwhich are expressions in a fragment of the compositional algebra of nets with\nboundaries. Here we extend the technique to the full algebra and introduce the\nrelated structural property of decomposition width on directed hypergraphs.\nSmall decomposition width is necessary for the applicability of the\nreachability checking algorithm. We give examples of families of nets with\nconstant decomposition width and develop the underlying theory of\ndecompositions.\n", "versions": [{"version": "v1", "created": "Wed, 10 Apr 2013 16:23:38 GMT"}], "update_date": "2013-04-12", "authors_parsed": [["Rathke", "Julian", ""], ["Sobocinski", "Pawel", ""], ["Stephens", "Owen", ""]]}, {"id": "1304.3249", "submitter": "Paolo Parisen Toldin", "authors": "Jean-Yves Moyen, Paolo Parisen Toldin", "title": "A polytime complexity analyser for Probabilistic Polynomial Time over\n  imperative stack programs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  We present iSAPP (Imperative Static Analyser for Probabilistic Polynomial\nTime), a complexity verifier tool that is sound and extensionally complete for\nthe Probabilistic Polynomial Time (PP) complexity class. iSAPP works on an\nimperative programming language for stack machines. The certificate of\npolynomiality can be built in polytime, with respect to the number of stacks\nused.\n", "versions": [{"version": "v1", "created": "Thu, 11 Apr 2013 10:20:24 GMT"}], "update_date": "2013-04-12", "authors_parsed": [["Moyen", "Jean-Yves", ""], ["Toldin", "Paolo Parisen", ""]]}, {"id": "1304.4091", "submitter": "Giovanni Birolo", "authors": "Giovanni Birolo", "title": "Interactive Realizability, Monads and Witness Extraction", "comments": "This is a draft of the author's Ph.D. dissertation", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this dissertation we collect some results about \"interactive\nrealizability\", a realizability semantics that extends the\nBrouwer-Heyting-Kolmogorov interpretation to (sub-)classical logic, more\nprecisely to first-order intuitionistic arithmetic (Heyting Arithmetic, HA)\nextended by the law of the excluded middle restricted to simply existential\nformulas formulas (EM1), a system motivated by its interest in proof mining.\n  We describe the interactive interpretation of a classical proof involving\nreal numbers. The statement we prove is a simple but non-trivial fact about\npoints in the real plane. The proof employs EM1 to deduce properties of the\nordering on the real numbers, which is undecidable and thus problematic from a\nconstructive point of view.\n  We present a new set of reductions for derivations in natural deduction that\ncan extract witnesses from closed derivations of simply existential formulas in\nHA + EM1. The reduction we present are inspired by the informal idea of\nlearning by making falsifiable hypothesis and checking them, and by the\ninteractive realizability interpretation. We extract the witnesses directly\nfrom derivations in HA + EM1 by reduction, without encoding derivations by a\nrealizability interpretation.\n  We give a new presentation of interactive realizability with a more explicit\nsyntax. We express interactive realizers by means of an abstract framework that\napplies the monadic approach used in functional programming to modified\nrealizability, in order to obtain less strict notions of realizability that are\nsuitable to classical logic. In particular we use a combination of the state\nand exception monads in order to capture the learning-from-mistakes nature of\ninteractive realizers.\n", "versions": [{"version": "v1", "created": "Mon, 15 Apr 2013 13:27:22 GMT"}], "update_date": "2013-04-16", "authors_parsed": [["Birolo", "Giovanni", ""]]}, {"id": "1304.4159", "submitter": "Olle Fredriksson", "authors": "Olle Fredriksson and Dan R. Ghica", "title": "Abstract machines for game semantics, revisited", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define new abstract machines for game semantics which correspond to\nnetworks of conventional computers, and can be used as an intermediate\nrepresentation for compilation targeting distributed systems. This is achieved\nin two steps. First we introduce the HRAM, a Heap and Register Abstract\nMachine, an abstraction of a conventional computer, which can be structured\ninto HRAM nets, an abstract point-to-point network model. HRAMs are\nmulti-threaded and subsume communication by tokens (cf. IAM) or jumps. Game\nAbstract Machines (GAM), are HRAMs with additional structure at the interface\nlevel, but no special operational capabilities. We show that GAMs cannot be\nnaively composed, but composition must be mediated using appropriate HRAM\ncombinators. HRAMs are flexible enough to allow the representation of game\nmodels for languages with state (non-innocent games) or concurrency\n(non-alternating games). We illustrate the potential of this technique by\nimplementing a toy distributed compiler for ICA, a higher-order programming\nlanguage with shared state concurrency, thus significantly extending our\nprevious distributed PCF compiler. We show that compilation is sound and\nmemory-safe, i.e. no (distributed or local) garbage collection is necessary.\n", "versions": [{"version": "v1", "created": "Mon, 15 Apr 2013 16:29:47 GMT"}], "update_date": "2013-04-16", "authors_parsed": [["Fredriksson", "Olle", ""], ["Ghica", "Dan R.", ""]]}, {"id": "1304.4164", "submitter": "Miika Hannula", "authors": "Miika Hannula", "title": "Axiomatizing first-order consequences in independence logic", "comments": "arXiv admin note: text overlap with arXiv:1208.0176 by other authors", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Independence logic cannot be effectively axiomatized. However, first-order\nconsequences of independence logic sentences can be axiomatized. In this\narticle we give an explicit axiomatization and prove that it is complete in\nthis sense. The proof is a generalization of the similar result for dependence\nlogic.\n", "versions": [{"version": "v1", "created": "Mon, 15 Apr 2013 16:48:21 GMT"}, {"version": "v2", "created": "Tue, 13 Oct 2015 10:22:33 GMT"}], "update_date": "2015-10-14", "authors_parsed": [["Hannula", "Miika", ""]]}, {"id": "1304.4267", "submitter": "Pietro Galliani Dr", "authors": "Pietro Galliani and Lauri Hella", "title": "Inclusion Logic and Fixed Point Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We investigate the properties of Inclusion Logic, that is, First Order Logic\nwith Team Semantics extended with inclusion dependencies. We prove that\nInclusion Logic is equivalent to Greatest Fixed Point Logic, and we prove that\nall union-closed first-order definable properties of relations are definable in\nit. We also provide an Ehrenfeucht-Fra\\\"iss\\'e game for Inclusion Logic, and\ngive an example illustrating its use.\n", "versions": [{"version": "v1", "created": "Mon, 15 Apr 2013 20:58:46 GMT"}, {"version": "v2", "created": "Wed, 17 Apr 2013 07:51:34 GMT"}, {"version": "v3", "created": "Tue, 30 Apr 2013 10:36:55 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Galliani", "Pietro", ""], ["Hella", "Lauri", ""]]}, {"id": "1304.4287", "submitter": "Barnaby Martin", "authors": "Stefan Dantchev and Barnaby Martin", "title": "Relativisation makes contradictions harder for Resolution", "comments": null, "journal-ref": "Ann. Pure Appl. Logic 165(3): 837-857 (2014)", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We provide a number of simplified and improved separations between pairs of\nResolution-with-bounded-conjunction refutation systems, Res(d), as well as\ntheir tree-like versions, Res*(d). The contradictions we use are natural\ncombinatorial principles: the Least number principle, LNP_n and an ordered\nvariant thereof, the Induction principle, IP_n.\n  LNP_n is known to be easy for Resolution. We prove that its relativisation is\nhard for Resolution, and more generally, the relativisation of LNP_n iterated d\ntimes provides a separation between Res(d) and Res(d+1). We prove the same\nresult for the iterated relativisation of IP_n, where the tree-like variant\nRes*(d) is considered instead of Res(d).\n  We go on to provide separations between the parameterized versions of Res(1)\nand Res(2). Here we are able again to use the relativisation of the LNP_n, but\nthe classical proof breaks down and we are forced to use an alternative.\nFinally, we separate the parameterized versions of Res*(1) and Res*(2). Here,\nthe relativisation of IP_n will not work as it is, and so we make a vectorising\namendment to it in order to address this shortcoming\n", "versions": [{"version": "v1", "created": "Mon, 15 Apr 2013 22:59:03 GMT"}, {"version": "v2", "created": "Wed, 29 Oct 2014 14:09:57 GMT"}], "update_date": "2014-10-30", "authors_parsed": [["Dantchev", "Stefan", ""], ["Martin", "Barnaby", ""]]}, {"id": "1304.4391", "submitter": "Miika Hannula", "authors": "Pietro Galliani, Miika Hannula and Juha Kontinen", "title": "Hierarchies in independence logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the expressive power of fragments of inclusion and independence\nlogic defined either by restricting the number of universal quantifiers or the\narity of inclusion and independence atoms in formulas. Assuming the so-called\nlax semantics for these logics, we relate these fragments of inclusion and\nindependence logic to familiar sublogics of existential second-order logic. We\nalso show that, with respect to the stronger strict semantics, inclusion logic\nis equivalent to existential second-order logic.\n", "versions": [{"version": "v1", "created": "Tue, 16 Apr 2013 10:43:10 GMT"}], "update_date": "2013-04-17", "authors_parsed": [["Galliani", "Pietro", ""], ["Hannula", "Miika", ""], ["Kontinen", "Juha", ""]]}, {"id": "1304.4499", "submitter": "Francesco Alberti", "authors": "Francesco Alberti and Silvio Ghilardi and Natasha Sharygina", "title": "Abstraction and Acceleration in SMT-based Model-Checking for Array\n  Programs", "comments": "Published in the proceedings of the 9th International Symposium on\n  Frontiers of Combining Systems (FroCoS) with the title \"Definability of\n  Accelerated Relations in a Theory of Arrays and its Applications\" (available\n  at http://www.springerlink.com)", "journal-ref": null, "doi": "10.1007/978-3-642-40885-4_3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Abstraction (in its various forms) is a powerful established technique in\nmodel-checking; still, when unbounded data-structures are concerned, it cannot\nalways cope with divergence phenomena in a satisfactory way. Acceleration is an\napproach which is widely used to avoid divergence, but it has been applied\nmostly to integer programs. This paper addresses the problem of accelerating\ntransition relations for unbounded arrays with the ultimate goal of avoiding\ndivergence during reachability analysis of abstract programs. For this, we\nfirst design a format to compute accelerations in this domain; then we show how\nto adapt the so-called 'monotonic abstraction' technique to efficiently handle\ncomplex formulas with nested quantifiers generated by the acceleration\npreprocessing. Notably, our technique can be easily plugged-in into\nabstraction/refinement loops, and strongly contributes to avoid divergence:\nexperiments conducted with the MCMT model checker attest the effectiveness of\nour approach on programs with unbounded arrays, where acceleration and\nabstraction/refinement technologies fail if applied alone.\n", "versions": [{"version": "v1", "created": "Tue, 16 Apr 2013 15:50:18 GMT"}, {"version": "v2", "created": "Thu, 3 Oct 2013 07:35:15 GMT"}], "update_date": "2013-10-04", "authors_parsed": [["Alberti", "Francesco", ""], ["Ghilardi", "Silvio", ""], ["Sharygina", "Natasha", ""]]}, {"id": "1304.4557", "submitter": "Lionel Rieg", "authors": "Lionel Rieg (LIP)", "title": "Extracting Herbrand trees from Coq", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Software certification aims at proving the correctness of programs but in\nmany cases, the use of external libraries allows only a conditional proof: it\ndepends on the assumption that the libraries meet their specifications. In\nparticular, a bug in these libraries might still impact the certified program.\nIn this case, the difficulty that arises is to isolate the defective library\nfunction and provide a counter-example. In this paper, we show that this\nproblem can be logically formalized as the construction of a Herbrand tree for\na contradictory universal theory and address it. The solution we propose is\nbased on a proof of Herbrand's theorem in the proof assistant Coq. Classical\nprogram extraction using Krivine's classical realizability then translates this\nproof into a certified program that computes Herbrand trees. Using this tree\nand calls to the library functions, we are able to determine which function is\ndefective and explicitly produce a counter-example to its specification.\n", "versions": [{"version": "v1", "created": "Tue, 16 Apr 2013 19:05:21 GMT"}], "update_date": "2013-04-17", "authors_parsed": [["Rieg", "Lionel", "", "LIP"]]}, {"id": "1304.4633", "submitter": "Brendan Juba", "authors": "Brendan Juba", "title": "PAC Quasi-automatizability of Resolution over Restricted Distributions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider principled alternatives to unsupervised learning in data mining\nby situating the learning task in the context of the subsequent analysis task.\nSpecifically, we consider a query-answering (hypothesis-testing) task: In the\ncombined task, we decide whether an input query formula is satisfied over a\nbackground distribution by using input examples directly, rather than invoking\na two-stage process in which (i) rules over the distribution are learned by an\nunsupervised learning algorithm and (ii) a reasoning algorithm decides whether\nor not the query formula follows from the learned rules. In a previous work\n(2013), we observed that the learning task could satisfy numerous desirable\ncriteria in this combined context -- effectively matching what could be\nachieved by agnostic learning of CNFs from partial information -- that are not\nknown to be achievable directly. In this work, we show that likewise, there are\nreasoning tasks that are achievable in such a combined context that are not\nknown to be achievable directly (and indeed, have been seriously conjectured to\nbe impossible, cf. (Alekhnovich and Razborov, 2008)). Namely, we test for a\nresolution proof of the query formula of a given size in quasipolynomial time\n(that is, \"quasi-automatizing\" resolution). The learning setting we consider is\na partial-information, restricted-distribution setting that generalizes\nlearning parities over the uniform distribution from partial information,\nanother task that is known not to be achievable directly in various models (cf.\n(Ben-David and Dichterman, 1998) and (Michael, 2010)).\n", "versions": [{"version": "v1", "created": "Tue, 16 Apr 2013 22:10:26 GMT"}], "update_date": "2013-04-18", "authors_parsed": [["Juba", "Brendan", ""]]}, {"id": "1304.5185", "submitter": "Roman Kontchakov", "authors": "Alessandro Artale and Roman Kontchakov and Frank Wolter and Michael\n  Zakharyaschev", "title": "Temporal Description Logic for Ontology-Based Data Access (Extended\n  Version)", "comments": "Full version of the IJCAI 2013 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Our aim is to investigate ontology-based data access over temporal data with\nvalidity time and ontologies capable of temporal conceptual modelling. To this\nend, we design a temporal description logic, TQL, that extends the standard\nontology language OWL 2 QL, provides basic means for temporal conceptual\nmodelling and ensures first-order rewritability of conjunctive queries for\nsuitably defined data instances with validity time.\n", "versions": [{"version": "v1", "created": "Thu, 18 Apr 2013 16:50:16 GMT"}, {"version": "v2", "created": "Tue, 30 Apr 2013 18:27:41 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Artale", "Alessandro", ""], ["Kontchakov", "Roman", ""], ["Wolter", "Frank", ""], ["Zakharyaschev", "Michael", ""]]}, {"id": "1304.5199", "submitter": "Frederic Magniez", "authors": "M.C. Gaudel and R. Lassaigne and F. Magniez and M. de Rougemont", "title": "Some approximations in Model Checking and Testing", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Model checking and testing are two areas with a similar goal: to verify that\na system satisfies a property. They start with different hypothesis on the\nsystems and develop many techniques with different notions of approximation,\nwhen an exact verification may be computationally too hard. We present some\nnotions of approximation with their logic and statistics backgrounds, which\nyield several techniques for model checking and testing: Bounded Model\nChecking, Approximate Model Checking, Approximate Black-Box Checking,\nApproximate Model-based Testing and Approximate Probabilistic Model Checking.\nAll these methods guarantee some quality and efficiency of the verification.\n", "versions": [{"version": "v1", "created": "Tue, 16 Apr 2013 13:20:16 GMT"}], "update_date": "2013-04-19", "authors_parsed": [["Gaudel", "M. C.", ""], ["Lassaigne", "R.", ""], ["Magniez", "F.", ""], ["de Rougemont", "M.", ""]]}, {"id": "1304.5278", "submitter": "Jan K\\v{r}et\\'insk\\'y", "authors": "Jan K\\v{r}et\\'insk\\'y and Salomon Sickert", "title": "On Refinements of Boolean and Parametric Modal Transition Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the extensions of modal transition systems (MTS), namely Boolean\nMTS and parametric MTS and we investigate the refinement problems over both\nclasses. Firstly, we reduce the problem of modal refinement over both classes\nto a problem solvable by a QBF solver and provide experimental results showing\nour technique scales well. Secondly, we extend the algorithm for thorough\nrefinement of MTS providing better complexity then via reductions to previously\nstudied problems. Finally, we investigate the relationship between modal and\nthorough refinement on the two classes and show how the thorough refinement can\nbe approximated by the modal refinement.\n", "versions": [{"version": "v1", "created": "Thu, 18 Apr 2013 23:17:06 GMT"}], "update_date": "2013-04-22", "authors_parsed": [["K\u0159et\u00ednsk\u00fd", "Jan", ""], ["Sickert", "Salomon", ""]]}, {"id": "1304.5281", "submitter": "Jan K\\v{r}et\\'insk\\'y", "authors": "Krishnendu Chatterjee and Andreas Gaiser and Jan K\\v{r}et\\'insk\\'y", "title": "Automata with Generalized Rabin Pairs for Probabilistic Model Checking\n  and LTL Synthesis", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The model-checking problem for probabilistic systems crucially relies on the\ntranslation of LTL to deterministic Rabin automata (DRW). Our recent Safraless\ntranslation for the LTL(F,G) fragment produces smaller automata as compared to\nthe traditional approach. In this work, instead of DRW we consider\ndeterministic automata with acceptance condition given as disjunction of\ngeneralized Rabin pairs (DGRW). The Safraless translation of LTL(F,G) formulas\nto DGRW results in smaller automata as compared to DRW. We present algorithms\nfor probabilistic model-checking as well as game solving for DGRW conditions.\nOur new algorithms lead to improvement both in terms of theoretical bounds as\nwell as practical evaluation. We compare PRISM with and without our new\ntranslation, and show that the new translation leads to significant\nimprovements.\n", "versions": [{"version": "v1", "created": "Thu, 18 Apr 2013 23:26:55 GMT"}], "update_date": "2013-04-22", "authors_parsed": [["Chatterjee", "Krishnendu", ""], ["Gaiser", "Andreas", ""], ["K\u0159et\u00ednsk\u00fd", "Jan", ""]]}, {"id": "1304.5438", "submitter": "EPTCS", "authors": "Thomas Brihaye (University of Mons), Quentin Menet (University of\n  Mons)", "title": "Simple strategies for Banach-Mazur games and fairly correct systems", "comments": "In Proceedings GandALF 2013, arXiv:1307.4162", "journal-ref": "EPTCS 119, 2013, pp. 21-34", "doi": "10.4204/EPTCS.119.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In 2006, Varacca and V\\\"olzer proved that on finite graphs, omega-regular\nlarge sets coincide with omega-regular sets of probability 1, by using the\nexistence of positional strategies in the related Banach-Mazur games. Motivated\nby this result, we try to understand relations between sets of probability 1\nand various notions of simple strategies (including those introduced in a\nrecent paper of Gr\\\"adel and Lessenich). Then, we introduce a generalisation of\nthe classical Banach-Mazur game and in particular, a probabilistic version\nwhose goal is to characterise sets of probability 1 (as classical Banach-Mazur\ngames characterise large sets). We obtain a determinacy result for these games,\nwhen the winning set is a countable intersection of open sets.\n", "versions": [{"version": "v1", "created": "Fri, 19 Apr 2013 14:53:04 GMT"}, {"version": "v2", "created": "Wed, 17 Jul 2013 04:12:09 GMT"}], "update_date": "2013-07-18", "authors_parsed": [["Brihaye", "Thomas", "", "University of Mons"], ["Menet", "Quentin", "", "University of\n  Mons"]]}, {"id": "1304.5602", "submitter": "Linh Anh Nguyen D.Sc.", "authors": "Ali Rezaei Divroodi and Linh Anh Nguyen", "title": "Bisimulation-Based Comparisons for Interpretations in Description Logics", "comments": "arXiv admin note: text overlap with arXiv:1104.1964", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study comparisons between interpretations in description logics with\nrespect to \"logical consequences\" of the form of semi-positive concepts (like\nsemi-positive concept assertions). Such comparisons are characterized by\nconditions similar to the ones of bisimulations. The simplest among the\nconsidered logics is a variant of PDL (propositional dynamic logic). The others\nextend that logic with inverse roles, nominals, quantified number restrictions,\nthe universal role, and/or the concept constructor for expressing the local\nreflexivity of a role. The studied problems are: preservation of semi-positive\nconcepts with respect to comparisons, the Hennessy-Milner property for\ncomparisons, and minimization of interpretations that preserves semi-positive\nconcepts.\n", "versions": [{"version": "v1", "created": "Sat, 20 Apr 2013 08:37:52 GMT"}], "update_date": "2013-04-23", "authors_parsed": [["Divroodi", "Ali Rezaei", ""], ["Nguyen", "Linh Anh", ""]]}, {"id": "1304.5661", "submitter": "Viktor Kuncak", "authors": "Etienne Kneuss, Viktor Kuncak, Ivan Kuraj, and Philippe Suter", "title": "On Integrating Deductive Synthesis and Verification Systems", "comments": "17 pages. 46 references", "journal-ref": null, "doi": null, "report-no": "EPFL-REPORT-186043", "categories": "cs.PL cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe techniques for synthesis and verification of recursive functional\nprograms over unbounded domains. Our techniques build on top of an algorithm\nfor satisfiability modulo recursive functions, a framework for deductive\nsynthesis, and complete synthesis procedures for algebraic data types. We\npresent new counterexample-guided algorithms for constructing verified\nprograms. We have implemented these algorithms in an integrated environment for\ninteractive verification and synthesis from relational specifications. Our\nsystem was able to synthesize a number of useful recursive functions that\nmanipulate unbounded numbers and data structures.\n", "versions": [{"version": "v1", "created": "Sat, 20 Apr 2013 18:58:36 GMT"}], "update_date": "2013-04-23", "authors_parsed": [["Kneuss", "Etienne", ""], ["Kuncak", "Viktor", ""], ["Kuraj", "Ivan", ""], ["Suter", "Philippe", ""]]}, {"id": "1304.5806", "submitter": "Ond\\v{r}ej Leng\\'al", "authors": "Lukas Holik and Ondrej Lengal and Adam Rogalewicz and Jiri Simacek and\n  Tomas Vojnar", "title": "Fully Automated Shape Analysis Based on Forest Automata", "comments": "Accepted to CAV'13", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Forest automata (FA) have recently been proposed as a tool for shape analysis\nof complex heap structures. FA encode sets of tree decompositions of heap\ngraphs in the form of tuples of tree automata. In order to allow for\nrepresenting complex heap graphs, the notion of FA allowed one to provide\nuser-defined FA (called boxes) that encode repetitive graph patterns of shape\ngraphs to be used as alphabet symbols of other, higher-level FA. In this paper,\nwe propose a novel technique of automatically learning the FA to be used as\nboxes that avoids the need of providing them manually. Further, we propose a\nsignificant improvement of the automata abstraction used in the analysis. The\nresult is an efficient, fully-automated analysis that can handle even as\ncomplex data structures as skip lists, with the performance comparable to\nstate-of-the-art fully-automated tools based on separation logic, which,\nhowever, specialise in dealing with linked lists only.\n", "versions": [{"version": "v1", "created": "Sun, 21 Apr 2013 22:10:02 GMT"}], "update_date": "2013-04-23", "authors_parsed": [["Holik", "Lukas", ""], ["Lengal", "Ondrej", ""], ["Rogalewicz", "Adam", ""], ["Simacek", "Jiri", ""], ["Vojnar", "Tomas", ""]]}, {"id": "1304.5823", "submitter": "Edward Grefenstette", "authors": "Edward Grefenstette", "title": "Towards a Formal Distributional Semantics: Simulating Logical Calculi\n  with Tensors", "comments": "10 pages, to appear in Proceedings of the Second Joint Conference on\n  Lexical and Computational Semantics. June 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.CL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The development of compositional distributional models of semantics\nreconciling the empirical aspects of distributional semantics with the\ncompositional aspects of formal semantics is a popular topic in the\ncontemporary literature. This paper seeks to bring this reconciliation one step\nfurther by showing how the mathematical constructs commonly used in\ncompositional distributional models, such as tensors and matrices, can be used\nto simulate different aspects of predicate logic.\n  This paper discusses how the canonical isomorphism between tensors and\nmultilinear maps can be exploited to simulate a full-blown quantifier-free\npredicate calculus using tensors. It provides tensor interpretations of the set\nof logical connectives required to model propositional calculi. It suggests a\nvariant of these tensor calculi capable of modelling quantifiers, using few\nnon-linear operations. It finally discusses the relation between these\nvariants, and how this relation should constitute the subject of future work.\n", "versions": [{"version": "v1", "created": "Mon, 22 Apr 2013 01:39:42 GMT"}, {"version": "v2", "created": "Sun, 28 Apr 2013 20:09:17 GMT"}], "update_date": "2013-04-30", "authors_parsed": [["Grefenstette", "Edward", ""]]}, {"id": "1304.5961", "submitter": "Andreas Pfandler", "authors": "Andreas Pfandler, Stefan R\\\"ummele, Stefan Szeider", "title": "Backdoors to Abduction", "comments": "12 pages, a short version will appear in the proceedings of the 23rd\n  International Joint Conference on Artificial Intelligence (IJCAI 2013)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Abductive reasoning (or Abduction, for short) is among the most fundamental\nAI reasoning methods, with a broad range of applications, including fault\ndiagnosis, belief revision, and automated planning. Unfortunately, Abduction is\nof high computational complexity; even propositional Abduction is\n\\Sigma_2^P-complete and thus harder than NP and coNP. This complexity barrier\nrules out the existence of a polynomial transformation to propositional\nsatisfiability (SAT). In this work we use structural properties of the\nAbduction instance to break this complexity barrier. We utilize the problem\nstructure in terms of small backdoor sets. We present fixed-parameter tractable\ntransformations from Abduction to SAT, which make the power of today's SAT\nsolvers available to Abduction.\n", "versions": [{"version": "v1", "created": "Mon, 22 Apr 2013 14:23:11 GMT"}], "update_date": "2013-04-23", "authors_parsed": [["Pfandler", "Andreas", ""], ["R\u00fcmmele", "Stefan", ""], ["Szeider", "Stefan", ""]]}, {"id": "1304.6038", "submitter": "David Monniaux", "authors": "Thomas Braibant (INRIA Rocquencourt), Jacques-Henri Jourdan (INRIA\n  Rocquencourt), David Monniaux (VERIMAG - IMAG)", "title": "Implementing hash-consed structures in Coq", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We report on three different approaches to use hash-consing in programs\ncertified with the Coq system, using binary decision diagrams (BDD) as running\nexample. The use cases include execution inside Coq, or execution of the\nextracted OCaml code. There are different trade-offs between faithful use of\npristine extracted code, and code that is fine-tuned to make use of OCaml\nprogramming constructs not available in Coq. We discuss the possible\nconsequences in terms of performances and guarantees.\n", "versions": [{"version": "v1", "created": "Mon, 22 Apr 2013 18:07:36 GMT"}], "update_date": "2013-04-23", "authors_parsed": [["Braibant", "Thomas", "", "INRIA Rocquencourt"], ["Jourdan", "Jacques-Henri", "", "INRIA\n  Rocquencourt"], ["Monniaux", "David", "", "VERIMAG - IMAG"]]}, {"id": "1304.6276", "submitter": "Rasoul Ramezanian", "authors": "Mohammad Ardeshir Rasoul Ramezanian", "title": "Epistemic Learning Programs A Calculus for Describing Epistemic Action\n  Models", "comments": "35 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Dynamic Epistemic Logic makes it possible to model and reason about\ninformation change in multi-agent systems. Information change is mathematically\nmodeled through epistemic action Kripke models introduced by Baltag et al.\nAlso, van Ditmarsch interprets the information change as a relation between\nepistemic states and sets of epistemic states and to describe it formally, he\nconsiders a special constructor LB called learning operator. Inspired by this,\nit seems natural to us that the basic source of information change in a\nmulti-agent system should be learning an announcement by some agents together,\nprivately, concurrently or even wrongly. Hence moving along this path, we\nintroduce the notion of a learning program and prove that all finite K45 action\nmodels can be described by our learning programs\n", "versions": [{"version": "v1", "created": "Tue, 23 Apr 2013 13:06:33 GMT"}], "update_date": "2016-11-26", "authors_parsed": [["Ramezanian", "Mohammad Ardeshir Rasoul", ""]]}, {"id": "1304.6279", "submitter": "Stephane Graham-Lengrand", "authors": "Mahfuza Farooque (LIX, INRIA Saclay - Ile de France), St\\'ephane\n  Graham-Lengrand (LIX, INRIA Saclay - Ile de France)", "title": "Sequent Calculi with procedure calls", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we introduce two focussed sequent calculi, LKp(T) and LK+(T),\nthat are based on Miller-Liang's LKF system for polarised classical logic. The\nnovelty is that those sequent calculi integrate the possibility to call a\ndecision procedure for some background theory T, and the possibility to\npolarise literals \"on the fly\" during proof-search. These features are used in\nour other works to simulate the DPLL(T) procedure as proof-search in the\nextension of LKp(T) with a cut-rule. In this report we therefore prove\ncut-elimination in LKp(T). Contrary to what happens in the empty theory, the\npolarity of literals affects the provability of formulae in presence of a\ntheory T. On the other hand, changing the polarities of connectives does not\nchange the provability of formulae, only the shape of proofs. In order to prove\nthis, we introduce a second sequent calculus, LK+(T) that extends LKp(T) with a\nrelaxed focussing discipline, but we then show an encoding of LK+(T) back into\nthe more restrictive system LK(T). We then prove completeness of LKp(T) (and\ntherefore of LK+(T)) with respect to first-order reasoning modulo the ground\npropositional lemmas of the background theory T .\n", "versions": [{"version": "v1", "created": "Tue, 23 Apr 2013 13:16:04 GMT"}, {"version": "v2", "created": "Tue, 14 May 2013 11:47:38 GMT"}, {"version": "v3", "created": "Tue, 17 Sep 2013 14:50:57 GMT"}], "update_date": "2013-09-18", "authors_parsed": [["Farooque", "Mahfuza", "", "LIX, INRIA Saclay - Ile de France"], ["Graham-Lengrand", "St\u00e9phane", "", "LIX, INRIA Saclay - Ile de France"]]}, {"id": "1304.6301", "submitter": "Amit Kumar Dhar", "authors": "St\\'ephane Demri, Amit Kumar Dhar, Arnaud Sangnier", "title": "On the Complexity of Verifying Regular Properties on Flat Counter\n  Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Among the approximation methods for the verification of counter systems, one\nof them consists in model-checking their flat unfoldings. Unfortunately, the\ncomplexity characterization of model-checking problems for such operational\nmodels is not always well studied except for reachability queries or for Past\nLTL. In this paper, we characterize the complexity of model-checking problems\non flat counter systems for the specification languages including first-order\nlogic, linear mu-calculus, infinite automata, and related formalisms. Our\nresults span different complexity classes (mainly from PTime to PSpace) and\nthey apply to languages in which arithmetical constraints on counter values are\nsystematically allowed. As far as the proof techniques are concerned, we\nprovide a uniform approach that focuses on the main issues.\n", "versions": [{"version": "v1", "created": "Tue, 23 Apr 2013 14:31:26 GMT"}], "update_date": "2013-04-24", "authors_parsed": [["Demri", "St\u00e9phane", ""], ["Dhar", "Amit Kumar", ""], ["Sangnier", "Arnaud", ""]]}, {"id": "1304.6363", "submitter": "Stuart Barry Cooper", "authors": "S. Barry Cooper", "title": "Incomputability after Alan Turing", "comments": null, "journal-ref": "Notices of the American Mathematical Society, Volume 59, Number 6,\n  2012, pp. 776-784", "doi": null, "report-no": null, "categories": "math.HO cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Incomputability as a mathematical notion arose from work of Alan Turing and\nAlonzo Church in the 1930s. Like Turing himself, it attracted less attention\nthan it deserved beyond the confines of mathematics. Today our experiences in\ncomputer science, physics, biology, artificial intelligence, economics and the\nhumanities point to the importance of the notion for understanding the world\naround us. This article takes a Turing centenary look at how the interface\nbetween the computable world and the incomputable formed a central theme in\nTuring's work - from the early establishment of the standard model of the\nstored program computer, to the late work on emergence of form in nature, and\nthe first approaches to understanding and simulating human intelligence.\nTuring's thinking was remarkably prescient, and his legacy still impacts on\nmuch of our work. The incomputable may turn out to be a specially important\npart of the legacy, with consequences that Alan Turing himself could not have\nenvisaged.\n", "versions": [{"version": "v1", "created": "Mon, 22 Apr 2013 19:02:47 GMT"}], "update_date": "2013-04-24", "authors_parsed": [["Cooper", "S. Barry", ""]]}, {"id": "1304.6482", "submitter": "Jeroen Keiren", "authors": "Jeroen J. A. Keiren, Wieger Wesselink and Tim A. C. Willemse", "title": "Improved Static Analysis of Parameterised Boolean Equation Systems using\n  Control Flow Reconstruction", "comments": "This is an extended version containing full proofs, and results with\n  both versions of our analysis. Scripts and results corresponding to this\n  submission can be found at\n  https://github.com/jkeiren/pbesstategraph-experiments", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a sound static analysis technique for fighting the combinatorial\nexplosion of parameterised Boolean equation systems (PBESs). These essentially\nare systems of mutually recursive fixed point equations ranging over\nfirst-order logic formulae. Our method detects parameters that are not live by\nanalysing a control flow graph of a PBES, and it subsequently eliminates such\nparameters. We show that a naive approach to constructing a control flow graph,\nneeded for the analysis, may suffer from an exponential blow-up, and we define\nan approximate analysis that avoids this problem. The effectiveness of our\ntechniques is evaluated using a number of case studies.\n", "versions": [{"version": "v1", "created": "Wed, 24 Apr 2013 05:41:30 GMT"}, {"version": "v2", "created": "Sun, 27 Apr 2014 11:01:09 GMT"}], "update_date": "2014-04-29", "authors_parsed": [["Keiren", "Jeroen J. A.", ""], ["Wesselink", "Wieger", ""], ["Willemse", "Tim A. C.", ""]]}, {"id": "1304.6498", "submitter": "Huixing Fang", "authors": "Huixing Fang, Huibiao Zhu and Jianqi Shi", "title": "Apricot - An Object-Oriented Modeling Language for Hybrid Systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose Apricot as an object-oriented language for modeling hybrid\nsystems. The language combines the features in domain specific language and\nobject-oriented language, that fills the gap between design and implementation,\nas a result, we put forward the modeling language with simple and distinct\nsyntax, structure and semantics. In addition, we introduce the concept of\ndesign by convention into Apricot.As the characteristic of object-oriented and\nthe component architecture in Apricot, we conclude that it is competent for\nmodeling hybrid systems without losing scalability.\n", "versions": [{"version": "v1", "created": "Wed, 24 Apr 2013 07:48:08 GMT"}], "update_date": "2013-04-25", "authors_parsed": [["Fang", "Huixing", ""], ["Zhu", "Huibiao", ""], ["Shi", "Jianqi", ""]]}, {"id": "1304.6574", "submitter": "Carlos Gregorio-Rodr", "authors": "David de Frutos Escrig (Universidad Complutense de Madrid), Carlos\n  Gregorio-Rodr\\'iguez (Universidad Complutense de Madrid), Miguel Palomino\n  (Universidad Complutense de Madrid), David Romero Hern\\'andez (Universidad\n  Complutense de Madrid)", "title": "Unifying the Linear Time-Branching Time Spectrum of Process Semantics", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 2 (June 27,\n  2013) lmcs:983", "doi": "10.2168/LMCS-9(2:11)2013", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Van Glabbeek's linear time-branching time spectrum is one of the most\nrelevant work on comparative study on process semantics, in which semantics are\npartially ordered by their discrimination power. In this paper we bring forward\na refinement of this classification and show how the process semantics can be\ndealt with in a uniform way: based on the very natural concept of constrained\nsimulation we show how we can classify the spectrum in layers; for the families\nlying in the same layer we show how to obtain in a generic way equational,\nobservational, logical and operational characterizations; relations among\nlayers are also very natural and differences just stem from the constraint\nimposed on the simulations that rule the layers. Our methodology also shows how\nto achieve a uniform treatment of semantic preorders and equivalences.\n", "versions": [{"version": "v1", "created": "Wed, 24 Apr 2013 13:20:15 GMT"}, {"version": "v2", "created": "Mon, 24 Jun 2013 20:07:02 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Escrig", "David de Frutos", "", "Universidad Complutense de Madrid"], ["Gregorio-Rodr\u00edguez", "Carlos", "", "Universidad Complutense de Madrid"], ["Palomino", "Miguel", "", "Universidad Complutense de Madrid"], ["Hern\u00e1ndez", "David Romero", "", "Universidad\n  Complutense de Madrid"]]}, {"id": "1304.6762", "submitter": "Daniel de Carvalho", "authors": "Daniel de Carvalho and Lorenzo Tortora de Falco", "title": "A semantic account of strong normalization in Linear Logic", "comments": "41 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that given two cut free nets of linear logic, by means of their\nrelational interpretations one can: 1) first determine whether or not the net\nobtained by cutting the two nets is strongly normalizable 2) then (in case it\nis strongly normalizable) compute the maximal length of the reduction sequences\nstarting from that net.\n", "versions": [{"version": "v1", "created": "Wed, 24 Apr 2013 21:38:39 GMT"}, {"version": "v2", "created": "Thu, 23 May 2013 15:47:55 GMT"}, {"version": "v3", "created": "Tue, 26 Aug 2014 21:37:29 GMT"}], "update_date": "2014-08-28", "authors_parsed": [["de Carvalho", "Daniel", ""], ["de Falco", "Lorenzo Tortora", ""]]}, {"id": "1304.6810", "submitter": "Guy Van den Broeck", "authors": "Daan Fierens, Guy Van den Broeck, Joris Renkens, Dimitar Shterionov,\n  Bernd Gutmann, Ingo Thon, Gerda Janssens, Luc De Raedt", "title": "Inference and learning in probabilistic logic programs using weighted\n  Boolean formulas", "comments": "To appear in Theory and Practice of Logic Programming (TPLP)", "journal-ref": "Theory and Practice of Logic Programming 15 (2015) 358-401", "doi": "10.1017/S1471068414000076", "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Probabilistic logic programs are logic programs in which some of the facts\nare annotated with probabilities. This paper investigates how classical\ninference and learning tasks known from the graphical model community can be\ntackled for probabilistic logic programs. Several such tasks such as computing\nthe marginals given evidence and learning from (partial) interpretations have\nnot really been addressed for probabilistic logic programs before.\n  The first contribution of this paper is a suite of efficient algorithms for\nvarious inference tasks. It is based on a conversion of the program and the\nqueries and evidence to a weighted Boolean formula. This allows us to reduce\nthe inference tasks to well-studied tasks such as weighted model counting,\nwhich can be solved using state-of-the-art methods known from the graphical\nmodel and knowledge compilation literature. The second contribution is an\nalgorithm for parameter estimation in the learning from interpretations\nsetting. The algorithm employs Expectation Maximization, and is built on top of\nthe developed inference algorithms.\n  The proposed approach is experimentally evaluated. The results show that the\ninference algorithms improve upon the state-of-the-art in probabilistic logic\nprogramming and that it is indeed possible to learn the parameters of a\nprobabilistic logic program from interpretations.\n", "versions": [{"version": "v1", "created": "Thu, 25 Apr 2013 06:10:55 GMT"}], "update_date": "2020-02-19", "authors_parsed": [["Fierens", "Daan", ""], ["Broeck", "Guy Van den", ""], ["Renkens", "Joris", ""], ["Shterionov", "Dimitar", ""], ["Gutmann", "Bernd", ""], ["Thon", "Ingo", ""], ["Janssens", "Gerda", ""], ["De Raedt", "Luc", ""]]}, {"id": "1304.6870", "submitter": "Anuj Dawar", "authors": "Matthew Anderson, Anuj Dawar, Bjarki Holm", "title": "Maximum Matching and Linear Programming in Fixed-Point Logic with\n  Counting", "comments": "Full version of paper to appear in LICS 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.CC cs.DM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We establish the expressibility in fixed-point logic with counting (FPC) of a\nnumber of natural polynomial-time problems. In particular, we show that the\nsize of a maximum matching in a graph is definable in FPC. This settles an open\nproblem first posed by Blass, Gurevich and Shelah, who asked whether the\nexistence of perfect matchings in general graphs could be determined in the\nmore powerful formalism of choiceless polynomial time with counting. Our result\nis established by showing that the ellipsoid method for solving linear programs\ncan be implemented in FPC. This allows us to prove that linear programs can be\noptimised in FPC if the corresponding separation oracle problem can be defined\nin FPC. On the way to defining a suitable separation oracle for the maximum\nmatching problem, we provide FPC formulas defining maximum flows and canonical\nminimum cuts in capacitated graphs.\n", "versions": [{"version": "v1", "created": "Thu, 25 Apr 2013 10:51:32 GMT"}], "update_date": "2013-04-26", "authors_parsed": [["Anderson", "Matthew", ""], ["Dawar", "Anuj", ""], ["Holm", "Bjarki", ""]]}, {"id": "1304.6925", "submitter": "Rastislav Lenhardt", "authors": "Saguy Benaim, Michael Benedikt, Rastislav Lenhardt, James Worrell", "title": "Controlling the Depth, Size, and Number of Subtrees for Two-variable\n  Logic on Trees", "comments": "28 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Verification of properties of first order logic with two variables FO2 has\nbeen investigated in a number of contexts. Over arbitrary structures it is\nknown to be decidable with NEXPTIME complexity, with finitely satisfiable\nformulas having exponential-sized models. Over word structures, where FO2 is\nknown to have the same expressiveness as unary temporal logic, the same\nproperties hold. Over finite labelled ordered trees FO2 is also of interest: it\nis known to have the same expressiveness as navigational XPath, a common query\nlanguage for XML documents. Prior work on XPath and FO2 gives a 2EXPTIME bound\nfor satisfiability of FO2. In this work we give the first in-depth look at the\ncomplexity of FO2 on trees, and on the size and depth of models. We show that\nthe doubly-exponential bound is not tight, and neither do the\nNEXPTIME-completeness results from the word case carry over: the exact\ncomplexity varies depending on the vocabulary used, the presence or absence of\na schema, and the encoding used for labels. Our results depend on an analysis\nof subformula types in models of FO2 formulas, including techniques for\ncontrolling the number of distinct subtrees, the depth, and the size of a\nwitness to finite satisfiability for FO2 sentences over trees.\n", "versions": [{"version": "v1", "created": "Thu, 25 Apr 2013 14:48:59 GMT"}, {"version": "v2", "created": "Thu, 30 May 2013 21:37:52 GMT"}], "update_date": "2013-06-03", "authors_parsed": [["Benaim", "Saguy", ""], ["Benedikt", "Michael", ""], ["Lenhardt", "Rastislav", ""], ["Worrell", "James", ""]]}, {"id": "1304.6983", "submitter": "Steffen Lewitzka", "authors": "Steffen Lewitzka", "title": "Algebraic semantics for a modal logic close to S1", "comments": "14 pages, thoroughly revised and extended version, title has changed", "journal-ref": null, "doi": "10.1093/logcom/exu067", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The modal systems S1--S3 were introduced by C. I. Lewis as logics for strict\nimplication. While there are Kripke semantics for S2 and S3, there is no known\nnatural semantics for S1. We extend S1 by a Substitution Principle SP which\ngeneralizes a reference rule of S1. In system S1+SP, the relation of strict\nequivalence $\\varphi\\equiv\\psi$ satisfies the identity axioms of R. Suszko's\nnon-Fregean logic adapted to the language of modal logic (we call these axioms\nthe axioms of propositional identity). This enables us to develop a framework\nof algebraic semantics which captures S1+SP as well as the Lewis systems\nS3--S5. So from the viewpoint of algebraic semantics, S1+SP turns out to be an\ninteresting modal logic. We show that S1+SP is strictly contained between S1\nand S3 and differs from S2. It is the weakest modal logic containing S1 such\nthat strict equivalence is axiomatized by propositional identity.\n", "versions": [{"version": "v1", "created": "Thu, 25 Apr 2013 19:25:30 GMT"}, {"version": "v2", "created": "Sun, 7 Sep 2014 01:06:38 GMT"}], "update_date": "2014-12-09", "authors_parsed": [["Lewitzka", "Steffen", ""]]}, {"id": "1304.7123", "submitter": "EPTCS", "authors": "Ruben Gamboa (University of Wyoming, USA), Jared Davis (Centaur\n  Technology, USA)", "title": "Proceedings International Workshop on the ACL2 Theorem Prover and its\n  Applications", "comments": null, "journal-ref": "EPTCS 114, 2013", "doi": "10.4204/EPTCS.114", "report-no": null, "categories": "cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Eleventh International Workshop\non the ACL2 Theorem Prover and its Applications, held on May 30 and 31, 2013,\nin Laramie, Wyoming, USA.\n  ACL2 is an industrial-strength automated reasoning system, the latest in the\nBoyer-Moore family of theorem provers. The ACL2 workshop is the major technical\nforum for users of the ACL2 theorem proving system to present research on the\nprover and its applications.\n  This year's workshop received 15 submissions covering a wide range of\napplications, libraries, prover enhancements, interfaces, and experience\nreports. 11 papers were selected by the program committee for presentation at\nthe workshop.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2013 10:59:21 GMT"}], "update_date": "2013-04-29", "authors_parsed": [["Gamboa", "Ruben", "", "University of Wyoming, USA"], ["Davis", "Jared", "", "Centaur\n  Technology, USA"]]}, {"id": "1304.7204", "submitter": "Filip Mazowiecki sheriff", "authors": "Witold Charatonik, Emanuel Kiero\\'nski, Filip Mazowiecki", "title": "Satisfiability of the Two-Variable Fragment of First-Order Logic over\n  Trees", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider the satisfiability problem for the two-variable fragment of\nfirst-order logic over finite unranked trees. We work with signatures\nconsisting of some unary predicates and the binary navigational predicates\nchild, right sibling, and their respective transitive closures. We prove that\nthe satisfiability problem for the logic containing all these predicates is\nEXPSPACE-complete. Further, we consider the restriction of the class of\nstructures to singular trees, i.e., we assume that at every node precisely one\nunary predicate holds. We observe that the full logic and even for unordered\ntrees remain EXPSPACE-complete over finite singular trees, but the complexity\ndecreases for some weaker logics. Namely, the logic with one binary predicate,\ndescendant is NEXPTIME-complete, and its guarded version is PSPACE-complete\nover finite singular trees, even though both these logics are EXPSPACE-complete\nover arbitrary finite trees.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2013 15:35:41 GMT"}, {"version": "v2", "created": "Tue, 21 Oct 2014 14:53:00 GMT"}], "update_date": "2014-10-22", "authors_parsed": [["Charatonik", "Witold", ""], ["Kiero\u0144ski", "Emanuel", ""], ["Mazowiecki", "Filip", ""]]}, {"id": "1304.7209", "submitter": "Roland Kindermann", "authors": "Roland Kindermann, Tommi Junttila, Ilkka Niemel\\\"a", "title": "Bounded Model Checking of an MITL Fragment for Timed Automata", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Timed automata (TAs) are a common formalism for modeling timed systems.\nBounded model checking (BMC) is a verification method that searches for runs\nviolating a property using a SAT or SMT solver. MITL is a real-time extension\nof the linear time logic LTL. Originally, MITL was defined for traces of\nnon-overlapping time intervals rather than the \"super-dense\" time traces\nallowing for intervals overlapping in single points that are employed by the\nnowadays common semantics of timed automata. In this paper we extend the\nsemantics of a fragment of MITL to super-dense time traces and devise a bounded\nmodel checking encoding for the fragment. We prove correctness and completeness\nin the sense that using a sufficiently large bound a counter-example to any\ngiven non-holding property can be found. We have implemented the proposed\nbounded model checking approach and experimentally studied the efficiency and\nscalability of the implementation.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2013 15:52:38 GMT"}], "update_date": "2013-04-29", "authors_parsed": [["Kindermann", "Roland", ""], ["Junttila", "Tommi", ""], ["Niemel\u00e4", "Ilkka", ""]]}, {"id": "1304.7394", "submitter": "Hristina Palikareva", "authors": "Joel Ouaknine (Department of Computer Science, Oxford University, UK),\n  Hristina Palikareva (Department of Computing, Imperial College London, UK),\n  A. W. Roscoe (Department of Computer Science, Oxford University, UK), James\n  Worrell (Department of Computer Science, Oxford University, UK)", "title": "A Static Analysis Framework for Livelock Freedom in CSP", "comments": "53 pages, 20 figures", "journal-ref": "Logical Methods in Computer Science, Volume 9, Issue 3 (September\n  23, 2013) lmcs:884", "doi": "10.2168/LMCS-9(3:24)2013", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In a process algebra with hiding and recursion it is possible to create\nprocesses which compute internally without ever communicating with their\nenvironment. Such processes are said to diverge or livelock. In this paper we\nshow how it is possible to conservatively classify processes as livelock-free\nthrough a static analysis of their syntax. In particular, we present a\ncollection of rules, based on the inductive structure of terms, which guarantee\nlivelock-freedom of the denoted process. This gives rise to an algorithm which\nconservatively flags processes that can potentially livelock. We illustrate our\napproach by applying both BDD-based and SAT-based implementations of our\nalgorithm to a range of benchmarks, and show that our technique in general\nsubstantially outperforms the model checker FDR whilst exhibiting a low rate of\ninconclusive results.\n", "versions": [{"version": "v1", "created": "Sat, 27 Apr 2013 18:10:36 GMT"}, {"version": "v2", "created": "Fri, 20 Sep 2013 17:03:47 GMT"}, {"version": "v3", "created": "Thu, 26 Sep 2013 15:39:27 GMT"}, {"version": "v4", "created": "Fri, 27 Sep 2013 11:25:50 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Ouaknine", "Joel", "", "Department of Computer Science, Oxford University, UK"], ["Palikareva", "Hristina", "", "Department of Computing, Imperial College London, UK"], ["Roscoe", "A. W.", "", "Department of Computer Science, Oxford University, UK"], ["Worrell", "James", "", "Department of Computer Science, Oxford University, UK"]]}, {"id": "1304.7590", "submitter": "Xu Wang", "authors": "Chris Chilton, Marta Kwiatkowska, Xu Wang", "title": "Revisiting Timed Specification Theory II : Realisability", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present an assume-guarantee specification theory (aka\ninterface theory from [14]) for modular synthesis and verification of real-time\nsystems with critical timing constraints. It is a further step of our earlier\nwork [10] which achieved an elegant algebraic specification theory for\nreal-time systems endowed with the capability to freeze time. In this paper we\nrelinquish such (unrealisable) capability and target more realistic systems\nwithout the ability to stop time.\n  Our theory, in a combined process-algebraic and reactive-synthesis style,\nprovides the operations of parallel composition for system integration, logical\nconjunction/disjunction for viewpoint fusion and independent development, and\nquotient for incremental synthesis.\n  We show that a substitutive refinement preorder, which is a coarsening of the\npre-congruence in [10], constitutes the weakest pre-congruence preserving\nfreedom of incompatibility errors. The coarsening requires a shift in the focus\nof our theory to a more game-theoretical treatment, where the coarsening\nconstitutes a reactive synthesis game named normalisation and is efficiently\nimplementable by a novel local bot-backpropagation algorithm.\n  Previously, timed concurrent games have been studied in [1,14,13], where one\nof the key concern is the removal of time-blocking strategies by applying blame\nassignment [13]. Our timed games also have the issue of time-blocking\nstrategies, which may arise through the composition of specifications. However,\ndue to our distinctively different formulation of timed games, we have\ndiscovered another elegant solution to the problem without blame assignment.\nOur solution utilises a second reactive synthesis game called realisation,\nwhich is dual to normalisation and implementable by the dual local\ntop-backpropagation algorithm.\n", "versions": [{"version": "v1", "created": "Mon, 29 Apr 2013 08:22:25 GMT"}], "update_date": "2013-04-30", "authors_parsed": [["Chilton", "Chris", ""], ["Kwiatkowska", "Marta", ""], ["Wang", "Xu", ""]]}, {"id": "1304.7614", "submitter": "Guoxin Su Mr", "authors": "Guoxin Su and David S.Rosenblum", "title": "Asymptotic Bounds for Quantitative Verification of Perturbed\n  Probabilistic Systems", "comments": "This paper is a long version of the paper Asymptotic Bounds for\n  Quantitative Verification of Perturbed Probabilistic Systems in the\n  proceedings of 15th International Conference on Formal Engineering Methods", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The majority of existing probabilistic model checking case studies are based\non well understood theoretical models and distributions. However, real-life\nprobabilistic systems usually involve distribution parameters whose values are\nobtained by empirical measurements and thus are subject to small perturbations.\nIn this paper, we consider perturbation analysis of reachability in the\nparametric models of these systems (i.e., parametric Markov chains) equipped\nwith the norm of absolute distance. Our main contribution is a method to\ncompute the asymptotic bounds in the form of condition numbers for constrained\nreachability probabilities against perturbations of the distribution parameters\nof the system. The adequacy of the method is demonstrated through experiments\nwith the Zeroconf protocol and the hopping frog problem.\n", "versions": [{"version": "v1", "created": "Mon, 29 Apr 2013 10:30:42 GMT"}, {"version": "v2", "created": "Fri, 3 May 2013 08:57:54 GMT"}, {"version": "v3", "created": "Sun, 14 Jul 2013 11:29:36 GMT"}, {"version": "v4", "created": "Wed, 28 Aug 2013 02:29:33 GMT"}], "update_date": "2013-08-29", "authors_parsed": [["Su", "Guoxin", ""], ["Rosenblum", "David S.", ""]]}, {"id": "1304.7855", "submitter": "EPTCS", "authors": "Matt Kaufmann (University of Texas at Austin), J Strother Moore\n  (University of Texas at Austin)", "title": "Enhancements to ACL2 in Versions 5.0, 6.0, and 6.1", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 5-12", "doi": "10.4204/EPTCS.114.1", "report-no": null, "categories": "cs.MS cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We report on highlights of the ACL2 enhancements introduced in ACL2 releases\nsince the 2011 ACL2 Workshop. Although many enhancements are critical for\nsoundness or robustness, we focus in this paper on those improvements that\ncould benefit users who are aware of them, but that might not be discovered in\neveryday practice.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:13:58 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Kaufmann", "Matt", "", "University of Texas at Austin"], ["Moore", "J Strother", "", "University of Texas at Austin"]]}, {"id": "1304.7857", "submitter": "EPTCS", "authors": "David Greve (Rockwell Collins), Konrad Slind (Rockwell Collins)", "title": "A Step-Indexing Approach to Partial Functions", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 42-53", "doi": "10.4204/EPTCS.114.4", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe an ACL2 package for defining partial recursive functions that\nalso supports efficient execution. While packages for defining partial\nrecursive functions already exist for other theorem provers, they often require\ninductive definitions or recursion operators which are not available in ACL2\nand they provide little, if any, support for executing the resulting\ndefinitions. We use step-indexing as the underlying implementation technology,\nenabling the definitions to be carried out in first order logic. We also show\nhow recent enhancements to ACL2's guard feature can be used to enable the\nefficient execution of partial recursive functions.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:14:13 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Greve", "David", "", "Rockwell Collins"], ["Slind", "Konrad", "", "Rockwell Collins"]]}, {"id": "1304.7858", "submitter": "EPTCS", "authors": "Shilpi Goel (Department of Computer Science, University of Texas at\n  Austin), Warren A Hunt, Jr. (Department of Computer Science, University of\n  Texas at Austin), Matt Kaufmann (Department of Computer Science, University\n  of Texas at Austin)", "title": "Abstract Stobjs and Their Application to ISA Modeling", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 54-69", "doi": "10.4204/EPTCS.114.5", "report-no": null, "categories": "cs.LO cs.AR cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a new ACL2 feature, the abstract stobj, and show how to apply it\nto modeling the instruction set architecture of a microprocessor. Benefits of\nabstract stobjs over traditional (\"concrete\") stobjs can include faster\nexecution, support for symbolic simulation, more efficient reasoning, and\nresilience of proof developments under modeling optimization.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:14:22 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Goel", "Shilpi", "", "Department of Computer Science, University of Texas at\n  Austin"], ["Hunt,", "Warren A", "Jr.", "Department of Computer Science, University of\n  Texas at Austin"], ["Kaufmann", "Matt", "", "Department of Computer Science, University\n  of Texas at Austin"]]}, {"id": "1304.7859", "submitter": "EPTCS", "authors": "Freek Verbeek (Open University of The Netherlands), Julien Schmaltz\n  (Open University of The Netherlands)", "title": "Verification of Building Blocks for Asynchronous Circuits", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 70-84", "doi": "10.4204/EPTCS.114.6", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Scalable formal verification constitutes an important challenge for the\ndesign of asynchronous circuits. Deadlock freedom is a property that is desired\nbut hard to verify. It is an emergent property that has to be verified\nmonolithically. We present our approach to using ACL2 to verify necessary and\nsufficient conditions over asynchronous delay-insensitive primitives. These\nconditions are used to derive SAT/SMT instances from circuits built out of\nthese primitives. These SAT/SMT instances help in establishing absence of\ndeadlocks. Our verification effort consists of building an executable checker\nin the ACL2 logic tailored for our purpose. We prove that this checker is\ncorrect. This approach enables us to prove ACL2 theorems involving defun-sk\nconstructs and free variables fully automatically.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:14:29 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Verbeek", "Freek", "", "Open University of The Netherlands"], ["Schmaltz", "Julien", "", "Open University of The Netherlands"]]}, {"id": "1304.7860", "submitter": "EPTCS", "authors": "Lucas Helms (University of Wyoming), Ruben Gamboa (University of\n  Wyoming)", "title": "An Interpreter for Quantum Circuits", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 85-94", "doi": "10.4204/EPTCS.114.7", "report-no": null, "categories": "cs.LO quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes an ACL2 interpreter for \"netlists\" describing quantum\ncircuits. Several quantum gates are implemented, including the Hadamard gate H,\nwhich rotates vectors by 45 degrees, necessitating the use of irrational\nnumbers, at least at the logical level. Quantum measurement presents an\nespecially difficult challenge, because it requires precise comparisons of\nirrational numbers and the use of random numbers. This paper does not address\ncomputation with irrational numbers or the generation of random numbers,\nalthough future work includes the development of pseudo-random generators for\nACL2.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:14:37 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Helms", "Lucas", "", "University of Wyoming"], ["Gamboa", "Ruben", "", "University of\n  Wyoming"]]}, {"id": "1304.7861", "submitter": "EPTCS", "authors": "Jared Davis (Centaur Technology), Sol Swords (Centaur Technology)", "title": "Verified AIG Algorithms in ACL2", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 95-110", "doi": "10.4204/EPTCS.114.8", "report-no": null, "categories": "cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  And-Inverter Graphs (AIGs) are a popular way to represent Boolean functions\n(like circuits). AIG simplification algorithms can dramatically reduce an AIG,\nand play an important role in modern hardware verification tools like\nequivalence checkers. In practice, these tricky algorithms are implemented with\noptimized C or C++ routines with no guarantee of correctness. Meanwhile, many\ninteractive theorem provers can now employ SAT or SMT solvers to automatically\nsolve finite goals, but no theorem prover makes use of these advanced,\nAIG-based approaches.\n  We have developed two ways to represent AIGs within the ACL2 theorem prover.\nOne representation, Hons-AIGs, is especially convenient to use and reason\nabout. The other, Aignet, is the opposite; it is styled after modern AIG\npackages and allows for efficient algorithms. We have implemented functions for\nconverting between these representations, random vector simulation, conversion\nto CNF, etc., and developed reasoning strategies for verifying these\nalgorithms.\n  Aside from these contributions towards verifying AIG algorithms, this work\nhas an immediate, practical benefit for ACL2 users who are using GL to\nbit-blast finite ACL2 theorems: they can now optionally trust an off-the-shelf\nSAT solver to carry out the proof, instead of using the built-in BDD package.\nLooking to the future, it is a first step toward implementing verified AIG\nsimplification algorithms that might further improve GL performance.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:14:44 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Davis", "Jared", "", "Centaur Technology"], ["Swords", "Sol", "", "Centaur Technology"]]}, {"id": "1304.7862", "submitter": "EPTCS", "authors": "Bernard van Gastel (Open University of the Netherlands), Julien\n  Schmaltz (Open University of the Netherlands)", "title": "A formalisation of XMAS", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 111-126", "doi": "10.4204/EPTCS.114.9", "report-no": null, "categories": "cs.AR cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Communication fabrics play a key role in the correctness and performance of\nmodern multi-core processors and systems-on-chip. To enable formal\nverification, a recent trend is to use high-level micro-architectural models to\ncapture designers' intent about the communication and processing of messages.\nIntel proposed the xMAS language to support the formal definition of executable\nspecifications of micro-architectures. We formalise the semantics of xMAS in\nACL2. Our formalisation represents the computation of the values of all wires\nof a design. Our main function computes a set of possible routing targets for\neach message and whether a message can make progress according to the current\nnetwork state. We prove several properties on the semantics, including\ntermination, non-emptiness of routing, and correctness of progress conditions.\nOur current effort focuses on a basic subset of the entire xMAS language, which\nincludes queues, functions, and switches.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:14:53 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["van Gastel", "Bernard", "", "Open University of the Netherlands"], ["Schmaltz", "Julien", "", "Open University of the Netherlands"]]}, {"id": "1304.7863", "submitter": "EPTCS", "authors": "David S. Hardin (Rockwell Collins), Samuel S. Hardin (Iowa State\n  University)", "title": "ACL2 Meets the GPU: Formalizing a CUDA-based Parallelizable All-Pairs\n  Shortest Path Algorithm in ACL2", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 127-142", "doi": "10.4204/EPTCS.114.10", "report-no": null, "categories": "cs.LO cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As Graphics Processing Units (GPUs) have gained in capability and GPU\ndevelopment environments have matured, developers are increasingly turning to\nthe GPU to off-load the main host CPU of numerically-intensive, parallelizable\ncomputations. Modern GPUs feature hundreds of cores, and offer programming\nniceties such as double-precision floating point, and even limited recursion.\nThis shift from CPU to GPU, however, raises the question: how do we know that\nthese new GPU-based algorithms are correct?\n  In order to explore this new verification frontier, we formalized a\nparallelizable all-pairs shortest path (APSP) algorithm for weighted graphs,\noriginally coded in NVIDIA's CUDA language, in ACL2. The ACL2 specification is\nwritten using a single-threaded object (stobj) and tail recursion, as the\nstobj/tail recursion combination yields the most straightforward translation\nfrom imperative programming languages, as well as efficient, scalable\nexecutable specifications within ACL2 itself. The ACL2 version of the APSP\nalgorithm can process millions of vertices and edges with little to no garbage\ngeneration, and executes at one-sixth the speed of a host-based version of APSP\ncoded in C- a very respectable result for a theorem prover.\n  In addition to formalizing the APSP algorithm (which uses Dijkstra's shortest\npath algorithm at its core), we have also provided capability that the original\nAPSP code lacked, namely shortest path recovery. Path recovery is accomplished\nusing a secondary ACL2 stobj implementing a LIFO stack, which is proven\ncorrect. To conclude the experiment, we ported the ACL2 version of the APSP\nkernels back to C, resulting in a less than 5% slowdown, and also performed a\npartial back-port to CUDA, which, surprisingly, yielded a slight performance\nincrease.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:15:02 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Hardin", "David S.", "", "Rockwell Collins"], ["Hardin", "Samuel S.", "", "Iowa State\n  University"]]}, {"id": "1304.7875", "submitter": "EPTCS", "authors": "Sebastiaan J. C. Joosten, Bernard van Gastel, Julien Schmaltz", "title": "A Macro for Reusing Abstract Functions and Theorems", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 29-41", "doi": "10.4204/EPTCS.114.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Even though the ACL2 logic is first order, the ACL2 system offers several\nmechanisms providing users with some operations akin to higher order logic\nones. In this paper, we propose a macro, named instance-of-defspec, to ease the\nreuse of abstract functions and facts proven about them. Defspec is an ACL2\nbook allowing users to define constrained functions and their associated\nproperties. It contains macros facilitating the definition of such abstract\nspecifications and instances thereof. Currently, lemmas and theorems derived\nfrom these abstract functions are not automatically instantiated. This is\nexactly the purpose of our new macro. instance-of-defspec will not only\ninstantiate functions and theorems within a specification but also many more\nfunctions and theorems built on top of the specification. As a working example,\nwe describe various fold functions over monoids, which we gradually built from\narbitrary functions.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:43:47 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Joosten", "Sebastiaan J. C.", ""], ["van Gastel", "Bernard", ""], ["Schmaltz", "Julien", ""]]}]