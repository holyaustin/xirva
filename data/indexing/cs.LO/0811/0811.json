[{"id": "0811.0166", "submitter": "David Monniaux", "authors": "David Monniaux (VERIMAG - Imag)", "title": "Automatic Modular Abstractions for Linear Constraints", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a method for automatically generating abstract transformers for\nstatic analysis by abstract interpretation. The method focuses on linear\nconstraints on programs operating on rational, real or floating-point variables\nand containing linear assignments and tests. In addition to loop-free code, the\nsame method also applies for obtaining least fixed points as functions of the\nprecondition, which permits the analysis of loops and recursive functions. Our\nalgorithms are based on new quantifier elimination and symbolic manipulation\ntechniques. Given the specification of an abstract domain, and a program block,\nour method automatically outputs an implementation of the corresponding\nabstract transformer. It is thus a form of program transformation. The\nmotivation of our work is data-flow synchronous programming languages, used for\nbuilding control-command embedded systems, but it also applies to imperative\nand functional programming.\n", "versions": [{"version": "v1", "created": "Sun, 2 Nov 2008 14:47:44 GMT"}], "update_date": "2008-11-04", "authors_parsed": [["Monniaux", "David", "", "VERIMAG - Imag"]]}, {"id": "0811.0359", "submitter": "Jos de Bruijn Jos de Bruijn", "authors": "Jos de Bruijn, Thomas Eiter, Axel Polleres, and Hans Tompits", "title": "Embedding Non-Ground Logic Programs into Autoepistemic Logic for\n  Knowledge Base Combination", "comments": "52 pages, submitted", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the context of the Semantic Web, several approaches to the combination of\nontologies, given in terms of theories of classical first-order logic and rule\nbases, have been proposed. They either cast rules into classical logic or limit\nthe interaction between rules and ontologies. Autoepistemic logic (AEL) is an\nattractive formalism which allows to overcome these limitations, by serving as\na uniform host language to embed ontologies and nonmonotonic logic programs\ninto it. For the latter, so far only the propositional setting has been\nconsidered. In this paper, we present three embeddings of normal and three\nembeddings of disjunctive non-ground logic programs under the stable model\nsemantics into first-order AEL. While the embeddings all correspond with\nrespect to objective ground atoms, differences arise when considering\nnon-atomic formulas and combinations with first-order theories. We compare the\nembeddings with respect to stable expansions and autoepistemic consequences,\nconsidering the embeddings by themselves, as well as combinations with\nclassical theories. Our results reveal differences and correspondences of the\nembeddings and provide useful guidance in the choice of a particular embedding\nfor knowledge combination.\n", "versions": [{"version": "v1", "created": "Mon, 3 Nov 2008 18:42:01 GMT"}, {"version": "v2", "created": "Fri, 30 Oct 2009 13:57:07 GMT"}, {"version": "v3", "created": "Fri, 11 Jun 2010 06:38:32 GMT"}], "update_date": "2010-06-14", "authors_parsed": [["de Bruijn", "Jos", ""], ["Eiter", "Thomas", ""], ["Polleres", "Axel", ""], ["Tompits", "Hans", ""]]}, {"id": "0811.0436", "submitter": "Kees Middelburg", "authors": "J. A. Bergstra, C. A. Middelburg", "title": "Instruction sequences for the production of processes", "comments": "23 pages; acknowledgement corrected, reference updated", "journal-ref": null, "doi": null, "report-no": "PRG0814", "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Single-pass instruction sequences under execution are considered to produce\nbehaviours to be controlled by some execution environment. Threads as\nconsidered in thread algebra model such behaviours: upon each action performed\nby a thread, a reply from its execution environment determines how the thread\nproceeds. Threads in turn can be looked upon as producing processes as\nconsidered in process algebra. We show that, by apposite choice of basic\ninstructions, all processes that can only be in a finite number of states can\nbe produced by single-pass instruction sequences.\n", "versions": [{"version": "v1", "created": "Tue, 4 Nov 2008 07:24:12 GMT"}, {"version": "v2", "created": "Tue, 18 Nov 2008 10:08:03 GMT"}], "update_date": "2008-11-18", "authors_parsed": [["Bergstra", "J. A.", ""], ["Middelburg", "C. A.", ""]]}, {"id": "0811.0537", "submitter": "Rajeev Alur", "authors": "Rajeev Alur (UPenn), Marcelo Arenas (PUC, Chile), Pablo Barcelo (U\n  Chile), Kousha Etessami (U Edinburgh), Neil Immerman (UMass), Leonid Libkin\n  (Edinbugh)", "title": "First-Order and Temporal Logics for Nested Words", "comments": "revised and corrected version of Mar 03, 2011", "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (November\n  25, 2008) lmcs:782", "doi": "10.2168/LMCS-4(4:11)2008", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Nested words are a structured model of execution paths in procedural\nprograms, reflecting their call and return nesting structure. Finite nested\nwords also capture the structure of parse trees and other tree-structured data,\nsuch as XML. We provide new temporal logics for finite and infinite nested\nwords, which are natural extensions of LTL, and prove that these logics are\nfirst-order expressively-complete. One of them is based on adding a \"within\"\nmodality, evaluating a formula on a subword, to a logic CaRet previously\nstudied in the context of verifying properties of recursive state machines\n(RSMs). The other logic, NWTL, is based on the notion of a summary path that\nuses both the linear and nesting structures. For NWTL we show that\nsatisfiability is EXPTIME-complete, and that model-checking can be done in time\npolynomial in the size of the RSM model and exponential in the size of the NWTL\nformula (and is also EXPTIME-complete). Finally, we prove that first-order\nlogic over nested words has the three-variable property, and we present a\ntemporal logic for nested words which is complete for the two-variable fragment\nof first-order.\n", "versions": [{"version": "v1", "created": "Tue, 4 Nov 2008 15:30:12 GMT"}, {"version": "v2", "created": "Tue, 25 Nov 2008 00:54:10 GMT"}, {"version": "v3", "created": "Thu, 3 Mar 2011 16:16:19 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Alur", "Rajeev", "", "UPenn"], ["Arenas", "Marcelo", "", "PUC, Chile"], ["Barcelo", "Pablo", "", "U\n  Chile"], ["Etessami", "Kousha", "", "U Edinburgh"], ["Immerman", "Neil", "", "UMass"], ["Libkin", "Leonid", "", "Edinbugh"]]}, {"id": "0811.0811", "submitter": "Andreas Blass", "authors": "Andreas Blass (University of Michigan), Nachum Dershowitz (Tel Aviv\n  University), and Yuri Gurevich (Microsoft Research)", "title": "When are two algorithms the same?", "comments": null, "journal-ref": "Bulletin of Symbolic Logic, vol. 15, no. 2, pp. 145-168, 2009", "doi": null, "report-no": null, "categories": "cs.GL cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  People usually regard algorithms as more abstract than the programs that\nimplement them. The natural way to formalize this idea is that algorithms are\nequivalence classes of programs with respect to a suitable equivalence\nrelation. We argue that no such equivalence relation exists.\n", "versions": [{"version": "v1", "created": "Wed, 5 Nov 2008 20:38:22 GMT"}], "update_date": "2020-06-11", "authors_parsed": [["Blass", "Andreas", "", "University of Michigan"], ["Dershowitz", "Nachum", "", "Tel Aviv\n  University"], ["Gurevich", "Yuri", "", "Microsoft Research"]]}, {"id": "0811.0819", "submitter": "Andreas Blass", "authors": "Andreas Blass (University of Michigan) and Yuri Gurevich (Microsoft\n  Research)", "title": "Persistent Queries", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a syntax and semantics for interactive abstract state machines to\ndeal with the following situation. A query is issued during a certain step, but\nthe step ends before any reply is received. Later, a reply arrives, and later\nyet the algorithm makes use of this reply. By a persistent query, we mean a\nquery for which a late reply might be used. Syntactically, our proposal\ninvolves issuing, along with a persistent query, a location where a late reply\nis to be stored. Semantically, it involves only a minor modification of the\nexisting theory of interactive small-step abstract state machines.\n", "versions": [{"version": "v1", "created": "Wed, 5 Nov 2008 21:10:33 GMT"}], "update_date": "2008-11-07", "authors_parsed": [["Blass", "Andreas", "", "University of Michigan"], ["Gurevich", "Yuri", "", "Microsoft\n  Research"]]}, {"id": "0811.0959", "submitter": "Michael Thomas", "authors": "Olaf Beyersdorff, Arne Meier, Michael Thomas, Heribert Vollmer", "title": "The Complexity of Propositional Implication", "comments": null, "journal-ref": null, "doi": "10.1016/j.ipl.2009.06.015", "report-no": null, "categories": "cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The question whether a set of formulae G implies a formula f is fundamental.\nThe present paper studies the complexity of the above implication problem for\npropositional formulae that are built from a systematically restricted set of\nBoolean connectives. We give a complete complexity classification for all sets\nof Boolean functions in the meaning of Post's lattice and show that the\nimplication problem is efficentily solvable only if the connectives are\ndefinable using the constants {false,true} and only one of {and,or,xor}. The\nproblem remains coNP-complete in all other cases. We also consider the\nrestriction of G to singletons.\n", "versions": [{"version": "v1", "created": "Thu, 6 Nov 2008 14:44:57 GMT"}, {"version": "v2", "created": "Tue, 25 Nov 2008 15:01:30 GMT"}, {"version": "v3", "created": "Wed, 12 Aug 2009 06:43:54 GMT"}], "update_date": "2010-06-02", "authors_parsed": [["Beyersdorff", "Olaf", ""], ["Meier", "Arne", ""], ["Thomas", "Michael", ""], ["Vollmer", "Heribert", ""]]}, {"id": "0811.0964", "submitter": "Andreas Blass", "authors": "Andreas Blass (University of Michigan) and Yuri Gurevich (Microsoft\n  Research)", "title": "One useful logic that defines its own truth", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Existential fixed point logic (EFPL) is a natural fit for some applications,\nand the purpose of this talk is to attract attention to EFPL. The logic is also\ninteresting in its own right as it has attractive properties. One of those\nproperties is rather unusual: truth of formulas can be defined (given\nappropriate syntactic apparatus) in the logic. We mentioned that property\nelsewhere, and we use this opportunity to provide the proof.\n", "versions": [{"version": "v1", "created": "Thu, 6 Nov 2008 15:09:43 GMT"}], "update_date": "2008-11-07", "authors_parsed": [["Blass", "Andreas", "", "University of Michigan"], ["Gurevich", "Yuri", "", "Microsoft\n  Research"]]}, {"id": "0811.0977", "submitter": "Andreas Blass", "authors": "Andreas Blass (University of Michigan) and Yuri Gurevich (Microsoft\n  Research)", "title": "Two Forms of One Useful Logic: Existential Fixed Point Logic and Liberal\n  Datalog", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A natural liberalization of Datalog is used in the Distributed Knowledge\nAuthorization Language (DKAL). We show that the expressive power of this\nliberal Datalog is that of existential fixed-point logic. The exposition is\nself-contained.\n", "versions": [{"version": "v1", "created": "Thu, 6 Nov 2008 15:58:17 GMT"}], "update_date": "2008-11-07", "authors_parsed": [["Blass", "Andreas", "", "University of Michigan"], ["Gurevich", "Yuri", "", "Microsoft\n  Research"]]}, {"id": "0811.1075", "submitter": "Jan Johannsen", "authors": "Samuel R. Buss, Jan Hoffmann, Jan Johannsen", "title": "Resolution Trees with Lemmas: Resolution Refinements that Characterize\n  DLL Algorithms with Clause Learning", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (December\n  5, 2008) lmcs:860", "doi": "10.2168/LMCS-4(4:13)2008", "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Resolution refinements called w-resolution trees with lemmas (WRTL) and with\ninput lemmas (WRTI) are introduced. Dag-like resolution is equivalent to both\nWRTL and WRTI when there is no regularity condition. For regular proofs, an\nexponential separation between regular dag-like resolution and both regular\nWRTL and regular WRTI is given.\n  It is proved that DLL proof search algorithms that use clause learning based\non unit propagation can be polynomially simulated by regular WRTI. More\ngenerally, non-greedy DLL algorithms with learning by unit propagation are\nequivalent to regular WRTI. A general form of clause learning, called\nDLL-Learn, is defined that is equivalent to regular WRTL.\n  A variable extension method is used to give simulations of resolution by\nregular WRTI, using a simplified form of proof trace extensions. DLL-Learn and\nnon-greedy DLL algorithms with learning by unit propagation can use variable\nextensions to simulate general resolution without doing restarts.\n  Finally, an exponential lower bound for WRTL where the lemmas are restricted\nto short clauses is shown.\n", "versions": [{"version": "v1", "created": "Fri, 7 Nov 2008 15:31:58 GMT"}, {"version": "v2", "created": "Fri, 5 Dec 2008 10:34:34 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Buss", "Samuel R.", ""], ["Hoffmann", "Jan", ""], ["Johannsen", "Jan", ""]]}, {"id": "0811.1878", "submitter": "Ivan Varzinczak", "authors": "Ivan Varzinczak", "title": "Action Theory Evolution", "comments": "64 pages, 19 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Like any other logical theory, domain descriptions in reasoning about actions\nmay evolve, and thus need revision methods to adequately accommodate new\ninformation about the behavior of actions. The present work is about changing\naction domain descriptions in propositional dynamic logic. Its contribution is\nthreefold: first we revisit the semantics of action theory contraction that has\nbeen done in previous work, giving more robust operators that express minimal\nchange based on a notion of distance between Kripke-models. Second we give\nalgorithms for syntactical action theory contraction and establish their\ncorrectness w.r.t. our semantics. Finally we state postulates for action theory\ncontraction and assess the behavior of our operators w.r.t. them. Moreover, we\nalso address the revision counterpart of action theory change, showing that it\nbenefits from our semantics for contraction.\n", "versions": [{"version": "v1", "created": "Wed, 12 Nov 2008 12:05:55 GMT"}], "update_date": "2008-11-13", "authors_parsed": [["Varzinczak", "Ivan", ""]]}, {"id": "0811.1914", "submitter": "Stephan Merz", "authors": "Kaustuv C. Chaudhuri (MRI), Damien Doligez (INRIA Rocquencourt),\n  Leslie Lamport, Stephan Merz (INRIA Lorraine - LORIA)", "title": "A TLA+ Proof System", "comments": null, "journal-ref": "Knowledge Exchange: Automated Provers and Proof Assistants\n  (KEAPPA) (2008)", "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe an extension to the TLA+ specification language with constructs\nfor writing proofs and a proof environment, called the Proof Manager (PM), to\nchecks those proofs. The language and the PM support the incremental\ndevelopment and checking of hierarchically structured proofs. The PM translates\na proof into a set of independent proof obligations and calls upon a collection\nof back-end provers to verify them. Different provers can be used to verify\ndifferent obligations. The currently supported back-ends are the tableau prover\nZenon and Isabelle/TLA+, an axiomatisation of TLA+ in Isabelle/Pure. The proof\nobligations for a complete TLA+ proof can also be used to certify the theorem\nin Isabelle/TLA+.\n", "versions": [{"version": "v1", "created": "Wed, 12 Nov 2008 15:00:22 GMT"}], "update_date": "2008-11-13", "authors_parsed": [["Chaudhuri", "Kaustuv C.", "", "MRI"], ["Doligez", "Damien", "", "INRIA Rocquencourt"], ["Lamport", "Leslie", "", "INRIA Lorraine - LORIA"], ["Merz", "Stephan", "", "INRIA Lorraine - LORIA"]]}, {"id": "0811.1976", "submitter": "Clemens Kupke", "authors": "C. Kupke, Y. Venema", "title": "Coalgebraic Automata Theory: Basic Results", "comments": "43 pages", "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (November\n  21, 2008) lmcs:1203", "doi": "10.2168/LMCS-4(4:10)2008", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We generalize some of the central results in automata theory to the\nabstraction level of coalgebras and thus lay out the foundations of a universal\ntheory of automata operating on infinite objects.\n  Let F be any set functor that preserves weak pullbacks. We show that the\nclass of recognizable languages of F-coalgebras is closed under taking unions,\nintersections, and projections. We also prove that if a nondeterministic\nF-automaton accepts some coalgebra it accepts a finite one of the size of the\nautomaton. Our main technical result concerns an explicit construction which\ntransforms a given alternating F-automaton into an equivalent nondeterministic\none, whose size is exponentially bound by the size of the original automaton.\n", "versions": [{"version": "v1", "created": "Wed, 12 Nov 2008 18:53:13 GMT"}, {"version": "v2", "created": "Fri, 21 Nov 2008 13:55:34 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Kupke", "C.", ""], ["Venema", "Y.", ""]]}, {"id": "0811.2113", "submitter": "J\\\"urgen Koslowski", "authors": "Chris Heunen", "title": "Compactly accessible categories and quantum key distribution", "comments": "26 pages in Logical Methods in Computer Science, Volume 4, Issue 4\n  (November 17, 2008) lmcs:1129", "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (November\n  17, 2008) lmcs:1129", "doi": "10.2168/LMCS-4(4:9)2008", "report-no": null, "categories": "cs.LO cs.PL quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Compact categories have lately seen renewed interest via applications to\nquantum physics. Being essentially finite-dimensional, they cannot accomodate\n(co)limit-based constructions. For example, they cannot capture protocols such\nas quantum key distribution, that rely on the law of large numbers. To overcome\nthis limitation, we introduce the notion of a compactly accessible category,\nrelying on the extra structure of a factorisation system. This notion allows\nfor infinite dimension while retaining key properties of compact categories:\nthe main technical result is that the choice-of-duals functor on the compact\npart extends canonically to the whole compactly accessible category. As an\nexample, we model a quantum key distribution protocol and prove its correctness\ncategorically.\n", "versions": [{"version": "v1", "created": "Thu, 13 Nov 2008 13:58:48 GMT"}, {"version": "v2", "created": "Mon, 17 Nov 2008 13:17:09 GMT"}, {"version": "v3", "created": "Tue, 19 Apr 2016 12:29:44 GMT"}], "update_date": "2016-04-20", "authors_parsed": [["Heunen", "Chris", ""]]}, {"id": "0811.2198", "submitter": "Alexander Rabinovich", "authors": "Alexander Rabinovich", "title": "The Church Problem for Countable Ordinals", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 5, Issue 2 (April 27,\n  2009) lmcs:1204", "doi": "10.2168/LMCS-5(2:5)2009", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A fundamental theorem of Buchi and Landweber shows that the Church synthesis\nproblem is computable. Buchi and Landweber reduced the Church Problem to\nproblems about &#969;-games and used the determinacy of such games as one of\nthe main tools to show its computability. We consider a natural generalization\nof the Church problem to countable ordinals and investigate games of arbitrary\ncountable length. We prove that determinacy and decidability parts of the\nBu}chi and Landweber theorem hold for all countable ordinals and that its full\nextension holds for all ordinals < \\omega\\^\\omega.\n", "versions": [{"version": "v1", "created": "Thu, 13 Nov 2008 18:47:27 GMT"}, {"version": "v2", "created": "Fri, 6 Feb 2009 13:30:28 GMT"}, {"version": "v3", "created": "Sun, 22 Mar 2009 20:17:43 GMT"}, {"version": "v4", "created": "Mon, 27 Apr 2009 08:32:47 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Rabinovich", "Alexander", ""]]}, {"id": "0811.2546", "submitter": "Andrei Bulatov", "authors": "Andrei A. Bulatov, Evgeny S. Skvortsov", "title": "Phase transition for Local Search on planted SAT", "comments": "20 pages, 3 figures, submitted to a conference", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Local Search algorithm (or Hill Climbing, or Iterative Improvement) is\none of the simplest heuristics to solve the Satisfiability and\nMax-Satisfiability problems. It is a part of many satisfiability and\nmax-satisfiability solvers, where it is used to find a good starting point for\na more sophisticated heuristics, and to improve a candidate solution. In this\npaper we give an analysis of Local Search on random planted 3-CNF formulas. We\nshow that if there is k<7/6 such that the clause-to-variable ratio is less than\nk ln(n) (n is the number of variables in a CNF) then Local Search whp does not\nfind a satisfying assignment, and if there is k>7/6 such that the\nclause-to-variable ratio is greater than k ln(n)$ then the local search whp\nfinds a satisfying assignment. As a byproduct we also show that for any\nconstant r there is g such that Local Search applied to a random (not\nnecessarily planted) 3-CNF with clause-to-variable ratio r produces an\nassignment that satisfies at least gn clauses less than the maximal number of\nsatisfiable clauses.\n", "versions": [{"version": "v1", "created": "Sun, 16 Nov 2008 01:41:15 GMT"}], "update_date": "2008-11-18", "authors_parsed": [["Bulatov", "Andrei A.", ""], ["Skvortsov", "Evgeny S.", ""]]}, {"id": "0811.3231", "submitter": "Olivier Danvy", "authors": "Olivier Danvy and Kevin Millikin", "title": "A Rational Deconstruction of Landin's SECD Machine with the J Operator", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 4, Issue 4 (November\n  29, 2008) lmcs:1112", "doi": "10.2168/LMCS-4(4:12)2008", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Landin's SECD machine was the first abstract machine for applicative\nexpressions, i.e., functional programs. Landin's J operator was the first\ncontrol operator for functional languages, and was specified by an extension of\nthe SECD machine. We present a family of evaluation functions corresponding to\nthis extension of the SECD machine, using a series of elementary\ntransformations (transformation into continu-ation-passing style (CPS) and\ndefunctionalization, chiefly) and their left inverses (transformation into\ndirect style and refunctionalization). To this end, we modernize the SECD\nmachine into a bisimilar one that operates in lockstep with the original one\nbut that (1) does not use a data stack and (2) uses the caller-save rather than\nthe callee-save convention for environments. We also identify that the dump\ncomponent of the SECD machine is managed in a callee-save way. The caller-save\ncounterpart of the modernized SECD machine precisely corresponds to Thielecke's\ndouble-barrelled continuations and to Felleisen's encoding of J in terms of\ncall/cc. We then variously characterize the J operator in terms of CPS and in\nterms of delimited-control operators in the CPS hierarchy. As a byproduct, we\nalso present several reduction semantics for applicative expressions with the J\noperator, based on Curien's original calculus of explicit substitutions. These\nreduction semantics mechanically correspond to the modernized versions of the\nSECD machine and to the best of our knowledge, they provide the first syntactic\ntheories of applicative expressions with the J operator.\n", "versions": [{"version": "v1", "created": "Wed, 19 Nov 2008 22:31:34 GMT"}, {"version": "v2", "created": "Fri, 28 Nov 2008 23:19:23 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Danvy", "Olivier", ""], ["Millikin", "Kevin", ""]]}, {"id": "0811.3400", "submitter": "Frederic Prost", "authors": "Dominique Duval (LMC - IMAG, LJK, NMST), Rachid Echahed (LIG, Leibniz\n  - IMAG, IMAG), Fr\\'ed\\'eric Prost (LIG)", "title": "A Cloning Pushout Approach to Term-Graph Transformation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We address the problem of cyclic termgraph rewriting. We propose a new\nframework where rewrite rules are tuples of the form $(L,R,\\tau,\\sigma)$ such\nthat $L$ and $R$ are termgraphs representing the left-hand and the right-hand\nsides of the rule, $\\tau$ is a mapping from the nodes of $L$ to those of $R$\nand $\\sigma$ is a partial function from nodes of $R$ to nodes of $L$. $\\tau$\ndescribes how incident edges of the nodes in $L$ are connected in $R$. $\\tau$\nis not required to be a graph morphism as in classical algebraic approaches of\ngraph transformation. The role of $\\sigma$ is to indicate the parts of $L$ to\nbe cloned (copied). Furthermore, we introduce a new notion of \\emph{cloning\npushout} and define rewrite steps as cloning pushouts in a given category.\nAmong the features of the proposed rewrite systems, we quote the ability to\nperform local and global redirection of pointers, addition and deletion of\nnodes as well as cloning and collapsing substructures.\n", "versions": [{"version": "v1", "created": "Thu, 20 Nov 2008 19:39:51 GMT"}], "update_date": "2008-11-21", "authors_parsed": [["Duval", "Dominique", "", "LMC - IMAG, LJK, NMST"], ["Echahed", "Rachid", "", "LIG, Leibniz\n  - IMAG, IMAG"], ["Prost", "Fr\u00e9d\u00e9ric", "", "LIG"]]}, {"id": "0811.3521", "submitter": "Angelo Brillout", "authors": "Angelo Brillout, Daniel Kroening, and Thomas Wahl", "title": "Craig Interpolation for Quantifier-Free Presburger Arithmetic", "comments": "15 pages, 1 algorithm, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Craig interpolation has become a versatile algorithmic tool for improving\nsoftware verification. Interpolants can, for instance, accelerate the\nconvergence of fixpoint computations for infinite-state systems. They also help\nimprove the refinement of iteratively computed lazy abstractions. Efficient\ninterpolation procedures have been presented only for a few theories. In this\npaper, we introduce a complete interpolation method for the full range of\nquantifier-free Presburger arithmetic formulas. We propose a novel convex\nvariable projection for integer inequalities and a technique to combine them\nwith equalities. The derivation of the interpolant has complexity low-degree\npolynomial in the size of the refutation proof and is typically fast in\npractice.\n", "versions": [{"version": "v1", "created": "Fri, 21 Nov 2008 11:44:22 GMT"}], "update_date": "2008-11-24", "authors_parsed": [["Brillout", "Angelo", ""], ["Kroening", "Daniel", ""], ["Wahl", "Thomas", ""]]}, {"id": "0811.3704", "submitter": "Olivier Finkel", "authors": "Olivier Finkel (LIP, Elm)", "title": "Highly Undecidable Problems about Recognizability by Tiling Systems", "comments": "to appear in a Special Issue of the journal Fundamenta Informaticae\n  on Machines, Computations and Universality", "journal-ref": "Fundamenta Informaticae 2, 91 (2009) 305-323", "doi": null, "report-no": null, "categories": "cs.CC cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Altenbernd, Thomas and W\\\"ohrle have considered acceptance of languages of\ninfinite two-dimensional words (infinite pictures) by finite tiling systems,\nwith usual acceptance conditions, such as the B\\\"uchi and Muller ones [1]. It\nwas proved in [9] that it is undecidable whether a B\\\"uchi-recognizable\nlanguage of infinite pictures is E-recognizable (respectively, A-recognizable).\nWe show here that these two decision problems are actually $\\Pi_2^1$-complete,\nhence located at the second level of the analytical hierarchy, and \"highly\nundecidable\". We give the exact degree of numerous other undecidable problems\nfor B\\\"uchi-recognizable languages of infinite pictures. In particular, the\nnon-emptiness and the infiniteness problems are $\\Sigma^1_1$-complete, and the\nuniversality problem, the inclusion problem, the equivalence problem, the\ndeterminizability problem, the complementability problem, are all\n$\\Pi^1_2$-complete. It is also $\\Pi^1_2$-complete to determine whether a given\nB\\\"uchi recognizable language of infinite pictures can be accepted row by row\nusing an automaton model over ordinal words of length $\\omega^2$.\n", "versions": [{"version": "v1", "created": "Sat, 22 Nov 2008 17:41:28 GMT"}], "update_date": "2009-08-04", "authors_parsed": [["Finkel", "Olivier", "", "LIP, Elm"]]}, {"id": "0811.4367", "submitter": "Alberto Momigliano", "authors": "Amy Felty and Alberto Momigliano", "title": "Hybrid: A Definitional Two-Level Approach to Reasoning with Higher-Order\n  Abstract Syntax", "comments": "58 pages, with 12 figures. To appear in the Journal of Automated\n  Reasoning, accepted April 2010. For associated code, see\n  http://hybrid.dsi.unimi.it/jar/index.html", "journal-ref": null, "doi": null, "report-no": "University of Ottawa Technical Report, number TR-2008-03", "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Combining higher-order abstract syntax and (co)induction in a logical\nframework is well known to be problematic. Previous work described the\nimplementation of a tool called Hybrid, within Isabelle HOL, which aims to\naddress many of these difficulties. It allows object logics to be represented\nusing higher-order abstract syntax, and reasoned about using tactical theorem\nproving and principles of (co)induction. In this paper we describe how to use\nit in a multi-level reasoning fashion, similar in spirit to other meta-logics\nsuch as Twelf. By explicitly referencing provability in a middle layer called a\nspecification logic, we solve the problem of reasoning by (co)induction in the\npresence of non-stratifiable hypothetical judgments, which allow very elegant\nand succinct specifications of object logic inference rules.\n", "versions": [{"version": "v1", "created": "Wed, 26 Nov 2008 17:04:30 GMT"}, {"version": "v2", "created": "Wed, 26 May 2010 13:22:10 GMT"}], "update_date": "2010-05-27", "authors_parsed": [["Felty", "Amy", ""], ["Momigliano", "Alberto", ""]]}, {"id": "0811.4497", "submitter": "Anuj Dawar", "authors": "Anuj Dawar", "title": "Homomorphism Preservation on Quasi-Wide Classes", "comments": "13 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A class of structures is said to have the homomorphism-preservation property\njust in case every first-order formula that is preserved by homomorphisms on\nthis class is equivalent to an existential-positive formula. It is known by a\nresult of Rossman that the class of finite structures has this property and by\nprevious work of Atserias et al. that various of its subclasses do. We extend\nthe latter results by introducing the notion of a quasi-wide class and showing\nthat any quasi-wide class that is closed under taking substructures and\ndisjoint unions has the homomorphism-preservation property. We show, in\nparticular, that classes of structures of bounded expansion and that locally\nexclude minors are quasi-wide. We also construct an example of a class of\nfinite structures which is closed under substructures and disjoint unions but\ndoes not admit the homomorphism-preservation property.\n", "versions": [{"version": "v1", "created": "Thu, 27 Nov 2008 09:50:22 GMT"}, {"version": "v2", "created": "Sun, 8 Mar 2009 17:48:07 GMT"}], "update_date": "2009-03-08", "authors_parsed": [["Dawar", "Anuj", ""]]}, {"id": "0811.4713", "submitter": "Mamadou Moustapha Kant\\'e", "authors": "Bruno Courcelle (LaBRI, IUF), Cyril Gavoille (LaBRI, INRIA Futurs),\n  Mamadou Moustapha Kant\\'e (LaBRI)", "title": "Compact Labelings For Efficient First-Order Model-Checking", "comments": null, "journal-ref": "Journal of Combinatorial Optimisation 21(1):19-46(2011)", "doi": "10.1007/s10878-009-9260-7", "report-no": null, "categories": "cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We consider graph properties that can be checked from labels, i.e., bit\nsequences, of logarithmic length attached to vertices. We prove that there\nexists such a labeling for checking a first-order formula with free set\nvariables in the graphs of every class that is \\emph{nicely locally\ncwd-decomposable}. This notion generalizes that of a \\emph{nicely locally\ntree-decomposable} class. The graphs of such classes can be covered by graphs\nof bounded \\emph{clique-width} with limited overlaps. We also consider such\nlabelings for \\emph{bounded} first-order formulas on graph classes of\n\\emph{bounded expansion}. Some of these results are extended to counting\nqueries.\n", "versions": [{"version": "v1", "created": "Fri, 28 Nov 2008 13:29:15 GMT"}, {"version": "v2", "created": "Tue, 8 Jul 2014 11:29:27 GMT"}], "update_date": "2014-07-09", "authors_parsed": [["Courcelle", "Bruno", "", "LaBRI, IUF"], ["Gavoille", "Cyril", "", "LaBRI, INRIA Futurs"], ["Kant\u00e9", "Mamadou Moustapha", "", "LaBRI"]]}, {"id": "0811.4720", "submitter": "Florent Jacquemard", "authors": "Adel Bouhoula and Florent Jacquemard", "title": "Automated Induction for Complex Data Structures", "comments": "This is the long version of a paper which appeared in IJCAR 2008. 38\n  pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a procedure for automated implicit inductive theorem proving for\nequational specifications made of rewrite rules with conditions and\nconstraints. The constraints are interpreted over constructor terms\n(representing data values), and may express syntactic equality, disequality,\nordering and also membership in a fixed tree language. Constrained equational\naxioms between constructor terms are supported and can be used in order to\nspecify complex data structures like sets, sorted lists, trees, powerlists...\n  Our procedure is based on tree grammars with constraints, a formalism which\ncan describe exactly the initial model of the given specification (when it is\nsufficiently complete and terminating). They are used in the inductive proofs\nfirst as an induction scheme for the generation of subgoals at induction steps,\nsecond for checking validity and redundancy criteria by reduction to an\nemptiness problem, and third for defining and solving membership constraints.\n  We show that the procedure is sound and refutationally complete. It\ngeneralizes former test set induction techniques and yields natural proofs for\nseveral non-trivial examples presented in the paper, these examples are\ndifficult to specify and carry on automatically with related induction\nprocedures.\n", "versions": [{"version": "v1", "created": "Fri, 28 Nov 2008 13:58:46 GMT"}], "update_date": "2008-12-01", "authors_parsed": [["Bouhoula", "Adel", ""], ["Jacquemard", "Florent", ""]]}]