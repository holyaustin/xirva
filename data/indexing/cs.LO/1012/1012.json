[{"id": "1012.0531", "submitter": "Jacob Biamonte", "authors": "Jacob D. Biamonte, Stephen R. Clark and Dieter Jaksch", "title": "Categorical Tensor Network States", "comments": "39 pages, 31 figures, published version", "journal-ref": "AIP Advances 1(4), 042172 (2011)", "doi": "10.1063/1.3672009", "report-no": null, "categories": "quant-ph cond-mat.other cs.CC cs.LO math-ph math.MP", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We examine the use of string diagrams and the mathematics of category theory\nin the description of quantum states by tensor networks. This approach lead to\na unification of several ideas, as well as several results and methods that\nhave not previously appeared in either side of the literature. Our approach\nenabled the development of a tensor network framework allowing a solution to\nthe quantum decomposition problem which has several appealing features.\nSpecifically, given an n-body quantum state S, we present a new and general\nmethod to factor S into a tensor network of clearly defined building blocks. We\nuse the solution to expose a previously unknown and large class of quantum\nstates which we prove can be sampled efficiently and exactly. This general\nframework of categorical tensor network states, where a combination of generic\nand algebraically defined tensors appear, enhances the theory of tensor network\nstates.\n", "versions": [{"version": "v1", "created": "Thu, 2 Dec 2010 18:21:09 GMT"}, {"version": "v2", "created": "Sat, 17 Dec 2011 07:13:48 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Biamonte", "Jacob D.", ""], ["Clark", "Stephen R.", ""], ["Jaksch", "Dieter", ""]]}, {"id": "1012.0735", "submitter": "Jos\\'e L Balc\\'azar Navarro", "authors": "Jos\\'e L. Balc\\'azar, Diego Garc\\'ia-Saiz, Domingo G\\'omez-P\\'erez,\n  Cristina T\\^irn\\u{a}uc\\u{a}", "title": "Closed-set-based Discovery of Bases of Association Rules", "comments": "Shorter version in: Ali Khenchaf and Pascal Poncelet (eds.),\n  Extraction et gestion des connaissances (EGC'2011)", "journal-ref": "Revue des Nouvelles Technologies de l'Information RNTI-E-20\n  (2011), pages 635-646", "doi": null, "report-no": null, "categories": "cs.LG cs.AI cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The output of an association rule miner is often huge in practice. This is\nwhy several concise lossless representations have been proposed, such as the\n\"essential\" or \"representative\" rules. We revisit the algorithm given by\nKryszkiewicz (Int. Symp. Intelligent Data Analysis 2001, Springer-Verlag LNCS\n2189, 350-359) for mining representative rules. We show that its output is\nsometimes incomplete, due to an oversight in its mathematical validation. We\npropose alternative complete generators and we extend the approach to an\nexisting closure-aware basis similar to, and often smaller than, the\nrepresentative rules, namely the basis B*.\n", "versions": [{"version": "v1", "created": "Fri, 3 Dec 2010 13:29:01 GMT"}, {"version": "v2", "created": "Thu, 24 Mar 2011 16:38:44 GMT"}], "update_date": "2011-04-25", "authors_parsed": [["Balc\u00e1zar", "Jos\u00e9 L.", ""], ["Garc\u00eda-Saiz", "Diego", ""], ["G\u00f3mez-P\u00e9rez", "Domingo", ""], ["T\u00eern\u0103uc\u0103", "Cristina", ""]]}, {"id": "1012.0746", "submitter": "Mark Kaminski", "authors": "Mark Kaminski (Saarland University), Sigurd Schneider (Saarland\n  University), Gert Smolka (Saarland University)", "title": "Terminating Tableaux for Graded Hybrid Logic with Global Modalities and\n  Role Hierarchies", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 1 (March 21,\n  2011) lmcs:969", "doi": "10.2168/LMCS-7(1:5)2011", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a terminating tableau calculus for graded hybrid logic with global\nmodalities, reflexivity, transitivity and role hierarchies. Termination of the\nsystem is achieved through pattern-based blocking. Previous approaches to\nrelated logics all rely on chain-based blocking. Besides being conceptually\nsimple and suitable for efficient implementation, the pattern-based approach\ngives us a NExpTime complexity bound for the decision procedure.\n", "versions": [{"version": "v1", "created": "Fri, 3 Dec 2010 14:19:17 GMT"}, {"version": "v2", "created": "Mon, 21 Mar 2011 17:39:23 GMT"}, {"version": "v3", "created": "Tue, 22 Mar 2011 20:49:02 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Kaminski", "Mark", "", "Saarland University"], ["Schneider", "Sigurd", "", "Saarland\n  University"], ["Smolka", "Gert", "", "Saarland University"]]}, {"id": "1012.0929", "submitter": "Danko Ilik", "authors": "Danko Ilik", "title": "Delimited control operators prove Double-negation Shift", "comments": null, "journal-ref": "Annals of Pure and Applied Logic 163(11), 2012", "doi": "10.1016/j.apal.2011.12.008", "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose an extension of minimal intuitionistic predicate logic, based on\ndelimited control operators, that can derive the predicate-logic version of the\nDouble-negation Shift schema, while preserving the disjunction and existence\nproperties.\n", "versions": [{"version": "v1", "created": "Sat, 4 Dec 2010 15:33:43 GMT"}, {"version": "v2", "created": "Fri, 11 Mar 2011 11:39:55 GMT"}], "update_date": "2014-11-04", "authors_parsed": [["Ilik", "Danko", ""]]}, {"id": "1012.1010", "submitter": "Benedikt Ahrens", "authors": "Benedikt Ahrens, Julianna Zsido", "title": "Initial Semantics for higher-order typed syntax in Coq", "comments": "Article as published in JFR (cf. Journal ref). Features some more\n  examples", "journal-ref": "Journal of Formalized Reasoning, Vol. 4, No. 1 (2011), pp. 25-69", "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Initial Semantics aims at characterizing the syntax associated to a signature\nas the initial object of some category. We present an initial semantics result\nfor typed higher-order syntax together with its formalization in the Coq proof\nassistant. The main theorem was first proved on paper in the second author's\nPhD thesis in 2010, and verified formally shortly afterwards. To a simply-typed\nbinding signature S over a fixed set T of object types we associate a category\ncalled the category of representations of S. We show that this category has an\ninitial object Sigma(S). From its construction it will be clear that the object\nSigma(S) merits the name abstract syntax associated to S. Our theorem is\nimplemented and proved correct in the proof assistant Coq through heavy use of\ndependent types. The approach through monads gives rise to an implementation of\nsyntax where both terms and variables are intrinsically typed, i.e. where the\nobject types are reflected in the meta-level types. This article is to be seen\nas a research article rather than about the formalization of a classical\nmathematical result. The nature of our theorem - involving lengthy, technical\nproofs and complicated algebraic structures - makes it particularly interesting\nfor formal verification. Our goal is to promote the use of computer theorem\nprovers as research tools, and, accordingly, a new way of publishing\nmathematical results: a parallel description of a theorem and its formalization\nshould allow the verification of correct transcription of definitions and\nstatements into the proof assistant, and straightforward but technical proofs\nshould be well-hidden in a digital library. We argue that Coq's rich type\ntheory, combined with its various features such as implicit arguments, allows a\nparticularly readable formalization and is hence well-suited for communicating\nmathematics.\n", "versions": [{"version": "v1", "created": "Sun, 5 Dec 2010 16:27:53 GMT"}, {"version": "v2", "created": "Sun, 5 Jun 2011 13:01:48 GMT"}, {"version": "v3", "created": "Sat, 17 Sep 2011 10:19:30 GMT"}], "update_date": "2011-09-20", "authors_parsed": [["Ahrens", "Benedikt", ""], ["Zsido", "Julianna", ""]]}, {"id": "1012.1174", "submitter": "Paulo Oliva", "authors": "Gilda Ferreira (Queen Mary University of London), Paulo Oliva (Queen\n  Mary University of London)", "title": "Functional Interpretations of Intuitionistic Linear Logic", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 1 (March 27,\n  2011) lmcs:1110", "doi": "10.2168/LMCS-7(1:9)2011", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present three different functional interpretations of intuitionistic\nlinear logic ILL and show how these correspond to well-known functional\ninterpretations of intuitionistic logic IL via embeddings of IL into ILL. The\nmain difference from previous work of the second author is that in\nintuitionistic linear logic (as opposed to classical linear logic) the\ninterpretations of !A are simpler and simultaneous quantifiers are no longer\nneeded for the characterisation of the interpretations. We then compare our\napproach in developing these three proof interpretations with the one of de\nPaiva around the Dialectica category model of linear logic.\n", "versions": [{"version": "v1", "created": "Mon, 6 Dec 2010 14:10:29 GMT"}, {"version": "v2", "created": "Thu, 24 Mar 2011 08:59:29 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Ferreira", "Gilda", "", "Queen Mary University of London"], ["Oliva", "Paulo", "", "Queen\n  Mary University of London"]]}, {"id": "1012.1220", "submitter": "Pierre Guillon", "authors": "Silvio Capobianco, Tarmo Uustalu", "title": "A Categorical Outlook on Cellular Automata", "comments": "Journ\\'ees Automates Cellulaires 2010, Turku : Finland (2010)", "journal-ref": null, "doi": null, "report-no": null, "categories": "nlin.CG cs.LO math.CT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In programming language semantics, it has proved to be fruitful to analyze\ncontext-dependent notions of computation, e.g., dataflow computation and\nattribute grammars, using comonads. We explore the viability and value of\nsimilar modeling of cellular automata. We identify local behaviors of cellular\nautomata with coKleisli maps of the exponent comonad on the category of uniform\nspaces and uniformly continuous functions and exploit this equivalence to\nconclude some standard results about cellular automata as instances of basic\ncategory-theoretic generalities. In particular, we recover\nCeccherini-Silberstein and Coornaert's version of the Curtis-Hedlund theorem.\n", "versions": [{"version": "v1", "created": "Fri, 3 Dec 2010 09:39:32 GMT"}], "update_date": "2010-12-07", "authors_parsed": [["Capobianco", "Silvio", ""], ["Uustalu", "Tarmo", ""]]}, {"id": "1012.1221", "submitter": "Pierre Guillon", "authors": "Fabien Givors (LIF), Gr\\'egory Lafitte (LIF), Nicolas Ollinger (LIF)", "title": "Infinite Time Cellular Automata: A Real Computation Model", "comments": "Journ\\'ees Automates Cellulaires 2010, Turku : Finland (2010)", "journal-ref": null, "doi": null, "report-no": null, "categories": "nlin.CG cs.CC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We define a new transfinite time model of computation, infinite time cellular\nautomata. The model is shown to be as powerful than infinite time Turing\nmachines, both on finite and infinite inputs; thus inheriting many of its\nproperties. We then show how to simulate the canonical real computation model,\nBSS machines, with infinite time cellular automata in exactly \\omega steps.\n", "versions": [{"version": "v1", "created": "Fri, 3 Dec 2010 09:57:11 GMT"}], "update_date": "2010-12-07", "authors_parsed": [["Givors", "Fabien", "", "LIF"], ["Lafitte", "Gr\u00e9gory", "", "LIF"], ["Ollinger", "Nicolas", "", "LIF"]]}, {"id": "1012.1222", "submitter": "Pierre Guillon", "authors": "Alexis Ballier (LIF), Emmanuel Jeandel (LIF)", "title": "Computing (or not) Quasi-Periodicity Functions of Tilings", "comments": "Journ\\'ees Automates Cellulaires 2010, Turku : Finland (2010)", "journal-ref": null, "doi": null, "report-no": null, "categories": "nlin.CG cs.LO math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We know that tilesets that can tile the plane always admit a quasi-periodic\ntiling [4, 8], yet they hold many uncomputable properties [3, 11, 21, 25]. The\nquasi-periodicity function is one way to measure the regularity of a\nquasi-periodic tiling. We prove that the tilings by a tileset that admits only\nquasi-periodic tilings have a recursively (and uniformly) bounded\nquasi-periodicity function. This corrects an error from [6, theorem 9] which\nstated the contrary. Instead we construct a tileset for which any\nquasi-periodic tiling has a quasi-periodicity function that cannot be\nrecursively bounded. We provide such a construction for 1-dimensional effective\nsubshifts and obtain as a corollary the result for tilings of the plane via\nrecent links between these objects [1, 10].\n", "versions": [{"version": "v1", "created": "Fri, 3 Dec 2010 09:58:32 GMT"}], "update_date": "2010-12-07", "authors_parsed": [["Ballier", "Alexis", "", "LIF"], ["Jeandel", "Emmanuel", "", "LIF"]]}, {"id": "1012.1552", "submitter": "Emad Saad", "authors": "Emad Saad", "title": "Bridging the Gap between Reinforcement Learning and Knowledge\n  Representation: A Logical Off- and On-Policy Framework", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Knowledge Representation is important issue in reinforcement learning. In\nthis paper, we bridge the gap between reinforcement learning and knowledge\nrepresentation, by providing a rich knowledge representation framework, based\non normal logic programs with answer set semantics, that is capable of solving\nmodel-free reinforcement learning problems for more complex do-mains and\nexploits the domain-specific knowledge. We prove the correctness of our\napproach. We show that the complexity of finding an offline and online policy\nfor a model-free reinforcement learning problem in our approach is NP-complete.\nMoreover, we show that any model-free reinforcement learning problem in MDP\nenvironment can be encoded as a SAT problem. The importance of that is\nmodel-free reinforcement\n", "versions": [{"version": "v1", "created": "Tue, 7 Dec 2010 16:57:54 GMT"}], "update_date": "2010-12-08", "authors_parsed": [["Saad", "Emad", ""]]}, {"id": "1012.1659", "submitter": "Adrian Paschke", "authors": "Ernesto Jimenez-Ruiz, Bernardo Cuenca Grau, Rafael Berlanga and\n  Dietrich Rebholz-Schuhmann", "title": "First steps in the logic-based assessment of post-composed phenotypic\n  descriptions", "comments": "in Adrian Paschke, Albert Burger, Andrea Splendiani, M. Scott\n  Marshall, Paolo Romano: Proceedings of the 3rd International Workshop on\n  Semantic Web Applications and Tools for the Life Sciences, Berlin,Germany,\n  December 8-10, 2010", "journal-ref": null, "doi": null, "report-no": "SWAT4LS 2010", "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present a preliminary logic-based evaluation of the\nintegration of post-composed phenotypic descriptions with domain ontologies.\nThe evaluation has been performed using a description logic reasoner together\nwith scalable techniques: ontology modularization and approximations of the\nlogical difference between ontologies.\n", "versions": [{"version": "v1", "created": "Wed, 8 Dec 2010 00:47:59 GMT"}], "update_date": "2010-12-09", "authors_parsed": [["Jimenez-Ruiz", "Ernesto", ""], ["Grau", "Bernardo Cuenca", ""], ["Berlanga", "Rafael", ""], ["Rebholz-Schuhmann", "Dietrich", ""]]}, {"id": "1012.1769", "submitter": "Marcel Wild", "authors": "Marcel Wild", "title": "Compactly generating all satisfying truth assignments of a Horn formula", "comments": "Considerably improves upon the readibility of the previous version", "journal-ref": "Journal on Satisfiability, Boolean Modeling and Computation 8\n  (2012) 63-82", "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  As instance of an overarching principle of exclusion an algorithm is\npresented that compactly (thus not one by one) generates all models of a Horn\nformula. The principle of exclusion can be adapted to generate only the models\nof weight $k$. We compare and contrast it with constraint programming, $0,1$\ninteger programming, and binary decision diagrams.\n", "versions": [{"version": "v1", "created": "Wed, 8 Dec 2010 14:24:43 GMT"}, {"version": "v2", "created": "Fri, 3 Jun 2011 10:09:45 GMT"}], "update_date": "2017-03-01", "authors_parsed": [["Wild", "Marcel", ""]]}, {"id": "1012.2299", "submitter": "Wlodzimierz Drabent", "authors": "Wlodzimierz Drabent", "title": "A Simple Correctness Proof for Magic Transformation", "comments": "Submitted to \"Theory and Practice of Logic Programming\"", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper presents a simple and concise proof of correctness of the magic\ntransformation. We believe it may provide a useful example of formal reasoning\nabout logic programs.\n  The correctness property concerns the declarative semantics. The proof,\nhowever, refers to the operational semantics (LD-resolution) of the source\nprograms. Its conciseness is due to applying a suitable proof method.\n", "versions": [{"version": "v1", "created": "Fri, 10 Dec 2010 15:50:36 GMT"}], "update_date": "2010-12-13", "authors_parsed": [["Drabent", "Wlodzimierz", ""]]}, {"id": "1012.2381", "submitter": "Michael Pinsker", "authors": "Manuel Bodirsky, Michael Pinsker, Todor Tsankov", "title": "Decidability of definability", "comments": "full journal version (17 pages)", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.LO cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For a fixed countably infinite structure \\Gamma\\ with finite relational\nsignature \\tau, we study the following computational problem: input are\nquantifier-free \\tau-formulas \\phi_0,\\phi_1,...,\\phi_n that define relations\nR_0,R_1,...,R_n over \\Gamma. The question is whether the relation R_0 is\nprimitive positive definable from R_1,...,R_n, i.e., definable by a first-order\nformula that uses only relation symbols for R_1,..., R_n, equality,\nconjunctions, and existential quantification (disjunction, negation, and\nuniversal quantification are forbidden).\n  We show decidability of this problem for all structures \\Gamma\\ that have a\nfirst-order definition in an ordered homogeneous structure \\Delta\\ with a\nfinite relational signature whose age is a Ramsey class and determined by\nfinitely many forbidden substructures. Examples of structures \\Gamma\\ with this\nproperty are the order of the rationals, the random graph, the homogeneous\nuniversal poset, the random tournament, all homogeneous universal C-relations,\nand many more. We also obtain decidability of the problem when we replace\nprimitive positive definability by existential positive, or existential\ndefinability. Our proof makes use of universal algebraic and model theoretic\nconcepts, Ramsey theory, and a recent characterization of Ramsey classes in\ntopological dynamics.\n", "versions": [{"version": "v1", "created": "Fri, 10 Dec 2010 20:57:44 GMT"}, {"version": "v2", "created": "Mon, 13 Dec 2010 13:53:04 GMT"}, {"version": "v3", "created": "Tue, 26 Apr 2011 20:42:01 GMT"}, {"version": "v4", "created": "Sun, 4 Mar 2012 19:10:05 GMT"}], "update_date": "2012-03-06", "authors_parsed": [["Bodirsky", "Manuel", ""], ["Pinsker", "Michael", ""], ["Tsankov", "Todor", ""]]}, {"id": "1012.2553", "submitter": "Jianhua Zhao", "authors": "Jianhua Zhao, Xuandong Li", "title": "Scope Logic with Local Reasoning and Pre/Post-State Properties", "comments": "30 pages, with two non-trival examples in the appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/3.0/", "abstract": "  This paper presents an extension to Hoare logic for pointer program\nverification. Logic formulas with user-defined recursive functions are used to\nspecify properties on the program states before/after program executions.\n  Three basic functions are introduced to represents memory access,\nrecord-field access and array-element access. Some axioms are introduced to\nspecify these basic functions in our logic.\n  The concept Memory Scope Function (MSF) is introduced in our logic. Given a\nrecursive function $f$, the MSF of $f$ computes the set of memory units\naccessed during the evaluation of $f$. A set of rules are given to derive the\ndefinition of this MSF syntactically from the definition of $f$. As MSFs are\nalso recursive functions, they also have their MSFs. An axiom is given to\nspecify that an MSF contains its MSF. Based on this axiom, local reasoning is\nsupported with predicate variables.\n  Pre-state terms are used to specify the relations between pre-states and\npost-states. People can use pre-state terms in post-conditions to represents\nthe values on the pre-state.\n  The axiom of assignment statements in Hoare's logic is modified to deal with\npointers. The basic idea is that during the program execution, a recursive\nfunction is evaluated to the same value as long as no memory unit in its memory\nscope is modified. Another proof rule is added for memory allocation\nstatements.\n  We use a simple example to show that our logic can deal with pointer programs\nin this paper. In the appendix, the Shorre-Waite algorithm is proved using our\nlogic. We also use the selection-sort program to show that our logic can be\nused to prove program with indirectly-specified components.\n", "versions": [{"version": "v1", "created": "Sun, 12 Dec 2010 16:12:57 GMT"}], "update_date": "2010-12-14", "authors_parsed": [["Zhao", "Jianhua", ""], ["Li", "Xuandong", ""]]}, {"id": "1012.2995", "submitter": "Andreas Lundblad", "authors": "Mads Dam, Andreas Lundblad", "title": "A Proof Carrying Code Framework for Inlined Reference Monitors in Java\n  Bytecode", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a light-weight approach for certification of monitor inlining for\nsequential Java bytecode using proof-carrying code. The goal is to enable the\nuse of monitoring for quality assurance at development time, while minimizing\nthe need for post-shipping code rewrites as well as changes to the end-host\nTCB. Standard automaton-based security policies express constraints on allowed\nAPI call/return sequences. Proofs are represented as JML-style program\nannotations. This is adequate in our case as all proofs generated in our\nframework are recognized in time polynomial in the size of the program. Policy\nadherence is proved by comparing the transitions of an inlined monitor with\nthose of a trusted \"ghost\" monitor represented using JML-style annotations. At\ntime of receiving a program with proof annotations, it is sufficient for the\nreceiver to plug in its own trusted ghost monitor and check the resulting\nverification conditions, to verify that inlining has been performed correctly,\nof the correct policy. We have proved correctness of the approach at the Java\nbytecode level and formalized the proof of soundness in Coq. An implementation,\nincluding an application loader running on a mobile device, is available, and\nwe conclude by giving benchmarks for two sample applications.\n", "versions": [{"version": "v1", "created": "Tue, 14 Dec 2010 11:12:36 GMT"}], "update_date": "2010-12-15", "authors_parsed": [["Dam", "Mads", ""], ["Lundblad", "Andreas", ""]]}, {"id": "1012.2998", "submitter": "Stefan Kiefer", "authors": "Stefan Kiefer and Dominik Wojtczak", "title": "On Probabilistic Parallel Programs with Process Creation and\n  Synchronisation", "comments": "This is a technical report accompanying a TACAS'11 paper", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We initiate the study of probabilistic parallel programs with dynamic process\ncreation and synchronisation. To this end, we introduce probabilistic\nsplit-join systems (pSJSs), a model for parallel programs, generalising both\nprobabilistic pushdown systems (a model for sequential probabilistic procedural\nprograms which is equivalent to recursive Markov chains) and stochastic\nbranching processes (a classical mathematical model with applications in\nvarious areas such as biology, physics, and language processing). Our pSJS\nmodel allows for a possibly recursive spawning of parallel processes; the\nspawned processes can synchronise and return values. We study the basic\nperformance measures of pSJSs, especially the distribution and expectation of\nspace, work and time. Our results extend and improve previously known results\non the subsumed models. We also show how to do performance analysis in\npractice, and present two case studies illustrating the modelling power of\npSJSs.\n", "versions": [{"version": "v1", "created": "Tue, 14 Dec 2010 11:24:07 GMT"}], "update_date": "2010-12-21", "authors_parsed": [["Kiefer", "Stefan", ""], ["Wojtczak", "Dominik", ""]]}, {"id": "1012.3018", "submitter": "Paolo Liberatore", "authors": "Paolo Liberatore and Marco Schaerf", "title": "On the size of data structures used in symbolic model checking", "comments": null, "journal-ref": null, "doi": "10.1109/TC.2015.2512872", "report-no": null, "categories": "cs.AI cs.CC cs.DS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Temporal Logic Model Checking is a verification method in which we describe a\nsystem, the model, and then we verify whether some properties, expressed in a\ntemporal logic formula, hold in the system. It has many industrial\napplications. In order to improve performance, some tools allow preprocessing\nof the model, verifying on-line a set of properties reusing the same compiled\nmodel; we prove that the complexity of the Model Checking problem, without any\npreprocessing or preprocessing the model or the formula in a polynomial data\nstructure, is the same. As a result preprocessing does not always exponentially\nimprove performance.\n  Symbolic Model Checking algorithms work by manipulating sets of states, and\nthese sets are often represented by BDDs. It has been observed that the size of\nBDDs may grow exponentially as the model and formula increase in size. As a\nside result, we formally prove that a superpolynomial increase of the size of\nthese BDDs is unavoidable in the worst case. While this exponential growth has\nbeen empirically observed, to the best of our knowledge it has never been\nproved so far in general terms. This result not only holds for all types of\nBDDs regardless of the variable ordering, but also for more powerful data\nstructures, such as BEDs, RBCs, MTBDDs, and ADDs.\n", "versions": [{"version": "v1", "created": "Tue, 14 Dec 2010 13:18:44 GMT"}], "update_date": "2021-04-12", "authors_parsed": [["Liberatore", "Paolo", ""], ["Schaerf", "Marco", ""]]}, {"id": "1012.3040", "submitter": "Jie Ding", "authors": "Jie Ding and Jane Hillston", "title": "Numerically Representing A Stochastic Process Algebra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The syntactic nature and compositionality characteristic of stochastic\nprocess algebras make models to be easily understood by human beings, but not\nconvenient for machines as well as people to directly carry out mathematical\nanalysis and stochastic simulation. This paper presents a numerical\nrepresentation schema for the stochastic process algebra PEPA, which can\nprovide a platform to directly and conveniently employ a variety of\ncomputational approaches to both qualitatively and quantitatively analyse the\nmodels. Moreover, these approaches developed on the basis of the schema are\ndemonstrated and discussed. In particular, algorithms for automatically\nderiving the schema from a general PEPA model and simulating the model based on\nthe derived schema to derive performance measures are presented.\n", "versions": [{"version": "v1", "created": "Mon, 13 Dec 2010 05:43:51 GMT"}], "update_date": "2010-12-15", "authors_parsed": [["Ding", "Jie", ""], ["Hillston", "Jane", ""]]}, {"id": "1012.3372", "submitter": "St\\'ephane Jean Eric Lengrand", "authors": "St\\'ephane Jean Eric Lengrand (CNRS, Ecole Polytechnique, France), Roy\n  Dyckhoff (School of Computer Science, University of St Andrews, Scotland),\n  James McKinna (Radboud University, Nijmegen, The Netherlands)", "title": "A Focused Sequent Calculus Framework for Proof Search in Pure Type\n  Systems", "comments": null, "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 1 (March 23,\n  2011) lmcs:842", "doi": "10.2168/LMCS-7(1:6)2011", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Basic proof-search tactics in logic and type theory can be seen as the\nroot-first applications of rules in an appropriate sequent calculus, preferably\nwithout the redundancies generated by permutation of rules. This paper\naddresses the issues of defining such sequent calculi for Pure Type Systems\n(PTS, which were originally presented in natural deduction style) and then\norganizing their rules for effective proof-search. We introduce the idea of\nPure Type Sequent Calculus with meta-variables (PTSCalpha), by enriching the\nsyntax of a permutation-free sequent calculus for propositional logic due to\nHerbelin, which is strongly related to natural deduction and already well\nadapted to proof-search. The operational semantics is adapted from Herbelin's\nand is defined by a system of local rewrite rules as in cut-elimination, using\nexplicit substitutions. We prove confluence for this system. Restricting our\nattention to PTSC, a type system for the ground terms of this system, we obtain\nthe Subject Reduction property and show that each PTSC is logically equivalent\nto its corresponding PTS, and the former is strongly normalising iff the latter\nis. We show how to make the logical rules of PTSC into a syntax-directed system\nPS for proof-search, by incorporating the conversion rules as in\nsyntax-directed presentations of the PTS rules for type-checking. Finally, we\nconsider how to use the explicitly scoped meta-variables of PTSCalpha to\nrepresent partial proof-terms, and use them to analyse interactive proof\nconstruction. This sets up a framework PE in which we are able to study\nproof-search strategies, type inhabitant enumeration and (higher-order)\nunification.\n", "versions": [{"version": "v1", "created": "Wed, 15 Dec 2010 16:04:02 GMT"}, {"version": "v2", "created": "Wed, 23 Mar 2011 08:02:48 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Lengrand", "St\u00e9phane Jean Eric", "", "CNRS, Ecole Polytechnique, France"], ["Dyckhoff", "Roy", "", "School of Computer Science, University of St Andrews, Scotland"], ["McKinna", "James", "", "Radboud University, Nijmegen, The Netherlands"]]}, {"id": "1012.3704", "submitter": "Janardan Misra", "authors": "Janardan Misra and Suman Roy", "title": "A Decidable Timeout based Extension of Propositional Linear Temporal\n  Logic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a timeout based extension of propositional linear temporal logic\n(which we call TLTL) to specify timing properties of timeout based models of\nreal time systems. TLTL formulas explicitly refer to a running global clock\ntogether with static timing variables as well as a dynamic variable abstracting\nthe timeout behavior. We extend LTL with the capability to express timeout\nconstraints. From the expressiveness view point, TLTL is not comparable with\nimportant known clock based real-time logics including TPTL, XCTL, and MTL,\ni.e., TLTL can specify certain properties, which cannot be specified in these\nlogics (also vice-versa). We define a corresponding timeout tableau for\nsatisfiability checking of the TLTL formulas. Also a model checking algorithm\nover timeout Kripke structure is presented. Further we prove that the validity\nchecking for such an extended logic remains PSPACE-complete even in the\npresence of timeout constraints and infinite state models. Under discrete time\nsemantics, with bounded timeout increments, the model-checking problem that if\na TLTL-formula holds in a timeout Kripke structure is also PSPACE complete. We\nfurther prove that when TLTL is interpreted over discrete time, it can be\nembedded in the monadic second order logic with time, and when TLTL is\ninterpreted over dense time without the condition of non-zenoness, the\nresulting logic becomes $\\Sigma_1^1$-complete.\n", "versions": [{"version": "v1", "created": "Thu, 16 Dec 2010 18:10:26 GMT"}], "update_date": "2010-12-20", "authors_parsed": [["Misra", "Janardan", ""], ["Roy", "Suman", ""]]}, {"id": "1012.3828", "submitter": "Felix Weiss", "authors": "Martin Mundhenk, Felix Weiss", "title": "The model checking problem for intuitionistic propositional logic with\n  one variable is AC1-complete", "comments": "A preliminary version of this work was presented at STACS 2011. 19\n  pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  We show that the model checking problem for intuitionistic propositional\nlogic with one variable is complete for logspace-uniform AC1. As basic tool we\nuse the connection between intuitionistic logic and Heyting algebra, and\ninvestigate its complexity theoretical aspects. For superintuitionistic logics\nwith one variable, we obtain NC1-completeness for the model checking problem.\n", "versions": [{"version": "v1", "created": "Fri, 17 Dec 2010 08:46:44 GMT"}, {"version": "v2", "created": "Wed, 13 Jul 2011 13:34:33 GMT"}, {"version": "v3", "created": "Thu, 15 Sep 2011 12:53:48 GMT"}], "update_date": "2011-09-16", "authors_parsed": [["Mundhenk", "Martin", ""], ["Weiss", "Felix", ""]]}, {"id": "1012.3853", "submitter": "Olivier Bailleux", "authors": "Olivier Bailleux", "title": "On the CNF encoding of cardinality constraints and beyond", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this report, we propose a quick survey of the currently known techniques\nfor encoding a Boolean cardinality constraint into a CNF formula, and we\ndiscuss about the relevance of these encodings. We also propose models to\nfacilitate analysis and design of CNF encodings for Boolean constraints.\n", "versions": [{"version": "v1", "created": "Fri, 17 Dec 2010 11:20:15 GMT"}], "update_date": "2010-12-20", "authors_parsed": [["Bailleux", "Olivier", ""]]}, {"id": "1012.3947", "submitter": "Agust\\'in Valverde", "authors": "Dov Gabbay and David Pearce and Agust\\'i n Valverde", "title": "Interpolation in Equilibrium Logic and Answer Set Programming: the\n  Propositional Case", "comments": "ASPOCP 2010", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.AI", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Interpolation is an important property of classical and many non classical\nlogics that has been shown to have interesting applications in computer science\nand AI. Here we study the Interpolation Property for the propositional version\nof the non-monotonic system of equilibrium logic, establishing weaker or\nstronger forms of interpolation depending on the precise interpretation of the\ninference relation. These results also yield a form of interpolation for ground\nlogic programs under the answer sets semantics. For disjunctive logic programs\nwe also study the property of uniform interpolation that is closely related to\nthe concept of variable forgetting.\n", "versions": [{"version": "v1", "created": "Fri, 17 Dec 2010 18:05:51 GMT"}], "update_date": "2010-12-20", "authors_parsed": [["Gabbay", "Dov", ""], ["Pearce", "David", ""], ["Valverde", "Agust\u00ed n", ""]]}, {"id": "1012.4032", "submitter": "EPTCS", "authors": "Pablo Arrighi, Alejandro D\\'iaz-Caro, Beno\\^it Valiron", "title": "A Type System for the Vectorial Aspect of the Linear-Algebraic\n  Lambda-Calculus", "comments": "In Proceedings DCM 2011, arXiv:1207.6821", "journal-ref": "EPTCS 88, 2012, pp. 1-15", "doi": "10.4204/EPTCS.88.1", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a type system for the linear-algebraic lambda-calculus. The type\nsystem accounts for the part of the language emulating linear operators and\nvectors, i.e. it is able to statically describe the linear combinations of\nterms resulting from the reduction of programs. This gives rise to an original\ntype theory where types, in the same way as terms, can be superposed into\nlinear combinations. We show that the resulting typed lambda-calculus is\nstrongly normalizing and features a weak subject-reduction.\n", "versions": [{"version": "v1", "created": "Fri, 17 Dec 2010 23:09:28 GMT"}, {"version": "v2", "created": "Fri, 4 Feb 2011 17:11:05 GMT"}, {"version": "v3", "created": "Wed, 25 Apr 2012 22:09:20 GMT"}, {"version": "v4", "created": "Tue, 31 Jul 2012 02:05:57 GMT"}], "update_date": "2012-08-01", "authors_parsed": [["Arrighi", "Pablo", ""], ["D\u00edaz-Caro", "Alejandro", ""], ["Valiron", "Beno\u00eet", ""]]}, {"id": "1012.4554", "submitter": "EPTCS", "authors": "Maribel Fernandez (King's College London)", "title": "Proceedings 24th International Workshop on Unification", "comments": null, "journal-ref": "EPTCS 42, 2010", "doi": "10.4204/EPTCS.42", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains selected papers presented at the 24th International\nWorkshop on Unification, UNIF2010, which was held in Edinburgh on the 14th July\n2010, as part of FLoC 2010 (Federated Logic Conferences).\n", "versions": [{"version": "v1", "created": "Tue, 21 Dec 2010 07:05:14 GMT"}], "update_date": "2010-12-22", "authors_parsed": [["Fernandez", "Maribel", "", "King's College London"]]}, {"id": "1012.4555", "submitter": "EPTCS", "authors": "Ana Bove (Chalmers University of Technology), Ekaterina Komendantskaya\n  (University of Dundee), Milad Niqui (CWI)", "title": "Proceedings Workshop on Partiality and Recursion in Interactive Theorem\n  Provers", "comments": null, "journal-ref": "EPTCS 43, 2010", "doi": "10.4204/EPTCS.43", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Workshop on Partiality and\nRecursion in Interactive Theorem Provers (PAR 2010) which took place on July 15\nin Edinburgh, UK. This workshop was held as a satellite workshop of the\nInternational Conference on Interactive Theorem Proving (ITP 2010), itself part\nof the Federated Logic Conference 2010 (FLoC 2010).\n  This workshop is a venue for researchers working on new approaches to cope\nwith partial functions and terminating general (co)recursion in theorem\nprovers.\n", "versions": [{"version": "v1", "created": "Tue, 21 Dec 2010 07:10:03 GMT"}], "update_date": "2010-12-22", "authors_parsed": [["Bove", "Ana", "", "Chalmers University of Technology"], ["Komendantskaya", "Ekaterina", "", "University of Dundee"], ["Niqui", "Milad", "", "CWI"]]}, {"id": "1012.4890", "submitter": "EPTCS", "authors": "Christian Urban (TU Munich, Germany)", "title": "Nominal Unification Revisited", "comments": "In Proceedings UNIF 2010, arXiv:1012.4554", "journal-ref": "EPTCS 42, 2010, pp. 1-11", "doi": "10.4204/EPTCS.42.1", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Nominal unification calculates substitutions that make terms involving\nbinders equal modulo alpha-equivalence. Although nominal unification can be\nseen as equivalent to Miller's higher-order pattern unification, it has\nproperties, such as the use of first-order terms with names (as opposed to\nalpha-equivalence classes) and that no new names need to be generated during\nunification, which set it clearly apart from higher-order pattern unification.\nThe purpose of this paper is to simplify a clunky proof from the original paper\non nominal unification and to give an overview over some results about nominal\nunification.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:07:38 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Urban", "Christian", "", "TU Munich, Germany"]]}, {"id": "1012.4891", "submitter": "EPTCS", "authors": "Deepak Kapur (University of New Mexico), Andrew Marshall (University\n  at Albany-SUNY), Paliath Narendran (University at Albany-SUNY)", "title": "Unification modulo a partial theory of exponentiation", "comments": "In Proceedings UNIF 2010, arXiv:1012.4554", "journal-ref": "EPTCS 42, 2010, pp. 12-23", "doi": "10.4204/EPTCS.42.2", "report-no": null, "categories": "cs.SC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modular exponentiation is a common mathematical operation in modern\ncryptography. This, along with modular multiplication at the base and exponent\nlevels (to different moduli) plays an important role in a large number of key\nagreement protocols. In our earlier work, we gave many decidability as well as\nundecidability results for multiple equational theories, involving various\nproperties of modular exponentiation. Here, we consider a partial subtheory\nfocussing only on exponentiation and multiplication operators. Two main results\nare proved. The first result is positive, namely, that the unification problem\nfor the above theory (in which no additional property is assumed of the\nmultiplication operators) is decidable. The second result is negative: if we\nassume that the two multiplication operators belong to two different abelian\ngroups, then the unification problem becomes undecidable.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:07:45 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Kapur", "Deepak", "", "University of New Mexico"], ["Marshall", "Andrew", "", "University\n  at Albany-SUNY"], ["Narendran", "Paliath", "", "University at Albany-SUNY"]]}, {"id": "1012.4892", "submitter": "EPTCS", "authors": "Sunil Kothari (University of Wyoming), James Caldwell (University of\n  Wyoming)", "title": "A Machine Checked Model of Idempotent MGU Axioms For Lists of Equational\n  Constraints", "comments": "In Proceedings UNIF 2010, arXiv:1012.4554", "journal-ref": "EPTCS 42, 2010, pp. 24-38", "doi": "10.4204/EPTCS.42.3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present formalized proofs verifying that the first-order unification\nalgorithm defined over lists of satisfiable constraints generates a most\ngeneral unifier (MGU), which also happens to be idempotent. All of our proofs\nhave been formalized in the Coq theorem prover. Our proofs show that finite\nmaps produced by the unification algorithm provide a model of the axioms\ncharacterizing idempotent MGUs of lists of constraints. The axioms that serve\nas the basis for our verification are derived from a standard set by extending\nthem to lists of constraints. For us, constraints are equalities between terms\nin the language of simple types. Substitutions are formally modeled as finite\nmaps using the Coq library Coq.FSets.FMapInterface. Coq's method of functional\ninduction is the main proof technique used in proving many of the axioms.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:07:52 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Kothari", "Sunil", "", "University of Wyoming"], ["Caldwell", "James", "", "University of\n  Wyoming"]]}, {"id": "1012.4894", "submitter": "EPTCS", "authors": "Paliath Narendran (University at Albany-SUNY), Andrew Marshall\n  (University at Albany-SUNY), Bibhu Mahapatra (University at Albany-SUNY)", "title": "On the Complexity of the Tiden-Arnborg Algorithm for Unification modulo\n  One-Sided Distributivity", "comments": "In Proceedings UNIF 2010, arXiv:1012.4554", "journal-ref": "EPTCS 42, 2010, pp. 54-63", "doi": "10.4204/EPTCS.42.5", "report-no": null, "categories": "cs.SC cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We prove that the Tiden and Arnborg algorithm for equational unification\nmodulo one-sided distributivity is not polynomial time bounded as previously\nthought. A set of counterexamples is developed that demonstrates that the\nalgorithm goes through exponentially many steps.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:08:05 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Narendran", "Paliath", "", "University at Albany-SUNY"], ["Marshall", "Andrew", "", "University at Albany-SUNY"], ["Mahapatra", "Bibhu", "", "University at Albany-SUNY"]]}, {"id": "1012.4895", "submitter": "EPTCS", "authors": "Alexander Krauss (Technische Universit\\\"at M\\\"unchen)", "title": "Recursive Definitions of Monadic Functions", "comments": "In Proceedings PAR 2010, arXiv:1012.4555", "journal-ref": "EPTCS 43, 2010, pp. 1-13", "doi": "10.4204/EPTCS.43.1", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Using standard domain-theoretic fixed-points, we present an approach for\ndefining recursive functions that are formulated in monadic style. The method\nworks both in the simple option monad and the state-exception monad of\nIsabelle/HOL's imperative programming extension, which results in a convenient\ndefinition principle for imperative programs, which were previously hard to\ndefine.\n  For such monadic functions, the recursion equation can always be derived\nwithout preconditions, even if the function is partial. The construction is\neasy to automate, and convenient induction principles can be derived\nautomatically.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:09:04 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Krauss", "Alexander", "", "Technische Universit\u00e4t M\u00fcnchen"]]}, {"id": "1012.4896", "submitter": "EPTCS", "authors": "Andreas Abel (Ludwig-Maximilians-University Munich)", "title": "MiniAgda: Integrating Sized and Dependent Types", "comments": "In Proceedings PAR 2010, arXiv:1012.4555", "journal-ref": "EPTCS 43, 2010, pp. 14-28", "doi": "10.4204/EPTCS.43.2", "report-no": null, "categories": "cs.PL cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Sized types are a modular and theoretically well-understood tool for checking\ntermination of recursive and productivity of corecursive definitions. The\nessential idea is to track structural descent and guardedness in the type\nsystem to make termination checking robust and suitable for strong abstractions\nlike higher-order functions and polymorphism. To study the application of sized\ntypes to proof assistants and programming languages based on dependent type\ntheory, we have implemented a core language, MiniAgda, with explicit handling\nof sizes. New considerations were necessary to soundly integrate sized types\nwith dependencies and pattern matching, which was made possible by concepts\nsuch as inaccessible patterns and parametric function spaces. This paper\nprovides an introduction to MiniAgda by example and informal explanations of\nthe underlying principles.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:09:10 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Abel", "Andreas", "", "Ludwig-Maximilians-University Munich"]]}, {"id": "1012.4897", "submitter": "EPTCS", "authors": "Issam Maamria (University of Southampton), Michael Butler (University\n  of Southampton)", "title": "Rewriting and Well-Definedness within a Proof System", "comments": "In Proceedings PAR 2010, arXiv:1012.4555", "journal-ref": "EPTCS 43, 2010, pp. 49-64", "doi": "10.4204/EPTCS.43.4", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Term rewriting has a significant presence in various areas, not least in\nautomated theorem proving where it is used as a proof technique. Many theorem\nprovers employ specialised proof tactics for rewriting. This results in an\ninterleaving between deduction and computation (i.e., rewriting) steps. If the\nlogic of reasoning supports partial functions, it is necessary that rewriting\ncopes with potentially ill-defined terms. In this paper, we provide a basis for\nintegrating rewriting with a deductive proof system that deals with\nwell-definedness. The definitions and theorems presented in this paper are the\ntheoretical foundations for an extensible rewriting-based prover that has been\nimplemented for the set theoretical formalism Event-B.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:09:25 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Maamria", "Issam", "", "University of Southampton"], ["Butler", "Michael", "", "University\n  of Southampton"]]}, {"id": "1012.4898", "submitter": "EPTCS", "authors": "Nils Anders Danielsson (University of Nottingham)", "title": "Beating the Productivity Checker Using Embedded Languages", "comments": "In Proceedings PAR 2010, arXiv:1012.4555", "journal-ref": "EPTCS 43, 2010, pp. 29-48", "doi": "10.4204/EPTCS.43.3", "report-no": null, "categories": "cs.LO cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Some total languages, like Agda and Coq, allow the use of guarded corecursion\nto construct infinite values and proofs. Guarded corecursion is a form of\nrecursion in which arbitrary recursive calls are allowed, as long as they are\nguarded by a coinductive constructor. Guardedness ensures that programs are\nproductive, i.e. that every finite prefix of an infinite value can be computed\nin finite time. However, many productive programs are not guarded, and it can\nbe nontrivial to put them in guarded form.\n  This paper gives a method for turning a productive program into a guarded\nprogram. The method amounts to defining a problem-specific language as a data\ntype, writing the program in the problem-specific language, and writing a\nguarded interpreter for this language.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:09:30 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Danielsson", "Nils Anders", "", "University of Nottingham"]]}, {"id": "1012.4899", "submitter": "EPTCS", "authors": "Claudio Sacerdoti Coen (Dipartimento di Scienze dell'Informazione,\n  Universit\\`a di Bologna), Silvio Valentini (Dipartimento di Matematica Pura e\n  Applicata, Universit\\`a di Padova)", "title": "General Recursion and Formal Topology", "comments": "In Proceedings PAR 2010, arXiv:1012.4555", "journal-ref": "EPTCS 43, 2010, pp. 65-75", "doi": "10.4204/EPTCS.43.5", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  It is well known that general recursion cannot be expressed within\nMartin-Loef's type theory and various approaches have been proposed to overcome\nthis problem still maintaining the termination of the computation of the\ntypable terms. In this work we propose a new approach to this problem based on\nthe use of inductively generated formal topologies.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 07:09:32 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Coen", "Claudio Sacerdoti", "", "Dipartimento di Scienze dell'Informazione,\n  Universit\u00e0 di Bologna"], ["Valentini", "Silvio", "", "Dipartimento di Matematica Pura e\n  Applicata, Universit\u00e0 di Padova"]]}, {"id": "1012.5059", "submitter": "Alban Ponse", "authors": "Jan A. Bergstra and Alban Ponse", "title": "On Hoare-McCarthy algebras", "comments": "29 pages, 1 table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO math.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We discuss an algebraic approach to propositional logic with side effects. To\nthis end, we use Hoare's conditional [1985], which is a ternary connective\ncomparable to if-then-else. Starting from McCarthy's notion of sequential\nevaluation [1963] we discuss a number of valuation congruences and we introduce\nHoare-McCarthy algebras as the structures that characterize these congruences.\n", "versions": [{"version": "v1", "created": "Wed, 22 Dec 2010 17:58:02 GMT"}], "update_date": "2010-12-23", "authors_parsed": [["Bergstra", "Jan A.", ""], ["Ponse", "Alban", ""]]}, {"id": "1012.5224", "submitter": "Soren Riis", "authors": "Soren Riis and Maximilien Gadouleau", "title": "Max-Flow Min-Cut Theorems for Multi-User Communication Networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.IT cs.LO math.CO math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper presents four distinct new ideas and results for communication\nnetworks:\n  1) We show that relay-networks (i.e. communication networks where different\nnodes use the same coding functions) can be used to model dynamic networks.\n  2) We introduce {\\em the term model}, which is a simple, graph-free symbolic\napproach to communication networks.\n  3) We state and prove variants of a theorem concerning the dispersion of\ninformation in single-receiver communications.\n  4) We show that the solvability of an abstract multi-user communication\nproblem is equivalent to the solvability of a single-target communication in a\nsuitable relay network.\n  In the paper, we develop a number of technical ramifications of these ideas\nand results. One technical result is a max-flow min-cut theorem for the R\\'enyi\nentropy with order less than one, given that the sources are equiprobably\ndistributed; conversely, we show that the max-flow min-cut theorem fails for\nthe R\\'enyi entropy with order greater than one. We leave the status of the\ntheorem with regards to the ordinary Shannon Entropy measure (R\\'enyi entropy\nof order one and the limit case between validity or failure of the theorem) as\nan open question. In non-dynamic static communication networks with a single\nreceiver, a simple application of Menger's theorem shows that the optimal\nthroughput can be achieved without proper use of network coding i.e. just by\nusing ordinary packet-switching. This fails dramatically in relay networks with\na single receiver. We show that even a powerful method like linear network\ncoding fails miserably for relay networks. With that in mind, it is noticeable\nthat our rather weak form of network coding (routing with dynamic headers) is\nasymptotically sufficient to reach capacity.\n", "versions": [{"version": "v1", "created": "Thu, 23 Dec 2010 15:09:14 GMT"}, {"version": "v2", "created": "Tue, 1 Mar 2011 15:39:06 GMT"}, {"version": "v3", "created": "Wed, 15 Oct 2014 23:46:43 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Riis", "Soren", ""], ["Gadouleau", "Maximilien", ""]]}, {"id": "1012.5337", "submitter": "EPTCS", "authors": "H\\'el\\`ene Kirchner (INRIA, France), C\\'esar Mu\\~noz (NASA, USA)", "title": "Proceedings International Workshop on Strategies in Rewriting, Proving,\n  and Programming", "comments": null, "journal-ref": "EPTCS 44, 2010", "doi": "10.4204/EPTCS.44", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains selected papers from the proceedings of the First\nInternational Workshop on Strategies in Rewriting, Proving, and Programming\n(IWS 2010), which was held on July 9, 2010, in Edinburgh, UK. Strategies are\nubiquitous in programming languages, automated deduction and reasoning systems.\nIn the two communities of Rewriting and Programming on one side, and of\nDeduction and Proof engines (Provers, Assistants, Solvers) on the other side,\nworkshops have been launched to make progress towards a deeper understanding of\nthe nature of strategies, their descriptions, their properties, and their\nusage, in all kinds of computing and reasoning systems. Since more recently,\nstrategies are also playing an important role in rewrite-based programming\nlanguages, verification tools and techniques like SAT/SMT engines or\ntermination provers. Moreover strategies have come to be viewed more generally\nas expressing complex designs for control in computing, modeling, proof search,\nprogram transformation, and access control. IWS 2010 was organized as a\nsatellite workshop of FLoC 2010. FLoC 2010 provided an excellent opportunity to\nfoster exchanges between the communities of Rewriting and Programming on one\nside, and of Deduction and Proof engines on the other side. IWS2010 was a joint\nfollow-up of two series of worshops, held since 1997: the Strategies workshops\nheld by the CADE-IJCAR community and the Workshops on Reduction Strategies\n(WRS) held by the RTA-RDP community.\n", "versions": [{"version": "v1", "created": "Fri, 24 Dec 2010 03:28:30 GMT"}], "update_date": "2010-12-27", "authors_parsed": [["Kirchner", "H\u00e9l\u00e8ne", "", "INRIA, France"], ["Mu\u00f1oz", "C\u00e9sar", "", "NASA, USA"]]}, {"id": "1012.5439", "submitter": "Ahmet Kara", "authors": "Ahmet Kara and Tony Tan", "title": "Extending B\\\"uchi Automata with Constraints on Data Values", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recently data trees and data words have received considerable amount of\nattention in connection with XML reasoning and system verification. These are\ntrees or words that, in addition to labels from a finite alphabet, carry data\nvalues from an infinite alphabet (data). In general it is rather hard to obtain\nlogics for data words and trees that are sufficiently expressive, but still\nhave reasonable complexity for the satisfiability problem. In this paper we\nextend and study the notion of B\\\"uchi automata for omega-words with data. We\nprove that the emptiness problem for such extension is decidable in elementary\ncomplexity. We then apply our result to show the decidability of two kinds of\nlogics for omega-words with data: the two-variable fragment of first-order\nlogic and some extensions of classical linear temporal logic for omega-words\nwith data.\n", "versions": [{"version": "v1", "created": "Fri, 24 Dec 2010 22:33:10 GMT"}, {"version": "v2", "created": "Sat, 23 Jun 2012 10:12:47 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Kara", "Ahmet", ""], ["Tan", "Tony", ""]]}, {"id": "1012.5561", "submitter": "EPTCS", "authors": "Alex Gerdes (Open Universiteit Nederland), Bastiaan Heeren (Open\n  Universiteit Nederland), Johan Jeuring (Utrecht University)", "title": "Properties of Exercise Strategies", "comments": "In Proceedings IWS 2010, arXiv:1012.5337", "journal-ref": "EPTCS 44, 2010, pp. 21-34", "doi": "10.4204/EPTCS.44.2", "report-no": null, "categories": "cs.CY cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Mathematical learning environments give domain-specific and immediate\nfeedback to students solving a mathematical exercise. Based on a language for\nspecifying strategies, we have developed a feedback framework that\nautomatically calculates semantically rich feedback. We offer this feedback\nfunctionality to mathematical learning environments via a set of web services.\nFeedback is only effective when it is precise and to the point. The tests we\nhave performed give some confidence about the correctness of our feedback\nservices. To increase confidence in our services, we explicitly specify the\nproperties our feedback services should satisfy, and, if possible, prove them\ncorrect. For this, we give a formal description of the concepts used in our\nfeedback framework services. The formalisation allows us to reason about these\nconcepts, and to state a number of desired properties of the concepts. Our\nfeedback services use exercise descriptions for their instances on domains such\nas logic, algebra, and linear algebra. We formulate requirements these domain\ndescriptions should satisfy for the feedback services to react as expected.\n", "versions": [{"version": "v1", "created": "Mon, 27 Dec 2010 06:30:10 GMT"}], "update_date": "2010-12-30", "authors_parsed": [["Gerdes", "Alex", "", "Open Universiteit Nederland"], ["Heeren", "Bastiaan", "", "Open\n  Universiteit Nederland"], ["Jeuring", "Johan", "", "Utrecht University"]]}, {"id": "1012.5562", "submitter": "EPTCS", "authors": "Bernhard Gramlich (Vienna University of Technology), Felix\n  Schernhammer (Vienna University of Technology)", "title": "Termination of Rewriting with and Automated Synthesis of Forbidden\n  Patterns", "comments": "In Proceedings IWS 2010, arXiv:1012.5337", "journal-ref": "EPTCS 44, 2010, pp. 35-50", "doi": "10.4204/EPTCS.44.3", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a modified version of the well-known dependency pair framework\nthat is suitable for the termination analysis of rewriting under forbidden\npattern restrictions. By attaching contexts to dependency pairs that represent\nthe calling contexts of the corresponding recursive function calls, it is\npossible to incorporate the forbidden pattern restrictions in the (adapted)\nnotion of dependency pair chains, thus yielding a sound and complete approach\nto termination analysis. Building upon this contextual dependency pair\nframework we introduce a dependency pair processor that simplifies problems by\nanalyzing the contextual information of the dependency pairs. Moreover, we show\nhow this processor can be used to synthesize forbidden patterns suitable for a\ngiven term rewriting system on-the-fly during the termination analysis.\n", "versions": [{"version": "v1", "created": "Mon, 27 Dec 2010 06:30:17 GMT"}], "update_date": "2010-12-30", "authors_parsed": [["Gramlich", "Bernhard", "", "Vienna University of Technology"], ["Schernhammer", "Felix", "", "Vienna University of Technology"]]}, {"id": "1012.5563", "submitter": "EPTCS", "authors": "Ren\\'e Thiemann (University of Innsbruck, Austria), Christian\n  Sternagel (University of Innsbruck, Austria), J\\\"urgen Giesl (RWTH Aachen\n  University, Germany), Peter Schneider-Kamp (University of Southern Denmark,\n  Denmark)", "title": "Loops under Strategies ... Continued", "comments": "In Proceedings IWS 2010, arXiv:1012.5337", "journal-ref": "EPTCS 44, 2010, pp. 51-65", "doi": "10.4204/EPTCS.44.4", "report-no": null, "categories": "cs.LO cs.CC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While there are many approaches for automatically proving termination of term\nrewrite systems, up to now there exist only few techniques to disprove their\ntermination automatically. Almost all of these techniques try to find loops,\nwhere the existence of a loop implies non-termination of the rewrite system.\nHowever, most programming languages use specific evaluation strategies, whereas\nloop detection techniques usually do not take strategies into account. So even\nif a rewrite system has a loop, it may still be terminating under certain\nstrategies.\n  Therefore, our goal is to develop decision procedures which can determine\nwhether a given loop is also a loop under the respective evaluation strategy.\nIn earlier work, such procedures were presented for the strategies of\ninnermost, outermost, and context-sensitive evaluation. In the current paper,\nwe build upon this work and develop such decision procedures for important\nstrategies like leftmost-innermost, leftmost-outermost,\n(max-)parallel-innermost, (max-)parallel-outermost, and forbidden patterns\n(which generalize innermost, outermost, and context-sensitive strategies). In\nthis way, we obtain the first approach to disprove termination under these\nstrategies automatically.\n", "versions": [{"version": "v1", "created": "Mon, 27 Dec 2010 06:30:24 GMT"}], "update_date": "2010-12-30", "authors_parsed": [["Thiemann", "Ren\u00e9", "", "University of Innsbruck, Austria"], ["Sternagel", "Christian", "", "University of Innsbruck, Austria"], ["Giesl", "J\u00fcrgen", "", "RWTH Aachen\n  University, Germany"], ["Schneider-Kamp", "Peter", "", "University of Southern Denmark,\n  Denmark"]]}, {"id": "1012.5590", "submitter": "Silvio Ranise", "authors": "A. Armando and S. Ranise", "title": "Automated Symbolic Analysis of ARBAC-Policies (Extended Version)", "comments": "Long version of the paper entitled \"Automated Symbolic Analysis of\n  ARBAC Policies\" published in Proc. of 6th Int. Workshop on Security and Trust\n  Management (co-located with EUROPKI'10, CRITIS'10, and ESORICS'10), Athens,\n  Sept. 23-24 (2010). Also, to appear in LNCS", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CR cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  One of the most widespread framework for the management of access-control\npolicies is Administrative Role Based Access Control (ARBAC). Several automated\nanalysis techniques have been proposed to help maintaining desirable security\nproperties of ARBAC policies. One limitation of many available techniques is\nthat the sets of users and roles are bounded. In this paper, we propose a\nsymbolic framework to overcome this difficulty. We design an automated security\nanalysis technique, parametric in the number of users and roles, by adapting\nrecent methods for model checking infinite state systems that use first-order\nlogic and state-of-the-art theorem proving techniques. Preliminary experiments\nwith a prototype implementations seem to confirm the scalability of our\ntechnique.\n", "versions": [{"version": "v1", "created": "Mon, 27 Dec 2010 10:53:25 GMT"}], "update_date": "2010-12-30", "authors_parsed": [["Armando", "A.", ""], ["Ranise", "S.", ""]]}, {"id": "1012.5803", "submitter": "Desharnais Jules", "authors": "Desharnais Jules (D'epartement d'informatique et de g'enie logiciel,\n  Universit'e Laval, Quebec, C), Bernhard Moeller (Institute for Informatics,\n  University of Augsburg, Germany), Struth Georg (Department of Computer\n  Science, University of Sheffield, United Kingdom)", "title": "Algebraic Notions of Termination", "comments": "29 pages", "journal-ref": "Logical Methods in Computer Science, Volume 7, Issue 1 (February\n  11, 2011) lmcs:777", "doi": "10.2168/LMCS-7(1:1)2011", "report-no": null, "categories": "cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Five algebraic notions of termination are formalised, analysed and compared:\nwellfoundedness or Noetherity, L\\\"ob's formula, absence of infinite iteration,\nabsence of divergence and normalisation. The study is based on modal semirings,\nwhich are additively idempotent semirings with forward and backward modal\noperators. To model infinite behaviours, idempotent semirings are extended to\ndivergence semirings, divergence Kleene algebras and omega algebras. The\nresulting notions and techniques are used in calculational proofs of classical\ntheorems of rewriting theory. These applications show that modal semirings are\npowerful tools for reasoning algebraically about the finite and infinite\ndynamics of programs and transition systems.\n", "versions": [{"version": "v1", "created": "Tue, 28 Dec 2010 17:33:09 GMT"}, {"version": "v2", "created": "Fri, 11 Feb 2011 11:57:33 GMT"}, {"version": "v3", "created": "Sun, 20 Mar 2011 10:37:05 GMT"}], "update_date": "2015-07-01", "authors_parsed": [["Jules", "Desharnais", "", "D'epartement d'informatique et de g'enie logiciel,\n  Universit'e Laval, Quebec, C"], ["Moeller", "Bernhard", "", "Institute for Informatics,\n  University of Augsburg, Germany"], ["Georg", "Struth", "", "Department of Computer\n  Science, University of Sheffield, United Kingdom"]]}, {"id": "1012.5804", "submitter": "Algirdas Antano Maknickas Dr.", "authors": "Algirdas Antano Maknickas", "title": "Finding of k in Fagin's R. Theorem 24", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CC cs.LO", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  By using of analytical multi-logic expresses in conjunction with\nnon-deterministic Turing machine the proposition was proved that algorithm of\ndeterministic Turing counter machine of polynomial time complexity can be\ndecreased to the algorithm of linear time complexity in non-deterministic\nTuring counter machine. Furthermore, it was shown that existence of reduction\nof polynomial time complexity to the linear time complexity by switching from\ndeterministic to non-deterministic Turing machine for string recognition imply\nP equals to NP. Analytical generation functions of higher order logic were used\nfor finding of k value in Fagin's R. Theorem 24.\n", "versions": [{"version": "v1", "created": "Tue, 28 Dec 2010 17:46:39 GMT"}, {"version": "v2", "created": "Fri, 30 Mar 2012 06:49:34 GMT"}, {"version": "v3", "created": "Mon, 17 Oct 2016 13:34:56 GMT"}, {"version": "v4", "created": "Wed, 19 Oct 2016 09:09:58 GMT"}], "update_date": "2016-10-20", "authors_parsed": [["Maknickas", "Algirdas Antano", ""]]}]