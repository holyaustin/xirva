[{"id": "0805.0192", "submitter": "Xavier Gonze J", "authors": "X. Gonze (1,2), C.-O. Almbladh (1,3), A. Cucca (1,4), D. Caliste\n  (1,2,5), C. Freysoldt (1,6), M. A. L. Marques (1,7,8), V. Olevano (1,4,9), Y.\n  Pouillon (1,2,10), M.J. Verstraete (1,11) ((1) European Theoretical\n  Spectroscopy Facility, (2) Universit\\'e Catholique de Louvain,\n  Louvain-la-Neuve, Belgium (3) University of Lund, Lund, Sweden (4) LSI,\n  CNRS-CEA, Ecole Polytechnique, Palaiseau, France, (5) C.E.A. Grenoble,\n  Grenoble, France, (6) Fritz-Haber-Institut, Berlin, Germany, (7) U. Lyon 1,\n  Villeurbanne, France, (8) U. Coimbra, Coimbra, Portugal, (9) Institut NEEL,\n  CNRS and U. Joseph Fourier, Grenoble, France, (10) Universidad del Pais Vasco\n  UPV/EHU, Donostia-San Sebasti\\`an, Spain, (11) U. York, York, United Kingdom)", "title": "Specification of an extensible and portable file format for electronic\n  structure and crystallographic data", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DL cond-mat.mtrl-sci cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In order to allow different software applications, in constant evolution, to\ninteract and exchange data, flexible file formats are needed. A file format\nspecification for different types of content has been elaborated to allow\ncommunication of data for the software developed within the European Network of\nExcellence \"NANOQUANTA\", focusing on first-principles calculations of materials\nand nanosystems. It might be used by other software as well, and is described\nhere in detail. The format relies on the NetCDF binary input/output library,\nalready used in many different scientific communities, that provides\nflexibility as well as portability accross languages and platforms. Thanks to\nNetCDF, the content can be accessed by keywords, ensuring the file format is\nextensible and backward compatible.\n", "versions": [{"version": "v1", "created": "Fri, 2 May 2008 08:48:26 GMT"}], "update_date": "2008-05-05", "authors_parsed": [["Gonze", "X.", ""], ["Almbladh", "C. -O.", ""], ["Cucca", "A.", ""], ["Caliste", "D.", ""], ["Freysoldt", "C.", ""], ["Marques", "M. A. L.", ""], ["Olevano", "V.", ""], ["Pouillon", "Y.", ""], ["Verstraete", "M. J.", ""]]}, {"id": "0805.0330", "submitter": "Ranko Lazic", "authors": "Marcin Jurdzinski and Ranko Lazic", "title": "Alternating Automata on Data Trees and XPath Satisfiability", "comments": "23 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.DB cs.FL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A data tree is an unranked ordered tree whose every node is labelled by a\nletter from a finite alphabet and an element (\"datum\") from an infinite set,\nwhere the latter can only be compared for equality. The article considers\nalternating automata on data trees that can move downward and rightward, and\nhave one register for storing data. The main results are that nonemptiness over\nfinite data trees is decidable but not primitive recursive, and that\nnonemptiness of safety automata is decidable but not elementary. The proofs use\nnondeterministic tree automata with faulty counters. Allowing upward moves,\nleftward moves, or two registers, each causes undecidability. As corollaries,\ndecidability is obtained for two data-sensitive fragments of the XPath query\nlanguage.\n", "versions": [{"version": "v1", "created": "Sat, 3 May 2008 00:12:15 GMT"}, {"version": "v2", "created": "Tue, 23 Jun 2009 13:21:17 GMT"}, {"version": "v3", "created": "Mon, 1 Mar 2010 15:20:58 GMT"}, {"version": "v4", "created": "Mon, 14 Jun 2010 14:13:49 GMT"}], "update_date": "2010-06-15", "authors_parsed": [["Jurdzinski", "Marcin", ""], ["Lazic", "Ranko", ""]]}, {"id": "0805.0747", "submitter": "Daniel Lemire", "authors": "Hazel Webb, Owen Kaser, Daniel Lemire", "title": "Pruning Attribute Values From Data Cubes with Diamond Dicing", "comments": null, "journal-ref": null, "doi": null, "report-no": "TR-08-011 (UNB Saint John)", "categories": "cs.DB cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Data stored in a data warehouse are inherently multidimensional, but most\ndata-pruning techniques (such as iceberg and top-k queries) are unidimensional.\nHowever, analysts need to issue multidimensional queries. For example, an\nanalyst may need to select not just the most profitable stores\nor--separately--the most profitable products, but simultaneous sets of stores\nand products fulfilling some profitability constraints. To fill this need, we\npropose a new operator, the diamond dice. Because of the interaction between\ndimensions, the computation of diamonds is challenging. We present the first\ndiamond-dicing experiments on large data sets. Experiments show that we can\ncompute diamond cubes over fact tables containing 100 million facts in less\nthan 35 minutes using a standard PC.\n", "versions": [{"version": "v1", "created": "Tue, 6 May 2008 15:45:15 GMT"}], "update_date": "2008-05-07", "authors_parsed": [["Webb", "Hazel", ""], ["Kaser", "Owen", ""], ["Lemire", "Daniel", ""]]}, {"id": "0805.1487", "submitter": "Spyros Sioutas SS", "authors": "Lagogiannis George, Lorentzos Nikos, Sioutas Spyros, Theodoridis\n  Evaggelos", "title": "A Time Efficient Indexing Scheme for Complex Spatiotemporal Retrieval", "comments": "6 pages, 7 figures, submitted to Sigmod Record", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper is concerned with the time efficient processing of spatiotemporal\npredicates, i.e. spatial predicates associated with an exact temporal\nconstraint. A set of such predicates forms a buffer query or a Spatio-temporal\nPattern (STP) Query with time. In the more general case of an STP query, the\ntemporal dimension is introduced via the relative order of the spatial\npredicates (STP queries with order). Therefore, the efficient processing of a\nspatiotemporal predicate is crucial for the efficient implementation of more\ncomplex queries of practical interest. We propose an extension of a known\napproach, suitable for processing spatial predicates, which has been used for\nthe efficient manipulation of STP queries with order. The extended method is\nsupported by efficient indexing structures. We also provide experimental\nresults that show the efficiency of the technique.\n", "versions": [{"version": "v1", "created": "Sat, 10 May 2008 17:18:32 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["George", "Lagogiannis", ""], ["Nikos", "Lorentzos", ""], ["Spyros", "Sioutas", ""], ["Evaggelos", "Theodoridis", ""]]}, {"id": "0805.1593", "submitter": "Bernd G\\\"unther", "authors": "Bernd G\\\"unther", "title": "On the Probability Distribution of Superimposed Random Codes", "comments": null, "journal-ref": "IEEE Trans. Inf. Theory, 54(7):3206--3210, 2008", "doi": "10.1109/TIT.2008.924658", "report-no": null, "categories": "cs.DB cs.DM cs.IT math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A systematic study of the probability distribution of superimposed random\ncodes is presented through the use of generating functions. Special attention\nis paid to the cases of either uniformly distributed but not necessarily\nindependent or non uniform but independent bit structures. Recommendations for\noptimal coding strategies are derived.\n", "versions": [{"version": "v1", "created": "Mon, 12 May 2008 08:52:16 GMT"}, {"version": "v2", "created": "Thu, 19 Jun 2008 05:30:49 GMT"}], "update_date": "2008-06-19", "authors_parsed": [["G\u00fcnther", "Bernd", ""]]}, {"id": "0805.2671", "submitter": "Spyros Sioutas SS", "authors": "Spyros Sioutas", "title": "Finger Indexed Sets: New Approaches", "comments": "13 pages, 1 figure, Submitted to Journal of Universal Computer\n  Science (J.UCS)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the particular case we have insertions/deletions at the tail of a given\nset S of $n$ one-dimensional elements, we present a simpler and more concrete\nalgorithm than that presented in [Anderson, 2007] achieving the same (but also\namortized) upper bound of $O(\\sqrt{logd/loglogd})$ for finger searching\nqueries, where $d$ is the number of sorted keys between the finger element and\nthe target element we are looking for. Furthermore, in general case we have\ninsertions/deletions anywhere we present a new randomized algorithm achieving\nthe same expected time bounds. Even the new solutions achieve the optimal\nbounds in amortized or expected case, the advantage of simplicity is of great\nimportance due to practical merits we gain.\n", "versions": [{"version": "v1", "created": "Sat, 17 May 2008 14:05:12 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Sioutas", "Spyros", ""]]}, {"id": "0805.3339", "submitter": "Daniel Lemire", "authors": "Kamel Aouiche, Daniel Lemire, Owen Kaser", "title": "Tri de la table de faits et compression des index bitmaps avec\n  alignement sur les mots", "comments": "to appear at BDA'08", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Bitmap indexes are frequently used to index multidimensional data. They rely\nmostly on sequential input/output. Bitmaps can be compressed to reduce\ninput/output costs and minimize CPU usage. The most efficient compression\ntechniques are based on run-length encoding (RLE), such as Word-Aligned Hybrid\n(WAH) compression. This type of compression accelerates logical operations\n(AND, OR) over the bitmaps. However, run-length encoding is sensitive to the\norder of the facts. Thus, we propose to sort the fact tables. We review\nlexicographic, Gray-code, and block-wise sorting. We found that a lexicographic\nsort improves compression--sometimes generating indexes twice as small--and\nmake indexes several times faster. While sorting takes time, this is partially\noffset by the fact that it is faster to index a sorted table. Column order is\nsignificant: it is generally preferable to put the columns having more distinct\nvalues at the beginning. A block-wise sort is much less efficient than a full\nsort. Moreover, we found that Gray-code sorting is not better than\nlexicographic sorting when using word-aligned compression.\n", "versions": [{"version": "v1", "created": "Wed, 21 May 2008 19:50:46 GMT"}, {"version": "v2", "created": "Tue, 8 Jul 2008 23:46:51 GMT"}, {"version": "v3", "created": "Fri, 15 Aug 2008 00:08:42 GMT"}], "update_date": "2008-08-15", "authors_parsed": [["Aouiche", "Kamel", ""], ["Lemire", "Daniel", ""], ["Kaser", "Owen", ""]]}, {"id": "0805.4107", "submitter": "Nicolas Bonnel", "authors": "Nicolas Bonnel (VALORIA), Gilbas M\\'enier (VALORIA),\n  Pierre-Fran\\c{c}ois Marteau (VALORIA)", "title": "Spiral Walk on Triangular Meshes : Adaptive Replication in Data P2P\n  Networks", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.DB", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce a decentralized replication strategy for peer-to-peer file\nexchange based on exhaustive exploration of the neighborhood of any node in the\nnetwork. The replication scheme lets the replicas evenly populate the network\nmesh, while regulating the total number of replicas at the same time. This is\nachieved by self adaptation to entering or leaving of nodes. Exhaustive\nexploration is achieved by a spiral walk algorithm that generates a number of\nmessages linearly proportional to the number of visited nodes. It requires a\ndedicated topology (a triangular mesh on a closed surface). We introduce\nprotocols for node connection and departure that maintain the triangular mesh\nat low computational and bandwidth cost. Search efficiency is increased using a\nmechanism based on dynamically allocated super peers. We conclude with a\ndiscussion on experimental validation results.\n", "versions": [{"version": "v1", "created": "Tue, 27 May 2008 12:49:55 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Bonnel", "Nicolas", "", "VALORIA"], ["M\u00e9nier", "Gilbas", "", "VALORIA"], ["Marteau", "Pierre-Fran\u00e7ois", "", "VALORIA"]]}, {"id": "0805.4134", "submitter": "Spyros Sioutas SS", "authors": "V.Chrissikopoulos, G.Papaloukopoulos, E.Sakkopoulos, S. Sioutas", "title": "Design and Implementation Aspects of a novel Java P2P Simulator with GUI", "comments": "8 Pages, 7 figures, This article was accepted for presentation in the\n  IEEE Panhellenic Conference in Informatics (PCI 2008),\n  http://www.aegean.gr/PCI2008", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.DB cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Peer-to-peer networks consist of thousands or millions of nodes that might\njoin and leave arbitrarily. The evaluation of new protocols in real\nenvironments is many times practically impossible, especially at design and\ntesting stages. The purpose of this paper is to describe the implementation\naspects of a new Java based P2P simulator that has been developed to support\nscalability in the evaluation of such P2P dynamic environments. Evolving the\nfunctionality presented by previous solutions, we provide a friendly graphical\nuser interface through which the high-level theoretic researcher/designer of a\nP2P system can easily construct an overlay with the desirable number of nodes\nand evaluate its operations using a number of key distributions. Furthermore,\nthe simulator has built-in ability to produce statistics about the distributed\nstructure. Emphasis was given to the parametrical configuration of the\nsimulator. As a result the developed tool can be utilized in the simulation and\nevaluation procedures of a variety of different protocols, with only few\nchanges in the Java code.\n", "versions": [{"version": "v1", "created": "Tue, 27 May 2008 14:36:20 GMT"}], "update_date": "2008-12-18", "authors_parsed": [["Chrissikopoulos", "V.", ""], ["Papaloukopoulos", "G.", ""], ["Sakkopoulos", "E.", ""], ["Sioutas", "S.", ""]]}]