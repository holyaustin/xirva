[{"id": "0708.0361", "submitter": "Grigoriev Evgeniy", "authors": "Evgeniy Grigoriev", "title": "Why the relational data model can be considered as a formal basis for\n  group operations in object-oriented systems", "comments": "10 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB", "license": null, "abstract": "  Relational data model defines a specification of a type \"relation\". However,\nits simplicity does not mean that the system implementing this model must\noperate with structures having the same simplicity. We consider two principles\nallowing create a system which combines object-oriented paradigm (OOP) and\nrelational data model (RDM) in one framework. The first principle -- \"complex\ndata in encapsulated domains\" -- is well known from The Third Manifesto by Date\nand Darwen. The second principle --\"data complexity in names\"-- is the basis\nfor a system where data are described as complex objects and uniquely\nrepresented as a set of relations. Names of these relations and names of their\nattributes are combinations of names entered in specifications of the complex\nobjects. Below, we consider the main properties of such a system.\n", "versions": [{"version": "v1", "created": "Thu, 2 Aug 2007 15:24:29 GMT"}, {"version": "v2", "created": "Fri, 3 Aug 2007 06:11:33 GMT"}, {"version": "v3", "created": "Sun, 5 Aug 2007 22:38:53 GMT"}, {"version": "v4", "created": "Tue, 7 Aug 2007 21:39:14 GMT"}, {"version": "v5", "created": "Thu, 9 Aug 2007 04:56:59 GMT"}, {"version": "v6", "created": "Thu, 9 Aug 2007 22:15:20 GMT"}, {"version": "v7", "created": "Wed, 5 Sep 2007 20:18:51 GMT"}], "update_date": "2007-09-05", "authors_parsed": [["Grigoriev", "Evgeniy", ""]]}, {"id": "0708.2076", "submitter": "Loreto Bravo", "authors": "Loreto Bravo, James Cheney and Irini Fundulaki", "title": "Repairing Inconsistent XML Write-Access Control Policies", "comments": "25 pages. To appear in Proceedings of DBPL 2007", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB", "license": null, "abstract": "  XML access control policies involving updates may contain security flaws,\nhere called inconsistencies, in which a forbidden operation may be simulated by\nperforming a sequence of allowed operations. This paper investigates the\nproblem of deciding whether a policy is consistent, and if not, how its\ninconsistencies can be repaired. We consider policies expressed in terms of\nannotated DTDs defining which operations are allowed or denied for the XML\ntrees that are instances of the DTD. We show that consistency is decidable in\nPTIME for such policies and that consistent partial policies can be extended to\nunique \"least-privilege\" consistent total policies. We also consider repair\nproblems based on deleting privileges to restore consistency, show that finding\nminimal repairs is NP-complete, and give heuristics for finding repairs.\n", "versions": [{"version": "v1", "created": "Wed, 15 Aug 2007 18:31:48 GMT"}], "update_date": "2007-08-16", "authors_parsed": [["Bravo", "Loreto", ""], ["Cheney", "James", ""], ["Fundulaki", "Irini", ""]]}, {"id": "0708.2173", "submitter": "James Cheney", "authors": "James Cheney, Amal Ahmed, and Umut Acar", "title": "Provenance as Dependency Analysis", "comments": "Long version of paper in 2007 Symposium on Database Programming\n  Languages; revised November 2009", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Provenance is information recording the source, derivation, or history of\nsome information. Provenance tracking has been studied in a variety of\nsettings; however, although many design points have been explored, the\nmathematical or semantic foundations of data provenance have received\ncomparatively little attention. In this paper, we argue that dependency\nanalysis techniques familiar from program analysis and program slicing provide\na formal foundation for forms of provenance that are intended to show how (part\nof) the output of a query depends on (parts of) its input. We introduce a\nsemantic characterization of such dependency provenance, show that this form of\nprovenance is not computable, and provide dynamic and static approximation\ntechniques.\n", "versions": [{"version": "v1", "created": "Thu, 16 Aug 2007 11:11:43 GMT"}, {"version": "v2", "created": "Tue, 22 Dec 2009 15:25:13 GMT"}], "update_date": "2009-12-22", "authors_parsed": [["Cheney", "James", ""], ["Ahmed", "Amal", ""], ["Acar", "Umut", ""]]}, {"id": "0708.2717", "submitter": "Alejandro Vaisman Prof.", "authors": "Leticia Gomez, Bart Kuijpers, Alejandro Vaisman", "title": "Aggregation Languages for Moving Object and Places of Interest Data", "comments": "15 pages, 5 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DB", "license": null, "abstract": "  We address aggregate queries over GIS data and moving object data, where\nnon-spatial data are stored in a data warehouse. We propose a formal data model\nand query language to express complex aggregate queries. Next, we study the\ncompression of trajectory data, produced by moving objects, using the notions\nof stops and moves. We show that stops and moves are expressible in our query\nlanguage and we consider a fragment of this language, consisting of regular\nexpressions to talk about temporally ordered sequences of stops and moves. This\nfragment can be used to efficiently express data mining and pattern matching\ntasks over trajectory data.\n", "versions": [{"version": "v1", "created": "Mon, 20 Aug 2007 20:08:53 GMT"}], "update_date": "2007-08-22", "authors_parsed": [["Gomez", "Leticia", ""], ["Kuijpers", "Bart", ""], ["Vaisman", "Alejandro", ""]]}, {"id": "0708.3259", "submitter": "Rasmus Pagh", "authors": "Philip Bille, Anna Pagh, Rasmus Pagh", "title": "Fast evaluation of union-intersection expressions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.DB cs.IR", "license": null, "abstract": "  We show how to represent sets in a linear space data structure such that\nexpressions involving unions and intersections of sets can be computed in a\nworst-case efficient way. This problem has applications in e.g. information\nretrieval and database systems. We mainly consider the RAM model of\ncomputation, and sets of machine words, but also state our results in the I/O\nmodel. On a RAM with word size $w$, a special case of our result is that the\nintersection of $m$ (preprocessed) sets, containing $n$ elements in total, can\nbe computed in expected time $O(n (\\log w)^2 / w + km)$, where $k$ is the\nnumber of elements in the intersection. If the first of the two terms\ndominates, this is a factor $w^{1-o(1)}$ faster than the standard solution of\nmerging sorted lists. We show a cell probe lower bound of time $\\Omega(n/(w m\n\\log m)+ (1-\\tfrac{\\log k}{w}) k)$, meaning that our upper bound is nearly\noptimal for small $m$. Our algorithm uses a novel combination of approximate\nset representations and word-level parallelism.\n", "versions": [{"version": "v1", "created": "Thu, 23 Aug 2007 22:23:04 GMT"}], "update_date": "2007-08-27", "authors_parsed": [["Bille", "Philip", ""], ["Pagh", "Anna", ""], ["Pagh", "Rasmus", ""]]}]