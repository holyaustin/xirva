[{"id": "1302.0432", "submitter": "Eric Polizzi", "authors": "Ping Tak Peter Tang, Eric Polizzi", "title": "FEAST as a Subspace Iteration Eigensolver Accelerated by Approximate\n  Spectral Projection", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NA cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The calculation of a segment of eigenvalues and their corresponding\neigenvectors of a Hermitian matrix or matrix pencil has many applications. A\nnew density-matrix-based algorithm has been proposed recently and a software\npackage FEAST has been developed. The density-matrix approach allows FEAST's\nimplementation to exploit a key strength of modern computer architectures,\nnamely, multiple levels of parallelism. Consequently, the software package has\nbeen well received, especially in the electronic structure community.\nNevertheless, theoretical analysis of FEAST has lagged. For instance, the FEAST\nalgorithm has not been proven to converge. This paper offers a detailed\nnumerical analysis of FEAST. In particular, we show that the FEAST algorithm\ncan be understood as an accelerated subspace iteration algorithm in conjunction\nwith the Rayleigh-Ritz procedure. The novelty of FEAST lies in its accelerator\nwhich is a rational matrix function that approximates the spectral projector\nonto the eigenspace in question. Analysis of the numerical nature of this\napproximate spectral projector and the resulting subspaces generated in the\nFEAST algorithm establishes the algorithm's convergence. This paper shows that\nFEAST is resilient against rounding errors and establishes properties that can\nbe leveraged to enhance the algorithm's robustness. Finally, we propose an\nextension of FEAST to handle non-Hermitian problems and suggest some future\nresearch directions.\n", "versions": [{"version": "v1", "created": "Sat, 2 Feb 2013 22:30:20 GMT"}, {"version": "v2", "created": "Wed, 6 Feb 2013 14:55:05 GMT"}, {"version": "v3", "created": "Thu, 12 Sep 2013 18:41:02 GMT"}, {"version": "v4", "created": "Mon, 20 Jan 2014 02:18:26 GMT"}], "update_date": "2014-01-21", "authors_parsed": [["Tang", "Ping Tak Peter", ""], ["Polizzi", "Eric", ""]]}, {"id": "1302.1737", "submitter": "Damien Pous", "authors": "Damien Pous (LIP)", "title": "Kleene Algebra with Tests and Coq Tools for While Programs", "comments": "16+3 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.MS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a Coq library about Kleene algebra with tests, including a proof\nof their completeness over the appropriate notion of languages, a decision\nprocedure for their equational theory, and tools for exploiting hypotheses of a\nparticular shape in such a theory. Kleene algebra with tests make it possible\nto represent if-then-else statements and while loops in most imperative\nprogramming languages. They were actually introduced by Kozen as an alternative\nto propositional Hoare logic. We show how to exploit the corresponding Coq\ntools in the context of program verification by proving equivalences of while\nprograms, correctness of some standard compiler optimisations, Hoare rules for\npartial correctness, and a particularly challenging equivalence of flowchart\nschemes.\n", "versions": [{"version": "v1", "created": "Thu, 7 Feb 2013 13:15:45 GMT"}], "update_date": "2013-02-08", "authors_parsed": [["Pous", "Damien", "", "LIP"]]}, {"id": "1302.2738", "submitter": "Jaros{\\l}aw Miszczak", "authors": "J.A. Miszczak, M. Wahl", "title": "RandFile package for Mathematica for accessing file-based sources of\n  randomness", "comments": "16 pages, 4 figures, 3 tables, improved version of the software\n  available from http://www.iitis.pl/~miszczak/rand_file/", "journal-ref": null, "doi": null, "report-no": null, "categories": "physics.comp-ph cs.MS physics.data-an quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a package for Mathematica computer algebra system which allows the\nexploitation of local files as sources of random data. We provide the\ndescription of the package and illustrate its usage by showing some examples.\nWe also compare the provided functionality with alternative sources of\nrandomness, namely a built-in pseudo-random generator and the package for\naccessing hardware true random number generators.\n", "versions": [{"version": "v1", "created": "Tue, 12 Feb 2013 09:38:46 GMT"}, {"version": "v2", "created": "Sun, 15 Mar 2015 10:03:45 GMT"}], "update_date": "2015-03-17", "authors_parsed": [["Miszczak", "J. A.", ""], ["Wahl", "M.", ""]]}, {"id": "1302.3894", "submitter": "Simon Funke Mr", "authors": "S. W. Funke and P. E. Farrell", "title": "A framework for automated PDE-constrained optimisation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A generic framework for the solution of PDE-constrained optimisation problems\nbased on the FEniCS system is presented. Its main features are an intuitive\nmathematical interface, a high degree of automation, and an efficient\nimplementation of the generated adjoint model. The framework is based upon the\nextension of a domain-specific language for variational problems to cleanly\nexpress complex optimisation problems in a compact, high-level syntax. For\nexample, optimisation problems constrained by the time-dependent Navier-Stokes\nequations can be written in tens of lines of code. Based on this high-level\nrepresentation, the framework derives the associated adjoint equations in the\nsame domain-specific language, and uses the FEniCS code generation technology\nto emit parallel optimised low-level C++ code for the solution of the forward\nand adjoint systems. The functional and gradient information so computed is\nthen passed to the optimisation algorithm to update the parameter values. This\napproach works both for steady-state as well as transient, and for linear as\nwell as nonlinear governing PDEs and a wide range of functionals and control\nparameters. We demonstrate the applicability and efficiency of this approach on\nclassical textbook optimisation problems and advanced examples.\n", "versions": [{"version": "v1", "created": "Fri, 15 Feb 2013 21:30:51 GMT"}], "update_date": "2013-02-19", "authors_parsed": [["Funke", "S. W.", ""], ["Farrell", "P. E.", ""]]}, {"id": "1302.4332", "submitter": "Paolo Bientinesi", "authors": "Lucas Beyer (1), Paolo Bientinesi (1), ((1) AICES, RWTH Aachen)", "title": "Streaming Data from HDD to GPUs for Sustained Peak Performance", "comments": null, "journal-ref": null, "doi": null, "report-no": "AICES-2013/02-1", "categories": "cs.DC cs.CE cs.MS q-bio.GN", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the context of the genome-wide association studies (GWAS), one has to\nsolve long sequences of generalized least-squares problems; such a task has two\nlimiting factors: execution time --often in the range of days or weeks-- and\ndata management --data sets in the order of Terabytes. We present an algorithm\nthat obviates both issues. By pipelining the computation, and thanks to a\nsophisticated transfer strategy, we stream data from hard disk to main memory\nto GPUs and achieve sustained peak performance; with respect to a\nhighly-optimized CPU implementation, our algorithm shows a speedup of 2.6x.\nMoreover, the approach lends itself to multiple GPUs and attains almost perfect\nscalability. When using 4 GPUs, we observe speedups of 9x over the\naforementioned implementation, and 488x over a widespread biology library.\n", "versions": [{"version": "v1", "created": "Mon, 18 Feb 2013 16:03:08 GMT"}], "update_date": "2013-05-02", "authors_parsed": [["Beyer", "Lucas", "", "AICES, RWTH Aachen"], ["Bientinesi", "Paolo", "", "AICES, RWTH Aachen"]]}, {"id": "1302.5133", "submitter": "Mohammed El-Dosuky", "authors": "A. S. Tolba, M. Z. Rashad, M. A. El-Dosuky", "title": "Q#, a quantum computation package for the .NET platform", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.ET cs.MS cs.PL quant-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Quantum computing is a promising approach of computation that is based on\nequations from Quantum Mechanics. A simulator for quantum algorithms must be\ncapable of performing heavy mathematical matrix transforms. The design of the\nsimulator itself takes one of three forms: Quantum Turing Machine, Network\nModel or circuit model of connected gates or, Quantum Programming Language,\nyet, some simulators are hybrid. We studied previous simulators and then we\nadopt features from three simulators of different implementation languages,\ndifferent paradigms, and for different platforms. They are Quantum Computing\nLanguage (QCL), QUASI, and Quantum Optics Toolbox for Matlab 5. Our simulator\nfor quantum algorithms takes the form of a package or a programming library for\nQuantum computing, with a case study showing the ability of using it in the\ncircuit model. The .NET is a promising platform for computing. VB.NET is an\neasy, high productive programming language with the full power and\nfunctionality provided by the .NET framework. It is highly readable, writeable,\nand flexible language, compared to another language such as C#.NET in many\naspects. We adopted VB.NET although its shortage in built-in mathematical\ncomplex and matrix operations, compared to Matlab. For implementation, we first\nbuilt a mathematical core of matrix operations. Then, we built a quantum core\nwhich contains: basic qubits and register operations, basic 1D, 2D, and 3D\nquantum gates, and multi-view visualization of the quantum state, then a window\nfor demos to show you how to use and get the most of the package.\n", "versions": [{"version": "v1", "created": "Wed, 20 Feb 2013 21:37:43 GMT"}], "update_date": "2013-02-25", "authors_parsed": [["Tolba", "A. S.", ""], ["Rashad", "M. Z.", ""], ["El-Dosuky", "M. A.", ""]]}, {"id": "1302.5674", "submitter": "Albert Heinle", "authors": "Albert Heinle and Viktor Levandovskyy", "title": "Factorization of Z-homogeneous polynomials in the First (q)-Weyl Algebra", "comments": "26 pages, Singular implementation, 2 algorithms, 1 figure, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SC cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present algorithms to factorize weighted homogeneous elements in the first\npolynomial Weyl algebra and $q$-Weyl algebra, which are both viewed as a\n$\\mathbb{Z}$-graded rings. We show, that factorization of homogeneous\npolynomials can be almost completely reduced to commutative univariate\nfactorization over the same base field with some additional uncomplicated\ncombinatorial steps. This allows to deduce the complexity of our algorithms in\ndetail. Furthermore, we will show for homogeneous polynomials that\nirreducibility in the polynomial first Weyl algebra also implies irreducibility\nin the rational one, which is of interest for practical reasons. We report on\nour implementation in the computer algebra system \\textsc{Singular}. It\noutperforms for homogeneous polynomials currently available implementations\ndealing with factorization in the first Weyl algebra both in speed and elegancy\nof the results.\n", "versions": [{"version": "v1", "created": "Sun, 20 Jan 2013 18:37:47 GMT"}, {"version": "v2", "created": "Mon, 8 Dec 2014 20:52:14 GMT"}, {"version": "v3", "created": "Thu, 18 Feb 2016 16:04:15 GMT"}], "update_date": "2016-02-19", "authors_parsed": [["Heinle", "Albert", ""], ["Levandovskyy", "Viktor", ""]]}]