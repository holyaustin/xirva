[{"id": "2008.01990", "submitter": "Shengguo Li", "authors": "Xia Liao, Shengguo Li, Yutong Lu and Jose E. Roman", "title": "A parallel structured divide-and-conquer algorithm for symmetric\n  tridiagonal eigenvalue problems", "comments": "17 pages, 9 figures", "journal-ref": "IEEE Transactions on Parallel and Distributed Systems 32 (2021)\n  367-378", "doi": "10.1109/TPDS.2020.3019471", "report-no": null, "categories": "cs.MS cs.DC", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  In this paper, a parallel structured divide-and-conquer (PSDC) eigensolver is\nproposed for symmetric tridiagonal matrices based on ScaLAPACK and a parallel\nstructured matrix multiplication algorithm, called PSMMA. Computing the\neigenvectors via matrix-matrix multiplications is the most computationally\nexpensive part of the divide-and-conquer algorithm, and one of the matrices\ninvolved in such multiplications is a rank-structured Cauchy-like matrix. By\nexploiting this particular property, PSMMA constructs the local matrices by\nusing generators of Cauchy-like matrices without any communication, and further\nreduces the computation costs by using a structured low-rank approximation\nalgorithm. Thus, both the communication and computation costs are reduced.\nExperimental results show that both PSMMA and PSDC are highly scalable and\nscale to 4096 processes at least. PSDC has better scalability than PHDC that\nwas proposed in [J. Comput. Appl. Math. 344 (2018) 512--520] and only scaled to\n300 processes for the same matrices. Comparing with \\texttt{PDSTEDC} in\nScaLAPACK, PSDC is always faster and achieves $1.4$x--$1.6$x speedup for some\nmatrices with few deflations. PSDC is also comparable with ELPA, with PSDC\nbeing faster than ELPA when using few processes and a little slower when using\nmany processes.\n", "versions": [{"version": "v1", "created": "Wed, 5 Aug 2020 08:23:36 GMT"}, {"version": "v2", "created": "Sat, 28 Nov 2020 15:09:22 GMT"}], "update_date": "2020-12-24", "authors_parsed": [["Liao", "Xia", ""], ["Li", "Shengguo", ""], ["Lu", "Yutong", ""], ["Roman", "Jose E.", ""]]}, {"id": "2008.04175", "submitter": "Jonas Rauber", "authors": "Jonas Rauber, Matthias Bethge, Wieland Brendel", "title": "EagerPy: Writing Code That Works Natively with PyTorch, TensorFlow, JAX,\n  and NumPy", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.MS stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  EagerPy is a Python framework that lets you write code that automatically\nworks natively with PyTorch, TensorFlow, JAX, and NumPy. Library developers no\nlonger need to choose between supporting just one of these frameworks or\nreimplementing the library for each framework and dealing with code\nduplication. Users of such libraries can more easily switch frameworks without\nbeing locked in by a specific 3rd party library. Beyond multi-framework\nsupport, EagerPy also brings comprehensive type annotations and consistent\nsupport for method chaining to any framework. The latest documentation is\navailable online at https://eagerpy.jonasrauber.de and the code can be found on\nGitHub at https://github.com/jonasrauber/eagerpy.\n", "versions": [{"version": "v1", "created": "Mon, 10 Aug 2020 14:57:41 GMT"}], "update_date": "2020-08-11", "authors_parsed": [["Rauber", "Jonas", ""], ["Bethge", "Matthias", ""], ["Brendel", "Wieland", ""]]}, {"id": "2008.04447", "submitter": "Jed Duersch", "authors": "Jed A. Duersch and Ming Gu", "title": "Randomized Projection for Rank-Revealing Matrix Factorizations and\n  Low-Rank Approximations", "comments": "Revised from Randomized QR with Column Pivoting for publication in\n  SIGEST", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS math.SP", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Rank-revealing matrix decompositions provide an essential tool in spectral\nanalysis of matrices, including the Singular Value Decomposition (SVD) and\nrelated low-rank approximation techniques. QR with Column Pivoting (QRCP) is\nusually suitable for these purposes, but it can be much slower than the\nunpivoted QR algorithm. For large matrices, the difference in performance is\ndue to increased communication between the processor and slow memory, which\nQRCP needs in order to choose pivots during decomposition. Our main algorithm,\nRandomized QR with Column Pivoting (RQRCP), uses randomized projection to make\npivot decisions from a much smaller sample matrix, which we can construct to\nreside in a faster level of memory than the original matrix. This technique may\nbe understood as trading vastly reduced communication for a controlled increase\nin uncertainty during the decision process. For rank-revealing purposes, the\nselection mechanism in RQRCP produces results that are the same quality as the\nstandard algorithm, but with performance near that of unpivoted QR (often an\norder of magnitude faster for large matrices). We also propose two formulas\nthat facilitate further performance improvements. The first efficiently updates\nsample matrices to avoid computing new randomized projections. The second\navoids large trailing updates during the decomposition in truncated low-rank\napproximations. Our truncated version of RQRCP also provides a key initial step\nin our truncated SVD approximation, TUXV. These advances open up a new\nperformance domain for large matrix factorizations that will support efficient\nproblem-solving techniques for challenging applications in science,\nengineering, and data analysis.\n", "versions": [{"version": "v1", "created": "Mon, 10 Aug 2020 23:02:28 GMT"}], "update_date": "2020-08-12", "authors_parsed": [["Duersch", "Jed A.", ""], ["Gu", "Ming", ""]]}, {"id": "2008.05172", "submitter": "Jens Hahne", "authors": "Jens Hahne, Stephanie Friedhoff, Matthias Bolten", "title": "PyMGRIT: A Python Package for the parallel-in-time method MGRIT", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we introduce the Python framework PyMGRIT, which implements\nthe multigrid-reduction-in-time (MGRIT) algorithm for solving the (non-)linear\nsystems arising from the discretization of time-dependent problems. The MGRIT\nalgorithm is a reduction-based iterative method that allows parallel-in-time\nsimulations, i. e., calculating multiple time steps simultaneously in a\nsimulation, by using a time-grid hierarchy. The PyMGRIT framework features many\ndifferent variants of the MGRIT algorithm, ranging from different multigrid\ncycle types and relaxation schemes, as well as various coarsening strategies,\nincluding time-only and space-time coarsening, to using different time\nintegrators on different levels in the multigrid hierachy. PyMGRIT allows\nserial runs for prototyping and testing of new approaches, as well as parallel\nruns using the Message Passing Interface (MPI). Here, we describe the\nimplementation of the MGRIT algorithm in PyMGRIT and present the usage from\nboth user and developer point of views. Three examples illustrate different\naspects of the package, including pure time parallelism as well as space-time\nparallelism by coupling PyMGRIT with PETSc or Firedrake, which enable spatial\nparallelism through MPI.\n", "versions": [{"version": "v1", "created": "Wed, 12 Aug 2020 08:38:07 GMT"}], "update_date": "2020-08-13", "authors_parsed": [["Hahne", "Jens", ""], ["Friedhoff", "Stephanie", ""], ["Bolten", "Matthias", ""]]}, {"id": "2008.06992", "submitter": "Anjali Sandip", "authors": "Anjali Sandip", "title": "Elmer FEM-Dakota: A unified open-source computational framework for\n  electromagnetics and data analytics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "physics.comp-ph cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Open-source electromagnetic design software, Elmer FEM, was interfaced with\ndata analytics toolkit, Dakota. Furthermore, the coupled software was validated\nagainst a benchmark test. The interface developed provides a unified\nopen-source computational framework for electromagnetics and data analytics.\nIts key features include uncertainty quantification, surrogate modelling and\nparameter studies. This framework enables a richer understanding of model\npredictions to better design electric machines in a time sensitive manner.\n", "versions": [{"version": "v1", "created": "Sun, 16 Aug 2020 20:37:28 GMT"}, {"version": "v2", "created": "Tue, 29 Dec 2020 03:46:58 GMT"}], "update_date": "2021-01-01", "authors_parsed": [["Sandip", "Anjali", ""]]}, {"id": "2008.08042", "submitter": "Andrew J. Landahl", "authors": "Benjamin C. A. Morrison, Andrew J. Landahl, Daniel S. Lobser, Kenneth\n  M. Rudinger, Antonio E. Russo, Jay W. Van Der Wall, Peter Maunz", "title": "Just another quantum assembly language (Jaqal)", "comments": "Accepted by the IEEE International Conference on Quantum Computing\n  and Engineering, Oct. 12-16, 2020. Contains overlaps with the formal Jaqal\n  language specification in arXiv:2003.09382, but expands significantly on the\n  rationales behind the language choices made", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Quantum Scientific Computing Open User Testbed (QSCOUT) is a trapped-ion\nquantum computer testbed realized at Sandia National Laboratories on behalf of\nthe Department of Energy's Office of Science and its Advanced Scientific\nComputing (ASCR) program. Here we describe Jaqal, for Just another quantum\nassembly language, the programming language we invented to specify programs\nexecuted on QSCOUT. Jaqal is useful beyond QSCOUT---it can support mutliple\nhardware targets because it offloads gate names and their pulse-sequence\ndefinitions to external files. We describe the capabilities of the Jaqal\nlanguage, our approach in designing it, and the reasons for its creation. To\nlearn more about QSCOUT, Jaqal, or JaqalPaq, the metaprogramming Python package\nwe developed for Jaqal, please visit https://qscout.sandia.gov,\nhttps://gitlab.com/jaqal, or send an e-mail to qscout@sandia.gov.\n", "versions": [{"version": "v1", "created": "Tue, 18 Aug 2020 17:10:00 GMT"}], "update_date": "2020-08-19", "authors_parsed": [["Morrison", "Benjamin C. A.", ""], ["Landahl", "Andrew J.", ""], ["Lobser", "Daniel S.", ""], ["Rudinger", "Kenneth M.", ""], ["Russo", "Antonio E.", ""], ["Van Der Wall", "Jay W.", ""], ["Maunz", "Peter", ""]]}, {"id": "2008.08478", "submitter": "Yuhsiang Tsai", "authors": "Yuhsiang Mike Tsai, Terry Cojean, Hartwig Anzt", "title": "Evaluating the Performance of NVIDIA's A100 Ampere GPU for Sparse Linear\n  Algebra Computations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.PF", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  GPU accelerators have become an important backbone for scientific high\nperformance computing, and the performance advances obtained from adopting new\nGPU hardware are significant. In this paper we take a first look at NVIDIA's\nnewest server line GPU, the A100 architecture part of the Ampere generation.\nSpecifically, we assess its performance for sparse linear algebra operations\nthat form the backbone of many scientific applications and assess the\nperformance improvements over its predecessor.\n", "versions": [{"version": "v1", "created": "Wed, 19 Aug 2020 14:38:07 GMT"}], "update_date": "2020-08-20", "authors_parsed": [["Tsai", "Yuhsiang Mike", ""], ["Cojean", "Terry", ""], ["Anzt", "Hartwig", ""]]}, {"id": "2008.11799", "submitter": "Robert Haase", "authors": "Daniela Vorkel and Robert Haase", "title": "GPU-accelerating ImageJ Macro image processing workflows using CLIJ", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC q-bio.QM", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  This chapter introduces GPU-accelerated image processing in ImageJ/FIJI. The\nreader is expected to have some pre-existing knowledge of ImageJ Macro\nprogramming. Core concepts such as variables, for-loops, and functions are\nessential. The chapter provides basic guidelines for improved performance in\ntypical image processing workflows. We present in a step-by-step tutorial how\nto translate a pre-existing ImageJ macro into a GPU-accelerated macro.\n", "versions": [{"version": "v1", "created": "Wed, 26 Aug 2020 20:38:31 GMT"}], "update_date": "2020-08-28", "authors_parsed": [["Vorkel", "Daniela", ""], ["Haase", "Robert", ""]]}, {"id": "2008.12256", "submitter": "Leonid Sokolinsky", "authors": "Leonid B. Sokolinsky", "title": "BSF-skeleton: A Template for Parallelization of Iterative Numerical\n  Algorithms on Cluster Computing Systems", "comments": "Submitted to MethodsX", "journal-ref": "MethodsX, 2021", "doi": "10.1016/j.mex.2021.101437", "report-no": null, "categories": "cs.DC cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This article describes a method for creating applications for cluster\ncomputing systems using the parallel BSF skeleton based on the original BSF\n(Bulk Synchronous Farm) model of parallel computations developed by the author\nearlier. This model uses the master/slave paradigm. The main advantage of the\nBSF model is that it allows to estimate the scalability of a parallel algorithm\nbefore its implementation. Another important feature of the BSF model is the\nrepresentation of problem data in the form of lists that greatly simplifies the\nlogic of building applications. The BSF skeleton is designed for creating\nparallel programs in C++ using the MPI library. The scope of the BSF skeleton\nis iterative numerical algorithms of high computational complexity. The BSF\nskeleton has the following distinctive features. - The BSF-skeleton completely\nencapsulates all aspects that are associated with parallelizing a program. -\nThe BSF skeleton allows error-free compilation at all stages of application\ndevelopment. - The BSF skeleton supports OpenMP programming model and\nworkflows.\n", "versions": [{"version": "v1", "created": "Sat, 22 Aug 2020 15:58:24 GMT"}, {"version": "v2", "created": "Wed, 23 Dec 2020 06:34:12 GMT"}, {"version": "v3", "created": "Fri, 4 Jun 2021 14:05:06 GMT"}], "update_date": "2021-07-06", "authors_parsed": [["Sokolinsky", "Leonid B.", ""]]}, {"id": "2008.12863", "submitter": "Dominique Orban", "authors": "Alexis Montoison and Dominique Orban", "title": "TriCG and TriMR: Two Iterative Methods for Symmetric Quasi-Definite\n  Systems", "comments": "24 pages, 12 figures", "journal-ref": null, "doi": "10.13140/RG.2.2.12344.16645", "report-no": "G-2020-41", "categories": "math.NA cs.MS cs.NA math.OC", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  We introduce iterative methods named TriCG and TriMR for solving symmetric\nquasi-definite systems based on the orthogonal tridiagonalization process\nproposed by Saunders, Simon and Yip in 1988. TriCG and TriMR are tantamount to\npreconditioned Block-CG and Block-MINRES with two right-hand sides in which the\ntwo approximate solutions are summed at each iteration, but require less\nstorage and work per iteration. We evaluate the performance of TriCG and TriMR\non linear systems generated from the SuiteSparse Matrix Collection and from\ndiscretized and stablized Stokes equations. We compare TriCG and TriMR with\nSYMMLQ and MINRES, the recommended Krylov methods for symmetric and indefinite\nsystems. In all our experiments, TriCG and TriMR terminate earlier than SYMMLQ\nand MINRES on a residual-based stopping condition with an improvement of up to\n50% in terms of number of iterations. They also terminate more reliably than\nBlock-CG and Block-MINRES. Experiments in quadruple and octuple precision\nsuggest that loss of orthogonality in the basis vectors is significantly less\npronounced in TriCG and TriMR than in Block-CG and Block-MINRES.\n", "versions": [{"version": "v1", "created": "Fri, 28 Aug 2020 22:08:01 GMT"}, {"version": "v2", "created": "Mon, 8 Feb 2021 23:53:13 GMT"}], "update_date": "2021-02-10", "authors_parsed": [["Montoison", "Alexis", ""], ["Orban", "Dominique", ""]]}]