[{"id": "1812.00904", "submitter": "Gyorgy Matyasfalvi", "authors": "Jonathan Eckstein and Gyorgy Matyasfalvi", "title": "Efficient Distributed-Memory Parallel Matrix-Vector Multiplication with\n  Wide or Tall Unstructured Sparse Matrices", "comments": "8 pages, IEEE format", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents an efficient technique for matrix-vector and\nvector-transpose-matrix multiplication in distributed-memory parallel computing\nenvironments, where the matrices are unstructured, sparse, and have a\nsubstantially larger number of columns than rows or vice versa. Our method\nallows for parallel I/O, does not require extensive preprocessing, and has the\nsame communication complexity as matrix-vector multiplies with column or row\npartitioning. Our implementation of the method uses MPI. We partition the\nmatrix by individual nonzero elements, rather than by row or column, and use an\n\"overlapped\" vector representation that is matched to the matrix. The transpose\nmultiplies use matrix-specific MPI communicators and reductions that we show\ncan be set up in an efficient manner. The proposed technique achieves a good\nwork per processor balance even if some of the columns are dense, while keeping\ncommunication costs relatively low.\n", "versions": [{"version": "v1", "created": "Mon, 3 Dec 2018 17:03:15 GMT"}], "update_date": "2018-12-04", "authors_parsed": [["Eckstein", "Jonathan", ""], ["Matyasfalvi", "Gyorgy", ""]]}, {"id": "1812.01219", "submitter": "Maurizio Tomasi", "authors": "Maurizio Tomasi, Mos\\`e Giordano", "title": "Towards new solutions for scientific computing: the case of Julia", "comments": "To appear in the Proceedings of ADASS2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "astro-ph.IM cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This year marks the consolidation of Julia (https://julialang.org/), a\nprogramming language designed for scientific computing, as the first stable\nversion (1.0) has been released, in August 2018. Among its main features,\nexpressiveness and high execution speeds are the most prominent: the\nperformance of Julia code is similar to statically compiled languages, yet\nJulia provides a nice interactive shell and fully supports Jupyter; moreover,\nit can transparently call external codes written in C, Fortran, and even Python\nand R without the need of wrappers. The usage of Julia in the astronomical\ncommunity is growing, and a GitHub organization named JuliaAstro takes care of\ncoordinating the development of packages. In this paper, we present the\nfeatures and shortcomings of this language and discuss its application in\nastronomy and astrophysics.\n", "versions": [{"version": "v1", "created": "Tue, 4 Dec 2018 05:07:20 GMT"}], "update_date": "2018-12-05", "authors_parsed": [["Tomasi", "Maurizio", ""], ["Giordano", "Mos\u00e8", ""]]}, {"id": "1812.03467", "submitter": "Philippe Toint", "authors": "S. Gratton, Ph. L. Toint", "title": "A note on solving nonlinear optimization problems in variable precision", "comments": "11 pages, 2 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NA cs.LG cs.MS math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This short note considers an efficient variant of the trust-region algorithm\nwith dynamic accuracy proposed Carter (1993) and Conn, Gould and Toint (2000)\nas a tool for very high-performance computing, an area where it is critical to\nallow multi-precision computations for keeping the energy dissipation under\ncontrol. Numerical experiments are presented indicating that the use of the\nconsidered method can bring substantial savings in objective function's and\ngradient's evaluation \"energy costs\" by efficiently exploiting multi-precision\ncomputations.\n", "versions": [{"version": "v1", "created": "Sun, 9 Dec 2018 12:16:33 GMT"}, {"version": "v2", "created": "Tue, 11 Dec 2018 13:32:09 GMT"}, {"version": "v3", "created": "Fri, 12 Apr 2019 18:49:20 GMT"}], "update_date": "2019-04-16", "authors_parsed": [["Gratton", "S.", ""], ["Toint", "Ph. L.", ""]]}, {"id": "1812.03770", "submitter": "Pierre Vandenhove", "authors": "Pierre Vandenhove", "title": "Functional Design of Computation Graph", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Representing the control flow of a computer program as a computation graph\ncan bring many benefits in a broad variety of domains where performance is\ncritical. This technique is a core component of most major numerical libraries\n(TensorFlow, PyTorch, Theano, MXNet,...) and is successfully used to speed up\nand optimise many computationally-intensive tasks. However, different design\nchoices in each of these libraries lead to noticeable differences in efficiency\nand in the way an end user writes efficient code. In this report, we detail the\nimplementation and features of the computation graph support in OCaml's\nnumerical library Owl, a recent entry in the world of scientific computing.\n", "versions": [{"version": "v1", "created": "Mon, 10 Dec 2018 12:52:03 GMT"}], "update_date": "2018-12-11", "authors_parsed": [["Vandenhove", "Pierre", ""]]}, {"id": "1812.04074", "submitter": "Akshay Agrawal", "authors": "Akshay Agrawal, Steven Diamond, Stephen Boyd", "title": "Disciplined Geometric Programming", "comments": "Fix typos: p2, changed \"g_i log-log concave\" to \"g_i log-log affine\";\n  p6, max of log-log convex functions is log-log convex, not concave", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.OC cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce log-log convex programs, which are optimization problems with\npositive variables that become convex when the variables, objective functions,\nand constraint functions are replaced with their logs, which we refer to as a\nlog-log transformation. This class of problems generalizes traditional\ngeometric programming and generalized geometric programming, and it includes\ninteresting problems involving nonnegative matrices. We give examples of\nlog-log convex functions, some well-known and some less so, and we develop an\nanalog of disciplined convex programming, which we call disciplined geometric\nprogramming. Disciplined geometric programming is a subclass of log-log convex\nprogramming generated by a composition rule and a set of functions with known\ncurvature under the log-log transformation. Finally, we describe an\nimplementation of disciplined geometric programming as a reduction in CVXPY\n1.0.\n", "versions": [{"version": "v1", "created": "Mon, 10 Dec 2018 20:43:14 GMT"}, {"version": "v2", "created": "Wed, 20 Mar 2019 23:50:14 GMT"}], "update_date": "2019-03-22", "authors_parsed": [["Agrawal", "Akshay", ""], ["Diamond", "Steven", ""], ["Boyd", "Stephen", ""]]}, {"id": "1812.06160", "submitter": "Joshua Booth", "authors": "Joshua Dennis Booth, Gregory Bolet", "title": "Javelin: A Scalable Implementation for Sparse Incomplete LU\n  Factorization", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we present a new scalable incomplete LU factorization framework\ncalled Javelin to be used as a preconditioner for solving sparse linear systems\nwith iterative methods. Javelin allows for improved parallel factorization on\nshared-memory many-core systems by packaging the coefficient matrix into a\nformat that allows for high performance sparse matrix-vector multiplication and\nsparse triangular solves with minimal overheads. The framework achieves these\ngoals by using a collection of traditional permutations, point-to-point thread\nsynchronizations, tasking, and segmented prefix scans in a conventional\ncompressed sparse row format. Moreover, this framework stresses the importance\nof co-designing dependent tasks, such as sparse factorization and triangular\nsolves, on highly-threaded architectures. Using these changes, traditional\nfill-in and drop tolerance methods can be used, while still being able to have\nobserved speedups of up to ~42x on 68 Intel Knights Landing cores and ~12x on\n14 Intel Haswell cores.\n", "versions": [{"version": "v1", "created": "Thu, 13 Dec 2018 15:20:41 GMT"}, {"version": "v2", "created": "Fri, 25 Jan 2019 13:52:26 GMT"}, {"version": "v3", "created": "Thu, 2 May 2019 22:34:10 GMT"}], "update_date": "2019-05-06", "authors_parsed": [["Booth", "Joshua Dennis", ""], ["Bolet", "Gregory", ""]]}, {"id": "1812.07388", "submitter": "Michael Clerx", "authors": "Michael Clerx, Martin Robinson, Ben Lambert, Chon Lok Lei, Sanmitra\n  Ghosh, Gary R. Mirams, David J. Gavaghan", "title": "Probabilistic Inference on Noisy Time Series (PINTS)", "comments": null, "journal-ref": null, "doi": "10.5334/jors.252", "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Time series models are ubiquitous in science, arising in any situation where\nresearchers seek to understand how a system's behaviour changes over time. A\nkey problem in time series modelling is \\emph{inference}; determining\nproperties of the underlying system based on observed time series. For both\nstatistical and mechanistic models, inference involves finding parameter\nvalues, or distributions of parameters values, for which model outputs are\nconsistent with observations. A wide variety of inference techniques are\navailable and different approaches are suitable for different classes of\nproblems. This variety presents a challenge for researchers, who may not have\nthe resources or expertise to implement and experiment with these methods.\nPINTS (Probabilistic Inference on Noisy Time Series -\nhttps://github.com/pints-team/pints is an open-source (BSD 3-clause license)\nPython library that provides researchers with a broad suite of non-linear\noptimisation and sampling methods. It allows users to wrap a model and data in\na transparent and straightforward interface, which can then be used with custom\nor pre-defined error measures for optimisation, or with likelihood functions\nfor Bayesian inference or maximum-likelihood estimation. Derivative-free\noptimisation algorithms - which work without harder-to-obtain gradient\ninformation - are included, as well as inference algorithms such as adaptive\nMarkov chain Monte Carlo and nested sampling which estimate distributions over\nparameter values. By making these statistical techniques available in an open\nand easy-to-use framework, PINTS brings the power of modern statistical\ntechniques to a wider scientific audience.\n", "versions": [{"version": "v1", "created": "Tue, 18 Dec 2018 14:36:17 GMT"}], "update_date": "2020-01-13", "authors_parsed": [["Clerx", "Michael", ""], ["Robinson", "Martin", ""], ["Lambert", "Ben", ""], ["Lei", "Chon Lok", ""], ["Ghosh", "Sanmitra", ""], ["Mirams", "Gary R.", ""], ["Gavaghan", "David J.", ""]]}, {"id": "1812.07908", "submitter": "Emmanuel Soubies", "authors": "Emmanuel Soubies, Ferr\\'eol Soulez, Michael T. McCann, Thanh-an Pham,\n  Laur\\`ene Donati, Thomas Debarre, Daniel Sage, and Michael Unser", "title": "Pocket Guide to Solve Inverse Problems with GlobalBioIm", "comments": null, "journal-ref": null, "doi": "10.1088/1361-6420/ab2ae9", "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  GlobalBioIm is an open-source MATLAB library for solving inverse problems.\nThe library capitalizes on the strong commonalities between forward models to\nstandardize the resolution of a wide range of imaging inverse problems. Endowed\nwith an operator-algebra mechanism, GlobalBioIm allows one to easily solve\ninverse problems by combining elementary modules in a lego-like fashion. This\nuser-friendly toolbox gives access to cutting-edge reconstruction algorithms,\nwhile its high modularity makes it easily extensible to new modalities and\nnovel reconstruction methods. We expect GlobalBioIm to respond to the needs of\nimaging scientists looking for reliable and easy-to-use computational tools for\nsolving their inverse problems. In this paper, we present in detail the\nstructure and main features of the library. We also illustrate its flexibility\nwith examples from multichannel deconvolution microscopy.\n", "versions": [{"version": "v1", "created": "Wed, 19 Dec 2018 12:25:06 GMT"}, {"version": "v2", "created": "Mon, 7 Jan 2019 12:17:36 GMT"}], "update_date": "2019-06-25", "authors_parsed": [["Soubies", "Emmanuel", ""], ["Soulez", "Ferr\u00e9ol", ""], ["McCann", "Michael T.", ""], ["Pham", "Thanh-an", ""], ["Donati", "Laur\u00e8ne", ""], ["Debarre", "Thomas", ""], ["Sage", "Daniel", ""], ["Unser", "Michael", ""]]}, {"id": "1812.08558", "submitter": "Uwe K\\\"ocher", "authors": "Uwe K\\\"ocher, Marius Paul Bruchh\\\"auser, Markus Bause", "title": "Efficient and scalable data structures and algorithms for goal-oriented\n  adaptivity of space-time FEM codes", "comments": null, "journal-ref": null, "doi": "10.1016/j.softx.2019.100239", "report-no": null, "categories": "cs.MS cs.NA math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The cost- and memory-efficient numerical simulation of coupled volume-based\nmulti-physics problems like flow, transport, wave propagation and others\nremains a challenging task with finite element method (FEM) approaches.\nGoal-oriented space and time adaptive methods derived from the dual weighted\nresidual (DWR) method appear to be a shiny key technology to generate optimal\nspace-time meshes to minimise costs. Current implementations for challenging\nproblems of numerical screening tools including the DWR technology broadly\nsuffer in their extensibility to other problems, in high memory consumption or\nin missing system solver technologies. This work contributes to the efficient\nembedding of DWR space-time adaptive methods into numerical screening tools for\nchallenging problems of physically relevance with a new approach of flexible\ndata structures and algorithms on them, a modularised and complete\nimplementation as well as illustrative examples to show the performance and\nefficiency.\n", "versions": [{"version": "v1", "created": "Thu, 20 Dec 2018 13:43:20 GMT"}], "update_date": "2019-05-01", "authors_parsed": [["K\u00f6cher", "Uwe", ""], ["Bruchh\u00e4user", "Marius Paul", ""], ["Bause", "Markus", ""]]}, {"id": "1812.09167", "submitter": "Mark Fingerhuth", "authors": "Mark Fingerhuth, Tom\\'a\\v{s} Babej, Peter Wittek", "title": "Open source software in quantum computing", "comments": "22 pages, 4 figures", "journal-ref": "Fingerhuth M, Babej T, Wittek P (2018) Open source software in\n  quantum computing. PLoS ONE 13(12): e0208561", "doi": "10.1371/journal.pone.0208561", "report-no": null, "categories": "quant-ph cs.MS cs.PL", "license": "http://creativecommons.org/publicdomain/zero/1.0/", "abstract": "  Open source software is becoming crucial in the design and testing of quantum\nalgorithms. Many of the tools are backed by major commercial vendors with the\ngoal to make it easier to develop quantum software: this mirrors how\nwell-funded open machine learning frameworks enabled the development of complex\nmodels and their execution on equally complex hardware. We review a wide range\nof open source software for quantum computing, covering all stages of the\nquantum toolchain from quantum hardware interfaces through quantum compilers to\nimplementations of quantum algorithms, as well as all quantum computing\nparadigms, including quantum annealing, and discrete and continuous-variable\ngate-model quantum computing. The evaluation of each project covers\ncharacteristics such as documentation, licence, the choice of programming\nlanguage, compliance with norms of software engineering, and the culture of the\nproject. We find that while the diversity of projects is mesmerizing, only a\nfew attract external developers and even many commercially backed frameworks\nhave shortcomings in software engineering. Based on these observations, we\nhighlight the best practices that could foster a more active community around\nquantum computing software that welcomes newcomers to the field, but also\nensures high-quality, well-documented code.\n", "versions": [{"version": "v1", "created": "Fri, 21 Dec 2018 14:56:18 GMT"}], "update_date": "2018-12-24", "authors_parsed": [["Fingerhuth", "Mark", ""], ["Babej", "Tom\u00e1\u0161", ""], ["Wittek", "Peter", ""]]}, {"id": "1812.11668", "submitter": "EPTCS", "authors": "Timothy Bourke (Inria Paris & \\'Ecole normale sup\\'erieure, PSL\n  University), Jun Inoue (National Institute of Advanced Industrial Science and\n  Technology), Marc Pouzet (Sorbonne Universit\\'es, UPMC Univ Paris 06 &\n  \\'Ecole normale sup\\'erieure, PSL University & Inria Paris)", "title": "Sundials/ML: Connecting OCaml to the Sundials Numeric Solvers", "comments": "In Proceedings ML/OCAML 2016, arXiv:1812.10891", "journal-ref": "EPTCS 285, 2018, pp. 101-130", "doi": "10.4204/EPTCS.285.4", "report-no": null, "categories": "cs.PL cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper describes the design and implementation of a comprehensive OCaml\ninterface to the Sundials library of numeric solvers for ordinary differential\nequations, differential algebraic equations, and non-linear equations. The\ninterface provides a convenient and memory-safe alternative to using Sundials\ndirectly from C and facilitates application development by integrating with\nhigher-level language features, like garbage-collected memory management,\nalgebraic data types, and exceptions. Our benchmark results suggest that the\ninterface overhead is acceptable: the standard examples are rarely twice as\nslow in OCaml than in C, and often less than 50% slower. The challenges in\ninterfacing with Sundials are to efficiently and safely share data structures\nbetween OCaml and C, to support multiple implementations of vector operations\nand linear solvers through a common interface, and to manage calls and error\nsignalling to and from OCaml. We explain how we overcame these difficulties\nusing a combination of standard techniques such as phantom types and\npolymorphic variants, and carefully crafted data representations.\n", "versions": [{"version": "v1", "created": "Mon, 31 Dec 2018 02:10:13 GMT"}], "update_date": "2019-01-07", "authors_parsed": [["Bourke", "Timothy", "", "Inria Paris & \u00c9cole normale sup\u00e9rieure, PSL\n  University"], ["Inoue", "Jun", "", "National Institute of Advanced Industrial Science and\n  Technology"], ["Pouzet", "Marc", "", "Sorbonne Universit\u00e9s, UPMC Univ Paris 06 &\n  \u00c9cole normale sup\u00e9rieure, PSL University & Inria Paris"]]}]