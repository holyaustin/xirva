[{"id": "1304.0864", "submitter": "David Monniaux", "authors": "Alexis Fouilh\\'e (VERIMAG - IMAG), David Monniaux (VERIMAG - IMAG),\n  Micha\\\"el P\\'erin (VERIMAG - IMAG)", "title": "Efficient Generation of Correctness Certificates for the Abstract Domain\n  of Polyhedra", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Polyhedra form an established abstract domain for inferring runtime\nproperties of programs using abstract interpretation. Computations on them need\nto be certified for the whole static analysis results to be trusted. In this\nwork, we look at how far we can get down the road of a posteriori verification\nto lower the overhead of certification of the abstract domain of polyhedra. We\ndemonstrate methods for making the cost of inclusion certificate generation\nnegligible. From a performance point of view, our single-representation,\nconstraints-based implementation compares with state-of-the-art\nimplementations.\n", "versions": [{"version": "v1", "created": "Wed, 3 Apr 2013 08:01:42 GMT"}], "update_date": "2013-04-04", "authors_parsed": [["Fouilh\u00e9", "Alexis", "", "VERIMAG - IMAG"], ["Monniaux", "David", "", "VERIMAG - IMAG"], ["P\u00e9rin", "Micha\u00ebl", "", "VERIMAG - IMAG"]]}, {"id": "1304.0878", "submitter": "Ludovic Courtes", "authors": "Ludovic Court\\`es (INRIA Bordeaux - Sud-Ouest)", "title": "C Language Extensions for Hybrid CPU/GPU Programming with StarPU", "comments": null, "journal-ref": "N&deg; RR-8278 (2013)", "doi": null, "report-no": "RR-8278", "categories": "cs.MS cs.CE cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Modern platforms used for high-performance computing (HPC) include machines\nwith both general-purpose CPUs, and \"accelerators\", often in the form of\ngraphical processing units (GPUs). StarPU is a C library to exploit such\nplatforms. It provides users with ways to define \"tasks\" to be executed on CPUs\nor GPUs, along with the dependencies among them, and by automatically\nscheduling them over all the available processing units. In doing so, it also\nrelieves programmers from the need to know the underlying architecture details:\nit adapts to the available CPUs and GPUs, and automatically transfers data\nbetween main memory and GPUs as needed. While StarPU's approach is successful\nat addressing run-time scheduling issues, being a C library makes for a poor\nand error-prone programming interface. This paper presents an effort started in\n2011 to promote some of the concepts exported by the library as C language\nconstructs, by means of an extension of the GCC compiler suite. Our main\ncontribution is the design and implementation of language extensions that map\nto StarPU's task programming paradigm. We argue that the proposed extensions\nmake it easier to get started with StarPU,eliminate errors that can occur when\nusing the C library, and help diagnose possible mistakes. We conclude on future\nwork.\n", "versions": [{"version": "v1", "created": "Wed, 3 Apr 2013 09:11:25 GMT"}, {"version": "v2", "created": "Wed, 10 Apr 2013 13:29:43 GMT"}], "update_date": "2013-04-11", "authors_parsed": [["Court\u00e8s", "Ludovic", "", "INRIA Bordeaux - Sud-Ouest"]]}, {"id": "1304.1356", "submitter": "Martin Mann", "authors": "Martin Mann, Heinz Ekker and Christoph Flamm", "title": "The Graph Grammar Library - a generic framework for chemical graph\n  rewrite systems", "comments": "Extended version of an abstract published in proceedings of the\n  International Conference on Model Transformation (ICMT) 2013", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.CE q-bio.BM q-bio.MN", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Graph rewrite systems are powerful tools to model and study complex problems\nin various fields of research. Their successful application to chemical\nreaction modelling on a molecular level was shown but no appropriate and simple\nsystem is available at the moment.\n  The presented Graph Grammar Library (GGL) implements a generic Double Push\nOut approach for general graph rewrite systems. The framework focuses on a high\nlevel of modularity as well as high performance, using state-of-the-art\nalgorithms and data structures, and comes with extensive documentation. The\nlarge GGL chemistry module enables extensive and detailed studies of chemical\nsystems. It well meets the requirements and abilities envisioned by Yadav et\nal. (2004) for such chemical rewrite systems. Here, molecules are represented\nas undirected labeled graphs while chemical reactions are described by\naccording graph grammar rules. Beside the graph transformation, the GGL offers\nadvanced cheminformatics algorithms for instance to estimate energies\nofmolecules or aromaticity perception. These features are illustrated using a\nset of reactions from polyketide chemistry a huge class of natural compounds of\nmedical relevance.\n  The graph grammar based simulation of chemical reactions offered by the GGL\nis a powerful tool for extensive cheminformatics studies on a molecular level.\nThe GGL already provides rewrite rules for all enzymes listed in the KEGG\nLIGAND database is freely available at\nhttp://www.tbi.univie.ac.at/software/GGL/.\n", "versions": [{"version": "v1", "created": "Thu, 4 Apr 2013 13:06:34 GMT"}], "update_date": "2013-04-05", "authors_parsed": [["Mann", "Martin", ""], ["Ekker", "Heinz", ""], ["Flamm", "Christoph", ""]]}, {"id": "1304.1864", "submitter": "Paolo Bientinesi", "authors": "Matthias Petschow (1), Enrique Quintana-Orti (2), Paolo Bientinesi\n  (1), ((1) AICES, RWTH Aachen, (2) Universidad Jaume I)", "title": "Improved Accuracy and Parallelism for MRRR-based Eigensolvers -- A Mixed\n  Precision Approach", "comments": null, "journal-ref": null, "doi": null, "report-no": "AICES-2013/04-1", "categories": "cs.NA cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The real symmetric tridiagonal eigenproblem is of outstanding importance in\nnumerical computations; it arises frequently as part of eigensolvers for\nstandard and generalized dense Hermitian eigenproblems that are based on a\nreduction to tridiagonal form. For its solution, the algorithm of Multiple\nRelatively Robust Representations (MRRR) is among the fastest methods. Although\nfast, the solvers based on MRRR do not deliver the same accuracy as competing\nmethods like Divide & Conquer or the QR algorithm. In this paper, we\ndemonstrate that the use of mixed precisions leads to improved accuracy of\nMRRR-based eigensolvers with limited or no performance penalty. As a result, we\nobtain eigensolvers that are not only equally or more accurate than the best\navailable methods, but also -in most circumstances- faster and more scalable\nthan the competition.\n", "versions": [{"version": "v1", "created": "Sat, 6 Apr 2013 08:14:25 GMT"}, {"version": "v2", "created": "Wed, 17 Apr 2013 08:40:47 GMT"}, {"version": "v3", "created": "Sat, 22 Jun 2013 10:08:46 GMT"}], "update_date": "2013-06-25", "authors_parsed": [["Petschow", "Matthias", "", "AICES, RWTH Aachen"], ["Quintana-Orti", "Enrique", "", "Universidad Jaume I"], ["Bientinesi", "Paolo", "", "AICES, RWTH Aachen"]]}, {"id": "1304.2272", "submitter": "Elmar Peise", "authors": "Elmar Peise (1), Diego Fabregat (1), Yurii Aulchenko (2), Paolo\n  Bientinesi (1) ((1) AICES, RWTH Aachen, (2) Institute of Cytology and\n  Genetics, Novosibirsk)", "title": "Algorithms for Large-scale Whole Genome Association Analysis", "comments": null, "journal-ref": null, "doi": null, "report-no": "AICES-2013/04-2", "categories": "cs.CE cs.MS q-bio.GN", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In order to associate complex traits with genetic polymorphisms, genome-wide\nassociation studies process huge datasets involving tens of thousands of\nindividuals genotyped for millions of polymorphisms. When handling these\ndatasets, which exceed the main memory of contemporary computers, one faces two\ndistinct challenges: 1) Millions of polymorphisms come at the cost of hundreds\nof Gigabytes of genotype data, which can only be kept in secondary storage; 2)\nthe relatedness of the test population is represented by a covariance matrix,\nwhich, for large populations, can only fit in the combined main memory of a\ndistributed architecture. In this paper, we present solutions for both\nchallenges: The genotype data is streamed from and to secondary storage using a\ndouble buffering technique, while the covariance matrix is kept across the main\nmemory of a distributed memory system. We show that these methods sustain\nhigh-performance and allow the analysis of enormous dataset\n", "versions": [{"version": "v1", "created": "Mon, 8 Apr 2013 17:13:39 GMT"}], "update_date": "2013-05-02", "authors_parsed": [["Peise", "Elmar", ""], ["Fabregat", "Diego", ""], ["Aulchenko", "Yurii", ""], ["Bientinesi", "Paolo", ""]]}, {"id": "1304.5546", "submitter": "Andreas Kl\\\"ockner", "authors": "Andreas Kl\\\"ockner and Timothy Warburton and Jan S. Hesthaven", "title": "Solving Wave Equations on Unstructured Geometries", "comments": "GPU Computing Gems, edited by Wen-mei Hwu, Elsevier (2011), ISBN\n  9780123859631, Chapter 18", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Waves are all around us--be it in the form of sound, electromagnetic\nradiation, water waves, or earthquakes. Their study is an important basic tool\nacross engineering and science disciplines. Every wave solver serving the\ncomputational study of waves meets a trade-off of two figures of merit--its\ncomputational speed and its accuracy. Discontinuous Galerkin (DG) methods fall\non the high-accuracy end of this spectrum. Fortuitously, their computational\nstructure is so ideally suited to GPUs that they also achieve very high\ncomputational speeds. In other words, the use of DG methods on GPUs\nsignificantly lowers the cost of obtaining accurate solutions. This article\naims to give the reader an easy on-ramp to the use of this technology, based on\na sample implementation which demonstrates a highly accurate, GPU-capable,\nreal-time visualizing finite element solver in about 1500 lines of code.\n", "versions": [{"version": "v1", "created": "Fri, 19 Apr 2013 21:07:10 GMT"}], "update_date": "2013-04-23", "authors_parsed": [["Kl\u00f6ckner", "Andreas", ""], ["Warburton", "Timothy", ""], ["Hesthaven", "Jan S.", ""]]}, {"id": "1304.6782", "submitter": "Sou-Cheng Choi", "authors": "Sou-Cheng (Terrya) Choi", "title": "Minimal Residual Methods for Complex Symmetric, Skew Symmetric, and Skew\n  Hermitian Systems", "comments": "arXiv admin note: substantial text overlap with arXiv:1003.4042", "journal-ref": null, "doi": null, "report-no": "Argonne National Laboratory Technical Report ANL/MCS-P3028-0812", "categories": "cs.MS math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While there is no lack of efficient Krylov subspace solvers for Hermitian\nsystems, there are few for complex symmetric, skew symmetric, or skew Hermitian\nsystems, which are increasingly important in modern applications including\nquantum dynamics, electromagnetics, and power systems. For a large consistent\ncomplex symmetric system, one may apply a non-Hermitian Krylov subspace method\ndisregarding the symmetry of $A$, or a Hermitian Krylov solver on the\nequivalent normal equation or an augmented system twice the original dimension.\nThese have the disadvantages of increasing either memory, conditioning, or\ncomputational costs. An exception is a special version of QMR by Freund (1992),\nbut that may be affected by non-benign breakdowns unless look-ahead is\nimplemented; furthermore, it is designed for only consistent and nonsingular\nproblems. For skew symmetric systems, Greif and Varah (2009) adapted CG for\nnonsingular skew symmetric linear systems that are necessarily and\nrestrictively of even order.\n  We extend the symmetric and Hermitian algorithms MINRES and MINRES-QLP by\nChoi, Paige and Saunders (2011) to complex symmetric, skew symmetric, and skew\nHermitian systems. In particular, MINRES-QLP uses a rank-revealing QLP\ndecomposition of the tridiagonal matrix from a three-term recurrent\ncomplex-symmetric Lanczos process. Whether the systems are real or complex,\nsingular or invertible, compatible or inconsistent, MINRES-QLP computes the\nunique minimum-length, i.e., pseudoinverse, solutions. It is a significant\nextension of MINRES by Paige and Saunders (1975) with enhanced stability and\ncapability.\n", "versions": [{"version": "v1", "created": "Thu, 25 Apr 2013 01:21:48 GMT"}, {"version": "v2", "created": "Mon, 13 Jan 2014 19:45:12 GMT"}], "update_date": "2014-01-14", "authors_parsed": [["Sou-Cheng", "", "", "Terrya"], ["Choi", "", ""]]}, {"id": "1304.6899", "submitter": "Bal\\'azs Szalkai", "authors": "Bal\\'azs Szalkai", "title": "An implementation of the relational k-means algorithm", "comments": "8 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.CV cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A C# implementation of a generalized k-means variant called relational\nk-means is described here. Relational k-means is a generalization of the\nwell-known k-means clustering method which works for non-Euclidean scenarios as\nwell. The input is an arbitrary distance matrix, as opposed to the traditional\nk-means method, where the clustered objects need to be identified with vectors.\n", "versions": [{"version": "v1", "created": "Thu, 25 Apr 2013 12:59:31 GMT"}], "update_date": "2013-04-26", "authors_parsed": [["Szalkai", "Bal\u00e1zs", ""]]}, {"id": "1304.7049", "submitter": "Chetan Jhurani", "authors": "Chetan Jhurani", "title": "Subspace-preserving sparsification of matrices with minimal perturbation\n  to the near null-space. Part I: Basics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NA cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is the first of two papers to describe a matrix sparsification algorithm\nthat takes a general real or complex matrix as input and produces a sparse\noutput matrix of the same size. The non-zero entries in the output are chosen\nto minimize changes to the singular values and singular vectors corresponding\nto the near null-space of the input. The output matrix is constrained to\npreserve left and right null-spaces exactly. The sparsity pattern of the output\nmatrix is automatically determined or can be given as input.\n  If the input matrix belongs to a common matrix subspace, we prove that the\ncomputed sparse matrix belongs to the same subspace. This works without\nimposing explicit constraints pertaining to the subspace. This property holds\nfor the subspaces of Hermitian, complex-symmetric, Hamiltonian, circulant,\ncentrosymmetric, and persymmetric matrices, and for each of the skew\ncounterparts.\n  Applications of our method include computation of reusable sparse\npreconditioning matrices for reliable and efficient solution of high-order\nfinite element systems. The second paper in this series describes our\nopen-source implementation, and presents further technical details.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2013 01:43:09 GMT"}], "update_date": "2013-04-29", "authors_parsed": [["Jhurani", "Chetan", ""]]}, {"id": "1304.7050", "submitter": "Chetan Jhurani", "authors": "Chetan Jhurani", "title": "Subspace-preserving sparsification of matrices with minimal perturbation\n  to the near null-space. Part II: Approximation and Implementation", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NA cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is the second of two papers to describe a matrix sparsification\nalgorithm that takes a general real or complex matrix as input and produces a\nsparse output matrix of the same size. The first paper presented the original\nalgorithm, its features, and theoretical results.\n  Since the output of this sparsification algorithm is a matrix rather than a\nvector, it can be costly in memory and run-time if an implementation does not\nexploit the structural properties of the algorithm and the matrix. Here we show\nhow to modify the original algorithm to increase its efficiency. This is\npossible by computing an approximation to the exact result. We introduce extra\nconstraints that are automatically determined based on the input matrix. This\naddition reduces the number of unknown degrees of freedom but still preserves\nmany matrix subspaces. We also describe our open-source library that implements\nthis sparsification algorithm and has interfaces in C++, C, and MATLAB.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2013 01:44:09 GMT"}], "update_date": "2013-04-29", "authors_parsed": [["Jhurani", "Chetan", ""]]}, {"id": "1304.7053", "submitter": "Chetan Jhurani", "authors": "Chetan Jhurani, Paul Mullowney", "title": "A GEMM interface and implementation on NVIDIA GPUs for multiple small\n  matrices", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an interface and an implementation of the General Matrix Multiply\n(GEMM) routine for multiple small matrices processed simultaneously on NVIDIA\ngraphics processing units (GPUs). We focus on matrix sizes under 16. The\nimplementation can be easily extended to larger sizes. For single precision\nmatrices, our implementation is 30% to 600% faster than the batched cuBLAS\nimplementation distributed in the CUDA Toolkit 5.0 on NVIDIA Tesla K20c. For\nexample, we obtain 104 GFlop/s and 216 GFlop/s when multiplying 100,000\nindependent matrix pairs of size 10 and 16, respectively. Similar improvement\nin performance is obtained for other sizes, in single and double precision for\nreal and complex types, and when the number of matrices is smaller. Apart from\nour implementation, our different function interface also plays an important\nrole in the improved performance. Applications of this software include Finite\nElement computation on GPUs.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2013 02:22:14 GMT"}], "update_date": "2013-04-29", "authors_parsed": [["Jhurani", "Chetan", ""], ["Mullowney", "Paul", ""]]}, {"id": "1304.7054", "submitter": "Chetan Jhurani", "authors": "Chetan Jhurani", "title": "Batched Kronecker product for 2-D matrices and 3-D arrays on NVIDIA GPUs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe an interface and an implementation for performing Kronecker\nproduct actions on NVIDIA GPUs for multiple small 2-D matrices and 3-D arrays\nprocessed in parallel as a batch. This method is suited to cases where the\nKronecker product component matrices are identical but the operands in a\nmatrix-free application vary in the batch. Any batched GEMM (General Matrix\nMultiply) implementation, for example ours [1] or the one in cuBLAS, can also\nbe used for performing batched Kronecker products on GPUs. However, the\nspecialized implementation presented here is faster and uses less memory.\nPartly this is because a simple GEMM based approach would require extra copies\nto and from main memory. We focus on matrix sizes less than or equal to 16,\nsince these are the typical polynomial degrees in Finite Elements, but the\nimplementation can be easily extended for other sizes. We obtain 143 and 285\nGFlop/s for single precision real when processing matrices of size 10 and 16,\nrespectively on NVIDIA Tesla K20c using CUDA 5.0. The corresponding speeds for\n3-D array Kronecker products are 126 and 268 GFlop/s, respectively. Double\nprecision is easily supported using the C++ template mechanism.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2013 02:22:25 GMT"}], "update_date": "2013-04-29", "authors_parsed": [["Jhurani", "Chetan", ""]]}, {"id": "1304.7123", "submitter": "EPTCS", "authors": "Ruben Gamboa (University of Wyoming, USA), Jared Davis (Centaur\n  Technology, USA)", "title": "Proceedings International Workshop on the ACL2 Theorem Prover and its\n  Applications", "comments": null, "journal-ref": "EPTCS 114, 2013", "doi": "10.4204/EPTCS.114", "report-no": null, "categories": "cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This volume contains the proceedings of the Eleventh International Workshop\non the ACL2 Theorem Prover and its Applications, held on May 30 and 31, 2013,\nin Laramie, Wyoming, USA.\n  ACL2 is an industrial-strength automated reasoning system, the latest in the\nBoyer-Moore family of theorem provers. The ACL2 workshop is the major technical\nforum for users of the ACL2 theorem proving system to present research on the\nprover and its applications.\n  This year's workshop received 15 submissions covering a wide range of\napplications, libraries, prover enhancements, interfaces, and experience\nreports. 11 papers were selected by the program committee for presentation at\nthe workshop.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2013 10:59:21 GMT"}], "update_date": "2013-04-29", "authors_parsed": [["Gamboa", "Ruben", "", "University of Wyoming, USA"], ["Davis", "Jared", "", "Centaur\n  Technology, USA"]]}, {"id": "1304.7223", "submitter": "Matthew England Dr", "authors": "Matthew England and Russell Bradford and James H. Davenport and David\n  Wilson", "title": "Understanding Branch Cuts of Expressions", "comments": "To appear in: Proceedings of Conferences on Intelligent Computer\n  Mathematics (CICM '13) - Mathematical Knowledge Management (MKM) strand", "journal-ref": "Intelligent Computer Mathematics. Berlin: Springer, pp. 136-151.\n  (Lecture Notes in Computer Science; 7961), 2013", "doi": "10.1007/978-3-642-39320-4_9", "report-no": null, "categories": "cs.MS cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We assume some standard choices for the branch cuts of a group of functions\nand consider the problem of then calculating the branch cuts of expressions\ninvolving those functions. Typical examples include the addition formulae for\ninverse trigonometric functions. Understanding these cuts is essential for\nworking with the single-valued counterparts, the common approach to encoding\nmulti-valued functions in computer algebra systems. While the defining choices\nare usually simple (typically portions of either the real or imaginary axes)\nthe cuts induced by the expression may be surprisingly complicated. We have\nmade explicit and implemented techniques for calculating the cuts in the\ncomputer algebra programme Maple. We discuss the issues raised, classifying the\ndifferent cuts produced. The techniques have been gathered in the BranchCuts\npackage, along with tools for visualising the cuts. The package is included in\nMaple 17 as part of the FunctionAdvisor tool.\n", "versions": [{"version": "v1", "created": "Fri, 26 Apr 2013 16:46:48 GMT"}, {"version": "v2", "created": "Mon, 6 May 2013 08:56:47 GMT"}, {"version": "v3", "created": "Fri, 24 May 2013 09:08:09 GMT"}], "update_date": "2013-07-10", "authors_parsed": [["England", "Matthew", ""], ["Bradford", "Russell", ""], ["Davenport", "James H.", ""], ["Wilson", "David", ""]]}, {"id": "1304.7855", "submitter": "EPTCS", "authors": "Matt Kaufmann (University of Texas at Austin), J Strother Moore\n  (University of Texas at Austin)", "title": "Enhancements to ACL2 in Versions 5.0, 6.0, and 6.1", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 5-12", "doi": "10.4204/EPTCS.114.1", "report-no": null, "categories": "cs.MS cs.AI cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We report on highlights of the ACL2 enhancements introduced in ACL2 releases\nsince the 2011 ACL2 Workshop. Although many enhancements are critical for\nsoundness or robustness, we focus in this paper on those improvements that\ncould benefit users who are aware of them, but that might not be discovered in\neveryday practice.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:13:58 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Kaufmann", "Matt", "", "University of Texas at Austin"], ["Moore", "J Strother", "", "University of Texas at Austin"]]}, {"id": "1304.7861", "submitter": "EPTCS", "authors": "Jared Davis (Centaur Technology), Sol Swords (Centaur Technology)", "title": "Verified AIG Algorithms in ACL2", "comments": "In Proceedings ACL2 2013, arXiv:1304.7123", "journal-ref": "EPTCS 114, 2013, pp. 95-110", "doi": "10.4204/EPTCS.114.8", "report-no": null, "categories": "cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  And-Inverter Graphs (AIGs) are a popular way to represent Boolean functions\n(like circuits). AIG simplification algorithms can dramatically reduce an AIG,\nand play an important role in modern hardware verification tools like\nequivalence checkers. In practice, these tricky algorithms are implemented with\noptimized C or C++ routines with no guarantee of correctness. Meanwhile, many\ninteractive theorem provers can now employ SAT or SMT solvers to automatically\nsolve finite goals, but no theorem prover makes use of these advanced,\nAIG-based approaches.\n  We have developed two ways to represent AIGs within the ACL2 theorem prover.\nOne representation, Hons-AIGs, is especially convenient to use and reason\nabout. The other, Aignet, is the opposite; it is styled after modern AIG\npackages and allows for efficient algorithms. We have implemented functions for\nconverting between these representations, random vector simulation, conversion\nto CNF, etc., and developed reasoning strategies for verifying these\nalgorithms.\n  Aside from these contributions towards verifying AIG algorithms, this work\nhas an immediate, practical benefit for ACL2 users who are using GL to\nbit-blast finite ACL2 theorems: they can now optionally trust an off-the-shelf\nSAT solver to carry out the proof, instead of using the built-in BDD package.\nLooking to the future, it is a first step toward implementing verified AIG\nsimplification algorithms that might further improve GL performance.\n", "versions": [{"version": "v1", "created": "Tue, 30 Apr 2013 04:14:44 GMT"}], "update_date": "2013-05-01", "authors_parsed": [["Davis", "Jared", "", "Centaur Technology"], ["Swords", "Sol", "", "Centaur Technology"]]}]