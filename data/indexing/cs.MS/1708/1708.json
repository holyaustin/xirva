[{"id": "1708.00707", "submitter": "Henri Vuollekoski", "authors": "Jarno Lintusaari, Henri Vuollekoski, Antti Kangasr\\\"a\\\"asi\\\"o, Kusti\n  Skyt\\'en, Marko J\\\"arvenp\\\"a\\\"a, Pekka Marttinen, Michael U. Gutmann, Aki\n  Vehtari, Jukka Corander, and Samuel Kaski", "title": "ELFI: Engine for Likelihood-Free Inference", "comments": null, "journal-ref": "Journal of Machine Learning Research, 19(16):1-7, 2018.\n  http://jmlr.org/papers/v19/17-374.html", "doi": null, "report-no": null, "categories": "stat.ML cs.MS stat.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Engine for Likelihood-Free Inference (ELFI) is a Python software library for\nperforming likelihood-free inference (LFI). ELFI provides a convenient syntax\nfor arranging components in LFI, such as priors, simulators, summaries or\ndistances, to a network called ELFI graph. The components can be implemented in\na wide variety of languages. The stand-alone ELFI graph can be used with any of\nthe available inference methods without modifications. A central method\nimplemented in ELFI is Bayesian Optimization for Likelihood-Free Inference\n(BOLFI), which has recently been shown to accelerate likelihood-free inference\nup to several orders of magnitude by surrogate-modelling the distance. ELFI\nalso has an inbuilt support for output data storing for reuse and analysis, and\nsupports parallelization of computation from multiple cores up to a cluster\nenvironment. ELFI is designed to be extensible and provides interfaces for\nwidening its functionality. This makes the adding of new inference methods to\nELFI straightforward and automatically compatible with the inbuilt features.\n", "versions": [{"version": "v1", "created": "Wed, 2 Aug 2017 11:39:11 GMT"}, {"version": "v2", "created": "Fri, 25 May 2018 13:04:57 GMT"}, {"version": "v3", "created": "Thu, 5 Jul 2018 08:34:27 GMT"}], "update_date": "2018-10-15", "authors_parsed": [["Lintusaari", "Jarno", ""], ["Vuollekoski", "Henri", ""], ["Kangasr\u00e4\u00e4si\u00f6", "Antti", ""], ["Skyt\u00e9n", "Kusti", ""], ["J\u00e4rvenp\u00e4\u00e4", "Marko", ""], ["Marttinen", "Pekka", ""], ["Gutmann", "Michael U.", ""], ["Vehtari", "Aki", ""], ["Corander", "Jukka", ""], ["Kaski", "Samuel", ""]]}, {"id": "1708.01773", "submitter": "Santiago Badia Sb", "authors": "Santiago Badia, Alberto F. Mart\\'in and Javier Principe", "title": "FEMPAR: An object-oriented parallel finite element framework", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CE cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  FEMPAR is an open source object oriented Fortran200X scientific software\nlibrary for the high-performance scalable simulation of complex multiphysics\nproblems governed by partial differential equations at large scales, by\nexploiting state-of-the-art supercomputing resources. It is a highly\nmodularized, flexible, and extensible library, that provides a set of modules\nthat can be combined to carry out the different steps of the simulation\npipeline. FEMPAR includes a rich set of algorithms for the discretization step,\nnamely (arbitrary-order) grad, div, and curl-conforming finite element methods,\ndiscontinuous Galerkin methods, B-splines, and unfitted finite element\ntechniques on cut cells, combined with $h$-adaptivity. The linear solver module\nrelies on state-of-the-art bulk-asynchronous implementations of multilevel\ndomain decomposition solvers for the different discretization alternatives and\nblock-preconditioning techniques for multiphysics problems. FEMPAR is a\nframework that provides users with out-of-the-box state-of-the-art\ndiscretization techniques and highly scalable solvers for the simulation of\ncomplex applications, hiding the dramatic complexity of the underlying\nalgorithms. But it is also a framework for researchers that want to experience\nwith new algorithms and solvers, by providing a highly extensible framework. In\nthis work, the first one in a series of articles about FEMPAR, we provide a\ndetailed introduction to the software abstractions used in the discretization\nmodule and the related geometrical module. We also provide some ingredients\nabout the assembly of linear systems arising from finite element\ndiscretizations, but the software design of complex scalable multilevel solvers\nis postponed to a subsequent work.\n", "versions": [{"version": "v1", "created": "Sat, 5 Aug 2017 14:47:00 GMT"}, {"version": "v2", "created": "Tue, 8 Aug 2017 08:57:48 GMT"}, {"version": "v3", "created": "Tue, 19 Sep 2017 13:15:02 GMT"}], "update_date": "2017-09-20", "authors_parsed": [["Badia", "Santiago", ""], ["Mart\u00edn", "Alberto F.", ""], ["Principe", "Javier", ""]]}, {"id": "1708.01873", "submitter": "Oliver Serang", "authors": "Christian Knauth, Boran Adas, Daniel Whitfield, Xuesong Wang, Lydia\n  Ickler, Tim Conrad, Oliver Serang", "title": "Practically efficient methods for performing bit-reversed permutation in\n  C++11 on the x86-64 architecture", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The bit-reversed permutation is a famous task in signal processing and is key\nto efficient implementation of the fast Fourier transform. This paper presents\noptimized C++11 implementations of five extant methods for computing the\nbit-reversed permutation: Stockham auto-sort, naive bitwise swapping, swapping\nvia a table of reversed bytes, local pairwise swapping of bits, and swapping\nvia a cache-localized matrix buffer. Three new strategies for performing the\nbit-reversed permutation in C++11 are proposed: an inductive method using the\nbitwise XOR operation, a template-recursive closed form, and a cache-oblivious\ntemplate-recursive approach, which reduces the bit-reversed permutation to\nsmaller bit-reversed permutations and a square matrix transposition. These new\nmethods are compared to the extant approaches in terms of theoretical runtime,\nempirical compile time, and empirical runtime. The template-recursive\ncache-oblivious method is shown to be competitive with the fastest known\nmethod; however, we demonstrate that the cache-oblivious method can more\nreadily benefit from parallelization on multiple cores and on the GPU.\n", "versions": [{"version": "v1", "created": "Wed, 2 Aug 2017 19:12:50 GMT"}], "update_date": "2017-08-08", "authors_parsed": [["Knauth", "Christian", ""], ["Adas", "Boran", ""], ["Whitfield", "Daniel", ""], ["Wang", "Xuesong", ""], ["Ickler", "Lydia", ""], ["Conrad", "Tim", ""], ["Serang", "Oliver", ""]]}, {"id": "1708.03438", "submitter": "Alejandro Ortiz-Bernardin", "authors": "Alejandro Ortiz-Bernardin, Catalina Alvarez, Nancy Hitschfeld-Kahler,\n  Alessandro Russo, Rodrigo Silva-Valenzuela and Edgardo Olate-Sanzana", "title": "Veamy: an extensible object-oriented C++ library for the virtual element\n  method", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper summarizes the development of Veamy, an object-oriented C++\nlibrary for the virtual element method (VEM) on general polygonal meshes, whose\nmodular design is focused on its extensibility. The linear elastostatic and\nPoisson problems in two dimensions have been chosen as the starting stage for\nthe development of this library. The theory of the VEM, upon which Veamy is\nbuilt, is presented using a notation and a terminology that resemble the\nlanguage of the finite element method (FEM) in engineering analysis. Several\nexamples are provided to demonstrate the usage of Veamy, and in particular, one\nof them features the interaction between Veamy and the polygonal mesh generator\nPolyMesher. A computational performance comparison between VEM and FEM is also\nconducted. Veamy is free and open source software.\n", "versions": [{"version": "v1", "created": "Fri, 11 Aug 2017 05:39:36 GMT"}, {"version": "v2", "created": "Thu, 21 Sep 2017 20:07:42 GMT"}, {"version": "v3", "created": "Sat, 24 Feb 2018 17:49:06 GMT"}, {"version": "v4", "created": "Mon, 24 Dec 2018 01:02:58 GMT"}], "update_date": "2018-12-27", "authors_parsed": [["Ortiz-Bernardin", "Alejandro", ""], ["Alvarez", "Catalina", ""], ["Hitschfeld-Kahler", "Nancy", ""], ["Russo", "Alessandro", ""], ["Silva-Valenzuela", "Rodrigo", ""], ["Olate-Sanzana", "Edgardo", ""]]}, {"id": "1708.04021", "submitter": "Yuliya Boyarinova", "authors": "Ya. Kalinovsky and Yu. Boyarinova and A. Sukalo and Ya. Hitsko", "title": "The basic principles and the structure and algorithmically software of\n  computing by hypercomplex number", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In article the basic principles put in a basis of algorithmicallysoftware of\nhypercomplex number calculations, structure of a software, structure of\nfunctional subsystems are considered. The most important procedures included in\nsubsystems are considered, program listings and examples of their application\nare given.\n", "versions": [{"version": "v1", "created": "Mon, 14 Aug 2017 07:13:39 GMT"}], "update_date": "2017-08-15", "authors_parsed": [["Kalinovsky", "Ya.", ""], ["Boyarinova", "Yu.", ""], ["Sukalo", "A.", ""], ["Hitsko", "Ya.", ""]]}, {"id": "1708.04440", "submitter": "\\'Agoston R\\'oth", "authors": "\\'Agoston R\\'oth", "title": "An OpenGL and C++ based function library for curve and surface modeling\n  in a large class of extended Chebyshev spaces", "comments": "29 pages, 20 figures, 2 tables, additional references have been\n  included, some cross-references have been updated", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.GR math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose a platform-independent multi-threaded function library that\nprovides data structures to generate, differentiate and render both the\nordinary basis and the normalized B-basis of a user-specified extended\nChebyshev (EC) space that comprises the constants and can be identified with\nthe solution space of a constant-coefficient homogeneous linear differential\nequation defined on a sufficiently small interval. Using the obtained\nnormalized B-bases, our library can also generate, (partially) differentiate,\nmodify and visualize a large family of so-called B-curves and tensor product\nB-surfaces. Moreover, the library also implements methods that can be used to\nperform dimension elevation, to subdivide B-curves and B-surfaces by means of\nde Casteljau-like B-algorithms, and to generate basis transformations for the\nB-representation of arbitrary integral curves and surfaces that are described\nin traditional parametric form by means of the ordinary bases of the underlying\nEC spaces. Independently of the algebraic, exponential, trigonometric or mixed\ntype of the applied EC space, the proposed library is numerically stable and\nefficient up to a reasonable dimension number and may be useful for academics\nand engineers in the fields of Approximation Theory, Computer Aided Geometric\nDesign, Computer Graphics, Isogeometric and Numerical Analysis.\n", "versions": [{"version": "v1", "created": "Tue, 15 Aug 2017 09:09:48 GMT"}, {"version": "v2", "created": "Tue, 10 Jul 2018 11:51:36 GMT"}, {"version": "v3", "created": "Sun, 14 Oct 2018 08:14:09 GMT"}], "update_date": "2018-10-16", "authors_parsed": [["R\u00f3th", "\u00c1goston", ""]]}, {"id": "1708.04539", "submitter": "Mathias Jacquelin", "authors": "Mathias Jacquelin, Lin Lin, Chao Yang", "title": "PSelInv - A Distributed Memory Parallel Algorithm for Selected\n  Inversion: the non-symmetric Case", "comments": "arXiv admin note: text overlap with arXiv:1404.0447", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper generalizes the parallel selected inversion algorithm called\nPSelInv to sparse non- symmetric matrices. We assume a general sparse matrix A\nhas been decomposed as PAQ = LU on a distributed memory parallel machine, where\nL, U are lower and upper triangular matrices, and P, Q are permutation\nmatrices, respectively. The PSelInv method computes selected elements of A-1.\nThe selection is confined by the sparsity pattern of the matrix AT . Our\nalgorithm does not assume any symmetry properties of A, and our parallel\nimplementation is memory efficient, in the sense that the computed elements of\nA-T overwrites the sparse matrix L+U in situ. PSelInv involves a large number\nof collective data communication activities within different processor groups\nof various sizes. In order to minimize idle time and improve load balancing,\ntree-based asynchronous communication is used to coordinate all such collective\ncommunication. Numerical results demonstrate that PSelInv can scale efficiently\nto 6,400 cores for a variety of matrices.\n", "versions": [{"version": "v1", "created": "Mon, 14 Aug 2017 00:18:41 GMT"}], "update_date": "2017-08-16", "authors_parsed": [["Jacquelin", "Mathias", ""], ["Lin", "Lin", ""], ["Yang", "Chao", ""]]}, {"id": "1708.05279", "submitter": "Ryan Curtin", "authors": "Ryan R. Curtin, Marcus Edel", "title": "Designing and building the mlpack open-source machine learning library", "comments": "submitted to ICOPUST 2017", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.LG cs.SE", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  mlpack is an open-source C++ machine learning library with an emphasis on\nspeed and flexibility. Since its original inception in 2007, it has grown to be\na large project implementing a wide variety of machine learning algorithms,\nfrom standard techniques such as decision trees and logistic regression to\nmodern techniques such as deep neural networks as well as other\nrecently-published cutting-edge techniques not found in any other library.\nmlpack is quite fast, with benchmarks showing mlpack outperforming other\nlibraries' implementations of the same methods. mlpack has an active community,\nwith contributors from around the world---including some from PUST. This short\npaper describes the goals and design of mlpack, discusses how the open-source\ncommunity functions, and shows an example usage of mlpack for a simple data\nscience problem.\n", "versions": [{"version": "v1", "created": "Thu, 17 Aug 2017 13:59:48 GMT"}, {"version": "v2", "created": "Wed, 30 Aug 2017 15:41:17 GMT"}], "update_date": "2017-08-31", "authors_parsed": [["Curtin", "Ryan R.", ""], ["Edel", "Marcus", ""]]}, {"id": "1708.05788", "submitter": "Jonas Einarsson", "authors": "Jonas Einarsson", "title": "Computer Algebra for Microhydrodynamics", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "physics.flu-dyn cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  I describe a method for computer algebra that helps with laborious\ncalculations typically encountered in theoretical microhydrodynamics. The\nprogram mimics how humans calculate by matching patterns and making\nreplacements according to the rules of algebra and calculus. This note gives an\noverview and walks through an example, while the accompanying code repository\ncontains the implementation details, a tutorial, and more examples. The code\nrepository is attached as supplementary material to this note, and maintained\nat https://github.com/jeinarsson/matte\n", "versions": [{"version": "v1", "created": "Sat, 19 Aug 2017 00:43:04 GMT"}], "update_date": "2017-08-22", "authors_parsed": [["Einarsson", "Jonas", ""]]}, {"id": "1708.06290", "submitter": "Nela Bosner", "authors": "Nela Bosner, Zvonimir Bujanovi\\'c, Zlatko Drma\\v{c}", "title": "Parallel solver for shifted systems in a hybrid CPU-GPU framework", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper proposes a combination of a hybrid CPU--GPU and a pure GPU\nsoftware implementation of a direct algorithm for solving shifted linear\nsystems $(A - \\sigma I)X = B$ with large number of complex shifts $\\sigma$ and\nmultiple right-hand sides. Such problems often appear e.g. in control theory\nwhen evaluating the transfer function, or as a part of an algorithm performing\ninterpolatory model reduction, as well as when computing pseudospectra and\nstructured pseudospectra, or solving large linear systems of ordinary\ndifferential equations. The proposed algorithm first jointly reduces the\ngeneral full $n\\times n$ matrix $A$ and the $n\\times m$ full right-hand side\nmatrix $B$ to the controller Hessenberg canonical form that facilitates\nefficient solution: $A$ is transformed to a so-called $m$-Hessenberg form and\n$B$ is made upper-triangular. This is implemented as blocked highly parallel\nCPU--GPU hybrid algorithm; individual blocks are reduced by the CPU, and the\nnecessary updates of the rest of the matrix are split among the cores of the\nCPU and the GPU. To enhance parallelization, the reduction and the updates are\noverlapped. In the next phase, the reduced $m$-Hessenberg--triangular systems\nare solved entirely on the GPU, with shifts divided into batches. The benefits\nof such load distribution are demonstrated by numerical experiments. In\nparticular, we show that our proposed implementation provides an excellent\nbasis for efficient implementations of computational methods in systems and\ncontrol theory, from evaluation of transfer function to the interpolatory model\nreduction.\n", "versions": [{"version": "v1", "created": "Mon, 21 Aug 2017 15:39:14 GMT"}], "update_date": "2017-08-24", "authors_parsed": [["Bosner", "Nela", ""], ["Bujanovi\u0107", "Zvonimir", ""], ["Drma\u010d", "Zlatko", ""]]}, {"id": "1708.07481", "submitter": "Andrew Knyazev", "authors": "David Zhuzhunashvili and Andrew Knyazev", "title": "Preconditioned Spectral Clustering for Stochastic Block Partition\n  Streaming Graph Challenge", "comments": "6 pages. To appear in Proceedings of the 2017 IEEE High Performance\n  Extreme Computing Conference. Student Innovation Award Streaming Graph\n  Challenge: Stochastic Block Partition, see\n  http://graphchallenge.mit.edu/champions", "journal-ref": "2017 IEEE High Performance Extreme Computing Conference (HPEC),\n  Waltham, MA, USA, 2017, pp. 1-6", "doi": "10.1109/HPEC.2017.8091045", "report-no": null, "categories": "cs.MS cs.DC cs.DS stat.CO stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Locally Optimal Block Preconditioned Conjugate Gradient (LOBPCG) is\ndemonstrated to efficiently solve eigenvalue problems for graph Laplacians that\nappear in spectral clustering. For static graph partitioning, 10-20 iterations\nof LOBPCG without preconditioning result in ~10x error reduction, enough to\nachieve 100% correctness for all Challenge datasets with known truth\npartitions, e.g., for graphs with 5K/.1M (50K/1M) Vertices/Edges in 2 (7)\nseconds, compared to over 5,000 (30,000) seconds needed by the baseline Python\ncode. Our Python code 100% correctly determines 98 (160) clusters from the\nChallenge static graphs with 0.5M (2M) vertices in 270 (1,700) seconds using\n10GB (50GB) of memory. Our single-precision MATLAB code calculates the same\nclusters at half time and memory. For streaming graph partitioning, LOBPCG is\ninitiated with approximate eigenvectors of the graph Laplacian already computed\nfor the previous graph, in many cases reducing 2-3 times the number of required\nLOBPCG iterations, compared to the static case. Our spectral clustering is\ngeneric, i.e. assuming nothing specific of the block model or streaming, used\nto generate the graphs for the Challenge, in contrast to the base code.\nNevertheless, in 10-stage streaming comparison with the base code for the 5K\ngraph, the quality of our clusters is similar or better starting at stage 4 (7)\nfor emerging edging (snowballing) streaming, while the computations are over\n100-1000 faster.\n", "versions": [{"version": "v1", "created": "Mon, 21 Aug 2017 14:09:05 GMT"}], "update_date": "2017-11-09", "authors_parsed": [["Zhuzhunashvili", "David", ""], ["Knyazev", "Andrew", ""]]}, {"id": "1708.09707", "submitter": "Peter Zaspel", "authors": "Peter Zaspel", "title": "Algorithmic patterns for $\\mathcal{H}$-matrices on many-core processors", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.MS cs.NA math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work, we consider the reformulation of hierarchical ($\\mathcal{H}$)\nmatrix algorithms for many-core processors with a model implementation on\ngraphics processing units (GPUs). $\\mathcal{H}$ matrices approximate specific\ndense matrices, e.g., from discretized integral equations or kernel ridge\nregression, leading to log-linear time complexity in dense matrix-vector\nproducts. The parallelization of $\\mathcal{H}$ matrix operations on many-core\nprocessors is difficult due to the complex nature of the underlying algorithms.\nWhile previous algorithmic advances for many-core hardware focused on\naccelerating existing $\\mathcal{H}$ matrix CPU implementations by many-core\nprocessors, we here aim at totally relying on that processor type. As main\ncontribution, we introduce the necessary parallel algorithmic patterns allowing\nto map the full $\\mathcal{H}$ matrix construction and the fast matrix-vector\nproduct to many-core hardware. Here, crucial ingredients are space filling\ncurves, parallel tree traversal and batching of linear algebra operations. The\nresulting model GPU implementation hmglib is the, to the best of the authors\nknowledge, first entirely GPU-based Open Source $\\mathcal{H}$ matrix library of\nthis kind. We conclude this work by an in-depth performance analysis and a\ncomparative performance study against a standard $\\mathcal{H}$ matrix library,\nhighlighting profound speedups of our many-core parallel approach.\n", "versions": [{"version": "v1", "created": "Thu, 31 Aug 2017 13:50:42 GMT"}], "update_date": "2017-09-04", "authors_parsed": [["Zaspel", "Peter", ""]]}]