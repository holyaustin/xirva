[{"id": "1211.0582", "submitter": "Andreas Kl\\\"ockner", "authors": "Andreas Kl\\\"ockner and Timothy Warburton and Jan S. Hesthaven", "title": "High-Order Discontinuous Galerkin Methods by GPU Metaprogramming", "comments": "To appear as part of \"GPU Solutions to Multi-scale Problems in\n  Science and Engineering\", http://books.google.com/books?vid=9783642164040", "journal-ref": "ISBN 9783642164040, Springer, 2012", "doi": null, "report-no": null, "categories": "cs.MS math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Discontinuous Galerkin (DG) methods for the numerical solution of partial\ndifferential equations have enjoyed considerable success because they are both\nflexible and robust: They allow arbitrary unstructured geometries and easy\ncontrol of accuracy without compromising simulation stability. In a recent\npublication, we have shown that DG methods also adapt readily to execution on\nmodern, massively parallel graphics processors (GPUs). A number of qualities of\nthe method contribute to this suitability, reaching from locality of reference,\nthrough regularity of access patterns, to high arithmetic intensity. In this\narticle, we illuminate a few of the more practical aspects of bringing DG onto\na GPU, including the use of a Python-based metaprogramming infrastructure that\nwas created specifically to support DG, but has found many uses across all\ndisciplines of computational science.\n", "versions": [{"version": "v1", "created": "Fri, 2 Nov 2012 23:55:22 GMT"}], "update_date": "2012-11-06", "authors_parsed": [["Kl\u00f6ckner", "Andreas", ""], ["Warburton", "Timothy", ""], ["Hesthaven", "Jan S.", ""]]}, {"id": "1211.2075", "submitter": "Olga Lopez-Acevedo", "authors": "L. Leukkunen, T. Verho, O. Lopez-Acevedo", "title": "A multi-scale code for flexible hybrid simulations", "comments": null, "journal-ref": null, "doi": "10.1109/MCSE.2013.51", "report-no": null, "categories": "physics.comp-ph cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multi-scale computer simulations combine the computationally efficient\nclassical algorithms with more expensive but also more accurate ab-initio\nquantum mechanical algorithms. This work describes one implementation of\nmulti-scale computations using the Atomistic Simulation Environment (ASE). This\nimplementation can mix classical codes like LAMMPS and the Density Functional\nTheory-based GPAW. Any combination of codes linked via the ASE interface\nhowever can be mixed. We also introduce a framework to easily add classical\nforce fields calculators for ASE using LAMMPS, which also allows harnessing the\nfull performance of classical-only molecular dynamics. Our work makes it\npossible to combine different simulation codes, quantum mechanical or\nclassical, with great ease and minimal coding effort.\n", "versions": [{"version": "v1", "created": "Fri, 9 Nov 2012 08:55:53 GMT"}], "update_date": "2014-08-20", "authors_parsed": [["Leukkunen", "L.", ""], ["Verho", "T.", ""], ["Lopez-Acevedo", "O.", ""]]}, {"id": "1211.3056", "submitter": "Mourad Gouicem", "authors": "Pierre Fortin (LIP6), Mourad Gouicem (LIP6), Stef Graillat (LIP6)", "title": "GPU-accelerated generation of correctly-rounded elementary functions", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The IEEE 754-2008 standard recommends the correct rounding of some elementary\nfunctions. This requires to solve the Table Maker's Dilemma which implies a\nhuge amount of CPU computation time. We consider in this paper accelerating\nsuch computations, namely Lefe'vre algorithm on Graphics Processing Units\n(GPUs) which are massively parallel architectures with a partial SIMD execution\n(Single Instruction Multiple Data). We first propose an analysis of the\nLef\\`evre hard-to-round argument search using the concept of continued\nfractions. We then propose a new parallel search algorithm much more efficient\non GPU thanks to its more regular control flow. We also present an efficient\nhybrid CPU-GPU deployment of the generation of the polynomial approximations\nrequired in Lef\\`evre algorithm. In the end, we manage to obtain overall\nspeedups up to 53.4x on one GPU over a sequential CPU execution, and up to 7.1x\nover a multi-core CPU, which enable a much faster solving of the Table Maker's\nDilemma for the double precision format.\n", "versions": [{"version": "v1", "created": "Tue, 13 Nov 2012 17:28:03 GMT"}, {"version": "v2", "created": "Wed, 5 Jun 2013 11:51:55 GMT"}], "update_date": "2013-06-06", "authors_parsed": [["Fortin", "Pierre", "", "LIP6"], ["Gouicem", "Mourad", "", "LIP6"], ["Graillat", "Stef", "", "LIP6"]]}, {"id": "1211.3567", "submitter": "Nikola Mirkov Mr.", "authors": "Nikola Mirkov and Bosko Rasuo", "title": "A Bernstein Polynomial Collocation Method for the Solution of Elliptic\n  Boundary Value Problems", "comments": "21 page, 12 figures, 5tables, Python code listings in the Appendix", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NA cs.MS cs.NA physics.comp-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this article, a formulation of a point-collocation method in which the\nunknown function is approximated using global expansion in tensor product\nBernstein polynomial basis is presented. Bernstein polynomials used in this\nstudy are defined over general interval [a,b]. Method incorporates several\nideas that enable higher numerical efficiency compared to Bernstein polynomial\nmethods that have been previously presented. The approach is illustrated by a\nsolution of Poisson, Helmholtz and Biharmonic equations with Dirichlet and\nNeumann type boundary conditions. Comparisons with analytical solutions are\ngiven to demonstrate the accuracy and convergence properties of the current\nprocedure. The method is implemented in an open-source code, and a library for\nmanipulation of Bernstein polynomials bernstein-poly, developed by the authors.\n", "versions": [{"version": "v1", "created": "Thu, 15 Nov 2012 10:38:46 GMT"}], "update_date": "2012-11-16", "authors_parsed": [["Mirkov", "Nikola", ""], ["Rasuo", "Bosko", ""]]}, {"id": "1211.4047", "submitter": "Garth Wells", "authors": "Martin S. Alnaes and Anders Logg and Kristian B. Oelgaard and Marie E.\n  Rognes and Garth N. Wells", "title": "Unified Form Language: A domain-specific language for weak formulations\n  of partial differential equations", "comments": "To appear in ACM Transactions on Mathematical Software", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present the Unified Form Language (UFL), which is a domain-specific\nlanguage for representing weak formulations of partial differential equations\nwith a view to numerical approximation. Features of UFL include support for\nvariational forms and functionals, automatic differentiation of forms and\nexpressions, arbitrary function space hierarchies for multi-field problems,\ngeneral differential operators and flexible tensor algebra. With these\nfeatures, UFL has been used to effortlessly express finite element methods for\ncomplex systems of partial differential equations in near-mathematical\nnotation, resulting in compact, intuitive and readable programs. We present in\nthis work the language and its construction. An implementation of UFL is freely\navailable as an open-source software library. The library generates abstract\nsyntax tree representations of variational problems, which are used by other\nsoftware libraries to generate concrete low-level implementations. Some\napplication examples are presented and libraries that support UFL are\nhighlighted.\n", "versions": [{"version": "v1", "created": "Fri, 16 Nov 2012 21:56:02 GMT"}, {"version": "v2", "created": "Thu, 25 Apr 2013 20:18:09 GMT"}], "update_date": "2013-04-29", "authors_parsed": [["Alnaes", "Martin S.", ""], ["Logg", "Anders", ""], ["Oelgaard", "Kristian B.", ""], ["Rognes", "Marie E.", ""], ["Wells", "Garth N.", ""]]}, {"id": "1211.4892", "submitter": "Barak Pearlmutter", "authors": "Oleksandr Manzyuk and Barak A. Pearlmutter and Alexey Andreyevich\n  Radul and David R. Rush and Jeffrey Mark Siskind", "title": "Confusion of Tagged Perturbations in Forward Automatic Differentiation\n  of Higher-Order Functions", "comments": null, "journal-ref": null, "doi": "10.1017/S095679681900008X", "report-no": null, "categories": "cs.SC cs.MS math.DG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Forward Automatic Differentiation (AD) is a technique for augmenting programs\nto compute derivatives. The essence of Forward AD is to attach perturbations to\neach number, and propagate these through the computation. When derivatives are\nnested, the distinct derivative calculations, and their associated\nperturbations, must be distinguished. This is typically accomplished by\ncreating a unique tag for each derivative calculation, tagging the\nperturbations, and overloading the arithmetic operators. We exhibit a subtle\nbug, present in fielded implementations, in which perturbations are confused\ndespite the tagging machinery. The essence of the bug is this: each invocation\nof a derivative creates a unique tag but a unique tag is needed for each\nderivative calculation. When taking derivatives of higher-order functions,\nthese need not correspond! The derivative of a higher-order function $f$ that\nreturns a function $g$ will be a function $f'$ that returns a function\n$\\bar{g}$ that performs a derivative calculation. A single invocation of $f'$\nwill create a single fresh tag but that same tag will be used for each\nderivative calculation resulting from an invocation of $\\bar{g}$. This\nsituation arises when taking derivatives of curried functions. Two potential\nsolutions are presented, and their serious deficiencies discussed. One requires\neta expansion to delay the creation of fresh tags from the invocation of $f'$\nto the invocation of $\\bar{g}$, which can be difficult or even impossible in\nsome circumstances. The other requires $f'$ to wrap $\\bar{g}$ with tag\nrenaming, which is difficult to implement without violating the desirable\ncomplexity properties of forward AD.\n", "versions": [{"version": "v1", "created": "Tue, 20 Nov 2012 22:08:31 GMT"}, {"version": "v2", "created": "Thu, 17 May 2018 15:00:10 GMT"}, {"version": "v3", "created": "Wed, 22 May 2019 13:50:20 GMT"}, {"version": "v4", "created": "Sat, 29 Jun 2019 20:44:41 GMT"}], "update_date": "2019-09-23", "authors_parsed": [["Manzyuk", "Oleksandr", ""], ["Pearlmutter", "Barak A.", ""], ["Radul", "Alexey Andreyevich", ""], ["Rush", "David R.", ""], ["Siskind", "Jeffrey Mark", ""]]}, {"id": "1211.5904", "submitter": "Paolo Bientinesi", "authors": "Diego Fabregat-Traver (1), Paolo Bientinesi (1), ((1) AICES, RWTH\n  Aachen)", "title": "Application-tailored Linear Algebra Algorithms: A search-based Approach", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we tackle the problem of automatically generating algorithms\nfor linear algebra operations by taking advantage of problem-specific\nknowledge. In most situations, users possess much more information about the\nproblem at hand than what current libraries and computing environments accept;\nevidence shows that if properly exploited, such information leads to\nuncommon/unexpected speedups. We introduce a knowledge-aware linear algebra\ncompiler that allows users to input matrix equations together with properties\nabout the operands and the problem itself; for instance, they can specify that\nthe equation is part of a sequence, and how successive instances are related to\none another. The compiler exploits all this information to guide the generation\nof algorithms, to limit the size of the search space, and to avoid redundant\ncomputations. We applied the compiler to equations arising as part of\nsensitivity and genome studies; the algorithms produced exhibit, respectively,\n100- and 1000-fold speedups.\n", "versions": [{"version": "v1", "created": "Mon, 26 Nov 2012 10:15:29 GMT"}], "update_date": "2012-11-27", "authors_parsed": [["Fabregat-Traver", "Diego", ""], ["Bientinesi", "Paolo", ""]]}, {"id": "1211.6989", "submitter": "Patrick Farrell", "authors": "Patrick E. Farrell and Colin J. Cotter and Simon W. Funke", "title": "A framework for the automation of generalised stability theory", "comments": "Accepted in SISC", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The traditional approach to investigating the stability of a physical system\nis to linearise the equations about a steady base solution, and to examine the\neigenvalues of the linearised operator. Over the past several decades, it has\nbeen recognised that this approach only determines the asymptotic stability of\nthe system, and neglects the possibility of transient perturbation growth\narising due to the nonnormality of the system. This observation motivated the\ndevelopment of a more powerful generalised stability theory (GST), which\nfocusses instead on the singular value decomposition of the linearised\npropagator of the system. While GST has had significant successes in\nunderstanding the stability of phenomena in geophysical fluid dynamics, its\nmore widespread applicability has been hampered by the fact that computing the\nSVD requires both the tangent linear operator and its adjoint: deriving the\ntangent linear and adjoint models is usually a considerable challenge, and\nmanually embedding them inside an eigensolver is laborious. In this paper, we\npresent a framework for the automation of generalised stability theory, which\novercomes these difficulties. Given a compact high-level symbolic\nrepresentation of a finite element discretisation implemented in the FEniCS\nsystem, efficient C++ code is automatically generated to assemble the forward,\ntangent linear and adjoint models; these models are then used to calculate the\noptimally growing perturbations to the forward model, and their growth rates.\nBy automating the stability computations, we hope to make these powerful tools\na more routine part of computational analysis. The efficiency and generality of\nthe framework is demonstrated with applications drawn from geophysical fluid\ndynamics, phase separation and quantum mechanics.\n", "versions": [{"version": "v1", "created": "Thu, 29 Nov 2012 17:15:08 GMT"}, {"version": "v2", "created": "Fri, 18 Oct 2013 20:36:50 GMT"}], "update_date": "2013-10-22", "authors_parsed": [["Farrell", "Patrick E.", ""], ["Cotter", "Colin J.", ""], ["Funke", "Simon W.", ""]]}, {"id": "1211.7110", "submitter": "Henning Ulfarsson", "authors": "Hjalti Magnusson, Henning Ulfarsson", "title": "Algorithms for discovering and proving theorems about permutation\n  patterns", "comments": "13 pages, 3 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.CO cs.DM cs.DS cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an algorithm, called BiSC, that describes the patterns avoided by\na given set of permutations. It automatically conjectures the statements of\nknown theorems such as the descriptions of stack-sortable (Knuth 1975) and\nWest-2-stack-sortable permutations (West 1990), smooth (Lakshmibai and Sandhya\n1990) and forest-like permutations (Bousquet-Melou and Butler 2007), and simsun\npermutations (Branden and Claesson 2011). The algorithm has also been used to\ndiscover new theorems and conjectures related to Young tableaux,\nWilf-equivalences and sorting devices. We further give algorithms to prove a\ncomplete description of preimages of pattern classes under certain sorting\ndevices. These generalize an algorithm of Claesson and Ulfarsson (2012) and\nallow us to prove a linear time algorithm for finding occurrences of the\npattern 4312.\n", "versions": [{"version": "v1", "created": "Thu, 29 Nov 2012 22:38:57 GMT"}], "update_date": "2012-12-03", "authors_parsed": [["Magnusson", "Hjalti", ""], ["Ulfarsson", "Henning", ""]]}]