[{"id": "1807.00672", "submitter": "Fabrice Zaoui", "authors": "Fabrice Zaoui (EDF R\\&D STEP)", "title": "A GPU-enabled finite volume solver for large shallow water simulations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CE cs.MS physics.comp-ph physics.med-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper presents the implementation of a HLLC finite volume solver using\nGPU technology for the solution of shallow water problems in two dimensions. It\ncompares both CPU and GPU approaches for implementing all the solver's steps.\nThe technology of graphics and central processors is highlighted with a\nparticular emphasis on the CUDA architecture of NVIDIA. The simple and\nwell-documented Application Programming Interface (CUDA API) facilitates the\nuse of the display card workstation as an additional computer unit to the\ncentral processor. Four professional solutions of the NVIDIA Quadro line are\ntested. Comparison tests between CPU and GPU are carried out on unstructured\ngrids of small sizes (up to 10,000 elements), medium and large sizes (up to\n10,000,000 elements). For all test cases, the accuracy of results is of the\nsame order of magnitude for both approaches. Furthermore, the obtained speed\ngains with the GPU strongly depend on the model of the graphics card, the size\nof the problem and the simulation time.\n", "versions": [{"version": "v1", "created": "Thu, 28 Jun 2018 08:11:29 GMT"}], "update_date": "2018-07-03", "authors_parsed": [["Zaoui", "Fabrice", "", "EDF R\\&D STEP"]]}, {"id": "1807.01417", "submitter": "Christopher Lee", "authors": "C.T. Lee, J.B. Moody, R.E. Amaro, J.A. McCammon, and M. Holst", "title": "The Implementation of the Colored Abstract Simplicial Complex and its\n  Application to Mesh Generation", "comments": "24 pages, 6 figures", "journal-ref": "ACM Trans. Math. Softw. 45, 3, Article 28 (August 2019)", "doi": "10.1145/3321515", "report-no": null, "categories": "cs.MS math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce CASC: a new, modern, and header-only C++ library which provides\na data structure to represent arbitrary dimension abstract simplicial complexes\n(ASC) with user-defined classes stored directly on the simplices at each\ndimension. This is accomplished by using the latest C++ language features\nincluding variadic template parameters introduced in C++11 and automatic\nfunction return type deduction from C++14. Effectively CASC decouples the\nrepresentation of the topology from the interactions of user data. We present\nthe innovations and design principles of the data structure and related\nalgorithms. This includes a metadata aware decimation algorithm which is\ngeneral for collapsing simplices of any dimension. We also present an example\napplication of this library to represent an orientable surface mesh.\n", "versions": [{"version": "v1", "created": "Wed, 4 Jul 2018 01:04:27 GMT"}, {"version": "v2", "created": "Wed, 27 Mar 2019 21:09:34 GMT"}], "update_date": "2019-08-14", "authors_parsed": [["Lee", "C. T.", ""], ["Moody", "J. B.", ""], ["Amaro", "R. E.", ""], ["McCammon", "J. A.", ""], ["Holst", "M.", ""]]}, {"id": "1807.01775", "submitter": "Pierre Augier", "authors": "Ashwin Vishnu Mohanan, Cyrille Bonamy and Pierre Augier", "title": "FluidFFT: common API (C++ and Python) for Fast Fourier Transform HPC\n  libraries", "comments": null, "journal-ref": null, "doi": "10.5334/jors.238", "report-no": null, "categories": "cs.MS physics.flu-dyn", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Python package fluidfft provides a common Python API for performing Fast\nFourier Transforms (FFT) in sequential, in parallel and on GPU with different\nFFT libraries (FFTW, P3DFFT, PFFT, cuFFT). fluidfft is a comprehensive FFT\nframework which allows Python users to easily and efficiently perform FFT and\nthe associated tasks, such as as computing linear operators and energy spectra.\nWe describe the architecture of the package composed of C++ and Cython FFT\nclasses, Python \"operator\" classes and Pythran functions. The package supplies\nutilities to easily test itself and benchmark the different FFT solutions for a\nparticular case and on a particular machine. We present a performance scaling\nanalysis on three different computing clusters and a microbenchmark showing\nthat fluidfft is an interesting solution to write efficient Python applications\nusing FFT.\n", "versions": [{"version": "v1", "created": "Tue, 3 Jul 2018 09:52:57 GMT"}], "update_date": "2019-04-11", "authors_parsed": [["Mohanan", "Ashwin Vishnu", ""], ["Bonamy", "Cyrille", ""], ["Augier", "Pierre", ""]]}, {"id": "1807.03032", "submitter": "Fabio Luporini", "authors": "Fabio Luporini and Michael Lange and Mathias Louboutin and Navjot\n  Kukreja and Jan H\\\"uckelheim and Charles Yount and Philipp Witte and Paul H.\n  J. Kelly and Felix J. Herrmann and Gerard J. Gorman", "title": "Architecture and performance of Devito, a system for automated stencil\n  computation", "comments": "Submitted to ACM Transactions on Mathematical Software", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Stencil computations are a key part of many high-performance computing\napplications, such as image processing, convolutional neural networks, and\nfinite-difference solvers for partial differential equations. Devito is a\nframework capable of generating highly-optimized code given symbolic equations\nexpressed in Python, specialized in, but not limited to, affine (stencil)\ncodes. The lowering process---from mathematical equations down to C++ code---is\nperformed by the Devito compiler through a series of intermediate\nrepresentations. Several performance optimizations are introduced, including\nadvanced common sub-expressions elimination, tiling and parallelization. Some\nof these are obtained through well-established stencil optimizers, integrated\nin the back-end of the Devito compiler. The architecture of the Devito\ncompiler, as well as the performance optimizations that are applied when\ngenerating code, are presented. The effectiveness of such performance\noptimizations is demonstrated using operators drawn from seismic imaging\napplications.\n", "versions": [{"version": "v1", "created": "Mon, 9 Jul 2018 10:32:50 GMT"}, {"version": "v2", "created": "Wed, 7 Aug 2019 09:37:06 GMT"}, {"version": "v3", "created": "Fri, 7 Feb 2020 11:30:42 GMT"}], "update_date": "2020-02-10", "authors_parsed": [["Luporini", "Fabio", ""], ["Lange", "Michael", ""], ["Louboutin", "Mathias", ""], ["Kukreja", "Navjot", ""], ["H\u00fcckelheim", "Jan", ""], ["Yount", "Charles", ""], ["Witte", "Philipp", ""], ["Kelly", "Paul H. J.", ""], ["Herrmann", "Felix J.", ""], ["Gorman", "Gerard J.", ""]]}, {"id": "1807.05252", "submitter": "Andreas Dedner", "authors": "Andreas Dedner and Martin Nolte", "title": "The Dune Python Module", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we present the new Dune-Python module which provides Python\nbindings for the Dune core, which is a C++ environment for solving partial\ndifferential equations. The aim of this new module is to firstly provide the\ngeneral infrastructure for exporting realizations of statically polymorphic\ninterfaces based on just-in-time compilation and secondly to provide bindings\nfor the central interfaces of the dune core modules. In the first release we\nfocus on the grid interface. Our aim is to only introduce a thin layer when\npassing objects into Python which can be removed when the object is passed back\ninto a C++ algorithm. Thus no efficiency is lost and little additional code\nmaintenance cost is incurred. To make the transition for Dune users to the\nPython environment straightforward the Python classes provide a very similar\ninterface to their C++ counterparts. In addition, vectorized versions of many\ninterfaces allow for more efficient code on the Python side. The infrastructure\nfor exporting these interfaces and the resulting bindings for a Dune grid are\nexplained in detail in this paper for both experienced Dune users and others\ninterested in a flexible Python environment for implementing grid based schemes\nfor solving partial differential equations.\n", "versions": [{"version": "v1", "created": "Fri, 13 Jul 2018 19:17:48 GMT"}], "update_date": "2018-07-17", "authors_parsed": [["Dedner", "Andreas", ""], ["Nolte", "Martin", ""]]}, {"id": "1807.06430", "submitter": "Christopher Rackauckas", "authors": "Christopher Rackauckas and Qing Nie", "title": "Confederated Modular Differential Equation APIs for Accelerated\n  Algorithm Development and Benchmarking", "comments": "4 figures, 3 algorithms", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Performant numerical solving of differential equations is required for\nlarge-scale scientific modeling. In this manuscript we focus on two questions:\n(1) how can researchers empirically verify theoretical advances and\nconsistently compare methods in production software settings and (2) how can\nusers (scientific domain experts) keep up with the state-of-the-art methods to\nselect those which are most appropriate? Here we describe how the confederated\nmodular API of DifferentialEquations.jl addresses these concerns. We detail the\npackage-free API which allows numerical methods researchers to readily utilize\nand benchmark any compatible method directly in full-scale scientific\napplications. In addition, we describe how the complexity of the method choices\nis abstracted via a polyalgorithm. We show how scientific tooling built on top\nof DifferentialEquations.jl, such as packages for dynamical systems\nquantification and quantum optics simulation, both benefit from this structure\nand provide themselves as convenient benchmarking tools.\n", "versions": [{"version": "v1", "created": "Tue, 17 Jul 2018 13:46:23 GMT"}], "update_date": "2018-07-18", "authors_parsed": [["Rackauckas", "Christopher", ""], ["Nie", "Qing", ""]]}, {"id": "1807.07643", "submitter": "Marcus Foster", "authors": "Marcus Foster and Sean Tregeagle", "title": "Physical-type correctness in scientific Python", "comments": "6 pages. v2 expanded Abstract only. v3 added reference to/description\n  of/code example for recent units library unyt arXiv:1806.02417; fixed typos", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  The representation of units and dimensions in informatics systems is barely\ncodified and often ignored. For instance, the major languages used in\nscientific computing (Fortran, C and Python), have no type for dimension or\nunit, and so physical quantities are represented in a program by variables of\ntype real, resulting in the possibility of unit or dimensional errors. In view\nof this danger, many authors have proposed language schemes for unit-checking\nand conversion. However, since many physical quantities have the same units, it\nis possible for a block of code to be unit-compatible, but still physically\nmeaningless. We demonstrate the limitations of three Python unit-libraries and\npresent a justification and method for checking kind-of-quantity.\n", "versions": [{"version": "v1", "created": "Tue, 17 Jul 2018 13:12:32 GMT"}, {"version": "v2", "created": "Mon, 23 Jul 2018 07:05:33 GMT"}, {"version": "v3", "created": "Fri, 3 Aug 2018 04:28:40 GMT"}], "update_date": "2018-08-06", "authors_parsed": [["Foster", "Marcus", ""], ["Tregeagle", "Sean", ""]]}, {"id": "1807.08607", "submitter": "Pawel Dlotko PhD", "authors": "Pawe{\\l} D{\\l}otko", "title": "Computational and applied topology, tutorial", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS math.AT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This is a tutorial in applied and computational topology and topological data\nanalysis. It is illustrated with numerous computational examples that utilize\nGudhi library. It is under constant development, so please do not consider this\nversion as final.\n", "versions": [{"version": "v1", "created": "Wed, 11 Jul 2018 09:19:41 GMT"}, {"version": "v2", "created": "Thu, 23 Aug 2018 09:56:59 GMT"}], "update_date": "2018-08-24", "authors_parsed": [["D\u0142otko", "Pawe\u0142", ""]]}, {"id": "1807.10129", "submitter": "Andrew Fitzgibbon", "authors": "Filip \\v{S}rajer, Zuzana Kukelova, Andrew Fitzgibbon", "title": "A Benchmark of Selected Algorithmic Differentiation Tools on Some\n  Problems in Computer Vision and Machine Learning", "comments": "Previous versions of this article appeared at AD2016---7th\n  International Conference on Algorithmic Differentiation, and in Optimization\n  Methods and Software, Taylor and Francis, Feb 2018 (online)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.CV cs.LG", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Algorithmic differentiation (AD) allows exact computation of derivatives\ngiven only an implementation of an objective function. Although many AD tools\nare available, a proper and efficient implementation of AD methods is not\nstraightforward. The existing tools are often too different to allow for a\ngeneral test suite. In this paper, we compare fifteen ways of computing\nderivatives including eleven automatic differentiation tools implementing\nvarious methods and written in various languages (C++, F#, MATLAB, Julia and\nPython), two symbolic differentiation tools, finite differences, and\nhand-derived computation.\n  We look at three objective functions from computer vision and machine\nlearning. These objectives are for the most part simple, in the sense that no\niterative loops are involved, and conditional statements are encapsulated in\nfunctions such as {\\tt abs} or {\\tt logsumexp}. However, it is important for\nthe success of algorithmic differentiation that such `simple' objective\nfunctions are handled efficiently, as so many problems in computer vision and\nmachine learning are of this form.\n  Of course, our results depend on programmer skill, and familiarity with the\ntools. However, we contend that this paper presents an important datapoint: a\nskilled programmer devoting roughly a week to each tool produced the timings we\npresent. We have made our implementations available as open source to allow the\ncommunity to replicate and update these benchmarks.\n", "versions": [{"version": "v1", "created": "Thu, 26 Jul 2018 13:42:30 GMT"}], "update_date": "2018-07-27", "authors_parsed": [["\u0160rajer", "Filip", ""], ["Kukelova", "Zuzana", ""], ["Fitzgibbon", "Andrew", ""]]}]