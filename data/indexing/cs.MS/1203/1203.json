[{"id": "1203.1017", "submitter": "Dimitrios Diochnos", "authors": "Dimitrios I. Diochnos, Ioannis Z. Emiris, Elias P. Tsigaridas", "title": "On the asymptotic and practical complexity of solving bivariate systems\n  over the reals", "comments": "17 pages, 4 algorithms, 1 table, and 1 figure with 2 sub-figures", "journal-ref": "J. Symb. Comput. 44(7): 818-835 (2009)", "doi": "10.1016/j.jsc.2008.04.009", "report-no": null, "categories": "cs.SC cs.DS cs.MS cs.NA math.AG math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper is concerned with exact real solving of well-constrained,\nbivariate polynomial systems. The main problem is to isolate all common real\nroots in rational rectangles, and to determine their intersection\nmultiplicities. We present three algorithms and analyze their asymptotic bit\ncomplexity, obtaining a bound of $\\sOB(N^{14})$ for the purely projection-based\nmethod, and $\\sOB(N^{12})$ for two subresultant-based methods: this notation\nignores polylogarithmic factors, where $N$ bounds the degree and the bitsize of\nthe polynomials. The previous record bound was $\\sOB(N^{14})$.\n  Our main tool is signed subresultant sequences. We exploit recent advances on\nthe complexity of univariate root isolation, and extend them to sign evaluation\nof bivariate polynomials over two algebraic numbers, and real root counting for\npolynomials over an extension field. Our algorithms apply to the problem of\nsimultaneous inequalities; they also compute the topology of real plane\nalgebraic curves in $\\sOB(N^{12})$, whereas the previous bound was\n$\\sOB(N^{14})$.\n  All algorithms have been implemented in MAPLE, in conjunction with numeric\nfiltering. We compare them against FGB/RS, system solvers from SYNAPS, and\nMAPLE libraries INSULATE and TOP, which compute curve topology. Our software is\namong the most robust, and its runtimes are comparable, or within a small\nconstant factor, with respect to the C/C++ libraries.\n  Key words: real solving, polynomial systems, complexity, MAPLE software\n", "versions": [{"version": "v1", "created": "Mon, 5 Mar 2012 19:39:05 GMT"}], "update_date": "2012-03-06", "authors_parsed": [["Diochnos", "Dimitrios I.", ""], ["Emiris", "Ioannis Z.", ""], ["Tsigaridas", "Elias P.", ""]]}, {"id": "1203.1023", "submitter": "David Stoutemyer", "authors": "David R. Stoutemyer", "title": "Can the Eureqa symbolic regression program, computer algebra and\n  numerical analysis help each other?", "comments": "21 pages, 3 figures, a Mathematica notebook attachment", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Eureqa symbolic regression program has recently received extensive press\npraise. A representative quote is\n  \"There are very clever 'thinking machines' in existence today, such as\nWatson, the IBM computer that conquered Jeopardy! last year. But next to\nEureqa, Watson is merely a glorified search engine.\"\n  The program was designed to work with noisy experimental data. However, if\nthe data is generated from an expression for which there exists more concise\nequivalent expressions, sometimes some of the Eureqa results are one or more of\nthose more concise equivalents. If not, perhaps one or more of the returned\nEureqa results might be a sufficiently accurate approximation that is more\nconcise than the given expression. Moreover, when there is no known closed form\nexpression, the data points can be generated by numerical methods, enabling\nEureqa to find expressions that concisely fit those data points with sufficient\naccuracy. In contrast to typical regression software, the user does not have to\nexplicitly or implicitly provide a specific expression or class of expressions\ncontainiing unknown constants for the software to determine.\n  Is Eureqa useful enough in these regards to provide an additional tool for\nexperimental mathematics, computer algebra users and numerical analysis? Yes if\nused carefully. Can computer algebra and numerical methods help Eureqa?\nDefinitely.\n", "versions": [{"version": "v1", "created": "Mon, 5 Mar 2012 19:49:02 GMT"}], "update_date": "2012-03-06", "authors_parsed": [["Stoutemyer", "David R.", ""]]}, {"id": "1203.1034", "submitter": "Jan Skowron", "authors": "J. Skowron, A. Gould (Department of Astronomy, Ohio State University)", "title": "General Complex Polynomial Root Solver and Its Further Optimization for\n  Binary Microlenses", "comments": "29 pages, 4 figures, 1 table, 3 appendices. Open-source codes\n  described in this paper are available in the ancillary files directory (anc/)\n  of this submission, and on the author's web page:\n  http://www.astrouw.edu.pl/~jskowron/cmplx_roots_sg/", "journal-ref": null, "doi": null, "report-no": null, "categories": "astro-ph.EP cs.MS math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a new algorithm to solve polynomial equations, and publish its\ncode, which is 1.6-3 times faster than the ZROOTS subroutine that is\ncommercially available from Numerical Recipes, depending on application. The\nlargest improvement, when compared to naive solvers, comes from a fail-safe\nprocedure that permits us to skip the majority of the calculations in the great\nmajority of cases, without risking catastrophic failure in the few cases that\nthese are actually required. Second, we identify a discriminant that enables a\nrational choice between Laguerre's Method and Newton's Method (or a new\nintermediate method) on a case-by-case basis. We briefly review the history of\nroot solving and demonstrate that \"Newton's Method\" was discovered neither by\nNewton (1671) nor by Raphson (1690), but only by Simpson (1740). Some of the\narguments leading to this conclusion were first given by the British historian\nof science Nick Kollerstrom in 1992, but these do not appear to have penetrated\nthe astronomical community. Finally, we argue that Numerical Recipes should\nvoluntarily surrender its copyright protection for non-profit applications,\ndespite the fact that, in this particular case, such protection was the major\nstimulant for developing our improved algorithm.\n", "versions": [{"version": "v1", "created": "Mon, 5 Mar 2012 21:00:01 GMT"}], "update_date": "2012-03-07", "authors_parsed": [["Skowron", "J.", "", "Department of Astronomy, Ohio State University"], ["Gould", "A.", "", "Department of Astronomy, Ohio State University"]]}, {"id": "1203.1263", "submitter": "Ronald Caplan", "authors": "R. M. Caplan", "title": "NLSEmagic: Nonlinear Schr\\\"odinger Equation Multidimensional\n  Matlab-based GPU-accelerated Integrators using Compact High-order Schemes", "comments": "37 pages, 13 figures", "journal-ref": null, "doi": "10.1016/j.cpc.2012.12.010", "report-no": null, "categories": "cs.MS cs.CE physics.comp-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a simple to use, yet powerful code package called NLSEmagic to\nnumerically integrate the nonlinear Schr\u007f\\\"odinger equation in one, two, and\nthree dimensions. NLSEmagic is a high-order finite-difference code package\nwhich utilizes graphic processing unit (GPU) parallel architectures. The codes\nrunning on the GPU are many times faster than their serial counterparts, and\nare much cheaper to run than on standard parallel clusters. The codes are\ndeveloped with usability and portability in mind, and therefore are written to\ninterface with MATLAB utilizing custom GPU-enabled C codes with the\nMEX-compiler interface. The packages are freely distributed, including user\nmanuals and set-up files.\n", "versions": [{"version": "v1", "created": "Tue, 6 Mar 2012 17:45:07 GMT"}, {"version": "v2", "created": "Mon, 3 Dec 2012 19:16:52 GMT"}], "update_date": "2015-06-04", "authors_parsed": [["Caplan", "R. M.", ""]]}, {"id": "1203.1295", "submitter": "David Stoutemyer", "authors": "David R. Stoutemyer", "title": "Subtotal ordering -- a pedagogically advantageous algorithm for\n  computing total degree reverse lexicographic order", "comments": "12 pages, 2 Algorithms, 1 Table", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SC cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Total degree reverse lexicographic order is currently generally regarded as\nmost often fastest for computing Groebner bases. This article describes an\nalternate less mysterious algorithm for computing this order using exponent\nsubtotals and describes why it should be very nearly the same speed the\ntraditional algorithm, all other things being equal. However, experimental\nevidence suggests that subtotal order is actually slightly faster for the\nMathematica Groebner basis implementation more often than not. This is probably\nbecause the weight vectors associated with the natural subtotal weight matrix\nand with the usual total degree reverse lexicographic weight matrix are\ndifferent, and Mathematica also uses those the corresponding weight vectors to\nhelp select successive S polynomials and divisor polynomials: Those selection\nheuristics appear to work slightly better more often with subtotal weight\nvectors.\n  However, the most important advantage of exponent subtotals is pedagogical.\nIt is easier to understand than the total degree reverse lexicographic\nalgorithm, and it is more evident why the resulting order is often the fastest\nknown order for computing Groebner bases.\n  Keywords: Term order, Total degree reverse lexicographic, tdeg, grevlex,\nGroebner basis\n", "versions": [{"version": "v1", "created": "Tue, 6 Mar 2012 19:51:48 GMT"}], "update_date": "2012-03-07", "authors_parsed": [["Stoutemyer", "David R.", ""]]}, {"id": "1203.1350", "submitter": "David Stoutemyer", "authors": "David R. Stoutemyer", "title": "Simplifying products of fractional powers of powers", "comments": "34 pages. 17 tables. Includes Mathematica rewrite rules. To appear in\n  Communications in Computer Algebra", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SC cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Most computer algebra systems incorrectly simplify (z - z)/(sqrt(w^2)/w^3 -\n1/(w*sqrt(w^2))) to 0 rather than to 0/0. The reasons for this are:\n  1. The default simplification doesn't succeed in simplifying the denominator\nto 0.\n  2. There is a rule that 0 is the result of 0 divided by anything that doesn't\nsimplify to either 0 or 0/0.\n  Try it on your computer algebra systems!\n  This article describes how to simplify products of the form w^a*(w^b1)^g1 ...\n(w^bn)^gn correctly and well, where w is any real or complex expression and the\nexponents are rational numbers.\n  It might seem that correct good simplification of such a restrictive\nexpression class must already be published and/or built into at least one\nwidely used computer-algebra system, but apparently this issue has been\noverlooked. Default and relevant optional simplification was tested with 86\nexamples for n=1 on Derive, Maple, Mathematica, Maxima and TI-CAS. Totaled over\nall five systems, 11% of the results were not equivalent to the input\neverywhere, 50% of the results did not simplify to 0 a result that was\nequivalent to 0, and at least 16% of the results exhibited one or more of four\nadditional flaw types. There was substantial room for improvement in all five\nsystems, including the two for which I was a co-author.\n  The good news is: These flaws are easy to fix.\n", "versions": [{"version": "v1", "created": "Tue, 6 Mar 2012 23:02:46 GMT"}], "update_date": "2012-03-08", "authors_parsed": [["Stoutemyer", "David R.", ""]]}, {"id": "1203.1357", "submitter": "David Stoutemyer", "authors": "David R. Stoutemyer", "title": "Series misdemeanors", "comments": "21 pages; 1 Algorithm; 2 Tables; To appear in the ACM Communications\n  in Computer Algebra", "journal-ref": "ACM Communications in Computer Algebra 12/2012; 46\n  (4)(182):134-153", "doi": null, "report-no": null, "categories": "cs.SC cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Puiseux series are power series in which the exponents can be fractional\nand/or negative rational numbers. Several computer algebra systems have one or\nmore built-in or loadable functions for computing truncated Puiseux series --\nperhaps generalized to allow coefficients containing functions of the series\nvariable that are dominated by any power of that variable, such as logarithms\nand nested logarithms of the series variable. Some computer-algebra systems\nalso offer functions that can compute more-general truncated recursive\nhierarchical series. However, for all of these kinds of truncated series there\nare important implementation details that haven't been addressed before in the\npublished literature and in current implementations.\n  For implementers this article contains ideas for designing more convenient,\ncorrect, and efficient implementations or improving existing ones. For users,\nthis article is a warning about some of these limitations. Many of the ideas in\nthis article have been implemented in the computer-algebra within the TI-Nspire\ncalculator, Windows and Macintosh products.\n", "versions": [{"version": "v1", "created": "Wed, 7 Mar 2012 00:34:35 GMT"}], "update_date": "2013-05-17", "authors_parsed": [["Stoutemyer", "David R.", ""]]}, {"id": "1203.1448", "submitter": "Barak Pearlmutter", "authors": "Alexey Radul and Barak A. Pearlmutter and Jeffrey Mark Siskind", "title": "AD in Fortran, Part 1: Design", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We propose extensions to Fortran which integrate forward and reverse\nAutomatic Differentiation (AD) directly into the programming model.\nIrrespective of implementation technology, embedding AD constructs directly\ninto the language extends the reach and convenience of AD while allowing\nabstraction of concepts of interest to scientific-computing practice, such as\nroot finding, optimization, and finding equilibria of continuous games.\nMultiple different subprograms for these tasks can share common interfaces,\nregardless of whether and how they use AD internally. A programmer can maximize\na function F by calling a library maximizer, XSTAR=ARGMAX(F,X0), which\ninternally constructs derivatives of F by AD, without having to learn how to\nuse any particular AD tool. We illustrate the utility of these extensions by\nexample: programs become much more concise and closer to traditional\nmathematical notation. A companion paper describes how these extensions can be\nimplemented by a program that generates input to existing Fortran-based AD\ntools.\n", "versions": [{"version": "v1", "created": "Wed, 7 Mar 2012 12:04:05 GMT"}, {"version": "v2", "created": "Thu, 8 Mar 2012 09:51:03 GMT"}], "update_date": "2012-03-09", "authors_parsed": [["Radul", "Alexey", ""], ["Pearlmutter", "Barak A.", ""], ["Siskind", "Jeffrey Mark", ""]]}, {"id": "1203.1450", "submitter": "Barak Pearlmutter", "authors": "Alexey Radul and Barak A. Pearlmutter and Jeffrey Mark Siskind", "title": "AD in Fortran, Part 2: Implementation via Prepreprocessor", "comments": null, "journal-ref": "Recent Advances in Algorithmic Differentiation, Springer Lecture\n  Notes in Computational Science and Engineering volume 87, 2012, ISBN\n  978-3-642-30022-6, pages 273-284", "doi": "10.1007/978-3-642-30023-3_25", "report-no": null, "categories": "cs.PL cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe an implementation of the Farfel Fortran AD extensions. These\nextensions integrate forward and reverse AD directly into the programming\nmodel, with attendant benefits to flexibility, modularity, and ease of use. The\nimplementation we describe is a \"prepreprocessor\" that generates input to\nexisting Fortran-based AD tools. In essence, blocks of code which are targeted\nfor AD by Farfel constructs are put into subprograms which capture their\nlexical variable context, and these are closure-converted into top-level\nsubprograms and specialized to eliminate EXTERNAL arguments, rendering them\namenable to existing AD preprocessors, which are then invoked, possibly\nrepeatedly if the AD is nested.\n", "versions": [{"version": "v1", "created": "Wed, 7 Mar 2012 12:16:30 GMT"}, {"version": "v2", "created": "Thu, 8 Mar 2012 09:56:48 GMT"}], "update_date": "2016-02-09", "authors_parsed": [["Radul", "Alexey", ""], ["Pearlmutter", "Barak A.", ""], ["Siskind", "Jeffrey Mark", ""]]}, {"id": "1203.1692", "submitter": "Nicolas Bock", "authors": "Nicolas Bock, Matt Challacombe", "title": "An Optimized Sparse Approximate Matrix Multiply for Matrices with Decay", "comments": null, "journal-ref": null, "doi": null, "report-no": "LA-UR 11-06091", "categories": "cs.NA cs.DS cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present an optimized single-precision implementation of the Sparse\nApproximate Matrix Multiply (\\SpAMM{}) [M. Challacombe and N. Bock, arXiv {\\bf\n1011.3534} (2010)], a fast algorithm for matrix-matrix multiplication for\nmatrices with decay that achieves an $\\mathcal{O} (n \\log n)$ computational\ncomplexity with respect to matrix dimension $n$. We find that the max norm of\nthe error achieved with a \\SpAMM{} tolerance below $2 \\times 10^{-8}$ is lower\nthan that of the single-precision {\\tt SGEMM} for dense quantum chemical\nmatrices, while outperforming {\\tt SGEMM} with a cross-over already for small\nmatrices ($n \\sim 1000$). Relative to naive implementations of \\SpAMM{} using\nIntel's Math Kernel Library ({\\tt MKL}) or AMD's Core Math Library ({\\tt\nACML}), our optimized version is found to be significantly faster. Detailed\nperformance comparisons are made for quantum chemical matrices with differently\nstructured sub-blocks. Finally, we discuss the potential of improved hardware\nprefetch to yield 2--3x speedups.\n", "versions": [{"version": "v1", "created": "Thu, 8 Mar 2012 05:33:01 GMT"}, {"version": "v2", "created": "Fri, 9 Mar 2012 22:42:22 GMT"}, {"version": "v3", "created": "Tue, 20 Mar 2012 21:49:56 GMT"}, {"version": "v4", "created": "Fri, 31 Aug 2012 22:30:22 GMT"}, {"version": "v5", "created": "Tue, 4 Sep 2012 18:10:32 GMT"}], "update_date": "2012-09-05", "authors_parsed": [["Bock", "Nicolas", ""], ["Challacombe", "Matt", ""]]}, {"id": "1203.3059", "submitter": "Erhan Turan", "authors": "Erhan Turan and Ali Ecder", "title": "Set Reduction In Nonlinear Equations", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, an idea to solve nonlinear equations is presented. During the\nsolution of any problem with Newton's Method, it might happen that some of the\nunknowns satisfy the convergence criteria where the others fail. The\nconvergence happens only when all variables reach to the convergence limit. A\nmethod to reduce the dimension of the overall system by excluding some of the\nunknowns that satisfy an intermediate tolerance is introduced. In this\napproach, a smaller system is solved in less amount of time and already\nestablished local solutions are preserved and kept as constants while the other\nvariables that belong to the \"set\" will be relaxed. To realize the idea, an\nalgorithm is given that utilizes applications of pointers to reduce and\nevaluate the sets. Matrix-free Newton-Krylov Techniques are used on a test\nproblem and it is shown that proposed idea improves the overall convergence.\n", "versions": [{"version": "v1", "created": "Wed, 14 Mar 2012 12:00:08 GMT"}], "update_date": "2012-03-15", "authors_parsed": [["Turan", "Erhan", ""], ["Ecder", "Ali", ""]]}, {"id": "1203.4009", "submitter": "Odemir Bruno PhD", "authors": "Ricardo Fabbri, Odemir Martinez Bruno and Luciano da Fontoura Costa", "title": "Scilab and SIP for Image Processing", "comments": "16 pages, 6 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.CV", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper is an overview of Image Processing and Analysis using Scilab, a\nfree prototyping environment for numerical calculations similar to Matlab. We\ndemonstrate the capabilities of SIP -- the Scilab Image Processing Toolbox --\nwhich extends Scilab with many functions to read and write images in over 100\nmajor file formats, including PNG, JPEG, BMP, and TIFF. It also provides\nroutines for image filtering, edge detection, blurring, segmentation, shape\nanalysis, and image recognition. Basic directions to install Scilab and SIP are\ngiven, and also a mini-tutorial on Scilab. Three practical examples of image\nanalysis are presented, in increasing degrees of complexity, showing how\nadvanced image analysis techniques seems uncomplicated in this environment.\n", "versions": [{"version": "v1", "created": "Sun, 18 Mar 2012 23:51:19 GMT"}], "update_date": "2012-03-20", "authors_parsed": [["Fabbri", "Ricardo", ""], ["Bruno", "Odemir Martinez", ""], ["Costa", "Luciano da Fontoura", ""]]}, {"id": "1203.4031", "submitter": "Eric Polizzi", "authors": "Eric Polizzi, James Kestyn", "title": "FEAST Eigenvalue Solver v3.0 User Guide", "comments": "37 pages, 10 Figures, 12 Tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.CE physics.chem-ph physics.comp-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The FEAST eigensolver package is a free high-performance numerical library\nfor solving the Hermitian and non-Hermitian eigenvalue problems, and obtaining\nall the eigenvalues and (right/left) eigenvectors within a given search\ninterval or arbitrary contour in the complex plane. Its originality lies with a\nnew transformative numerical approach to the traditional eigenvalue algorithm\ndesign - the FEAST algorithm. The FEAST eigensolver combines simplicity and\nefficiency and it offers many important capabilities for achieving high\nperformance, robustness, accuracy, and scalability on parallel architectures.\nFEAST is both a comprehensive library package, and an easy to use software. It\nincludes flexible reverse communication interfaces and ready to use predefined\ninterfaces for dense, banded and sparse systems. The current version v3.0 of\nthe FEAST package can address both Hermitian and non-Hermitian eigenvalue\nproblems (real symmetric, real non-symmetric, complex Hermitian, complex\nsymmetric, or complex general systems) on both shared-memory and distributed\nmemory architectures (i.e contains both FEAST-SMP and FEAST-MPI packages). This\nUser's guide provides instructions for installation setup, a detailed\ndescription of the FEAST interfaces and a large number of examples.\n", "versions": [{"version": "v1", "created": "Mon, 19 Mar 2012 03:47:55 GMT"}, {"version": "v2", "created": "Wed, 20 Feb 2013 02:31:28 GMT"}, {"version": "v3", "created": "Tue, 16 Jun 2015 15:47:52 GMT"}], "update_date": "2015-06-17", "authors_parsed": [["Polizzi", "Eric", ""], ["Kestyn", "James", ""]]}, {"id": "1203.5846", "submitter": "David Stoutemyer", "authors": "David R. Stoutemyer", "title": "Series Crimes", "comments": "36 pages, 5 tables, to appear in ACM Communications in Computer\n  Algebra", "journal-ref": "ACM Communications in Computer Algebra 12/2012; 46\n  (4)(182):134-153", "doi": null, "report-no": null, "categories": "cs.SC cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Puiseux series are power series in which the exponents can be fractional\nand/or negative rational numbers. Several computer algebra systems have one or\nmore built-in or loadable functions for computing truncated Puiseux series.\nSome are generalized to allow coefficients containing functions of the series\nvariable that are dominated by any power of that variable, such as logarithms\nand nested logarithms of the series variable. Some computer algebra systems\nalso have built-in or loadable functions that compute infinite Puiseux series.\nUnfortunately, there are some little-known pitfalls in computing Puiseux\nseries. The most serious of these is expansions within branch cuts or at branch\npoints that are incorrect for some directions in the complex plane. For example\nwith each series implementation accessible to you:\n  Compare the value of (z^2 + z^3)^(3/2) with that of its truncated series\nexpansion about z = 0, approximated at z = -0.01. Does the series converge to a\nvalue that is the negative of the correct value?\n  Compare the value of ln(z^2 + z^3) with its truncated series expansion about\nz = 0, approximated at z = -0.01 + 0.1i. Does the series converge to a value\nthat is incorrect by 2pi i?\n  Compare arctanh(-2 + ln(z)z) with its truncated series expansion about z = 0,\napproximated at z = -0.01. Does the series converge to a value that is\nincorrect by about pi i?\n  At the time of this writing, most implementations that accommodate such\nseries exhibit such errors. This article describes how to avoid these errors\nboth for manual derivation of series and when implementing series packages.\n", "versions": [{"version": "v1", "created": "Tue, 27 Mar 2012 00:31:28 GMT"}], "update_date": "2016-10-05", "authors_parsed": [["Stoutemyer", "David R.", ""]]}, {"id": "1203.6005", "submitter": "Benjamin Piwowarski", "authors": "Benjamin Piwowarski", "title": "The Kernel Quantum Probabilities (KQP) Library", "comments": "Describes the library available at http://kqp.bpiwowar.net/", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this document, we show how the different quantities necessary to compute\nkernel quantum probabilities can be computed. This document form the basis of\nthe implementation of the Kernel Quantum Probability (KQP) open source project\n", "versions": [{"version": "v1", "created": "Tue, 27 Mar 2012 15:57:59 GMT"}, {"version": "v2", "created": "Fri, 30 Mar 2012 18:49:36 GMT"}], "update_date": "2012-04-02", "authors_parsed": [["Piwowarski", "Benjamin", ""]]}]