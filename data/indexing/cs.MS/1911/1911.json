[{"id": "1911.00093", "submitter": "Rise Ooi", "authors": "Rise Ooi, Takeshi Iwashita, Takeshi Fukaya, Akihiro Ida, Rio Yokota", "title": "Effect of Mixed Precision Computing on H-Matrix Vector Multiplication in\n  BEM Analysis", "comments": "Accepted manuscript to International Conference on High Performance\n  Computing in Asia-Pacific Region (HPCAsia2020), January 15--17, 2020,\n  Fukuoka, Japan", "journal-ref": null, "doi": "10.1145/3368474.3368479", "report-no": null, "categories": "cs.MS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Hierarchical Matrix (H-matrix) is an approximation technique which splits a\ntarget dense matrix into multiple submatrices, and where a selected portion of\nsubmatrices are low-rank approximated. The technique substantially reduces both\ntime and space complexity of dense matrix vector multiplication, and hence has\nbeen applied to numerous practical problems.\n  In this paper, we aim to accelerate the H-matrix vector multiplication by\nintroducing mixed precision computing, where we employ both binary64 (FP64) and\nbinary32 (FP32) arithmetic operations. We propose three methods to introduce\nmixed precision computing to H-matrix vector multiplication, and then evaluate\nthem in a boundary element method (BEM) analysis. The numerical tests examine\nthe effects of mixed precision computing, particularly on the required\nsimulation time and rate of convergence of the iterative (BiCG-STAB) linear\nsolver. We confirm the effectiveness of the proposed methods.\n", "versions": [{"version": "v1", "created": "Wed, 30 Oct 2019 04:07:52 GMT"}], "update_date": "2019-11-04", "authors_parsed": [["Ooi", "Rise", ""], ["Iwashita", "Takeshi", ""], ["Fukaya", "Takeshi", ""], ["Ida", "Akihiro", ""], ["Yokota", "Rio", ""]]}, {"id": "1911.01166", "submitter": "C\\'ecile Daversin-Catty", "authors": "C\\'ecile Daversin-Catty, Chris N. Richardson, Ada J. Ellingsrud, Marie\n  E. Rognes", "title": "Abstractions and automated algorithms for mixed domain finite element\n  methods", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Mixed dimensional partial differential equations (PDEs) are equations\ncoupling unknown fields defined over domains of differing topological\ndimension. Such equations naturally arise in a wide range of scientific fields\nincluding geology, physiology, biology and fracture mechanics. Mixed\ndimensional PDEs are also commonly encountered when imposing non-standard\nconditions over a subspace of lower dimension e.g. through a Lagrange\nmultiplier. In this paper, we present general abstractions and algorithms for\nfinite element discretizations of mixed domain and mixed dimensional PDEs of\nco-dimension up to one (i.e. nD-mD with |n-m| <= 1). We introduce high level\nmathematical software abstractions together with lower level algorithms for\nexpressing and efficiently solving such coupled systems. The concepts\nintroduced here have also been implemented in the context of the FEniCS finite\nelement software. We illustrate the new features through a range of examples,\nincluding a constrained Poisson problem, a set of Stokes-type flow models and a\nmodel for ionic electrodiffusion.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 12:42:42 GMT"}], "update_date": "2019-11-05", "authors_parsed": [["Daversin-Catty", "C\u00e9cile", ""], ["Richardson", "Chris N.", ""], ["Ellingsrud", "Ada J.", ""], ["Rognes", "Marie E.", ""]]}, {"id": "1911.01492", "submitter": "Christian Engwer", "authors": "Peter Bastian, Mirco Altenbernd, Nils-Arne Dreier, Christian Engwer,\n  Jorrit Fahlke, Ren\\'e Fritze, Markus Geveler, Dominik G\\\"oddeke, Oleg Iliev,\n  Olaf Ippisch, Jan Mohring, Steffen M\\\"uthing, Mario Ohlberger, Dirk Ribbrock,\n  Nikolay Shegunov, Stefan Turek", "title": "Exa-Dune -- Flexible PDE Solvers, Numerical Methods and Applications", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In the Exa-Dune project we have developed, implemented and optimised\nnumerical algorithms and software for the scalable solution of partial\ndifferential equations (PDEs) on future exascale systems exhibiting a\nheterogeneous massively parallel architecture. In order to cope with the\nincreased probability of hardware failures, one aim of the project was to add\nflexible, application-oriented resilience capabilities into the framework.\nContinuous improvement of the underlying hardware-oriented numerical methods\nhave included GPU-based sparse approximate inverses, matrix-free\nsum-factorisation for high-order discontinuous Galerkin discretisations as well\nas partially matrix-free preconditioners. On top of that, additional\nscalability is facilitated by exploiting massive coarse grained parallelism\noffered by multiscale and uncertainty quantification methods where we have\nfocused on the adaptive choice of the coarse/fine scale and the overlap region\nas well as the combination of local reduced basis multiscale methods and the\nmultilevel Monte-Carlo algorithm. Finally, some of the concepts are applied in\na land-surface model including subsurface flow and surface runoff.\n", "versions": [{"version": "v1", "created": "Mon, 4 Nov 2019 21:17:47 GMT"}, {"version": "v2", "created": "Wed, 6 Nov 2019 11:15:15 GMT"}], "update_date": "2019-11-07", "authors_parsed": [["Bastian", "Peter", ""], ["Altenbernd", "Mirco", ""], ["Dreier", "Nils-Arne", ""], ["Engwer", "Christian", ""], ["Fahlke", "Jorrit", ""], ["Fritze", "Ren\u00e9", ""], ["Geveler", "Markus", ""], ["G\u00f6ddeke", "Dominik", ""], ["Iliev", "Oleg", ""], ["Ippisch", "Olaf", ""], ["Mohring", "Jan", ""], ["M\u00fcthing", "Steffen", ""], ["Ohlberger", "Mario", ""], ["Ribbrock", "Dirk", ""], ["Shegunov", "Nikolay", ""], ["Turek", "Stefan", ""]]}, {"id": "1911.02410", "submitter": "Francesco Farina", "authors": "Francesco Farina, Andrea Camisa, Andrea Testa, Ivano Notarnicola,\n  Giuseppe Notarstefano", "title": "DISROPT: a Python Framework for Distributed Optimization", "comments": null, "journal-ref": "IFAC-PapersOnLine 2020", "doi": "10.1016/j.ifacol.2020.12.382", "report-no": null, "categories": "math.OC cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we introduce DISROPT, a Python package for distributed\noptimization over networks. We focus on cooperative set-ups in which an\noptimization problem must be solved by peer-to-peer processors (without central\ncoordinators) that have access only to partial knowledge of the entire problem.\nTo reflect this, agents in DISROPT are modeled as entities that are initialized\nwith their local knowledge of the problem. Agents then run local routines and\ncommunicate with each other to solve the global optimization problem. A simple\nsyntax has been designed to allow for an easy modeling of the problems. The\npackage comes with many distributed optimization algorithms that are already\nembedded. Moreover, the package provides full-fledged functionalities for\ncommunication and local computation, which can be used to design and implement\nnew algorithms. DISROPT is available at github.com/disropt/disropt under the\nGPL license, with a complete documentation and many examples.\n", "versions": [{"version": "v1", "created": "Wed, 6 Nov 2019 14:39:41 GMT"}, {"version": "v2", "created": "Wed, 20 May 2020 17:43:21 GMT"}], "update_date": "2021-04-21", "authors_parsed": [["Farina", "Francesco", ""], ["Camisa", "Andrea", ""], ["Testa", "Andrea", ""], ["Notarnicola", "Ivano", ""], ["Notarstefano", "Giuseppe", ""]]}, {"id": "1911.02558", "submitter": "Glen Evenbly", "authors": "Glen Evenbly", "title": "TensorTrace: an application to contract tensor networks", "comments": "5 pages, 5 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "quant-ph cond-mat.str-el cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Tensor network methods are a conceptually elegant framework for encoding\ncomplicated datasets, where high-order tensors are approximated as networks of\nlow-order tensors. In practice, however, the numeric implementation of tensor\nnetwork algorithms is often a labor-intensive and error-prone task, even for\nexperienced researchers in this area. \\emph{TensorTrace} is application\ndesigned to alleviate the burden of contracting tensor networks: it provides a\ngraphic drawing interface specifically tailored for the construction of tensor\nnetwork diagrams, from which the code for their optimal contraction can then be\nautomatically generated (in the users choice of the MATLAB, Python or Julia\nlanguages). \\emph{TensorTrace} is freely available at\n\\url{https://www.tensortrace.com} with versions for Windows, Mac and Ubuntu.\n", "versions": [{"version": "v1", "created": "Wed, 6 Nov 2019 18:57:01 GMT"}], "update_date": "2019-11-07", "authors_parsed": [["Evenbly", "Glen", ""]]}, {"id": "1911.04488", "submitter": "Cody Permann", "authors": "Cody J. Permann, Derek R. Gaston, David Andrs, Robert W. Carlsen,\n  Fande Kong, Alexander D. Lindsay, Jason M. Miller, John W. Peterson, Andrew\n  E. Slaughter, Roy H. Stogner, Richard C. Martineau", "title": "MOOSE: Enabling Massively Parallel Multiphysics Simulation", "comments": "10 Pages of content, 2 Figures, 30 References", "journal-ref": "SoftwareX. 11 (2020) 100430", "doi": "10.1016/j.softx.2020.100430", "report-no": null, "categories": "cs.MS physics.comp-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Harnessing modern parallel computing resources to achieve complex\nmulti-physics simulations is a daunting task. The Multiphysics Object Oriented\nSimulation Environment (MOOSE) aims to enable such development by providing\nsimplified interfaces for specification of partial differential equations,\nboundary conditions, material properties, and all aspects of a simulation\nwithout the need to consider the parallel, adaptive, nonlinear, finite-element\nsolve that is handled internally. Through the use of interfaces and\ninheritance, each portion of a simulation becomes reusable and composable in a\nmanner that allows disparate research groups to share code and create an\necosystem of growing capability that lowers the barrier for the creation of\nmultiphysics simulation codes. Included within the framework is a unique\ncapability for building multiscale, multiphysics simulations through\nsimultaneous execution of multiple sub-applications with data transfers between\nthe scales. Other capabilities include automatic differentiation, scaling to a\nlarge number of processors, hybrid parallelism, and mesh adaptivity. To date,\nMOOSE-based applications have been created in areas of science and engineering\nsuch as nuclear physics, geothermal science, magneto-hydrodynamics, seismic\nevents, compressible and incompressible fluid flow, microstructure evolution,\nand advanced manufacturing processes.\n", "versions": [{"version": "v1", "created": "Mon, 11 Nov 2019 18:20:43 GMT"}], "update_date": "2020-03-10", "authors_parsed": [["Permann", "Cody J.", ""], ["Gaston", "Derek R.", ""], ["Andrs", "David", ""], ["Carlsen", "Robert W.", ""], ["Kong", "Fande", ""], ["Lindsay", "Alexander D.", ""], ["Miller", "Jason M.", ""], ["Peterson", "John W.", ""], ["Slaughter", "Andrew E.", ""], ["Stogner", "Roy H.", ""], ["Martineau", "Richard C.", ""]]}, {"id": "1911.06055", "submitter": "Fernando Morales", "authors": "Fernando A. Morales", "title": "The RaPID-OMEGA system: Room and Proctor Intelligent Decider for large\n  scale tests programming", "comments": "21 pages, 12 tables", "journal-ref": "Yugolav Journal of Operations Research, 2020", "doi": "10.2298/YJOR191115019M", "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present the mathematical modeling for the problem of choosing rooms and\nproctoring crews for massive tests, together with its implementation as the\nopen-box system RaPID-Omega. The mathematical model is a binary integer\nprogramming problem: a combination of the 0-1 Knapsack problem and the\njob-assignment problem. The model makes decisions according the following\ncriteria in order of priority: minimization of labor-hours, maximization of\nequity in the distribution of duties and maximization of the proctoring\nquality. The software is a digital solution for the aforementioned problem,\nwhich is a common need in educational institutions offering large, coordinated,\nlower-division courses. The system can be downloaded from\n\\url{https://sites.google.com/a/unal.edu.co/fernando-a-morales-j/home/research/software}\n", "versions": [{"version": "v1", "created": "Thu, 14 Nov 2019 12:09:31 GMT"}, {"version": "v2", "created": "Mon, 18 Nov 2019 18:59:38 GMT"}, {"version": "v3", "created": "Thu, 9 Apr 2020 21:22:17 GMT"}, {"version": "v4", "created": "Thu, 16 Jul 2020 14:05:28 GMT"}, {"version": "v5", "created": "Fri, 17 Jul 2020 14:11:37 GMT"}], "update_date": "2020-08-26", "authors_parsed": [["Morales", "Fernando A.", ""]]}, {"id": "1911.06817", "submitter": "Anne Reinarz", "authors": "Jean-Matthieu Gallard, Lukas Krenz, Leonhard Rannabauer, Anne Reinarz,\n  Michael Bader", "title": "Role-Oriented Code Generation in an Engine for Solving Hyperbolic PDE\n  Systems", "comments": "SC19 SE-HER", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.SE", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  The development of a high performance PDE solver requires the combined\nexpertise of interdisciplinary teams with respect to application domain,\nnumerical scheme and low-level optimization. In this paper, we present how the\nExaHyPE engine facilitates the collaboration of such teams by isolating three\nroles: application, algorithms, and optimization expert. We thus support team\nmembers in letting them focus on their own area of expertise while integrating\ntheir contributions into an HPC production code. Inspired by web application\ndevelopment practices, ExaHyPE relies on two custom code generation modules,\nthe Toolkit and the Kernel Generator, which follow a Model-View-Controller\narchitectural pattern on top of the Jinja2 template engine library. Using\nJinja2's templates to abstract the critical components of the engine and\ngenerated glue code, we isolate the application development from the engine.\nThe template language also allows us to define and use custom template macros\nthat isolate low-level optimizations from the numerical scheme described in the\ntemplates. We present three use cases, each focusing on one of our user roles,\nshowcasing how the design of the code generation modules allows to easily\nexpand the solver schemes to support novel demands from applications, to add\noptimized algorithmic schemes (with reduced memory footprint, e.g.), or provide\nimproved low-level SIMD vectorization support.\n", "versions": [{"version": "v1", "created": "Fri, 15 Nov 2019 10:07:24 GMT"}, {"version": "v2", "created": "Sat, 28 Mar 2020 13:21:09 GMT"}], "update_date": "2020-03-31", "authors_parsed": [["Gallard", "Jean-Matthieu", ""], ["Krenz", "Lukas", ""], ["Rannabauer", "Leonhard", ""], ["Reinarz", "Anne", ""], ["Bader", "Michael", ""]]}, {"id": "1911.07531", "submitter": "Ronald Kriemann", "authors": "Steffen B\\\"orm, Sven Christophersen, Ronald Kriemann", "title": "Semi-Automatic Task Graph Construction for $\\mathcal{H}$-Matrix\n  Arithmetic", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A new method to construct task graphs for \\mcH-matrix arithmetic is\nintroduced, which uses the information associated with all tasks of the\nstandard recursive \\mcH-matrix algorithms, e.g., the block index set of the\nmatrix blocks involved in the computation. Task refinement, i.e., the\nreplacement of tasks by sub-computations, is then used to proceed in the\n\\mcH-matrix hierarchy until the matrix blocks containing the actual matrix data\nare reached. This process is a natural extension of the classical, recursive\nway in which \\mcH-matrix arithmetic is defined and thereby simplifies the\nefficient usage of many-core systems. Examples for standard and accumulator\nbased \\mcH-arithmetic are shown for model problems with different block\nstructures.\n", "versions": [{"version": "v1", "created": "Mon, 18 Nov 2019 10:36:43 GMT"}], "update_date": "2019-11-19", "authors_parsed": [["B\u00f6rm", "Steffen", ""], ["Christophersen", "Sven", ""], ["Kriemann", "Ronald", ""]]}, {"id": "1911.09220", "submitter": "Will Pazner", "authors": "Robert Anderson, Julian Andrej, Andrew Barker, Jamie Bramwell,\n  Jean-Sylvain Camier, Jakub Cerveny, Veselin Dobrev, Yohann Dudouit, Aaron\n  Fisher, Tzanio Kolev, Will Pazner, Mark Stowell, Vladimir Tomov, Johann Dahm,\n  David Medina, Stefano Zampini", "title": "MFEM: a modular finite element methods library", "comments": "36 pages, 21 figures", "journal-ref": null, "doi": "10.1016/j.camwa.2020.06.009", "report-no": null, "categories": "cs.MS cs.NA math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  MFEM is an open-source, lightweight, flexible and scalable C++ library for\nmodular finite element methods that features arbitrary high-order finite\nelement meshes and spaces, support for a wide variety of discretization\napproaches and emphasis on usability, portability, and high-performance\ncomputing efficiency. MFEM's goal is to provide application scientists with\naccess to cutting-edge algorithms for high-order finite element meshing,\ndiscretizations and linear solvers, while enabling researchers to quickly and\neasily develop and test new algorithms in very general, fully unstructured,\nhigh-order, parallel and GPU-accelerated settings. In this paper we describe\nthe underlying algorithms and finite element abstractions provided by MFEM,\ndiscuss the software implementation, and illustrate various applications of the\nlibrary.\n", "versions": [{"version": "v1", "created": "Wed, 20 Nov 2019 23:49:09 GMT"}, {"version": "v2", "created": "Mon, 13 Jul 2020 18:16:51 GMT"}], "update_date": "2020-07-15", "authors_parsed": [["Anderson", "Robert", ""], ["Andrej", "Julian", ""], ["Barker", "Andrew", ""], ["Bramwell", "Jamie", ""], ["Camier", "Jean-Sylvain", ""], ["Cerveny", "Jakub", ""], ["Dobrev", "Veselin", ""], ["Dudouit", "Yohann", ""], ["Fisher", "Aaron", ""], ["Kolev", "Tzanio", ""], ["Pazner", "Will", ""], ["Stowell", "Mark", ""], ["Tomov", "Vladimir", ""], ["Dahm", "Johann", ""], ["Medina", "David", ""], ["Zampini", "Stefano", ""]]}, {"id": "1911.09421", "submitter": "Christos Psarras M.Sc.", "authors": "Christos Psarras, Henrik Barthels and Paolo Bientinesi", "title": "The Linear Algebra Mapping Problem", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We observe a disconnect between the developers and the end users of linear\nalgebra libraries. On the one hand, the numerical linear algebra and the\nhigh-performance communities invest significant effort in the development and\noptimization of highly sophisticated numerical kernels and libraries, aiming at\nthe maximum exploitation of both the properties of the input matrices, and the\narchitectural features of the target computing platform. On the other hand, end\nusers are progressively less likely to go through the error-prone and time\nconsuming process of directly using said libraries by writing their code in C\nor Fortran; instead, languages and libraries such as Matlab, Julia, Eigen and\nArmadillo, which offer a higher level of abstraction, are becoming more and\nmore popular. Users are given the opportunity to code matrix computations with\na syntax that closely resembles the mathematical description; it is then a\ncompiler or an interpreter that internally maps the input program to lower\nlevel kernels, as provided by libraries such as BLAS and LAPACK. Unfortunately,\nour experience suggests that in terms of performance, this translation is\ntypically vastly suboptimal.\n  In this paper, we first introduce the Linear Algebra Mapping Problem, and\nthen investigate how effectively a benchmark of test problems is solved by\npopular high-level programming languages. Specifically, we consider Matlab,\nOctave, Julia, R, Armadillo (C++), Eigen (C++), and NumPy (Python); the\nbenchmark is meant to test both standard compiler optimizations such as common\nsubexpression elimination and loop-invariant code motion, as well as linear\nalgebra specific optimizations such as optimal parenthesization of a matrix\nproduct and kernel selection for matrices with properties. The aim of this\nstudy is to give concrete guidelines for the development of languages and\nlibraries that support linear algebra computations.\n", "versions": [{"version": "v1", "created": "Thu, 21 Nov 2019 11:42:14 GMT"}], "update_date": "2019-11-22", "authors_parsed": [["Psarras", "Christos", ""], ["Barthels", "Henrik", ""], ["Bientinesi", "Paolo", ""]]}, {"id": "1911.10139", "submitter": "Qiao Chen", "authors": "Qiao Chen, Aditi Ghai, Xiangmin Jiao", "title": "HILUCSI: Simple, Robust, and Fast Multilevel ILU for Large-Scale\n  Saddle-Point Problems from PDEs", "comments": "Submitted to Numerical Linear Algebra with Applications (NLAA)", "journal-ref": "Numerical Linear Algebra with Applications (2021)", "doi": "10.1002/nla.2400", "report-no": null, "categories": "math.NA cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Incomplete factorization is a widely used preconditioning technique for\nKrylov subspace methods for solving large-scale sparse linear systems. Its\nmultilevel variants, such as ILUPACK, are more robust for many symmetric or\nunsymmetric linear systems than the traditional, single-level incomplete LU (or\nILU) techniques. However, the previous multilevel ILU techniques still lacked\nrobustness and efficiency for some large-scale saddle-point problems, which\noften arise from systems of partial differential equations (PDEs). We introduce\nHILUCSI, or Hierarchical Incomplete LU-Crout with Scalability-oriented and\nInverse-based dropping. As a multilevel preconditioner, HILUCSI statically and\ndynamically permutes individual rows and columns to the next level for deferred\nfactorization. Unlike ILUPACK, HILUCSI applies symmetric preprocessing\ntechniques at the top levels but always uses unsymmetric preprocessing and\nunsymmetric factorization at the coarser levels. The deferring combined with\nmixed preprocessing enabled a unified treatment for nearly or partially\nsymmetric systems, and simplified the implementation by avoiding mixed $1\\times\n1$ and $2\\times 2$ pivots for symmetric indefinite systems. We show that this\ncombination improves robustness for indefinite systems without compromising\nefficiency. Furthermore, to enable superior efficiency for large-scale systems\nwith millions or more unknowns, HILUCSI introduces a scalability-oriented\ndropping in conjunction with a variant of inverse-based dropping. We\ndemonstrate the effectiveness of HILUCSI for dozens of benchmark problems,\nincluding those from the mixed formulation of the Poisson equation, Stokes\nequations, and Navier-Stokes equations. We also compare its performance with\nILUPACK, the supernodal ILUTP in SuperLU, and multithreaded direct solvers in\nPARDISO and MUMPS.\n", "versions": [{"version": "v1", "created": "Fri, 22 Nov 2019 16:59:53 GMT"}, {"version": "v2", "created": "Mon, 16 Dec 2019 17:06:06 GMT"}, {"version": "v3", "created": "Mon, 27 Apr 2020 20:03:38 GMT"}, {"version": "v4", "created": "Fri, 22 Jan 2021 21:54:31 GMT"}, {"version": "v5", "created": "Fri, 28 May 2021 14:13:29 GMT"}], "update_date": "2021-05-31", "authors_parsed": [["Chen", "Qiao", ""], ["Ghai", "Aditi", ""], ["Jiao", "Xiangmin", ""]]}, {"id": "1911.10930", "submitter": "Nikolai Kosmatov", "authors": "Maxime Jacquemin, Fonenantsoa Maurica, Nikolai Kosmatov, Julien\n  Signoles, Franck V\\'edrine", "title": "Abstract Compilation for Verification of Numerical Accuracy Properties", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SE cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Verification of numerical accuracy properties in modern software remains an\nimportant and challenging task. This paper describes an original framework\ncombining different solutions for numerical accuracy. First, we extend an\nexisting runtime verification tool called E-ACSL with rational numbers to\nmonitor accuracy properties at runtime. Second, we present an abstract\ncompiler, FLDCompiler, that performs a source-to-source transformation such\nthat the execution of the resulting program, called an abstract execution, is\nan abstract interpretation of the initial program. Third, we propose an\ninstrumentation library FLDLib that formally propagates accuracy properties\nalong an abstract execution. While each of these solutions has its own\ninterest, we emphasize the benefits of their combination for an industrial\nsetting. Initial experiments show that the proposed technique can efficiently\nand soundly analyze the accuracy of industrial programs by restricting the\nanalysis on thin numerical scenarios.\n", "versions": [{"version": "v1", "created": "Mon, 25 Nov 2019 14:23:44 GMT"}], "update_date": "2019-11-26", "authors_parsed": [["Jacquemin", "Maxime", ""], ["Maurica", "Fonenantsoa", ""], ["Kosmatov", "Nikolai", ""], ["Signoles", "Julien", ""], ["V\u00e9drine", "Franck", ""]]}, {"id": "1911.12604", "submitter": "Patrick Peltzer", "authors": "Patrick Peltzer, Johannes Lotz, Uwe Naumann", "title": "Eigen-AD: Algorithmic Differentiation of the Eigen Library", "comments": "Updated with accepted version for ICCS 2020 conference proceedings.\n  The final authenticated publication is available online at\n  https://doi.org/10.1007/978-3-030-50371-0_51. See v1 for the original,\n  extended preprint. 14 pages, 7 figures", "journal-ref": "Computational Science - ICCS 2020: 20th International Conference,\n  Amsterdam, The Netherlands, June 3-5, 2020, Proceedings, Part I, 12137,\n  690-704", "doi": "10.1007/978-3-030-50371-0_51", "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this work we present useful techniques and possible enhancements when\napplying an Algorithmic Differentiation (AD) tool to the linear algebra library\nEigen using our in-house AD by overloading (AD-O) tool dco/c++ as a case study.\nAfter outlining performance and feasibility issues when calculating derivatives\nfor the official Eigen release, we propose Eigen-AD, which enables different\noptimization options for an AD-O tool by providing add-on modules for Eigen.\nThe range of features includes a better handling of expression templates for\ngeneral performance improvements, as well as implementations of symbolically\nderived expressions for calculating derivatives of certain core operations. The\nsoftware design allows an AD-O tool to provide specializations to automatically\ninclude symbolic operations and thereby keep the look and feel of plain AD by\noverloading. As a showcase, dco/c++ is provided with such a module and its\nsignificant performance improvements are validated by benchmarks.\n", "versions": [{"version": "v1", "created": "Thu, 28 Nov 2019 09:07:08 GMT"}, {"version": "v2", "created": "Mon, 22 Jun 2020 12:42:13 GMT"}], "update_date": "2020-06-23", "authors_parsed": [["Peltzer", "Patrick", ""], ["Lotz", "Johannes", ""], ["Naumann", "Uwe", ""]]}, {"id": "1911.13027", "submitter": "Robert Speck", "authors": "Robert Speck and Michael Knobloch and Sebastian L\\\"uhrs and Andreas\n  Gocht", "title": "Using performance analysis tools for parallel-in-time integrators --\n  Does my time-parallel code do what I think it does?", "comments": "31 pages, 15 figures, CVS Proceedings of the 9th PinT Workshop", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PF cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  While many ideas and proofs of concept for parallel-in-time integration\nmethods exists, the number of large-scale, accessible time-parallel codes is\nrather small. This is often due to the apparent or subtle complexity of the\nalgorithms and the many pitfalls awaiting developers of parallel numerical\nsoftware. One example of such a time-parallel code is pySDC, which implements,\namong others, the parallel full approximation scheme in space and time\n(PFASST). Inspired by nonlinear multigrid ideas, PFASST allows to integrate\nmultiple time-steps simultaneously using a space-time hierarchy of spectral\ndeferred corrections. In this paper we demonstrate the application of\nperformance analysis tools to the PFASST implementation pySDC. Tracing the path\nwe took for this work, we highlight the obstacles encountered, describe\nremedies and explain the sometimes surprising findings made possible by the\ntools. Although focusing only on a single implementation of a particular\nparallel-in-time integrator, we hope that our results and in particular the way\nwe obtained them are a blueprint for other time-parallel codes.\n", "versions": [{"version": "v1", "created": "Fri, 29 Nov 2019 09:58:23 GMT"}, {"version": "v2", "created": "Fri, 28 Aug 2020 12:32:34 GMT"}], "update_date": "2020-08-31", "authors_parsed": [["Speck", "Robert", ""], ["Knobloch", "Michael", ""], ["L\u00fchrs", "Sebastian", ""], ["Gocht", "Andreas", ""]]}]