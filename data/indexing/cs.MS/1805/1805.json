[{"id": "1805.01407", "submitter": "Sebastiano Vigna", "authors": "David Blackman, Sebastiano Vigna", "title": "Scrambled Linear Pseudorandom Number Generators", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.CR cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Linear pseudorandom number generators are very popular due to their high\nspeed, to the ease with which generators with a sizable state space can be\ncreated, and to their provable theoretical properties. However, they suffer\nfrom linear artifacts which show as failures in linearity-related statistical\ntests such as the binary-rank and the linear-complexity test. In this paper, we\ngive three new contributions. First, we introduce two new linear\ntransformations that have been handcrafted to have good statistical properties\nand at the same time to be programmable very efficiently on superscalar\nprocessors, or even directly in hardware. Then, we describe a new test for\nHamming-weight dependencies that is able to discover subtle, previously unknown\nbiases in existing generators (in particular, in linear ones). Finally, we\ndescribe a number of scramblers, that is, nonlinear functions applied to the\nstate array that reduce or delete the linear artifacts, and propose\ncombinations of linear transformations and scramblers that give extremely fast\npseudorandom generators of high quality. A novelty in our approach is that we\nuse ideas from the theory of filtered linear-feedback shift register to prove\nsome properties of our scramblers, rather than relying purely on heuristics. In\nthe end, we provide simple, extremely fast generators that use a few hundred\nbits of memory, have provable properties and pass very strong statistical\ntests.\n", "versions": [{"version": "v1", "created": "Thu, 3 May 2018 16:22:23 GMT"}, {"version": "v2", "created": "Thu, 1 Aug 2019 11:01:41 GMT"}], "update_date": "2019-08-02", "authors_parsed": [["Blackman", "David", ""], ["Vigna", "Sebastiano", ""]]}, {"id": "1805.02201", "submitter": "Victor Magron", "authors": "Victor Magron and Mohab Safey El Din", "title": "RealCertify: a Maple package for certifying non-negativity", "comments": "4 pages, 2 tables", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.SC cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Let $\\mathbb{Q}$ (resp. $\\mathbb{R}$) be the field of rational (resp. real)\nnumbers and $X = (X_1, \\ldots, X_n)$ be variables. Deciding the non-negativity\nof polynomials in $\\mathbb{Q}[X]$ over $\\mathbb{R}^n$ or over semi-algebraic\ndomains defined by polynomial constraints in $\\mathbb{Q}[X]$ is a classical\nalgorithmic problem for symbolic computation.\n  The Maple package \\textsc{RealCertify} tackles this decision problem by\ncomputing sum of squares certificates of non-negativity for inputs where such\ncertificates hold over the rational numbers. It can be applied to numerous\nproblems coming from engineering sciences, program verification and\ncyber-physical systems. It is based on hybrid symbolic-numeric algorithms based\non semi-definite programming.\n", "versions": [{"version": "v1", "created": "Sun, 6 May 2018 12:31:55 GMT"}], "update_date": "2018-05-08", "authors_parsed": [["Magron", "Victor", ""], ["Din", "Mohab Safey El", ""]]}, {"id": "1805.03380", "submitter": "Conrad Sanderson", "authors": "Conrad Sanderson, Ryan Curtin", "title": "A User-Friendly Hybrid Sparse Matrix Class in C++", "comments": null, "journal-ref": "Lecture Notes in Computer Science (LNCS), Vol. 10931, pp. 422-430,\n  2018", "doi": "10.1007/978-3-319-96418-8_50", "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  When implementing functionality which requires sparse matrices, there are\nnumerous storage formats to choose from, each with advantages and\ndisadvantages. To achieve good performance, several formats may need to be used\nin one program, requiring explicit selection and conversion between the\nformats. This can be both tedious and error-prone, especially for non-expert\nusers. Motivated by this issue, we present a user-friendly sparse matrix class\nfor the C++ language, with a high-level application programming interface\ndeliberately similar to the widely used MATLAB language. The class internally\nuses two main approaches to achieve efficient execution: (i) a hybrid storage\nframework, which automatically and seamlessly switches between three underlying\nstorage formats (compressed sparse column, coordinate list, Red-Black tree)\ndepending on which format is best suited for specific operations, and (ii)\ntemplate-based meta-programming to automatically detect and optimise execution\nof common expression patterns. To facilitate relatively quick conversion of\nresearch code into production environments, the class and its associated\nfunctions provide a suite of essential sparse linear algebra functionality\n(eg., arithmetic operations, submatrix manipulation) as well as high-level\nfunctions for sparse eigendecompositions and linear equation solvers. The\nlatter are achieved by providing easy-to-use abstractions of the low-level\nARPACK and SuperLU libraries. The source code is open and provided under the\npermissive Apache 2.0 license, allowing unencumbered use in commercial\nproducts.\n", "versions": [{"version": "v1", "created": "Wed, 9 May 2018 05:49:05 GMT"}, {"version": "v2", "created": "Thu, 26 Jul 2018 03:43:22 GMT"}, {"version": "v3", "created": "Mon, 21 Oct 2019 08:27:42 GMT"}], "update_date": "2019-10-22", "authors_parsed": [["Sanderson", "Conrad", ""], ["Curtin", "Ryan", ""]]}, {"id": "1805.03949", "submitter": "Guillaume Houzeaux", "authors": "Marta Garcia-Gasulla, Guillaume Houzeaux, Roger Ferrer, Antoni\n  Artigues, Victor L\\'opez, Jes\\'us Labarta and Mariano V\\'azquez", "title": "MPI+X: task-based parallelization and dynamic load balance of finite\n  element assembly", "comments": null, "journal-ref": null, "doi": "10.1080/10618562.2019.1617856", "report-no": null, "categories": "cs.MS cs.DC cs.PF cs.PL", "license": "http://creativecommons.org/licenses/by-nc-sa/4.0/", "abstract": "  The main computing tasks of a finite element code(FE) for solving partial\ndifferential equations (PDE's) are the algebraic system assembly and the\niterative solver. This work focuses on the first task, in the context of a\nhybrid MPI+X paradigm. Although we will describe algorithms in the FE context,\na similar strategy can be straightforwardly applied to other discretization\nmethods, like the finite volume method. The matrix assembly consists of a loop\nover the elements of the MPI partition to compute element matrices and\nright-hand sides and their assemblies in the local system to each MPI\npartition. In a MPI+X hybrid parallelism context, X has consisted traditionally\nof loop parallelism using OpenMP. Several strategies have been proposed in the\nliterature to implement this loop parallelism, like coloring or substructuring\ntechniques to circumvent the race condition that appears when assembling the\nelement system into the local system. The main drawback of the first technique\nis the decrease of the IPC due to bad spatial locality. The second technique\navoids this issue but requires extensive changes in the implementation, which\ncan be cumbersome when several element loops should be treated. We propose an\nalternative, based on the task parallelism of the element loop using some\nextensions to the OpenMP programming model. The taskification of the assembly\nsolves both aforementioned problems. In addition, dynamic load balance will be\napplied using the DLB library, especially efficient in the presence of hybrid\nmeshes, where the relative costs of the different elements is impossible to\nestimate a priori. This paper presents the proposed methodology, its\nimplementation and its validation through the solution of large computational\nmechanics problems up to 16k cores.\n", "versions": [{"version": "v1", "created": "Wed, 9 May 2018 16:01:01 GMT"}], "update_date": "2019-05-28", "authors_parsed": [["Garcia-Gasulla", "Marta", ""], ["Houzeaux", "Guillaume", ""], ["Ferrer", "Roger", ""], ["Artigues", "Antoni", ""], ["L\u00f3pez", "Victor", ""], ["Labarta", "Jes\u00fas", ""], ["V\u00e1zquez", "Mariano", ""]]}, {"id": "1805.04775", "submitter": "Paolo Bientinesi", "authors": "Daniele G. Spampinato (1), Diego Fabregat-Traver (2), Paolo Bientinesi\n  (2), Markus Pueschel (1), ((1) ETH Zurich, (2) RWTH Aachen University)", "title": "Program Generation for Small-Scale Linear Algebra Applications", "comments": "CGO 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present SLinGen, a program generation system for linear algebra. The input\nto SLinGen is an application expressed mathematically in a\nlinear-algebra-inspired language (LA) that we define. LA provides basic\nscalar/vector/matrix additions/multiplications and higher level operations\nincluding linear systems solvers, Cholesky and LU factorizations. The output of\nSLinGen is performance-optimized single-source C code, optionally vectorized\nwith intrinsics. The target of SLinGen are small-scale computations on\nfixed-size operands, for which a straightforward implementation using optimized\nlibraries (e.g., BLAS or LAPACK) is known to yield suboptimal performance\n(besides increasing code size and introducing dependencies), but which are\ncrucial in control, signal processing, computer vision, and other domains.\nInternally, SLinGen uses synthesis and DSL-based techniques to optimize at a\nhigh level of abstraction. We benchmark our program generator on three\nprototypical applications: the Kalman filter, Gaussian process regression, and\nan L1-analysis convex solver, as well as basic routines including Cholesky\nfactorization and solvers for the continuous-time Lyapunov and Sylvester\nequations. The results show significant speed-ups compared to straightforward C\nwith Intel icc and clang with a polyhedral optimizer, as well as library-based\nand template-based implementations.\n", "versions": [{"version": "v1", "created": "Sat, 12 May 2018 20:21:40 GMT"}], "update_date": "2018-05-15", "authors_parsed": [["Spampinato", "Daniele G.", "", "ETH Zurich"], ["Fabregat-Traver", "Diego", "", "RWTH Aachen University"], ["Bientinesi", "Paolo", "", "RWTH Aachen University"], ["Pueschel", "Markus", "", "ETH Zurich"]]}, {"id": "1805.05121", "submitter": "Mathias Soeken", "authors": "Mathias Soeken, Heinz Riener, Winston Haaswijk, Eleonora Testa, Bruno\n  Schmitt, Giulia Meuli, Fereshte Mozafari, Giovanni De Micheli", "title": "The EPFL Logic Synthesis Libraries", "comments": "11 pages, originally accepted at Int'l Workshop on Logic & Synthesis\n  2018, extended for Workshop on Open-Source EDA Technology 2019", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a collection of modular open source C++ libraries for the\ndevelopment of logic synthesis applications. These libraries can be used to\ndevelop applications for the design of classical and emerging technologies, as\nwell as for the implementation of quantum compilers. All libraries are well\ndocumented and well tested. Furthermore, being header-only, the libraries can\nbe readily used as core components in complex logic synthesis systems.\n", "versions": [{"version": "v1", "created": "Mon, 14 May 2018 11:34:47 GMT"}, {"version": "v2", "created": "Wed, 6 Nov 2019 14:02:30 GMT"}], "update_date": "2019-11-07", "authors_parsed": [["Soeken", "Mathias", ""], ["Riener", "Heinz", ""], ["Haaswijk", "Winston", ""], ["Testa", "Eleonora", ""], ["Schmitt", "Bruno", ""], ["Meuli", "Giulia", ""], ["Mozafari", "Fereshte", ""], ["De Micheli", "Giovanni", ""]]}, {"id": "1805.08308", "submitter": "Nina Miolane", "authors": "Nina Miolane, Johan Mathe, Claire Donnat, Mikael Jorda, Xavier Pennec", "title": "geomstats: a Python Package for Riemannian Geometry in Machine Learning", "comments": "Preprint NIPS2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.LG cs.MS stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We introduce geomstats, a python package that performs computations on\nmanifolds such as hyperspheres, hyperbolic spaces, spaces of symmetric positive\ndefinite matrices and Lie groups of transformations. We provide efficient and\nextensively unit-tested implementations of these manifolds, together with\nuseful Riemannian metrics and associated Exponential and Logarithm maps. The\ncorresponding geodesic distances provide a range of intuitive choices of\nMachine Learning loss functions. We also give the corresponding Riemannian\ngradients. The operations implemented in geomstats are available with different\ncomputing backends such as numpy, tensorflow and keras. We have enabled GPU\nimplementation and integrated geomstats manifold computations into keras deep\nlearning framework. This paper also presents a review of manifolds in machine\nlearning and an overview of the geomstats package with examples demonstrating\nits use for efficient and user-friendly Riemannian geometry.\n", "versions": [{"version": "v1", "created": "Mon, 21 May 2018 22:24:14 GMT"}, {"version": "v2", "created": "Tue, 6 Nov 2018 01:28:54 GMT"}], "update_date": "2018-11-07", "authors_parsed": [["Miolane", "Nina", ""], ["Mathe", "Johan", ""], ["Donnat", "Claire", ""], ["Jorda", "Mikael", ""], ["Pennec", "Xavier", ""]]}, {"id": "1805.08846", "submitter": "David Ketcheson", "authors": "H. Gorune Ohannessian and George Turkiyyah and Aron Ahmadia and David\n  Ketcheson", "title": "CUDACLAW: A high-performance programmable GPU framework for the solution\n  of hyperbolic PDEs", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present cudaclaw, a CUDA-based high performance data-parallel framework\nfor the solution of multidimensional hyperbolic partial differential equation\n(PDE) systems, equations describing wave motion. cudaclaw allows computational\nscientists to solve such systems on GPUs without being burdened by the need to\nwrite CUDA code, worry about thread and block details, data layout, and data\nmovement between the different levels of the memory hierarchy. The user defines\nthe set of PDEs to be solved via a CUDA- independent serial Riemann solver and\nthe framework takes care of orchestrating the computations and data transfers\nto maximize arithmetic throughput. cudaclaw treats the different spatial\ndimensions separately to allow suitable block sizes and dimensions to be used\nin the different directions, and includes a number of optimizations to minimize\naccess to global memory.\n", "versions": [{"version": "v1", "created": "Mon, 21 May 2018 14:21:51 GMT"}], "update_date": "2018-05-24", "authors_parsed": [["Ohannessian", "H. Gorune", ""], ["Turkiyyah", "George", ""], ["Ahmadia", "Aron", ""], ["Ketcheson", "David", ""]]}, {"id": "1805.10121", "submitter": "Edoardo di Napoli", "authors": "Jan Winkelmann (1) and Paul Springer (1) and Edoardo Di Napoli (1 and\n  2) ((1) AICES, RWTH Aachen University, (2) JSC, Forschungszentrum J\\\"ulich)", "title": "ChASE: Chebyshev Accelerated Subspace iteration Eigensolver for\n  sequences of Hermitian eigenvalue problems", "comments": "33 pages. Submitted to ACM TOMS", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.CE cs.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Solving dense Hermitian eigenproblems arranged in a sequence with direct\nsolvers fails to take advantage of those spectral properties which are\npertinent to the entire sequence, and not just to the single problem. When such\nfeatures take the form of correlations between the eigenvectors of consecutive\nproblems, as is the case in many real-world applications, the potential benefit\nof exploiting them can be substantial. We present ChASE, a modern algorithm and\nlibrary based on subspace iteration with polynomial acceleration. Novel to\nChASE is the computation of the spectral estimates that enter in the filter and\nan optimization of the polynomial degree which further reduces the necessary\nFLOPs. ChASE is written in C++ using the modern software engineering concepts\nwhich favor a simple integration in application codes and a straightforward\nportability over heterogeneous platforms. When solving sequences of Hermitian\neigenproblems for a portion of their extremal spectrum, ChASE greatly benefits\nfrom the sequence's spectral properties and outperforms direct solvers in many\nscenarios. The library ships with two distinct parallelization schemes,\nsupports execution over distributed GPUs, and it is easily extensible to other\nparallel computing architectures.\n", "versions": [{"version": "v1", "created": "Fri, 25 May 2018 12:56:18 GMT"}], "update_date": "2018-05-29", "authors_parsed": [["Winkelmann", "Jan", "", "AICES, RWTH Aachen University"], ["Springer", "Paul", "", "AICES, RWTH Aachen University"], ["Di Napoli", "Edoardo", "", "1 and\n  2"]]}, {"id": "1805.10167", "submitter": "Dominik Bartuschat", "authors": "Nils Kohl, Dominik Th\\\"onnes, Daniel Drzisga, Dominik Bartuschat, and\n  Ulrich R\\\"ude", "title": "A Scalable and Modular Software Architecture for Finite Elements on\n  Hierarchical Hybrid Grids", "comments": "Preprint of an article submitted to International Journal of\n  Parallel, Emergent and Distributed Systems (Taylor & Francis)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this article, a new generic higher-order finite-element framework for\nmassively parallel simulations is presented. The modular software architecture\nis carefully designed to exploit the resources of modern and future\nsupercomputers. Combining an unstructured topology with structured grid\nrefinement facilitates high geometric adaptability and matrix-free multigrid\nimplementations with excellent performance. Different abstraction levels and\nfully distributed data structures additionally ensure high flexibility,\nextensibility, and scalability. The software concepts support sophisticated\nload balancing and flexibly combining finite element spaces. Example scenarios\nwith coupled systems of PDEs show the applicability of the concepts to\nperforming geophysical simulations.\n", "versions": [{"version": "v1", "created": "Fri, 25 May 2018 14:10:59 GMT"}], "update_date": "2018-05-28", "authors_parsed": [["Kohl", "Nils", ""], ["Th\u00f6nnes", "Dominik", ""], ["Drzisga", "Daniel", ""], ["Bartuschat", "Dominik", ""], ["R\u00fcde", "Ulrich", ""]]}, {"id": "1805.10211", "submitter": "Laurent Risser", "authors": "Camille Champion (IMT), Anne-Claire Brunet (IMT), Jean-Michel Loubes\n  (IMT), Laurent Risser (IMT)", "title": "COREclust: a new package for a robust and scalable analysis of complex\n  data", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS stat.CO stat.ML", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper, we present a new R package COREclust dedicated to the\ndetection of representative variables in high dimensional spaces with a\npotentially limited number of observations. Variable sets detection is based on\nan original graph clustering strategy denoted CORE-clustering algorithm that\ndetects CORE-clusters, i.e. variable sets having a user defined size range and\nin which each variable is very similar to at least another variable.\nRepresentative variables are then robustely estimate as the CORE-cluster\ncenters. This strategy is entirely coded in C++ and wrapped by R using the Rcpp\npackage. A particular effort has been dedicated to keep its algorithmic cost\nreasonable so that it can be used on large datasets. After motivating our work,\nwe will explain the CORE-clustering algorithm as well as a greedy extension of\nthis algorithm. We will then present how to use it and results obtained on\nsynthetic and real data.\n", "versions": [{"version": "v1", "created": "Fri, 25 May 2018 15:50:15 GMT"}], "update_date": "2018-05-28", "authors_parsed": [["Champion", "Camille", "", "IMT"], ["Brunet", "Anne-Claire", "", "IMT"], ["Loubes", "Jean-Michel", "", "IMT"], ["Risser", "Laurent", "", "IMT"]]}, {"id": "1805.11007", "submitter": "Maria Bruna", "authors": "Maria Bruna, Philip K. Maini, Martin Robinson", "title": "Particle-based simulations of reaction-diffusion processes with Aboria", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.CE cs.MS q-bio.QM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Mathematical models of transport and reactions in biological systems have\nbeen traditionally written in terms of partial differential equations (PDEs)\nthat describe the time evolution of population-level variables. In recent\nyears, the use of stochastic particle-based models, which keep track of the\nevolution of each organism in the system, has become widespread. These models\nprovide a lot more detail than the population-based PDE models, for example by\nexplicitly modelling particle-particle interactions, but bring with them many\ncomputational challenges. In this paper we overview Aboria, a powerful and\nflexible C++ library for the implementation of numerical methods for\nparticle-based models. We demonstrate the use of Aboria with a commonly used\nmodel in mathematical biology, namely cell chemotaxis. Cells interact with each\nother and diffuse, biased by extracellular chemicals, that can be altered by\nthe cells themselves. We use a hybrid approach where particle-based models of\ncells are coupled with a PDE for the concentration of the extracellular\nchemical.\n", "versions": [{"version": "v1", "created": "Mon, 28 May 2018 16:07:30 GMT"}], "update_date": "2018-05-29", "authors_parsed": [["Bruna", "Maria", ""], ["Maini", "Philip K.", ""], ["Robinson", "Martin", ""]]}, {"id": "1805.11938", "submitter": "Zheng Wang", "authors": "Shizhao Chen, Jianbin Fang, Donglin Chen, Chuanfu Xu, Zheng Wang", "title": "Optimizing Sparse Matrix-Vector Multiplication on Emerging Many-Core\n  Architectures", "comments": "Accepted to be published at HPCC 2018", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://creativecommons.org/licenses/by/4.0/", "abstract": "  Sparse matrix vector multiplication (SpMV) is one of the most common\noperations in scientific and high-performance applications, and is often\nresponsible for the application performance bottleneck. While the sparse matrix\nrepresentation has a significant impact on the resulting application\nperformance, choosing the right representation typically relies on expert\nknowledge and trial and error. This paper provides the first comprehensive\nstudy on the impact of sparse matrix representations on two emerging many-core\narchitectures: the Intel's Knights Landing (KNL) XeonPhi and the ARM-based\nFT-2000Plus (FTP). Our large-scale experiments involved over 9,500 distinct\nprofiling runs performed on 956 sparse datasets and five mainstream SpMV\nrepresentations. We show that the best sparse matrix representation depends on\nthe underlying architecture and the program input. To help developers to choose\nthe optimal matrix representation, we employ machine learning to develop a\npredictive model. Our model is first trained offline using a set of training\nexamples. The learned model can be used to predict the best matrix\nrepresentation for any unseen input for a given architecture. We show that our\nmodel delivers on average 95% and 91% of the best available performance on KNL\nand FTP respectively, and it achieves this with no runtime profiling overhead.\n", "versions": [{"version": "v1", "created": "Tue, 29 May 2018 15:29:30 GMT"}], "update_date": "2018-05-31", "authors_parsed": [["Chen", "Shizhao", ""], ["Fang", "Jianbin", ""], ["Chen", "Donglin", ""], ["Xu", "Chuanfu", ""], ["Wang", "Zheng", ""]]}]