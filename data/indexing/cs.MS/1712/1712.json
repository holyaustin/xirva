[{"id": "1712.01773", "submitter": "Viktor Levandovskyy", "authors": "Johannes Hoffmann, Viktor Levandovskyy", "title": "Constructive Arithmetics in Ore Localizations of Domains", "comments": "24 pages", "journal-ref": "Journal of Symbolic Computation 98 (2020) 23-46", "doi": "10.1016/j.jsc.2019.07.005", "report-no": null, "categories": "math.RA cs.MS cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  For a non-commutative domain $R$ and a multiplicatively closed set $S$ the\n(left) Ore localization of $R$ at $S$ exists if and only if $S$ satisfies the\n(left) Ore property. Since the concept has been introduced by Ore back in the\n1930's, Ore localizations have been widely used in theory and in applications.\nWe investigate the arithmetics of the localized ring $S^{-1}R$ from both\ntheoretical and practical points of view. We show that the key component of the\narithmetics is the computation of the intersection of a left ideal with a\nsubmonoid $S$ of $R$. It is not known yet, whether there exists an algorithmic\nsolution of this problem in general. Still, we provide such solutions for cases\nwhere $S$ is equipped with additional structure by distilling three most\nfrequently occurring types of Ore sets. We introduce the notion of the (left)\nsaturation closure and prove that it is a canonical form for (left) Ore sets in\n$R$. We provide an implementation of arithmetics over the ubiquitous\n$G$-algebras in \\textsc{Singular:Plural} and discuss questions arising in this\ncontext. Numerous examples illustrate the effectiveness of the proposed\napproach.\n", "versions": [{"version": "v1", "created": "Tue, 5 Dec 2017 17:26:19 GMT"}], "update_date": "2020-09-07", "authors_parsed": [["Hoffmann", "Johannes", ""], ["Levandovskyy", "Viktor", ""]]}, {"id": "1712.02329", "submitter": "Stanislav Poslavsky", "authors": "Stanislav Poslavsky", "title": "Rings: an efficient Java/Scala library for polynomial rings", "comments": "Computer Physics Communications (2018)", "journal-ref": null, "doi": "10.1016/j.cpc.2018.09.005", "report-no": null, "categories": "cs.SC cs.MS hep-ph math.AC math.RA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we briefly discuss \\Rings --- an efficient lightweight library\nfor commutative algebra. Polynomial arithmetic, GCDs, polynomial factorization\nand Gr\\\"obner bases are implemented with the use of modern asymptotically fast\nalgorithms. \\Rings can be easily interacted or embedded in applications in\nhigh-energy physics and other research areas via a simple API with fully typed\nhierarchy of algebraic structures and algorithms for commutative algebra. The\nuse of the Scala language brings a quite novel powerful, strongly typed\nfunctional programming model allowing to write short, expressive, and fast code\nfor applications. At the same time Rings shows one of the best performances\namong existing software for algebraic calculations. \\Rings is available from\nhttp://github.com/PoslavskySV/rings\n", "versions": [{"version": "v1", "created": "Wed, 6 Dec 2017 18:52:14 GMT"}, {"version": "v2", "created": "Mon, 18 Dec 2017 22:20:52 GMT"}, {"version": "v3", "created": "Fri, 21 Sep 2018 19:32:48 GMT"}], "update_date": "2018-09-25", "authors_parsed": [["Poslavsky", "Stanislav", ""]]}, {"id": "1712.04076", "submitter": "Thomas Bartz-Beielstein", "authors": "Thomas Bartz-Beielstein and Martin Zaefferer and Frederik Rehbach", "title": "In a Nutshell -- The Sequential Parameter Optimization Toolbox", "comments": "For SPOT Version >= 2.2.24", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.AI math.OC", "license": "http://creativecommons.org/licenses/by-nc-nd/4.0/", "abstract": "  The performance of optimization algorithms relies crucially on their\nparameterizations. Finding good parameter settings is called algorithm tuning.\nThe sequential parameter optimization (SPOT) package for R is a toolbox for\ntuning and understanding simulation and optimization algorithms. Model-based\ninvestigations are common approaches in simulation and optimization. Sequential\nparameter optimization has been developed, because there is a strong need for\nsound statistical analysis of simulation and optimization algorithms. SPOT\nincludes methods for tuning based on classical regression and analysis of\nvariance techniques; tree-based models such as CART and random forest; Gaussian\nprocess models (Kriging), and combinations of different meta-modeling\napproaches. Using a simple simulated annealing algorithm, we will demonstrate\nhow optimization algorithms can be tuned using SPOT. The underling concepts of\nthe SPOT approach are explained. This includes key techniques such as\nexploratory fitness landscape analysis and sensititvity analysis. Many examples\nillustrate how SPOT can be used for understanding the performance of algorithms\nand gaining insight into algorithm's behavior. Furthermore, we demonstrate how\nSPOT can be used as an optimizer and how a sophisticated ensemble approach is\nable to combine several meta models via stacking. This article exemplifies how\nSPOT can be used for automatic and interactive tuning.\n", "versions": [{"version": "v1", "created": "Tue, 12 Dec 2017 00:03:45 GMT"}, {"version": "v2", "created": "Thu, 4 Mar 2021 18:55:44 GMT"}], "update_date": "2021-03-05", "authors_parsed": [["Bartz-Beielstein", "Thomas", ""], ["Zaefferer", "Martin", ""], ["Rehbach", "Frederik", ""]]}, {"id": "1712.07206", "submitter": "Edoardo Di Napoli", "authors": "Davor Davidovi\\'c, Diego Fabregat-Traver, Markus H\\\"ohnerbach, and\n  Edoardo di Napoli", "title": "Accelerating the computation of FLAPW methods on heterogeneous\n  architectures", "comments": "22 pages, submitted to special issue of CCPE", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.CE cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Legacy codes in computational science and engineering have been very\nsuccessful in providing essential functionality to researchers. However, they\nare not capable of exploiting the massive parallelism provided by emerging\nheterogeneous architectures. The lack of portable performance and scalability\nputs them at high risk: either they evolve or they are doomed to disappear. One\nexample of legacy code which would heavily benefit from a modern design is\nFLEUR, a software for electronic structure calculations. In previous work, the\ncomputational bottleneck of FLEUR was partially re-engineered to have a modular\ndesign that relies on standard building blocks, namely BLAS and LAPACK. In this\npaper, we demonstrate how the initial redesign enables the portability to\nheterogeneous architectures. More specifically, we study different approaches\nto port the code to architectures consisting of multi-core CPUs equipped with\none or more coprocessors such as Nvidia GPUs and Intel Xeon Phis. Our final\ncode attains over 70\\% of the architectures' peak performance, and outperforms\nNvidia's and Intel's libraries. Finally, on JURECA, the supercomputer where\nFLEUR is often executed, the code takes advantage of the full power of the\ncomputing nodes, attaining $5\\times$ speedup over the sole use of the CPUs.\n", "versions": [{"version": "v1", "created": "Tue, 19 Dec 2017 20:58:08 GMT"}], "update_date": "2017-12-21", "authors_parsed": [["Davidovi\u0107", "Davor", ""], ["Fabregat-Traver", "Diego", ""], ["H\u00f6hnerbach", "Markus", ""], ["di Napoli", "Edoardo", ""]]}, {"id": "1712.07297", "submitter": "Chao Chen", "authors": "Chao Chen, Hadi Pouransari, Sivasankaran Rajamanickam, Erik G. Boman,\n  Eric Darve", "title": "A distributed-memory hierarchical solver for general sparse linear\n  systems", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NA cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a parallel hierarchical solver for general sparse linear systems\non distributed-memory machines. For large-scale problems, this fully algebraic\nalgorithm is faster and more memory-efficient than sparse direct solvers\nbecause it exploits the low-rank structure of fill-in blocks. Depending on the\naccuracy of low-rank approximations, the hierarchical solver can be used either\nas a direct solver or as a preconditioner. The parallel algorithm is based on\ndata decomposition and requires only local communication for updating boundary\ndata on every processor. Moreover, the computation-to-communication ratio of\nthe parallel algorithm is approximately the volume-to-surface-area ratio of the\nsubdomain owned by every processor. We present various numerical results to\ndemonstrate the versatility and scalability of the parallel algorithm.\n", "versions": [{"version": "v1", "created": "Wed, 20 Dec 2017 02:54:20 GMT"}], "update_date": "2017-12-21", "authors_parsed": [["Chen", "Chao", ""], ["Pouransari", "Hadi", ""], ["Rajamanickam", "Sivasankaran", ""], ["Boman", "Erik G.", ""], ["Darve", "Eric", ""]]}, {"id": "1712.07438", "submitter": "Richard Gerum", "authors": "Richard Gerum, Sebastian Richter, Alexander Winterl, Ben Fabry, Daniel\n  Zitterbart", "title": "CameraTransform: a Scientific Python Package for Perspective Camera\n  Corrections", "comments": "8 pages, 5 figures", "journal-ref": null, "doi": "10.1016/j.softx.2019.100333", "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Scientific applications often require an exact reconstruction of object\npositions and distances from digital images. Therefore, the images need to be\ncorrected for perspective distortions. We present \\textit{CameraTransform}, a\npython package that performs a perspective image correction whereby the height,\ntilt/roll angle and heading of the camera can be automatically obtained from\nthe images if additional information such as GPS coordinates or object sizes\nare provided. We present examples of images of penguin colonies that are\nrecorded with stationary cameras and from a helicopter.\n", "versions": [{"version": "v1", "created": "Wed, 20 Dec 2017 12:13:44 GMT"}], "update_date": "2019-10-04", "authors_parsed": [["Gerum", "Richard", ""], ["Richter", "Sebastian", ""], ["Winterl", "Alexander", ""], ["Fabry", "Ben", ""], ["Zitterbart", "Daniel", ""]]}, {"id": "1712.08162", "submitter": "Valerio Bertone Dr", "authors": "Valerio Bertone and Michiel Botje", "title": "A C++ interface to QCDNUM", "comments": "6 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "hep-ph cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this document we report on the recent development of a C++ interface to\nthe FORTRAN-based evolution program QCDNUM. A short description of the\ninterface is given with a few basic examples of its usage.\n", "versions": [{"version": "v1", "created": "Thu, 21 Dec 2017 08:20:43 GMT"}], "update_date": "2017-12-25", "authors_parsed": [["Bertone", "Valerio", ""], ["Botje", "Michiel", ""]]}, {"id": "1712.10230", "submitter": "Anton Shterenlikht", "authors": "Anton Shterenlikht", "title": "On quality of implementation of Fortran 2008 complex intrinsic functions\n  on branch cuts", "comments": "28 pages, 10 figures, 13 tables, original work", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Branch cuts in complex functions in combination with signed zero and signed\ninfinity have important uses in fracture mechanics, jet flow and aerofoil\nanalysis. We present benchmarks for validating Fortran 2008 complex functions -\nLOG, SQRT, ASIN, ACOS, ATAN, ASINH, ACOSH and ATANH - on branch cuts with\narguments of all 3 IEEE floating point binary formats: binary32, binary64 and\nbinary128. Results are reported with 8 Fortran 2008 compilers: GCC, Flang,\nCray, Oracle, PGI, Intel, NAG and IBM. Multiple test failures were revealed,\ne.g. wrong signs of results or unexpected overflow, underflow, or NaN. We\nconclude that the quality of implementation of these Fortran 2008 intrinsics in\nmany compilers is not yet sufficient to remove the need for special code for\nbranch cuts. The test results are complemented by conformal maps of the branch\ncuts and detailed derivations of the values of these functions on branch cuts,\nto be used as a reference. The benchmarks are freely available from\ncmplx.sf.net. This work will be of interest to engineers who use complex\nfunctions, as well as to compiler and maths library developers.\n", "versions": [{"version": "v1", "created": "Fri, 29 Dec 2017 13:53:03 GMT"}], "update_date": "2018-01-05", "authors_parsed": [["Shterenlikht", "Anton", ""]]}]