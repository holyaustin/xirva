[{"id": "0705.1033", "submitter": "Kebin Wang", "authors": "Michael A. Bender, Bradley C. Kuszmaul, Shang-Hua Teng, Kebin Wang", "title": "Optimal Cache-Oblivious Mesh Layouts", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.CE cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A mesh is a graph that divides physical space into regularly-shaped regions.\nMeshes computations form the basis of many applications, e.g. finite-element\nmethods, image rendering, and collision detection. In one important mesh\nprimitive, called a mesh update, each mesh vertex stores a value and repeatedly\nupdates this value based on the values stored in all neighboring vertices. The\nperformance of a mesh update depends on the layout of the mesh in memory.\n  This paper shows how to find a memory layout that guarantees that the mesh\nupdate has asymptotically optimal memory performance for any set of memory\nparameters. Such a memory layout is called cache-oblivious. Formally, for a\n$d$-dimensional mesh $G$, block size $B$, and cache size $M$ (where\n$M=\\Omega(B^d)$), the mesh update of $G$ uses $O(1+|G|/B)$ memory transfers.\nThe paper also shows how the mesh-update performance degrades for smaller\ncaches, where $M=o(B^d)$.\n  The paper then gives two algorithms for finding cache-oblivious mesh layouts.\nThe first layout algorithm runs in time $O(|G|\\log^2|G|)$ both in expectation\nand with high probability on a RAM. It uses $O(1+|G|\\log^2(|G|/M)/B)$ memory\ntransfers in expectation and $O(1+(|G|/B)(\\log^2(|G|/M) + \\log|G|))$ memory\ntransfers with high probability in the cache-oblivious and disk-access machine\n(DAM) models. The layout is obtained by finding a fully balanced decomposition\ntree of $G$ and then performing an in-order traversal of the leaves of the\ntree. The second algorithm runs faster by almost a $\\log|G|/\\log\\log|G|$ factor\nin all three memory models, both in expectation and with high probability. The\nlayout obtained by finding a relax-balanced decomposition tree of $G$ and then\nperforming an in-order traversal of the leaves of the tree.\n", "versions": [{"version": "v1", "created": "Tue, 8 May 2007 05:59:55 GMT"}, {"version": "v2", "created": "Mon, 5 Oct 2009 18:45:25 GMT"}], "update_date": "2009-10-05", "authors_parsed": [["Bender", "Michael A.", ""], ["Kuszmaul", "Bradley C.", ""], ["Teng", "Shang-Hua", ""], ["Wang", "Kebin", ""]]}, {"id": "0705.2626", "submitter": "Andrew Knyazev", "authors": "A. V. Knyazev, M. E. Argentati, I. Lashuk, and E. E. Ovtchinnikov", "title": "Block Locally Optimal Preconditioned Eigenvalue Xolvers (BLOPEX) in\n  hypre and PETSc", "comments": "Submitted to SIAM Journal on Scientific Computing", "journal-ref": "SIAM Journal on Scientific Computing (SISC). 25(5): 2224-2239,\n  2007", "doi": "10.1137/060661624", "report-no": "UCDHSC-CCM-251", "categories": "cs.MS cs.NA", "license": null, "abstract": "  We describe our software package Block Locally Optimal Preconditioned\nEigenvalue Xolvers (BLOPEX) publicly released recently. BLOPEX is available as\na stand-alone serial library, as an external package to PETSc (``Portable,\nExtensible Toolkit for Scientific Computation'', a general purpose suite of\ntools for the scalable solution of partial differential equations and related\nproblems developed by Argonne National Laboratory), and is also built into {\\it\nhypre} (``High Performance Preconditioners'', scalable linear solvers package\ndeveloped by Lawrence Livermore National Laboratory). The present BLOPEX\nrelease includes only one solver--the Locally Optimal Block Preconditioned\nConjugate Gradient (LOBPCG) method for symmetric eigenvalue problems. {\\it\nhypre} provides users with advanced high-quality parallel preconditioners for\nlinear systems, in particular, with domain decomposition and multigrid\npreconditioners. With BLOPEX, the same preconditioners can now be efficiently\nused for symmetric eigenvalue problems. PETSc facilitates the integration of\nindependently developed application modules with strict attention to component\ninteroperability, and makes BLOPEX extremely easy to compile and use with\npreconditioners that are available via PETSc. We present the LOBPCG algorithm\nin BLOPEX for {\\it hypre} and PETSc. We demonstrate numerically the scalability\nof BLOPEX by testing it on a number of distributed and shared memory parallel\nsystems, including a Beowulf system, SUN Fire 880, an AMD dual-core Opteron\nworkstation, and IBM BlueGene/L supercomputer, using PETSc domain decomposition\nand {\\it hypre} multigrid preconditioning. We test BLOPEX on a model problem,\nthe standard 7-point finite-difference approximation of the 3-D Laplacian, with\nthe problem size in the range $10^5-10^8$.\n", "versions": [{"version": "v1", "created": "Fri, 18 May 2007 02:25:16 GMT"}], "update_date": "2010-06-02", "authors_parsed": [["Knyazev", "A. V.", ""], ["Argentati", "M. E.", ""], ["Lashuk", "I.", ""], ["Ovtchinnikov", "E. E.", ""]]}, {"id": "0705.4369", "submitter": "Jean-Michel Muller", "authors": "Peter Kornerup (IMADA), Vincent Lef\\`evre (LIP), Jean-Michel Muller\n  (LIP)", "title": "Computing Integer Powers in Floating-Point Arithmetic", "comments": "Laboratoire LIP : CNRS/ENS Lyon/INRIA/Universit\\'e Lyon 1", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NA cs.MS", "license": null, "abstract": "  We introduce two algorithms for accurately evaluating powers to a positive\ninteger in floating-point arithmetic, assuming a fused multiply-add (fma)\ninstruction is available. We show that our log-time algorithm always produce\nfaithfully-rounded results, discuss the possibility of getting correctly\nrounded results, and show that results correctly rounded in double precision\ncan be obtained if extended-precision is available with the possibility to\nround into double precision (with a single rounding).\n", "versions": [{"version": "v1", "created": "Wed, 30 May 2007 11:34:39 GMT"}], "update_date": "2007-06-13", "authors_parsed": [["Kornerup", "Peter", "", "IMADA"], ["Lef\u00e8vre", "Vincent", "", "LIP"], ["Muller", "Jean-Michel", "", "LIP"]]}]