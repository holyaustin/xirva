[{"id": "1301.0044", "submitter": "EPTCS", "authors": "Chen-Wei Wang (McMaster Centre for Software Certification, McMaster\n  University), Jim Davies (Department of Computer Science, University of\n  Oxford)", "title": "Formal Model-Driven Engineering: Generating Data and Behavioural\n  Components", "comments": "In Proceedings FTSCS 2012, arXiv:1212.6574", "journal-ref": "EPTCS 105, 2012, pp. 100-117", "doi": "10.4204/EPTCS.105.8", "report-no": null, "categories": "cs.SE cs.LO cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Model-driven engineering is the automatic production of software artefacts\nfrom abstract models of structure and functionality. By targeting a specific\nclass of system, it is possible to automate aspects of the development process,\nusing model transformations and code generators that encode domain knowledge\nand implementation strategies. Using this approach, questions of correctness\nfor a complex, software system may be answered through analysis of abstract\nmodels of lower complexity, under the assumption that the transformations and\ngenerators employed are themselves correct. This paper shows how formal\ntechniques can be used to establish the correctness of model transformations\nused in the generation of software components from precise object models. The\nsource language is based upon existing, formal techniques; the target language\nis the widely-used SQL notation for database programming. Correctness is\nestablished by giving comparable, relational semantics to both languages, and\nchecking that the transformations are semantics-preserving.\n", "versions": [{"version": "v1", "created": "Tue, 1 Jan 2013 01:54:57 GMT"}], "update_date": "2013-01-03", "authors_parsed": [["Wang", "Chen-Wei", "", "McMaster Centre for Software Certification, McMaster\n  University"], ["Davies", "Jim", "", "Department of Computer Science, University of\n  Oxford"]]}, {"id": "1301.0114", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "Tree-based Arithmetic and Compressed Representations of Giant Numbers", "comments": "UNPUBLISHED DRAFT, 26 pages, 2 figures, literate Haskell code\n  included", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.PL cs.DM cs.DS cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Can we do arithmetic in a completely different way, with a radically\ndifferent data structure? Could this approach provide practical benefits, like\noperations on giant numbers while having an average performance similar to\ntraditional bitstring representations?\n  While answering these questions positively, our tree based representation\ndescribed in this paper comes with a few extra benefits: it compresses giant\nnumbers such that, for instance, the largest known prime number as well as its\nrelated perfect number are represented as trees of small sizes. The same also\napplies to Fermat numbers and important computations like exponentiation of two\nbecome constant time operations.\n  At the same time, succinct representations of sparse sets, multisets and\nsequences become possible through bijections to our tree-represented natural\nnumbers.\n", "versions": [{"version": "v1", "created": "Tue, 1 Jan 2013 18:29:39 GMT"}], "update_date": "2013-01-03", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1301.0128", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "Binary Tree Arithmetic with Generalized Constructors", "comments": "UNPUBLISHED DRAFt, 7 pages, 1 figure", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DM cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe arithmetic computations in terms of operations on some well known\nfree algebras (S1S, S2S and ordered rooted binary trees) while emphasizing the\ncommon structure present in all them when seen as isomorphic with the set of\nnatural numbers.\n  Constructors and deconstructors seen through an initial algebra semantics are\ngeneralized to recursively defined functions obeying similar laws.\n  Implementation using Scala's apply and unapply are discussed together with an\napplication to a realistic arbitrary size arithmetic package written in Scala,\nbased on the free algebra of rooted ordered binary trees, which also supports\nrational number operations through an extension to signed rationals of the\nCalkin-Wilf bijection.\n", "versions": [{"version": "v1", "created": "Tue, 1 Jan 2013 19:58:26 GMT"}], "update_date": "2013-01-03", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1301.0129", "submitter": "Paul Tarau", "authors": "Paul Tarau", "title": "On Two Infinite Families of Pairing Bijections", "comments": "UNPUBLISHED DRAFT", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DM cs.PL", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe two general mechanisms for producing pairing bijections\n(bijective functions defined from N x N to N).\n  The first mechanism, using n-adic valuations results in parameterized\nalgorithms generating a countable family of distinct pairing bijections.\n  The second mechanism, using characteristic functions of subsets of N provides\n2^N distinct pairing bijections.\n  Mechanisms to combine such pairing functions and their application to\ngenerate families of permutations of N are also described.\n  The paper uses a small subset of the functional language Haskell to provide\ntype checked executable specifications of all the functions defined in a\nliterate programming style. The self-contained Haskell code extracted from the\npaper is available at http://logic.cse.unt.edu/tarau/research/2012/infpair.hs .\n", "versions": [{"version": "v1", "created": "Tue, 1 Jan 2013 20:10:51 GMT"}], "update_date": "2013-01-03", "authors_parsed": [["Tarau", "Paul", ""]]}, {"id": "1301.0763", "submitter": "Lorenzo Pasquini", "authors": "Lorenzo Pasquini", "title": "Improved QFT algorithm for power-of-two FFT", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This paper shows that it is possible to improve the computational cost, the\nmemory requirements and the accuracy of Quick Fourier Transform (QFT) algorithm\nfor power-of-two FFT (Fast Fourier Transform) just introducing a slight\nmodification in this algorithm. The new algorithm requires the same number of\nadditions and multiplications of split-radix 3add/3mul, one of the most\nappreciated FFT algorithms appeared in the literature, but employing only half\nof the trigonometric constants. These results can elevate the QFT approach to\nthe level of most used FFT procedures. A new quite general way to describe FFT\nalgorithms, based on signal types and on a particular notation, is also\nproposed and used, highligting its advantages.\n", "versions": [{"version": "v1", "created": "Fri, 4 Jan 2013 16:25:56 GMT"}], "update_date": "2013-01-07", "authors_parsed": [["Pasquini", "Lorenzo", ""]]}, {"id": "1301.1334", "submitter": "Sylwester Arabas Sylwester Arabas", "authors": "Sylwester Arabas, Dorota Jarecka, Anna Jaruga, Maciej Fija{\\l}kowski", "title": "Object-oriented implementations of the MPDATA advection equation solver\n  in C++, Python and Fortran", "comments": null, "journal-ref": "Scientific Programming 22, 201-222 (2014)", "doi": "10.3233/SPR-140379", "report-no": null, "categories": "physics.comp-ph cs.MS physics.ao-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Three object-oriented implementations of a prototype solver of the advection\nequation are introduced. The presented programs are based on Blitz++ (C++),\nNumPy (Python), and Fortran's built-in array containers. The solvers include an\nimplementation of the Multidimensional Positive-Definite Advective Transport\nAlgorithm (MPDATA). The introduced codes exemplify how the application of\nobject-oriented programming (OOP) techniques allows to reproduce the\nmathematical notation used in the literature within the program code. A\ndiscussion on the tradeoffs of the programming language choice is presented.\nThe main angles of comparison are code brevity and syntax clarity (and hence\nmaintainability and auditability) as well as performance. In the case of\nPython, a significant performance gain is observed when switching from the\nstandard interpreter (CPython) to the PyPy implementation of Python. Entire\nsource code of all three implementations is embedded in the text and is\nlicensed under the terms of the GNU GPL license.\n", "versions": [{"version": "v1", "created": "Mon, 7 Jan 2013 20:59:13 GMT"}, {"version": "v2", "created": "Tue, 19 Mar 2013 12:59:17 GMT"}], "update_date": "2014-08-21", "authors_parsed": [["Arabas", "Sylwester", ""], ["Jarecka", "Dorota", ""], ["Jaruga", "Anna", ""], ["Fija\u0142kowski", "Maciej", ""]]}, {"id": "1301.1704", "submitter": "Qi Hu", "authors": "Qi Hu, Nail A. Gumerov, Ramani Duraiswami", "title": "Parallel Algorithms for Constructing Data Structures for Fast Multipole\n  Methods", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present efficient algorithms to build data structures and the lists needed\nfor fast multipole methods. The algorithms are capable of being efficiently\nimplemented on both serial, data parallel GPU and on distributed architectures.\nWith these algorithms it is possible to map the FMM efficiently on to the GPU\nor distributed heterogeneous CPU-GPU systems. Further, in dynamic problems, as\nthe distribution of the particles change, the reduced cost of building the data\nstructures improves performance. Using these algorithms, we demonstrate example\nhigh fidelity simulations with large problem sizes by using FMM on both single\nand multiple heterogeneous computing facilities equipped with multi-core CPU\nand many-core GPUs.\n", "versions": [{"version": "v1", "created": "Tue, 8 Jan 2013 21:57:20 GMT"}], "update_date": "2013-01-10", "authors_parsed": [["Hu", "Qi", ""], ["Gumerov", "Nail A.", ""], ["Duraiswami", "Ramani", ""]]}, {"id": "1301.2102", "submitter": "Kirk Soodhalter", "authors": "Kirk M. Soodhalter", "title": "A block MINRES algorithm based on the banded Lanczos method", "comments": "20 Pages, 8 figures, 1 Algorithm, Revision based on reviewer comments", "journal-ref": null, "doi": "10.1007/s11075-014-9907-z", "report-no": null, "categories": "math.NA cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We develop a block minimum residual (MINRES) algorithm for symmetric\nindefinite matrices. This version is built upon the band Lanczos method that\ngenerates one basis vector of the block Krylov subspace per iteration rather\nthan a whole block as in the block Lanczos process. However, we modify the\nmethod such that the most expensive operations are still performed in a block\nfashion. The benefit of using the band Lanczos method is that one can detect\nbreakdowns from scalar values arising in the computation, allowing for a\nhandling of breakdown which is straightforward to implement.\n  We derive a progressive formulation of the MINRES method based on the band\nLanczos process and give some implementation details. Specifically, a simple\nreordering of the steps allows us to perform many of the operations at the\nblock level in order to take advantage of communication efficiencies offered by\nthe block Lanczos process. This is an important concern in the context of\nnext-generation super computing applications.\n  We also present a technique allowing us to maintain the block size by\nreplacing dependent Lanczos vectors with pregenerated random vectors whose\northogonality against all Lanczos vectors is maintained. Numerical results\nillustrate the performance on some sample problems. We present experiments that\nshow how the relationship between right-hand sides can effect the performance\nof the method.\n", "versions": [{"version": "v1", "created": "Thu, 10 Jan 2013 12:22:23 GMT"}, {"version": "v2", "created": "Tue, 15 Oct 2013 09:50:43 GMT"}, {"version": "v3", "created": "Tue, 13 May 2014 13:29:05 GMT"}], "update_date": "2014-10-01", "authors_parsed": [["Soodhalter", "Kirk M.", ""]]}, {"id": "1301.2650", "submitter": "Kirk Soodhalter", "authors": "Kirk M. Soodhalter and Daniel B. Szyld and Fei Xue", "title": "Krylov Subspace Recycling for Sequences of Shifted Linear Systems", "comments": "5 figures, 20 pages (main paper 18 pages + refs 2 pages)", "journal-ref": "Applied Numerical Mathematics 81C (2014), pp. 105-118", "doi": "10.1016/j.apnum.2014.02.006", "report-no": null, "categories": "math.NA cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We study the use of Krylov subspace recycling for the solution of a sequence\nof slowly-changing families of linear systems, where each family consists of\nshifted linear systems that differ in the coefficient matrix only by multiples\nof the identity. Our aim is to explore the simultaneous solution of each family\nof shifted systems within the framework of subspace recycling, using one\naugmented subspace to extract candidate solutions for all the shifted systems.\nThe ideal method would use the same augmented subspace for all systems and have\nfixed storage requirements, independent of the number of shifted systems per\nfamily. We show that a method satisfying both requirements cannot exist in this\nframework.\n  As an alternative, we introduce two schemes. One constructs a separate\ndeflation space for each shifted system but solves each family of shifted\nsystems simultaneously. The other builds only one recycled subspace and\nconstructs approximate corrections to the solutions of the shifted systems at\neach cycle of the iterative linear solver while only minimizing the base system\nresidual. At convergence of the base system solution, we apply the method\nrecursively to the remaining unconverged systems. We present numerical examples\ninvolving systems arising in lattice quantum chromodynamics.\n", "versions": [{"version": "v1", "created": "Sat, 12 Jan 2013 05:36:09 GMT"}, {"version": "v2", "created": "Tue, 15 Jan 2013 10:19:09 GMT"}, {"version": "v3", "created": "Thu, 29 Aug 2013 10:59:06 GMT"}], "update_date": "2014-10-01", "authors_parsed": [["Soodhalter", "Kirk M.", ""], ["Szyld", "Daniel B.", ""], ["Xue", "Fei", ""]]}, {"id": "1301.2707", "submitter": "Sou-Cheng Choi", "authors": "Sou-Cheng T. Choi and Michael A. Saunders", "title": "ALGORITHM 937: MINRES-QLP for Singular Symmetric and Hermitian Linear\n  Equations and Least-Squares Problems", "comments": "14 pages and 1 figure", "journal-ref": null, "doi": "10.1145/2527267", "report-no": null, "categories": "cs.MS cs.DS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe algorithm MINRES-QLP and its FORTRAN 90 implementation for\nsolving symmetric or Hermitian linear systems or least-squares problems. If the\nsystem is singular, MINRES-QLP computes the unique minimum-length solution\n(also known as the pseudoinverse solution), which generally eludes MINRES. In\nall cases, it overcomes a potential instability in the original MINRES\nalgorithm. A positive-definite preconditioner may be supplied. Our FORTRAN 90\nimplementation illustrates a design pattern that allows users to make problem\ndata known to the solver but hidden and secure from other program units. In\nparticular, we circumvent the need for reverse communication. While we focus\nhere on a FORTRAN 90 implementation, we also provide and maintain MATLAB\nversions of MINRES and MINRES-QLP.\n", "versions": [{"version": "v1", "created": "Sat, 12 Jan 2013 19:00:15 GMT"}, {"version": "v2", "created": "Fri, 27 Mar 2015 00:44:56 GMT"}], "update_date": "2015-03-30", "authors_parsed": [["Choi", "Sou-Cheng T.", ""], ["Saunders", "Michael A.", ""]]}, {"id": "1301.3863", "submitter": "Soren Hojsgaard", "authors": "Soren Hojsgaard", "title": "YGGDRASIL - A Statistical Package for Learning Split Models", "comments": "Appears in Proceedings of the Sixteenth Conference on Uncertainty in\n  Artificial Intelligence (UAI2000)", "journal-ref": null, "doi": null, "report-no": "UAI-P-2000-PG-274-281", "categories": "cs.AI cs.MS stat.ME", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  There are two main objectives of this paper. The first is to present a\nstatistical framework for models with context specific independence structures,\ni.e., conditional independences holding only for sepcific values of the\nconditioning variables. This framework is constituted by the class of split\nmodels. Split models are extension of graphical models for contigency tables\nand allow for a more sophisticiated modelling than graphical models. The\ntreatment of split models include estimation, representation and a Markov\nproperty for reading off those independencies holding in a specific context.\nThe second objective is to present a software package named YGGDRASIL which is\ndesigned for statistical inference in split models, i.e., for learning such\nmodels on the basis of data.\n", "versions": [{"version": "v1", "created": "Wed, 16 Jan 2013 15:50:42 GMT"}], "update_date": "2013-01-18", "authors_parsed": [["Hojsgaard", "Soren", ""]]}, {"id": "1301.4438", "submitter": "Jean-Guillaume Dumas", "authors": "Jean-Guillaume Dumas (LJK), Cl\\'ement Pernet (INRIA Grenoble\n  Rh\\^one-Alpes / LIG Laboratoire d'Informatique de Grenoble), Ziad Sultan\n  (LJK, INRIA Grenoble Rh\\^one-Alpes / LIG Laboratoire d'Informatique de\n  Grenoble)", "title": "Simultaneous computation of the row and column rank profiles", "comments": null, "journal-ref": "ISSAC 2013, Boston, MA : \\'Etats-Unis (2013)", "doi": null, "report-no": null, "categories": "cs.NA cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Gaussian elimination with full pivoting generates a PLUQ matrix\ndecomposition. Depending on the strategy used in the search for pivots, the\npermutation matrices can reveal some information about the row or the column\nrank profiles of the matrix. We propose a new pivoting strategy that makes it\npossible to recover at the same time both row and column rank profiles of the\ninput matrix and of any of its leading sub-matrices. We propose a\nrank-sensitive and quad-recursive algorithm that computes the latter PLUQ\ntriangular decomposition of an m \\times n matrix of rank r in O(mnr^{\\omega-2})\nfield operations, with \\omega the exponent of matrix multiplication. Compared\nto the LEU decomposition by Malashonock, sharing a similar recursive structure,\nits time complexity is rank sensitive and has a lower leading constant. Over a\nword size finite field, this algorithm also improveLs the practical efficiency\nof previously known implementations.\n", "versions": [{"version": "v1", "created": "Fri, 18 Jan 2013 17:23:01 GMT"}], "update_date": "2013-05-21", "authors_parsed": [["Dumas", "Jean-Guillaume", "", "LJK"], ["Pernet", "Cl\u00e9ment", "", "INRIA Grenoble\n  Rh\u00f4ne-Alpes / LIG Laboratoire d'Informatique de Grenoble"], ["Sultan", "Ziad", "", "LJK, INRIA Grenoble Rh\u00f4ne-Alpes / LIG Laboratoire d'Informatique de\n  Grenoble"]]}, {"id": "1301.4499", "submitter": "Marco Selig", "authors": "Marco Selig, Michael R. Bell, Henrik Junklewitz, Niels Oppermann,\n  Martin Reinecke, Maksim Greiner, Carlos Pachajoa, Torsten A. En{\\ss}lin", "title": "NIFTY - Numerical Information Field Theory - a versatile Python library\n  for signal inference", "comments": "9 pages, 3 tables, 4 figures, accepted by Astronomy & Astrophysics;\n  refereed version, 1 figure added, results unchanged", "journal-ref": null, "doi": "10.1051/0004-6361/201321236", "report-no": null, "categories": "astro-ph.IM cs.IT cs.MS math-ph math.IT math.MP physics.data-an stat.CO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  NIFTY, \"Numerical Information Field Theory\", is a software package designed\nto enable the development of signal inference algorithms that operate\nregardless of the underlying spatial grid and its resolution. Its\nobject-oriented framework is written in Python, although it accesses libraries\nwritten in Cython, C++, and C for efficiency. NIFTY offers a toolkit that\nabstracts discretized representations of continuous spaces, fields in these\nspaces, and operators acting on fields into classes. Thereby, the correct\nnormalization of operations on fields is taken care of automatically without\nconcerning the user. This allows for an abstract formulation and programming of\ninference algorithms, including those derived within information field theory.\nThus, NIFTY permits its user to rapidly prototype algorithms in 1D, and then\napply the developed code in higher-dimensional settings of real world problems.\nThe set of spaces on which NIFTY operates comprises point sets, n-dimensional\nregular grids, spherical spaces, their harmonic counterparts, and product\nspaces constructed as combinations of those. The functionality and diversity of\nthe package is demonstrated by a Wiener filter code example that successfully\nruns without modification regardless of the space on which the inference\nproblem is defined.\n", "versions": [{"version": "v1", "created": "Fri, 18 Jan 2013 21:00:01 GMT"}, {"version": "v2", "created": "Wed, 5 Jun 2013 17:24:59 GMT"}], "update_date": "2013-06-06", "authors_parsed": [["Selig", "Marco", ""], ["Bell", "Michael R.", ""], ["Junklewitz", "Henrik", ""], ["Oppermann", "Niels", ""], ["Reinecke", "Martin", ""], ["Greiner", "Maksim", ""], ["Pachajoa", "Carlos", ""], ["En\u00dflin", "Torsten A.", ""]]}, {"id": "1301.6879", "submitter": "Christian Himpe", "authors": "Christian Himpe, Mario Ohlberger", "title": "A Unified Software Framework for Empirical Gramians", "comments": "Preprint", "journal-ref": null, "doi": "10.1155/2013/365909", "report-no": null, "categories": "math.OC cs.MS cs.SY math.DS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  A common approach in model reduction is balanced truncation, which is based\non gramian matrices classifiying certain attributes of states or parameters of\na given dynamic system. Initially restricted to linear systems, the empirical\ngramians not only extended this concept to nonlinear systems, but also provide\na uniform computational method. This work introduces a unified software\nframework supplying routines for six types of empirical gramians. The gramian\ntypes will be discussed and applied in a model reduction framework for\nmultiple-input-multiple-output (MIMO) systems.\n", "versions": [{"version": "v1", "created": "Tue, 29 Jan 2013 10:05:37 GMT"}, {"version": "v2", "created": "Tue, 5 Feb 2013 12:14:00 GMT"}, {"version": "v3", "created": "Tue, 5 Mar 2013 11:08:11 GMT"}, {"version": "v4", "created": "Thu, 4 Apr 2013 14:05:43 GMT"}, {"version": "v5", "created": "Mon, 15 Jul 2013 15:12:32 GMT"}], "update_date": "2016-08-22", "authors_parsed": [["Himpe", "Christian", ""], ["Ohlberger", "Mario", ""]]}, {"id": "1301.7283", "submitter": "Jonathan Hogg", "authors": "J.D. Hogg and J. A. Scott", "title": "On the effects of scaling on the performance of Ipopt", "comments": null, "journal-ref": null, "doi": null, "report-no": "RAL-P-2012-009", "categories": "math.OC cs.MS math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The open-source nonlinear solver Ipopt (https://projects.coin-or.org/Ipopt)\nis a widely-used software package for the solution of large-scale non-linear\noptimization problems. At its heart, it employs a third-party linear solver to\nsolve a series of sparse symmetric indefinite systems. The speed, accuracy and\nrobustness of the chosen linear solver is critical to the overall performance\nof Ipopt. In some instances, it can be beneficial to scale the linear system\nbefore it is solved.\n  In this paper, different scaling algorithms are employed within Ipopt with a\nnew linear solver HSL_MA97 from the HSL mathematical software library\n(http://www.hsl.rl.ac.uk). An extensive collection of problems from the CUTEr\ntest set (http://www.cuter.rl.ac.uk) is used to illustrate the effects of\nscaling.\n", "versions": [{"version": "v1", "created": "Wed, 30 Jan 2013 16:52:05 GMT"}], "update_date": "2013-01-31", "authors_parsed": [["Hogg", "J. D.", ""], ["Scott", "J. A.", ""]]}, {"id": "1301.7744", "submitter": "Tamara Kolda", "authors": "Martin D. Schatz, Tze Meng Low, Robert A. van de Geijn, Tamara G.\n  Kolda", "title": "Exploiting Symmetry in Tensors for High Performance: Multiplication with\n  Symmetric Tensors", "comments": null, "journal-ref": "SIAM Journal on Scientific Computing, Vol. 36, No. 5, pp.\n  C453-C479, September 2014", "doi": "10.1137/130907215", "report-no": null, "categories": "math.NA cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Symmetric tensor operations arise in a wide variety of computations. However,\nthe benefits of exploiting symmetry in order to reduce storage and computation\nis in conflict with a desire to simplify memory access patterns. In this paper,\nwe propose a blocked data structure (Blocked Compact Symmetric Storage) wherein\nwe consider the tensor by blocks and store only the unique blocks of a\nsymmetric tensor. We propose an algorithm-by-blocks, already shown of benefit\nfor matrix computations, that exploits this storage format by utilizing a\nseries of temporary tensors to avoid redundant computation. Further, partial\nsymmetry within temporaries is exploited to further avoid redundant storage and\nredundant computation. A detailed analysis shows that, relative to storing and\ncomputing with tensors without taking advantage of symmetry and partial\nsymmetry, storage requirements are reduced by a factor of $ O\\left( m! \\right)$\nand computational requirements by a factor of $O\\left( (m+1)!/2^m \\right)$,\nwhere $ m $ is the order of the tensor. However, as the analysis shows, care\nmust be taken in choosing the correct block size to ensure these storage and\ncomputational benefits are achieved (particularly for low-order tensors). An\nimplementation demonstrates that storage is greatly reduced and the complexity\nintroduced by storing and computing with tensors by blocks is manageable.\nPreliminary results demonstrate that computational time is also reduced. The\npaper concludes with a discussion of how insights in this paper point to\nopportunities for generalizing recent advances in the domain of linear algebra\nlibraries to the field of multi-linear computation.\n", "versions": [{"version": "v1", "created": "Thu, 31 Jan 2013 20:39:44 GMT"}, {"version": "v2", "created": "Fri, 13 Sep 2013 21:14:48 GMT"}, {"version": "v3", "created": "Wed, 9 Apr 2014 21:40:55 GMT"}], "update_date": "2014-10-21", "authors_parsed": [["Schatz", "Martin D.", ""], ["Low", "Tze Meng", ""], ["van de Geijn", "Robert A.", ""], ["Kolda", "Tamara G.", ""]]}]