[{"id": "1106.1319", "submitter": "Xiaosheng Zhuang", "authors": "Gitta Kutyniok and Morteza Shahram and Xiaosheng Zhuang", "title": "ShearLab: A Rational Design of a Digital Parabolic Scaling Algorithm", "comments": "submitted to SIAM J. Multiscale Model. Simul", "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NA cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Multivariate problems are typically governed by anisotropic features such as\nedges in images. A common bracket of most of the various directional\nrepresentation systems which have been proposed to deliver sparse\napproximations of such features is the utilization of parabolic scaling. One\nprominent example is the shearlet system. Our objective in this paper is\nthree-fold: We firstly develop a digital shearlet theory which is rationally\ndesigned in the sense that it is the digitization of the existing shearlet\ntheory for continuous data. This implicates that shearlet theory provides a\nunified treatment of both the continuum and digital realm. Secondly, we analyze\nthe utilization of pseudo-polar grids and the pseudo-polar Fourier transform\nfor digital implementations of parabolic scaling algorithms. We derive an\nisometric pseudo-polar Fourier transform by careful weighting of the\npseudo-polar grid, allowing exploitation of its adjoint for the inverse\ntransform. This leads to a digital implementation of the shearlet transform; an\naccompanying Matlab toolbox called ShearLab is provided. And, thirdly, we\nintroduce various quantitative measures for digital parabolic scaling\nalgorithms in general, allowing one to tune parameters and objectively improve\nthe implementation as well as compare different directional transform\nimplementations. The usefulness of such measures is exemplarily demonstrated\nfor the digital shearlet transform.\n", "versions": [{"version": "v1", "created": "Tue, 7 Jun 2011 11:36:55 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Kutyniok", "Gitta", ""], ["Shahram", "Morteza", ""], ["Zhuang", "Xiaosheng", ""]]}, {"id": "1106.1347", "submitter": "Ivo Hedtke", "authors": "Ivo Hedtke", "title": "Methods of Matrix Multiplication: An Overview of Several Methods and\n  their Implementation", "comments": "25 pages", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this overview article we present several methods for multiplying matrices\nand the implementation of these methods in C. Also a little test program is\ngiven to compare their running time and the numerical stability.\n  The methods are: naive method, naive method working on arrays, naive method\nwith the \\textsc{Kahan} trick, three methods with loop unrolling, winograd\nmethod and the scaled variant, original \\textsc{Strassen} method and the\n\\textsc{Strassen}-\\textsc{Winograd} variant.\n  Please note, that this is the FIRST version. The algorithms are not well\ntested and the implementation is not optimized. If you like to join the\nproject, please contact me.\n", "versions": [{"version": "v1", "created": "Fri, 3 Jun 2011 09:17:11 GMT"}], "update_date": "2011-06-08", "authors_parsed": [["Hedtke", "Ivo", ""]]}, {"id": "1106.1862", "submitter": "Jacques Carette", "authors": "Jacques Carette, William M. Farmer, Filip Jeremic, Vincent Maccio,\n  Russell O'Connor, Quang M. Tran", "title": "The MathScheme Library: Some Preliminary Experiments", "comments": "Accepted as a work-in-progress paper at CICM 2011", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.SC cs.SE math.RA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present some of the experiments we have performed to best test our design\nfor a library for MathScheme, the mechanized mathematics software system we are\nbuilding. We wish for our library design to use and reflect, as much as\npossible, the mathematical structure present in the objects which populate the\nlibrary.\n", "versions": [{"version": "v1", "created": "Thu, 9 Jun 2011 17:16:38 GMT"}], "update_date": "2011-06-10", "authors_parsed": [["Carette", "Jacques", ""], ["Farmer", "William M.", ""], ["Jeremic", "Filip", ""], ["Maccio", "Vincent", ""], ["O'Connor", "Russell", ""], ["Tran", "Quang M.", ""]]}, {"id": "1106.2176", "submitter": "Rio Yokota Dr.", "authors": "Rio Yokota and Lorena Barba", "title": "A Tuned and Scalable Fast Multipole Method as a Preeminent Algorithm for\n  Exascale Systems", "comments": null, "journal-ref": null, "doi": "10.1177/1094342011429952", "report-no": null, "categories": "cs.NA cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Among the algorithms that are likely to play a major role in future exascale\ncomputing, the fast multipole method (FMM) appears as a rising star. Our\nprevious recent work showed scaling of an FMM on GPU clusters, with problem\nsizes in the order of billions of unknowns. That work led to an extremely\nparallel FMM, scaling to thousands of GPUs or tens of thousands of CPUs. This\npaper reports on a a campaign of performance tuning and scalability studies\nusing multi-core CPUs, on the Kraken supercomputer. All kernels in the FMM were\nparallelized using OpenMP, and a test using 10^7 particles randomly distributed\nin a cube showed 78% efficiency on 8 threads. Tuning of the\nparticle-to-particle kernel using SIMD instructions resulted in 4x speed-up of\nthe overall algorithm on single-core tests with 10^3 - 10^7 particles. Parallel\nscalability was studied in both strong and weak scaling. The strong scaling\ntest used 10^8 particles and resulted in 93% parallel efficiency on 2048\nprocesses for the non-SIMD code and 54% for the SIMD-optimized code (which was\nstill 2x faster). The weak scaling test used 10^6 particles per process, and\nresulted in 72% efficiency on 32,768 processes, with the largest calculation\ntaking about 40 seconds to evaluate more than 32 billion unknowns. This work\nbuilds up evidence for our view that FMM is poised to play a leading role in\nexascale computing, and we end the paper with a discussion of the features that\nmake it a particularly favorable algorithm for the emerging heterogeneous and\nmassively parallel architectural landscape.\n", "versions": [{"version": "v1", "created": "Fri, 10 Jun 2011 21:02:40 GMT"}, {"version": "v2", "created": "Sun, 16 Oct 2011 20:45:45 GMT"}], "update_date": "2012-10-30", "authors_parsed": [["Yokota", "Rio", ""], ["Barba", "Lorena", ""]]}, {"id": "1106.2263", "submitter": "David Miguel Antunes", "authors": "David Miguel Antunes, David Martins de Matos, Jos\\'e Gaspar", "title": "A Library for Implementing the Multiple Hypothesis Tracking Algorithm", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The Multiple Hypothesis Tracking (MHT) algorithm is known to produce good\nresults in difficult multi-target tracking situations. However, its\nimplementation is not trivial, and is associated with a significant programming\neffort, code size and long implementation time. We propose a library which\naddresses these problems by providing a domain independent implementation of\nthe most complex MHT operations. We also address the problem of applying\nclustering in domain independent manner.\n", "versions": [{"version": "v1", "created": "Sat, 11 Jun 2011 22:32:32 GMT"}], "update_date": "2011-06-14", "authors_parsed": [["Antunes", "David Miguel", ""], ["de Matos", "David Martins", ""], ["Gaspar", "Jos\u00e9", ""]]}, {"id": "1106.4448", "submitter": "Damien Pous", "authors": "Thomas Braibant (LIG), Damien Pous (LIG)", "title": "Tactics for Reasoning modulo AC in Coq", "comments": "16p", "journal-ref": "Certified Proofs and Programs, Ta\\\"iwan, Province De Chine (2011)", "doi": "10.1007/978-3-642-25379-9_14", "report-no": null, "categories": "cs.MS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a set of tools for rewriting modulo associativity and\ncommutativity (AC) in Coq, solving a long-standing practical problem. We use\ntwo building blocks: first, an extensible reflexive decision procedure for\nequality modulo AC; second, an OCaml plug-in for pattern matching modulo AC. We\nhandle associative only operations, neutral elements, uninterpreted function\nsymbols, and user-defined equivalence relations. By relying on type-classes for\nthe reification phase, we can infer these properties automatically, so that\nend-users do not need to specify which operation is A or AC, or which constant\nis a neutral element.\n", "versions": [{"version": "v1", "created": "Wed, 22 Jun 2011 13:58:58 GMT"}, {"version": "v2", "created": "Thu, 22 Sep 2011 12:47:56 GMT"}], "update_date": "2013-03-08", "authors_parsed": [["Braibant", "Thomas", "", "LIG"], ["Pous", "Damien", "", "LIG"]]}, {"id": "1106.5694", "submitter": "Roberto Roverso", "authors": "Roberto Roverso, Amgad Naiem, Mohammed El-Beltagy and Sameh El-Ansary", "title": "GPU-Based Heuristic Solver for Linear Sum Assignment Problems Under\n  Real-time Constraints", "comments": "White Paper, Peerialism Inc. (www.peerialism.com)", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DC cs.MS cs.PF math.OC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In this paper we modify a fast heuristic solver for the Linear Sum Assignment\nProblem (LSAP) for use on Graphical Processing Units (GPUs). The motivating\nscenario is an industrial application for P2P live streaming that is moderated\nby a central node which is periodically solving LSAP instances for assigning\npeers to one another. The central node needs to handle LSAP instances involving\nthousands of peers in as near to real-time as possible. Our findings are\ngeneric enough to be applied in other contexts. Our main result is a parallel\nversion of a heuristic algorithm called Deep Greedy Switching (DGS) on GPUs\nusing the CUDA programming language. DGS sacrifices absolute optimality in\nfavor of low computation time and was designed as an alternative to classical\nLSAP solvers such as the Hungarian and auctioning methods. The contribution of\nthe paper is threefold: First, we present the process of trial and error we\nwent through, in the hope that our experience will be beneficial to adopters of\nGPU programming for similar problems. Second, we show the modifications needed\nto parallelize the DGS algorithm. Third, we show the performance gains of our\napproach compared to both a sequential CPU-based implementation of DGS and a\nparallel GPU-based implementation of the auctioning algorithm.\n", "versions": [{"version": "v1", "created": "Tue, 28 Jun 2011 14:53:58 GMT"}, {"version": "v2", "created": "Thu, 30 Jun 2011 13:41:49 GMT"}], "update_date": "2011-07-01", "authors_parsed": [["Roverso", "Roberto", ""], ["Naiem", "Amgad", ""], ["El-Beltagy", "Mohammed", ""], ["El-Ansary", "Sameh", ""]]}]