[{"id": "1706.00231", "submitter": "Samer Abdallah", "authors": "Samer Abdallah", "title": "Automatic Differentiation using Constraint Handling Rules in Prolog", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.PL cs.SC", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Automatic differentiation is a technique which allows a programmer to define\na numerical computation via compositions of a broad range of numeric and\ncomputational primitives and have the underlying system support the computation\nof partial derivatives of the result with respect to any of its inputs, without\nmaking any finite difference approximations, and without manipulating large\nsymbolic expressions representing the computation. This note describes a novel\napproach to reverse mode automatic differentiation using constraint logic\nprogrammming, specifically, the constraint handling rules (CHR) library of SWI\nProlog, resulting in a very small (50 lines of code) implementation. When\napplied to a differentiation-based implementation of the inside-outside\nalgorithm for parameter learning in probabilistic grammars, the CHR based\nimplementations outperformed two well-known frameworks for optimising\ndifferentiable functions, Theano and TensorFlow, by a large margin.\n", "versions": [{"version": "v1", "created": "Thu, 1 Jun 2017 09:55:10 GMT"}], "update_date": "2017-06-02", "authors_parsed": [["Abdallah", "Samer", ""]]}, {"id": "1706.01346", "submitter": "Lawrence Mitchell", "authors": "Robert C. Kirby and Lawrence Mitchell", "title": "Solver composition across the PDE/linear algebra barrier", "comments": "23 pages. Fixed axis labelling in Fig 3", "journal-ref": "SIAM Journal on Scientific Computing 40(1):C76-C98 (2018)", "doi": "10.1137/17M1133208", "report-no": null, "categories": "cs.MS cs.NA math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The efficient solution of discretisations of coupled systems of partial\ndifferential equations (PDEs) is at the core of much of numerical simulation.\nSignificant effort has been expended on scalable algorithms to precondition\nKrylov iterations for the linear systems that arise. With few exceptions, the\nreported numerical implementation of such solution strategies is specific to a\nparticular model setup, and intimately ties the solver strategy to the\ndiscretisation and PDE, especially when the preconditioner requires auxiliary\noperators. In this paper, we present recent improvements in the Firedrake\nfinite element library that allow for straightforward development of the\nbuilding blocks of extensible, composable preconditioners that decouple the\nsolver from the model formulation. Our implementation extends the algebraic\ncomposability of linear solvers offered by the PETSc library by augmenting\noperators, and hence preconditioners, with the ability to provide any necessary\nauxiliary operators. Rather than specifying up front the full solver\nconfiguration, tied to the model, solvers can be developed independently of\nmodel formulation and configured at runtime. We illustrate with examples from\nincompressible fluids and temperature-driven convection.\n", "versions": [{"version": "v1", "created": "Mon, 5 Jun 2017 14:25:39 GMT"}, {"version": "v2", "created": "Tue, 17 Oct 2017 16:16:44 GMT"}, {"version": "v3", "created": "Wed, 8 Nov 2017 11:04:49 GMT"}], "update_date": "2018-02-22", "authors_parsed": [["Kirby", "Robert C.", ""], ["Mitchell", "Lawrence", ""]]}, {"id": "1706.02808", "submitter": "Art Owen", "authors": "Art B. Owen", "title": "A randomized Halton algorithm in R", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "stat.CO cs.MS cs.NA math.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Randomized quasi-Monte Carlo (RQMC) sampling can bring orders of magnitude\nreduction in variance compared to plain Monte Carlo (MC) sampling. The extent\nof the efficiency gain varies from problem to problem and can be hard to\npredict. This article presents an R function rhalton that produces scrambled\nversions of Halton sequences. On some problems it brings efficiency gains of\nseveral thousand fold. On other problems, the efficiency gain is minor. The\ncode is designed to make it easy to determine whether a given integrand will\nbenefit from RQMC sampling. An RQMC sample of n points in $[0,1]^d$ can be\nextended later to a larger n and/or d.\n", "versions": [{"version": "v1", "created": "Fri, 9 Jun 2017 01:44:03 GMT"}, {"version": "v2", "created": "Thu, 22 Jun 2017 22:04:44 GMT"}], "update_date": "2017-06-26", "authors_parsed": [["Owen", "Art B.", ""]]}, {"id": "1706.08569", "submitter": "Saverio Perugini", "authors": "Tyler M. Masthay and Saverio Perugini", "title": "Parareal Algorithm Implementation and Simulation in Julia", "comments": "6 pages, 2 figures, 2 listings", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We present a full implementation of the parareal algorithm---an integration\ntechnique to solve differential equations in parallel---in the Julia\nprogramming language for a fully general, first-order, initial-value problem.\nWe provide a brief overview of Julia---a concurrent programming language for\nscientific computing. Our implementation of the parareal algorithm accepts both\ncoarse and fine integrators as functional arguments. We use Euler's method and\nanother Runge-Kutta integration technique as the integrators in our\nexperiments. We also present a simulation of the algorithm for purposes of\npedagogy and as a tool for investigating the performance of the algorithm.\n", "versions": [{"version": "v1", "created": "Mon, 26 Jun 2017 19:27:58 GMT"}, {"version": "v2", "created": "Thu, 13 Dec 2018 20:21:25 GMT"}], "update_date": "2018-12-17", "authors_parsed": [["Masthay", "Tyler M.", ""], ["Perugini", "Saverio", ""]]}]