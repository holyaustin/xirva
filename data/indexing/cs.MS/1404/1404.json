[{"id": "1404.0390", "submitter": "Sebastiano Vigna", "authors": "Sebastiano Vigna", "title": "Further scramblings of Marsaglia's xorshift generators", "comments": "arXiv admin note: text overlap with arXiv:1402.6246", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.DS cs.CR cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  xorshift* generators are a variant of Marsaglia's xorshift generators that\neliminate linear artifacts typical of generators based on $\\mathbf Z/2\\mathbf\nZ$-linear operations using multiplication by a suitable constant. Shortly after\nhigh-dimensional xorshift* generators were introduced, Saito and Matsumoto\nsuggested a different way to eliminate linear artifacts based on addition in\n$\\mathbf Z/2^{32}\\mathbf Z$, leading to the XSadd generator. Starting from the\nobservation that the lower bits of XSadd are very weak, as its reverse fails\nsystematically several statistical tests, we explore xorshift+, a variant of\nXSadd using 64-bit operations, which leads, in small dimension, to extremely\nfast high-quality generators.\n", "versions": [{"version": "v1", "created": "Tue, 1 Apr 2014 20:14:51 GMT"}, {"version": "v2", "created": "Mon, 14 Dec 2015 09:46:02 GMT"}, {"version": "v3", "created": "Mon, 23 May 2016 15:44:18 GMT"}], "update_date": "2016-05-24", "authors_parsed": [["Vigna", "Sebastiano", ""]]}, {"id": "1404.2891", "submitter": "Eric Polizzi", "authors": "Ping Tak Peter Tang, James Kestyn, Eric Polizzi", "title": "A New Highly Parallel Non-Hermitian Eigensolver", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "math.NA cs.MS cs.NA", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Calculating portions of eigenvalues and eigenvectors of matrices or matrix\npencils has many applications. An approach to this calculation for Hermitian\nproblems based on a density matrix has been proposed in 2009 and a software\npackage called FEAST has been developed. The density-matrix approach allows\nFEAST's implementation to exploit a key strength of modern computer\narchitectures, namely, multiple levels of parallelism. Consequently, the\nsoftware package has been well received and subsequently commercialized. A\ndetailed theoretical analysis of Hermitian FEAST has also been established very\nrecently. This paper generalizes the FEAST algorithm and theory, for the first\ntime, to tackle non-Hermitian problems. Fundamentally, the new algorithm is\nbasic subspace iteration or Bauer bi-iteration, except applied with a novel\naccelerator based on Cauchy integrals. The resulting algorithm retains the\nmulti-level parallelism of Hermitian FEAST, making it a valuable new tool for\nlarge-scale computational science and engineering problems on leading-edge\ncomputing platforms.\n", "versions": [{"version": "v1", "created": "Thu, 10 Apr 2014 17:59:44 GMT"}], "update_date": "2014-04-11", "authors_parsed": [["Tang", "Ping Tak Peter", ""], ["Kestyn", "James", ""], ["Polizzi", "Eric", ""]]}, {"id": "1404.3406", "submitter": "Diego Fabregat-Traver", "authors": "Diego Fabregat-Traver", "title": "Knowledge-Based Automatic Generation of Linear Algebra Algorithms and\n  Code", "comments": "Dissertation", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This dissertation focuses on the design and the implementation of\ndomain-specific compilers for linear algebra matrix equations. The development\nof efficient libraries for such equations, which lie at the heart of most\nsoftware for scientific computing, is a complex process that requires expertise\nin a variety of areas, including the application domain, algorithms, numerical\nanalysis and high-performance computing. Moreover, the process involves the\ncollaboration of several people for a considerable amount of time. With our\ncompilers, we aim to relieve the developers from both designing algorithms and\nwriting code, and to generate routines that match or even surpass the\nperformance of those written by human experts.\n", "versions": [{"version": "v1", "created": "Sun, 13 Apr 2014 18:13:32 GMT"}], "update_date": "2014-04-15", "authors_parsed": [["Fabregat-Traver", "Diego", ""]]}, {"id": "1404.4161", "submitter": "Edoardo Di Napoli", "authors": "Mario Berljafa (1), Daniel Wortmann (2), Edoardo Di Napoli (2 and 3)\n  ((1) The University of Manchester, (2) Forschungszentrum Juelich, (3) AICES,\n  RWTH Aachen)", "title": "An Optimized and Scalable Eigensolver for Sequences of Eigenvalue\n  Problems", "comments": "23 Pages, 6 figures. First revision of an invited submission to\n  special issue of Concurrency and Computation: Practice and Experience", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.DC physics.comp-ph", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  In many scientific applications the solution of non-linear differential\nequations are obtained through the set-up and solution of a number of\nsuccessive eigenproblems. These eigenproblems can be regarded as a sequence\nwhenever the solution of one problem fosters the initialization of the next. In\naddition, in some eigenproblem sequences there is a connection between the\nsolutions of adjacent eigenproblems. Whenever it is possible to unravel the\nexistence of such a connection, the eigenproblem sequence is said to be\ncorrelated. When facing with a sequence of correlated eigenproblems the current\nstrategy amounts to solving each eigenproblem in isolation. We propose a\nalternative approach which exploits such correlation through the use of an\neigensolver based on subspace iteration and accelerated with Chebyshev\npolynomials (ChFSI). The resulting eigensolver is optimized by minimizing the\nnumber of matrix-vector multiplications and parallelized using the Elemental\nlibrary framework. Numerical results show that ChFSI achieves excellent\nscalability and is competitive with current dense linear algebra parallel\neigensolvers.\n", "versions": [{"version": "v1", "created": "Wed, 16 Apr 2014 08:09:56 GMT"}, {"version": "v2", "created": "Sun, 6 Jul 2014 11:59:36 GMT"}], "update_date": "2014-07-08", "authors_parsed": [["Berljafa", "Mario", "", "2 and 3"], ["Wortmann", "Daniel", "", "2 and 3"], ["Di Napoli", "Edoardo", "", "2 and 3"]]}, {"id": "1404.4410", "submitter": "Jeremy Avigad", "authors": "Jeremy Avigad, Robert Y. Lewis, and Cody Roux", "title": "A heuristic prover for real inequalities", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MS cs.LO", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  We describe a general method for verifying inequalities between real-valued\nexpressions, especially the kinds of straightforward inferences that arise in\ninteractive theorem proving. In contrast to approaches that aim to be complete\nwith respect to a particular language or class of formulas, our method\nestablishes claims that require heterogeneous forms of reasoning, relying on a\nNelson-Oppen-style architecture in which special-purpose modules collaborate\nand share information. The framework is thus modular and extensible. A\nprototype implementation shows that the method works well on a variety of\nexamples, and complements techniques that are used by contemporary interactive\nprovers.\n", "versions": [{"version": "v1", "created": "Thu, 17 Apr 2014 01:31:39 GMT"}, {"version": "v2", "created": "Mon, 4 Jan 2016 19:09:17 GMT"}], "update_date": "2016-01-05", "authors_parsed": [["Avigad", "Jeremy", ""], ["Lewis", "Robert Y.", ""], ["Roux", "Cody", ""]]}, {"id": "1404.4893", "submitter": "Daniele Codecasa", "authors": "Daniele Codecasa and Fabio Stella", "title": "CTBNCToolkit: Continuous Time Bayesian Network Classifier Toolkit", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.AI cs.LG cs.MS", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Continuous time Bayesian network classifiers are designed for temporal\nclassification of multivariate streaming data when time duration of events\nmatters and the class does not change over time. This paper introduces the\nCTBNCToolkit: an open source Java toolkit which provides a stand-alone\napplication for temporal classification and a library for continuous time\nBayesian network classifiers. CTBNCToolkit implements the inference algorithm,\nthe parameter learning algorithm, and the structural learning algorithm for\ncontinuous time Bayesian network classifiers. The structural learning algorithm\nis based on scoring functions: the marginal log-likelihood score and the\nconditional log-likelihood score are provided. CTBNCToolkit provides also an\nimplementation of the expectation maximization algorithm for clustering\npurpose. The paper introduces continuous time Bayesian network classifiers. How\nto use the CTBNToolkit from the command line is described in a specific\nsection. Tutorial examples are included to facilitate users to understand how\nthe toolkit must be used. A section dedicate to the Java library is proposed to\nhelp further code extensions.\n", "versions": [{"version": "v1", "created": "Fri, 18 Apr 2014 21:48:34 GMT"}], "update_date": "2014-04-22", "authors_parsed": [["Codecasa", "Daniele", ""], ["Stella", "Fabio", ""]]}, {"id": "1404.6383", "submitter": "Pierre de Buyl", "authors": "Valentin Haenel", "title": "Bloscpack: a compressed lightweight serialization format for numerical\n  data", "comments": "Part of the Proceedings of the 6th European Conference on Python in\n  Science (EuroSciPy 2013), Pierre de Buyl and Nelle Varoquaux editors, (2014)", "journal-ref": null, "doi": null, "report-no": "euroscipy-proceedings2013-02", "categories": "cs.MS cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  This paper introduces the Bloscpack file format and the accompanying Python\nreference implementation. Bloscpack is a lightweight, compressed binary\nfile-format based on the Blosc codec and is designed for lightweight, fast\nserialization of numerical data. This article presents the features of the\nfile-format and some some API aspects of the reference implementation, in\nparticular the ability to handle Numpy ndarrays. Furthermore, in order to\ndemonstrate its utility, the format is compared both feature- and\nperformance-wise to a few alternative lightweight serialization solutions for\nNumpy ndarrays. The performance comparisons take the form of some comprehensive\nbenchmarks over a range of different artificial datasets with varying size and\ncomplexity, the results of which are presented as the last section of this\narticle.\n", "versions": [{"version": "v1", "created": "Fri, 25 Apr 2014 10:53:23 GMT"}, {"version": "v2", "created": "Tue, 29 Apr 2014 14:16:55 GMT"}], "update_date": "2014-04-30", "authors_parsed": [["Haenel", "Valentin", ""]]}, {"id": "1404.6388", "submitter": "Pierre de Buyl", "authors": "Riccardo Murri", "title": "Performance of Python runtimes on a non-numeric scientific code", "comments": "Part of the Proceedings of the 6th European Conference on Python in\n  Science (EuroSciPy 2013), Pierre de Buyl and Nelle Varoquaux editors, (2014)", "journal-ref": null, "doi": null, "report-no": "euroscipy-proceedings2013-07", "categories": "cs.MS cs.PL", "license": "http://creativecommons.org/licenses/by/3.0/", "abstract": "  The Python library FatGHol FatGHoL used in Murri2012 to reckon the rational\nhomology of the moduli space of Riemann surfaces is an example of a non-numeric\nscientific code: most of the processing it does is generating graphs\n(represented by complex Python objects) and computing their isomorphisms (a\ntriple of Python lists; again a nested data structure). These operations are\nrepeated many times over: for example, the spaces and are triangulated by\n4'583'322 and 747'664 graphs, respectively. This is an opportunity for every\nPython runtime to prove its strength in optimization. The purpose of this\nexperiment was to assess the maturity of alternative Python runtimes, in terms\nof: compatibility with the language as implemented in CPython 2.7, and\nperformance speedup. This paper compares the results and experiences from\nrunning FatGHol with different Python runtimes: CPython 2.7.5, PyPy 2.1, Cython\n0.19, Numba 0.11, Nuitka 0.4.4 and Falcon.\n", "versions": [{"version": "v1", "created": "Fri, 25 Apr 2014 10:55:48 GMT"}, {"version": "v2", "created": "Tue, 29 Apr 2014 14:21:46 GMT"}], "update_date": "2014-04-30", "authors_parsed": [["Murri", "Riccardo", ""]]}]