[{"id": "1101.0011", "submitter": "Aditya Dua", "authors": "Aditya Dua and Nicholas Bambos", "title": "Packet Scheduling in Switches with Target Outflow Profiles", "comments": "33 pages, 10 figures", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.NI cs.MM cs.SY", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The problem of packet scheduling for traffic streams with target outflow\nprofiles traversing input queued switches is formulated in this paper. Target\noutflow profiles specify the desirable inter-departure times of packets leaving\nthe switch from each traffic stream. The goal of the switch scheduler is to\ndynamically select service configurations of the switch, so that actual outflow\nstreams (\"pulled\" through the switch) adhere to their desired target profiles\nas accurately as possible. Dynamic service controls (schedules) are developed\nto minimize deviation of actual outflow streams from their targets and suppress\nstream \"distortion\". Using appropriately selected subsets of service\nconfigurations of the switch, efficient schedules are designed, which deliver\nhigh performance at relatively low complexity. Some of these schedules are\nprovably shown to achieve 100% pull-throughput. Moreover, simulations\ndemonstrate that for even substantial contention of streams through the switch,\ndue to stringent/intense target outflow profiles, the proposed schedules\nachieve closely their target profiles and suppress stream distortion. The\nswitch model investigated here deviates from the classical switching paradigm.\nIn the latter, the goal of packet scheduling is primarily to \"push\" as much\ntraffic load through the switch as possible, while controlling delay to\ntraverse the switch and keeping congestion/backlogs from exploding. In the\nmodel presented here, however, the goal of packet scheduling is to \"pull\"\ntraffic streams through the switch, maintaining desirable (target) outflow\nprofiles.\n", "versions": [{"version": "v1", "created": "Wed, 29 Dec 2010 21:44:50 GMT"}], "update_date": "2011-01-04", "authors_parsed": [["Dua", "Aditya", ""], ["Bambos", "Nicholas", ""]]}, {"id": "1101.2219", "submitter": "Serguei Mokhov", "authors": "Elizaveta Eidelman and Serguei A. Mokhov", "title": "Alchymical Mirror: Real-time Interactive Sound- and Simple\n  Motion-Tracking Set of Jitter/Max/MSP Patches", "comments": "13 pages; a December 2005 report; video is not included into the\n  arXiv submission; Jitter language patches are not replicated in this version", "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.MM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  This document supplements an experimental Jitter / Max/MSP collection of\nimplementation patches that set its goal to simulate an alchemical process for\na person standing in front of a mirror-like screen while interacting with it.\nThe work involved takes some patience and has three stages to go through. At\nthe final stage the \"alchemist\" in the mirror wearing sharp-colored gloves (for\nmotion tracking) is to extract the final ultimate shining sparkle (FFT-based\nvisualization) in the nexus of the hands. The more the hands are apart, the\nlarge the sparkle should be. Moving hands around should make the sparkle\nfollow. To achieve the desired visual effect and the feedback mechanism, the\nJitter lattice-based intensional programming model is used to work on\n4-dimensional (A+R+G+B) video matrices and sound signals in order to apply some\nwell-known alchemical techniques to the video at real-time to get a mirror\neffect and accompanying transmutation and transformation stages of the video\nbased on the stability of the sound produced for some duration of time in\nreal-time. There is an accompanying video of the result with the interaction\nwith the tool and the corresponding programming patches.\n", "versions": [{"version": "v1", "created": "Wed, 5 Jan 2011 18:43:30 GMT"}], "update_date": "2011-01-13", "authors_parsed": [["Eidelman", "Elizaveta", ""], ["Mokhov", "Serguei A.", ""]]}, {"id": "1101.3979", "submitter": "Nikolaos Thomos", "authors": "Nicolae Cleju, Nikolaos Thomos, and Pascal Frossard", "title": "Selection of network coding nodes for minimal playback delay in\n  streaming overlays", "comments": "submitted to IEEE Transactions on Multimedia, January 18th 2011", "journal-ref": null, "doi": "10.1109/TMM.2011.2161448", "report-no": "EPFL report TR-LTS-2011-001", "categories": "cs.MM cs.IT cs.NI math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Network coding permits to deploy distributed packet delivery algorithms that\nlocally adapt to the network availability in media streaming applications.\nHowever, it may also increase delay and computational complexity if it is not\nimplemented efficiently. We address here the effective placement of nodes that\nimplement randomized network coding in overlay networks, so that the goodput is\nkept high while the delay for decoding stays small in streaming applications.\nWe first estimate the decoding delay at each client, which depends on the\ninnovative rate in the network. This estimation permits to identify the nodes\nthat have to perform coding for a reduced decoding delay. We then propose two\niterative algorithms for selecting the nodes that should perform network\ncoding. The first algorithm relies on the knowledge of the full network\nstatistics. The second algorithm uses only local network statistics at each\nnode. Simulation results show that large performance gains can be achieved with\nthe selection of only a few network coding nodes. Moreover, the second\nalgorithm performs very closely to the central estimation strategy, which\ndemonstrates that the network coding nodes can be selected efficiently in a\ndistributed manner. Our scheme shows large gains in terms of achieved\nthroughput, delay and video quality in realistic overlay networks when compared\nto methods that employ traditional streaming strategies as well as random\nnetwork nodes selection algorithms.\n", "versions": [{"version": "v1", "created": "Thu, 20 Jan 2011 17:50:26 GMT"}], "update_date": "2016-11-17", "authors_parsed": [["Cleju", "Nicolae", ""], ["Thomos", "Nikolaos", ""], ["Frossard", "Pascal", ""]]}, {"id": "1101.4789", "submitter": "Wojciech Mazurczyk", "authors": "Wojciech Fraczek, Wojciech Mazurczyk, Krzysztof Szczypiorski", "title": "Multi-Level Steganography: Improving Hidden Communication in Networks", "comments": "18 pages, 13 figures", "journal-ref": "Journal of Universal Computer Science (J. UCS), Vol. 18, No. 14,\n  pp. 1967-1986", "doi": "10.3217/jucs-018-14-1967", "report-no": null, "categories": "cs.CR cs.MM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  The paper presents Multi-Level Steganography (MLS), which defines a new\nconcept for hidden communication in telecommunication networks. In MLS, at\nleast two steganographic methods are utilised simultaneously, in such a way\nthat one method (called the upper-level) serves as a carrier for the second one\n(called the lower-level). Such a relationship between two (or more) information\nhiding solutions has several potential benefits. The most important is that the\nlower-level method steganographic bandwidth can be utilised to make the\nsteganogram unreadable even after the detection of the upper-level method:\ne.g., it can carry a cryptographic key that deciphers the steganogram carried\nby the upper-level one. It can also be used to provide the steganogram with\nintegrity. Another important benefit is that the lower-layer method may be used\nas a signalling channel in which to exchange information that affects the way\nthat the upper-level method functions, thus possibly making the steganographic\ncommunication harder to detect. The prototype of MLS for IP networks was also\ndeveloped, and the experimental results are included in this paper.\n", "versions": [{"version": "v1", "created": "Tue, 25 Jan 2011 12:26:00 GMT"}, {"version": "v2", "created": "Wed, 26 Jan 2011 20:46:59 GMT"}, {"version": "v3", "created": "Mon, 9 Apr 2012 20:35:38 GMT"}], "update_date": "2013-12-06", "authors_parsed": [["Fraczek", "Wojciech", ""], ["Mazurczyk", "Wojciech", ""], ["Szczypiorski", "Krzysztof", ""]]}, {"id": "1101.5127", "submitter": "Vishal Goyal", "authors": "J. Anitha, S. Immanuel Alex Pandian", "title": "A Color Image Digital Watermarking Scheme Based on SOFM", "comments": "International Journal of Computer Science Issues online at\n  http://www.ijcsi.org", "journal-ref": "IJCSI, Volume 7, Issue 5, September 2010", "doi": null, "report-no": null, "categories": "cs.MM cs.CR", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Digital watermarking technique has been presented and widely researched to\nsolve some important issues in the digital world, such as copyright protection,\ncopy protection and content authentication. Several robust watermarking schemes\nbased on vector quantization (VQ) have been presented. In this paper, we\npresent a new digital image watermarking method based on SOFM vector quantizer\nfor color images. This method utilizes the codebook partition technique in\nwhich the watermark bit is embedded into the selected VQ encoded block. The\nmain feature of this scheme is that the watermark exists both in VQ compressed\nimage and in the reconstructed image. The watermark extraction can be performed\nwithout the original image. The watermark is hidden inside the compressed\nimage, so much transmission time and storage space can be saved when the\ncompressed data are transmitted over the Internet. Simulation results\ndemonstrate that the proposed method has robustness against various image\nprocessing operations without sacrificing compression performance and the\ncomputational speed.\n", "versions": [{"version": "v1", "created": "Thu, 13 Jan 2011 15:01:12 GMT"}], "update_date": "2011-01-27", "authors_parsed": [["Anitha", "J.", ""], ["Pandian", "S. Immanuel Alex", ""]]}, {"id": "1101.5755", "submitter": "Yong Fang", "authors": "Yong Fang, Bormin Huang, and Jiaji Wu", "title": "2D Sparse Signal Recovery via 2D Orthogonal Matching Pursuit", "comments": null, "journal-ref": null, "doi": null, "report-no": null, "categories": "cs.IT cs.MM math.IT", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Recovery algorithms play a key role in compressive sampling (CS). Most of\ncurrent CS recovery algorithms are originally designed for one-dimensional (1D)\nsignal, while many practical signals are two-dimensional (2D). By utilizing 2D\nseparable sampling, 2D signal recovery problem can be converted into 1D signal\nrecovery problem so that ordinary 1D recovery algorithms, e.g. orthogonal\nmatching pursuit (OMP), can be applied directly. However, even with 2D\nseparable sampling, the memory usage and complexity at the decoder is still\nhigh. This paper develops a novel recovery algorithm called 2D-OMP, which is an\nextension of 1D-OMP. In the 2D-OMP, each atom in the dictionary is a matrix. At\neach iteration, the decoder projects the sample matrix onto 2D atoms to select\nthe best matched atom, and then renews the weights for all the already selected\natoms via the least squares. We show that 2D-OMP is in fact equivalent to\n1D-OMP, but it reduces recovery complexity and memory usage significantly.\nWhat's more important, by utilizing the same methodology used in this paper,\none can even obtain higher dimensional OMP (say 3D-OMP, etc.) with ease.\n", "versions": [{"version": "v1", "created": "Sun, 30 Jan 2011 10:02:06 GMT"}, {"version": "v2", "created": "Tue, 26 Apr 2011 12:09:57 GMT"}], "update_date": "2011-04-27", "authors_parsed": [["Fang", "Yong", ""], ["Huang", "Bormin", ""], ["Wu", "Jiaji", ""]]}, {"id": "1101.5791", "submitter": "Bela Genge", "authors": "Genge Bela and Haller Piroska", "title": "Using Planetlab to Implement Multicast at the Application Level", "comments": null, "journal-ref": "International Journal of Computer Networks & Communications\n  (IJCNC) Vol.3, No.1, January 2011", "doi": null, "report-no": null, "categories": "cs.DC cs.MM", "license": "http://arxiv.org/licenses/nonexclusive-distrib/1.0/", "abstract": "  Application-layer multicast implements the multicast functionality at the\napplication layer. The main goal of application-layer multicast is to construct\nand maintain efficient distribution structures between endhosts. In this paper\nwe focus on the implementation of an application-layer multicast network using\nPlanetLab. We observe that the total time required to measure network latency\nover TCP is influenced dramatically by the TCP connection time. We argue that\nend-host distribution is not only influenced by the quality of network links\nbut also by the time required to make connections between nodes. We provide\nseveral solutions to decrease the total end-host distribution time.\n", "versions": [{"version": "v1", "created": "Sun, 30 Jan 2011 17:49:58 GMT"}], "update_date": "2011-02-01", "authors_parsed": [["Bela", "Genge", ""], ["Piroska", "Haller", ""]]}]